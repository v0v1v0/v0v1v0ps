<div class="container">

<table style="width: 100%;"><tr>
<td>roundfixS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Round to Integer Keeping the Sum Fixed</h2>

<h3>Description</h3>

<p>Given a real numbers <code class="reqn">y_i</code> with the particular property that
<code class="reqn">\sum_i y_i</code> is integer, find <em>integer</em> numbers <code class="reqn">x_i</code>
which are close to <code class="reqn">y_i</code> (<code class="reqn">\left|x_i - y_i\right| &lt; 1 \forall i</code>), and have identical “marginal”
sum, <code>sum(x) == sum(y)</code>.
</p>
<p>As I found later, the problem is known as “Apportionment Problem”
and it is quite an old problem with several solution methods proposed
historically, but only in 1982, Balinski and Young proved that there
is no method that fulfills three natural desiderata.
</p>
<p>Note that the (first) three methods currently available here were all
(re?)-invented by M.Maechler, without any knowledge of the
litterature.  At the time of writing, I have not even checked to which
(if any) of the historical methods they match.
</p>


<h3>Usage</h3>

<pre><code class="language-R">roundfixS(x, method = c("offset-round", "round+fix", "1greedy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector which <b>must</b> sum to an integer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string specifying the algorithm to be used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Without hindsight, it may be surprising that all three methods give
identical results (in all situations and simulations considered),
notably that the idea of ‘mass shifting’ employed in the
iterative <code>"1greedy"</code> algorithm seems equivalent to the much simpler
idea used in <code>"offset-round"</code>.
</p>
<p>I am pretty sure that these algorithms solve the <code class="reqn">L_p</code>
optimization problem, <code class="reqn">\min_x \left\|y - x\right\|_p</code>,
typically for all <code class="reqn">p \in [1,\infty]</code>
<em>simultaneously</em>, but have not bothered to find a formal proof.
</p>


<h3>Value</h3>

<p>a numeric vector, say <code>r</code>, of the same length as <code>x</code>, but
with integer values and fulfulling <code>sum(r) == sum(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, November 2007</p>


<h3>References</h3>

<p>Michel Balinski and H. Peyton Young (1982)
<b>Fair Representation: Meeting the Ideal of One Man, One Vote</b>;
</p>
<p><a href="https://en.wikipedia.org/wiki/Apportionment_paradox">https://en.wikipedia.org/wiki/Apportionment_paradox</a>
</p>
<p><a href="https://www.ams.org/samplings/feature-column/fcarc-apportionii3">https://www.ams.org/samplings/feature-column/fcarc-apportionii3</a>
</p>


<h3>See Also</h3>

<p><code>round</code> etc
</p>


<h3>Examples</h3>

<pre><code class="language-R">## trivial example
kk &lt;- c(0,1,7)
stopifnot(identical(kk, roundfixS(kk))) # failed at some point

x &lt;- c(-1.4, -1, 0.244, 0.493, 1.222, 1.222, 2, 2, 2.2, 2.444, 3.625, 3.95)
sum(x) # an integer
r &lt;- roundfixS(x)
stopifnot(all.equal(sum(r), sum(x)))
m &lt;- cbind(x=x, `r2i(x)` = r, resid = x - r, `|res|` = abs(x-r))
rbind(m, c(colSums(m[,1:2]), 0, sum(abs(m[,"|res|"]))))

chk &lt;- function(y) {
  cat("sum(y) =", format(S &lt;- sum(y)),"\n")
  r2  &lt;- roundfixS(y, method="offset")
  r2. &lt;- roundfixS(y, method="round")
  r2_ &lt;- roundfixS(y, method="1g")
  stopifnot(all.equal(sum(r2 ), S),
            all.equal(sum(r2.), S),
            all.equal(sum(r2_), S))
  all(r2 == r2. &amp; r2. == r2_) # TRUE if all give the same result
}

makeIntSum &lt;- function(y) {
   n &lt;- length(y)
   y[n] &lt;- ceiling(y[n]) - (sum(y[-n]) %% 1)
   y
}
set.seed(11)
y &lt;- makeIntSum(rnorm(100))
chk(y)

## nastier example:
set.seed(7)
y &lt;- makeIntSum(rpois(100, 10) + c(runif(75, min= 0, max=.2),
                                   runif(25, min=.5, max=.9)))
chk(y)

## Not run: 
for(i in 1:1000)
    stopifnot(chk(makeIntSum(rpois(100, 10) +
                             c(runif(75, min= 0, max=.2),
                               runif(25, min=.5, max=.9)))))

## End(Not run)
</code></pre>


</div>