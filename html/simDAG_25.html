<div class="container">

<table style="width: 100%;"><tr>
<td>node_time_to_event</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulate a Time-to-Event Node in Discrete-Time Simulation
</h2>

<h3>Description</h3>

<p>This node essentially models a dichotomous time-dependent variable for which the time of the event will be important for later usage. It adds two columns to <code>data</code>: <code>name_event</code> (whether the person currently has an event) and <code>name_time</code> (the time at which the current event started). Past events are stored in a list. Can only be used inside of the <code>sim_discrete_time</code> function, not outside of it. See details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_time_to_event(data, parents, sim_time, name,
                   prob_fun, ..., event_duration=1,
                   immunity_duration=event_duration,
                   time_since_last=FALSE, event_count=FALSE,
                   save_past_events=TRUE, check_inputs=TRUE,
                   envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A <code>data.table</code> containing all columns specified by <code>parents</code>. Similar objects such as <code>data.frame</code>s are not supported.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parents</code></td>
<td>

<p>A character vector specifying the names of the parents that this particular child node has. Those child nodes should be valid column names in <code>data</code>. Because the state of this variable is by definition dependent on its previous states, the columns produced by this function will automatically be considered its parents without the user having to manually specify this.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim_time</code></td>
<td>

<p>The current time of the simulation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>

<p>The name of the node. This will be used as prefix before the <code>_event</code>, <code>_time</code> columns. If the <code>time_since_last</code> or <code>event_count</code> arguments are set to <code>TRUE</code>, this will also be used as prefix for those respective columns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob_fun</code></td>
<td>

<p>A function that returns a numeric vector of size <code>nrow(data)</code> containing only numbers between 0 and 1. These numbers specify the person-specific probability of experiencing the event modeled by this node at the particular point in time of the simulation. The corresponding event will be generated internally using the <code>rbernoulli</code> function. The function needs to have a named argument called <code>data</code>. If the function has an argument named <code>sim_time</code>, the current simulation time will also be passed to this function automatically, allowing time-dependent probabilities to be generated. Alternatively this argument can be set to a single number (between 0 and 1), resulting in a fixed probability of occurrence for every simulated individual at every point in time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>An arbitrary amount of additional named arguments passed to <code>prob_fun</code>. Ignore this if you do not want to pass any arguments. Also ignored if <code>prob_fun</code> is a single number.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event_duration</code></td>
<td>

<p>A single number &gt; 0 specifying how long the event should last. The point in time at which an event occurs also counts into this duration. For example, if an event occurs at <code class="reqn">t = 2</code> and it has a duration of 3, the event will be set to <code>TRUE</code> on <code class="reqn">t \in \{2, 3, 4\}</code>. Therefore, all events must have a duration of at least 1 unit (otherwise they never happened).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>immunity_duration</code></td>
<td>

<p>A single number &gt;= <code>event_duration</code> specifying how long the person should be immune to the event after it is over. The count internally starts when the event starts, so in order to use an immunity duration of 10 time units after the event is over <code>event_duration + 10</code> should be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_since_last</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default), indicating whether an additional column should be generated that tracks the number of time units since the individual had its last event onset. For example, if the individual experienced a single event at <code class="reqn">t = 10</code>, this column would be <code>NA</code> before time 10, 0 at time 10 and increased by 1 at each point in time. If another event happens, the time is set to 0 again. The column is named <code>paste0(name, "_time_since_last")</code>. The difference to the column ending with <code>"_time"</code> is that this column will not be set to <code>NA</code> again if the <code>immunity_duration</code> is over. It keeps counting until the end of the simulation, which may be useful when constructing event-time dependent probability functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event_count</code></td>
<td>

<p>Either <code>TRUE</code> or <code>FALSE</code> (default), indicating whether an additional column should be generated that tracks the number of events the individual has already experienced. This column is 0 for all individuals at t = 0. Each time a new event occurs, the counter is increased by one. Note that only new events increase this counter. For example, an individual with an event at t = 10 that has an <code>event_duration</code> of 15 will have a value of 0 before t = 10, and will have a value of 1 at t = 10 and afterwards. The column will be named <code>paste0(name, "_event_count")</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_past_events</code></td>
<td>

<p>When the event modeled using this node is recurrent (<code>immunity_duration &lt; Inf &amp; event_duration &lt; Inf</code>), the same person may experience multiple events over the course of the simulation. Those are generally stored in the <code>tte_past_events</code> list which is included in the output of the <code>sim_discrete_time</code> function. This extends the runtime and increases RAM usage, so if you are not interested in the timing of previous events or if you are using <code>save_states="all"</code> this functionality can be turned off by setting this argument to <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_inputs</code></td>
<td>

<p>Whether to perform plausibility checks for the user input or not. Is set to <code>TRUE</code> by default, but can be set to <code>FALSE</code> in order to speed things up when using this function in a simulation study or something similar.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>

<p>Only used internally to efficiently store the past event times. Cannot be used by the user.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When performing discrete-time simulation using the <code>sim_discrete_time</code> function, the standard node functions implemented in this package are usually not sufficient because they don't capture the time-dependent nature of some very interesting variables. Often, the variable that should be modelled has some probability of occurring at each point in time. Once it does occur, it has some kind of influence on other variables for a period of time until it goes back to normal (or doesn't). This could be a car crash, a surgery, a vaccination etc. The <code>time_to_event</code> node function can be used to model these kinds of nodes in a fairly straightforward fashion.
</p>
<p><strong><em>How it Works</em></strong>:
</p>
<p>At <code class="reqn">t = 1</code>, this node will be initialized for the first time. It adds two columns to the data: <code>name_event</code> (whether the person currently has an event) and <code>name_time</code> (the time at which the current event started) where <code>name</code> is the name of the node. Additionally, it adds a list with <code>max_t</code> entries to the <code>tte_past_events</code> list returned by the <code>sim_discrete_time</code> function, which records which individuals experienced a new event at each point in time.
</p>
<p>In a nutshell, it simply models the occurrence of some event by calculating the probability of occurrence at <code class="reqn">t</code> and drawing a single bernoulli trial from this probability. If the trial is a "success", the corresponding event column will be set to <code>TRUE</code>, the time column will be set to the current simulation time <code class="reqn">t</code> and the column storing the past event times will receive an entry.
</p>
<p>The <code>_event</code> column will stay <code>TRUE</code> until the event is over. The duration for that is controlled by the <code>event_duration</code> parameter. When modeling terminal events such as death, one can simply set this parameter to <code>Inf</code>, making the event eternal. In many cases it will also be necessary to implement some kind of immunity after the event, which can be done using the <code>immunity_duration</code> argument. This effectively sets the probability of another occurrence of the event to 0 in the next <code>immunity_duration</code> time steps. During the immunity duration, the event may be <code>TRUE</code> (if the event is still ongoing) or <code>FALSE</code> (if the <code>event_duration</code> has already passed). The <code>_time</code> column is similarly set to the time of occurrence of the event and reset to <code>NA</code> when the <code>immunity_duration</code> is over.
</p>
<p>The probability of occurrence is calculated using the function provided by the user using the <code>prob_fun</code> argument. This can be an arbitrary complex function. The only requirement is that it takes <code>data</code> as a first argument. The columns defined by the <code>parents</code> argument will be passed to this argument automatically. If it has an argument called <code>sim_time</code>, the current time of the simulation will automatically be passed to it as well. Any further arguments can be passed using the <code>...</code> syntax. A simple example could be a logistic regression node, in which the probability is calculated as an additive linear combination of the columns defined by <code>parents</code>. A more complex function could include simulation-time dependent effects, further effects dependent on past event times etc. Examples can be found below and in the vignettes.
</p>
<p><strong><em>How it is Used</em></strong>:
</p>
<p>This function should never be called directly by the user. Instead, the user should define a DAG object using the <code>empty_dag</code> and <code>node_td</code> functions and set the <code>type</code> argument inside of a <code>node_td</code> call to <code>"time_to_event"</code>. This DAG can be passed to the <code>sim_discrete_time</code> function to generate the desired data. Many examples and more explanations are given below and in the vignettes of this package.
</p>
<p><strong><em>What can be done with it</em></strong>:
</p>
<p>This type of node naturally supports the implementation of terminal and recurrent events that may be influenced by pretty much anything. By specifying the <code>parents</code> and <code>prob_fun</code> arguments correctly, it is possible to create an event type that is dependent on past events of itself or other time-to-event variables and other variables in general. The user can include any amount of these nodes in their simulation. It may also be used to simulate any kind of binary time-dependent variable that one would usually not associate with the name "event" as well. It is very flexible, but it does require the user to do some coding by themselves (e.g. creating a suitable function for the <code>prob_fun</code> argument).
</p>
<p><strong><em>What can't be done with it</em></strong>:
</p>
<p>Currently this function only allows binary events. Categorical event types may be implemented using the <code>node_competing_events</code> function, which works in a very similar fashion.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> containing at least two columns with updated values of the node.
</p>


<h3>Note</h3>

<p>This function cannot be called outside of the <code>sim_discrete_time</code> function. It only makes sense to use it as a type in a <code>node_td</code> function call, as described in the documentation and vignettes.
</p>


<h3>Author(s)</h3>

<p>Robin Denz, Katharina Meiszl
</p>


<h3>See Also</h3>

<p><code>empty_dag</code>, <code>node_td</code>, <code>sim_discrete_time</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(simDAG)

## a simple terminal time-to-event node, with a constant probability of
## occurrence, independent of any other variable
dag &lt;- empty_dag() +
  node_td("death", type="time_to_event", prob_fun=0.0001,
          event_duration=Inf)

## a simple recurrent time-to-event node with a constant probability of
## occurrence, independent of any other variable
dag &lt;- empty_dag() +
  node_td("car_crash", type="time_to_event", prob_fun=0.001, event_duration=1)

## a time-to-event node with a time-dependent probability function that
## has an additional argument
prob_car_crash &lt;- function(data, sim_time, base_p) {
  return(base_p + sim_time * 0.0001)
}

dag &lt;- empty_dag() +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          event_duration=1, base_p=0.0001)

## a time-to-event node with a probability function dependent on a
## time-fixed variable
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex")

## a little more complex car crash simulation, where the probability for
## a car crash is dependent on the sex, and the probability of death is
## highly increased for 3 days after a car crash happened
prob_car_crash &lt;- function(data) {
  ifelse(data$sex==1, 0.001, 0.01)
}

prob_death &lt;- function(data) {
  ifelse(data$car_crash_event, 0.1, 0.0001)
}

dag &lt;- empty_dag() +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("car_crash", type="time_to_event", prob_fun=prob_car_crash,
          parents="sex") +
  node_td("death", type="time_to_event", prob_fun=prob_death,
          parents="car_crash_event")

# use the sim_discrete_time function to simulate data from one of these DAGs:
sim &lt;- sim_discrete_time(dag, n_sim=20, max_t=500)

## more examples can be found in the vignettes of this package
</code></pre>


</div>