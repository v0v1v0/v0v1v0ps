<div class="container">

<table style="width: 100%;"><tr>
<td>TransferData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transfer data</h2>

<h3>Description</h3>

<p>Transfer categorical or continuous data across single-cell datasets. For
transferring categorical information, pass a vector from the reference
dataset (e.g. <code>refdata = reference$celltype</code>). For transferring
continuous information, pass a matrix from the reference dataset (e.g.
<code>refdata = GetAssayData(reference[['RNA']])</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">TransferData(
  anchorset,
  refdata,
  reference = NULL,
  query = NULL,
  query.assay = NULL,
  weight.reduction = "pcaproject",
  l2.norm = FALSE,
  dims = NULL,
  k.weight = 50,
  sd.weight = 1,
  eps = 0,
  n.trees = 50,
  verbose = TRUE,
  slot = "data",
  prediction.assay = FALSE,
  only.weights = FALSE,
  store.weights = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>anchorset</code></td>
<td>
<p>An <code>AnchorSet</code> object generated by
<code>FindTransferAnchors</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refdata</code></td>
<td>
<p>Data to transfer. This can be specified in one of two ways:
</p>

<ul>
<li>
<p>The reference data itself as either a vector where the names
correspond to the reference cells, or a matrix, where the column names
correspond to the reference cells.
</p>
</li>
<li>
<p>The name of the metadata field or assay from the reference object
provided. This requires the reference parameter to be specified. If pulling
assay data in this manner, it will pull the data from the data slot. To
transfer data from other slots, please pull the data explicitly with
<code>GetAssayData</code> and provide that matrix here.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>Reference object from which to pull data to transfer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>Query object into which the data will be transferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.reduction</code></td>
<td>
<p>Dimensional reduction to use for the weighting
anchors. Options are:
</p>

<ul>
<li>
<p>pcaproject: Use the projected PCA used for anchor building
</p>
</li>
<li>
<p>lsiproject: Use the projected LSI used for anchor building
</p>
</li>
<li>
<p>pca: Use an internal PCA on the query only
</p>
</li>
<li>
<p>cca: Use the CCA used for anchor building
</p>
</li>
<li>
<p>custom DimReduc: User provided <code>DimReduc</code> object
computed on the query cells
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.norm</code></td>
<td>
<p>Perform L2 normalization on the cell embeddings after
dimensional reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Set of dimensions to use in the anchor weighting procedure. If
NULL, the same dimensions that were used to find anchors will be used for
weighting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code>RANN</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slot</code></td>
<td>
<p>Slot to store the imputed data. Must be either "data" (default)
or "counts"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction.assay</code></td>
<td>
<p>Return an <code>Assay</code> object with the prediction
scores for each class stored in the <code>data</code> slot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.weights</code></td>
<td>
<p>Only return weights matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.weights</code></td>
<td>
<p>Optionally store the weights matrix used for predictions
in the returned query object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>For both transferring discrete labels and also feature imputation, we first
compute the weights matrix.
</p>

<ul><li>
<p>Construct a weights matrix that defines the association between each
query cell and each anchor. These weights are computed as 1 - the distance
between the query cell and the anchor divided by the distance of the query
cell to the <code>k.weight</code>th anchor multiplied by the anchor score
computed in <code>FindIntegrationAnchors</code>. We then apply a Gaussian
kernel width a bandwidth defined by <code>sd.weight</code> and normalize across
all <code>k.weight</code> anchors.
</p>
</li></ul>
<p>The main difference between label transfer (classification) and feature
imputation is what gets multiplied by the weights matrix. For label transfer,
we perform the following steps:
</p>

<ul>
<li>
<p>Create a binary classification matrix, the rows corresponding to each
possible class and the columns corresponding to the anchors. If the
reference cell in the anchor pair is a member of a certain class, that
matrix entry is filled with a 1, otherwise 0.
</p>
</li>
<li>
<p>Multiply this classification matrix by the transpose of weights
matrix to compute a prediction score for each class for each cell in the
query dataset.
</p>
</li>
</ul>
<p>For feature imputation, we perform the following step:
</p>

<ul><li>
<p>Multiply the expression matrix for the reference anchor cells by the
weights matrix. This returns a predicted expression matrix for the
specified features for each cell in the query dataset.
</p>
</li></ul>
<h3>Value</h3>

<p>If <code>query</code> is not provided, for the categorical data in <code>refdata</code>,
returns a data.frame with label predictions. If <code>refdata</code> is a matrix,
returns an Assay object where the imputed data has been stored in the
provided slot.
</p>
<p>If <code>query</code> is provided, a modified query object is returned. For
the categorical data in refdata, prediction scores are stored as Assays
(prediction.score.NAME) and two additional metadata fields: predicted.NAME
and predicted.NAME.score which contain the class prediction and the score for
that predicted class. For continuous data, an Assay called NAME is returned.
NAME here corresponds to the name of the element in the refdata list.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("pbmc3k")

# for demonstration, split the object into reference and query
pbmc.reference &lt;- pbmc3k[, 1:1350]
pbmc.query &lt;- pbmc3k[, 1351:2700]

# perform standard preprocessing on each object
pbmc.reference &lt;- NormalizeData(pbmc.reference)
pbmc.reference &lt;- FindVariableFeatures(pbmc.reference)
pbmc.reference &lt;- ScaleData(pbmc.reference)

pbmc.query &lt;- NormalizeData(pbmc.query)
pbmc.query &lt;- FindVariableFeatures(pbmc.query)
pbmc.query &lt;- ScaleData(pbmc.query)

# find anchors
anchors &lt;- FindTransferAnchors(reference = pbmc.reference, query = pbmc.query)

# transfer labels
predictions &lt;- TransferData(anchorset = anchors, refdata = pbmc.reference$seurat_annotations)
pbmc.query &lt;- AddMetaData(object = pbmc.query, metadata = predictions)

## End(Not run)

</code></pre>


</div>