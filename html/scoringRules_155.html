<div class="container">

<table style="width: 100%;"><tr>
<td>scores_sample_multiv_weighted</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted Multivariate Scoring Rules for Simulated Forecast Distributions</h2>

<h3>Description</h3>

<p>Compute weighted versions of multivariate scores <code class="reqn">S(y, dat)</code>, where <code class="reqn">S</code> is a
proper scoring rule, <code class="reqn">y</code> is a d-dimensional realization vector and 
<code class="reqn">dat</code> is a simulated sample of multivariate forecasts. The weighted scores allow 
particular outcomes of interest to be emphasised during forecast evaluation.
Threshold-weighted and outcome-weighted versions of three multivariate scores are 
available: the energy score, a score based on a Gaussian kernel (mmds_sample, 
see details below) and the variogram score of order <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">twes_sample(y, dat, a = -Inf, b = Inf, chain_func = NULL, w = NULL)

owes_sample(y, dat, a = -Inf, b = Inf, weight_func = NULL, w = NULL)

twmmds_sample(y, dat, a = -Inf, b = Inf, chain_func = NULL, w = NULL)

owmmds_sample(y, dat, a = -Inf, b = Inf, weight_func = NULL, w = NULL)

twvs_sample(
  y,
  dat,
  a = -Inf,
  b = Inf,
  chain_func = NULL,
  w = NULL,
  w_vs = NULL,
  p = 0.5
)

owvs_sample(
  y,
  dat,
  a = -Inf,
  b = Inf,
  weight_func = NULL,
  w = NULL,
  w_vs = NULL,
  p = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>realized values (numeric vector of length d).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>numeric matrix of data
(columns are simulation draws from multivariate forecast distribution).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>numeric vector of of length d containing lower bounds for the indicator 
weight function <code>w(z) = 1{a[1] &lt; z[1] &lt; b[1], ..., a[d] &lt; z[d] &lt; b[d]}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric vector of of length d containing upper bounds for the indicator 
weight function <code>w(z) = 1{a[1] &lt; z[1] &lt; b[1], ..., a[d] &lt; z[d] &lt; b[d]}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain_func</code></td>
<td>
<p>function used to target particular outcomes in the threshold-weighted scores; 
the default corresponds to the weight function above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>numeric vector of weights for forecast draws (length equal to number of columns of <code>dat</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_func</code></td>
<td>
<p>function used to target particular outcomes in the outcome-weighted scores; 
the default corresponds to the weight function above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_vs</code></td>
<td>
<p>numeric matrix of weights for <code>dat</code> used in the variogram
score. This matrix must be square and symmetric, with all elements being non-negative.
If no weights are specified, constant weights (with all elements of <code>w_vs</code> 
equal to one) are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>order of variogram score. Standard choices include <code class="reqn">p = 1</code> and
<code class="reqn">p = 0.5</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the input matrix <code>dat</code> each column is expected to represent a sample
from the multivariate forecast distribution, the number of rows of <code>dat</code>
thus has to match the length of the observation vector <code>y</code>, and the
number of columns of <code>dat</code> is the number of simulated samples.
</p>
<p>The threshold-weighted scores (<code>twes_sample</code>, <code>twmmds_sample</code>, 
<code>twvs_sample</code>) transform <code>y</code> and <code>dat</code> using the chaining
function <code>chain_func</code> and then call the relevant unweighted score function
(<code>es_sample</code>, <code>mmds_sample</code>, <code>vs_sample</code>). 
The outcome-weighted scores (<code>owes_sample</code>, <code>owmmds_sample</code>, 
<code>owvs_sample</code>) weight <code>y</code> and <code>dat</code> using the weight
function <code>weight_func</code> and then call the relevant unweighted score function
(<code>es_sample</code>, <code>mmds_sample</code>, <code>vs_sample</code>). 
See the documentation for e.g. <code>es_sample</code> for further details.
</p>
<p>The default weight function used in the weighted scores is 
<code>w(z) = 1{a[1] &lt; z[1] &lt; b[1], ..., a[d] &lt; z[d] &lt; b[d]}</code>, which is equal to one 
if <code>z</code> is in the 'box' defined by the vectors <code>a</code> and <code>b</code>, and 
is equal to zero otherwise. This weight function emphasises outcomes between 
the vectors <code>a</code> and <code>b</code>, and is commonly used in practical applications 
when interest is on values above a threshold along multiple dimensions.
</p>
<p>Alternative weight functions can also be employed using the <code>chain_func</code> 
and <code>weight_func</code> arguments. Computation of the threshold-weighted scores
for samples from a predictive distribution requires a chaining function rather 
than a weight function. This is why a chaining function is an input for 
<code>twes_sample</code>, <code>twmmds_sample</code>, and <code>twvs_sample</code>,
whereas a weight function is an input for <code>owes_sample</code>, 
<code>owmmds_sample</code>, and <code>owvs_sample</code>. 
</p>
<p>The <code>chain_func</code> and <code>weight_func</code> arguments are functions that will 
be applied to the elements in <code>y</code> and <code>dat</code>. 
<code>weight_func</code> must input a numeric vector of length d, and output a single 
numeric value. An error will be returned if <code>weight_func</code> returns negative values.
<code>chain_func</code> must input a numeric vector of length d, and return a numeric
vector of length d.
</p>
<p>If no custom argument is given for <code>a</code>, <code>b</code>, <code>chain_func</code> or 
<code>weight_func</code>, then all weighted scores are equivalent to the standard 
unweighted scores <code>es_sample</code>, <code>mmds_sample</code>, and
<code>vs_sample</code>.
</p>
<p>The <code>w</code> argument is also present in the unweighted scores.
<code>w</code> is used to weight the draws from the predictive distribution, and does 
not weight particular outcomes within the weighted scoring rules. This should not be
confused with the <code>weight_func</code> argument.
</p>


<h3>Value</h3>

<p>Value of the score. <em>A lower score indicates a better forecast.</em>
</p>


<h3>Author(s)</h3>

<p>Sam Allen
</p>


<h3>References</h3>

<p>Allen, S. (2024): 
‘Weighted scoringRules: Emphasising Particular Outcomes when Evaluating Probabilistic Forecasts’, 
<em>Journal of Statistical Software</em>.
<a href="https://doi.org/10.18637/jss.v110.i08">doi:10.18637/jss.v110.i08</a>
</p>
<p><em>Threshold-weighted scores</em>
</p>
<p>Allen, S., Ginsbourger, D. and J. Ziegel (2023): 
‘Evaluating forecasts for high-impact events using transformed kernel scores’, 
<em>SIAM/ASA Journal on Uncertainty Quantification</em> 11, 906-940.
<a href="https://doi.org/10.1137/22M1532184">doi:10.1137/22M1532184</a>
</p>
<p><em>Outcome-weighted scores:</em>
</p>
<p>Holzmann, H. and B. Klar (2017):
‘Focusing on regions of interest in forecast evaluation’,
<em>Annals of Applied Statistics</em> 11, 2404-2431. 
<a href="https://doi.org/10.1214/17-AOAS1088">doi:10.1214/17-AOAS1088</a>
</p>


<h3>See Also</h3>

<p>scores_sample_multiv for standard (unweighted) scores based on simulated multivariate forecast distributions. scores_sample_univ_weighted for weighted scores based on simulated univariate forecast distributions
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
d &lt;- 3  # number of dimensions
m &lt;- 10  # number of samples from multivariate forecast distribution

# parameters for multivariate normal example
mu0 &lt;- rep(0, d)
mu &lt;- rep(1, d)
S0 &lt;- S &lt;- diag(d)
S0[S0==0] &lt;- 0.2
S[S==0] &lt;- 0.1

# generate samples from multivariate normal distributions
obs &lt;- drop(mu0 + rnorm(d) %*% chol(S0))
sample_fc &lt;- replicate(m, drop(mu + rnorm(d) %*% chol(S)))

# if no additional parameters are provided, the weighted scores are the same as
# the unweighted scores:
es_sample(y = obs, dat = sample_fc) # energy score
twes_sample(y = obs, dat = sample_fc) # threshold-weighted energy score
owes_sample(y = obs, dat = sample_fc) # outcome-weighted energy score

mmds_sample(y = obs, dat = sample_fc) # Gaussian kernel score
twmmds_sample(y = obs, dat = sample_fc) # threshold-weighted Gaussian kernel score
owmmds_sample(y = obs, dat = sample_fc) # outcome-weighted Gaussian kernel score

vs_sample(y = obs, dat = sample_fc) # variogram score
twvs_sample(y = obs, dat = sample_fc) # threshold-weighted variogram score
owvs_sample(y = obs, dat = sample_fc) # outcome-weighted variogram score


# the outcome-weighted scores are undefined if none of dat are between a and b
# this can lead to NaNs in some of the scores calculated below, particularly
# if the thresholds are extreme, or if the dimension is large


# emphasise outcomes greater than 0 in all dimensions
twes_sample(y = obs, dat = sample_fc, a = 0)
owes_sample(y = obs, dat = sample_fc, a = 0)
twmmds_sample(y = obs, dat = sample_fc, a = 0)
owmmds_sample(y = obs, dat = sample_fc, a = 0)
twvs_sample(y = obs, dat = sample_fc, a = 0)
owvs_sample(y = obs, dat = sample_fc, a = 0)

# this can also be done more explicitly by setting a = rep(0, d)
twes_sample(y = obs, dat = sample_fc, a = rep(0, d))
owes_sample(y = obs, dat = sample_fc, a = rep(0, d))

# a should also be specified fully if the threshold changes in each dimension
a &lt;- rnorm(d)
twes_sample(y = obs, dat = sample_fc, a = a)
owes_sample(y = obs, dat = sample_fc, a = a)
twmmds_sample(y = obs, dat = sample_fc, a = a)
owmmds_sample(y = obs, dat = sample_fc, a = a)
twvs_sample(y = obs, dat = sample_fc, a = a)
owvs_sample(y = obs, dat = sample_fc, a = a)

# emphasise outcomes smaller than 0 in all dimensions
twes_sample(y = obs, dat = sample_fc, b = 0)
owes_sample(y = obs, dat = sample_fc, b = 0)
twmmds_sample(y = obs, dat = sample_fc, b = 0)
owmmds_sample(y = obs, dat = sample_fc, b = 0)
twvs_sample(y = obs, dat = sample_fc, b = 0)
owvs_sample(y = obs, dat = sample_fc, b = 0)

# emphasise outcomes between (-1, -1, -1) and (1, 1, 1)
twes_sample(y = obs, dat = sample_fc, a = -1, b = 1)
owes_sample(y = obs, dat = sample_fc, a = -1, b = 1)
twmmds_sample(y = obs, dat = sample_fc, a = -1, b = 1)
owmmds_sample(y = obs, dat = sample_fc, a = -1, b = 1)
twvs_sample(y = obs, dat = sample_fc, a = -1, b = 1)
owvs_sample(y = obs, dat = sample_fc, a = -1, b = 1)

# emphasise outcomes between (-2, 0, -1) and (0, 2, 1)
a &lt;- c(-2, 0, -1)
b &lt;- c(0, 2, 1)
twes_sample(y = obs, dat = sample_fc, a = a, b = b)
owes_sample(y = obs, dat = sample_fc, a = a, b = b)
twmmds_sample(y = obs, dat = sample_fc, a = a, b = b)
owmmds_sample(y = obs, dat = sample_fc, a = a, b = b)
twvs_sample(y = obs, dat = sample_fc, a = a, b = b)
owvs_sample(y = obs, dat = sample_fc, a = a, b = b)


# values of a cannot be larger than the corresponding values of b
twes_sample(y = obs, dat = sample_fc, a = c(0, 0, 0), b = c(0, 0, 1))
twes_sample(y = obs, dat = sample_fc, a = c(0, 0, 0), b = c(0, 0, 0)) # error
twes_sample(y = obs, dat = sample_fc, a = c(0, 0, 0), b = c(1, 1, -1)) # error

# a and b must be of the same length (and of the same length as y)
owmmds_sample(y = obs, dat = sample_fc, a = c(0, 0), b = 1) # error
owmmds_sample(y = obs, dat = sample_fc, a = c(0, 0), b = c(1, 1)) # error


# alternative custom weight and chaining functions can also be used

# Example 1: the default weight function with an alternative chaining function
# the default weight function is 
# w(z) = 1{a[1] &lt; z[1] &lt; b[1], ..., a[d] &lt; z[d] &lt; b[d]}
# the default chaining function is 
# v(z) = (min(max(z[1], a[1]), b[1]), ..., min(max(z[d], a[d]), b[d]))
a &lt;- -2
b &lt;- 2
weight_func &lt;- function(x) as.numeric(all(x &gt; a &amp; x &lt; b))
chain_func &lt;- function(x) pmin(pmax(x, a), b)
owes_sample(y = obs, dat = sample_fc, a = a, b = b)
owes_sample(y = obs, dat = sample_fc, weight_func = weight_func)
twes_sample(y = obs, dat = sample_fc, a = a, b = b)
twes_sample(y = obs, dat = sample_fc, chain_func = chain_func)

# consider an alternative chaining function: v(z) = z if w(z) = 1, else v(z) = 0
chain_func &lt;- function(x) x*weight_func(x)
twes_sample(y = obs, dat = sample_fc, chain_func = chain_func)


# Example 2: a mulivariate Gaussian weight function with mean vector mu and 
# diagonal covariance matrix sigma
mu &lt;- rep(0, d)
sigma &lt;- diag(d)
weight_func &lt;- function(x) prod(pnorm(x, mu, diag(sigma)))
# the corresponding chaining function is
chain_func &lt;- function(x){
 (x - mu)*pnorm(x, mu, diag(sigma)) + (diag(sigma)^2)*dnorm(x, mu, diag(sigma))
}

owvs_sample(y = obs, dat = sample_fc, a = mu)
owvs_sample(y = obs, dat = sample_fc, weight_func = weight_func)
twvs_sample(y = obs, dat = sample_fc, a = mu)
twvs_sample(y = obs, dat = sample_fc, chain_func = chain_func)

## End(Not run)

</code></pre>


</div>