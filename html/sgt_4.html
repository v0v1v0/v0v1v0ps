<div class="container">

<table style="width: 100%;"><tr>
<td>sgtmle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum Likelihood Estimation with the Skewed Generalized T Distribution</h2>

<h3>Description</h3>

<p>This function allows data to be fit to the skewed generalized t distribution using maximum likelihood estimation. This function uses the <code>maxLik</code> package to perform its estimations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgt.mle(X.f, mu.f = mu ~ mu, sigma.f = sigma ~ sigma, 
lambda.f = lambda ~ lambda, p.f = p ~ p, q.f = q ~ q, 
data = parent.frame(), start, subset, 
method = c("Nelder-Mead", "BFGS"), itnmax = NULL,
hessian.method="Richardson", 
gradient.method="Richardson",
mean.cent = TRUE, var.adj = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X.f</code></td>
<td>
<p>A formula specifying the data, or the function of the data with parameters, that should be used in the maximisation procedure. <code>X</code> should be on the left-hand side and the right-hand side should be the data or function of the data that should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.f, sigma.f, lambda.f, p.f, q.f</code></td>
<td>
<p>formulas including variables and
parameters that specify the functional form of the parameters in the skewed generalized t log-likelihood function. <code>mu</code>, <code>sigma</code>, <code>lambda</code>, <code>p</code>, and <code>q</code> should be on the left-hand side of these formulas respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in <code>formula</code> and <code>weights</code>.  Can also be a list or an environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a named list or named numeric vector of starting estimates for every parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A list of the optimization methods to be used, which is passed directly to the <code>optimx</code> function in the <code>optimx</code> package. See <code>?optimx</code> for a list of methods that can be used.
Note that the method that achieves the highest log-likelihood value is the method that is printed and reported.
The default method is to use both "Nelder-Mead" and the "BFGS" methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itnmax</code></td>
<td>
<p>If provided as a vector of the same length as <code>method</code>, gives the maximum number of iterations or function values for the corresponding method. If a single number is provided, this will be used for all methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian.method</code></td>
<td>
<p>method used to calculate the hessian of the final estimates, either "Richardson" or "complex". This method is passed to the <code>hessian</code> function in the <code>numDeriv</code> package. See <code>?hessian</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient.method</code></td>
<td>
<p>method used to calculate the gradient of the final estimates, either "Richardson", "simple", or "complex". This method is passed to the <code>grad</code> function in the <code>numDeriv</code> package. See <code>?grad</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.cent, var.adj</code></td>
<td>
<p>arguments passed to the skewed generalized t distribution function (see <code>?dsgt</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments that are passed to the <code>control</code> argument in the <code>optimx</code> function in the <code>optimx</code> package. See <code>?optimx</code> for a list of arguments that can be used in the <code>control</code> argument.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter names are taken from <code>start</code>. If there is a name of a parameter or some data found on the right-hand side of one of the formulas but not found in <code>data</code> and not found in <code>start</code>, then an error is given.
</p>
<p>This function simply uses the <code>optimx</code> function in the <code>optimx</code> package to maximize the skewed generalized t distribution log-likelihood function. It takes the method that returned the highest log-likelihood, and saves these results as the final estimates.
</p>


<h3>Value</h3>

<p><code>sgt.mle</code> returns a list of class <code>"sgtest"</code>.
A list of class <code>"sgtest"</code> has the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>maximum</code></td>
<td>
<p>log-likelihood value of estimates (the last calculated value
if not converged) of the method that achieved the greatest log-likelihood value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>estimated parameter value with the method that achieved the greatest log-likelihood value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convcode</code></td>
<td>
<p><code>convcode</code> returned from the <code>optimx</code> function in the <code>optimx</code> package of the method that achieved the greatest log-likelihood value. See <code>?optimx</code> for the different <code>convcode</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>The amount of iterations that the method which achieved the the greatest log-likelihood value used to reach its estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.method.used</code></td>
<td>
<p>name of the method that achieved the greatest log-likelihood value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimx</code></td>
<td>
<p>A <code>data.frame</code> of class <code>"optimx"</code> that contains the results of the <code>optimx</code> maximization for every method (<em>not</em> just the method that achieved the highest log-likelihood value). See <code>?optimx</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>vector, gradient value of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>matrix, hessian of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcov</code></td>
<td>
<p>variance/covariance matrix of the maximimum likelihood estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.error</code></td>
<td>
<p>standard errors of the estimates</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Carter Davis, <a href="mailto:carterdavis@byu.edu">carterdavis@byu.edu</a></p>


<h3>References</h3>

<p>Davis, Carter, James McDonald, and Daniel Walton (2015). 
"A Generalized Regression Specification using the Skewed Generalized T Distribution" 
working paper.
</p>


<h3>See Also</h3>

<p>The <code>optimx</code> package and its documentation. The <code>sgt.mle</code> simply uses its functions to maximize the skewed generalized t log-likelihood. Also, the <code>sgt.mle</code> function uses the <code>numDeriv</code> package to compute the final hessian and gradients of the estimates.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># SINGLE VARIABLE ESTIMATION:
### generate random variable
set.seed(7900)
n = 1000
x = rsgt(n, mu = 2, sigma = 2, lambda = -0.25, p = 1.7, q = 7)

### Get starting values and estimate the parameter values
start = list(mu = 0, sigma = 1, lambda = 0, p = 2, q = 10)
result = sgt.mle(X.f = ~ x, start = start, method = "nlminb")
print(result)
print(summary(result))

# REGRESSION MODEL ESTIMATION:
### Generate Random Data 
set.seed(1253)
n = 1000
x1 = rnorm(n)
x2 = runif(n)
y = 1 + 2*x1 + 3*x2 + rnorm(n)
data = as.data.frame(cbind(y, x1, x2))

### Estimate Linear Regression Model
reg = lm(y ~ x1 + x2, data = data)
coef = as.numeric(reg$coefficients)
rmse = summary(reg)$sigma
start = c(b0 = coef[1], b1 = coef[2], b2 = coef[3], 
g0 = log(rmse)+log(2)/2, g1 = 0, g2 = 0, d0 = 0, 
d1 = 0, d2 = 0, p = 2, q = 10)

### Set up Model
X.f = X ~ y - (b0 + b1*x1 + b2*x2)
mu.f = mu ~ 0
sigma.f = sigma ~ exp(g0 + g1*x1 + g2*x2)
lambda.f = lambda ~ (exp(d0 + d1*x1 + d2*x2)-1)/(exp(d0 + d1*x1 + d2*x2)+1)

### Estimate Regression with a skewed generalized t error term
### This estimates the regression model from the Davis, 
### McDonald, and Walton (2015) paper cited in the references section
### q is in reality infinite since the error term is normal
result = sgt.mle(X.f = X.f, mu.f = mu.f, sigma.f = sigma.f, 
lambda.f = lambda.f, data = data, start = start, 
var.adj = FALSE, method = "nlm")
print(result)
print(summary(result))
</code></pre>


</div>