<div class="container">

<table style="width: 100%;"><tr>
<td>segmentClusters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run the <code>segmenTier</code> algorithm.</h2>

<h3>Description</h3>

<p>segmenTier's main wrapper interface, calculates segments from a
clustering sequence. This will run the segmentation algorithm once
for the indicated parameters. The function
<code>segmentCluster.batch</code> allows for multiple runs over
different parameters or input-clusterings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">segmentClusters(seq, k = 1, csim, E = 1, S = "ccor", M = 175,
  Mn = 20, a = -2, nui = 1, nextmax = TRUE, multi = "max",
  multib = "max", rm.nui = TRUE, save.matrix = FALSE, verb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seq</code></td>
<td>
<p>Either an integer vector of cluster labels, or a
structure of class 'clustering' as returned by
<code>clusterTimeseries</code>. The only strict requirement
for the first option is that nuisance clusters (which will be
treated specially during the dynamic programming routine) have
to be '0' (zero).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>if argument <code>seq</code> is of class 'clustering' the kth
clustering will be used; defaults to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csim</code></td>
<td>
<p>The cluster-cluster or position-cluster similarity
matrix for scoring functions "ccor" and "icor" (option
<code>S</code>), respectively. If <code>seq</code> is of class 'clustering'
<code>csim</code> is optional and will override the similarity
matrices in <code>seq</code>. If argument <code>seq</code> is a simple
vector of cluster labels and the scoring function is "icor" or
"ccor", an appropriate matrix <code>csim</code> MUST be
provided. Finally, for scoring function "ccls" the argument
<code>csim</code> will be ignored and the matrix is instead
automatically constructed from argument <code>a</code>, and using
argument <code>nui</code> for the nuisance cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>exponent to scale similarity matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>the scoring function to be used: "ccor", "icor" or "ccls"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>segment length penalty. Note, that this is not a strict
cut-off but defined as a penalty that must be "overcome" by
good score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mn</code></td>
<td>
<p>segment length penalty for nuisance cluster. Mn&lt;M will
allow shorter distances between "real" segments; only used in
scoring functions "ccor" and "icor"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>a cluster "dissimilarity" only used for pure cluster-based
scoring w/o cluster similarity measures in scoring function
"ccls".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nui</code></td>
<td>
<p>the similarity score to be used for nuisance clusters
in the cluster similarity matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nextmax</code></td>
<td>
<p>go backwards while score is increasing before
opening a new segment, default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multi</code></td>
<td>
<p>handling of multiple k with max. score in forward
phase, either "min" (default) or "max"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multib</code></td>
<td>
<p>handling of multiple k with max. score in back-trace
phase, either "min" (default), "max" or "skip"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.nui</code></td>
<td>
<p>remove nuisance cluster segments from final results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.matrix</code></td>
<td>
<p>store the total score matrix <code>S(i,c)</code> and
the backtracing matrix <code>K(i,c)</code>; useful in testing stage
or for debugging or illustration of the algorithm;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is the main R wrapper function for the ‘segmenTier’
segmentation algorithm. It takes an ordered sequence of cluster
labels and returns segments of consistent clusterings, where
cluster-cluster or cluster-position similarities are
maximal. Its main input (argument <code>seq</code>) is either a
"clustering" object returned by <code>clusterTimeseries</code>
(scenario I), or an integer vector of cluster labels (scenario
II) or. The function then runs the dynamic programming algorithm
(<code>calculateScore</code>) for a selected scoring function
and an according cluster similarity matrix, followed by the
back-tracing step (<code>backtrace</code>) to find segment
borders.
</p>
<p>The main result, list item "segments" of the returned 
object, is a 3-column matrix, where column 1 is the cluster
assignment and columns 2 and 3 are start and end indices of the
segments. For the batch function <code>segmentCluster.batch</code>,
the "segments" item is a <code>data.frame</code>
contain additional information, see ?segmentCluster.batch.
</p>
<p>As shown in the publication, the parameters <code>M</code>,
<code>E</code> and <code>nui</code> have the strongest impact on resulting
segment borders.  Other parameters can be fine-tuned but had
little impact on our test data set.
</p>
<p>In the default and tested scenario I, when the input is an object
of class "clustering" produced by <code>clusterTimeseries</code>,
the cluster-cluster and cluster-position similarity matrices are
already provided by this object.
</p>
<p>In the second scenario II for custom use, argument <code>seq</code> can
be a simple clustering vector, where a nuisance cluster must be
indicated by cluster label "0" (zero). The cluster-cluster or
cluster-position similarities MUST be provided (argument
<code>csim</code>) for scoring functions "ccor" and "icor",
respectively. For the simplest scoring function "ccls", a uniform
cluster similarity matrix is constructed from arguments <code>a</code>
and <code>nui</code>, with cluster self-similarities of 1,
"dissimilarities" between different clusters using argument
<code>a&lt;0</code>, and nuisance cluster self-similarity of <code>-a</code>.
</p>
<p>The function returns a list (class "segments") comprising of the
main result (list item "segments"), and "warnings" from the dynamic
programming and backtracing phases, the used similarity matrix
<code>csim</code>, extended by the nuisance cluster; and optionally (see
option <code>save.matrix</code>) the scoring vectors <code>S1(i,c)</code>, the
total score matrix <code>S(i,c)</code> and the backtracing matrix
<code>K(i,c)</code> for analysis of algorithm performance for novel data
sets.  Additional convenience data is reported, such as cluster
colors and sortings if argument <code>seq</code> was of class
'clustering'. These allow for convenient inspection of all data
processing steps with the plot methods. A plot method exists that
allows to plot segments aligned to "timeseries" and "clustering"
plots.
</p>


<h3>Value</h3>

<p>Returns a list (class "segments") containing the main
result (list item "segments"), and additional information (see
‘Details’). A plot method exists that allows to plot clusters
aligned to time-series and segmentation plots.
</p>


<h3>References</h3>

<p>Machne, Murray &amp; Stadler (2017)
&lt;doi:10.1038/s41598-017-12401-8&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load example data, an RNA-seq time-series data from a short genomic region
# of budding yeast
data(primseg436)

# 1) Fourier-transform time series:
## NOTE: reducing official example data set to stay within 
## CRAN example timing restrictions with segmentation below
tset &lt;- processTimeseries(ts=tsd[2500:6500,], na2zero=TRUE, use.fft=TRUE,
                          dft.range=1:7, dc.trafo="ash", use.snr=TRUE)

# 2) cluster time-series into K=12 clusters:
cset &lt;- clusterTimeseries(tset, K=12)

# 3) ... segment it; this takes a few seconds:
segments &lt;- segmentClusters(seq=cset, M=100, E=2, nui=3, S="icor")

# 4) inspect results:
print(segments)
plotSegmentation(tset, cset, segments, cex=.5, lwd=3)

# 5) and get segment border table for further processing:
sgtable &lt;- segments$segments

</code></pre>


</div>