<div class="container">

<table style="width: 100%;"><tr>
<td>st_as_stars</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>convert objects into a stars object</h2>

<h3>Description</h3>

<p>convert objects into a stars object
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cubble_df'
st_as_stars(.x, ..., check_times = FALSE)

## S3 method for class 'ncdfgeom'
st_as_stars(.x, ..., sf_geometry = NA)

## S3 method for class 'OpenStreetMap'
st_as_stars(.x, ..., as_col = FALSE)

## S3 method for class 'stars_proxy'
st_as_stars(
  .x,
  ...,
  downsample = 0,
  url = attr(.x, "url"),
  envir = parent.frame()
)

## S3 method for class 'data.frame'
st_as_stars(.x, ..., dims = coords, xy, y_decreasing = TRUE, coords = 1:2)

## S3 method for class 'Raster'
st_as_stars(.x, ..., att = 1, ignore_file = FALSE)

## S3 method for class 'SpatRaster'
st_as_stars(
  .x,
  ...,
  ignore_file = FALSE,
  as_attributes = all(terra::is.factor(.x))
)

## S3 method for class 'sf'
st_as_stars(.x, ..., dims = attr(.x, "sf_column"))

st_as_stars(.x, ...)

## S3 method for class 'list'
st_as_stars(.x, ..., dimensions = NULL)

## Default S3 method:
st_as_stars(.x = NULL, ..., raster = NULL)

## S3 method for class 'stars'
st_as_stars(.x, ..., curvilinear = NULL, crs = st_crs("OGC:CRS84"))

## S3 method for class 'bbox'
st_as_stars(
  .x,
  ...,
  nx,
  ny,
  dx = dy,
  dy = dx,
  xlim = .x[c("xmin", "xmax")],
  ylim = .x[c("ymin", "ymax")],
  values = 0,
  n = 64800,
  pretty = FALSE,
  inside = FALSE,
  nz,
  proxy = FALSE
)

## S3 method for class 'xts'
st_as_stars(.x, ..., dimensions, name = "attr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p>object to convert</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>in case <code>.x</code> is of class <code>bbox</code>, arguments passed on to 
pretty. In case <code>.x</code> is of class <code>nc_proxy</code>, arguments
passed on to <code>read_ncdf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_times</code></td>
<td>
<p>logical; should we check that the time stamps of all time series are identical?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sf_geometry</code></td>
<td>
<p>sf data.frame with geometry and attributes to be added to stars object.
Must have same number of rows as timeseries instances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_col</code></td>
<td>
<p>logical; return rgb numbers (FALSE) or (character) color values (TRUE)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>downsample</code></td>
<td>
<p>integer: if larger than 0, downsample with this rate (number of pixels to skip in every row/column); if length 2, specifies downsampling rate in x and y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>url</code></td>
<td>
<p>character; URL of the stars endpoint where the data reside</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>environment to resolve objects in</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>the column names or indices that form the cube dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>the x and y raster dimension names or indices; only takes effect after <code>dims</code> has been specified, see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_decreasing</code></td>
<td>
<p>logical; if TRUE, (numeric) y values get a negative delta (decrease with increasing index)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>same as dims, for symmetry with st_as_sf</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>att</code></td>
<td>
<p>see factorValues; column in the RasterLayer's attribute table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_file</code></td>
<td>
<p>logical; if <code>TRUE</code>, ignore the SpatRaster object file name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_attributes</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>.x</code> has more than one layer, load these as separate attributes rather than as a band or time dimension (only implemented for the case where <code>ignore_file</code> is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimensions</code></td>
<td>
<p>object of class dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raster</code></td>
<td>
<p>character; the names of the dimensions that denote raster dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curvilinear</code></td>
<td>
<p>only for creating curvilinear grids: named length 2 list holding longitude and latitude matrices or stars arrays, or the names of the corresponding attributes in <code>.x</code>; the names of this vector should correspond to raster dimensions the matrices are associated with; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>object of class <code>crs</code> with the coordinate reference system of the values in <code>curvilinear</code>; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>integer; number of cells in x direction; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny</code></td>
<td>
<p>integer; number of cells in y direction; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p>numeric or object of class units; cell size in x direction; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dy</code></td>
<td>
<p>numeric or object of class units; cell size in y direction; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>length 2 numeric vector with extent (min, max) in x direction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>length 2 numeric vector with extent (min, max) in y direction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>value(s) to populate the raster values with</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the (approximate) target number of grid cells</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pretty</code></td>
<td>
<p>logical; should cell coordinates have pretty values?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inside</code></td>
<td>
<p>logical; should all cells entirely fall inside the bbox, potentially not covering it completely (<code>TRUE</code>), or always cover the bbox (<code>FALSE</code>), or find a good approximation (<code>NA</code>, default)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz</code></td>
<td>
<p>integer; number of cells in z direction; if missing no z-dimension is created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proxy</code></td>
<td>
<p>logical; should a <code>stars_proxy</code> object be created? (requires gdal_create binary when sf &lt; 1.0-6)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>character; attribute name for array from an <code>xts</code> object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the <code>ncdfgeom</code> method: objects are point-timeseries with optional line or polygon geometry for each timeseries specified with the <code>sf_geometry</code> parameter. See <span class="pkg">ncdfgeom</span> for more about this NetCDF-based format for geometry and timeseries.
</p>
<p>If <code>xy</code> is not specified and the first two dimensions in <code>dims</code> are both numeric,
then it is set to these two dimensions.
</p>
<p>The <code>st_as_stars</code> method for <code>sf</code> objects without any additional
arguments returns a one-dimensional data cube with a dimension for the simple features
geometries, and all remaining attributes as data cube attributes. When used with
further arguments, the method for <code>data.frame</code>s is called.
</p>
<p>if <code>curvilinear</code> is a list with <code>stars</code> objects with longitude and latitude values, its coordinate reference system is typically not that of the latitude and longitude values. If <code>curvilinear</code> contains the names of two arrays in <code>.x</code>, then these are removed from the returned object.
</p>
<p>For the <code>bbox</code> method: if <code>pretty</code> is <code>TRUE</code>, raster cells may extend the coordinate range of <code>.x</code> on all sides. If in addition to <code>nx</code> and <code>ny</code>, <code>dx</code> and <code>dy</code> are also missing, these are set to a single value computed as <code>sqrt(diff(xlim)*diff(ylim)/n)</code>. 
</p>
<p>If <code>nx</code> and <code>ny</code> are missing and <code>values</code> is a matrix, the number of columns and rows of the matrix are taken.
</p>
<p>Otherwise, if <code>nx</code> and <code>ny</code> are missing, they are computed as the (ceiling, floor, or rounded to integer value) of the ratio of the (x or y) range divided by (dx or dy), depending on the value of <code>inside</code>. Positive <code>dy</code> will be made negative. Further named arguments (<code>...</code>) are passed on to <code>pretty</code>. If <code>dx</code> or <code>dy</code> are <code>units</code> objects, their value is converted to the units of <code>st_crs(.x)</code> (only when sf &gt;= 1.0-7).
</p>
<p>for the <code>xts</code> methods, if <code>dimensions</code> are provided, time has to be the first dimension.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require(plm, quietly = TRUE)) {
 data(Produc, package = "plm")
 st_as_stars(Produc)
}
if (require(dplyr, quietly = TRUE)) {
  # https://stackoverflow.com/questions/77368957/
spatial_dim &lt;- st_sf(
  ID = 1:3,
  geometry = list(
    st_polygon(list(
      cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
    )),
    st_polygon(list(
      cbind(c(1, 2, 2, 1, 1), c(0, 0, 1, 1, 0))
    )),
    st_polygon(list(
      cbind(c(2, 3, 3, 2, 2), c(0, 0, 1, 1, 0))
    ))
  )
)
weekdays_dim &lt;- data.frame(weekdays = c("Monday", "Tuesday", "Wednesday", 
    "Thursday", "Friday", "Saturday", "Sunday"))
hours_dim &lt;- data.frame(hours = c("8am", "11am", "4pm", "11pm"))
sf_dta &lt;- spatial_dim |&gt;
  cross_join(weekdays_dim)|&gt;
  cross_join(hours_dim) |&gt;
  mutate(population = rnorm(n(), mean = 1000, sd = 200)) |&gt;
  select(everything(), geometry)

st_as_stars(sf_dta, dims = c("weekdays", "hours", "geometry"))
}
demo(nc, echo=FALSE,ask=FALSE)
st_as_stars(nc)
st_as_stars(st_drop_geometry(nc), dims = "NAME")
data.frame(expand.grid(x=1:5, y = 1:5), z = rnorm(25)) |&gt; st_as_stars()
nc = st_read(system.file("gpkg/nc.gpkg", package="sf"))
st_as_stars(nc)
</code></pre>


</div>