<div class="container">

<table style="width: 100%;"><tr>
<td>GIRF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate generalized impulse response function for
structural STVAR models.</h2>

<h3>Description</h3>

<p><code>GIRF</code> estimates generalized impulse response function for
structural STVAR models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GIRF(
  stvar,
  which_shocks,
  shock_size = 1,
  N = 30,
  R1 = 250,
  R2 = 250,
  init_regime = 1,
  init_values = NULL,
  which_cumulative = numeric(0),
  scale = NULL,
  scale_type = c("instant", "peak"),
  scale_horizon = N,
  ci = c(0.95, 0.8),
  ncores = 2,
  burn_in = 1000,
  exo_weights = NULL,
  seeds = NULL,
  use_parallel = TRUE
)

## S3 method for class 'girf'
plot(x, margs, ...)

## S3 method for class 'girf'
print(x, ..., digits = 2, N_to_print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code> or <code>fitSSTVAR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_shocks</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">d</code>
(<code>=ncol(data)</code>) and elements in <code class="reqn">1,...,d</code> specifying the
structural shocks for which the GIRF should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shock_size</code></td>
<td>
<p>a non-zero scalar value specifying the common size for all scalar
components of the structural shock. Note that the conditional covariance
matrix of the structural shock is normalized to an identity matrix and that the
(generalized) impulse responses may not be symmetric with respect to the sign
and size of the shock.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
generalized impulse responses be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R1</code></td>
<td>
<p>the number of repetitions used to estimate GIRF for each initial
value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2</code></td>
<td>
<p>the number of initial values to use, i.e., to draw from <code>init_regime</code>
if <code>init_values</code> are not specified. The confidence bounds
will be sample quantiles of the GIRFs based on different initial values.
Ignored if the argument <code>init_value</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_regime</code></td>
<td>
<p>an integer in <code class="reqn">1,...,M</code> specifying the regime from which
the initial values should be generated from. The initial values will be generated
from the stationary distribution of the specific regime. Due to the lack of
knowledge of the stationary distribution, models with other than Gaussian conditional distribution
uses a simulation procedure with a burn-in period. See the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_values</code></td>
<td>
<p>a size <code>[p, d, R2]</code> array specifying the initial values in each slice
for each Monte Carlo repetition, where d is the number of time series in the system and <code>R2</code>
is an argument of this function. In each slice, the <strong>last</strong> row will be used as initial values
for the first lag, the second last row for second lag etc. If not specified, initial values will be
drawn from the regime specified in <code>init_regimes</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the impulse
responses should be cumulative. Default is none.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>should the GIRFs to some of the shocks be scaled so that they
correspond to a specific magnitude of instantaneous or peak response
of some specific variable (see the argument <code>scale_type</code>)?
Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
the magnitude of its instantaneous or peak response in the third element
(a non-zero real number). If the GIRFs of multiple shocks should be scaled, provide
a matrix which has one column for each of the shocks with the columns being
the length three vectors described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_type</code></td>
<td>
<p>If argument <code>scale</code> is specified, should the GIRFs be
scaled to match an instantaneous response (<code>"instant"</code>) or peak response
(<code>"peak"</code>). If <code>"peak"</code>, the scale is based on the largest magnitude
of peak response in absolute value. Ignored if <code>scale</code> is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_horizon</code></td>
<td>
<p>If <code>scale_type == "peak"</code> what the maximum horizon up
to which peak response is expected? Scaling won't based on values after this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>a numeric vector with elements in <code class="reqn">(0, 1)</code> specifying the
confidence levels of the confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing. Only
single core computing is supported if an initial value is specified (and
the GIRF won't thus be estimated multiple times).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn_in</code></td>
<td>
<p>Burn-in period for simulating initial values from a regime when <code>cond_dist!="Gaussian"</code>.
See the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exo_weights</code></td>
<td>
<p>if <code>weight_function="exogenous"</code>, provide a size
<code class="reqn">(N+1 x M)</code> matrix of exogenous transition weights for the regimes: <code>[h, m]</code>
for the (after-the-impact) period <code class="reqn">h-1</code> and regime <code class="reqn">m</code> weight (<code>[1, m]</code>
is for the impact period). Ignored if <code>weight_function!="exogenous"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>a length <code>R2</code> vector containing the random number generator
seed for estimation of each GIRF. A single number of an initial value is
specified. or <code>NULL</code> for not initializing the seed. Exists for
creating reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, does not print
anything.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>'girf'</code> generated by the function <code>GIRF</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margs</code></td>
<td>
<p>numeric vector of length four that adjusts the
<code>[bottom_marginal, left_marginal, top_marginal, right_marginal]</code>
as the relative sizes of the marginals to the figures of the responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>graphical parameters passed to <code>plot</code> method plotting the GIRFs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of decimals to print</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The confidence bounds reflect uncertainty about the initial state (but
not about the parameter estimates) if initial values are not
specified. If initial values are specified, confidence intervals won't be
estimated.
</p>
<p>Note that if the argument <code>scale</code> is used, the scaled responses of
the transition weights might be more than one in absolute value.
</p>
<p>If <code>weight_function="exogenous"</code>, exogenous transition weights used in
the Monte Carlo simulations for the future sample paths of the process must
the given in the argument <code>exo_weights</code>. The same weights are used as
the transition weights across the Monte Carlo repetitions.
</p>


<h3>Value</h3>

<p>Returns a class <code>'girf'</code> list with the GIRFs in the first
element (<code>$girf_res</code>) and the used arguments the rest. The first
element containing the GIRFs is a list with the <code class="reqn">m</code>th element
containing the point estimates for the GIRF in <code>$point_est</code> (the first
element) and confidence intervals in <code>$conf_ints</code> (the second
element). The first row is for the GIRF at impact <code class="reqn">(n=0)</code>, the second
for <code class="reqn">n=1</code>, the third for <code class="reqn">n=2</code>, and so on.
</p>
<p>The element <code>$all_girfs</code> is a list containing results from all the individual GIRFs
obtained from the MC repetitions. Each element is for one shock and results are in
array of the form <code>[horizon, variables, MC-repetitions]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(girf)</code>: plot method
</p>
</li>
<li> <p><code>print(girf)</code>: print method
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>GFEVD</code>, <code>linear_IRF</code>, <code>fitSSTVAR</code>
</p>

<ul><li>
<p> Kilian L., LÃ¼tkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R"> 
 # These are long-running examples that use parallel computing.
 # It takes approximately 30 seconds to run all the below examples.
 # Note that larger R1 and R2 should be used for more reliable results;
 # small R1 and R2 are used here to shorten the estimation time.

 # Recursively identified logistic Student's t STVAR(p=3, M=2) model with the first
 # lag of the second variable as the switching variable:
 params32logt &lt;- c(0.5959, 0.0447, 2.6279, 0.2897, 0.2837, 0.0504, -0.2188, 0.4008,
  0.3128, 0.0271, -0.1194, 0.1559, -0.0972, 0.0082, -0.1118, 0.2391, 0.164, -0.0363,
  -1.073, 0.6759, 3e-04, 0.0069, 0.4271, 0.0533, -0.0498, 0.0355, -0.4686, 0.0812,
   0.3368, 0.0035, 0.0325, 1.2289, -0.047, 0.1666, 1.2067, 7.2392, 11.6091)
 mod32logt &lt;- STVAR(gdpdef, p=3, M=2, params=params32logt, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", identification="recursive")

 # GIRF for one-standard-error positive structural shocks, N=30 steps ahead,
 # with the inital values drawn from the first regime.
 girf1 &lt;- GIRF(mod32logt, which_shocks=1:2, shock_size=1, N=30, R1=50, R2=50,
  init_regime=2)
 print(girf1) # Print the results
 plot(girf1) # Plot the GIRFs

 # GIRF for one-standard-error positive structural shocks, N=30 steps ahead,
 # with the inital values drawn from the second regime. The responses of the
 # GDP and GDP deflator growth rates are accumulated.
 girf2 &lt;- GIRF(mod32logt, which_shocks=1:2, which_cumulative=1:2, shock_size=1,
  N=30, R1=50, R2=50, init_regime=2)
 plot(girf2) # Plot the GIRFs

 # GIRF for two-standard-error negative structural shock - the first shock only.
 # N=50 steps ahead with the inital values drawn from the first regime. The responses
 # are scaled to correspond an instantanous increase of 0.5 of the first variable.
 girf3 &lt;- GIRF(mod32logt, which_shocks=1, shock_size=-2, N=50, R1=50, R2=50,
  init_regime=1, scale_type="instant", scale=c(1, 1, 0.5))
 plot(girf3) # Plot the GIRFs
 
</code></pre>


</div>