<div class="container">

<table style="width: 100%;"><tr>
<td>learn_bipartite_k_component_graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learns a bipartite k-component graph
Jointly learns the Laplacian and Adjacency matrices of a graph on the basis
of an observed data matrix</h2>

<h3>Description</h3>

<p>Learns a bipartite k-component graph
</p>
<p>Jointly learns the Laplacian and Adjacency matrices of a graph on the basis
of an observed data matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">learn_bipartite_k_component_graph(
  S,
  is_data_matrix = FALSE,
  z = 0,
  k = 1,
  w0 = "naive",
  m = 7,
  alpha = 0,
  beta = 10000,
  rho = 0.01,
  fix_beta = TRUE,
  beta_max = 1e+06,
  nu = 10000,
  lb = 0,
  ub = 10000,
  maxiter = 10000,
  abstol = 1e-06,
  reltol = 1e-04,
  eigtol = 1e-09,
  record_weights = FALSE,
  record_objective = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>either a pxp sample covariance/correlation matrix, or a pxn data
matrix, where p is the number of nodes and n is the number of
features (or data points per node)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_data_matrix</code></td>
<td>
<p>whether the matrix S should be treated as data matrix
or sample covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>the number of zero eigenvalues for the Adjancecy matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the number of components of the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w0</code></td>
<td>
<p>initial estimate for the weight vector the graph or a string
selecting an appropriate method. Available methods are: "qp": finds w0 that minimizes
||ginv(S) - L(w0)||_F, w0 &gt;= 0; "naive": takes w0 as the negative of the
off-diagonal elements of the pseudo inverse, setting to 0 any elements s.t.
w0 &lt; 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>in case is_data_matrix = TRUE, then we build an affinity matrix based
on Nie et. al. 2017, where m is the maximum number of possible connections
for a given node</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>L1 regularization hyperparameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>regularization hyperparameter for the term ||L(w) - U Lambda U'||^2_F</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>how much to increase (decrease) beta in case fix_beta = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_beta</code></td>
<td>
<p>whether or not to fix the value of beta. In case this parameter
is set to false, then beta will increase (decrease) depending whether the number of
zero eigenvalues is lesser (greater) than k</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_max</code></td>
<td>
<p>maximum allowed value for beta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>regularization hyperparameter for the term ||A(w) - V Psi V'||^2_F</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>lower bound for the eigenvalues of the Laplacian matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>upper bound for the eigenvalues of the Laplacian matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>absolute tolerance on the weight vector w</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>relative tolerance on the weight vector w</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigtol</code></td>
<td>
<p>value below which eigenvalues are considered to be zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>record_weights</code></td>
<td>
<p>whether to record the edge values at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>record_objective</code></td>
<td>
<p>whether to record the objective function values at
each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether to output a progress bar showing the evolution of the
iterations</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>laplacian</code></td>
<td>
<p>the estimated Laplacian Matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>the estimated Adjacency Matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>the estimated weight vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>optimization variable accounting for the eigenvalues of the Adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>optimization variable accounting for the eigenvalues of the Laplacian matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>eigenvectors of the estimated Adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>eigenvectors of the estimated Laplacian matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed_time</code></td>
<td>
<p>elapsed time recorded at every iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_seq</code></td>
<td>
<p>sequence of values taken by beta in case fix_beta = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj_fun</code></td>
<td>
<p>values of the objective function at every iteration in case record_objective = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negloglike</code></td>
<td>
<p>values of the negative loglikelihood at every iteration in case record_objective = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_seq</code></td>
<td>
<p>sequence of weight vectors at every iteration in case record_weights = TRUE</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ze Vinicius and Daniel Palomar
</p>


<h3>References</h3>

<p>S. Kumar, J. Ying, J. V. M. Cardoso, D. P. Palomar. A unified
framework for structured graph learning via spectral constraints.
Journal of Machine Learning Research, 2020.
http://jmlr.org/papers/v21/19-276.html
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(spectralGraphTopology)
library(igraph)
library(viridis)
library(corrplot)
set.seed(42)
w &lt;- c(1, 0, 0, 1, 0, 1) * runif(6)
Laplacian &lt;- block_diag(L(w), L(w))
Atrue &lt;- diag(diag(Laplacian)) - Laplacian
bipartite &lt;- graph_from_adjacency_matrix(Atrue, mode = "undirected", weighted = TRUE)
n &lt;- ncol(Laplacian)
Y &lt;- MASS::mvrnorm(40 * n, rep(0, n), MASS::ginv(Laplacian))
graph &lt;- learn_bipartite_k_component_graph(cov(Y), k = 2, beta = 1e2, nu = 1e2, verbose = FALSE)
graph$adjacency[graph$adjacency &lt; 1e-2] &lt;- 0
# Plot Adjacency matrices: true, noisy, and estimated
corrplot(Atrue / max(Atrue), is.corr = FALSE, method = "square", addgrid.col = NA, tl.pos = "n",
         cl.cex = 1.25)
corrplot(graph$adjacency / max(graph$adjacency), is.corr = FALSE, method = "square",
         addgrid.col = NA, tl.pos = "n", cl.cex = 1.25)
# Plot networks
estimated_bipartite &lt;- graph_from_adjacency_matrix(graph$adjacency, mode = "undirected",
                                                   weighted = TRUE)
V(bipartite)$type &lt;- rep(c(TRUE, FALSE), 4)
V(estimated_bipartite)$type &lt;- rep(c(TRUE, FALSE), 4)
la = layout_as_bipartite(estimated_bipartite)
colors &lt;- viridis(20, begin = 0, end = 1, direction = -1)
c_scale &lt;- colorRamp(colors)
E(estimated_bipartite)$color = apply(
               c_scale(E(estimated_bipartite)$weight / max(E(estimated_bipartite)$weight)), 1,
                                     function(x) rgb(x[1]/255, x[2]/255, x[3]/255))
E(bipartite)$color = apply(c_scale(E(bipartite)$weight / max(E(bipartite)$weight)), 1,
                           function(x) rgb(x[1]/255, x[2]/255, x[3]/255))
la = la[, c(2, 1)]
# Plot networks: true and estimated
plot(bipartite, layout = la,
     vertex.color = c("red","black")[V(bipartite)$type + 1],
     vertex.shape = c("square", "circle")[V(bipartite)$type + 1],
     vertex.label = NA, vertex.size = 5)
plot(estimated_bipartite, layout = la,
     vertex.color = c("red","black")[V(estimated_bipartite)$type + 1],
     vertex.shape = c("square", "circle")[V(estimated_bipartite)$type + 1],
     vertex.label = NA, vertex.size = 5)
</code></pre>


</div>