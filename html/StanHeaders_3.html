<div class="container">

<table style="width: 100%;"><tr>
<td>stanFunction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compile and Call a Stan Math Function
</h2>

<h3>Description</h3>

<p>Call a function defined in the Stan Math Library from R using this wrapper around 
<code>cppFunction</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  stanFunction(function_name, ..., env = parent.frame(), rebuild = FALSE,
               cacheDir = getOption("rcpp.cache.dir", tempdir()), 
               showOutput = verbose, verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>function_name</code></td>
<td>

<p>A <code>character</code> vector of length one that is the unscoped basename of a 
C++ function under the <code>prim/</code> directory of the Stan Math Library that you 
would like to evaluate. Functions (such as <code>integrate_1d</code>) of other functions
are not permitted and neither are functions (such as <code>reject</code>) of characters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments that are passed to <code>function_name</code> in <code>tag = value</code>
form, which are passed to <code>function_name</code> by  <em>position</em>. See the Details 
and Examples sections.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env,rebuild,cacheDir,showOutput,verbose</code></td>
<td>

<p>The same as in <code>cppFunction</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>stanFunction</code> function essentially compiles and
evaluates a C++ function of the form
</p>
<pre>auto function_name(...) { return stan::math::function_name(...); }</pre>
<p>It is essential to pass all arguments to <code>function_name</code> through the ...
in order for the C++ wrapper to know what the argument types are. The mapping
between R types and Stan types is
</p>

<table>
<tr>
<td style="text-align: left;">
    <b>R type</b>  </td>
<td style="text-align: right;"> <b>Stan type</b> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>double</code>  </td>
<td style="text-align: right;"> <code>real</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>integer</code> </td>
<td style="text-align: right;"> <code>int</code>  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>complex</code> </td>
<td style="text-align: right;"> <code>complex</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vector</code>  </td>
<td style="text-align: right;"> <code>vector</code> or <code>complex_vector</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matrix(*, nrow = 1)</code> </td>
<td style="text-align: right;"> <code>row_vector</code> or <code>complex_row_vector</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matrix</code>  </td>
<td style="text-align: right;"> <code>matrix</code> or <code>complex_matrix</code>
  </td>
</tr>
</table>
<p>and, in addition, lists of the aforementioned R types map
to arrays of Stan types and thus must not be ragged if they are nested. The
Stan version of the function is called with arguments specified by position,
i.e. in the order that they appear in the .... However, the R wrapper
function has arguments whose names are the same as the names passed through
the ....
</p>


<h3>Value</h3>

<p>The result of <code>function_name</code> evaluated at the arguments
that are passed through the ..., which could be of various
R types. It also has the side effect of defining a function
named <code>function_name</code> in the environment given by the
<code>env</code> argument that can subsequently be called with
inputs of the same type (but not necessarily the same value)
that were passed through the ....
</p>


<h3>Examples</h3>

<pre><code class="language-R">  files &lt;- dir(system.file("include", "stan", "math", "prim",
                           package = "StanHeaders"), 
               pattern = "hpp$", recursive = TRUE)
  functions &lt;- sub("\\.hpp$", "", 
                   sort(unique(basename(files[dirname(files) != "."]))))
  length(functions) # you could call most of these Stan functions
  
  ## Not run: 
    log(sum(exp(exp(1)), exp(pi))) # true value
    
    stanFunction("log_sum_exp", x = exp(1), y = pi)
    args(log_sum_exp) # now exists in .GlobalEnv
    log_sum_exp(x = pi, y = exp(1))
    
    # but log_sum_exp() was not defined for a vector or matrix
    x &lt;- c(exp(1), pi)
    try(log_sum_exp(x))
    stanFunction("log_sum_exp", x = x) # now it is
    
    # log_sum_exp() is now also defined for a matrix
    log_sum_exp(as.matrix(x))
    log_sum_exp(t(as.matrix(x)))
    log_sum_exp(rbind(x, x))
    
    # but log_sum_exp() was not defined for a list
    try(log_sum_exp(as.list(x)))
    stanFunction("log_sum_exp", x = as.list(x)) # now it is

    # in rare cases, passing a nested list is needed
    stanFunction("dims", x = list(list(1:3)))
    
    # functions of complex arguments work
    stanFunction("eigenvalues", # different ordering than base:eigen()
                 x = matrix(complex(real = 1:9, imaginary = pi),
                            nrow = 3, ncol = 3))
    
    # nullary functions work but are not that interesting
    stanFunction("negative_infinity")
    
    # PRNG functions work by adding a seed argument
    stanFunction("lkj_corr_rng", K = 3L, eta = 1)
    args(lkj_corr_rng) # has a seed argument
  
## End(Not run)
</code></pre>


</div>