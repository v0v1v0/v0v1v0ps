<div class="container">

<table style="width: 100%;"><tr>
<td>flex.zones</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine zones for flexibly shaped spatial scan test</h2>

<h3>Description</h3>

<p><code>flex.zones</code> determines the unique zones to consider
for the flexibly shaped spatial scan test of Tango and
Takahashi (2005).  The algorithm uses a breadth-first
search to find all subgraphs connected to each vertex
(region) in the data set of size <code class="reqn">k</code> or less.
</p>


<h3>Usage</h3>

<pre><code class="language-R">flex.zones(
  coords,
  w,
  k = 10,
  longlat = FALSE,
  cl = NULL,
  loop = FALSE,
  verbose = FALSE,
  pfreq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>A cluster object created by <code>makeCluster</code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loop</code></td>
<td>
<p>A logical value indicating whether a loop
should be used to implement the function instead of
<code>pbapply</code>.  The default is
<code>FALSE</code>. If <code>TRUE</code>, then memory-saving steps
are also taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value indicating whether
progress messages should be provided.
The default is <code>FALSE</code>.  If both <code>loop</code> and
<code>verbose</code> are <code>TRUE</code>, informative messages
are displayed that can be useful for diagnosing where
the sequences of connected subgraphs are slowing down
or having problems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pfreq</code></td>
<td>
<p>The frequency that messages are reported
from the loop (if <code>verbose = TRUE</code>). The default
is <code>pfreq = 1</code>, meaning a message is returned for
each index of the loop.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T., &amp; Takahashi, K. (2005). A flexibly
shaped spatial scan statistic for detecting clusters.
International journal of health geographics, 4(1), 11.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nydf)
data(nyw)
coords &lt;- cbind(nydf$x, nydf$y)
zones &lt;- flex.zones(coords, w = nyw, k = 3)
## Not run: 
# see what happens when verbose = TRUE
zones &lt;- flex.zones(coords, w = nyw, k = 3, verbose = TRUE)

## End(Not run)
</code></pre>


</div>