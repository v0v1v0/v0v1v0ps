<div class="container">

<table style="width: 100%;"><tr>
<td>chop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cut data into intervals</h2>

<h3>Description</h3>

<p><code>chop()</code> cuts <code>x</code> into intervals. It returns a <code>factor</code> of the same length as
<code>x</code>, representing which interval contains each element of <code>x</code>.
<code>kiru()</code> is an alias for <code>chop</code>.
<code>tab()</code> calls <code>chop()</code> and returns a contingency <code>table()</code> from the result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">chop(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)

kiru(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)

tab(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>A numeric vector of cut-points or a function to create
cut-points from <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>A character vector of labels or a function to create labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, always extend breaks to <code style="white-space: pre;">⁠+/-Inf⁠</code>. If <code>NULL</code>,
extend breaks to <code>min(x)</code> and/or <code>max(x)</code> only if necessary. If <code>NULL</code>, never
extend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Logical. Drop unused levels from the result?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>x</code> may be a numeric vector, or more generally, any vector which can be
compared with <code>&lt;</code> and <code>==</code> (see Ops). In particular Date
and date-time objects are supported. Character vectors
are supported with a warning.
</p>


<h4>Breaks</h4>

<p><code>breaks</code> may be a vector or a function.
</p>
<p>If it is a vector, <code>breaks</code> gives the break endpoints. Repeated values create
singleton intervals. For example <code>breaks = c(1, 3, 3, 5)</code> creates 3
intervals: <code>[1, 3)</code>, <code>{3}</code> and <code>(3, 5]</code>.
</p>
<p>If <code>breaks</code> is a function, it is called with the <code>x</code>, <code>extend</code>, <code>left</code> and
<code>close_end</code> arguments, and should return an object of class <code>breaks</code>.
Use <code style="white-space: pre;">⁠brk_*⁠</code> functions to create a variety of data-dependent breaks.
</p>
<p>Names of <code>breaks</code> may be used for labels. See "Labels" below.
</p>



<h4>Options for breaks</h4>

<p>By default, left-closed intervals are created. If <code>left</code> is <code>FALSE</code>,
right-closed intervals are created.
</p>
<p>If <code>close_end</code> is <code>TRUE</code> the final break (or first break if <code>left</code> is <code>FALSE</code>)
will be closed at both ends. This guarantees that all values <code>x</code> with
<code style="white-space: pre;">⁠min(breaks) &lt;= x &lt;= max(breaks)⁠</code> are included in the intervals.
</p>
<p>Before version 0.9.0, <code>close_end</code> was <code>FALSE</code> by default, and also behaved
differently with respect to extended breaks: see "Extending intervals" below.
</p>
<p>Using mathematical set notation:
</p>

<ul>
<li>
<p> If <code>left</code> is <code>TRUE</code> and <code>close_end</code> is <code>TRUE</code>, breaks will look like
<code>[b1, b2), [b2, b3) ... [b_n-1, b_n]</code>.
</p>
</li>
<li>
<p> If <code>left</code> is <code>FALSE</code> and <code>close_end</code> is <code>TRUE</code>, breaks will look like
<code>[b1, b2], (b2, b3] ... (b_n-1, b_n]</code>.
</p>
</li>
<li>
<p> If <code>left</code> is <code>TRUE</code> and <code>close_end</code> is <code>FALSE</code>, all breaks will look like
<code>...[b1, b2) ...</code>.
</p>
</li>
<li>
<p> If <code>left</code> is <code>FALSE</code> and <code>close_end</code> is <code>FALSE</code>, all breaks will look like
<code>...(b1, b2] ...</code>.
</p>
</li>
</ul>
<h4>Extending intervals</h4>

<p>If <code>extend</code> is <code>TRUE</code>, intervals will be extended to <code>[-Inf,
min(breaks))</code> and <code>(max(breaks), Inf]</code>.
</p>
<p>If <code>extend</code> is <code>NULL</code> (the default), intervals will be extended to
<code>[min(x), min(breaks))</code> and <code>(max(breaks), max(x)]</code>, <em>only</em> if
necessary – i.e. if elements of <code>x</code> would be below or above the unextended
breaks.
</p>
<p><code>close_end</code> is applied after breaks are extended, i.e. always to the very last
or very first break. This is a change from
previous behaviour. Up to version 0.8.0, <code>close_end</code> was applied to the
user-specified intervals, then <code>extend</code> was applied. Note that
if breaks are extended, then the extended break is always closed anyway.
</p>



<h4>Labels</h4>

<p><code>labels</code> may be a character vector. It should have the same length as the
(possibly extended) number of intervals. Alternatively, <code>labels</code> may be a
<code style="white-space: pre;">⁠lbl_*⁠</code> function such as <code>lbl_seq()</code>.
</p>
<p>If <code>breaks</code> is a named vector, then non-zero-length names of <code>breaks</code> will be
used as labels for the interval starting at the corresponding element. This
overrides the <code>labels</code> argument (but unnamed breaks will still use <code>labels</code>).
This feature is <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>.
</p>
<p>If <code>labels</code> is <code>NULL</code>, then integer codes will be returned instead of a
factor.
</p>
<p>If <code>raw</code> is <code>TRUE</code>, labels will show the actual numbers calculated by breaks.
If <code>raw</code> is <code>FALSE</code> then labels may show other objects, such
as quantiles for <code>chop_quantiles()</code> and friends, proportions of the range for
<code>chop_proportions()</code>, or standard deviations for <code>chop_mean_sd()</code>.
</p>
<p>If <code>raw</code> is <code>NULL</code> then <code style="white-space: pre;">⁠lbl_*⁠</code> functions will use their default (usually
<code>FALSE</code>). Otherwise, <code>raw</code> argument to <code>chop()</code> overrides <code>raw</code> arguments
passed into <code style="white-space: pre;">⁠lbl_*⁠</code> functions directly.
</p>



<h4>Miscellaneous</h4>

<p><code>NA</code> values in <code>x</code>, and values which are outside the extended endpoints,
return <code>NA</code>.
</p>
<p><code>kiru()</code> is a synonym for <code>chop()</code>. If you load <code>{tidyr}</code>, you can use it to
avoid confusion with <code>tidyr::chop()</code>.
</p>
<p>Note that <code>chop()</code>, like all of R, uses binary arithmetic. Thus, numbers may
not be exactly equal to what you think they should be. There is an example
below.
</p>



<h3>Value</h3>

<p><code>chop()</code> returns a <code>factor</code> of the same length as <code>x</code>, representing the
intervals containing the value of <code>x</code>.
</p>
<p><code>tab()</code> returns a contingency <code>table()</code>.
</p>


<h3>See Also</h3>

<p><code>base::cut()</code>, <code>non-standard-types</code> for chopping objects that
aren't numbers.
</p>
<p>Other chopping functions: 
<code>chop_equally()</code>,
<code>chop_evenly()</code>,
<code>chop_fn()</code>,
<code>chop_mean_sd()</code>,
<code>chop_n()</code>,
<code>chop_proportions()</code>,
<code>chop_quantiles()</code>,
<code>chop_width()</code>,
<code>fillet()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
chop(1:7, c(2, 4, 6))

chop(1:7, c(2, 4, 6), extend = FALSE)

# Repeat a number for a singleton break:
chop(1:7, c(2, 4, 4, 6))

chop(1:7, c(2, 4, 6), left = FALSE)

chop(1:7, c(2, 4, 6), close_end = FALSE)

chop(1:7, brk_quantiles(c(0.25, 0.75)))

# A single break is fine if `extend` is not `FALSE`:
chop(1:7, 4)

# Floating point inaccuracy:
chop(0.3/3, c(0, 0.1, 0.1, 1), labels = c("&lt; 0.1", "0.1", "&gt; 0.1"))

# -- Labels --

chop(1:7, c(Lowest = 1, Low = 2, Mid = 4, High = 6))

chop(1:7, c(2, 4, 6), labels = c("Lowest", "Low", "Mid", "High"))

chop(1:7, c(2, 4, 6), labels = lbl_dash())

# Mixing names and other labels:
chop(1:7, c("&lt;2" = 1, 2, 4, "&gt;=6" = 6), labels = lbl_dash())

# -- Non-standard types --

chop(as.Date("2001-01-01") + 1:7, as.Date("2001-01-04"))

suppressWarnings(chop(LETTERS[1:7], "D"))


tab(1:10, c(2, 5, 8))

</code></pre>


</div>