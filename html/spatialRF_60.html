<div class="container">

<table style="width: 100%;"><tr>
<td>select_spatial_predictors_sequential</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sequential introduction of spatial predictors into a model</h2>

<h3>Description</h3>

<p>Selects spatial predictors by adding them sequentially into a model while monitoring the Moran's I of the model residuals and the model's R-squared. Once all the available spatial predictors have been added to the model, the function identifies the first <code>n</code> predictors that minimize the spatial correlation of the residuals and maximize R-squared, and returns the names of the selected spatial predictors and a data frame with the selection criteria.
</p>


<h3>Usage</h3>

<pre><code class="language-R">select_spatial_predictors_sequential(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  spatial.predictors.ranking = NULL,
  weight.r.squared = 0.75,
  weight.penalization.n.predictors = 0.25,
  verbose = FALSE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranger.arguments</code></td>
<td>
<p>Named list with ranger arguments (other arguments of this function can also go here). All ranger arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of ranger if you are not familiar with the arguments of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial.predictors.ranking</code></td>
<td>
<p>Ranking of the spatial predictors returned by <code>rank_spatial_predictors()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.r.squared</code></td>
<td>
<p>Numeric between 0 and 1, weight of R-squared in the optimization index. Default: <code>0.75</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.penalization.n.predictors</code></td>
<td>
<p>Numeric between 0 and 1, weight of the penalization for the number of spatial predictors added in the optimization index. Default: <code>0.25</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, ff <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>Integer, number of cores to use. Default: <code>parallel::detectCores() - 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A cluster definition generated by <code>parallel::makeCluster()</code>. Default: <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm works as follows: If the function rank_spatial_predictors returns 10 spatial predictors (sp1 to sp10, ordered from best to worst), select_spatial_predictors_sequential is going to fit the models <code>y ~ predictors + sp1</code>, <code>y ~ predictors + sp1 + sp2</code>, until all spatial predictors are used in <code style="white-space: pre;">⁠y ~ predictors + sp1 ... sp10⁠</code>. The model with lower Moran's I of the residuals and higher R-squared (computed on the out-of-bag data) is selected, and its spatial predictors returned.
</p>


<h3>Value</h3>

<p>A list with two slots: <code>optimization</code>, a data frame with the index of the spatial predictor added on each iteration, the spatial correlation of the model residuals, and the R-squared of the model, and <code>best.spatial.predictors</code>, that is a character vector with the names of the spatial predictors that minimize the Moran's I of the residuals and maximize the R-squared of the model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){

#loading example data
data(distance_matrix)
data(plant_richness_df)

#common arguments
dependent.variable.name = "richness_species_vascular"
predictor.variable.names = colnames(plant_richness_df)[5:21]

#non-spatial model
model &lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#preparing spatial predictors
spatial.predictors &lt;- mem_multithreshold(
  distance.matrix = distance.matrix,
  distance.thresholds = 0
)
#ranking spatial predictors by their Moran's I (faster option)
spatial.predictors.ranking &lt;- rank_spatial_predictors(
  ranking.method = "moran",
  spatial.predictors.df = spatial.predictors,
  reference.moran.i = model$spatial.correlation.residuals$max.moran,
  distance.matrix = distance.matrix,
  distance.thresholds = 0,
  n.cores = 1
)

#selecting the best subset of predictors
selection &lt;- select_spatial_predictors_sequential(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  spatial.predictors.df = spatial.predictors,
  spatial.predictors.ranking = spatial.predictors.ranking,
  n.cores = 1
)

selection$optimization
selection$best.spatial.predictors
plot_optimization(selection$optimization)

}
</code></pre>


</div>