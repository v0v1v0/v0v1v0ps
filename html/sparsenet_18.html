<div class="container">

<table style="width: 100%;"><tr>
<td>sparsenet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a linear model regularized by the nonconvex MC+ sparsity penalty
</h2>

<h3>Description</h3>

<p>Sparsenet uses coordinate descent on the MC+ nonconvex penalty family,
and fits a surface of solutions over the two-dimensional parameter
space. This penalty family is indexed by an overall strength paramter lambda
(like lasso), and a convexity parameter gamma. Gamma = infinity
corresponds to the lasso, and gamma = 1 best subset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sparsenet(x, y, weights, exclude, dfmax = nvars + 1, pmax = min(dfmax *2, nvars),
ngamma = 9, nlambda = 50, max.gamma = 150, min.gamma = 1.000001,
lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04), lambda = NULL,
gamma = NULL, parms = NULL, warm = c("lambda", "gamma", "both"),
thresh = 1e-05, maxit = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input matrix of nobs x nvars predictors
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights; default 1 for each observation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmax</code></td>
<td>
<p>Limit the maximum number of variables in the
model. Useful for very large <code>nvars</code>, if a partial path is desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>
<p>Limit the maximum number of variables ever to be nonzero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngamma</code></td>
<td>

<p>Number of gamma values, if <code>gamma</code> not supplied; default is 9.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p> Number of lambda values, if <code>lambda</code> not
supplied; default is 50
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.gamma</code></td>
<td>
<p>Largest gamma value to be used, apart from infinity
(lasso), if <code>gamma</code> not supplied; default is 150
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.gamma</code></td>
<td>
<p>Smallest value of gamma to use, and should be &gt;1;
default is 1.000001
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero). The default depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.0001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.01</code>.
A very small value of
<code>lambda.min.ratio</code> will lead to a saturated fit in the <code>nobs &lt;
    nvars</code> case.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, in decreasing order. Typical usage
is to have the 
program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.min.ratio</code>. Supplying a value of
<code>lambda</code> overrides this. WARNING: use with care. Do not supply
a single value for <code>lambda</code> (for predictions after CV use <code>predict()</code>
instead).  Supply instead
a decreasing sequence of <code>lambda</code> values. <code>sparsenet</code> relies
on its warms starts for speed, and its often faster to fit a whole
path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>Sparsity parameter vector, with 1&lt;gamma&lt;infty. Gamma=1 corresponds to
best-subset regression, gamma=infty to the lasso. Should be given in
decreasing order.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>

<p>An optional three-dimensional array: 2x ngamma x nlambda.
Here the user can supply exactly the gamma, lambda pairs that are to
be traversed by the coordinate descent algorithm. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm</code></td>
<td>

<p>How to traverse the grid. Default is "lambda", meaning warm starts from
the previous lambda with the same gamma. "gamma" means the opposite,
previous gamma for the same lambda. "both" tries both warm starts, and
uses the one that improves the criterion the most. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
coordinate-descent loop continues until the maximum change in the
objective after any coefficient update is less than <code>thresh</code>
times the null Rss. Defaults value is <code>1E-5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda/gamma
values; default is 10^6.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This algorithm operates like <code>glmnet</code>, with its alpha parameter
which moves the penalty between lasso and ridge; here gamma moves it
between lasso and best subset.
The algorithm traverses the two dimensional gamma/lambda array in a nested loop, with
decreasing gamma in the outer loop, and decreasing lambda in the inner
loop. Because of the nature of the MC+ penalty, each coordinate update
is a convex problem, with a simple two-threshold shrinking scheme:
beta&lt; lambda set to zero; beta &gt; lambda*gamma leave alone; beta
inbetween, shrink proportionally. Note that this algorithm ALWAYS
standardizes the columns of x and y to have mean zero and variance 1
(using the 1/N averaging) before it computes its fit. The
coefficients reflect the original scale.
</p>


<h3>Value</h3>

<p>An object of class <code>"sparsenet"</code>, with a number of
components. Mostly one will access the components via generic
functions
like <code>coef()</code>, <code>plot()</code>, <code>predict()</code> etc.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsq</code></td>
<td>
<p>The percentage variance explained on the training data;
an ngamma x nlambda matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors (largely for internal debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>A coefficient list with ngamma elements; each of
these is a coefficient list with various components: the matrix beta
of coefficients, its dimension dim, the vector of intercepts, the lambda sequence, the gamma value,  the sequence
of df (nonzero coefficients) for each solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>
<p>Irrespective how the parameters were input, the three-way
array of what was used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The gamma values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambda values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.lambda</code></td>
<td>
<p>The entry value for lambda</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Rahul Mazumder, Jerome Friedman and Trevor Hastie
</p>
<p>Maintainer: Trevor Hastie &lt;hastie@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Mazumder, Rahul, Friedman, Jerome and Hastie, Trevor (2011)
<em>SparseNet: Coordinate Descent with Nonconvex Penalties. JASA, Vol 106(495), 1125-38</em>,
<a href="https://hastie.su.domains/public/Papers/Sparsenet/Mazumder-SparseNetCoordinateDescent-2011.pdf">https://hastie.su.domains/public/Papers/Sparsenet/Mazumder-SparseNetCoordinateDescent-2011.pdf</a>
</p>


<h3>See Also</h3>

<p><code>glmnet</code> package,  <code>predict</code>, <code>coef</code>, <code>print</code> and <code>plot</code> methods, and the <code>cv.sparsenet</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">train.data=gendata(100,1000,nonzero=30,rho=0.3,snr=3)
fit=sparsenet(train.data$x,train.data$y)
par(mfrow=c(3,3))
plot(fit)
par(mfrow=c(1,1))
fitcv=cv.sparsenet(train.data$x,train.data$y,trace.it=TRUE)
plot(fitcv)
</code></pre>


</div>