<div class="container">

<table style="width: 100%;"><tr>
<td>farringtonFlexible</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surveillance for Univariate Count Time Series Using an Improved Farrington Method</h2>

<h3>Description</h3>


<p>The function takes <code>range</code> values of the surveillance time
series <code>sts</code> and for each time point uses a Poisson GLM with overdispersion to
predict an upper bound on the number of counts according to the procedure by
Farrington et al. (1996) and by Noufaily et al. (2012). This bound is then compared to the observed
number of counts. If the observation is above the bound, then an alarm is raised.
The implementation is illustrated in Salmon et al. (2016).

</p>


<h3>Usage</h3>

<pre><code class="language-R">farringtonFlexible(sts, control = list(
    range = NULL, b = 5, w = 3,
    reweight = TRUE, weightsThreshold = 2.58,
    verbose = FALSE, glmWarnings = TRUE,
    alpha = 0.05, trend = TRUE, pThresholdTrend = 0.05,
    limit54 = c(5,4), powertrans = "2/3",
    fitFun = "algo.farrington.fitGLM.flexible",
    populationOffset = FALSE,
    noPeriods = 1, pastWeeksNotIncluded = NULL,
    thresholdMethod = "delta"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sts</code></td>
<td>
<p>object of class <code>sts</code> (including the <code>observed</code> and the <code>state</code> time series)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Control object given as a <code>list</code> containing the following components:
</p>

<dl>
<dt><code>range</code></dt>
<dd>
<p>Specifies the index of all timepoints which
should be tested. If range is <code>NULL</code> all possible timepoints are used.</p>
</dd>
<dt><code>b</code></dt>
<dd>
<p>How many years back in time to include when
forming the base counts.</p>
</dd>
<dt><code>w</code></dt>
<dd>
<p>Window's half-size, i.e. number of weeks to include
before and after the current week in each year.</p>
</dd>
<dt><code>reweight</code></dt>
<dd>
<p>Boolean specifying whether to perform reweighting step.</p>
</dd>
<dt><code>weightsThreshold</code></dt>
<dd>
<p>Defines the threshold for reweighting past outbreaks  using the Anscombe residuals
(1 in the original method, 2.58 advised in the improved method).</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Boolean specifying whether to show extra debugging information.</p>
</dd>
<dt><code>glmWarnings</code></dt>
<dd>
<p>Boolean specifying whether to print warnings from the call to <code>glm</code>.</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>An approximate (one-sided) <code class="reqn">(1-\alpha)\cdot 100\%</code>
prediction interval is calculated unlike the original method where it was a two-sided interval. The upper limit of this interval
i.e. the <code class="reqn">(1-\alpha)\cdot 100\%</code> quantile serves as an upperbound.</p>
</dd>
<dt><code>trend</code></dt>
<dd>
<p>Boolean indicating whether a trend should be included and kept in
case the conditions in the Farrington et. al. paper are met
(see the results). If <code>false</code> then NO trend is fit.</p>
</dd>
<dt><code>pThresholdTrend</code></dt>
<dd>
<p>Threshold for deciding whether to keep trend in the model
(0.05 in the original method, 1 advised in the improved method).</p>
</dd>
<dt><code>limit54</code></dt>
<dd>
<p>Vector containing two numbers: <code>cases</code> and <code>period</code>. To avoid alarms in cases where the time series only
has about almost no cases in the specific week the algorithm uses the following heuristic
criterion (see Section 3.8 of the Farrington paper) to protect
against low counts: no alarm is sounded if fewer than
<code class="reqn">\code{cases}=5</code> reports were received in the past <code class="reqn">\code{period}=4</code>
weeks. <code>limit54=c(cases,period)</code> is a vector allowing the
user to change these numbers. Note: As of version 0.9-7 of the package the
term "last" period of weeks includes the current week -
otherwise no alarm is sounded for horrible large numbers if
the four weeks before that are too low.</p>
</dd>
<dt><code>powertrans</code></dt>
<dd>
<p>Power transformation to apply to the
data if the threshold is to be computed with  the method described
in Farrington et al. (1996. Use either "2/3" for skewness correction (Default),
"1/2" for variance stabilizing transformation or "none" for no
transformation.</p>
</dd>
<dt><code>fitFun</code></dt>
<dd>
<p>String containing the name of the fit
function to be used for fitting the GLM. The only current option is 
"algo.farrington.fitGLM.flexible".</p>
</dd>
<dt><code>populationOffset</code></dt>
<dd>
<p>Boolean specifying whether to include 
a population offset in the GLM. 
The slot <code>sts@population</code> gives the population vector.</p>
</dd>
<dt><code>noPeriods</code></dt>
<dd>
<p>Number of levels in the factor allowing to use more baseline. If
equal to 1 no factor variable is created, the set of reference values is defined as in
Farrington et al (1996).</p>
</dd>
<dt><code>pastWeeksNotIncluded</code></dt>
<dd>
<p>Number of past weeks to ignore in the calculation.
The default (<code>NULL</code>) means to use the value of <code>control$w</code>.
Setting <code>pastWeeksNotIncluded=26</code> might be preferable
(Noufaily et al., 2012).</p>
</dd>
<dt><code>thresholdMethod</code></dt>
<dd>
<p>Method to be used to derive the upperbound.
Options are <code>"delta"</code> for the method described in Farrington et al. (1996),
<code>"nbPlugin"</code> for the method described in Noufaily et al. (2012),
and <code>"muan"</code> for the method extended from Noufaily et al. (2012).</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following steps are performed according to the Farrington
et al. (1996) paper.
</p>

<ol>
<li>
<p> Fit of the initial model with intercept, time trend if <code>trend</code> is <code>TRUE</code>,
seasonal factor variable if <code>noPeriod</code> is bigger than 1, and population offset if
<code>populationOffset</code> is <code>TRUE</code>. Initial estimation of mean and
overdispersion.
</p>
</li>
<li>
<p> Calculation of the weights omega (correction for past outbreaks) if <code>reweighting</code> is <code>TRUE</code>.
The threshold for reweighting is defined in <code>control</code>.
</p>
</li>
<li>
<p> Refitting of the model
</p>
</li>
<li>
<p> Revised estimation of overdispersion
</p>
</li>
<li>
<p> Omission of the trend, if it is not significant
</p>
</li>
<li>
<p> Repetition of the whole procedure
</p>
</li>
<li>
<p> Calculation of the threshold value using the model to compute a quantile of the predictive distribution.
The method used depends on <code>thresholdMethod</code>, this can either be:  
</p>

<dl>
<dt>"delta"</dt>
<dd>
<p>One assumes that the prediction error (or a transformation of the prediction
error, depending on <code>powertrans</code>), is normally distributed. The threshold is deduced from a quantile of
this normal distribution using the variance and estimate of the expected
count given by GLM, and the delta rule. The procedure takes into account both the estimation error (variance of the estimator
of the expected count in the GLM) and the prediction error (variance of the prediction error). This is the suggestion
in Farrington et al. (1996).</p>
</dd>
<dt>"nbPlugin"</dt>
<dd>
<p>One assumes that the new count follows
a negative binomial distribution parameterized by the expected count and the overdispersion
estimated in the GLM. The threshold is deduced from a quantile of this discrete distribution.
This process disregards the estimation error, though. This method was used in Noufaily, et al. (2012).</p>
</dd>
<dt>"muan"</dt>
<dd>
<p>One also uses the assumption of the negative
binomial sampling distribution but does not plug in the estimate of the expected count from the GLM,
instead one uses a quantile from the asymptotic normal distribution of the expected count estimated
in the GLM; in order to take into account both the estimation error and the prediction error.   </p>
</dd>        </dl>
</li>
<li>
<p> Computation of exceedance score
</p>
</li>
</ol>
<p>Warning: monthly data containing the last day of each month as date should be analysed with <code>epochAsDate=FALSE</code> in the <code>sts</code> object. Otherwise February makes it impossible to find some reference time points. 
</p>


<h3>Value</h3>

<p>An object of class <code>sts</code> with the slots <code>upperbound</code> and <code>alarm</code> filled by appropriate output of the algorithm.
The <code>control</code> slot of the input <code>sts</code> is amended with the
following matrix elements, all with <code>length(range)</code> rows:
</p>

<dl>
<dt>trend</dt>
<dd>
<p>Booleans indicating whether a time trend was fitted for this time point.</p>
</dd>
<dt>trendVector</dt>
<dd>
<p>coefficient of the time trend in the GLM for this time point. If no trend was fitted it is equal to NA.</p>
</dd>
<dt>pvalue</dt>
<dd>
<p>probability of observing a value at least equal to the observation under the null hypothesis .</p>
</dd>
<dt>expected</dt>
<dd>
<p>expectation of the predictive distribution for each timepoint. 
It is only reported if the conditions for raising an alarm are met (enough cases).</p>
</dd>
<dt>mu0Vector</dt>
<dd>
<p>input for the negative binomial distribution to get the upperbound as a quantile 
(either a plug-in from the GLM or a quantile from the asymptotic normal distribution of the estimator)</p>
</dd>
<dt>phiVector</dt>
<dd>
<p>overdispersion of the GLM at each timepoint.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>M. Salmon, M. HÃ¶hle</p>


<h3>References</h3>

<p>Farrington, C.P., Andrews, N.J, Beale A.D. and Catchpole, M.A. (1996):
A statistical algorithm for the early detection of outbreaks of
infectious disease. J. R. Statist. Soc. A, 159, 547-563.
</p>
<p>Noufaily, A., Enki, D.G., Farrington, C.P., Garthwaite, P., Andrews,
N.J., Charlett, A. (2012): An improved algorithm for outbreak
detection in multiple surveillance systems. Statistics in Medicine,
32 (7), 1206-1222.
</p>
<p>Salmon, M., Schumacher, D. and HÃ¶hle, M. (2016):
Monitoring count time series in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: Aberration detection in public
health surveillance. <em>Journal of Statistical Software</em>,
<b>70</b> (10), 1-35. <a href="https://doi.org/10.18637/jss.v070.i10">doi:10.18637/jss.v070.i10</a>
</p>


<h3>See Also</h3>

<p><code>algo.farrington.fitGLM</code>,<code>algo.farrington.threshold</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data("salmonella.agona")
# Create the corresponding sts object from the old disProg object
salm &lt;- disProg2sts(salmonella.agona)

### RUN THE ALGORITHMS WITH TWO DIFFERENT SETS OF OPTIONS
control1 &lt;-  list(range=282:312,
                  noPeriods=1,
                  b=4, w=3, weightsThreshold=1,
                  pastWeeksNotIncluded=3,
                  pThresholdTrend=0.05,
                  alpha=0.1)
control2 &lt;- list(range=282:312,
                 noPeriods=10,
                 b=4, w=3, weightsThreshold=2.58,
                 pastWeeksNotIncluded=26,
                 pThresholdTrend=1,
                 alpha=0.1)
salm1 &lt;- farringtonFlexible(salm,control=control1)
salm2 &lt;- farringtonFlexible(salm,control=control2)

### PLOT THE RESULTS
y.max &lt;- max(upperbound(salm1),observed(salm1),upperbound(salm2),na.rm=TRUE)
plot(salm1, ylim=c(0,y.max), main='S. Newport in Germany', legend.opts=NULL)
lines(1:(nrow(salm1)+1)-0.5,
      c(upperbound(salm1),upperbound(salm1)[nrow(salm1)]),
      type="s",col='tomato4',lwd=2)
lines(1:(nrow(salm2)+1)-0.5,
      c(upperbound(salm2),upperbound(salm2)[nrow(salm2)]),
      type="s",col="blueviolet",lwd=2)
legend("topleft",
       legend=c('Alarm','Upperbound with old options',
                'Upperbound with new options'),
       pch=c(24,NA,NA),lty=c(NA,1,1),
       bg="white",lwd=c(2,2,2),col=c('red','tomato4',"blueviolet"))
</code></pre>


</div>