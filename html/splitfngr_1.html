<div class="container">

<table style="width: 100%;"><tr>
<td>fngr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Access a list of values separately but calculate them together.
This function generalizes grad_share for any number of functions.</h2>

<h3>Description</h3>

<p>Access a list of values separately but calculate them together.
This function generalizes grad_share for any number of functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fngr(func, evalForNewX = TRUE, recalculate_indices = c(),
  check_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>Function that returns a list of values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalForNewX</code></td>
<td>
<p>Should the function reevaluate for any new x?
Recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recalculate_indices</code></td>
<td>
<p>Indices for which the values should
be recalculated. Ignored if evalForNewX is true. Use this if
you don't want to pass x to dependent functions, or if you know
other indices won't need to be recalculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_all</code></td>
<td>
<p>Should it check that the accessed values were
calculated at the current input? Ignored if evalForNewX is true.
Will give a warning but still return the stored value.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An environment where the function values are calculated.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tfunc &lt;- function(x) {list(x+1, x+2, x+3, x+4, x+5)}
f &lt;- fngr(tfunc)
f(1)(0)
f(3)(0)
f(3)(1)
f(1)(23.4)
f(4)()

# Use same function but only recalculate when first value is called
g &lt;- fngr(tfunc, evalForNewX = FALSE, recalculate_indices = c(1))
g1 &lt;- g(1)
g3 &lt;- g(3)
g1(1)
g3(1)
g3(11) # This won't be give expected value
g1(11) # This updates all values
g3(11) # This is right
</code></pre>


</div>