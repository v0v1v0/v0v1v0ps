<div class="container">

<table style="width: 100%;"><tr>
<td>seriate_best</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Best Seriation</h2>

<h3>Description</h3>

<p>Often the best seriation method for a particular dataset is not know and
heuristics may produce unstable results.
<code>seriate_best()</code> and <code>seriate_rep()</code> automatically try different seriation methods or
rerun randomized methods several times to find the best and order
given a criterion measure. <code>seriate_improve()</code> uses a local improvement strategy
to imporve an existing solution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seriate_best(
  x,
  methods = NULL,
  control = NULL,
  criterion = NULL,
  rep = 10L,
  parallel = TRUE,
  verbose = TRUE,
  ...
)

seriate_rep(
  x,
  method = NULL,
  control = NULL,
  criterion = NULL,
  rep = 10L,
  parallel = TRUE,
  verbose = TRUE,
  ...
)

seriate_improve(
  x,
  order,
  criterion = NULL,
  control = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>a vector of character string with the name of the seriation
methods to try.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control options passed on to <code>seriate()</code>.
For <code>seriate_best()</code> control needs to be a named list of control lists
with the names matching the seriation methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p><code>seriate_rep()</code> chooses the criterion specified for the
method in the registry. A character string with the criterion to optimize
can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep</code></td>
<td>
<p>number of times to repeat the randomized seriation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical; perform replications in parallel.
Uses <code>foreach::foreach()</code> if a
<code style="white-space: pre;">⁠%dopar%⁠</code> backend (e.g., doParallel::doParallel) is registered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; show progress and results for different methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments are passed on to the <code>seriate()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string with the name of the seriation method
(default: varies by data type).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a <code>ser_permutation</code> object for <code>x</code> or the name of a seriation method to start with.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>seriate_rep()</code> rerun a randomized seriation methods to find the best solution
given the criterion specified for the method in the registry.
A specific criterion can also be specified.
Non-stochastic methods are automatically only run once.
</p>
<p><code>seriate_best()</code> runs a set of methods and returns the best result given a
criterion. Stochastic methods are automatically randomly restarted several times.
</p>
<p><code>seriate_improve()</code> improves a seriation order using simulated annealing using
a specified criterion measure. It uses <code>seriate()</code> with method "<code>GSA</code>",
a reduced probability to accept bad moves, and a lower minimum temperature. Control
parameters for this method are accepted.
</p>
<p><strong>Criterion</strong>
</p>
<p>If no criterion is specified, ten the criterion specified for the method in
the registry (see <code style="white-space: pre;">⁠[get_seriation_method()]⁠</code>) is used. For methods with no
criterion in the registry (marked as "other"), a default method is used.
The defaults are:
</p>

<ul>
<li> <p><code>dist</code>: <code>"AR_deviations"</code> - the study in Hahsler (2007) has shown that this
criterion has high similarity with most other criteria.
</p>
</li>
<li> <p><code>matrix</code>: "Moore_stress"
</p>
</li>
</ul>
<p><strong>Parallel Execution</strong>
</p>
<p>Some methods support for parallel execution is provided using the
foreach package. To
use parallel execution, a suitable backend needs to be registered (see
the Examples section for using the doParallel backend).
</p>


<h3>Value</h3>

<p>Returns an object of class ser_permutation.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Hahsler, M. (2017): An experimental comparison of seriation methods for
one-mode two-way data. <em>European Journal of Operational Research,</em>
<b>257</b>, 133–143.
<a href="https://doi.org/10.1016/j.ejor.2016.08.066">doi:10.1016/j.ejor.2016.08.066</a>
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code>register_DendSer()</code>,
<code>register_GA()</code>,
<code>register_optics()</code>,
<code>register_smacof()</code>,
<code>register_tsne()</code>,
<code>register_umap()</code>,
<code>registry_for_seriaiton_methods</code>,
<code>seriate()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(SupremeCourt)
d_supreme &lt;- as.dist(SupremeCourt)

# find best seriation order (tries by by default several fast methods)
o &lt;- seriate_best(d_supreme, criterion = "AR_events")
o
pimage(d_supreme, o)

# run a randomized algorithms several times. It automatically chooses the
# LS criterion. Repetition information is returned as attributes
o &lt;- seriate_rep(d_supreme, "QAP_LS", rep = 5)

attr(o, "criterion")
hist(attr(o, "criterion_distribution"))
pimage(d_supreme, o)

## Not run: 
# Using parallel execution on a larger dataset
data(iris)
m_iris &lt;- as.matrix(iris[sample(seq(nrow(iris))),-5])
d_iris &lt;- dist(m_iris)

library(doParallel)
registerDoParallel(cores = detectCores() - 1L)

# seriate rows of the iris data set
o &lt;- seriate_best(d_iris, criterion = "LS")
o

pimage(d_iris, o)

# improve the order to minimize RGAR instead of LS
o_improved &lt;- seriate_improve(d_iris, o, criterion = "RGAR")
pimage(d_iris, o_improved)

# available control parameters for seriate_improve()
get_seriation_method(name = "GSA")

## End(Not run)
</code></pre>


</div>