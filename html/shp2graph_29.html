<div class="container">

<table style="width: 100%;"><tr>
<td>readshpnw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read a network from a “SpatialLines” or “SpatialLinesDataFrame” object</h2>

<h3>Description</h3>

<p>A function to read a spatial network from a “SpatialLines” or “SpatialLinesDataFrame” object,
and resolve it into a  “nodelist” and “edgelist” for the following conversion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">readshpnw(ntdata, ELComputed=FALSE, longlat=FALSE, Detailed=FALSE, ea.prop=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ntdata</code></td>
<td>
<p>A “SpatialLinesDataFrame” or “SpatialLines” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ELComputed</code></td>
<td>
<p>If TRUE, the length of each edge will be calculated and returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>If TRUE, distances on an ellipse with WGS84 parameters will be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Detailed</code></td>
<td>
<p>If TRUE, all the vertices within the polylines of a spatial network
will be recognised as nodes; if FALSE, only two endpoints of 
each polyline are treated as nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
in the network “ntdata”) with values of 1 or 0:
</p>
<p>1: the corresponding column in the data frame will be kept for 
the new network;
</p>
<p>0: the corresponding column in the data frame will not be kept.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function plays the first step to convert a spatial network (in a “SpatialLines” 
or “SpatialLinesDataFrame” object) into an “igraph” object by returning
a “nodelist” and “edgelist”. 
</p>


<h3>Value</h3>

<p>A list consisted of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Detailed</code></td>
<td>
<p>TRUE if the output is under a “Detailed” mode;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodelist</code></td>
<td>
<p>A “nodelist” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgelist</code></td>
<td>
<p>An “edgelist” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Edgelength</code></td>
<td>
<p>If “ELComputed” is TRUE, lengths of all the edges will be 
returned as a numeric vector; otherwise it will be NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Eadf</code></td>
<td>
<p>A data frame of attributes of the returned edges, of which the structure is
a data frame with [EdgeID,(attributes inherited from the input network data)]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodexlist</code></td>
<td>
<p>A vector contains X-coordinates of all the nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodeylist</code></td>
<td>
<p>A vector contains Y-coordinates of all the nodes</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>Examples</h3>

<pre><code class="language-R">data(ORN)
rtNEL&lt;-readshpnw(ORN.nt)
nl&lt;-rtNEL[[2]]
el&lt;-rtNEL[[3]]
#Compute edge length
rtNEL&lt;-readshpnw(ORN.nt, ELComputed=TRUE)
edgelength&lt;-rtNEL[[4]]
eadf&lt;-rtNEL[[5]]
</code></pre>


</div>