<div class="container">

<table style="width: 100%;"><tr>
<td>Analyse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute estimates and statistics</h2>

<h3>Description</h3>

<p>Compute all relevant test statistics, parameter estimates, detection rates, and so on.
This is the computational heavy lifting portion of the Monte Carlo simulation. Users
may define a single Analysis function to perform all the analyses in the same function environment,
or may define a <code>list</code> of named functions to <code>runSimulation</code> to allow for a more
modularized approach to performing the analyses in independent blocks (but that share the same generated
data). Note that if a suitable <code>Generate</code> function was not supplied then this function
can be used to be generate and analyse the Monte Carlo data (though in general this
setup is not recommended for larger simulations).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Analyse(condition, dat, fixed_objects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>a single row from the design input (as a <code>data.frame</code>), indicating the
simulation conditions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>the <code>dat</code> object returned from the <code>Generate</code> function
(usually a <code>data.frame</code>, <code>matrix</code>, <code>vector</code>, or <code>list</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_objects</code></td>
<td>
<p>object passed down from <code>runSimulation</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In some cases, it may be easier to change the output to a named <code>list</code> containing
different parameter configurations (e.g., when
determining RMSE values for a large set of population parameters).
</p>
<p>The use of <code>try</code> functions is generally not required in this function because <code>Analyse</code>
is internally wrapped in a <code>try</code> call. Therefore, if a function stops early
then this will cause the function to halt internally, the message which triggered the <code>stop</code>
will be recorded, and <code>Generate</code> will be called again to obtain a different dataset.
That said, it may be useful for users to throw their own <code>stop</code> commands if the data
should be re-drawn for other reasons (e.g., an estimated model terminated correctly
but the maximum number of iterations were reached).
</p>


<h3>Value</h3>

<p>returns a named <code>numeric</code> vector or <code>data.frame</code> with the values of interest
(e.g., p-values, effects sizes, etc), or a <code>list</code> containing values of interest
(e.g., separate matrix and vector of parameter estimates corresponding to elements in
<code>parameters</code>). If a <code>data.frame</code> is returned with more than 1 row then these
objects will be wrapped into suitable <code>list</code> objects
</p>


<h3>References</h3>

<p>Chalmers, R. P., &amp; Adkins, M. C.  (2020). Writing Effective and Reliable Monte Carlo Simulations
with the SimDesign Package. <code>The Quantitative Methods for Psychology, 16</code>(4), 248-280.
<a href="https://doi.org/10.20982/tqmp.16.4.p248">doi:10.20982/tqmp.16.4.p248</a>
</p>
<p>Sigal, M. J., &amp; Chalmers, R. P. (2016). Play it again: Teaching statistics with Monte
Carlo simulation. <code>Journal of Statistics Education, 24</code>(3), 136-156.
<a href="https://doi.org/10.1080/10691898.2016.1246953">doi:10.1080/10691898.2016.1246953</a>
</p>


<h3>See Also</h3>

<p><code>stop</code>, <code>AnalyseIf</code>, <code>manageWarnings</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

analyse &lt;- function(condition, dat, fixed_objects) {

    # require packages/define functions if needed, or better yet index with the :: operator
    require(stats)
    mygreatfunction &lt;- function(x) print('Do some stuff')

    #wrap computational statistics in try() statements to control estimation problems
    welch &lt;- t.test(DV ~ group, dat)
    ind &lt;- stats::t.test(DV ~ group, dat, var.equal=TRUE)

    # In this function the p values for the t-tests are returned,
    #  and make sure to name each element, for future reference
    ret &lt;- c(welch = welch$p.value,
             independent = ind$p.value)

    return(ret)
}

# A more modularized example approach

analysis_welch &lt;- function(condition, dat, fixed_objects) {
    welch &lt;- t.test(DV ~ group, dat)
    ret &lt;- c(p=welch$p.value)
    ret
}

analysis_ind &lt;- function(condition, dat, fixed_objects) {
    ind &lt;- t.test(DV ~ group, dat, var.equal=TRUE)
    ret &lt;- c(p=ind$p.value)
    ret
}

# pass functions as a named list
# runSimulation(..., analyse=list(welch=analyse_welch, independent=analysis_ind))


## End(Not run)
</code></pre>


</div>