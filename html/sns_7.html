<div class="container">

<table style="width: 100%;"><tr>
<td>sns</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stochastic Newton Sampler (SNS)</h2>

<h3>Description</h3>

<p>SNS is a Metropolis-Hastings MCMC sampler with a multivariate Gaussian proposal function resulting from a local, second-order Taylor series expansion of log-density. The mean of the Gaussian proposal is identical to the full Newton-Raphson step from the current point. During burn-in, Newton-Raphson optimization can be performed to get close to the mode of the pdf which is unique due to convexity, resulting in faster convergence. For high dimensional densities, state space partitioning can be used to improve mixing. Support for numerical differentiation is provided using <span class="pkg">numDeriv</span> package. <code>sns</code> is the low-level function for drawing one sample from the distribution. For drawing multiple samples from a (fixed) distribution, consider using <code>sns.run</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sns(x, fghEval, rnd = TRUE, gfit = NULL, mh.diag = FALSE
  , part = NULL, numderiv = 0
  , numderiv.method = c("Richardson", "simple")
  , numderiv.args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Current state vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fghEval</code></td>
<td>
<p>Log-density to be sampled from. A valid log-density can have one of 3 forms: 1) return log-density, but no gradient or Hessian, 2) return a list of <code>f</code> and <code>g</code> for log-density and its gradient vector, respectively, 3) return a list of <code>f</code>, <code>g</code>, and <code>h</code> for log-density, gradient vector, and Hessian matrix. Missing derivatives are computed numerically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rnd</code></td>
<td>
<p>Runs 1 iteration of Newton-Raphson optimization method (non-stochastic or 'nr' mode) when <code>FALSE</code>. Runs Metropolis-Hastings (stochastic or 'mcmc' mode) for drawing a sample when <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gfit</code></td>
<td>
<p>Gaussian fit at point <code>init</code>. If <code>NULL</code> then <code>sns</code> will compute a Gaussian fit at <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mh.diag</code></td>
<td>
<p>Boolean flag, indicating whether detailed MH diagnostics such as components of acceptance test must be returned or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>part</code></td>
<td>
<p>List describing partitioning of state space into subsets. Each element of the list must be an integer vector containing a set of indexes (between <code>1</code> and <code>length(x)</code> or <code>length(init)</code>) indicating which subset of all dimensions to jointly sample. These integer vectors must be mutually exclusive and collectively exhaustive, i.e. cover the entire state space and have no duplicates, in order for the partitioning to represent a valid Gibbs sampling approach. See <code>sns.make.part</code> and <code>sns.check.part</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv</code></td>
<td>
<p>Integer with value from the set <code>0,1,2</code>. If <code>0</code>, no numerical differentiation is performed, and thus <code>fghEval</code> is expected to supply <code>f</code>, <code>g</code> and <code>h</code>. If <code>1</code>, we expect <code>fghEval</code> to provide <code>f</code> amd <code>g</code>, and Hessian will be calculated numerically. If <code>2</code>, <code>fghEval</code> only returns log-density, and numerical differentiation is needed to calculate gradient and Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv.method</code></td>
<td>
<p>Method used for numeric differentiation. This is passed to the <code>grad</code> and <code>hessian</code> functions in <span class="pkg">numDeriv</span> package. See the package documentation for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv.args</code></td>
<td>
<p>Arguments to the numeric differentiation method chosen in <code>numderiv.method</code>, passed to <code>grad</code> and <code>hessian</code> functions in <span class="pkg">numDeriv</span>. See package documentation for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to <code>fghEval</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>sns</code> returns the sample drawn as a vector, with attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>accept</code></td>
<td>
<p>A boolean indicating whether the proposed point was accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll</code></td>
<td>
<p>Value of the log-density at the sampled point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gfit</code></td>
<td>
<p>List containing Gaussian fit to pdf at the sampled point.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>1. Since SNS makes local Gaussian approximations to the density with the covariance matrix of the Gaussian proposal being the log-density Hessian, there is a strict requirement for the log-density to be concave.  
</p>
<p>2. Proving log-concavity for arbitrary probability distributions is non-trvial. However, distributions <em>generated</em> by replacing parameters of a concave distribution with linear expressions are known to be log-concave. This negative-definiteness invariance as well as expressions for full gradient and Hessian in terms of derivatives of low-dimensional base distributions are discussed in the vignette. The GLM expansion framework is available in the R package <span class="pkg">RegressionFactory</span>.
</p>
<p>3. See package vignette for more details on SNS theory, software, examples, and performance.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Asad Hasan, Marshall Jiang, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Mahani A.S., Hasan A., Jiang M. &amp;  Sharabiani M.T.A. (2016). Stochastic Newton Sampler: The R Package sns. Journal of Statistical Software, Code Snippets, 74(2), 1-33. doi:10.18637/jss.v074.c02
</p>
<p>Hastings, W. K. (1970). Monte Carlo sampling methods using Markov chains and their applications. Biometrika, 57(1), 97-109.
</p>
<p>Qi, Y., &amp; Minka, T. P. (2002). Hessian-based markov chain monte-carlo algorithms. 1st Cape Cod Workshop on Monte Carlo Methods.
</p>


<h3>See Also</h3>

<p><code>sns.run</code>, <code>sns.fghEval.numaug</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# using RegressionFactory for generating log-likelihood and its derivatives
library(RegressionFactory)

loglike.poisson &lt;- function(beta, X, y) {
  regfac.expand.1par(beta, X = X, y = y,
                     fbase1 = fbase1.poisson.log)
}

# simulating data
K &lt;- 5
N &lt;- 1000
X &lt;- matrix(runif(N * K, -0.5, +0.5), ncol = K)
beta &lt;- runif(K, -0.5, +0.5)
y &lt;- rpois(N, exp(X %*% beta))

beta.init &lt;- rep(0.0, K)

# glm estimate, for reference
beta.glm &lt;- glm(y ~ X - 1, family = "poisson",
                start = beta.init)$coefficients

# running SNS in non-stochastic mode
# this should produce results very close to glm
beta.sns &lt;- beta.init
for (i in 1:20)
  beta.sns &lt;- sns(beta.sns, loglike.poisson, X = X, y = y, rnd = F)

# comparison
all.equal(as.numeric(beta.glm), as.numeric(beta.sns))

# trying numerical differentiation
loglike.poisson.fonly &lt;- function(beta, X, y) {
  regfac.expand.1par(beta, X = X, y = y, fgh = 0,
                     fbase1 = fbase1.poisson.log)
}

beta.sns.numderiv &lt;- beta.init
for (i in 1:20)
  beta.sns.numderiv &lt;- sns(beta.sns.numderiv, loglike.poisson.fonly
                  , X = X, y = y, rnd = F, numderiv = 2)
all.equal(as.numeric(beta.glm), as.numeric(beta.sns.numderiv))

# add numerical derivatives to fghEval outside sns
loglike.poisson.numaug &lt;- sns.fghEval.numaug(loglike.poisson.fonly
  , numderiv = 2)

beta.sns.numaug &lt;- beta.init
for (i in 1:20)
  # set numderiv to 0 to avoid repeating 
  # numerical augmentation inside sns
  beta.sns.numaug &lt;- sns(beta.sns.numaug, loglike.poisson.numaug
                           , X = X, y = y, rnd = F, numderiv = 0)
all.equal(as.numeric(beta.glm), as.numeric(beta.sns.numaug))


## End(Not run)
</code></pre>


</div>