<div class="container">

<table style="width: 100%;"><tr>
<td>sbss_boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Different Bootstrap Tests for the White Noise Dimension in a Spatial Blind Source Separation Model
</h2>

<h3>Description</h3>

<p><code>sbss_boot</code> uses bootstrap tests for the spatial blind source separation (SBSS) methodology to test if the last <code class="reqn">p - q</code> entries of the latent random field are white noise assuming that the <code class="reqn">p</code>-variate observed random field follows a SBSS model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sbss_boot(x, ...)

## Default S3 method:
sbss_boot(x, coords, q, kernel_parameters, 
          boot_method = c('permute', 'parametric'), 
          n_boot = 200, kernel_list = NULL, ...) 
## S3 method for class 'SpatialPointsDataFrame'
sbss_boot(x, ...)
## S3 method for class 'sf'
sbss_boot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code>SpatialPointsDataFrame</code> or an object of class <code>sf</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>

<p>an integer between <code>0</code> and <code>p - 1</code> specifying the number of hypothetical signal components (null hypothesis) in the latent random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the ring kernel function. At least length of two, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_method</code></td>
<td>

<p>a string indicating which bootstrap strategy is used, see details. Either <code>'permute'</code> (default) or <code>'parametric'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_boot</code></td>
<td>

<p>positive integer specifying the number of bootstrap samples. Default is <code class="reqn">200</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code>frjd</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses the SBSS methodology in conjunction with local covariance matrices based on ring kernel functions to estimate the <code class="reqn">p</code>-variate latent random field <code class="reqn">s = x^{wh} w</code>, where <code class="reqn">x^{wh}</code> is the whitened version of the data and <code class="reqn">w</code> is the estimated unmixing matrix. The considered (adapted) local covariance matrices write as
</p>
<p style="text-align: center;"><code class="reqn"> LCov^* = 1/(n F^{1/2}_n) \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})'</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> F_n = 1 / n \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o).</code>
</p>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code> (which is the i-th row of the argument <code>x</code> and the location corresponds to the i-th row of the argument <code>coords</code>) and <code class="reqn">\bar{x}</code> is the sample mean vector. The function argument <code>kernel_parameters</code> determines the parameters of the used ring kernel functions or alternatively a list of kernel matrices can be given with the argument <code>kernel_list</code>, see <code>sbss</code> for details. 
</p>
<p>The null hypothesis specified with the argument <code>q</code> states that the last <code class="reqn">p - q</code> components of the estimated latent field are white noise. The method orders the components of the latent field by the order of the decreasing sums of squares of the corresponding (pseudo-)eigenvalues of the local covariance matrices produced by the joint diagonalization algorithm (or the eigendecomposition if only one local covariance matrix is used). Under the null the lower right <code class="reqn">(p - q) * (p - q)</code> block matrices of the jointly diagonalized local covariance matrices equal zero matrices. Therefore, the sum of their squared norms <code class="reqn">m</code> is used as test statistic for the bootstrap based inference methods described below. 
</p>

<ol>
<li>
<p> Compute the test statistic <code class="reqn">m</code> based on the original data <code class="reqn">x</code>.
</p>
</li>
<li>
<p> The estimated latent field <code class="reqn">s</code> (its dimension is <code>c(n,p)</code>) is split into the signal part (first <code>q</code> columns) and the white noise part (last <code>p - q</code> columns).
</p>
</li>
<li>
<p> Replace the noise part by a bootstrap sample drawn based on one of the two strategies described below.
</p>
</li>
<li>
<p> Recombine the signal part and resampled noise part by concatenating the columns leading to <code class="reqn">s^{bs}</code> and back-transform it by <code class="reqn">x^{bs} = s^{bs}  w^{-1}</code>.
</p>
</li>
<li>
<p> Compute the test statistic <code class="reqn">m^{bs}</code> based on <code class="reqn">x^{bs}</code>.
</p>
</li>
<li>
<p> Repeat Step 2 - 5 for a total amount of <code>n_boot</code> times (default is <code>200</code>) and the p-value of the bootstrap test is computed by
</p>
<p style="text-align: center;"><code class="reqn"> (sum(m &gt; m^{bs}) + 1) / (n_{boot} + 1). </code>
</p>

</li>
</ol>
<p>The argument <code>boot_method</code> (default is <code>"permute"</code>) specifies the used resample strategy. The two following strategies are implemented:
</p>

<ul>
<li> <p><code>boot_method = "permute"</code>: 
This strategy is non-parametric. It draws each bootstrap sample from the vector of all <code class="reqn">n(p - q)</code> observed hypothetical white noise observations.
</p>
</li>
<li> <p><code>boot_method = "parametric"</code>: 
This is parametric. Each bootstrap sample is drawn independently and identically from the standard normal distribution.
</p>
</li>
</ul>
<p>If more than one local covariance matrix is used <code>sbss_boot</code> jointly diagonalizes these matrices with the function <code>frjd</code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>sbss_boot</code> returns a list of class <code>'sbss_test'</code> inheriting from the classes <code>'htest'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>

<p>a string containing the alternative hypothesis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>a string which indicates which test methods was used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>

<p>a string specifying the name of the used data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>

<p>a integer specifying the number of generated bootstrap samples (the value of the argument <code>n_boot</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>

<p>the p-value of the test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>sbss_boot</code> call.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c((length(kernel_parameters) / 2)*p,p)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>spatial_kernel_matrix</code>, <code>local_covariance_matrix</code>, <code>sp</code>, 
<code>sf</code>, <code>frjd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- rnorm(n)
  field_4 &lt;- rnorm(n)
  
  latent_field &lt;- cbind(as.matrix(cbind(field_1, field_2)), field_3, field_4)
  mixing_matrix &lt;- matrix(rnorm(16), 4, 4)
  observed_field &lt;- latent_field %*% t(mixing_matrix)
  
  # apply the bootstrap tests for a hypothetical latent white noise dimension of q
  # q can lie between 0 and 3 in this case
  # using one ring kernel function with the permute strategy
  # and the null hypothesis q = 1
  boot_res_1 &lt;- 
    sbss_boot(observed_field, coords, q = 1, kernel_parameters = c(0, 1), 
              boot_method = 'permute', n_boot = 100)
  
  # using two one ring kernel function with the parametric strategy
  # and the null hypothesis q = 3
  boot_res_2 &lt;- 
    sbss_boot(observed_field, coords, q = 3, kernel_parameters = c(0, 1, 1, 2), 
              boot_method = 'parametric', n_boot = 100)
    
  # the result is of class sbss_test which is inherited from htest and sbss
  # print object (print method for an object of class htest)
  print(boot_res_1)
  print(boot_res_2)
  
  # plot latent field (plot method for an object of class sbss)
  plot(boot_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid (predict method for an object of class sbss)
  predict(boot_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix (coef method for an object of class sbss)
  w_unmix &lt;- coef(boot_res_1)
}

</code></pre>


</div>