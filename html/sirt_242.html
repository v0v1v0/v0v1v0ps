<div class="container">

<table style="width: 100%;"><tr>
<td>nedelsky-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Functions for the Nedelsky Model
</h2>

<h3>Description</h3>

<p>Functions for simulating and estimating the Nedelsky model
(Bechger et al., 2003, 2005). <code>nedelsky.sim</code> can be used for
simulating the model, <code>nedelsky.irf</code> computes the item response
function and can be used for example when estimating the
Nedelsky model in the <span class="pkg">mirt</span> package or using the
<code>xxirt</code> function in the <span class="pkg">sirt</span> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># simulating the Nedelsky model
nedelsky.sim(theta, b, a=NULL, tau=NULL)

# creating latent responses of the Nedelsky model
nedelsky.latresp(K)

# computing the item response function of the Nedelsky model
nedelsky.irf(Theta, K, b, a, tau, combis, thdim=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>

<p>Unidimensional ability (theta)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>

<p>Matrix of category difficulties
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>

<p>Vector of item discriminations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>Category attractivity parameters <code class="reqn">\tau</code> (see Bechger et al., 2005)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>(Maximum) Number of distractors of the used multiple choice items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>

<p>Theta vector. Note that the Nedelsky model can be only specified
as models with between item dimensionality (defined in <code>thdim</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combis</code></td>
<td>

<p>Latent response classes as produced by <code>nedelsky.latresp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thdim</code></td>
<td>

<p>Theta dimension at which the item loads
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assume that for item <code class="reqn">i</code> there exists <code class="reqn">K+1</code> categories <code class="reqn">0,1,...,K</code>.
The category 0 denotes the correct alternative. The Nedelsky model assumes
that a respondent eliminates all distractors which are thought to be
incorrect and guesses the solution from the remaining alternatives.
This means, that for item <code class="reqn">i</code>, <code class="reqn">K</code> latent variables <code class="reqn">S_{ik}</code>
are defined which indicate whether alternative <code class="reqn">k</code> has been correctly
identified as a distractor. By definition, the correct alternative is never
been judged as wrong by the respondent.
</p>
<p>Formally, the Nedelsky model assumes a 2PL model for eliminating each of the
distractors
</p>
<p style="text-align: center;"><code class="reqn">P(S_{ik}=1 | \theta )=invlogit[ a_i ( \theta - b_{ik} ) ] </code>
</p>

<p>where <code class="reqn">\theta</code> is the person ability and <code class="reqn">b_{ik}</code> are
distractor difficulties.
</p>
<p>The guessing process of the Nedelsky model is defined as
</p>
<p style="text-align: center;"><code class="reqn">P(X_i=j | \theta, S_{i1}, ..., S_{iK} )=
\frac{ ( 1- S_{ij} ) \tau_{ij} }{ \sum_{k=0}^K [ ( 1- S_{ik} ) \tau_{ik} ] }</code>
</p>

<p>where <code class="reqn">\tau_{ij}</code> are attractivity parameters of alternative <code class="reqn">j</code>.
By definition <code class="reqn">\tau_{i0}</code> is set to 1. By default, all attractivity parameters
are set to 1.
</p>


<h3>References</h3>

<p>Bechger, T. M., Maris, G., Verstralen, H. H. F. M., &amp; Verhelst, N. D. (2003).
<em>The Nedelsky model for multiple-choice items</em>.
CITO Research Report, 2003-5.
</p>
<p>Bechger, T. M., Maris, G., Verstralen, H. H. F. M., &amp; Verhelst, N. D. (2005).
The Nedelsky model for multiple-choice items.
In L. van der Ark, M. Croon, &amp; Sijtsma, K. (Eds.).
<em>New developments in categorical data analysis for the social and behavioral
sciences</em>, pp. 187-206. Mahwah, Lawrence Erlbaum.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: Simulated data according to the Nedelsky model
#############################################################################

#*** simulate data
set.seed(123)
I &lt;- 20          # number of items
b &lt;- matrix(NA,I,ncol=3)
b[,1] &lt;- -0.5 + stats::runif( I, -.75, .75 )
b[,2] &lt;- -1.5 + stats::runif( I, -.75, .75 )
b[,3] &lt;- -2.5 + stats::runif( I, -.75, .75 )
K &lt;- 3           # number of distractors
N &lt;- 2000        # number of persons
# apply simulation function
dat &lt;- sirt::nedelsky.sim( theta=stats::rnorm(N,sd=1.2), b=b )

#*** latent response patterns
K &lt;- 3
combis &lt;- sirt::nedelsky.latresp(K=3)

#*** defining the Nedelsky item response function for estimation in mirt
par &lt;- c( 3, rep(-1,K), 1, rep(1,K+1),1)
names(par) &lt;- c("K", paste0("b",1:K), "a", paste0("tau", 0:K),"thdim")
est &lt;- c( FALSE, rep(TRUE,K), rep(FALSE, K+1 + 2 ) )
names(est) &lt;- names(par)
nedelsky.icc &lt;- function( par, Theta, ncat ){
     K &lt;- par[1]
     b &lt;- par[ 1:K + 1]
     a &lt;- par[ K+2]
     tau &lt;- par[1:(K+1) + (K+2) ]
     thdim &lt;- par[ K+2+K+1 +1 ]
     probs &lt;- sirt::nedelsky.irf( Theta, K=K, b=b, a=a, tau=tau, combis,
                    thdim=thdim  )$probs
     return(probs)
}
name &lt;- "nedelsky"
# create item response function
nedelsky.itemfct &lt;- mirt::createItem(name, par=par, est=est, P=nedelsky.icc)

#*** define model in mirt
mirtmodel &lt;- mirt::mirt.model("
           F1=1-20
           COV=F1*F1
           # define some prior distributions
           PRIOR=(1-20,b1,norm,-1,2),(1-20,b2,norm,-1,2),
                   (1-20,b3,norm,-1,2)
        " )

itemtype &lt;- rep("nedelsky", I )
customItems &lt;- list("nedelsky"=nedelsky.itemfct)
# define parameters to be estimated
mod1.pars &lt;- mirt::mirt(dat, mirtmodel, itemtype=itemtype,
                   customItems=customItems, pars="values")
# estimate model
mod1 &lt;- mirt::mirt(dat,mirtmodel, itemtype=itemtype, customItems=customItems,
               pars=mod1.pars, verbose=TRUE  )
# model summaries
print(mod1)
summary(mod1)
mirt.wrapper.coef( mod1 )$coef
mirt.wrapper.itemplot(mod1,ask=TRUE)

#******************************************************
# fit Nedelsky model with xxirt function in sirt

# define item class for xxirt
item_nedelsky &lt;- sirt::xxirt_createDiscItem( name="nedelsky", par=par,
                est=est, P=nedelsky.icc,
                prior=c( b1="dnorm", b2="dnorm", b3="dnorm" ),
                prior_par1=c( b1=-1, b2=-1, b3=-1),
                prior_par2=c(b1=2, b2=2, b3=2) )
customItems &lt;- list( item_nedelsky )

#---- definition theta distribution
#** theta grid
Theta &lt;- matrix( seq(-6,6,length=21), ncol=1 )
#** theta distribution
P_Theta1 &lt;- function( par, Theta, G){
    mu &lt;- par[1]
    sigma &lt;- max( par[2], .01 )
    TP &lt;- nrow(Theta)
    pi_Theta &lt;- matrix( 0, nrow=TP, ncol=G)
    pi1 &lt;- dnorm( Theta[,1], mean=mu, sd=sigma )
    pi1 &lt;- pi1 / sum(pi1)
    pi_Theta[,1] &lt;- pi1
    return(pi_Theta)
}
#** create distribution class
par_Theta &lt;- c( "mu"=0, "sigma"=1 )
customTheta &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta, est=c(FALSE,TRUE),
                   P=P_Theta1 )

#-- create parameter table
itemtype &lt;- rep( "nedelsky", I )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype, customItems=customItems)

# estimate model
mod2 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable, customItems=customItems,
                    customTheta=customTheta)
summary(mod2)
# compare sirt::xxirt and mirt::mirt
logLik(mod2)
mod1@Fit$logLik

#############################################################################
# EXAMPLE 2: Multiple choice dataset data.si06
#############################################################################

data(data.si06)
dat &lt;- data.si06

#*** create latent responses
combis &lt;- sirt::nedelsky.latresp(K)
I &lt;- ncol(dat)
#*** define item response function
K &lt;- 3
par &lt;- c( 3, rep(-1,K), 1, rep(1,K+1),1)
names(par) &lt;- c("K", paste0("b",1:K), "a", paste0("tau", 0:K),"thdim")
est &lt;- c( FALSE, rep(TRUE,K), rep(FALSE, K+1 + 2 ) )
names(est) &lt;- names(par)
nedelsky.icc &lt;- function( par, Theta, ncat ){
     K &lt;- par[1]
     b &lt;- par[ 1:K + 1]
     a &lt;- par[ K+2]
     tau &lt;- par[1:(K+1) + (K+2) ]
     thdim &lt;- par[ K+2+K+1 +1 ]
     probs &lt;- sirt::nedelsky.irf( Theta, K=K, b=b, a=a, tau=tau, combis,
                    thdim=thdim  )$probs
     return(probs)
}
name &lt;- "nedelsky"
# create item response function
nedelsky.itemfct &lt;- mirt::createItem(name, par=par, est=est, P=nedelsky.icc)

#*** define model in mirt
mirtmodel &lt;- mirt::mirt.model("
           F1=1-14
           COV=F1*F1
           PRIOR=(1-14,b1,norm,-1,2),(1-14,b2,norm,-1,2),
                   (1-14,b3,norm,-1,2)
        " )

itemtype &lt;- rep("nedelsky", I )
customItems &lt;- list("nedelsky"=nedelsky.itemfct)
# define parameters to be estimated
mod1.pars &lt;- mirt::mirt(dat, mirtmodel, itemtype=itemtype,
                   customItems=customItems, pars="values")

#*** estimate model
mod1 &lt;- mirt::mirt(dat,mirtmodel, itemtype=itemtype, customItems=customItems,
               pars=mod1.pars, verbose=TRUE )
#*** summaries
print(mod1)
summary(mod1)
mirt.wrapper.coef( mod1 )$coef
mirt.wrapper.itemplot(mod1,ask=TRUE)

## End(Not run)
</code></pre>


</div>