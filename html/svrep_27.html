<div class="container">

<table style="width: 100%;"><tr>
<td>make_fays_gen_rep_factors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Form replication factors using Fay's generalized replication method</h2>

<h3>Description</h3>

<p>Generate a matrix of replication factors
using Fay's generalized replication method.
This method yields a fully efficient variance estimator
if a sufficient number of replicates is used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_fays_gen_rep_factors(
  Sigma,
  max_replicates = Matrix::rankMatrix(Sigma) + 4,
  balanced = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>A quadratic form matrix corresponding to
a target variance estimator. Must be positive semidefinite.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_replicates</code></td>
<td>
<p>The maximum number of replicates to allow.
The function will attempt to create the minimum number of replicates
needed to produce a fully-efficient variance estimator.
If more replicates are needed than <code>max_replicates</code>, then the full number of replicates
needed will be created, but only a random subsample will be retained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balanced</code></td>
<td>
<p>If <code>balanced=TRUE</code>, the replicates
will all contribute equally to variance estimates, but
the number of replicates needed may slightly increase.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix of replicate factors,
with the number of rows matching the number of rows of <code>Sigma</code>
and the number of columns less than or equal to <code>max_replicates</code>.
To calculate variance estimates using these factors,
use the overall scale factor given by calling
<code>attr(x, "scale")</code> on the result.
</p>


<h3>Statistical Details</h3>

<p>See Fay (1989) for a full explanation of Fay's generalized replication method.
This documentation provides a brief overview.
</p>
<p>Let <code class="reqn">\boldsymbol{\Sigma}</code> be the quadratic form matrix for a target variance estimator,
which is assumed to be positive semidefinite.
Suppose the rank of <code class="reqn">\boldsymbol{\Sigma}</code> is <code class="reqn">k</code>,
and so <code class="reqn">\boldsymbol{\Sigma}</code> can be represented by the spectral decomposition
of <code class="reqn">k</code> eigenvectors and eigenvalues, where the <code class="reqn">r</code>-th eigenvector and eigenvalue
are denoted <code class="reqn">\mathbf{v}_{(r)}</code> and <code class="reqn">\lambda_r</code>, respectively.
</p>
<p style="text-align: center;"><code class="reqn">
\boldsymbol{\Sigma} = \sum_{r=1}^k \lambda_r \mathbf{v}_{(r)} \mathbf{v^{\prime}}_{(r)}
</code>
</p>

<p>If <code>balanced = FALSE</code>, then we let <code class="reqn">\mathbf{H}</code> denote an identity matrix
with <code class="reqn">k' = k</code> rows/columns. If <code>balanced = TRUE</code>, then we let <code class="reqn">\mathbf{H}</code> be a Hadamard matrix (with all entries equal to <code class="reqn">1</code> or <code class="reqn">-1</code>),
of order <code class="reqn">k^{\prime} \geq k</code>. Let <code class="reqn">\mathbf{H}_{mr}</code> denote the entry in row
<code class="reqn">m</code> and column <code class="reqn">r</code> of <code class="reqn">\mathbf{H}</code>.
</p>
<p>Then <code class="reqn">k^{\prime}</code> replicates are formed as follows.
Let <code class="reqn">r</code> denote a given replicate, with <code class="reqn">r = 1, ..., k^{\prime}</code>,
and let <code class="reqn">c</code> denote some positive constant (yet to be specified).
</p>
<p>The <code class="reqn">r</code>-th replicate adjustment factor <code class="reqn">\mathbf{f}_{r}</code> is formed as:
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{f}_{r} = 1 + c \sum_{m=1}^k H_{m r} \lambda_{(m)}^{\frac{1}{2}} \mathbf{v}_{(m)}
</code>
</p>

<p>If <code>balanced = FALSE</code>, then <code class="reqn">c = 1</code>. If <code>balanced = TRUE</code>,
then <code class="reqn">c = \frac{1}{\sqrt{k^{\prime}}}</code>.
</p>
<p>If any of the replicates
are negative, you can use <code>rescale_reps</code>,
which recalculates the replicate factors with a smaller value of <code class="reqn">c</code>.
</p>
<p>If all <code class="reqn">k^{\prime}</code> replicates are used, then variance estimates are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
  v_{rep}\left(\hat{T}_y\right) = \sum_{r=1}^{k^{\prime}}\left(\hat{T}_y^{*(r)}-\hat{T}_y\right)^2
</code>
</p>

<p>For population totals, this replication variance estimator
will <em>exactly</em> match the target variance estimator
if the number of replicates <code class="reqn">k^{\prime}</code> matches the rank of <code class="reqn">\Sigma</code>.
</p>


<h3>The Number of Replicates</h3>

<p>If <code>balanced=TRUE</code>, the number of replicates created
may need to increase slightly.
This is due to the fact that a Hadamard matrix
of order <code class="reqn">k^{\prime} \geq k</code> is used to balance the replicates,
and it may be necessary to use order <code class="reqn">k^{\prime} &gt; k</code>.
</p>
<p>If the number of replicates <code class="reqn">k^{\prime}</code> is too large for practical purposes,
then one can simply retain only a random subset of <code class="reqn">R</code> of the <code class="reqn">k^{\prime}</code> replicates.
In this case, variances are calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  v_{rep}\left(\hat{T}_y\right) = \frac{k^{\prime}}{R} \sum_{r=1}^{R}\left(\hat{T}_y^{*(r)}-\hat{T}_y\right)^2
</code>
</p>

<p>This is what happens if <code>max_replicates</code> is less than the
matrix rank of <code>Sigma</code>: only a random subset
of the created replicates will be retained.
</p>
<p>Subsampling replicates is only recommended when
using <code>balanced=TRUE</code>, since in this case every replicate
contributes equally to variance estimates. If <code>balanced=FALSE</code>,
then randomly subsampling replicates is valid but may
produce large variation in variance estimates since replicates
in that case may vary greatly in their contribution to variance
estimates.
</p>


<h3>Reproducibility</h3>

<p>If <code>balanced=TRUE</code>, a Hadamard matrix
is used as described above. The Hadamard matrix is
deterministically created using the function
<code>hadamard()</code> from the 'survey' package.
However, the order of rows/columns is randomly permuted
before forming replicates.
</p>
<p>In general, column-ordering of the replicate weights is random.
To ensure exact reproducibility, it is recommended to call
<code>set.seed()</code> before using this function.
</p>


<h3>References</h3>

<p>Fay, Robert. 1989.
"Theory And Application Of Replicate Weighting For Variance Calculations."
In, 495â€“500. Alexandria, VA: American Statistical Association.
http://www.asasrms.org/Proceedings/papers/1989_033.pdf
</p>


<h3>See Also</h3>

<p>Use <code>rescale_reps</code> to eliminate negative adjustment factors.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  library(survey)

# Load an example dataset that uses unequal probability sampling ----
  data('election', package = 'survey')

# Create matrix to represent the Horvitz-Thompson estimator as a quadratic form ----
  n &lt;- nrow(election_pps)
  pi &lt;- election_jointprob
  horvitz_thompson_matrix &lt;- matrix(nrow = n, ncol = n)
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      horvitz_thompson_matrix[i,j] &lt;- 1 - (pi[i,i] * pi[j,j])/pi[i,j]
    }
  }

  ## Equivalently:

  horvitz_thompson_matrix &lt;- make_quad_form_matrix(
    variance_estimator = "Horvitz-Thompson",
    joint_probs = election_jointprob
  )

# Make generalized replication adjustment factors ----

  adjustment_factors &lt;- make_fays_gen_rep_factors(
    Sigma = horvitz_thompson_matrix,
    max_replicates = 50
  )
  attr(adjustment_factors, 'scale')

# Compute the Horvitz-Thompson estimate and the replication estimate

ht_estimate &lt;- svydesign(data = election_pps, ids = ~ 1,
                         prob = diag(election_jointprob),
                         pps = ppsmat(election_jointprob)) |&gt;
  svytotal(x = ~ Kerry)

rep_estimate &lt;- svrepdesign(
  data = election_pps,
  weights = ~ wt,
  repweights = adjustment_factors,
  combined.weights = FALSE,
  scale = attr(adjustment_factors, 'scale'),
  rscales = rep(1, times = ncol(adjustment_factors)),
  type = "other",
  mse = TRUE
) |&gt;
  svytotal(x = ~ Kerry)

SE(rep_estimate)
SE(ht_estimate)
SE(rep_estimate) / SE(ht_estimate)

## End(Not run)
</code></pre>


</div>