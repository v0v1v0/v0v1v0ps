<div class="container">

<table style="width: 100%;"><tr>
<td>biScale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
standardize a matrix to have optionally row means zero and variances one,
and/or column means zero and variances one.
</h2>

<h3>Description</h3>

<p>A function for standardizing a matrix in a symmetric
fashion. Generalizes the <code>scale</code> function in R. Works with
matrices with NAs, matrices of class "Incomplete", and matrix in
"sparseMatrix" format.
</p>


<h3>Usage</h3>

<pre><code class="language-R">biScale(x, maxit = 20, thresh = 1e-09, row.center = TRUE, row.scale =TRUE,
        col.center = TRUE, col.scale = TRUE, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>matrix, possibly with NAs, also of class "Incomplete" or "sparseMatrix" format.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>When both row and column centering/scaling is requested, iteration is
may be necessary
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>

<p>Convergence threshold
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.center</code></td>
<td>

<p>if <code>row.center==TRUE</code> (the default), row centering will be performed resulting in a matrix
with row means zero. If <code>row.center</code> is a vector, it will be used
to center the rows. If <code>row.center=FALSE</code> nothing is done. See details for
more info.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.scale</code></td>
<td>

<p>if <code>row.scale==TRUE</code>, the rows are scaled (after possibly
centering, to have variance one. Alternatively, if a positive vector is
supplied, it is used for row centering. See details for
more info.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.center</code></td>
<td>

<p>Similar to <code>row.center</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.scale</code></td>
<td>

<p>Similar to <code>row.scale</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>with <code>trace=TRUE</code>, convergence progress is reported, when iteration
is needed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes a transformation
</p>
<p style="text-align: center;"><code class="reqn">\frac{X_{ij}-\alpha_i-\beta_j}{\gamma_i\tau_j}</code>
</p>

<p>to transform the matrix <code class="reqn">X</code>. It uses an iterative algorithm based
on "method-of-moments". At each step, all but one of the parameter
vectors is fixed, and the remaining vector is computed to solve the
required condition. Although in genereal this is not guaranteed to
converge,
it mostly does, and quite rapidly. When there are convergence
problems, remove some of the required constraints. When any of the
row/column centers or scales are provided, they are used rather than
estimated in the above model.
</p>


<h3>Value</h3>

<p>A matrix like <code>x</code> is returned, with attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>biScale:row</code></td>
<td>
<p>a list with elements <code>"center"</code> and
<code>"scale"</code> (the <code class="reqn">alpha</code> and <code class="reqn">gamma</code> above. If no
centering was done, the center component will be a vector of
zeros. Likewise, of no row scaling was done, the scale component
will be a vector of ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>biScale:column</code></td>
<td>
<p>Same details as <code>biScale:row</code></p>
</td>
</tr>
</table>
<p>For matrices with missing values, the constraints apply to the
non-missing entries. If <code>x</code> is of class <code>"sparseMatrix"</code>,
then the sparsity is maintained, and an object of class
<code>"SparseplusLowRank"</code> is returned, such that the low-rank part
does the centering.
</p>


<h3>Note</h3>

<p>This function will be described in detail in a forthcoming paper</p>


<h3>Author(s)</h3>

<p>Trevor Hastie, with help from Andreas Buja and Steven Boyd<br>,
Maintainer: Trevor Hastie  <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>See Also</h3>

<p><code>softImpute</code>,<code>Incomplete</code>,<code>lambda0</code>,<code>impute</code>,<code>complete</code>,
and class <code>"SparseplusLowRank"</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(101)
n=200
p=100
J=50
np=n*p
missfrac=0.3
x=matrix(rnorm(n*J),n,J)%*%matrix(rnorm(J*p),J,p)+matrix(rnorm(np),n,p)/5
xc=biScale(x)
ix=seq(np)
imiss=sample(ix,np*missfrac,replace=FALSE)
xna=x
xna[imiss]=NA
xnab=biScale(xna,row.scale=FALSE,trace=TRUE)
xnaC=as(xna,"Incomplete")
xnaCb=biScale(xnaC)
nnz=trunc(np*.3)
inz=sample(seq(np),nnz,replace=FALSE)
i=row(x)[inz]
j=col(x)[inz]
x=rnorm(nnz)
xS=sparseMatrix(x=x,i=i,j=j)
xSb=biScale(xS)
class(xSb)
</code></pre>


</div>