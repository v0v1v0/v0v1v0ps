<div class="container">

<table style="width: 100%;"><tr>
<td>sgPLS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Group Partial Least Squares (sgPLS)</h2>

<h3>Description</h3>

<p>Function to perform  sparse group Partial Least Squares (sgPLS) in the conext of datasets are divided into groups of variables. The sgPLS approach enables selection at both groups and single feature levels.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgPLS(X, Y, ncomp, mode = "regression",
     max.iter = 500, tol = 1e-06, keepX, 
     keepY = NULL,ind.block.x, ind.block.y = NULL, alpha.x, alpha.y = NULL,
     upper.lambda = 10 ^ 5,scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric matrix of predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric vector or matrix of responses (for multi-response models). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>The number of components to include in the model (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use, (partially) matching 
one of <code>"regression"</code> or <code>"canonical"</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Integer, the maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A positive real, the tolerance used in the iterative algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepX</code></td>
<td>
<p>Numeric vector of length <code>ncomp</code>, the number of variables
to keep in <code class="reqn">X</code>-loadings. By default all variables are kept in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepY</code></td>
<td>
<p>Numeric vector of length <code>ncomp</code>, the number of variables
to keep in <code class="reqn">Y</code>-loadings. By default all variables are kept in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.block.x</code></td>
<td>
<p>A vector of integers describing the grouping of the <code class="reqn">X</code> variables. (see an example in Details section).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.block.y</code></td>
<td>
<p>A vector of integers describing the grouping of the <code class="reqn">Y</code> variables (see example in Details section).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.x</code></td>
<td>
<p>The mixing parameter (value between 0 and 1) related to the sparsity within group for the <code class="reqn">X</code> dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.y</code></td>
<td>
<p>The mixing parameter (value between 0 and 1) related to the sparsity within group for the <code class="reqn">Y</code> dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.lambda</code></td>
<td>
<p>By default <code>upper.lambda=10 ^ 5</code>. A large value specifying the upper bound of the intervall of lambda values for searching the value of the tuning parameter (lambda) corresponding to a non-zero group of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating if the orignal data set need to be scaled. By default <code>scale</code>=TRUE</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sgPLS</code> function fit gPLS models with <code class="reqn">1, \ldots ,</code><code>ncomp</code> components. 
Multi-response models are fully supported. 
</p>
<p>The type of algorithm to use is specified with the <code>mode</code> argument. Two gPLS 
algorithms are available: gPLS regression <code>("regression")</code> and gPLS canonical analysis 
<code>("canonical")</code> (see References). 
</p>
<p><code>ind.block.x &lt;- c(3, 10, 15)</code> means that <code class="reqn">X</code> is structured into 4 groups: X1 to X3; X4 to X10, X11 to X15 and X16 to X<code class="reqn">p</code> where <code class="reqn">p</code> is the number of variables in the <code class="reqn">X</code> matrix.</p>


<h3>Value</h3>

<p><code>sgPLS</code> returns an object of class <code>"sgPLS"</code>, a list 
that contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The centered and standardized original predictor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The centered and standardized original response vector or matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>The number of components included in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>The algorithm used to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepX</code></td>
<td>
<p>Number of <code class="reqn">X</code> variables kept in the model on each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepY</code></td>
<td>
<p>Number of <code class="reqn">Y</code> variables kept in the model on each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat.c</code></td>
<td>
<p>Matrix of coefficients to be used internally by <code>predict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variates</code></td>
<td>
<p>List containing the variates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>List containing the estimated loadings for the <code class="reqn">X</code> and 
<code class="reqn">Y</code> variates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>List containing the names to be used for individuals and variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance used in the iterative algorithm, used for subsequent S3 methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>The maximum number of iterations, used for subsequent S3 methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Vector containing the number of iterations for convergence in each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.block.x</code></td>
<td>
<p>A vector of integers describing the grouping of the <code class="reqn">X</code> variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.block.y</code></td>
<td>
<p>A vector of consecutive integers describing the grouping of the <code class="reqn">Y</code> variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.x</code></td>
<td>
<p>The mixing parameter related to the sparsity within group for the <code class="reqn">X</code> dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.y</code></td>
<td>
<p>The mixing parameter related to the sparsity within group for the <code class="reqn">Y</code> dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.lambda</code></td>
<td>
<p>The upper bound of the intervall of lambda values for searching the value of the tuning parameter (lambda) corresponding to a non-zero group of variables.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Benoit Liquet and Pierre Lafaye de Micheaux.</p>


<h3>References</h3>

<p>Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). A group and Sparse Group Partial Least Square approach applied in Genomics context. <em>Bioinformatics</em>.
</p>
<p>Le Cao, K.-A., Martin, P.G.P., Robert-Grani\'e, C. and Besse, P. (2009). Sparse canonical methods for biological data integration: application to a cross-platform study. <em>BMC Bioinformatics</em> <b>10</b>:34.
</p>
<p>Le Cao, K.-A., Rossouw, D., Robert-Grani\'e, C. and Besse, P. (2008). A sparse PLS for variable 
selection when integrating Omics data. <em>Statistical Applications in Genetics and Molecular 
Biology</em> <b>7</b>, article 35.
</p>
<p>Shen, H. and Huang, J. Z. (2008). Sparse principal component analysis via regularized 
low rank matrix approximation. <em>Journal of Multivariate Analysis</em> <b>99</b>, 1015-1034.    
</p>
<p>Tenenhaus, M. (1998). <em>La r\'egression PLS: th\'eorie et pratique</em>. Paris: Editions Technic.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by iterative least squares. 
In: Krishnaiah, P. R. (editors), <em>Multivariate Analysis</em>. Academic Press, N.Y., 391-420.
</p>


<h3>See Also</h3>

<p><code>sPLS</code>, <code>sgPLS</code>, <code>predict</code>, <code>perf</code> and functions from <code>mixOmics</code> package: <code>summary</code>, <code>plotIndiv</code>, <code>plotVar</code>, <code>plot3dIndiv</code>, <code>plot3dVar</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">	
## Simulation of datasets X and Y with group variables
n &lt;- 100
sigma.gamma &lt;- 1
sigma.e &lt;- 1.5
p &lt;- 400
q &lt;- 500
theta.x1 &lt;- c(rep(1,15),rep(0,5),rep(-1,15),rep(0,5),rep(1.5,15)
             ,rep(0,5),rep(-1.5,15),rep(0,325))
theta.x2 &lt;- c(rep(0,320),rep(1,15),rep(0,5),rep(-1,15),rep(0,5)
             ,rep(1.5,15),rep(0,5),rep(-1.5,15),rep(0,5))

theta.y1 &lt;- c(rep(1,15),rep(0,5),rep(-1,15),rep(0,5),rep(1.5,15)
             ,rep(0,5),rep(-1.5,15),rep(0,425))
theta.y2 &lt;- c(rep(0,420),rep(1,15),rep(0,5),rep(-1,15),rep(0,5),
			rep(1.5,15),rep(0,5),rep(-1.5,15),rep(0,5))                             


Sigmax &lt;- matrix(0, nrow = p, ncol = p)
diag(Sigmax) &lt;- sigma.e ^ 2
Sigmay &lt;- matrix(0, nrow = q, ncol = q)
diag(Sigmay) &lt;- sigma.e ^ 2

set.seed(125)

gam1 &lt;- rnorm(n)
gam2 &lt;- rnorm(n)

X &lt;- matrix(c(gam1, gam2), ncol = 2, byrow = FALSE) %*% matrix(c(theta.x1, theta.x2),
     nrow = 2, byrow = TRUE) + rmvnorm(n, mean = rep(0, p), sigma =
     Sigmax, method = "svd")
Y &lt;- matrix(c(gam1, gam2), ncol = 2, byrow = FALSE) %*% matrix(c(theta.y1, theta.y2),
     nrow = 2, byrow = TRUE) + rmvnorm(n, mean = rep(0, q), sigma =
     Sigmay, method = "svd")


ind.block.x &lt;- seq(20, 380, 20)
ind.block.y &lt;- seq(20, 480, 20)
##


model.sgPLS &lt;- sgPLS(X, Y, ncomp = 2, mode = "regression", keepX = c(4, 4), 
                   keepY = c(4, 4), ind.block.x = ind.block.x
                   ,ind.block.y = ind.block.y,
                   alpha.x = c(0.95, 0.95), alpha.y = c(0.95, 0.95))

result.sgPLS &lt;- select.sgpls(model.sgPLS)
result.sgPLS$group.size.X
result.sgPLS$group.size.Y
</code></pre>


</div>