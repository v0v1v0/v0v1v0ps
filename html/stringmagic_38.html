<div class="container">

<table style="width: 100%;"><tr>
<td>string_split</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Splits a character string wrt a pattern</h2>

<h3>Description</h3>

<p>Splits a character string with respect to pattern
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_split(
  x,
  split,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame()
)

stsplit(
  x,
  split,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>A character scalar. Used to split the character vectors. By default
this is a regular expression. You can use flags in the pattern in the form <code style="white-space: pre;">⁠flag1, flag2/pattern⁠</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
magic (add interpolation with <code>"{}"</code>). Example:
if "ignore/hello" and the text contains "Hello", it will be split at "Hello".
Shortcut: use the first letters of the flags. Ex: "iw/one" will split at the word
"one" (flags 'ignore' + 'word').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If <code>TRUE</code>, then when the vector input <code>x</code>
is of length 1, a character vector is returned instead of a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to consider the argument <code>split</code>
as fixed (and not as a regular expression).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>simplify = TRUE</code> (default), the object returned is:
</p>

<ul>
<li>
<p> a character vector if <code>x</code>, the vector in input, is of length 1: the character vector contains
the result of the split.
</p>
</li>
<li>
<p> a list of the same length as <code>x</code>. The ith element of the list is a character vector
containing the result of the split of the ith element of <code>x</code>.
</p>
</li>
</ul>
<p>If <code>simplify = FALSE</code>, the object returned is always a list.
</p>


<h3>Functions</h3>


<ul><li> <p><code>stsplit()</code>: Alias to <code>string_split</code>
</p>
</li></ul>
<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant <em>"any character"</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".
</p>
<p>The four flags always available are: "ignore", "fixed", "word" and "magic".
</p>

<ul>
<li>
<p> "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)"
at the beginning of the pattern.
</p>
</li>
<li>
<p> "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li>
<p> "word" adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, "word/one, two" is treated as "\b(one|two)\b". Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to " I ambushed?" thanks to the flags "ignore" and "word".
</p>
</li>
<li>
<p> "magic" allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
time = "This is the year 2024."

# we break the sentence
string_split(time, " ")

# simplify = FALSE leads to a list
string_split(time, " ", simplify = FALSE)

# let's break at "is"
string_split(time, "is")

# now breaking at the word "is"
# NOTE: we use the flag `word` (`w/`)
string_split(time, "w/is")

# same but using a pattern from a variable
# NOTE: we use the `magic` flag
pat = "is"
string_split(time, "mw/{pat}")


</code></pre>


</div>