<div class="container">

<table style="width: 100%;"><tr>
<td>apportion_inverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distribute streamflow depletion within a stream network using inverse distance weighting.</h2>

<h3>Description</h3>

<p>Distribute streamflow depletion within a stream network using inverse distance weighting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">apportion_inverse(
  reach_dist,
  w,
  max_dist = Inf,
  min_frac = 0,
  reach_name = NULL,
  dist_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>reach_dist</code></td>
<td>
<p>data frame with two columns: <code>reach</code>, which is a grouping variable with
the name of each stream reach, and <code>dist</code> which is the distance of that stream reach to
the well of interest. There can be more than one <code>dist</code> per <code>reach</code>; the function
will automatically find the minimum. Columns can either be named exactly as defined here, or
set using <code>reach_name</code> and <code>dist_name</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>inverse distance weighting factor; 1 for inverse distance, 2 for inverse distance squared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_dist</code></td>
<td>
<p>the maximum distance of a stream to be depleted; defaults to <code>Inf</code>, which means all reaches will be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_frac</code></td>
<td>
<p>the minimum <code>frac_depletion</code> to be returned; defaults to <code>0</code>, which means all reaches will be considered.
If <code>min_frac &gt; 0</code> and some reaches have an estimated <code>frac_depletion &lt; min_frac</code>, depletion in those reaches will be set to 0
and that depletion will be reallocated based on the proportional depletion in the remaining reaches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reach_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your stream reach grouping variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>reach</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_name</code></td>
<td>
<p>The name of the column in <code>reach_dist</code> indicating your distance variable. If set to <code>NULL</code> (default), it will assume that the column name is <code>dist</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Since analytical models assume the presence of 1 (or sometimes 2) linear streams, the <code>apportion_*</code> functions
can be used to distribute that depletion to various reaches within a real stream network. These geometric functions are described
in Zipper et al (2018), which found that <code>apportion_web</code> a weighting factor (<code>w</code>) of 2 produced the best results.
</p>


<h3>Value</h3>

<p>A data frame with two columns:
</p>

<dl>
<dt>reach</dt>
<dd>
<p>the grouping variable input in <code>reach_dist</code></p>
</dd>
<dt>frac_depletion</dt>
<dd>
<p>the proportion of streamflow depletion from the well occurring in that reach.</p>
</dd>
</dl>
<h3>References</h3>

<p>Zipper, SC, T Dallemagne, T Gleeson, TC Boerman, A Hartmann (2018). Groundwater Pumping Impacts
on Real Stream Networks: Testing the Performance of Simple Management Tools. Water Resources Research.
doi:10.1029/2018WR022707.
</p>


<h3>Examples</h3>

<pre><code class="language-R">reach_dist &lt;- data.frame(reach = seq(1,5), dist = c(100, 150, 900, 300, 200))
apportion_inverse(reach_dist, w = 2)
apportion_inverse(reach_dist, w = 2, max_dist = 500)

reach_dist &lt;- data.frame(reach = c("A", "A", "A", "B", "B"), dist = c(100, 150, 900, 300, 200))
apportion_inverse(reach_dist, w = 1)
apportion_inverse(reach_dist, w = 1, max_dist = 500)
</code></pre>


</div>