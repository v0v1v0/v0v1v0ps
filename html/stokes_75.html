<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.kform</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Arithmetic Ops Group Methods for <code>kform</code> and <code>ktensor</code>
objects</h2>

<h3>Description</h3>

<p>Allows arithmetic operators to be used for <code class="reqn">k</code>-forms and
<code class="reqn">k</code>-tensors such as addition, multiplication, etc, where
defined.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'kform'
Ops(e1, e2 = NULL)
## S3 method for class 'ktensor'
Ops(e1, e2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>e1,e2</code></td>
<td>
<p>Objects of class <code>kform</code> or <code>ktensor</code></p>
</td>
</tr></table>
<h3>Details</h3>

<p>The functions <code>Ops.kform()</code> and <code>Ops.ktensor()</code> pass unary
and binary arithmetic operators (“<code>+</code>”, “<code>-</code>”,
“<code>*</code>”, “<code>/</code>” and “<code>^</code>”) to the
appropriate specialist function by coercing to <code>spray</code> objects.
</p>
<p>For wedge products of <code class="reqn">k</code>-forms, use <code>wedge()</code> or
<code>%^%</code> or <code>^</code>; and for tensor products of
<code class="reqn">k</code>-tensors, use <code>tensorprod()</code> or <code>%X%</code>.
</p>


<h3>Value</h3>

<p>All functions documented here return an object of class
<code>kform</code> or <code>ktensor</code>.
</p>


<h3>Note</h3>

<p>A plain asterisk, “<code>*</code>” behaves differently for ktensors
and kforms.  Given two ktensors <code>T1</code>, <code>T2</code>, then
“<code>T1*T2</code>” will return the their tensor product.  This on
the grounds that the idiom has only one natural interpretation.  But
its use is discouraged (use <code>%X%</code> or <code>tensorprod()</code>
instead).  An asterisk can also be used to multiply a tensor by a
scalar, as in <code>T1*5</code>.
</p>
<p>An asterisk cannot be used to multiply two kforms <code>K1</code>,
<code>K2</code>, as in <code>K1*K2</code>, which will always return an error.
This on the grounds that it has no sensible interpretation in general
and you probably meant to use a wedge product, <code>K1^K2</code>.  Note
that multiplication by scalars is acceptable, as in <code>K1*6</code>.
Further note that <code>K1*K2</code> returns an error even if one or both is
a 0-form (or scalar), as in <code>K1*scalar(3)</code>.  This behaviour may
change in the future.
</p>
<p>In the package the caret (“<code>^</code>”) evaluates the wedge
product; note that <code>%^%</code> is also acceptable.  Powers simply do
not make sense for alternating forms: <code>S %^% S = S^S</code> is zero
identically.  Here the caret is interpreted consistently as a wedge
product, and if one of the factors is numeric it is interpreted as a
zero-form (that is, a scalar).  Thus <code>S^2 = wedge(S,2) = 2^S =
  S*2 = S+S</code>, and indeed <code>S^n==S*n</code>.  Caveat emptor!  If <code>S</code>
is a <code>kform</code> object, it is very tempting [but incorrect] to
interpret “<code>S^3</code>” as something like “<code>S</code> to
the power 3”.  See also the note at <code>Ops.clifford</code> in the
<a href="https://CRAN.R-project.org/package=clifford"><span class="pkg">clifford</span></a> package.
</p>
<p>Powers are not implemented for ktensors on the grounds that a ktensor
to the power zero is not defined.
</p>
<p>Note that one has to take care with order of operations if we mix
<code>^</code> with <code>*</code>.  For example, <code>dx ^ (6*dy)</code> is perfectly
acceptable; but <code>(dx ^ 6)*dy)</code> will return an error, as will the
unbracketed form <code>dx ^ 6 * dy</code>.  In the second case we attempt to
use an asterisk to multiply two k-forms, which triggers the error.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">## dx_1 ^ dx_2 + 6dx_5 ^ dx_6:
as.kform(1) ^ as.kform(2) + 6*as.kform(5) ^ as.kform(6)

k1 &lt;- kform_general(4,2,rnorm(6))
k2 &lt;- kform_general(4,2,rnorm(6))

E &lt;- matrix(rnorm(8),4,2)
as.function(k1+k2)(E)

## verify linearity, here 2*k1 + 3*k2:
as.function(2*k1+3*k2)(E)-(2*as.function(k1)(E) + 3*as.function(k2)(E))
## should be small
</code></pre>


</div>