<div class="container">

<table style="width: 100%;"><tr>
<td>SLFPCA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse logistic functional principal component analysis</h2>

<h3>Description</h3>

<p>Sparse logistic functional principal component analysis (SLFPCA) for binary data. The estimated eigenfunctions from SLFPCA can be strictly zero on some sub-intervals, which is helpful for interpretation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SLFPCA(
  Ly,
  Lt,
  interval,
  npc,
  L_list,
  norder,
  kappa_theta,
  sparse_pen,
  nRegGrid = 51,
  bwmu_init = 0.5,
  bwcov_init = 1,
  kappa_mu,
  itermax = 100,
  tol = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the binary measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>A <code>vector</code> of length two denoting the supporting interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npc</code></td>
<td>
<p>An integer denoting the number of FPCs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_list</code></td>
<td>
<p>A <code>vector</code> denoting the candidates for the number of B-spline basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norder</code></td>
<td>
<p>An integer denoting the order of the using B-spline basis, which is one higher than their degree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa_theta</code></td>
<td>
<p>A <code>vector</code> denoting the smoothing parameters for eigenfunctions, the optimal tuning parameter is chosen from them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse_pen</code></td>
<td>
<p>A <code>vector</code> denoting the sparseness parameters for eigenfunctions, the optimal tuning parameter is chosen from them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRegGrid</code></td>
<td>
<p>An integer denoting the number of equally spaced time points in the supporting interval. The eigenfunctions and mean function are estimated at these equally spaced time points first, before transforming into functional data object. (default: 51)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwmu_init</code></td>
<td>
<p>A scalar denoting the bandwidth for mean function estimation in the setting of initial values. (default: 0.5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwcov_init</code></td>
<td>
<p>A scalar denoting the bandwidth for covariance function estimation in the setting of initial values. (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa_mu</code></td>
<td>
<p>A <code>vector</code> denoting the smoothing parameters for mean function, the optimal tuning parameter is chosen from them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>An integer denoting the maximum number of iterations. (default: 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A scalar. When difference of the loglikelihood functions between two consecutive iteration is less than <code>tol</code>, the convergence is supposed to be reached. (default: 10)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mufd</code></td>
<td>
<p>A functional data object for the mean function estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigfd_list</code></td>
<td>
<p>A <code>list</code> containing <code>npc</code> functional data objects, which are the eigenfunction estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>A <em>n</em> by <code>npc</code> <code>matrix</code> containing the estimates of the FPC scores, where <em>n</em> is the sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa_mu</code></td>
<td>
<p>A scalar denoting the selected smoothing parameter for mean function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa_theta</code></td>
<td>
<p>A scalar denoting the selected smoothing parameter for eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse_pen</code></td>
<td>
<p>A scalar denoting the selected sparseness parameter for eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_select</code></td>
<td>
<p>A scalar denoting the selected number of B-spline basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EBICscore</code></td>
<td>
<p>A <code>vector</code> denoting the selected EBIC scores corresponding to different numbers of B-spline basis functions in <code>L_list</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p><cite>Rou Zhong, Shishi Liu, Haocheng Li, Jingxiao Zhang. Sparse logistic functional principal component analysis for binary data. Statistics and Computing, 33, 15 (2023). https://doi.org/10.1007/s11222-022-10190-3</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate data
n &lt;- 100
npc &lt;- 1
interval &lt;- c(0, 10)
gridequal &lt;- seq(0, 10, length.out = 51)
basis &lt;- fda::create.bspline.basis(c(0, 10), nbasis = 13, norder = 4,
         breaks = seq(0, 10, length.out = 11))
meanfun &lt;- function(t){2 * sin(pi * t/5)/sqrt(5)}
lambda_1 &lt;- 3^2 #the first eigenvalue
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)))
eigfun &lt;- list()
eigfun[[1]] &lt;- function(t){cos(pi * t/5)/sqrt(5)}
eigfd &lt;- list()
for(i in 1:npc){
  eigfd[[i]] &lt;- fda::smooth.basis(gridequal, eigfun[[i]](gridequal), basis)$fd
}
DataNew &lt;- GenBinaryFD(n, interval, sparse = 8:12, regular = FALSE,
           meanfun = meanfun, score, eigfd)
SLFPCA_list &lt;- SLFPCA(DataNew$Ly, DataNew$Lt, interval, npc, L_list = 13,
               norder = 4, kappa_theta = 0.2, sparse_pen = 0, kappa_mu = 0)
plot(SLFPCA_list$eigfd_list[[1]])

</code></pre>


</div>