<div class="container">

<table style="width: 100%;"><tr>
<td>spatstat.model-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The spatstat.model Package</h2>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.model</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the core functionality
for parametric statistical modelling of spatial data.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.model</span> contains all the main
user-level functions
that perform parametric statistical modelling of spatial data.
</p>
<p>(The main exception is that functions for linear networks
are in the separate sub-package <span class="pkg">spatstat.linnet</span>.)
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.univar</span> containing functions for estimating
probability distributions of random variables
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the functionality
for exploratory analysis and nonparametric modelling of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for parametric modelling, analysis and inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li>
</ul>
<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
</p>
<p>For an overview of all the functions available in
the sub-packages of <span class="pkg">spatstat</span>,
see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package.
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li>
</ul>
<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Overview of Functionality in <span class="pkg">spatstat.model</span>
</h3>

<p>The <span class="pkg">spatstat</span> family of packages
is designed to support a complete statistical analysis
of spatial data. It supports
</p>

<ul>
<li>
<p> creation, manipulation and plotting of point patterns;
</p>
</li>
<li>
<p> exploratory data analysis;
</p>
</li>
<li>
<p> spatial random sampling;
</p>
</li>
<li>
<p> simulation of point process models;
</p>
</li>
<li>
<p> parametric model-fitting;
</p>
</li>
<li>
<p> non-parametric smoothing and regression;
</p>
</li>
<li>
<p> formal inference (hypothesis tests, confidence intervals);
</p>
</li>
<li>
<p> model diagnostics.
</p>
</li>
</ul>
<p>For an overview, see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package. 
</p>
<p>Following is a list of the functionality provided in the
<span class="pkg">spatstat.model</span> package only.
</p>
<p><b>To simulate a random point pattern:</b>
</p>
<p>Functions for generating random point patterns
are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p><b>Exploratory analysis</b>
</p>
<p>Exploratory graphics, 
smoothing, and exploratory analysis of spatial data
are now provided in the <span class="pkg">spatstat.explore</span> package.
</p>
<p><b>Model fitting (Cox and cluster models)</b>
</p>
<p>Cluster process models (with homogeneous or inhomogeneous intensity)
and Cox processes can be fitted by the function <code>kppm</code>.
Its result is an object of class <code>"kppm"</code>.
The fitted model can be printed, plotted, predicted, simulated
and updated.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>kppm</code> </td>
<td style="text-align: left;">  Fit model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.kppm</code> </td>
<td style="text-align: left;">  Plot the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary.kppm</code> </td>
<td style="text-align: left;">  Summarise the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.kppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.kppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>update.kppm</code> </td>
<td style="text-align: left;"> Update the model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>improve.kppm</code> </td>
<td style="text-align: left;"> Refine the estimate of trend </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.kppm</code> </td>
<td style="text-align: left;"> Generate simulated realisations </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.kppm</code> </td>
<td style="text-align: left;"> Variance-covariance matrix of coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.kppm</code>
    </td>
<td style="text-align: left;"> Extract trend coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>formula.kppm</code>
    </td>
<td style="text-align: left;"> Extract trend formula </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>parameters</code> </td>
<td style="text-align: left;"> Extract all model parameters </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clusterfield.kppm</code> </td>
<td style="text-align: left;"> Compute offspring density </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clusterradius.kppm</code> </td>
<td style="text-align: left;"> Radius of support of offspring density </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmodel.kppm</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfmodel.kppm</code> </td>
<td style="text-align: left;"> Pair correlation of fitted model 
  </td>
</tr>
</table>
<p>For model selection, you can also use 
the generic functions <code>step</code>, <code>drop1</code> 
and <code>AIC</code> on fitted point process models.
For variable selection, see <code>sdr</code>.
</p>
<p>The theoretical models can also be simulated,
for any choice of parameter values,
using <code>rThomas</code>, <code>rMatClust</code>,
<code>rCauchy</code>, <code>rVarGamma</code>,
and <code>rLGCP</code>.
</p>
<p>Lower-level fitting functions include:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>lgcp.estK</code> </td>
<td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lgcp.estpcf</code> </td>
<td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>thomas.estK</code> </td>
<td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>thomas.estpcf</code> </td>
<td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matclust.estK</code> </td>
<td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matclust.estpcf</code> </td>
<td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>cauchy.estK</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>cauchy.estpcf</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
   <code>vargamma.estK</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
<td style="text-align: left;">
   <code>vargamma.estpcf</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>mincontrast</code> </td>
<td style="text-align: left;"> low-level algorithm for fitting models
    </td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> by the method of minimum contrast 
  </td>
</tr>
</table>
<p><b>Model fitting (Poisson and Gibbs models)</b>
</p>
<p>Poisson point processes are the simplest models for point patterns.
A Poisson model assumes that the points are stochastically
independent. It may allow the points to have a non-uniform spatial
density. The special case of a Poisson process with a uniform
spatial density is often called Complete Spatial Randomness.
</p>
<p>Poisson point processes are included in the more general class of Gibbs point
process models. In a Gibbs model, there is <em>interaction</em>
or dependence between points. Many different types of interaction
can be specified.
</p>
<p>For a detailed explanation of how to fit Poisson or
Gibbs point process models to point pattern data using <span class="pkg">spatstat</span>,
see Baddeley and Turner (2005b) or Baddeley (2008).
</p>
<p><b>To fit a Poisson or Gibbs point process model:</b>
</p>
<p>Model fitting in <span class="pkg">spatstat</span> is performed mainly by the function
<code>ppm</code>. Its result is an object of class <code>"ppm"</code>.
</p>
<p>Here are some examples, where <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
<td style="text-align: left;">
    <em>command</em> </td>
<td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ 1)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ x)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                             </td>
<td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ 1, Strauss(0.1))</code> </td>
<td style="text-align: left;"> Stationary Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ x, Strauss(0.1))</code> </td>
<td style="text-align: left;"> Strauss process with </td>
</tr>
<tr>
<td style="text-align: left;">
                              </td>
<td style="text-align: left;"> conditional intensity loglinear in <code class="reqn">x</code>
  </td>
</tr>
</table>
<p>It is also possible to fit models that depend on
other covariates.
</p>
<p><b>Manipulating the fitted model:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>plot.ppm</code> </td>
<td style="text-align: left;"> 		Plot the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.ppm</code>
    </td>
<td style="text-align: left;">   Compute the spatial trend and conditional intensity</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">   of the fitted point process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.ppm</code> </td>
<td style="text-align: left;"> Extract the fitted model coefficients</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>parameters</code> </td>
<td style="text-align: left;"> Extract all model parameters</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>formula.ppm</code> </td>
<td style="text-align: left;"> Extract the trend formula</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>intensity.ppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmodel.ppm</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfmodel.ppm</code> </td>
<td style="text-align: left;"> pair correlation of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.ppm</code> </td>
<td style="text-align: left;"> Compute fitted conditional intensity at quadrature points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>residuals.ppm</code> </td>
<td style="text-align: left;"> Compute point process residuals at quadrature points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>update.ppm</code> </td>
<td style="text-align: left;"> Update the fit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.ppm</code> </td>
<td style="text-align: left;"> Variance-covariance matrix of estimates</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rmh.ppm</code> </td>
<td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.ppm</code> </td>
<td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>print.ppm</code> </td>
<td style="text-align: left;"> Print basic information about a fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary.ppm</code> </td>
<td style="text-align: left;"> Summarise a fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>effectfun</code> </td>
<td style="text-align: left;"> Compute the fitted effect of one covariate</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>logLik.ppm</code> </td>
<td style="text-align: left;"> log-likelihood or log-pseudolikelihood</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>anova.ppm</code> </td>
<td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.frame.ppm</code> </td>
<td style="text-align: left;"> Extract data frame used to fit model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.images</code> </td>
<td style="text-align: left;"> Extract spatial data used to fit model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.depends</code> </td>
<td style="text-align: left;"> Identify variables in the model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.interact</code> </td>
<td style="text-align: left;"> Interpoint interaction component of model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitin</code> </td>
<td style="text-align: left;"> Extract fitted interpoint interaction </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.hybrid</code> </td>
<td style="text-align: left;"> Determine whether the model is a hybrid </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>valid.ppm</code> </td>
<td style="text-align: left;"> Check the model is a valid point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>project.ppm</code> </td>
<td style="text-align: left;"> Ensure the model is a valid point process 
  </td>
</tr>
</table>
<p>For model selection, you can also use 
the generic functions <code>step</code>, <code>drop1</code> 
and <code>AIC</code> on fitted point process models.
For variable selection, see <code>sdr</code>.
</p>
<p>See <code>spatstat.options</code> to control plotting of fitted model.
</p>
<p><b>To specify a point process model:</b>
</p>
<p>The first order “trend” of the model is determined by an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 
language formula. The formula specifies the form of the
<em>logarithm</em> of the trend.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>X ~ 1</code>  </td>
<td style="text-align: left;"> No trend (stationary) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ x</code>   </td>
<td style="text-align: left;"> Loglinear trend
      <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta x)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> where <code class="reqn">x,y</code> are Cartesian coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ polynom(x,y,3)</code>  </td>
<td style="text-align: left;"> Log-cubic polynomial trend  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ harmonic(x,y,2)</code>  </td>
<td style="text-align: left;"> Log-harmonic polynomial trend </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ Z</code>   </td>
<td style="text-align: left;"> Loglinear function of covariate <code>Z</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">  <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta Z(x,y))</code> 
  </td>
</tr>
</table>
<p>The higher order (“interaction”) components are described by
an object of class <code>"interact"</code>. Such objects are created by:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>Poisson()</code> </td>
<td style="text-align: left;">		the Poisson point process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>AreaInter()</code>	 </td>
<td style="text-align: left;"> Area-interaction process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>BadGey()</code> </td>
<td style="text-align: left;">	multiscale Geyer process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Concom()</code> </td>
<td style="text-align: left;">	connected component interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>DiggleGratton() </code> </td>
<td style="text-align: left;"> Diggle-Gratton potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>DiggleGatesStibbard() </code> </td>
<td style="text-align: left;"> Diggle-Gates-Stibbard potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Fiksel()</code>	 </td>
<td style="text-align: left;"> Fiksel pairwise interaction process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Geyer()</code>	 </td>
<td style="text-align: left;"> Geyer's saturation process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Hardcore()</code>	 </td>
<td style="text-align: left;"> Hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierHard()</code>	 </td>
<td style="text-align: left;"> Hierarchical multiype hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierStrauss()</code>	 </td>
<td style="text-align: left;"> Hierarchical multiype Strauss process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierStraussHard()</code>	 </td>
<td style="text-align: left;">
    Hierarchical multiype Strauss-hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Hybrid()</code>	 </td>
<td style="text-align: left;"> Hybrid of several interactions</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>LennardJones() </code> </td>
<td style="text-align: left;"> Lennard-Jones potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiHard()</code> </td>
<td style="text-align: left;"> 		multitype hard core process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiStrauss()</code> </td>
<td style="text-align: left;"> 		multitype Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiStraussHard()</code> </td>
<td style="text-align: left;"> 	multitype Strauss/hard core process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>OrdThresh()</code> </td>
<td style="text-align: left;">		Ord process, threshold potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Ord()</code> </td>
<td style="text-align: left;"> 		        Ord model, user-supplied potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>PairPiece()</code> </td>
<td style="text-align: left;">		pairwise interaction, piecewise constant </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Pairwise()</code> </td>
<td style="text-align: left;">	pairwise interaction, user-supplied potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Penttinen()</code> </td>
<td style="text-align: left;">	Penttinen pairwise interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>SatPiece()</code> </td>
<td style="text-align: left;">	Saturated pair model, piecewise  constant potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Saturated()</code> </td>
<td style="text-align: left;">	Saturated pair model, user-supplied potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Softcore()</code> </td>
<td style="text-align: left;"> pairwise interaction, soft core potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Strauss()</code> </td>
<td style="text-align: left;">  Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>StraussHard()</code> </td>
<td style="text-align: left;"> Strauss/hard core point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Triplets()</code> </td>
<td style="text-align: left;"> Geyer triplets process
  </td>
</tr>
</table>
<p>Note that it is also possible to combine several such interactions
using <code>Hybrid</code>.
</p>
<p><b>Simulation and goodness-of-fit for fitted models:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>rmh.ppm</code> </td>
<td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.ppm</code> </td>
<td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope</code> </td>
<td style="text-align: left;"> compute simulation envelopes for a
    fitted model 
  </td>
</tr>
</table>
<p><b>Model fitting (determinantal point process models)</b>
</p>
<p>Code for fitting <em>determinantal point process models</em> has 
recently been added to <span class="pkg">spatstat</span>.
</p>
<p>For information, see the help file for <code>dppm</code>.
</p>
<p><b>Model fitting (spatial logistic regression)</b>
</p>
<p>Pixel-based spatial logistic regression is an alternative
technique for analysing spatial point patterns
that is widely used in Geographical Information Systems.
It is approximately equivalent to fitting a Poisson point process
model.
</p>
<p>In pixel-based logistic regression, the spatial domain is
divided into small pixels, the presence or absence of a
data point in each pixel is recorded, and logistic regression
is used to model the presence/absence indicators as a function
of any covariates.
</p>
<p>Facilities for performing spatial logistic regression are
provided in <span class="pkg">spatstat</span> for comparison purposes.
</p>
<p><b>Fitting a spatial logistic regression</b>
</p>
<p>Spatial logistic regression is performed by the function
<code>slrm</code>. Its result is an object of class <code>"slrm"</code>.
There are many methods for this class, including methods for
<code>print</code>, <code>fitted</code>, <code>predict</code>, <code>simulate</code>,
<code>anova</code>, <code>coef</code>, <code>logLik</code>, <code>terms</code>,
<code>update</code>, <code>formula</code> and <code>vcov</code>. 
</p>
<p>For example, if <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
<td style="text-align: left;">
    <em>command</em> </td>
<td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ 1)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ x)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                </td>
<td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ Z)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                </td>
<td style="text-align: left;"> intensity loglinear in covariate <code>Z</code>
  </td>
</tr>
</table>
<p><b>Manipulating a fitted spatial logistic regression</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>anova.slrm</code> </td>
<td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.slrm</code>  </td>
<td style="text-align: left;"> Extract fitted coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.slrm</code>  </td>
<td style="text-align: left;"> Variance-covariance matrix of fitted coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.slrm</code> </td>
<td style="text-align: left;"> Compute fitted probabilities or
    intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>logLik.slrm</code>   </td>
<td style="text-align: left;"> Evaluate loglikelihood of fitted
    model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.slrm</code>    </td>
<td style="text-align: left;"> Plot fitted probabilities or
    intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.slrm</code> </td>
<td style="text-align: left;"> Compute predicted probabilities or
    intensity with new data </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.slrm</code> </td>
<td style="text-align: left;"> Simulate model
  </td>
</tr>
</table>
<p>There are many other undocumented methods for this class,
including methods for <code>print</code>, <code>update</code>, <code>formula</code>
and <code>terms</code>. Stepwise model selection is
possible using <code>step</code> or <code>stepAIC</code>.
For variable selection, see <code>sdr</code>.
</p>
<p><b>Simulation</b>
</p>
<p>There are many ways to generate a random point pattern,
line segment pattern, pixel image or tessellation
in <span class="pkg">spatstat</span>. 
</p>
<p><b>Random point patterns:</b>
Functions for random generation are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p>See also <code>varblock</code> for estimating the variance
of a summary statistic by block resampling, and
<code>lohboot</code> for another bootstrap technique.
</p>
<p><b>Fitted point process models:</b>
</p>
<p>If you have fitted a point process model to a point pattern dataset,
the fitted model can be simulated.
</p>
<p>Cluster process models 
are fitted by the function <code>kppm</code> yielding an
object of class <code>"kppm"</code>. To generate one or more simulated
realisations of this fitted model, use 
<code>simulate.kppm</code>.
</p>
<p>Gibbs point process models 
are fitted by the function <code>ppm</code> yielding an
object of class <code>"ppm"</code>. To generate a simulated
realisation of this fitted model, use <code>rmh.ppm</code>.
To generate one or more simulated realisations of the fitted model,
use <code>simulate.ppm</code>.
</p>
<p><b>Other random patterns:</b>
Functions for random generation are now contained in the
<span class="pkg">spatstat.random</span> package.
</p>
<p><b>Simulation-based inference</b>
</p>
<p>Simulation-based inference including simulation envelopes
and hypothesis tests is now supported by the package <span class="pkg">spatstat.explore</span>.
</p>
<p><b>Sensitivity diagnostics:</b>
</p>
<p>Classical measures of model sensitivity such as leverage and influence
have been adapted to point process models.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>leverage.ppm</code> </td>
<td style="text-align: left;"> Leverage for point process model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>influence.ppm</code> </td>
<td style="text-align: left;"> Influence for point process model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dfbetas.ppm</code> </td>
<td style="text-align: left;"> Parameter influence</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dffit.ppm</code> </td>
<td style="text-align: left;"> Effect change diagnostic
    </td>
</tr>
</table>
<p><b>Diagnostics for covariate effect:</b>
</p>
<p>Classical diagnostics for covariate effects have been adapted to
point process models.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>parres</code> </td>
<td style="text-align: left;"> Partial residual plot</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>addvar</code> </td>
<td style="text-align: left;"> Added variable plot </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rhohat.ppm</code> </td>
<td style="text-align: left;"> Kernel estimate of covariate effect</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rho2hat</code> </td>
<td style="text-align: left;"> Kernel estimate of covariate effect
    (bivariate) 
  </td>
</tr>
</table>
<p><b>Residual diagnostics:</b>
</p>
<p>Residuals for a fitted point process model, and diagnostic plots
based on the residuals, were introduced in Baddeley et al (2005) and
Baddeley, Rubak and Moller (2011).
</p>
<p>Type <code>demo(diagnose)</code>
for a demonstration of the diagnostics features.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>diagnose.ppm</code> </td>
<td style="text-align: left;"> diagnostic plots for spatial trend</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>qqplot.ppm</code> </td>
<td style="text-align: left;"> diagnostic Q-Q plot for interpoint interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>residualspaper</code> </td>
<td style="text-align: left;"> examples from Baddeley et al (2005) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kcom</code> </td>
<td style="text-align: left;"> model compensator of <code class="reqn">K</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gcom</code> </td>
<td style="text-align: left;"> model compensator of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kres</code> </td>
<td style="text-align: left;"> score residual of <code class="reqn">K</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gres</code> </td>
<td style="text-align: left;"> score residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psst</code> </td>
<td style="text-align: left;"> pseudoscore residual of summary function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psstA</code> </td>
<td style="text-align: left;"> pseudoscore residual of empty space function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psstG</code> </td>
<td style="text-align: left;"> pseudoscore residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>compareFit</code> </td>
<td style="text-align: left;"> compare compensators of several fitted
    models
  </td>
</tr>
</table>
<p><b>Resampling and randomisation procedures</b>
</p>
<p>You can build your own tests based on randomisation and resampling
using the following capabilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>quadratresample</code> </td>
<td style="text-align: left;"> block resampling </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rshift</code> </td>
<td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rthin</code> </td>
<td style="text-align: left;">  random thinning  
  </td>
</tr>
</table>
<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the "GNU 
General Public License", a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ottmar Cronie,
Tilman Davies,
Julian Gilbey, 
Yongtao Guan,
Ute Hahn,
Kassel Hingee,
Abdollah Jalilian,
Marie-Colette van Lieshout,
Greg McSwiggan,
Tuomas Rajala,
Suman Rakshit,
Dominic Schuhmacher,
Rasmus Waagepetersen
and
Hangsheng Wang
made substantial contributions of code.
</p>
<p>For comments, corrections, bug alerts and suggestions, we thank
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Ben Madin,
Martin Maechler,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


</div>