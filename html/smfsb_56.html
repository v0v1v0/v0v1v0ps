<div class="container">

<table style="width: 100%;"><tr>
<td>StepGillespie</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a function for advancing the state of an SPN by using the Gillespie algorithm</h2>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using the Gillespie algorithm. The resulting function (closure) can be used in conjunction with other functions (such as <code>simTs</code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">StepGillespie(N)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using the Gillespie algorithm. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code>StepEulerSPN</code>, <code>StepGillespie1D</code>,
<code>simTs</code>, <code>simTimes</code>, <code>simSample</code>, <code>StepFRM</code>,
<code>StepPTS</code>, <code>StepCLE</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># load up the Lotka-Volterra (LV) model
data(spnModels)
LV
# create a stepping function
stepLV = StepGillespie(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# simulate a realisation of the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
# simulate a realisation using simTimes
times = seq(0,100,by=0.1)
plot(ts(simTimes(c(x1=50,x2=100),0,times,stepLV),start=0,deltat=0.1),plot.type="single",lty=1:2)
# simulate a realisation at irregular times
times = c(0,10,20,50,100)
out2 = simTimes(c(x1=50,x2=100),0,times,stepLV)
print(out2)
</code></pre>


</div>