<div class="container">

<table style="width: 100%;"><tr>
<td>regSGB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regression for compositions following a SGB distribution
</h2>

<h3>Description</h3>

<p>Explanatory variables may influence the scale vector through a linear model applied to a log-ratio transform of the compositions. The shape parameters do not depend on explanatory variables. The overall shape parameter <code>shape1</code> is common to all parts, whereas the Dirichlet shape parameters vector <code>shape2</code> are specific to each part, i.e. <code>shape2[j]</code> is the Dirichlet parameter for <code>u[i,j]</code>, <code>i=1,...,n</code>, (<code>n</code>=number of compositions in the dataset <code>u</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">regSGB(d, ...)

## Default S3 method:
regSGB(d, u, V, weight=rep(1,dim(d)[1]), 
    shape10 = 1, bound = 2.1, ind = NULL, shape1 = NULL, Mean2 = TRUE, 
    control.optim = list(trace=0,fnscale=-1),
    control.outer = list(itmax=1000,ilack.max=200,trace=TRUE, kkt2.check =TRUE,
    method = "BFGS"),...)
       
## S3 method for class 'formula'
regSGB(Formula, data= list(), weight=rep(1,dim(d)[1]), 
    shape10 = 1, bound = 2.1, ind = NULL, shape1 = 1,  Mean2=TRUE,
    control.optim = list(trace=0,fnscale=-1),
    control.outer = list(itmax=1000,ilack.max=200,trace=TRUE,kkt2.check =TRUE, 
    method = "BFGS"),...)
         
## S3 method for class 'regSGB'
print(x, ...)

## S3 method for class 'regSGB'
summary(object, digits=3,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Formula</code></td>
<td>

<p>formula of class Formula, see <code>Formula</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n \times m)</code>; <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n \times D)</code>; <code class="reqn">D</code>: number of parts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>

<p>log-ratio transformation matrix <code class="reqn">(D \times (D-1))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a list with 3 components <code>d</code>, <code>u</code> and <code>V</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default rep(1,n). Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape10</code></td>
<td>

<p>positive number, initial value of the overall shape parameter, default 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>

<p>inequality constraints on the estimates of shapes:<br><code>shape1*shape2[i] &gt; bound, i=1,...,D.</code> <br>
By default <code>bound = 2.1</code>, see <code>InequalityConstr</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>

<p>vector of length equal to the number of fixed parameters; see <code>index</code> in <code>EqualityConstr</code>. 
Default <code>ind</code> = NULL (no fixed parameters).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape1</code></td>
<td>

<p>fixed value of the overall shape parameter if <code>min(ind)=1</code>. Default is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mean2</code></td>
<td>

<p>logical, if TRUE (default), the computed <code>shape2</code> parameters are each replaced by their average. See <code>initpar.SGB</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.optim</code></td>
<td>

<p>list of control parameters for optim, see <code>optim</code>. Default is from <code>auglag</code>, except <code>list(fnscale = -1)</code>. Always specify <code>fnscale = -1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.outer</code></td>
<td>

<p>list of control parameters to be used by the outer loop in <code>constrOptim.nl</code>, see <code>auglag</code>. 
Default is from <code>auglag</code>, except <br><code>list(itmax = 1000, ilack.max = 200</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object of class "regSGB".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>

<p>number of decimal places for print, default 3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an object of class "regSGB".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> not used. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is advisable to use the formula to specify the model for easy comparison between models. 
Without formula, the <code>d</code> matrix of explanatory variables must contain exactly the variables used in the model, 
whereas with formula other variables can be included as well. 
Variable transformations can be utilized within the formula, see Example 4 below with the indicator <code>I</code> and the log. <br> 
Constraints on parameters can be introduced, see example 5 and  <code>EqualityConstr</code> for more details. <br>
Use <code> weight</code> for pseudo-likelihood estimation. <code> weight</code> is scaled to <code class="reqn">n</code>, the sample size. <br>
A design based covariance matrix of the parameters can be obtained by linearization as the covariance matrix of the <code>scores</code>.
</p>


<h3>Value</h3>

<p>A list of class 'regSGB' with the following components:<br>
The first 13 form the output from <code>auglag</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>par </code></td>
<td>
<p>Vector of length <code class="reqn">npar</code>. Parameters that optimize the nonlinear objective function, satisfying constraints, if convergence is successful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value </code></td>
<td>
<p>The value of the objective function at termination.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts </code></td>
<td>
<p>A vector of length 2 denoting the number of times the objective and its gradient were evaluated, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence </code></td>
<td>
<p>An integer code indicating the type of convergence. 0 indicates successful convergence. 
Positive integer codes indicate failure to converge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message </code></td>
<td>
<p>A character string giving any additional information on convergence returned by <code>optim</code>, or NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outer.iteration </code></td>
<td>
<p>Number of outer iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda </code></td>
<td>
<p>Values of the Lagrangian parameter. This is a vector of the same length as the total number of inequalities and equalities. It must be zero for inactive inequalities; non-negative for active inequalities; and can have any sign for equalities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma </code></td>
<td>
<p>Value of augmented penalty parameter for the quadratic term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient </code></td>
<td>
<p>Gradient of the augmented Lagrangian function at convergence. It should be small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian </code></td>
<td>
<p>Hessian of the augmented Lagrangian function at convergence. It should be negative definite for maximization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ineq </code></td>
<td>
<p>Values of inequality constraints at convergence. All of them must be non-negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal </code></td>
<td>
<p>Values of equality constraints at convergence. All of them must be close to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kkt1 </code></td>
<td>
<p>A logical variable indicating whether or not the first-order KKT conditions were satisfied (printed 1 if conditions satisfied and 0 otherwise).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kkt2 </code></td>
<td>
<p>A logical variable indicating whether or not the second-order KKT conditions were satisfied (printed 1 if conditions satisfied and 0 otherwise).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale </code></td>
<td>
<p><code class="reqn">n 	\times D</code> matrix, the estimated scale compositions, see <code>bval</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanA</code></td>
<td>
<p>Aitchison expectation at estimated parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values </code></td>
<td>
<p><code class="reqn">(n 	\times (D-1))</code> matrix, estimated log-ratio transforms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals </code></td>
<td>
<p>Observed minus estimated log-ratio transforms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores </code></td>
<td>
<p>matrix <code class="reqn">n \times npar</code>. Each row contains the (unweighted) derivatives of the log-density at a data point w.r.t the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rsquare </code></td>
<td>
<p>ratio of total variation of <code>meanA</code> and total variation of compositions <code>u</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>The robust covariance matrix of parameters estimates, see <code>covest.SGB</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StdErr1 </code></td>
<td>
<p>Ordinary asymptotic standard errors of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StdErr </code></td>
<td>
<p>Robust asymptotic standard errors of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.par </code></td>
<td>
<p>Indices of the fixed parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary </code></td>
<td>
<p>The summary from <code>covest.SGB</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC </code></td>
<td>
<p>AIC criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>log-ratio transformation matrix (same as corresponding input parameter <code>V</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p> Arguments for calling <code>regSGB</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Formula </code></td>
<td>
<p>Expression for formula.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Graf, M. (2017). A distribution on the simplex of the Generalized Beta type. <em>In J. A. Martin-Fernandez (Ed.), Proceedings CoDaWork 2017</em>, University of Girona (Spain), 71-90.
</p>
<p>Hijazi, R. H. and R. W. Jernigan (2009). Modelling compositional data using Dirichlet regression models.
<em>Journal of Applied Probability and Statistics</em>, <strong>4</strong> (1), 77-91.
</p>
<p>Kotz, S., N. Balakrishnan, and N. L. Johnson (2000). <em>Continuous Multivariate Distributions</em>, Volume 1, Models and Applications. John Wiley &amp; Sons.
</p>
<p>Madsen, K., H. Nielsen, and O. Tingleff (2004). Optimization With Constraints. <em>Informatics and Mathematical Modelling</em>, Technical University of Denmark.
</p>
<p>Monti, G. S., G. Mateu-Figueras, and V. Pawlowsky-Glahn (2011). Notes on the scaled Dirichlet distribution. In <em>V. Pawlowsky-Glahn and A. Buccianti (Eds.), Compositional data analysis. Theory and applications.</em> Wiley.
</p>
<p>Varadhan, R. (2015). alabama: Constrained Nonlinear Optimization. R package version 2015.3-1.
</p>
<p>Wicker, N., J. Muller, R. K. R. Kalathur, and O. Poch (2008). A maximum likelihood approximation
method for Dirichlet parameter estimation. Computational Statistics &amp; Data Analysis 52 (3), 1315-1322.
</p>
<p>Zeileis, A. and Y. Croissant (2010). Extended model formulas in R: Multiple parts and multiple responses. <em>Journal of Statistical Software</em> <strong>34</strong> (1), 1-13.
</p>


<h3>See Also</h3>

<p><code>stepSGB</code>, for an experimental stepwise descending regression, <code>initpar.SGB</code>, for the computation of initial parameters.
This function uses <code>Formula</code>, <code>auglag</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Regression for car segment shares
## ---------------------------------
data(carseg)
## Extract the compositions
uc &lt;- as.matrix(carseg[,(1:5)])

## Extract the explanatory variables
attach(carseg)

## Example 1: without formula
## --------------------------
## Change some variables
dc &lt;- data.frame(l.exp1=log(expend)*PAC,l.exp0=log(expend)*(1-PAC), l.sent=log(sent),
l.FBCF=log(FBCF), l.price=log(price), rates)

## Define the log-ratio transformation matrix
Vc &lt;- matrix(c( 1,0,0,0,
               -1,1,0,0,
               0,-1,1,0,
               0,0,-1,1,
               0,0,0,-1),ncol=4,byrow=TRUE)
colnames(Vc) &lt;- c("AB","BC","CD","DE")
rownames(Vc) &lt;- colnames(uc)
Vc

# 2 next rows  only necessary when calling regSGB without a formula.
dc1 &lt;- cbind("(Intercept)"= 1 , dc)
dc1 &lt;- as.matrix(dc1)   

object10 &lt;- regSGB(dc1,uc, Vc,shape10=4.4)
summary(object10)

## Example 2: same with formula
## ----------------------------
## Define the formula
Form &lt;- Formula(AB | BC | CD | DE ~  l.exp1 + l.exp0 + l.sent + l.FBCF + l.price +  rates)

## Regression with formula
object1 &lt;- regSGB(Form, data= list(dc, uc, Vc),shape10=4.4)

summary(object1)

## Example 3: Usage of I()
## -----------------------
Form2 &lt;- Formula(AB | BC | CD | DE ~  I(l.exp1 + l.exp0) + l.exp1 +l.sent + 
                 l.FBCF + l.price + rates )
object2 &lt;- regSGB(Form2,data= list(dc, uc, Vc),shape10=4.4)
object2

## Example 4: Usage of variable transformations on the original file
## -----------------------------------------------------------------
Form3 &lt;- Formula(AB | BC | CD | DE ~  log(expend) + I(PAC*log(expend)) + log(sent) + log(FBCF) + 
                 log(price) + rates)
object3 &lt;- regSGB(Form3, data=list(carseg, uc, Vc),shape10=4.4)
object3
object2[["par"]]-object3[["par"]]    # same results

## Example 5: Fixing parameter values
## ----------------------------------
## 1. In the following regression we condition on shape1 = 2.36.
object4 &lt;- regSGB(Form3,data=list(carseg, uc, Vc), 
                  shape10 = 4.4,  bound = 2.0, ind = 1, shape1 = 2.36)
summary(object4)

## 2. In the following regression we condition on shape1 = 2.36 and the  coefficient of 
## log(FBCF).BC = 0.  Notice that it is the 19th parameter.
object5 &lt;- regSGB(Form3,data=list(carseg, uc, Vc),
                  shape10 = 4.4, bound = 2.0, ind = c(1,19) , shape1 = 2.36)
summary(object5)

object3[["AIC"]]
object4[["AIC"]]  # largest AIC
object5[["AIC"]]
</code></pre>


</div>