<div class="container">

<table style="width: 100%;"><tr>
<td>predict.intPGOcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for prediction at new locations for single-species integrated occupancy models</h2>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'intPGOcc'. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'intPGOcc'
predict(object, X.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class intPGOcc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.0</code></td>
<td>
<p>the design matrix for prediction locations. This should include a column of 1s for the intercept. Covariates should have the same column names as those used when fitting the model with <code>intPGOcc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>predict.intPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence probability values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence values.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br>
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1008)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 10
J.y &lt;- 10
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 1)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- runif(2, -1, 1)
}
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = FALSE)

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2]) 
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2]) 
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2]) 
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2]) 
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites)

J &lt;- length(dat$z.obs)
# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)))
n.samples &lt;- 5000
out &lt;- intPGOcc(occ.formula = ~ occ.cov, 
                det.formula = list(f.1 = ~ det.cov.1.1, 
                                   f.2 = ~ det.cov.2.1, 
                                   f.3 = ~ det.cov.3.1, 
                                   f.4 = ~ det.cov.4.1), 
                data = data.list,
                inits = inits.list,
                n.samples = n.samples, 
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1000, 
                n.burn = 4000, 
                n.thin = 1)

summary(out)

# Prediction
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred

out.pred &lt;- predict(out, X.0)
psi.hat.quants &lt;- apply(out.pred$psi.0.samples, 2, quantile, c(0.025, 0.5, 0.975))
plot(psi.0, psi.hat.quants[2, ], pch = 19, xlab = 'True', 
     ylab = 'Fitted', ylim = c(min(psi.hat.quants), max(psi.hat.quants)))
segments(psi.0, psi.hat.quants[1, ], psi.0, psi.hat.quants[3, ])
lines(psi.0, psi.0)
</code></pre>


</div>