<div class="container">

<table style="width: 100%;"><tr>
<td>mergeRaster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split and re-merge <code>RasterLayer</code>(s)</h2>

<h3>Description</h3>

<p><code>splitRaster</code> divides up a raster into an arbitrary number of pieces (tiles).
Split rasters can be recombined using <code>do.call(merge, y)</code> or <code>mergeRaster(y)</code>,
where <code>y &lt;- splitRaster(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mergeRaster(x, fun = NULL)

## S4 method for signature 'list'
mergeRaster(x, fun = NULL)

splitRaster(
  r,
  nx = 1,
  ny = 1,
  buffer = c(0, 0),
  path = NA,
  cl,
  rType = "FLT4S",
  fExt = ".tif"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A list of split raster tiles (i.e., from <code>splitRaster</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function (e.g. <code>mean</code>, <code>min</code>, or <code>max</code> that
accepts a <code>na.rm</code> argument. The default is <code>mean</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The raster to be split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>The number of tiles to make along the x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny</code></td>
<td>
<p>The number of tiles to make along the y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p>Numeric vector of length 2 giving the size of the buffer along the x and y axes.
If values greater than or equal to <code>1</code> are used, this
is interpreted as the number of pixels (cells) to use as a buffer.
Values between <code>0</code> and <code>1</code> are interpreted as proportions
of the number of pixels in each tile (rounded up to an integer value).
Default is <code>c(0, 0)</code>, which means no buffer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>Character specifying the directory to which the split tiles will be saved.
If missing, the function will write to memory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>A cluster object. Optional. This would generally be created using
<code>parallel::makeCluster()</code> or equivalent. This is an alternative way, instead
of <code>beginCluster()</code>, to use parallelism for this function, allowing for
more control over cluster use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rType</code></td>
<td>
<p>Data type of the split rasters. Defaults to FLT4S.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fExt</code></td>
<td>
<p>file extension (e.g., <code>".grd"</code> or <code>".tif"</code>) specifying the file format.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>mergeRaster</code> differs from <code>merge</code> in how overlapping tile regions
are handled: <code>merge</code> retains the values of the first raster in the list.
This has the consequence of retaining the values from the buffered
region in the first tile in place of the values from the neighbouring tile.
On the other hand, <code>mergeRaster</code> retains the values of the tile region,
over the values in any buffered regions.
This is useful for reducing edge effects when performing raster operations involving
contagious processes.
</p>
<p>This function is parallel-aware using the same mechanism as used in <span class="pkg">raster</span>:
NOTE: This may not work as expected as we transition away from <code>raster</code>.
Specifically, if you start a cluster using <code>raster::beginCluster()</code>,
then this function will automatically use that cluster.
It is always a good idea to stop the cluster when finished, using <code>raster::endCluster()</code>.
</p>


<h3>Value</h3>

<p><code>mergeRaster</code> returns a <code>RasterLayer</code> object.
</p>
<p><code>splitRaster</code> returns a list (length <code>nx*ny</code>) of cropped raster tiles.
</p>


<h3>Author(s)</h3>

<p>Yong Luo, Alex Chubaty, Tati Micheletti &amp; Ian Eddy
</p>
<p>Alex Chubaty and Yong Luo
</p>


<h3>See Also</h3>

<p><code>terra::merge()</code>, <code>terra::mosaic()</code>
</p>
<p><code>do.call()</code>, <code>terra::merge()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1462)

## an example with dimensions: nrow = 77,  ncol = 101, nlayers = 3
b &lt;- rast(system.file("ex/logo.tif", package = "terra"))
r &lt;- b[[1]] # use first layer only
nx &lt;- 3
ny &lt;- 4

tmpdir &lt;- dir.create(file.path(tempdir(), "splitRaster-example"), showWarnings = FALSE)

y0 &lt;- splitRaster(r, nx, ny, path = file.path(tmpdir, "y0")) # no buffer

## buffer: 10 pixels along both axes
y1 &lt;- splitRaster(r, nx, ny, c(10, 10), path = file.path(tmpdir, "y1"))

## buffer: half the width and length of each tile
y2 &lt;- splitRaster(r, nx, ny, c(0.5, 0.5), path = file.path(tmpdir, "y2"))

## the original raster:
if (interactive()) plot(r) # may require a call to `dev()` if using RStudio

## the split raster:
layout(mat = matrix(seq_len(nx * ny), ncol = nx, nrow = ny))
plotOrder &lt;- unlist(lapply(split(1:12, rep(1:nx, each = ny)), rev))

if (interactive()) {
  invisible(lapply(y0[plotOrder], terra::plot))
}

## parallel splitting
if (requireNamespace("raster", quietly = TRUE) &amp;&amp;
    requireNamespace("parallel")) {
  if (interactive()) {
    n &lt;- pmin(parallel::detectCores(), 4) # use up to 4 cores
    raster::beginCluster(n, type = "PSOCK")
    y3 &lt;- splitRaster(r, nx, ny, c(0.7, 0.7), path = file.path(tmpdir, "y3"))
    raster::endCluster()
    if (interactive()) {
      invisible(lapply(y3[plotOrder], terra::plot))
    }
  }
}

## can be recombined using `terra::merge`
m0 &lt;- do.call(merge, y0)
all.equal(m0, r) ## TRUE

m1 &lt;- do.call(merge, y1)
all.equal(m1, r) ## TRUE

m2 &lt;- do.call(merge, y2)
all.equal(m2, r) ## TRUE

## or recombine using mergeRaster
n0 &lt;- mergeRaster(y0)
all.equal(n0, r) ## TRUE

n1 &lt;- mergeRaster(y1)
all.equal(n1, r) ## TRUE

n2 &lt;- mergeRaster(y2)
all.equal(n2, r) ## TRUE

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
unlink(tmpdir, recursive = TRUE)
</code></pre>


</div>