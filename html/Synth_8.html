<div class="container">

<table style="width: 100%;"><tr>
<td>synth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Constructs synthetic control units for comparative case studies
</h2>

<h3>Description</h3>

<p>Implements the synthetic control method for causal inference in comparative case studies as developed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010, 2011, 2014). <code>synth</code> estimates the effect of an intervention by comparing the evolution of an aggregate outcome for a unit affected by the intervention to the evolution of the same aggregate outcome for a synthetic control group.
</p>
<p><code>synth</code> constructs this synthetic control group by searching for a weighted combination of control units chosen to approximate the unit affected by the intervention in terms of characteristics that are predictive of the outcome. The evolution of the outcome for the resulting synthetic control group is an estimate of the counterfactual of what would have been observed for the affected unit in the absence of the intervention. 
</p>
<p><code>synth</code> can also be used to conduct a variety of placebo and permutation tests that produce
informative inference regardless of the number of available comparison units and the number of available time-periods. See Abadie and Gardeazabal (2003), Abadie, Diamond, and Hainmueller (2010, 2011, 2014) for details.
</p>
<p><code>synth</code> requires the user to supply four matrices as its main arguments. These matrices are named X0, X1, Z1, and Z0 accordingly. X1 and X0 contain the predictor values for the treated unit and the control units respectively. Z1 and Z0 contain the outcome variable for the pre-intervention period for the treated unit and the control unit respectively. The pre-intervention period refers to the time period prior to the intervention, over which the mean squared prediction error (MSPE) should be minimized. The MSPE refers to the squared deviations between the outcome for the treated unit and the
synthetic control unit summed over all pre-intervention periods specified in Z1 and Z0.
</p>
<p>Creating the matrices X1, X0, Z1, and Z0 from a (panel) dataset can be tedious. Therefore the <code>Synth</code> library offers a preparatory function called <code>dataprep</code> that allows the user to easily create all inputs required for <code>synth</code>. By first calling <code>dataprep</code> the user creates a single list object called <code>data.prep.obj</code> that contains all essential data elements to run <code>synth</code>. 
</p>
<p>Accordingly, a usual sequence of commands to implement the synthetic control method is to first call <code>dataprep</code> to prepare the data to be loaded into <code>synth</code>. Then 
<code>synth</code> is called to construct the synthetic control group. Finally, results are 
summarized using the functions <code>synth.tab</code>, <code>path.plot</code>, or <code>gaps.plot</code>.
</p>
<p>An example of this sequence is provided in the documentation to <code>dataprep</code>. This procedure is strongly recommended. Alternatively, the user may provide his own preprocessed data matrices and load them into <code>synth</code> via the X0, X1, Z1, and Z0 arguments. In this case, no data.prep.obj should be specified.
</p>
<p>The output from <code>synth</code> is a list object that contains the weights on predictors (solution.V) and weights on control units (solution.W) that define contributions 
to the synthetic control unit. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">synth(data.prep.obj = NULL,
X1 = NULL, X0 = NULL, 
Z0 = NULL, Z1 = NULL, 
custom.v = NULL, 
optimxmethod = c("Nelder-Mead", "BFGS"), 
genoud = FALSE, quadopt = "ipop", 
Margin.ipop = 5e-04, 
Sigf.ipop = 5, 
Bound.ipop = 10, 
verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.prep.obj</code></td>
<td>

<p>the object that comes from running <code>dataprep</code>. This object contains all information about X0, X1, Z1, and Z0. Therefore, if data.prep.obj is supplied, none of X0, X1, Z1, and Z0 should be manually specified!
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>

<p>matrix of treated predictor data, nrows = number of predictors ncols = ones.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X0</code></td>
<td>

<p>matrix of controls' predictor data. nrows = number of predictors. ncols = number of control units (&gt;=2). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z1</code></td>
<td>

<p>matrix of treated outcome data for the pre-treatment periods over which MSPE is to be minimized.
nrows = number of pre-treatment periods. ncols = 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z0</code></td>
<td>

<p>matrix of controls' outcome data for the pre-treatment periods over which MSPE is to be minimized. nrows = number of pre-treatment periods. ncols = number of control units.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom.v</code></td>
<td>

<p>vector of weights for predictors supplied by the user. uses <code>synth</code> to bypass optimization for solution.V. See details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimxmethod</code></td>
<td>

<p>string vector that specifies the optimization algorithms to be used. Permissable values are all optimization algorithms that are currently implemented in the <code>optimx</code> function (see this function for details). This list currently includes c("Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf"). If multiple algorithms are specified, <code>synth</code> will run the optimization with all chosen algorithms and then return the result for the best performing method. Default is c("Nelder-Mead", "BFGS"). As an additional possibility, the user can also specify 'All' which means that <code>synth</code> will run the results over all algorithms in <code>optimx</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genoud</code></td>
<td>

<p>Logical flag. If true, <code>synth</code> embarks on a two step optimization. In the first step, <code>genoud</code>, an optimization function that combines evolutionary algorithm methods with a derivative-based (quasi-Newton) method to solve difficult optimization problems, is used to obtain a solution. See <code>genoud</code> for details. In the second step, the genoud results are passed to the optimization algorithm(s) chosen in <code>optimxmethod</code> for a local optimization within the neighborhood of the genoud solution. This two step optimization procedure will require much more computing time, but may yield lower loss in cases where the search space is highly irregular.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadopt</code></td>
<td>

<p>string vector that specifies the routine for quadratic optimization over w weights. possible values are "ipop" (see <code>ipop</code> for details). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Margin.ipop</code></td>
<td>

<p>setting for ipop optimization routine: how close we get to the constrains (see <code>ipop</code> for details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigf.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Precision (default: 7 significant figures (see <code>ipop</code> for details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bound.ipop</code></td>
<td>

<p>setting for ipop optimization routine: Clipping bound for the variables (see <code>ipop</code> for details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical flag. If TRUE then intermediate results will be shown.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments to be passed to <code>optimx</code> and or <code>genoud</code> to adjust optimization.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller (2010), the <code>synth</code> function routinely searches for the set of weights that generate the best fitting convex combination of the control units. In other words, the predictor weight matrix V is chosen among all positive definite diagonal matrices such that MSPE is minimized for the pre-intervention period. 
</p>
<p>Instead of using this data-driven procedures to search for the best fitting synthetic control group, the
user may supply his own vector of V weights, based on his subjective assessment of the predictive power of the variables in X1 and X0. In this case, the vector of V weights for each variable should be supplied via the <code>custom.V</code> option in <code>synth</code> and the optimization over the V matrices is bypassed.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>solution.v </code></td>
<td>
<p>vector of predictor weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution.w </code></td>
<td>
<p>vector of weights across the controls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss.v </code></td>
<td>
<p>  MSPE from optimization over v and w weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss.w </code></td>
<td>
<p>  Loss from optimization over w weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom.v </code></td>
<td>
<p>if this argument was specified in the call to <code>synth</code>, this
outputs the weight vector specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rgV.optim</code></td>
<td>
<p>Results from optimx() minimization. Could be used for diagnostics.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jens Hainmueller and Alexis Diamond
</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A., Hainmueller, J. (2014). Comparative Politics and the Synthetic Control Method. <em>American Journal of Political Science</em> Forthcoming 2014.
</p>
<p>Synthetic : An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1–17.
</p>
<p>Abadie, A., Diamond, A., Hainmueller, J. (2011). Synth: An R Package for Synthetic Control Methods in Comparative Case Studies. <em>Journal of Statistical Software</em> 42 (13) 1–17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic Control Methods for Comparative Case Studies: Estimating the Effect of California's Tobacco Control Program. <em>Journal of the American Statistical Association</em> 105 (490) 493–505.
</p>
<p>Abadie, A. and Gardeazabal, J. (2003) Economic Costs of Conflict: A Case Study of the Basque Country <em>American Economic Review</em> 93 (1) 113–132.
</p>


<h3>See Also</h3>

<p><code>dataprep</code>, <code>gaps.plot</code>, <code>path.plot</code>, <code>synth.tab</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## While synth() can be used to construct synthetic control groups
## directly, by providing the X1, X0, Z1, and Z0 matrices, we strongly
## recommend to first run dataprep() to extract these matrices 
## and pass them to synth() as a single object

## The usual sequence of commands is:
## 1. dataprep() for matrix-extraction
## 2. synth() for the construction of the synthetic control group
## 3. synth.tab(), gaps.plot(), and path.plot() to summarize the results
## Below we provide two examples


## First Example: Toy panel dataset

# load data
data(synth.data)

# create matrices from panel data that provide inputs for synth()
dataprep.out&lt;-
  dataprep(
   foo = synth.data,
   predictors = c("X1", "X2", "X3"),
   predictors.op = "mean",
   dependent = "Y",
   unit.variable = "unit.num",
   time.variable = "year",
   special.predictors = list(
      list("Y", 1991, "mean"),
      list("Y", 1985, "mean"),
      list("Y", 1980, "mean")
                            ),
   treatment.identifier = 7,
   controls.identifier = c(29, 2, 13, 17, 32, 38),
   time.predictors.prior = c(1984:1989),
   time.optimize.ssr = c(1984:1990),
   unit.names.variable = "name",
   time.plot = 1984:1996
   )

## run the synth command to identify the weights
## that create the best possible synthetic 
## control unit for the treated.
synth.out &lt;- synth(dataprep.out)

## there are two ways to summarize the results
## we can either access the output from synth.out directly
round(synth.out$solution.w,2)
# contains the unit weights or
synth.out$solution.v 
## contains the predictor weights. 

## the output from synth opt 
## can be flexibly combined with 
## the output from dataprep to 
## compute other quantities of interest
## for example, the period by period 
## discrepancies between the 
## treated unit and its synthetic control unit
## can be computed by typing
gaps&lt;- dataprep.out$Y1plot-(
        dataprep.out$Y0plot%*%synth.out$solution.w
        ) ; gaps

## also there are three convenience functions to summarize results.
## to get summary tables for all information 
## (V and W weights plus balance btw. 
## treated and synthetic control) use the 
## synth.tab() command
synth.tables &lt;- synth.tab(
      dataprep.res = dataprep.out,
      synth.res = synth.out)
print(synth.tables)

## to get summary plots for outcome trajectories 
## of the treated and the synthetic control unit use the 
## path.plot() and the gaps.plot() commands

## plot in levels (treated and synthetic)
path.plot(dataprep.res = dataprep.out,synth.res = synth.out)

## plot the gaps (treated - synthetic)
gaps.plot(dataprep.res = dataprep.out,synth.res = synth.out)



## Second example: The economic impact of terrorism in the
## Basque country using data from Abadie and Gardeazabal (2003)
## see JSS paper in the references details

data(basque)

# dataprep: prepare data for synth
dataprep.out &lt;-
  dataprep(
  foo = basque
  ,predictors= c("school.illit",
                 "school.prim",
                 "school.med",
                 "school.high",
                 "school.post.high"
                 ,"invest"
                 )
   ,predictors.op = c("mean")
   ,dependent     = c("gdpcap")
   ,unit.variable = c("regionno")
   ,time.variable = c("year")
   ,special.predictors = list(
    list("gdpcap",1960:1969,c("mean")),                            
    list("sec.agriculture",seq(1961,1969,2),c("mean")),
    list("sec.energy",seq(1961,1969,2),c("mean")),
    list("sec.industry",seq(1961,1969,2),c("mean")),
    list("sec.construction",seq(1961,1969,2),c("mean")),
    list("sec.services.venta",seq(1961,1969,2),c("mean")),
    list("sec.services.nonventa",seq(1961,1969,2),c("mean")),
    list("popdens",1969,c("mean")))
    ,treatment.identifier  = 17
    ,controls.identifier   = c(2:16,18)
    ,time.predictors.prior = c(1964:1969)
    ,time.optimize.ssr     = c(1960:1969)
    ,unit.names.variable   = c("regionname")
    ,time.plot            = c(1955:1997) 
    )

# 1. combine highest and second highest 
# schooling category and eliminate highest category
dataprep.out$X1["school.high",] &lt;- 
 dataprep.out$X1["school.high",] + 
 dataprep.out$X1["school.post.high",]
dataprep.out$X1                 &lt;- 
 as.matrix(dataprep.out$X1[
  -which(rownames(dataprep.out$X1)=="school.post.high"),])
dataprep.out$X0["school.high",] &lt;- 
 dataprep.out$X0["school.high",] + 
 dataprep.out$X0["school.post.high",]
dataprep.out$X0                 &lt;- 
dataprep.out$X0[
 -which(rownames(dataprep.out$X0)=="school.post.high"),]

# 2. make total and compute shares for the schooling catgeories
lowest  &lt;- which(rownames(dataprep.out$X0)=="school.illit")
highest &lt;- which(rownames(dataprep.out$X0)=="school.high")

dataprep.out$X1[lowest:highest,] &lt;- 
 (100 * dataprep.out$X1[lowest:highest,]) /
 sum(dataprep.out$X1[lowest:highest,])
dataprep.out$X0[lowest:highest,] &lt;-  
 100 * scale(dataprep.out$X0[lowest:highest,],
             center=FALSE,
             scale=colSums(dataprep.out$X0[lowest:highest,])
                                                 )
    
# run synth
synth.out &lt;- synth(data.prep.obj = dataprep.out)

# Get result tables
synth.tables &lt;- synth.tab(
                          dataprep.res = dataprep.out,
                          synth.res = synth.out
                          ) 

# results tables:
print(synth.tables)

# plot results:
# path
path.plot(synth.res = synth.out,
          dataprep.res = dataprep.out,
          Ylab = c("real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(0,13), 
          Legend = c("Basque country","synthetic Basque country"),
          ) 

## gaps
gaps.plot(synth.res = synth.out,
          dataprep.res = dataprep.out, 
          Ylab = c("gap in real per-capita GDP (1986 USD, thousand)"),
          Xlab = c("year"), 
          Ylim = c(-1.5,1.5), 
          )


</code></pre>


</div>