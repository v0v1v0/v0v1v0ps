<div class="container">

<table style="width: 100%;"><tr>
<td>spec.lomb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lomb-Scargle Periodigram</h2>

<h3>Description</h3>

<p>The Lomb-Scargle periodigram represents a statistical estimator for the
amplitude and phase at a given frequency. This function takes also multivariate
(n-dimensional) input data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spec.lomb(
  x = NULL,
  y = stop("Missing y-Value"),
  f = NULL,
  ofac = 1,
  w = NULL,
  mode = "normal",
  maxMem = 8,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>sampling vector or data frame <code>data.frame(x1, x2, x3, ...)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>input data vector or data frame <code>data.frame(x1, x2, ..., val)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>optional frequency vector / data frame. If not supplied <code>f</code> is calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ofac</code></td>
<td>
<p>in case <code>f=NULL</code> this value controlls the amount of frequency
oversampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weights for data. It must be a 1D vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p><code>"normal"</code> calculates the normal Lomb-Scargle periodogram;
<code>"generalized"</code> calculates the generalized Lomb-Scargle periodogram including
floating average and weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxMem</code></td>
<td>
<p>sets the amount of memory (in MB) to utilize, as a rough approximate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>if <code>numeric</code>, it defines the number of workers to use, or provides a cluster
definition of class <code>cluster</code> or <code>SocketCluster</code> from <code>parallel</code> package</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Since the given time series does not need to be evenly sampled, the data
mainly consists of data pairs <code>x1, x2, x3, ...</code> (sampling points) and (one)
corresponding value <code>y</code>, which stores the realisation/measurement data.
As can be seen from the data definition above, multivariate (n-dimensional)
input data is allowed and properly processed.
</p>
<p>Two different methods are implemented: the standard Lomb-Scargle method with
</p>
<p><code class="reqn">y(t) = a * cos(\omega (t - \tau)) + b * sin(\omega (t - \tau))</code>
</p>
<p>as model function and the generalized Lomb-Scargle (after Zechmeister 2009)
method with
</p>
<p><code class="reqn">y(t) = a * cos(\omega t) + b * sin(\omega t) + c</code>
</p>
<p>as model function, which investigates a floating average parameter <code class="reqn">c</code>
as well.
</p>
<p>Both methods can be supplied by an artifical dense frequency vector <code>f</code>.
In conjunction with the resulting phase information the user might be able to
build a "Fourier"-like spectrum to reconstruct or interpolate the timeseries in equally
spaced sampling. Remind the band limitation which must be fulfilled for this.
</p>

<dl>
<dt>f</dt>
<dd>
<p>The frequencies should be stored in a 1D vector or – in case of
multivariate analysis – in a <code>data.frame</code> structure to preserve variable names</p>
</dd>
<dt><code>ofac</code></dt>
<dd>
<p>If the user does not provide a corresponding frequency
vector, the <code>ofac</code> parameter causes the function to estimate
</p>
<p style="text-align: center;"><code class="reqn">nf = ofac*length(x)/2</code>
</p>
<p> equidistant frequencies.</p>
</dd>
<dt>
<code>p</code>-value</dt>
<dd>
<p>The <code>p</code>-value (aka false alarm probability FAP)
gives the probability, wheter the estimated amplitude is NOT significant.
However, if <code>p</code> tends to zero the
amplidutde is significant. The user must decide which maximum value is acceptable,
until an amplitude is not valid.</p>
</dd>
</dl>
<p>If missing values <code>NA</code> or <code>NaN</code> appear in any column, the corresponding row
is excluded from calculation.
</p>


<h3>Value</h3>

<p>The <code>spec.lomb</code> function returns an object of the class <code>lomb</code>,
which is a <code>list</code> containg the following information:
</p>

<dl>
<dt><code>A</code></dt>
<dd>
<p>A vector with amplitude spectrum</p>
</dd>
<dt><code>f</code></dt>
<dd>
<p>corresponding frequency vector</p>
</dd>
<dt><code>phi</code></dt>
<dd>
<p>phase vector</p>
</dd>
<dt><code>PSD</code></dt>
<dd>
<p>power spectral density normalized to the sample variance</p>
</dd>
<dt><code>floatAvg</code></dt>
<dd>
<p>floating average value only in case of
<code>mode == "generalized"</code></p>
</dd>
<dt><code>w</code></dt>
<dd>
<p>if, <code>mode == "generalized"</code> contains the weighting vector</p>
</dd>
<dt><code>x,y</code></dt>
<dd>
<p>original data</p>
</dd>
<dt>p</dt>
<dd>
<p>p-value False Alarm Probability</p>
</dd>
</dl>
<h3>Speed Up</h3>

<p>In general the function calculates everything in a vectorized manner, which
speeds up the procedure. If the memory requirement is more than <code>maxMem</code>,
the calculation is split into chunks which fit in the memory (cache). Depending on the
problem size (number of frequencies and data size) a tuning of this value
enhances speed.
</p>
<p>Please consider to replpace the BLAS library by a multithreaded version. For example
<a href="https://prs.ism.ac.jp/~nakama/SurviveGotoBLAS2/binary/windows/x64/">https://prs.ism.ac.jp/~nakama/SurviveGotoBLAS2/binary/windows/x64/</a> is hosting
some Windows RBlas.dll files. Refer to <a href="https://mattstats.wordpress.com/2016/02/07/r-with-gotoblas-on-windows-10/">https://mattstats.wordpress.com/2016/02/07/r-with-gotoblas-on-windows-10/</a>
for further information.
</p>
<p>The parameter <code>cl</code> controls a possible cluster, which can be invoked. It takes an
integer number of workers (i. e. <code>cl = 4</code>), a list with node names <code>c("localhost",...)</code>
or an object of class <code>'cluster'</code> or similar. The first two options cause the
function to create the cluster internally. This takes time due to the initialization.
The faster way is to provide an already initialized cluster to the function.
</p>


<h3>References</h3>

<p>A. Mathias, F. Grond, R. Guardans, D. Seese, M. Canela, H. H. Diebner,
and G. Baiocchi, "Algorithms for spectral analysis of irregularly sampled
time series", Journal of Statistical Software, 11(2), pp. 1–30, 2004.
</p>
<p>J. D. Scargle, "Studies in astronomical time series analysis. II - Statistical
aspects of spectral analysis of unevenly spaced data", The Astrophysical Journal,
263, pp. 835–853, 1982.
</p>
<p>M. Zechmeister and M. Kurster, "The generalised Lomb-Scargle periodogram.
A new formalism for the floating-mean and Keplerian periodograms",
Astronomy &amp; Astrophysics, 496(2), pp. 577–584, 2009.
</p>


<h3>See Also</h3>

<p><code>filter.lomb</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create two sin-functions
x_orig &lt;- seq(0,1,by=1e-2)
y_orig &lt;- 2*sin(10*2*pi*x_orig) + 1.5*sin(2*2*pi*x_orig)

# make a 10% gap
i &lt;- round(length(x_orig)*0.2) : round(length(x_orig)*0.3)
x &lt;- x_orig
y &lt;- y_orig
x[i] &lt;- NA
y[i] &lt;- NA


# calculating the lomb periodogram
l &lt;- spec.lomb(x = x, y = y,ofac = 20,mode = "normal")

# select a frequency range
m &lt;- rbind(c(9,11))
# select and reconstruct the most significant component
l2 = filter.lomb(l, x_orig, filt = m)

# plot everything
par(mfrow=c(2,1),mar = c(4,4,2,4))
plot(x,y,"l", main = "Gapped signal")
lines(l2$x, l2$y,lty=2)
legend("bottomleft",c("gapped","10Hz component"),lty=c(1,2))

plot(l,main = "Spectrum")

summary(l)

### Multivariate -- 3D Expample ###
require(lattice)
fx &lt;- 8.1
fy &lt;- 5
fz &lt;- 2

# creating frequency space
f &lt;- expand.grid( fx = seq(-10,10,by = 0.5)
                  ,fy = seq(-10,10,by = 0.5)
                  ,fz = 0:3
)

# creating spatial space
pts &lt;- expand.grid( x = seq(0,1,by = 0.02)
                   ,y = seq(0,1,by = 0.02)
                   ,z = seq(0,1,by = 0.02)
)

# gapping 30%
i &lt;- sample(1:dim(pts)[1],0.7*dim(pts)[1])
pts &lt;- pts[i,]

# caluculating function
pts$val &lt;- cos(2*pi*(  fx*pts$x
                     + fy*pts$y
                     + fz*pts$z
                    ) + pi/4
              ) +
  0.5 * cos(2*pi*(  - 0.5 * fx*pts$x
              + 0.5*fy*pts$y
              + 1 * pts$z
  ) + pi/4
  )

# display with lattice
levelplot(val~x+y,pts,subset = z == 0,main = "with z = 0")

# calculating lomb takes a while
# or we sample only a few points
# which enlarges the noise but accelerates the calculation
l &lt;- spec.lomb(y = pts[sample(1:dim(pts)[1],2e3),]
               ,f = f
               # ,mode = "generalized"
               )

# name the stripes
l$fz_lev &lt;- factor(x = paste("fz =",l$fz)
)

# display output
levelplot(PSD~fx+fy|fz_lev,l)

# the result is an oversampled spectrum of a non equidistant
# sampled function. We recognize a 3D analysis in all provided
# spatial directions x, y, z.

summary(l)
</code></pre>


</div>