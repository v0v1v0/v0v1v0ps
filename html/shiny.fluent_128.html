<div class="container">

<table style="width: 100%;"><tr>
<td>MaskedTextField</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>TextField</h2>

<h3>Description</h3>

<p>Text fields (<code>TextField</code>) give people a way to enter and edit text. They’re used in forms, modal dialogs, tables, and other surfaces where text input is required.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/TextField">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MaskedTextField(...)

TextField(...)

TextField.shinyInput(inputId, ..., value = defaultValue)

updateTextField.shinyInput(
  session = shiny::getDefaultReactiveDomain(),
  inputId,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputId</code></td>
<td>
<p>ID of the component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>Starting value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>Object passed as the <code>session</code> argument to Shiny server.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li> <p><b> ariaLabel </b> <code>string</code> <br> Aria label for the text field.
</p>
</li>
<li> <p><b> autoAdjustHeight </b> <code>boolean</code> <br> For multiline text fields, whether or not to auto adjust text field height.
</p>
</li>
<li> <p><b> autoComplete </b> <code>string</code> <br> Whether the input field should have autocomplete enabled. This tells the browser to display options based on earlier typed values. Common values are 'on' and 'off' but for all possible values see the following links: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#Values https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill
</p>
</li>
<li> <p><b> borderless </b> <code>boolean</code> <br> Whether or not the text field is borderless.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> Optional class name that is added to the container of the component.
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;ITextField&gt;⁠</code> <br> Optional callback to access the ITextField component. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> defaultValue </b> <code>string</code> <br> Default value of the text field. Only provide this if the text field is an uncontrolled component; otherwise, use the <code>value</code> property.
</p>
</li>
<li> <p><b> deferredValidationTime </b> <code>number</code> <br> Text field will start to validate after users stop typing for <code>deferredValidationTime</code> milliseconds. Updates to this prop will not be respected.
</p>
</li>
<li> <p><b> description </b> <code>string</code> <br> Description displayed below the text field to provide additional details about what text to enter.
</p>
</li>
<li> <p><b> disabled </b> <code>boolean</code> <br> Disabled state of the text field.
</p>
</li>
<li> <p><b> errorMessage </b> <code>string | JSX.Element</code> <br> Static error message displayed below the text field. Use <code>onGetErrorMessage</code> to dynamically change the error message displayed (if any) based on the current value. <code>errorMessage</code> and <code>onGetErrorMessage</code> are mutually exclusive (<code>errorMessage</code> takes precedence).
</p>
</li>
<li> <p><b> iconProps </b> <code>IIconProps</code> <br> Props for an optional icon, displayed in the far right end of the text field.
</p>
</li>
<li> <p><b> inputClassName </b> <code>string</code> <br> Optional class name that is added specifically to the input/textarea element.
</p>
</li>
<li> <p><b> label </b> <code>string</code> <br> Label displayed above the text field (and read by screen readers).
</p>
</li>
<li> <p><b> mask </b> <code>string</code> <br> Only used by MaskedTextField: The masking string that defines the mask's behavior. A backslash will escape any character. Special format characters are: '9': <code style="white-space: pre;">⁠[0-9]⁠</code> 'a': <code style="white-space: pre;">⁠[a-zA-Z]⁠</code> '*': <code style="white-space: pre;">⁠[a-zA-Z0-9]⁠</code>
</p>
</li>
<li> <p><b> maskChar </b> <code>string</code> <br> Only used by MaskedTextField: The character to show in place of unfilled characters of the mask.
</p>
</li>
<li> <p><b> maskFormat </b> <code style="white-space: pre;">⁠{ [key: string]: RegExp; }⁠</code> <br> Only used by MaskedTextField: An object defining the format characters and corresponding regexp values. Default format characters: { '9': /<code style="white-space: pre;">⁠[0-9]⁠</code>/, 'a': /<code style="white-space: pre;">⁠[a-zA-Z]⁠</code>/, '*': /<code style="white-space: pre;">⁠[a-zA-Z0-9]⁠</code>/ }
</p>
</li>
<li> <p><b> multiline </b> <code>boolean</code> <br> Whether or not the text field is a multiline text field.
</p>
</li>
<li> <p><b> onChange </b> <code style="white-space: pre;">⁠(event: React.FormEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;, newValue?: string) =&gt; void⁠</code> <br> Callback for when the input value changes. This is called on both <code>input</code> and <code>change</code> events. (In a later version, this will probably only be called for the <code>change</code> event.)
</p>
</li>
<li> <p><b> onGetErrorMessage </b> <code style="white-space: pre;">⁠(value: string) =&gt; string | JSX.Element | PromiseLike&lt;string | JSX.Element&gt; | undefined⁠</code> <br> Function used to determine whether the input value is valid and get an error message if not. Mutually exclusive with the static string <code>errorMessage</code> (it will take precedence over this).
</p>
</li>
</ul>
<p>When it returns <code>string | JSX.Element</code>: - If valid, it returns empty string. - If invalid, it returns the error message and the text field will show a red border and show an error message below the text field.
</p>
<p>When it returns <code style="white-space: pre;">⁠Promise&lt;string | JSX.Element&gt;⁠</code>: - The resolved value is displayed as the error message. - If rejected, the value is thrown away.
</p>

<ul>
<li> <p><b> onNotifyValidationResult </b> <code style="white-space: pre;">⁠(errorMessage: string | JSX.Element, value: string | undefined) =&gt; void⁠</code> <br> Function called after validation completes.
</p>
</li>
<li> <p><b> onRenderDescription </b> <code style="white-space: pre;">⁠IRenderFunction&lt;ITextFieldProps&gt;⁠</code> <br> Custom renderer for the description.
</p>
</li>
<li> <p><b> onRenderLabel </b> <code style="white-space: pre;">⁠IRenderFunction&lt;ITextFieldProps&gt;⁠</code> <br> Custom renderer for the label. If you don't call defaultRender, ensure that you give your custom-rendered label an id and that you set the textfield's aria-labelledby prop to that id.
</p>
</li>
<li> <p><b> onRenderPrefix </b> <code style="white-space: pre;">⁠IRenderFunction&lt;ITextFieldProps&gt;⁠</code> <br> Custom render function for prefix.
</p>
</li>
<li> <p><b> onRenderSuffix </b> <code style="white-space: pre;">⁠IRenderFunction&lt;ITextFieldProps&gt;⁠</code> <br> Custom render function for suffix.
</p>
</li>
<li> <p><b> prefix </b> <code>string</code> <br> Prefix displayed before the text field contents. This is not included in the value. Ensure a descriptive label is present to assist screen readers, as the value does not include the prefix.
</p>
</li>
<li> <p><b> readOnly </b> <code>boolean</code> <br> If true, the text field is readonly.
</p>
</li>
<li> <p><b> resizable </b> <code>boolean</code> <br> For multiline text fields, whether or not the field is resizable.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;ITextFieldStyleProps, ITextFieldStyles&gt;⁠</code> <br> Call to provide customized styling that will layer on top of the variant rules.
</p>
</li>
<li> <p><b> suffix </b> <code>string</code> <br> Suffix displayed after the text field contents. This is not included in the value. Ensure a descriptive label is present to assist screen readers, as the value does not include the suffix.
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme (provided through customization).
</p>
</li>
<li> <p><b> underlined </b> <code>boolean</code> <br> Whether or not the text field is underlined.
</p>
</li>
<li> <p><b> validateOnFocusIn </b> <code>boolean</code> <br> Run validation when focus moves into the input, and <strong>do not</strong> validate on change.
</p>
</li>
</ul>
<p>(Unless this prop and/or <code>validateOnFocusOut</code> is set to true, validation will run on every change.)
</p>

<ul><li> <p><b> validateOnFocusOut </b> <code>boolean</code> <br> Run validation when focus moves out of the input, and <strong>do not</strong> validate on change.
</p>
</li></ul>
<p>(Unless this prop and/or <code>validateOnFocusIn</code> is set to true, validation will run on every change.)
</p>

<ul>
<li> <p><b> validateOnLoad </b> <code>boolean</code> <br> Whether validation should run when the input is initially rendered.
</p>
</li>
<li> <p><b> value </b> <code>string</code> <br> Current value of the text field. Only provide this if the text field is a controlled component where you are maintaining its current state; otherwise, use the <code>defaultValue</code> property.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
The update functions return nothing (called for side effects).
</p>


<h3>Best practices</h3>



<h4>Layout</h4>


<ul>
<li>
<p> Use a multiline text field when long entries are expected.
</p>
</li>
<li>
<p> Don't place a text field in the middle of a sentence, because the sentence structure might not make sense in all languages. For example, "Remind me in <code style="white-space: pre;">⁠[textfield]⁠</code> weeks" should instead read, "Remind me in this many weeks: <code style="white-space: pre;">⁠[textfield]⁠</code>".
</p>
</li>
<li>
<p> Format the text field for the expected entry. For example, when someone needs to enter a phone number, use an input mask to indicate that three sets of digits should be entered.
</p>
</li>
</ul>
<h4>Content</h4>


<ul>
<li>
<p> Include a short label above the text field to communicate what information should be entered. Don't use placeholder text instead of a label. Placeholder text poses a variety of accessibility issues (including possible problems with color/contrast, and people thinking the form input is already filled out).
</p>
</li>
<li>
<p> When part of a form, make it clear which fields are required vs. optional. If the input is required, add "(required)" to the label. Don't exclusively use "\*" to indicate required inputs as it is often not read by screen readers. For example, "First name (required)".
</p>
</li>
<li>
<p> Use sentence-style capitalization—only capitalize the first word. For more info, see <a href="https://docs.microsoft.com/style-guide/capitalization">Capitalization</a> in the Microsoft Writing Style Guide.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Example 1
library(shiny)
library(shiny.fluent)

ui &lt;- function(id) {
  ns &lt;- NS(id)
  div(
    TextField.shinyInput(ns("text")),
    textOutput(ns("textValue"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    output$textValue &lt;- renderText({
      sprintf("Value: %s", input$text)
    })
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}

# Example 2
library(shiny)
library(shiny.fluent)

# Using custom handler to convert input to uppercase
CustomComponents &lt;- tags$script(HTML("(function() {
  const { InputAdapter } = jsmodule['@/shiny.react'];
  const { TextField } = jsmodule['@fluentui/react'];
  const CustomComponents = jsmodule['CustomComponents'] ??= {};

  CustomComponents.UpperCaseTextField = InputAdapter(TextField, (value, setValue) =&gt; ({
    value: value.toUpperCase(),
    onChange: (e, v) =&gt; setValue(v.toUpperCase()),
  }));
})();"))

UpperCaseTextField &lt;- function(inputId, ..., value = "") {
  shiny.react::reactElement(
    module = "CustomComponents",
    name = "UpperCaseTextField",
    props = shiny.react::asProps(inputId = inputId, ..., value = value),
    deps = shinyFluentDependency()
  )
}

ui &lt;- function(id) {
  ns &lt;- NS(id)
  tagList(
    CustomComponents,
    UpperCaseTextField(ns("uppercase_text")),
    textOutput(ns("text"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    output$text &lt;- renderText(input$uppercase_text)
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>