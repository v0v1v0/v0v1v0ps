<div class="container">

<table style="width: 100%;"><tr>
<td>predint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>prediction interval for Sharpe ratio</h2>

<h3>Description</h3>

<p>Computes the prediction interval for Sharpe ratio.
</p>


<h3>Usage</h3>

<pre><code class="language-R">predint(
  x,
  oosdf,
  oosrescal = 1/sqrt(oosdf + 1),
  ope = NULL,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  type = c("t", "Z", "Mertens", "Bao")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a (non-empty) numeric vector of data values, or an
object of class <code>sr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oosdf</code></td>
<td>
<p>the future (or 'out of sample', thus 'oos') degrees of freedom.
In the vanilla Sharpe case, this is the number of future observations
<em>minus one</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oosrescal</code></td>
<td>
<p>the rescaling parameter for the future Sharpe ratio. The default value
holds for the case of unattributed models ('vanilla Shape'), but can be set
to some other value to deal with the magnitude of attribution factors in the
future period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is to take the same <code>ope</code> from the input <code>x</code>
object, if it is unambiguous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.lo</code></td>
<td>
<p>the lower confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.hi</code></td>
<td>
<p>the upper confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>which method to apply. Only methods based on an approximate
standard error are supported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">n_0</code> observations <code class="reqn">x_i</code> from a normal random variable,
with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma</code>, computes
an interval <code class="reqn">[y_1,y_2]</code> such that with a fixed probability,
the sample Sharpe ratio over <code class="reqn">n</code> future observations will fall in the
given interval. The coverage is over repeated draws of both the past and
future data, thus this computation takes into account error in both the
estimate of Sharpe and the as yet unrealized returns.
Coverage is approximate. Prediction intervals are computed by
inflating a confidence interval by an amount which depends on the sample
sizes.
</p>
<p>See ‘The Sharpe Ratio: Statistics and Applications’,
sections 2.5.9 and 3.5.2.
</p>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper
confidence limits for the parameter. These will be labelled as
level.lo and level.hi in %, <em>e.g.</em> <code>"2.5 %"</code>
</p>


<h3>Note</h3>

<p>if <code>level.lo &lt; 0</code> or <code>level.hi &gt; 1</code>, <code>NaN</code> will be
returned.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. "The Sharpe Ratio: Statistics and Applications." CRC Press, 2021.
</p>
<p>Sharpe, William F. "Mutual fund performance." Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code>confint.sr</code>.
</p>
<p>Other sr: 
<code>as.sr()</code>,
<code>confint.sr()</code>,
<code>dsr()</code>,
<code>is.sr()</code>,
<code>plambdap()</code>,
<code>power.sr_test()</code>,
<code>print.sr()</code>,
<code>reannualize()</code>,
<code>se()</code>,
<code>sr_equality_test()</code>,
<code>sr_test()</code>,
<code>sr_unpaired_test()</code>,
<code>sr_vcov()</code>,
<code>sr</code>,
<code>summary.sr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# should reject null
set.seed(1234)
etc &lt;- predint(rnorm(1000,mean=0.5,sd=0.1),oosdf=127,ope=1)
etc &lt;- predint(matrix(rnorm(1000*5,mean=0.05),ncol=5),oosdf=63,ope=1)

# check coverage
mu &lt;- 0.0005
sg &lt;- 0.013
n1 &lt;- 512
n2 &lt;- 256
p  &lt;- 100
x1 &lt;- matrix(rnorm(n1*p,mean=mu,sd=sg),ncol=p)
x2 &lt;- matrix(rnorm(n2*p,mean=mu,sd=sg),ncol=p)
sr1 &lt;- as.sr(x1)
sr2 &lt;- as.sr(x2)
# check coverage of prediction interval
etc1 &lt;- predint(sr1,oosdf=n2-1,level=0.95)
is.ok &lt;- (etc1[,1] &lt;= sr2$sr) &amp; (sr2$sr &lt;= etc1[,2])
covr &lt;- mean(is.ok)

</code></pre>


</div>