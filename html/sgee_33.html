<div class="container">

<table style="width: 100%;"><tr>
<td>summary.sgee</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coefficient Path summary</h2>

<h3>Description</h3>

<p>Function to analyze  and summarize a path of coefficent values by
comparing them using
prediction error on a \"new\" data set (or fold in CV), or the
original data set if no comparison data is provided. The best point along
the path in terms of the prediction error is identified. All of the
prediction errors for each point along the path, the minimum prediction
error, and the index of the minimum are returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sgee'
summary(object, newX = NULL, newY = NULL, newOffset = NULL,
  trueBeta = NULL, trueIntercept = NULL, scale = NULL,
  classification = 0.5, averaged = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>sgee</code>, from which various path
information is pulled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newX</code></td>
<td>
<p>Design matrix to be used for model testing. It is assumed
that <code>newX</code> does not contain an intercept column. An intercept column
is appended by<code>sgee.summary</code> if an intercept was used to make
<code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newY</code></td>
<td>
<p>Response vector to be used for model testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newOffset</code></td>
<td>
<p>Vector of offsets to be used for model testing. Must be
same length as newY.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trueBeta</code></td>
<td>
<p>For simulation use; true coefficient values can be provided
to get certain metrics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trueIntercept</code></td>
<td>
<p>For simulation use; true intercept value to be used in
conjunction with trueBeta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Scale value can be passed to allow for standardized error
measurements (poisson case only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classification</code></td>
<td>
<p>A numeric parameter from 0 to 1 indicating
cutoff to be used to determine classification rate in Binomial
setting. Default is 0.5. Values below 0 indicate that the
squared error, in either the observation
or the true linear predictor is the trueBeta is given, is to be used
instead of the classification rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>averaged</code></td>
<td>
<p>Logical parameter indicating whether the mean of the
total error is to be used; assumed TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The prediction error used is dependent on the input. If the true Beta is
not given, then the sum squared error (or MSE; see parameter averaged)
in the response is used for gaussian (or non-poisson); for poisson
if the scale (or an estimate) is also given, then the sum squared Pearson
residuals are used, otherwise the deviance is used. If the true Beta is
provided then the sum squared error in the linear predictor is used instead.
</p>
<p>Furthermore, when true Beta is supplied, additional model selection metrics
are produced, including: False Positive Rate, False Discovery Rate,
False Negative Rate.
</p>
<p>The function is provided to allow for model selection; given
a path generated by a sgee function, the path can be fed into this function
with a testing data set to identify an optimal point along the path.
Cross validation can be performed by dividing the original data set
into k folds before hand and generating multiple coefficient paths and
applying this function to each path generated.
</p>


<h3>Value</h3>

<p>A list containing  1) a vector of prediction errors with
testing data set, 2) the smallest prediction error found along path,
3) the index of the smallest error, and if the trueBeta parameter is
provided the False Positive, False Discovery, and false negative
rates, and True positive and False Positive counts
at the index of the smallest error, along with the minimum
mis-classification and corresponding index, where the mis-classification
is the total of the coefficients incorrectly marked as important/unimportant.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2.4,5),
          c(1.3, 0, 1.7, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 1
numGroups &lt;- length(beta)/groupSize



trainingData &lt;- genData(numClusters = 50,
                        clusterSize = 4,
                        clusterRho = 0.6,
                        clusterCorstr = "exchangeable",
                        yVariance = 1,
                        xVariance = 1,
                        numGroups = numGroups,
                        groupSize = groupSize,
                        groupRho = 0.3,
                        beta = beta,
                        family = gaussian(),
                        intercept = 1)

testingData &lt;- genData(numClusters = 50,
                       clusterSize = 4,
                       clusterRho = 0.6,
                       clusterCorstr = "exchangeable",
                       yVariance = 1,
                       xVariance = 1,
                       numGroups = numGroups,
                       groupSize = groupSize,
                       groupRho = 0.3,
                       beta = beta,
                       family = gaussian(),
                       intercept = 1)

coefMat &lt;- see(y = trainingData$y,
               x = trainingData$x,
                    family = gaussian(),
                    clusterID = trainingData$clusterID, 
                    corstr="exchangeable", 
                    maxIt = 200,
                    epsilon = .1)

analysisResults &lt;- summary(coefMat,
                           newX = testingData$x,
                           newY = testingData$y)


</code></pre>


</div>