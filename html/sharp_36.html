<div class="container">

<table style="width: 100%;"><tr>
<td>Graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graph visualisation</h2>

<h3>Description</h3>

<p>Produces an <code>igraph</code> object from an
adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Graph(
  adjacency,
  node_label = NULL,
  node_colour = NULL,
  node_shape = NULL,
  edge_colour = "grey60",
  label_colour = "grey20",
  mode = "undirected",
  weighted = FALSE,
  satellites = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>adjacency matrix or output of <code>GraphicalModel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_label</code></td>
<td>
<p>optional vector of node labels. This vector must contain as
many entries as there are rows/columns in the adjacency matrix and must be
in the same order (the order is used to assign labels to nodes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_colour</code></td>
<td>
<p>optional vector of node colours. This vector must contain
as many entries as there are rows/columns in the adjacency matrix and must
be in the same order (the order is used to assign colours to nodes).
Integers, named colours or RGB values can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_shape</code></td>
<td>
<p>optional vector of node shapes. This vector must contain as
many entries as there are rows/columns in the adjacency matrix and must be
in the same order (the order is used to assign shapes to nodes). Possible
values are <code>"circle"</code>, <code>"square"</code>, <code>"triangle"</code> or
<code>"star"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_colour</code></td>
<td>
<p>optional character string for edge colour. Integers, named
colours or RGB values can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label_colour</code></td>
<td>
<p>optional character string for label colour. Integers,
named colours or RGB values can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>character string indicating how the adjacency matrix should be
interpreted. Possible values include <code>"undirected"</code> or
<code>"directed"</code> (see <code>graph_from_adjacency_matrix</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>indicating if entries of the adjacency matrix should define
edge width. If <code>weighted=FALSE</code>, an unweighted igraph object is
created, all edges have the same width. If <code>weighted=TRUE</code>, edge width
is defined by the corresponding value in the adjacency matrix. If
<code>weighted=NULL</code>, nodes are linked by as many edges as indicated in the
adjacency matrix (integer values are needed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>satellites</code></td>
<td>
<p>logical indicating if unconnected nodes (satellites) should
be included in the igraph object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All functionalities implemented in
<code>igraph</code> can be used on the output.
These include cosmetic changes for the visualisation, but also various
tools for network analysis (including topological properties and community
detection).
</p>
<p>The R package <code>visNetwork</code> offers
interactive network visualisation tools. An
<code>igraph</code> object can easily be converted
to a <code>visNetwork</code> object (see
example below).
</p>
<p>For Cytoscape users, the <code>RCy3</code> package can be used
to open the network in Cytoscape.
</p>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>See Also</h3>

<p><code>Adjacency</code>, <code>GraphicalModel</code>,
<a href="https://igraph.org/r/">igraph manual</a>,
<a href="http://datastorm-open.github.io/visNetwork/">visNetwork manual</a>,
<a href="https://cytoscape.org">Cytoscape</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## From adjacency matrix

# Un-weighted
adjacency &lt;- SimulateAdjacency(pk = 20, topology = "scale-free")
plot(Graph(adjacency))

# Weighted
adjacency &lt;- adjacency * runif(prod(dim(adjacency)))
adjacency &lt;- adjacency + t(adjacency)
plot(Graph(adjacency, weighted = TRUE))

# Node colours and shapes
plot(Graph(adjacency, weighted = TRUE, node_shape = "star", node_colour = "red"))


## From stability selection outputs

# Graphical model
set.seed(1)
simul &lt;- SimulateGraphical(pk = 20)
stab &lt;- GraphicalModel(xdata = simul$data)
plot(Graph(stab))

# Sparse PLS
if (requireNamespace("sgPLS", quietly = TRUE)) {
  set.seed(1)
  simul &lt;- SimulateRegression(n = 50, pk = c(5, 5, 5), family = "gaussian")
  x &lt;- simul$xdata
  y &lt;- simul$ydata
  stab &lt;- BiSelection(
    xdata = simul$xdata, ydata = simul$ydata,
    family = "gaussian", ncomp = 3,
    LambdaX = seq_len(ncol(x) - 1),
    implementation = SparsePLS
  )
  plot(Graph(stab))
}


## Tools from other packages

# Applying some igraph functionalities
adjacency &lt;- SimulateAdjacency(pk = 20, topology = "scale-free")
mygraph &lt;- Graph(adjacency)
igraph::degree(mygraph)
igraph::betweenness(mygraph)
igraph::shortest_paths(mygraph, from = 1, to = 2)
igraph::walktrap.community(mygraph)

# Interactive view using visNetwork
if (requireNamespace("visNetwork", quietly = TRUE)) {
  vgraph &lt;- mygraph
  igraph::V(vgraph)$shape &lt;- rep("dot", length(igraph::V(vgraph)))
  v &lt;- visNetwork::visIgraph(vgraph)
  mylayout &lt;- as.matrix(v$x$nodes[, c("x", "y")])
  mylayout[, 2] &lt;- -mylayout[, 2]
  plot(mygraph, layout = mylayout)
}

# Opening in Cytoscape using RCy3
if (requireNamespace("RCy3", quietly = TRUE)) {
  # Make sure that Cytoscape is open before running the following line
  # RCy3::createNetworkFromIgraph(mygraph)
}


</code></pre>


</div>