<div class="container">

<table style="width: 100%;"><tr>
<td>dltTestCalibration</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tests the accuracy of a stereo camera calibration</h2>

<h3>Description</h3>

<p>This function uses a set of grid points, ideally other than those used in stereo camera calibration, to test calibration accuracy. Results of both distance-based and position-based accuracy tests are returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dltTestCalibration(cal.coeff, coor.2d, nx, sq.size, 
                   reciprocal = TRUE, align.princomp = FALSE)

## S3 method for class 'dltTestCalibration'
summary(object, print.tab = '', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cal.coeff</code></td>
<td>
<p>a matrix of DLT calibration coefficients. The columns correspond to each camera view and the column order should match the camera view order in the fourth dimension of the <code>coor.2d</code> array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coor.2d</code></td>
<td>
<p>a four-dimensional array of grid points. The first two dimensions correspond to each matrix of grid points, the third corresponds to each grid position/orientation and the fourth corresponds to each camera view. These can be read in from file by <code>readCheckerboardsToArray</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points in <code>coor.2d</code> are listed first by row). The number of points along the second dimension is calculated based on the total number of points per view and orientation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sq.size</code></td>
<td>
<p>the size of the grid squares in real-world units (e.g. millimeters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reciprocal</code></td>
<td>
<p>a logical indicating whether epipolar distance should be calculated reciprocally and then averaged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>align.princomp</code></td>
<td>
<p>a logical indicating whether checkerboard corners should be aligned along principal coordinate axes prior to error testing (serves to describe error along axes that may be more physically meaningful than the initial, arbitrary coordinate system).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a list of class <code>"dltTestCalibration"</code> (the output of <code>dltTestCalibration()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Although the RMS errors reported by <code>dltCalibrateCameras</code> can be used to assess the accuracy of a stereo camera setup, these represent how well the DLT parameters fit the calibration point set and not the reconstruction accuracy per se. It has been argued that in order to obtain a true estimation of reconstruction accuracy, an independent assessment criterion is required (Challis &amp; Kerwin 1992). With the StereoMorph package, this is best accomplished by photographing a grid not used in the calibration and of a different square size (to test for proper scaling). These images are taken and the internal corners extracted just as in the calibration step (see <code>dltCalibrateCameras</code>), again ensuring that the test images fully sample the calibration volume and that the extracted point orders correspond between the two views. The input format of <code>coor.2d</code> to <code>dltTestCalibration()</code> is the same format as the <code>coor.2d</code> input to <code>dltCalibrateCameras</code>.
</p>
<p><code>dltTestCalibration()</code> measures the calibration accuracy using two approaches: a distance-based approach and a position-based approach. For the distance-based approach (e.g. Tashman &amp; Anderst 2003; Brainerd et al. 2010), random pairs of grid points are chosen (without resampling), reconstructed and the distance between the reconstructed points is compared with the actual distance. The deviations from the true distance (interpoint distance error or IPD error) for each pair of points are returned in the <code>ipd.error</code> vector. <code>dltTestCalibration()</code> also measures IPD error of only adjacent points, returned in the vector <code>adj.pair.ipd.error</code>. With a sufficient number of grid points, adjacent points are close enough that one can test how IPD error varies as a function of the distance from the approximate center of the calibrated volume (<code>adj.pair.centroid.dist</code>) or along a particular dimension (<code>adj.pair.mean.pos</code>).
</p>
<p>One challenge in interpreting the IPD error, however, is that each deviation represents error in the x, y and z position of two points. This makes it difficult to assess the accuracy of a particular point or along a particular dimension. Since we do not know the 3D coordinates of a test grid placed at an arbitrary orientation in the calibration volume, we must find the best fit 3D position in order to assess positional accuracy. For the position-based approach, <code>dltTestCalibration()</code> takes an ideal grid of the same square size and dimensions and optimally aligns it with the reconstructed test points using <code>findOptimalPointAlignment</code>. The reconstructed test points can then be compared with their corresponding reference points. These errors are returned in the matrix <code>aitr.error</code> (aligned ideal to reconstructed point position). This approach has the disadvantage that best fit alignment will tend to align the reference grid where the error is highest so as to minimize differences. This can decrease error where it is in actuality relatively high and vice versa.
</p>


<h3>Value</h3>

<p>a list of class <code>"dltTestCalibration"</code> with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>num.grids</code></td>
<td>
<p>the number of test calibration grids used in accuracy assessment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epipolar.error</code></td>
<td>
<p>the epipolar error (distance) for every test calibration point. This is the reciprocal epipolar distance if <code>reciprocal</code> is <code>TRUE</code>. See <code>dltEpipolarDistance</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epipolar.rmse</code></td>
<td>
<p>the root-mean-square error of <code>epipolar.error</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ipd.error</code></td>
<td>
<p>a vector of the deviations from the true distance between random pairs of points (without resampling).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pair.dist</code></td>
<td>
<p>a vector of the true distances between the random pairs of points in <code>ipd.error</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ipd.rmse</code></td>
<td>
<p>the root-mean-square error of <code>ipd.error</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.pair.ipd.error</code></td>
<td>
<p>a vector of the deviations from the true distance between random pairs of adjacent points (without resampling).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.pair.mean.pos</code></td>
<td>
<p>a three-column matrix of the mean position (midpoint) of the adjacent pairs of points in <code>adj.pair.ipd.error</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.pair.centroid.dist</code></td>
<td>
<p>a vector of the distances from each point in <code>adj.pair.mean.pos</code> to the centroid of all <code>adj.pair.mean.pos</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.error</code></td>
<td>
<p>a three-column matrix of the x, y and z position errors for the reconstructed test calibration points relative to optimally aligned ideal grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.dist.error</code></td>
<td>
<p>a vector of the distances between the reconstructed test calibration points and the optimally aligned ideal grid points. Note that ideally this distance should be zero so all values in this vector are positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.dist.rmse</code></td>
<td>
<p>the RMS error (or deviation) of <code>aitr.dist.error</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.rmse</code></td>
<td>
<p>a vector of the RMS error (or deviation) of <code>aitr.error</code> along each dimension. This is very similar to the standard deviation of <code>aitr.error</code> along each dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.pos</code></td>
<td>
<p>a three-column matrix of the ideal grid points after best fit alignment to the reconstructed grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aitr.centroid.dist</code></td>
<td>
<p>a vector of the distances between each AITR point and the centroid of all AITR points.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Challis, J.H. and Kerwin, D.G. (1992). Accuracy assessment and control point configuration when using the DLT for photogrammetry. <em>Journal of Biomechanics</em>, <b>25</b> (9), 1053–1058.
</p>
<p>Tashman, S. and Anderst, W. (2003). <em>In Vivo</em> Measurement of Dynamic Joint Motion Using High Speed Biplane Radiography and CT: Application to Canine ACL Deficiency. <em>Transactions of the ASME</em>, <b>125</b>, 238–245.
</p>
<p>Brainerd, E.L., Baier, D.B., Gatesy, S.M., Hedrick, T.L., Metzger, K.A., Gilbert, S.L and Crisco, J.J. (2010). X-ray reconstruction of moving morphology (XROMM): Precision, accuracy and applications in comparative biomechanics research. <em>Journal of Experimental Zoology</em>, <b>313A</b>, 262–279.
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code>dltCalibrateCameras</code>,
<code>dltCoefficients</code>,
<code>readCheckerboardsToArray</code>,
<code>dltEpipolarDistance</code>,
<code>findCheckerboardCorners</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## SET NUMBER OF INTERNAL ROWS AND COLUMNS
nx &lt;- 21
ny &lt;- 14

## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CHECKERBOARD CORNERS FROM TEST CALIBRATION IMAGE SET
file &lt;- matrix(c(paste0(fdir, "test_cal_a", 1:11, "_v1.txt"), 
  paste0(fdir, "test_cal_a", 1:11, "_v2.txt")), ncol=2)

## READ IN CHECKERBOARD CORNERS
coor.2d &lt;- readCheckerboardsToArray(file=file, nx=nx, ny=ny, col.reverse=FALSE)

## SET GRID SIZE OF TEST CHECKERBOARDS (IN MM)
sq.size &lt;- 4.2218

## LOAD CALIBRATION COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=paste0(fdir, "cal_coeffs.txt")))

## TEST CALIBRATION ACCURACY
## USE ONLY A SUBSET (FIVE) OF TEST CALIBRATION IMAGES
## IN THE TUTORIAL POINTS, UNITS NOT IN PIXELS ARE MILLIMETERS
dlt_test &lt;- dltTestCalibration(cal.coeff=cal.coeff, coor.2d=coor.2d[, , 1:5, ], nx=nx, 
  sq.size=sq.size)

## RUN TEST ON ALL TEST CALIBRATION IMAGES
## Not run: 
dlt_test &lt;- dltTestCalibration(cal.coeff=cal.coeff, coor.2d=coor.2d, nx=nx, 
  sq.size=sq.size)

## End(Not run)

## PRINT SUMMARY
summary(dlt_test)

## PLOT A HISTOGRAM OF THE INTERPOINT DISTANCE ERROR
hist(dlt_test$ipd.error)

## PLOT ADJACENT POINT DISTANCE ERROR AS A FUNCTION OF POSITION ALONG THE Y-AXIS
dev.new()
plot(dlt_test$adj.pair.ipd.error, abs(dlt_test$adj.pair.mean.pos[, 2, ]))

## PLOT POSITION-BASED ERROR AS A FUNCTION OF POSITION ALONG THE X-AXIS
dev.new()
plot(dlt_test$aitr.pos[, 1, ], abs(dlt_test$aitr.error[, 1, ]))
</code></pre>


</div>