<div class="container">

<table style="width: 100%;"><tr>
<td>sieve.sgd.preprocess</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Preprocess the original data for sieve-SGD estimation.</h2>

<h3>Description</h3>

<p>Preprocess the original data for sieve-SGD estimation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sieve.sgd.preprocess(
  X,
  s = c(2),
  r0 = c(2),
  J = c(1),
  type = c("cosine"),
  interaction_order = c(3),
  omega = c(0.51),
  norm_feature = TRUE,
  norm_para = NULL,
  lower_q = 0.005,
  upper_q = 0.995
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a data frame containing prediction features/ independent variables. The (i,j)-th element is the j-th dimension of the i-th sample's feature vector. 
So the number of rows equals to the sample size and the number of columns equals to the feature/covariate dimension. If the complete data set is large, this can be a representative subset of it (ideally have more than 1000 samples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>numerical array. Smoothness parameter, a smaller s corresponds to a more flexible model. Default is 2. The elements of this array should take values greater than 0.5. The larger s is, the smoother we are assuming the truth to be.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r0</code></td>
<td>
<p>numerical array. Initial learning rate/step size, don't set it too large. The step size at each iteration will be r0*(sample size)^(-1/(2s+1)), which is slowly decaying.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>numerical array. Initial number of basis functions, a larger J corresponds to a more flexible estimator The number of basis functions at each iteration will be J*(sample size)^(1/(2s+1)), which is slowly increasing. We recommend use J that is at least the dimension of predictor, i.e. the column number of the X matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a string. It specifies what kind of basis functions are used. The default is (aperiodic) cosine basis functions ('cosine'), which is enough for generic usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction_order</code></td>
<td>
<p>a number. It also controls the model complexity. 1 means fitting an additive model, 2 means fitting a model allows, 3 means interaction terms between 3 dimensions of the feature, etc. The default is 3. 
For large sample size, lower dimension problems, try a larger value (but need to be smaller than the dimension of original features); for smaller sample size and higher dimensional problems, try set it to a smaller value (1 or 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>the rate of dimension-reduction parameter. Default is 0.51, usually do not need to change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_feature</code></td>
<td>
<p>a logical variable. Default is TRUE. It means sieve_preprocess will rescale the each dimension of features to 0 and 1. Only set to FALSE when user already manually rescale them between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_para</code></td>
<td>
<p>a matrix. It specifies how the features are normalized. For training data, use the default value NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower_q</code></td>
<td>
<p>lower quantile used in normalization. Default is 0.01 (1% quantile).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_q</code></td>
<td>
<p>upper quantile used in normalization. Default is 0.99 (99% quantile).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the necessary information for next step model fitting. Typically, the list is used as the main input of sieve.sgd.solver.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s.size.sofar</code></td>
<td>
<p>a number. Number of samples has been processed so far.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a string. The type of basis funtion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyper.para.list</code></td>
<td>
<p>a list of hyperparameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.matrix</code></td>
<td>
<p>a matrix. Identifies the multivariate basis functions used in fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.row.prod</code></td>
<td>
<p>the index product for each basis function. It is used in calculating basis function - specific learning rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inf.list</code></td>
<td>
<p>a list storing the fitted results. It has a length of "number of unique combinations of the hyperparameters". The component of inf.list is itself a list, it has a hyper.para.index domain to specify its corresponding hyperparameters (need to be used together with hyper.para.list). Its rolling.cv domain is the progressive validation statistics for hyperparameter tuning; beta.f is the regression coefficients for the first length(beta.f) basis functions, the rest of the basis have 0 coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_para</code></td>
<td>
<p>a matrix. It records how each dimension of the feature/predictor is rescaled, which is useful when rescaling the testing sample's predictors.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">xdim &lt;- 1 #1 dimensional feature
#generate 1000 training samples
TrainData &lt;- GenSamples(s.size = 1000, xdim = xdim)
sieve.model &lt;- sieve.sgd.preprocess(X = TrainData[,2:(xdim+1)])
</code></pre>


</div>