<div class="container">

<table style="width: 100%;"><tr>
<td>combineSQM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine several SQM objects</h2>

<h3>Description</h3>

<p>Combine an arbitrary number of SQM objects into a single SQM object. The input objects must be subsets of the same original SQM object (i.e. from the same SqueezeMeta run). For combining results from different runs please check <code>combineSQMlite</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">combineSQM(
  ...,
  tax_source = "orfs",
  trusted_functions_only = FALSE,
  ignore_unclassified_functions = FALSE,
  rescale_tpm = TRUE,
  rescale_copy_number = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>an arbitrary number of SQM objects. Alternatively, a single list containing an arbitrary number of SQM objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tax_source</code></td>
<td>
<p>character. Features used for calculating aggregated abundances at the different taxonomic ranks. Either <code>"orfs"</code> or <code>"contigs"</code> (default <code>"orfs"</code>). If the objects being combined contain a subset of taxa or bins, this parameter can be set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trusted_functions_only</code></td>
<td>
<p>logical. If <code>TRUE</code>, only highly trusted functional annotations (best hit + best average) will be considered when generating aggregated function tables. If <code>FALSE</code>, best hit annotations will be used (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unclassified_functions</code></td>
<td>
<p>logical. If <code>FALSE</code>, ORFs with no functional classification will be aggregated together into an "Unclassified" category. If <code>TRUE</code>, they will be ignored (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_tpm</code></td>
<td>
<p>logical. If <code>TRUE</code>, TPMs for KEGGs, COGs, and PFAMs will be recalculated (so that the TPMs in the subset actually add up to 1 million). Otherwise, per-function TPMs will be calculated by aggregating the TPMs of the ORFs annotated with that function, and will thus keep the scaling present in the parent object (default <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_copy_number</code></td>
<td>
<p>logical. If <code>TRUE</code>, copy numbers with be recalculated using the RecA/RadA coverages in the subset. Otherwise, RecA/RadA coverages will be taken from the parent object with the highest RecA/RadA coverages. By default it is set to <code>TRUE</code>, which means that the returned copy numbers will represent the average copy number per function <em>in the genomes of the selected bins or contigs</em>. If any SQM objects that are being combined contain a functional subset rather than a contig/bins subset, this parameter should be set to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A SQM object
</p>


<h3>See Also</h3>

<p><code>subsetFun</code>, <code>subsetTax</code>, <code>combineSQMlite</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Hadza)
# Select Carbohydrate metabolism ORFs in Bacteroidetes,
#  and Amino acid metabolism ORFs in Proteobacteria
bact = subsetTax(Hadza, "phylum", "Bacteroidetes")
bact.carb = subsetFun(bact, "Carbohydrate metabolism")
proteo = subsetTax(Hadza, "phylum", "Proteobacteria")
proteo.amins = subsetFun(proteo, "Amino acid metabolism")
bact.carb_proteo.amins = combineSQM(bact.carb, proteo.amins, rescale_copy_number=FALSE)
</code></pre>


</div>