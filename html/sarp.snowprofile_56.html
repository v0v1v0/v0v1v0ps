<div class="container">

<table style="width: 100%;"><tr>
<td>snowprofileLayers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor for a snowprofileLayers object</h2>

<h3>Description</h3>

<p>Helper function to conveniently create a snowprofileLayers object, i.e. data.frame with mandatory column fields height (or depth) that provides vertical position of layers.
Layers need to be ordered in a sequential manner, and the routine will rearrange the layers so that the last row of the resulting dataframe corresponds to the snow surface.
If the vertical location of the layers is given by depth, make sure to provide <code>hs</code> if it's known. Otherwise, provide the field <code>maxObservedDepth</code> or layer thicknesses.
Providing only depth will issue a warning and set the corresponding lowest layer thickness to NA.
The resulting dataframe will contain all three fields <code>height</code>, <code>depth</code>, and <code>thickness</code>, which will be auto-filled if not provided (see format_snowprofileLayers).
If the columns that describe layer properties are not of equal
lengths, their values will be recycled (default data.frame mechanism). Instead of individual layer characteristics, a data.frame can be provided, which will be converted into a snowprofileLayers class.
The constructor asserts correctness of the layers object by a call to validate_snowprofileLayers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">snowprofileLayers(
  height = as.double(NA),
  temperature = as.double(NA),
  density = as.double(NA),
  lwc = as.double(NA),
  gsize = as.double(NA),
  gsize_max = as.double(NA),
  gsize_avg = as.double(NA),
  gtype = as.factor(NA),
  gtype_sec = as.factor(NA),
  hardness = as.double(NA),
  ddate = as.POSIXct(NA),
  bdate = as.POSIXct(NA),
  datetag = as.Date(NA),
  ssi = as.double(NA),
  sphericity = as.double(NA),
  v_strain_rate = as.double(NA),
  crit_cut_length = as.double(NA),
  tsa = as.double(NA),
  tsa_interface = as.double(NA),
  rta = as.double(NA),
  rta_interface = as.double(NA),
  layerOfInterest = as.logical(NA),
  comment = as.character(NA),
  ...,
  hs = as.double(NA),
  maxObservedDepth = as.double(NA),
  layerFrame = NA,
  validate = TRUE,
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>height vector (cm) referring to the top layer interface. Instead of <code>height</code>, <code>depth</code> can also be given and should be accompanied by
an array specifying the <code>thickness</code> of the layers, or alternatively, the total snow depth <code>hs</code> and/or the maximum observed depth <code>maxObservedDepth</code>
should be provided. Note, that also the <code>depth</code> refers to the top layer interface. <strong>See examples!</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temperature</code></td>
<td>
<p>snow temperature (deg C)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>layer density (kg/m3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwc</code></td>
<td>
<p>liquid water content (%)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gsize</code></td>
<td>
<p>grain size (mm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gsize_max</code></td>
<td>
<p>maximum grain size (mm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gsize_avg</code></td>
<td>
<p>average grain size (mm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gtype</code></td>
<td>
<p>grain type (character or factor)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gtype_sec</code></td>
<td>
<p>secondary grain type (character or factor)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hardness</code></td>
<td>
<p>numeric hand hardness (use char2numHHI to convert from character hardness)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ddate</code></td>
<td>
<p>deposition date of layer (POSIXct format). WARNING: if you provide character format, the time zone of your computer system will be assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bdate</code></td>
<td>
<p>burial date of layer (POSIXct format). WARNING: if you provide character format, the time zone of your computer system will be assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datetag</code></td>
<td>
<p>of layer (i.e., usually corresponds to <code>ddate</code> for 'MFcr', and to <code>bdate</code> for all other grain types.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssi</code></td>
<td>
<p>snow stability index (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sphericity</code></td>
<td>
<p>between 0 and 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v_strain_rate</code></td>
<td>
<p>viscous deformation rate (s^-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit_cut_length</code></td>
<td>
<p>critical crack length (m)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsa</code></td>
<td>
<p>threshold sum approach for structural instability (also called lemons); valid for the layer, i.e., the weakest interface adjacent to the layer. see computeTSA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tsa_interface</code></td>
<td>
<p>same as tsa, but valid for top interface of corresponding layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rta</code></td>
<td>
<p>relative threshold sum approach (following Monti et al 2013, ISSW paper); valid for the layer, i.e., the weakest interface adjacent to the layer. see computeRTA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rta_interface</code></td>
<td>
<p>same as rta, but valid for top interface of corresponding layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layerOfInterest</code></td>
<td>
<p>a boolean column to label specific layers of interest, e.g. weak layers. see labelPWL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comment</code></td>
<td>
<p>character string</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>columns to include in the layers object. Note, that they need to correspond to the according height/depth array.
e.g. hardness (can use character hardness or numeric hardness via char2numHHI), ddate (class POSIX), bdate (class Date) gtype (character or factor), density, temperature, gsize, lwc, gsize_max, gtype_sec, ssi, depth, thickness</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>total snow height (cm), if not deductible from <code>height</code> vector. Particularly important when only a depth grid is provided!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxObservedDepth</code></td>
<td>
<p>the observed depth of the profile from the snow surface downwards. Will only be used, if
no <code>height</code>, <code>thickness</code>, or <code>hs</code> is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layerFrame</code></td>
<td>
<p>a data.frame that's converted to a snowprofileLayers class if no other layer characteristics are provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate</code></td>
<td>
<p>Validate <code>obj</code> with validate_snowprofileLayers?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropNAs</code></td>
<td>
<p>Do you want to drop all columns consisting of NAs only?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>snowprofileLayers object as data.frame with strings as factors
</p>


<h3>Author(s)</h3>

<p>shorton, fherla
</p>


<h3>See Also</h3>

<p>snowprofile
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Empty layers object:
snowprofileLayers()


## simple layers example that recycles the hardness 1F+: with warning issued!
## Try what happens if you provide ddate as character array without a timezone.
snowprofileLayers(height = c(10, 25, 50),
                  hardness = char2numHHI('1F+'),
                  gtype = c('FC', NA, 'PP'),
                  ddate = as.POSIXct(c(NA, NA, "2020-02-15 10:45:00"),
                                     tz = "Etc/GMT+7"))

## create snowprofileLayers object from data.frame
## and feed it into a snowprofile object:
df &lt;- data.frame(height = c(10, 25, 50),
                  hardness = c(2, 3, 1),
                  gtype = c('FC', NA, 'PP'),
                  stringsAsFactors = TRUE)

spL &lt;- snowprofileLayers(layerFrame = df)
(sp &lt;- snowprofile(layers = spL))


##### Create top-down recorded snowprofileLayers ####
## check out how the fields 'hs' and 'maxObservedDepth' are auto-filled in the
## resulting snowprofile object!
## 1.) Specify depth and hs:
## In that case the routine will assume that the deepest layer extends down to the ground
(sp1 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                                               hardness = c(2, 3, 1),
                                               gtype = c('FC', NA, 'PP'),
                                               hs = 50)))
## note that sp and sp1 are the same profiles:
all(sapply(names(sp$layers), function(cols) {sp$layers[cols] == sp1$layers[cols]}), na.rm = TRUE)

## 2.) Specify depth, hs and thickness or maxObservedDepth:
## This will include a basal layer of NAs to fill the unobserved space down to the ground.
(sp2 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                                               hardness = c(2, 3, 1),
                                               gtype = c('FC', NA, 'PP'),
                                               hs = 70,
                                               maxObservedDepth = 50)))

## 3.) Specify depth and maxObservedDepth:
## This will include a basal layer of NAs which is 1 cm thick to flag the unknown basal layers.
(sp3 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'),
                         gsize = c(2, NA, NA),
                         maxObservedDepth = 50)))

## 4.) Specify depth and thickness:
## This is equivalent to the example spL3 above!
## This will include a basal layer of NAs which is 1 cm thick to flag the unknown basal layers.
(sp4 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         thickness = c(10, 15, 25),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'))))

## 5.) Specify only depth: issues warning!
(sp5 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'))))

## plot all 5 top.down-recorded profiles:
set &lt;- snowprofileSet(list(sp1, sp2, sp3, sp4, sp5))
plot(set, SortMethod = "unsorted", xticklabels = "originalIndices",
     hardnessResidual = 0.1, hardnessScale = 1.5, TopDown = TRUE,
     main = "TopDown Plot")

plot(set, SortMethod = "unsorted", xticklabels = "originalIndices",
     hardnessResidual = 0.1, hardnessScale = 1.5, TopDown = FALSE,
     main = "BottomUp Plot")

</code></pre>


</div>