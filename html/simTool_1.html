<div class="container">

<table style="width: 100%;"><tr>
<td>eval_tibbles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Workhorse for simulation studies</h2>

<h3>Description</h3>

<p>Generates data according to all provided
constellations in <code>data_tibble</code> and applies
all provided constellations in <code>proc_tibble</code>
to them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval_tibbles(
  data_grid,
  proc_grid = expand_tibble(proc = "length"),
  replications = 1,
  discard_generated_data = FALSE,
  post_analyze = identity,
  summary_fun = NULL,
  group_for_summary = NULL,
  ncpus = 1L,
  cluster = NULL,
  cluster_seed = rep(12345, 6),
  cluster_libraries = NULL,
  cluster_global_objects = NULL,
  envir = globalenv(),
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data_grid</code></td>
<td>
<p>a <code>data.frame</code> or <code>tibble</code> where the first column
is a character vector with function names. The other
columns contain parameters for the functions specified
in the first column. Parameters with NA are ignored. If a column with name
<code>.truth</code> exist, then the corresponding entry is passed to functions
generated from
<code>proc_grid</code> and the function specified in <code>post_analyze</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proc_grid</code></td>
<td>
<p>similar as <code>data_grid</code> the first
column must contain function names. The other columns
contain parameters for the functions specified in the
first column. The data generated according to
<code>data_grid</code> will always be passed to the first
unspecified argument of the functions specified in the first
column of <code>proc_grid</code>. If a function specified in
<code>proc_grid</code> has an argument <code>.truth</code>, then the corresponding
entry in the
<code>.truth</code> column from <code>data_grid</code> is passed to the
<code>.truth</code> parameter or if no column <code>.truth</code> exist in
<code>data_grid</code>, then all parameters used
for the data generation are passed to the <code>.truth</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replications</code></td>
<td>
<p>number of replications for the simulation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discard_generated_data</code></td>
<td>
<p>if <code>TRUE</code> the generated
data is deleted after all function constellations in
<code>proc_grid</code> have been applied. Otherwise, ALL
generated data sets will be part of the returned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post_analyze</code></td>
<td>
<p>this is a convenience function, that is applied
directly after the data analyzing function. If this function has an
argument <code>.truth</code>, then the corresponding entry in the
<code>.truth</code> column from <code>data_grid</code> is passed to the <code>.truth</code>
parameter or if no column <code>.truth</code> exist in <code>data_grid</code>,
then all parameters used for the data generation are passed to the
<code>.truth</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary_fun</code></td>
<td>
<p>named list of univariate function to summarize the
results (numeric or logical) over the replications, e.g.
list(mean = mean, sd = sd).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_for_summary</code></td>
<td>
<p>if the result returned by the data analyzing
function  or <code>post_analyze</code>
is a <code>data.frame</code> with more than one row, one usually is interested
in summarizing the results while grouping for some variables. This group
variables can be passed as a character vector into <code>group_for_summary</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>a cluster of <code>ncpus</code> workers (R-processes)
is created on the local machine to conduct the
simulation. If <code>ncpus</code>
equals one no cluster is created and the simulation
is conducted by the current R-process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>a cluster generated by the <code>parallel</code>
package that will be used to conduct the simulation.
If <code>cluster</code> is specified, then <code>ncpus</code> will
be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_seed</code></td>
<td>
<p>if the simulation is done in parallel
manner, then the combined multiple-recursive generator from L'Ecuyer (1999)
is used to generate random numbers. Thus <code>cluster_seed</code> must be a
(signed) integer vector of length 6.
The 6 elements of the seed are internally regarded as
32-bit unsigned integers. Neither the first three nor the last three
should be all zero, and they are limited to less than 4294967087 and
4294944443 respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_libraries</code></td>
<td>
<p>a character vector specifying
the packages that should be loaded by the workers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_global_objects</code></td>
<td>
<p>a character vector specifying
the names of R objects in the global environment that should
be exported to the global environment of every worker.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>must be provided if the functions specified
in <code>data_grid</code> or <code>proc_grid</code> are not part
of the global environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>usually the result column is nested, by default it is
tried to unnest it.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The returned object list of the class
<code>eval_tibbles</code>, where the element <code>simulations</code> contain
the results of the simulation.
</p>


<h3>Note</h3>

<p>If <code>cluster</code> is provided by the user the
function <code>eval_tibbles</code> will NOT stop the cluster.
This has to be done by the user. Conducting parallel
simulations by specifying <code>ncpus</code> will internally
create a cluster and stop it after the simulation
is done.
</p>


<h3>Author(s)</h3>

<p>Marsel Scheer
</p>


<h3>Examples</h3>

<pre><code class="language-R">rng &lt;- function(data, ...) {
  ret &lt;- range(data)
  names(ret) &lt;- c("min", "max")
  ret
}

### The following line is only necessary
### if the examples are not executed in the global
### environment, which for instance is the case when
### the oneline-documentation
### http://marselscheer.github.io/simTool/reference/eval_tibbles.html
### is build. In such case eval_tibble() would search the
### above defined function rng() in the global environment where
### it does not exist!
eval_tibbles &lt;- purrr::partial(eval_tibbles, envir = environment())

dg &lt;- expand_tibble(fun = "rnorm", n = c(5L, 10L))
pg &lt;- expand_tibble(proc = c("rng", "median", "length"))

eval_tibbles(dg, pg, rep = 2, simplify = FALSE)
eval_tibbles(dg, pg, rep = 2)
eval_tibbles(dg, pg,
  rep = 2,
  post_analyze = purrr::compose(as.data.frame, t)
)
eval_tibbles(dg, pg, rep = 2, summary_fun = list(mean = mean, sd = sd))

regData &lt;- function(n, SD) {
  data.frame(
    x = seq(0, 1, length = n),
    y = rnorm(n, sd = SD)
  )
}

eg &lt;- eval_tibbles(
  expand_tibble(fun = "regData", n = 5L, SD = 1:2),
  expand_tibble(proc = "lm", formula = c("y~x", "y~I(x^2)")),
  replications = 3
)
eg

presever_rownames &lt;- function(mat) {
  rn &lt;- rownames(mat)
  ret &lt;- tibble::as_tibble(mat)
  ret$term &lt;- rn
  ret
}

eg &lt;- eval_tibbles(
  expand_tibble(fun = "regData", n = 5L, SD = 1:2),
  expand_tibble(proc = "lm", formula = c("y~x", "y~I(x^2)")),
  post_analyze = purrr::compose(presever_rownames, coef, summary),
  # post_analyze = broom::tidy, # is a nice out of the box alternative
  summary_fun = list(mean = mean, sd = sd),
  group_for_summary = "term",
  replications = 3
)
eg$simulation

dg &lt;- expand_tibble(fun = "rexp", rate = c(10, 100), n = c(50L, 100L))
pg &lt;- expand_tibble(proc = c("t.test"), conf.level = c(0.8, 0.9, 0.95))
et &lt;- eval_tibbles(dg, pg,
  ncpus = 1,
  replications = 10^1,
  post_analyze = function(ttest, .truth) {
    mu &lt;- 1 / .truth$rate
    ttest$conf.int[1] &lt;= mu &amp;&amp; mu &lt;= ttest$conf.int[2]
  },
  summary_fun = list(mean = mean, sd = sd)
)
et

dg &lt;- dplyr::bind_rows(
  expand_tibble(fun = "rexp", rate = 10, .truth = 1 / 10, n = c(50L, 100L)),
  expand_tibble(fun = "rnorm", .truth = 0, n = c(50L, 100L))
)
pg &lt;- expand_tibble(proc = c("t.test"), conf.level = c(0.8, 0.9, 0.95))
et &lt;- eval_tibbles(dg, pg,
  ncpus = 1,
  replications = 10^1,
  post_analyze = function(ttest, .truth) {
    ttest$conf.int[1] &lt;= .truth &amp;&amp; .truth &lt;= ttest$conf.int[2]
  },
  summary_fun = list(mean = mean, sd = sd)
)
et
### need to remove the locally adapted eval_tibbles()
### otherwise executing the examples would mask
### eval_tibbles from simTool-namespace.
rm(eval_tibbles)
</code></pre>


</div>