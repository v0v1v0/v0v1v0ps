<div class="container">

<table style="width: 100%;"><tr>
<td>dppm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Determinantal Point Process Model</h2>

<h3>Description</h3>

<p>Fit a determinantal point process model to a point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  dppm(formula, family, data=NULL,
       ...,
       startpar = NULL,
       method = c("mincon", "clik2", "palm", "adapcl"),
       weightfun = NULL,
       control =  list(),
       algorithm,
       statistic = "K",
       statargs = list(),
       rmax = NULL,
       epsilon = 0.01,
       covfunargs = NULL,
       use.gam = FALSE,
       nd = NULL, eps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A <code>formula</code> in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language
specifying the data (on the left side) and the
form of the model to be fitted (on the right side).
For a stationary model it suffices to provide a point pattern
without a formula. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>Information specifying the family of point processes
to be used in the model.
Typically one of the family functions
<code>dppGauss</code>, <code>dppMatern</code>,
<code>dppCauchy</code>, <code>dppBessel</code>
or <code>dppPowerExp</code>.
Alternatively a character string giving the name
of a family function, or the result of calling one of the
family functions. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>The values of spatial covariates (other than the Cartesian
coordinates) required by the model.
A named list of pixel images, functions, windows,
tessellations or numeric constants.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startpar</code></td>
<td>

<p>Named vector of starting parameter values for the optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The fitting method. Either
<code>"mincon"</code> for minimum contrast,
<code>"clik2"</code> for second order composite likelihood,
<code>"adapcl"</code> for adaptive second order composite likelihood,
or <code>"palm"</code> for Palm likelihood.
Partially matched.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun</code></td>
<td>

<p>Optional weighting function <code class="reqn">w</code>
in the composite likelihoods or Palm likelihood.
A <code>function</code> in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language.
See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>List of control parameters passed to the optimization function
<code>optim</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>

<p>Character string determining the mathematical algorithm
to be used to solve the fitting problem.
If <code>method="mincon", "clik2"</code> or <code>"palm"</code> this argument
is passed to the generic optimization function
<code>optim</code> (renamed as the argument <code>method</code>)
with default <code>"Nelder-Mead"</code>.
If <code>method="adapcl"</code>) the argument is passed to the
equation solver <code>nleqslv</code>,
with default <code>"Bryden"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>

<p>Name of the summary statistic to be used
for minimum contrast estimation: either <code>"K"</code> or <code>"pcf"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statargs</code></td>
<td>

<p>Optional list of arguments to be used when calculating
the <code>statistic</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmax</code></td>
<td>

<p>Maximum value of interpoint distance
to use in the composite likelihood.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>Tuning parameter for the adaptive composite likelihood.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covfunargs,use.gam,nd,eps</code></td>
<td>

<p>Arguments passed to <code>ppm</code> when fitting the intensity.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function fits a determinantal point process model to a
point pattern dataset as described in Lavancier et al. (2015).
</p>
<p>The model to be fitted is specified by the arguments
<code>formula</code> and <code>family</code>.
</p>
<p>The argument <code>formula</code> should normally be a <code>formula</code> in the
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language. The left hand side of the formula
specifies the point pattern dataset to which the model should be fitted.
This should be a single argument which may be a point pattern
(object of class <code>"ppp"</code>) or a quadrature scheme
(object of class <code>"quad"</code>). The right hand side of the formula is called
the <code>trend</code> and specifies the form of the
<em>logarithm of the intensity</em> of the process.
Alternatively the argument <code>formula</code> may be a point pattern or quadrature
scheme, and the trend formula is taken to be <code>~1</code>.
</p>
<p>The argument <code>family</code> specifies the family of point processes
to be used in the model.
It is typically one of the family functions
<code>dppGauss</code>, <code>dppMatern</code>,
<code>dppCauchy</code>, <code>dppBessel</code>
or <code>dppPowerExp</code>. 
Alternatively it may be a character string giving the name
of a family function, or the result of calling one of the
family functions. A family function belongs to class
<code>"detpointprocfamilyfun"</code>. The result of calling a family
function is a point process family, which belongs to class
<code>"detpointprocfamily"</code>.   
</p>
<p>The algorithm first estimates the intensity function
of the point process using <code>ppm</code>.
If the trend formula is <code>~1</code>
(the default if a point pattern or quadrature
scheme is given rather than a <code>"formula"</code>)
then the model is <em>homogeneous</em>. The algorithm begins by
estimating the intensity as the number of points divided by
the area of the window.
Otherwise, the model is <em>inhomogeneous</em>.
The algorithm begins by fitting a Poisson process with log intensity
of the form specified by the formula <code>trend</code>.
(See <code>ppm</code> for further explanation).
</p>
<p>The interaction parameters of the model are then fitted
either by minimum contrast estimation,
or by a composite likelihood method (maximum
composite likelihood, maximum Palm likelihood, or by solving the adaptive 
composite likelihood estimating equation).
</p>

<dl>
<dt>Minimum contrast:</dt>
<dd>
<p>If <code>method = "mincon"</code> (the default) interaction parameters of
the model will be fitted
by minimum contrast estimation, that is, by matching the theoretical
<code class="reqn">K</code>-function of the model to the empirical <code class="reqn">K</code>-function
of the data, as explained in <code>mincontrast</code>.
</p>
<p>For a homogeneous model (<code> trend = ~1 </code>)
the empirical <code class="reqn">K</code>-function of the data is computed
using <code>Kest</code>,
and the interaction parameters of the model are estimated by
the method of minimum contrast.
</p>
<p>For an inhomogeneous model,
the inhomogeneous <code class="reqn">K</code> function is estimated
by <code>Kinhom</code> using the fitted intensity.
Then the interaction parameters of the model
are estimated by the method of minimum contrast using the
inhomogeneous <code class="reqn">K</code> function. This two-step estimation
procedure is heavily inspired by Waagepetersen (2007).
</p>
<p>If <code>statistic="pcf"</code> then instead of using the
<code class="reqn">K</code>-function, the algorithm will use
the pair correlation function <code>pcf</code> for homogeneous
models and the inhomogeneous pair correlation function
<code>pcfinhom</code> for inhomogeneous models.
In this case, the smoothing parameters of the pair correlation
can be controlled using the argument <code>statargs</code>,
as shown in the Examples.
</p>
<p>Additional arguments <code>...</code> will be passed to
<code>clusterfit</code> to control the minimum contrast fitting
algorithm.
</p>
</dd>
<dt>Composite likelihood:</dt>
<dd>
<p>If <code>method = "clik2"</code> the interaction parameters of the
model will be fitted by maximising the second-order composite likelihood
(Guan, 2006). The log composite likelihood is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(d_{ij}) \log\rho(d_{ij}; \theta)
	- \left( \sum_{i,j} w(d_{ij}) \right)
	\log \int_D \int_D w(\|u-v\|) \rho(\|u-v\|; \theta)\, du\, dv
      </code>
</p>

<p>where the sums are taken over all pairs of data points
<code class="reqn">x_i, x_j</code> separated by a distance
<code class="reqn">d_{ij} = \| x_i - x_j\|</code>
less than <code>rmax</code>,
and the double integral is taken over all pairs of locations
<code class="reqn">u,v</code> in the spatial window of the data.
Here <code class="reqn">\rho(d;\theta)</code> is the
pair correlation function of the model with
interaction parameters <code class="reqn">\theta</code>.
</p>
<p>The function <code class="reqn">w</code> in the composite likelihood
is a weighting function and may be chosen arbitrarily.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
a threshold weight function,
<code class="reqn">w(d) = 1(d \le R)</code>, where <code class="reqn">R</code> is <code>rmax/2</code>.
</p>
</dd>
<dt>Palm likelihood:</dt>
<dd>
<p>If <code>method = "palm"</code> the interaction parameters of the
model will be fitted by maximising the Palm loglikelihood
(Tanaka et al, 2008)
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(x_i, x_j) \log \lambda_P(x_j \mid x_i; \theta)
	- \int_D w(x_i, u) \lambda_P(u \mid x_i; \theta) {\rm d} u
      </code>
</p>

<p>with the same notation as above. Here
<code class="reqn">\lambda_P(u|v;\theta</code> is the Palm intensity of
the model at location <code class="reqn">u</code> given there is a point at <code class="reqn">v</code>.
</p>
</dd>
<dt>Adaptive Composite likelihood:</dt>
<dd>
<p>If <code>method = "cladap"</code> the clustering parameters of the
model will be fitted by solving the adaptive second order 
composite likelihood estimating equation (Lavancier et al, 2021).
The estimating function is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{u, v} w(\epsilon \frac{|g(0; \theta) - 1|}{g(\|u-v\|; \theta)-1}) 
	\frac{\nabla_\theta g(\|u-v\|;\theta)}{g(\|u-v\|;\theta)} - 
	\int_D \int_D w(\epsilon \frac{M(u,v; \theta)} \nabla_\theta g(\|u-v\|; \theta) 
	\rho(u) \rho(v)\, du\, dv
      </code>
</p>

<p>where the sum is taken over all distinct pairs of points.
Here <code class="reqn">g(d;\theta)</code> is the
pair correlation function  with
parameters <code class="reqn">\theta</code>.
The partial derivative with respect to <code class="reqn">\theta</code> 
is <code class="reqn">g'(d; \theta)</code>, and <code class="reqn">\rho(u)</code> denotes
the fitted intensity function of the model.
</p>
<p>The tuning parameter <code class="reqn">\epsilon</code> is 
independent of the data. It can be specified by the
argument <code>epsilon</code> and has default value <code class="reqn">0.01</code>.
</p>
<p>The function <code class="reqn">w</code> in the estimating function
is a weighting function of bounded support <code class="reqn">[-1,1]</code>.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
<code class="reqn">
	w(d) = 1(\|d\| \le 1) \exp(1/(r^2-1))</code>.
The estimating equation is solved using the
nonlinear equation solver <code>nleqslv</code>
from the package <span class="pkg">nleqslv</span>. The package <span class="pkg">nleqslv</span>
must be installed in order to use this option.
</p>
</dd>
</dl>
<p>It is also possible to fix any parameters desired before the
optimisation by specifying them as <code>name=value</code>
in the call to the family function. See Examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"dppm"</code> representing the fitted model.
There are methods for printing, plotting, predicting and simulating
objects of this class.
</p>


<h3>Optimization algorithm</h3>

<p>The following details allow greater control over the fitting
procedure.
</p>
<p>For the first three fitting methods
(<code>method="mincon", "clik2"</code> and <code>"palm"</code>), 
the optimisation is performed by the generic
optimisation algorithm <code>optim</code>.
The behaviour of this algorithm can be modified using the
arguments <code>control</code> and <code>algorithm</code>.
Useful control arguments include
<code>trace</code>, <code>maxit</code> and <code>abstol</code>
(documented in the help for <code>optim</code>).
</p>
<p>For <code>method="adapcl"</code>, the estimating equation is solved
using the nonlinear equation solver <code>nleqslv</code>
from the package <span class="pkg">nleqslv</span>. 
Arguments available for controlling the solver are
documented in the help for   
<code>nleqslv</code>; they include <code>control</code>, 
<code>globStrat</code>, <code>startparm</code> for the initial estimates and 
<code>algorithm</code> for the method. 
The package <span class="pkg">nleqslv</span> must be installed in order to use this option.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
Adaptive composite likelihood method contributed by Chiara Fend
and modified by Adrian Baddeley.
</p>


<h3>References</h3>

<p>Guan, Y. (2006)
A composite likelihood approach in fitting spatial point process
models.
<em>Journal of the American Statistical Association</em>
<b>101</b>, 1502–1512.
</p>
<p>Lavancier, F., Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853–977.
</p>
<p>Lavancier, F., Poinas, A., and Waagepetersen, R. (2021)
Adaptive estimating function inference for nonstationary
determinantal point processes.
<em>Scandinavian Journal of Statistics</em>, <b>48</b> (1), 87–107.
</p>
<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for
Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43–57.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252–258.
</p>


<h3>See Also</h3>

<p>methods for <code>dppm</code> objects:
<code>plot.dppm</code>,
<code>fitted.dppm</code>,
<code>predict.dppm</code>,
<code>simulate.dppm</code>,
<code>methods.dppm</code>,
<code>as.ppm.dppm</code>,
<code>Kmodel.dppm</code>,
<code>pcfmodel.dppm</code>.
</p>
<p>Minimum contrast fitting algorithm:
higher level interface <code>clusterfit</code>;
low-level algorithm <code>mincontrast</code>.
</p>
<p>Deterimantal point process models:
<code>dppGauss</code>,
<code>dppMatern</code>,
<code>dppCauchy</code>,
<code>dppBessel</code>,
<code>dppPowerExp</code>,
</p>
<p>Summary statistics:
<code>Kest</code>,
<code>Kinhom</code>,
<code>pcf</code>,
<code>pcfinhom</code>.
</p>
<p>See also <code>ppm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  jpines &lt;- residualspaper$Fig1
  

  dppm(jpines ~ 1, dppGauss)

  dppm(jpines ~ 1, dppGauss, method="c")
  dppm(jpines ~ 1, dppGauss, method="p")
  dppm(jpines ~ 1, dppGauss, method="a")

  if(interactive()) {
     # Fixing the intensity at lambda=2 rather than the Poisson MLE 2.04:
     dppm(jpines ~ 1, dppGauss(lambda=2))

     # The following is quite slow (using K-function)
     dppm(jpines ~ x, dppMatern)
  }

   # much faster using pair correlation function
  dppm(jpines ~ x, dppMatern, statistic="pcf", statargs=list(stoyan=0.2))

  # Fixing the Matern shape parameter at nu=2 rather than estimating it:
  dppm(jpines ~ x, dppMatern(nu=2))
</code></pre>


</div>