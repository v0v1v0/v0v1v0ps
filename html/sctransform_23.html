<div class="container">

<table style="width: 100%;"><tr>
<td>vst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variance stabilizing transformation for UMI count data</h2>

<h3>Description</h3>

<p>Apply variance stabilizing transformation to UMI count data using a regularized Negative Binomial regression model.
This will remove unwanted effects from UMI data and return Pearson residuals.
Uses future_lapply; you can set the number of cores it will use to n with plan(strategy = "multicore", workers = n).
If n_genes is set, only a (somewhat-random) subset of genes is used for estimating the
initial model parameters. For details see doi: <a href="https://doi.org/10.1186/s13059-019-1874-1">10.1186/s13059-019-1874-1</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vst(
  umi,
  cell_attr = NULL,
  latent_var = c("log_umi"),
  batch_var = NULL,
  latent_var_nonreg = NULL,
  n_genes = 2000,
  n_cells = NULL,
  method = "poisson",
  do_regularize = TRUE,
  theta_regularization = "od_factor",
  res_clip_range = c(-sqrt(ncol(umi)), sqrt(ncol(umi))),
  bin_size = 500,
  min_cells = 5,
  residual_type = "pearson",
  return_cell_attr = FALSE,
  return_gene_attr = TRUE,
  return_corrected_umi = FALSE,
  min_variance = -Inf,
  bw_adjust = 3,
  gmean_eps = 1,
  theta_estimation_fun = "theta.ml",
  theta_given = NULL,
  exclude_poisson = FALSE,
  use_geometric_mean = TRUE,
  use_geometric_mean_offset = FALSE,
  fix_intercept = FALSE,
  fix_slope = FALSE,
  scale_factor = NA,
  vst.flavor = NULL,
  verbosity = 2,
  verbose = NULL,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>umi</code></td>
<td>
<p>A matrix of UMI counts with genes as rows and cells as columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_attr</code></td>
<td>
<p>A data frame containing the dependent variables; if omitted a data frame with umi and gene will be generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latent_var</code></td>
<td>
<p>The independent variables to regress out as a character vector; must match column names in cell_attr; default is c("log_umi")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_var</code></td>
<td>
<p>The dependent variables indicating which batch a cell belongs to; no batch interaction terms used if omiited</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latent_var_nonreg</code></td>
<td>
<p>The non-regularized dependent variables to regress out as a character vector; must match column names in cell_attr; default is NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_genes</code></td>
<td>
<p>Number of genes to use when estimating parameters (default uses 2000 genes, set to NULL to use all genes)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cells</code></td>
<td>
<p>Number of cells to use when estimating parameters (default uses all cells)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method to use for initial parameter estimation; one of 'poisson', 'qpoisson', 'nb_fast', 'nb', 'nb_theta_given', 'glmGamPoi', 'offset', 'offset_shared_theta_estimate', 'glmGamPoi_offset'; default is 'poisson'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_regularize</code></td>
<td>
<p>Boolean that, if set to FALSE, will bypass parameter regularization and use all genes in first step (ignoring n_genes); default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_regularization</code></td>
<td>
<p>Method to use to regularize theta; use 'log_theta' for the behavior prior to version 0.3; default is 'od_factor'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res_clip_range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the results will be clipped to; default is c(-sqrt(ncol(umi)), sqrt(ncol(umi)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin_size</code></td>
<td>
<p>Number of genes to process simultaneously; this will determine how often the progress bars are updated and how much memory is being used; default is 500</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_cells</code></td>
<td>
<p>Only use genes that have been detected in at least this many cells; default is 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residual_type</code></td>
<td>
<p>What type of residuals to return; can be 'pearson', 'deviance', or 'none'; default is 'pearson'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_cell_attr</code></td>
<td>
<p>Make cell attributes part of the output; default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_gene_attr</code></td>
<td>
<p>Calculate gene attributes and make part of output; default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_corrected_umi</code></td>
<td>
<p>If set to TRUE output will contain corrected UMI matrix; see <code>correct</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_variance</code></td>
<td>
<p>Lower bound for the estimated variance for any gene in any cell when calculating pearson residual; one of 'umi_median', 'model_median', 'model_mean' or a
numeric. default is -Inf.  When set to 'umi_median' uses (median of non-zero UMIs / 5)^2 as the minimum variance so that a median UMI (often 1)
results in a maximum pearson residual of 5. When set to 'model_median' or 'model_mean' uses the mean/median of the model estimated mu per gene as the minimum_variance.#'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw_adjust</code></td>
<td>
<p>Kernel bandwidth adjustment factor used during regurlarization; factor will be applied to output of bw.SJ; default is 3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmean_eps</code></td>
<td>
<p>Small value added when calculating geometric mean of a gene to avoid log(0); default is 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_estimation_fun</code></td>
<td>
<p>Character string indicating which method to use to estimate theta (when method = poisson); default is 'theta.ml', but 'theta.mm' seems to be a good and fast alternative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_given</code></td>
<td>
<p>If method is set to nb_theta_given, this should be a named numeric vector of fixed theta values for the genes; if method is offset, this should be a single value; default is NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_poisson</code></td>
<td>
<p>Exclude poisson genes (i.e. mu &lt; 0.001 or mu &gt; variance) from regularization; default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_geometric_mean</code></td>
<td>
<p>Use geometric mean instead of arithmetic mean for all calculations ; default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_geometric_mean_offset</code></td>
<td>
<p>Use geometric mean instead of arithmetic mean in the offset model; default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_intercept</code></td>
<td>
<p>Fix intercept as defined in the offset model; default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_slope</code></td>
<td>
<p>Fix slope to log(10) (equivalent to using library size as an offset); default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_factor</code></td>
<td>
<p>Replace all values of UMI in the regression model by this value instead of the median UMI; default is NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vst.flavor</code></td>
<td>
<p>When set to 'v2' sets method = glmGamPoi_offset, n_cells=2000, and exclude_poisson = TRUE which causes the model to learn theta and intercept only besides excluding poisson genes from learning and regularization; default is NULL which uses the original sctransform model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>An integer specifying whether to show only messages (1), messages and progress bars (2) or nothing (0) while the function is running; default is 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_progress</code></td>
<td>
<p>Deprecated; use verbosity instead</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Matrix of transformed data, i.e. Pearson residuals, or deviance residuals; empty if <code>residual_type = 'none'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>umi_corrected</code></td>
<td>
<p>Matrix of corrected UMI counts (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_str</code></td>
<td>
<p>Character representation of the model formula</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_pars</code></td>
<td>
<p>Matrix of estimated model parameters per gene (theta and regression coefficients)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_pars_outliers</code></td>
<td>
<p>Vector indicating whether a gene was considered to be an outlier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_pars_fit</code></td>
<td>
<p>Matrix of fitted / regularized model parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_str_nonreg</code></td>
<td>
<p>Character representation of model for non-regularized variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_pars_nonreg</code></td>
<td>
<p>Model parameters for non-regularized variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genes_log_gmean_step1</code></td>
<td>
<p>log-geometric mean of genes used in initial step of parameter estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cells_step1</code></td>
<td>
<p>Cells used in initial step of parameter estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arguments</code></td>
<td>
<p>List of function call arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_attr</code></td>
<td>
<p>Data frame of cell meta data (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene_attr</code></td>
<td>
<p>Data frame with gene attributes such as mean, detection rate, etc. (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Time stamps at various points in the function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the first step of the algorithm, per-gene glm model parameters are learned. This step can be done
on a subset of genes and/or cells to speed things up.
If <code>method</code> is set to 'poisson', a poisson regression is done and
the negative binomial theta parameter is estimated using the response residuals in
<code>theta_estimation_fun</code>.
If <code>method</code> is set to 'qpoisson', coefficients and overdispersion (phi) are estimated by quasi
poisson regression and theta is estimated based on phi and the mean fitted value - this is currently
the fastest method with results very similar to 'glmGamPoi'
If <code>method</code> is set to 'nb_fast', coefficients and theta are estimated as in the
'poisson' method, but coefficients are then re-estimated using a proper negative binomial
model in a second call to glm with <code>family = MASS::negative.binomial(theta = theta)</code>.
If <code>method</code> is set to 'nb', coefficients and theta are estimated by a single call to
<code>MASS::glm.nb</code>.
If <code>method</code> is set to 'glmGamPoi', coefficients and theta are estimated by a single call to
<code>glmGamPoi::glm_gp</code>.
</p>
<p>A special case is <code>method = 'offset'</code>. Here no regression parameters are learned, but
instead an offset model is assumed. The latent variable is set to log_umi and a fixed
slope of log(10) is used (offset). The intercept is given by log(gene_mean) - log(avg_cell_umi).
See Lause et al. doi: <a href="https://doi.org/10.1186/s13059-021-02451-7">10.1186/s13059-021-02451-7</a> for details.
Theta is set
to 100 by default, but can be changed using the <code>theta_given</code> parameter (single numeric value).
If the offset method is used, the following parameters are overwritten:
<code>cell_attr &lt;- NULL, latent_var &lt;- c('log_umi'), batch_var &lt;- NULL, latent_var_nonreg &lt;- NULL,
n_genes &lt;- NULL, n_cells &lt;- NULL, do_regularize &lt;- FALSE</code>. Further, <code>method = 'offset_shared_theta_estimate'</code>
exists where the 250 most highly expressed genes with detection rate of at least 0.5 are used
to estimate a theta that is then shared across all genes. Thetas are estimated per individual gene
using 5000 randomly selected cells. The final theta used for all genes is then the average.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
vst_out &lt;- vst(pbmc)


</code></pre>


</div>