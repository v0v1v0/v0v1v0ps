<div class="container">

<table style="width: 100%;"><tr>
<td>enc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Encryption of shipment content</h2>

<h3>Description</h3>

<p>Various functions and helper functions to establish encrypted files. To
secure the content (any file) the Advanced Encryption Standard (AES) is
applied with an ephemeral key consisting of 256 random bits. This key is
only used once for encryption (and then one more time during decryption at a
later stage). A random 128 bit initialization vector (iv) is also applied
during encryption. There is no extra security gain in this since the key
will never be re-used for encryption/decryption. So, just for good measures
then :-) After the content has been encrypted the key itself is encrypted by
applying a public key offered by the recipient. This key is obtained from a
public provider. Currently, GitHub is the only option. The three files:
encrypted content, the encrypted key and the (cleartext) iv is then bundled
into a tarball ready for shipment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">enc_filename(filename)

make_pubkey_url(pubkey_holder = "github", pid)

get_pubkey(pubkey_holder, pid)

enc(filename, pubkey_holder, pid, pubkey = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Character string with fully qualified path to a file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pubkey_holder</code></td>
<td>
<p>Character string defining the provider of the public key
used for encryption of the symmetric key. Currently, 'github' is the only
valid pubkey holder. If a local pubkey is to be used (see parameter
<code>pubkey</code>, <code>pubkey_holder</code> may be set to NULL or some other value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>
<p>Character string uniquely defining the user at
<code>pubkey_holder</code> who is also the owner of the  public key.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pubkey</code></td>
<td>
<p>Character string representing a valid public key. Default is
NULL in which case the key will be obtained as per <code>pubkey_holder</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Encrypted files can be decrypted outside R using the OpenSSL library. Both
the key and the initialization vector (iv) are binary and this method uses
the key directly (and not a [hashed] passphrase). OpenSSL decryption need to
be fed the key (and iv) as a string of hex digits. Methods for conversion
from binary to hex may vary between systems. Below, a bash shell (unix)
example is given
</p>

<p>Step 1: decrypt symmetric key (open envelope) using a private key
</p>
<pre>
openssl rsautl -decrypt -inkey ~/.ssh/id_rsa -in key.enc -out key
</pre>
<p>Step 2: decrypt content by key obtained in step 1, also converting key and
iv to strings of hexadecimal digits
</p>
<pre>
openssl aes-256-cbc -d -in data.csv.enc -out data.csv \
-K $(hexdump -e '32/1 "%02x"' key) -iv $(hexdump -e '16/1 "%02x"' iv)
</pre>


<h3>Value</h3>

<p>Character string providing a filename or a key
</p>


<h3>See Also</h3>

<p>dec
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Please note that these examples will write files to a local temporary
# directory.

## Define temporary working directory and a secret file name
wd &lt;- tempdir()
secret_file_name &lt;- "secret.rds"

## Add content to the secret file
saveRDS(iris, file = file.path(wd, secret_file_name), ascii = TRUE)

## Make a private-public key pair named "id_rsa" and "id_rsa.pub"
keygen(directory = wd, type = "rsa", overwrite_existing = TRUE)

## Load public key
pubkey &lt;- readLines(file.path(wd, "id_rsa.pub"))

## Make a secured file (ready for shipment)
secure_secret_file &lt;- enc(filename = file.path(wd, "secret.rds"),
                          pubkey_holder = NULL, pubkey = pubkey)
</code></pre>


</div>