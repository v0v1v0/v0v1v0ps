<div class="container">

<table style="width: 100%;"><tr>
<td>pelora</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Supervised Grouping of Predictor Variables</h2>

<h3>Description</h3>

<p>Performs selection and supervised grouping of predictor
variables in large (microarray gene expression) datasets, with an
option for simultaneous classification. Works in a greedy forward
strategy and optimizes the binomial log-likelihood, based on estimated
conditional probabilities from penalized logistic regression analysis.</p>


<h3>Usage</h3>

<pre><code class="language-R">pelora(x, y, u = NULL, noc = 10, lambda = 1/32, flip = "pm",
       standardize = TRUE, trace = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be grouped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Numeric matrix of additional (clinical) explanatory variables
(<code class="reqn">m</code> variables in columns, <code class="reqn">n</code> cases in rows) that are used
in the (penalized logistic regression) prediction model, but neither
grouped nor averaged. For example, these can be 'traditional'
clinical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noc</code></td>
<td>
<p>Integer, the number of clusters that should be searched for
on the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Real, defaults to 1/32. Rescaled penalty parameter that
should be in <code class="reqn">[0,1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>Character string, describing a method how the <code>x</code>
(gene expression) matrix should be sign-flipped. Possible are
<code>"pm"</code> (the default) where the sign for each variable is
determined upon its entering into the group, <code>"cor"</code> where the
sign for each variable is determined a priori as the sign of the
empirical correlation of that variable with the <code>y</code>-vector, and
<code>"none"</code> where no sign-flipping is carried out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Is indicating
whether the predictor variables (genes) should be standardized to
zero mean and unit variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Integer &gt;= 0; when positive, the output of the internal
loops is provided; <code>trace &gt;= 2</code> provides output even from the
internal C routines.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>pelora</code> returns an object of class "pelora". The functions
<code>print</code> and <code>summary</code> are used to obtain an overview of the
variables (genes) that have been selected and the groups that have
been formed. The function <code>plot</code> yields a two-dimensional
projection into the space of the first two group centroids that
<code>pelora</code> found. The generic function <code>fitted</code> returns
the fitted values, these are the cluster representatives. <code>coef</code>
returns the penalized logistic regression coefficients <code class="reqn">\theta_j</code>
for each of the predictors. Finally, <code>predict</code> is used for
classifying test data with Pelora's internal penalized logistic
regression classifier on the basis of the (gene) groups that have been
found.
</p>
<p>An object of class "pelora" is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>genes</code></td>
<td>
<p>A list of length <code>noc</code>, containing integer vectors
consisting of the indices (column numbers) of the variables (genes)
that have been clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>A numerical matrix with dimension <code class="reqn">n \times
      \code{noc}</code>, containing the fitted values, i.e. the group
centroids <code class="reqn">\tilde{x}_j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels are coded by 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>Numerical vector of length <code>noc</code>, showing the number
of forward/backward cycles in the fitting process of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The rescaled penalty parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noc</code></td>
<td>
<p>The number of clusters that has been searched for on the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>px</code></td>
<td>
<p>The number of columns (genes) in the <code>x</code>-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>The method that has been chosen for sign-flipping the
<code>x</code>-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.type</code></td>
<td>
<p>A factor with <code>noc</code> entries, describing whether
the <code class="reqn">j</code>th predictor is a group of predictors (genes) or a single
(clinical) predictor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>A list of length <code>noc</code>, containing numerical vectors
that provide information about the development of the grouping
criterion during the clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signs</code></td>
<td>
<p>Numerical vector of length <code class="reqn">p</code>, saying whether the
<code class="reqn">i</code>th variable (gene) should be sign-flipped (-1) or not (+1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.names</code></td>
<td>
<p>The names of the samples (rows) in the
<code>x</code>-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.names</code></td>
<td>
<p>The names of the variables (columns) in the
<code>x</code>-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The function call.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Marcel Dettling (2003)
<em>Finding Predictive Gene Groups from Microarray Data</em>, see
<a href="https://stat.ethz.ch/~dettling/supervised.html">https://stat.ethz.ch/~dettling/supervised.html</a>
</p>
<p>Marcel Dettling and Peter Bühlmann (2002).
Supervised Clustering of Genes.
<em>Genome Biology</em>, <b>3</b>(12): research0069.1-0069.15,
doi: <a href="https://doi.org/10.1186/gb-2002-3-12-research0069">10.1186/gb-2002-3-12-research0069</a>.
</p>
<p>Marcel Dettling and Peter Bühlmann (2004).
Finding Predictive Gene Groups from Microarray Data.
<em>Journal of Multivariate Analysis</em> <b>90</b>, 106–131,
doi: <a href="https://doi.org/10.1016/j.jmva.2004.02.012">10.1016/j.jmva.2004.02.012</a>
</p>


<h3>See Also</h3>

<p><code>wilma</code> for another supervised clustering technique.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Pelora
fit &lt;- pelora(leukemia.x, leukemia.y, noc = 3)

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)
coef(fit)

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", noc = c(1,2,3))
predict(fit, newdata = xN, type = "pro", noc = c(1,3))

## Fitting Pelora such that the first 70 variables (genes) are not grouped
fit &lt;- pelora(leukemia.x[, -(1:70)], leukemia.y, leukemia.x[,1:70])

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)
coef(fit)

## Fitted values and class probabilities for the training data
predict(fit, type = "cla")
predict(fit, type = "prob")

## Predicting fitted values and class labels for the random test data
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70])
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], "cla", noc  = 1:10)
predict(fit, newdata = xN[, -(1:70)], newclin = xN[, 1:70], type = "pro")
</code></pre>


</div>