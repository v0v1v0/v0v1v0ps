<div class="container">

<table style="width: 100%;"><tr>
<td>lexcelScores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lexicographical Excellence</h2>

<h3>Description</h3>

<p>Calculate the Lexicographical Excellence (or Lexcel) score.
</p>
<p><code>lexcelRanking()</code> returns the corresponding ranking.
</p>
<p><code>dualLexcelRanking()</code> uses the same score vectors but instead of rewarding
participation, it punishes mediocrity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lexcelScores(powerRelation, elements = powerRelation$elements)

lexcelRanking(powerRelation)

dualLexcelRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An equivalence class <code class="reqn">\sum_i</code> contains coalitions that are indifferent to one another.
In a given power relation created with <code>PowerRelation()</code> or <code>as.PowerRelation()</code>, the equivalence classes are saved in <code style="white-space: pre;">⁠$eqs⁠</code>.
</p>
<p>As an example, consider the power relation
<code class="reqn">\succsim: 123 \succ (12 \sim 13 \sim 1 \sim \emptyset) \succ (23 \sim 1 \sim 2)</code>.
The corresponding equivalence classes are:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_1 = \lbrace 123 \rbrace, \sum_2 = \lbrace 12, 13, 1, \emptyset \rbrace, \sum_3 = \lbrace 23, 1, 2 \rbrace.
</code>
</p>

<p>The lexcel score of an element is a vector wherein each index indicates the number of times that element appears in the equivalence class.
From our example, we would get
</p>
<p style="text-align: center;"><code class="reqn">\textrm{lexcel}(1) = [ 1, 3, 1 ], \textrm{lexcel}(2) = [ 1, 1, 2 ], \textrm{lexcel}(3) = [ 1, 1, 1 ].</code>
</p>



<h3>Value</h3>

<p>Score function returns a list of type <code>LexcelScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>powerRelation$eqs</code>, the number of
times the given element appears in each equivalence class.
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>Lexcel Ranking</h3>

<p>The most "excellent contribution" of an element determines its ranking against the other elements.
Given two Lexcel score vectors <code class="reqn">\textrm{Score}(i)</code>
and <code class="reqn">\textrm{Score}(j)</code>, the first index <code class="reqn">x</code> where
<code class="reqn">\textrm{Score}(i)_x \neq \textrm{Score}(j)_x</code>
determines which element should be ranked higher.
</p>
<p>From the previous example this would be <code class="reqn">1 &gt; 2 &gt; 3</code>, because:
</p>
<p><code class="reqn">\textrm{Score}(1)_2 = 3 &gt; \textrm{Score}(2)_2 = \textrm{Score}(3)_2 = 1</code>,
<code class="reqn">\textrm{Score}(2)_3 = 2 &gt; \textrm{Score}(3)_3 = 1</code>.
</p>


<h3>Dual Lexcel Ranking</h3>

<p>The dual lexcel works in reverse order and, instead of rewarding high
scores, punishes mediocrity. In that case we get <code class="reqn">3 &gt; 1 &gt; 2</code>
because:
</p>
<p><code class="reqn">\textrm{Score}(3)_3 &lt; \textrm{Score}(2)_3</code> and
<code class="reqn">\textrm{Score}(3)_2 &lt; \textrm{Score}(1)_2</code>,
<code class="reqn">\textrm{Score}(1)_3 &lt; \textrm{Score}(2)_3</code>.
</p>


<h3>References</h3>

<p>Bernardi G, Lucchetti R, Moretti S (2019).
“Ranking objects from a preference relation over their subsets.”
<em>Social Choice and Welfare</em>, <b>52</b>(4), 589–606.
</p>
<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
“Lexicographic solutions for coalitional rankings.”
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1–33.
</p>
<p>Serramia M, López-Sánchez M, Moretti S, Rodríguez-Aguilar JA (2021).
“On the dominant set selection problem and its application to value alignment.”
<em>Autonomous Agents and Multi-Agent Systems</em>, <b>35</b>(2), 1–38.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code>L1Scores()</code>,
<code>L2Scores()</code>,
<code>LPSScores()</code>,
<code>LPScores()</code>,
<code>copelandScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># note that the coalition {1} appears twice
# 123 &gt; 12 ~ 13 ~ 1 ~ {} &gt; 23 ~ 1 ~ 2
# E = {123} &gt; {12, 13, 1, {}} &gt; {23, 1, 2}
pr &lt;- suppressWarnings(as.PowerRelation(
  "123 &gt; (12 ~ 13 ~ 1 ~ {}) &gt; (23 ~ 1 ~ 2)"
))

# lexcel scores for all elements
# `1` = c(1, 3, 1)
# `2` = c(1, 1, 2)
# `3` = c(1, 1, 1)
lexcelScores(pr)

# lexcel scores for a subset of all elements
lexcelScores(pr, c(1, 3))
lexcelScores(pr, 2)

# 1 &gt; 2 &gt; 3
lexcelRanking(pr)

# 3 &gt; 1 &gt; 2
dualLexcelRanking(pr)

</code></pre>


</div>