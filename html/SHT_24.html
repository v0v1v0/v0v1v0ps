<div class="container">

<table style="width: 100%;"><tr>
<td>mean2.2014CLX</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two-sample Test for High-Dimensional Means by Cai, Liu, and Xia (2014)</h2>

<h3>Description</h3>

<p>Given two multivariate data <code class="reqn">X</code> and <code class="reqn">Y</code> of same dimension, it tests
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \mu_x = \mu_y\quad vs\quad H_1 : \mu_x \neq \mu_y</code>
</p>

<p>using the procedure by Cai, Liu, and Xia (2014) which is equivalent to test
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \Omega(\mu_x - \mu_y)=0</code>
</p>

<p>for an inverse covariance (or precision) <code class="reqn">\Omega</code>. When <code class="reqn">\Omega</code> is not given 
and known to be sparse, it is first estimated with CLIME estimator. Otherwise, 
adaptive thresholding estimator is used. Also, if two samples 
are assumed to have different covariance structure, it uses weighting scheme for adjustment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mean2.2014CLX(
  X,
  Y,
  precision = c("sparse", "unknown"),
  delta = 2,
  Omega = NULL,
  cov.equal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">(n_x \times p)</code> data matrix of 1st sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>an <code class="reqn">(n_y \times p)</code> data matrix of 2nd sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>type of assumption for a precision matrix (default: <code>"sparse"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>an algorithmic parameter for adaptive thresholding estimation (default: 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>precision matrix; if <code>NULL</code>, an estimate is used. Otherwise, 
a <code class="reqn">(p\times p)</code> inverse covariance should be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.equal</code></td>
<td>
<p>a logical to determine homogeneous covariance assumption.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a (list) object of <code>S3</code> class <code>htest</code> containing: </p>

<dl>
<dt>statistic</dt>
<dd>
<p>a test statistic.</p>
</dd>
<dt>p.value</dt>
<dd>
<p><code class="reqn">p</code>-value under <code class="reqn">H_0</code>.</p>
</dd>
<dt>alternative</dt>
<dd>
<p>alternative hypothesis.</p>
</dd>
<dt>method</dt>
<dd>
<p>name of the test.</p>
</dd>
<dt>data.name</dt>
<dd>
<p>name(s) of provided sample data.</p>
</dd>
</dl>
<h3>References</h3>

<p>Cai TT, Liu W, Xia Y (2014).
“Two-sample test of high dimensional means under dependence.”
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>76</b>(2), 349–372.
ISSN 13697412.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## CRAN-purpose small example
smallX = matrix(rnorm(10*3),ncol=3)
smallY = matrix(rnorm(10*3),ncol=3)
mean2.2014CLX(smallX, smallY, precision="unknown")
mean2.2014CLX(smallX, smallY, precision="sparse")

## Not run: 
## empirical Type 1 error 
niter   = 100
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
  X = matrix(rnorm(50*5), ncol=10)
  Y = matrix(rnorm(50*5), ncol=10)
  
  counter[i] = ifelse(mean2.2014CLX(X, Y)$p.value &lt; 0.05, 1, 0)
}

## print the result
cat(paste("\n* Example for 'mean2.2014CLX'\n","*\n",
"* number of rejections   : ", sum(counter),"\n",
"* total number of trials : ", niter,"\n",
"* empirical Type 1 error : ",round(sum(counter/niter),5),"\n",sep=""))

## End(Not run)

</code></pre>


</div>