<div class="container">

<table style="width: 100%;"><tr>
<td>bootSemNeT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrapped Semantic Network Analysis</h2>

<h3>Description</h3>

<p>Bootstrap techniques to generate
semantic networks and compute global network characteristics
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootSemNeT(
  ...,
  method = c("CN", "NRW", "PF", "TMFG"),
  methodArgs = list(),
  type = c("case", "node"),
  prop = 0.5,
  sim,
  weighted = FALSE,
  iter = 1000,
  cores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Matrices or data frames.
Cleaned response matrices (e.g., <code>responses$clean</code> from
<code>textcleaner</code>) or  binary response matrices
(e.g., <code>binary</code> output from <code>textcleaner</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character.
Network estimation method to use.
Current options include:
</p>

<ul>
<li>
<p><code>TMFG</code>
Triangulated Maximally Filtered Graph
</p>
</li>
<li>
<p><code>CN</code>
Community Network
</p>
</li>
<li>
<p><code>NRW</code>
Naive Random Walk
</p>
</li>
<li>
<p><code>PF</code>
Pathfinder
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methodArgs</code></td>
<td>
<p>List.
A list of additional arguments for the network estimation function.
See links in argument <code>method</code> for additional arguments (see also Examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character.
Type of bootstrap to perform
</p>

<ul>
<li>
<p><code>node</code>
Generates partial networks based on dropping a certain
proportion of nodes (see argument <code>prop</code>)
</p>
</li>
<li>
<p><code>case</code>
Samples with replacement the same number of participants
as in the original dataset
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>Numeric.
<strong>Only</strong> for <code>type = "node"</code>.
Proportion of nodes to remain in the network.
Defaults to <code>.50</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>Character.
Similarity measure to use.
Defaults to <code>"cosine"</code>.
See <code>similarity</code> for other options</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>Boolean.
Should weighted ASPL and CC be used?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> for weighted ASPL and CC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Numeric.
Number of iterations in bootstrap.
Defaults to <code>1000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Numeric.
Number of computer processing cores to use for bootstrapping samples.
Defaults to <em>n</em> / 2 total number of cores.
Set to any number between 1 and maximum amount of cores on your computer
(see <code>parellel::detectCores()</code>)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dataMeas</code></td>
<td>
<p>A matrix for the network input in the <code>data</code>
argument, where columns are the semantic network measures
from <code>semnetmeas</code> and rows are their values from each
bootstrapped sample (results in a matrix with the dimensions <code>iter</code> by 3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataSumm</code></td>
<td>
<p>Summary statistics across the bootrapped samples for the
network input in the <code>data</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>Outputs the proportion used from the <code>prop</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Outputs the number of bootstrapped samples
used from the <code>iter</code> argument</p>
</td>
</tr>
</table>
<p>If a <code>paired</code> network is input, then also returns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pairedMeas</code></td>
<td>
<p>A matrix for the network input in the <code>paired</code>
argument, where columns are the semantic network measures
from <code>semnetmeas</code> and rows are their values from each
bootstrapped sample (results in a matrix with the dimensions <code>iter</code> by 3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairedSumm</code></td>
<td>
<p>Summary statistics across the bootrapped samples for the
network input in the <code>paired</code> argument</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Simulate Dataset
one &lt;- sim.fluency(20)

# Run bootstrap node-drop (partial) networks
one.result &lt;- bootSemNeT(one, prop = .50, iter = 100,
sim = "cosine", cores = 2, method = "TMFG", type = "node")

# Run bootstrap case-drop networks
## Includes additional equating argument: minCase
one.result &lt;- bootSemNeT(one, iter = 100, sim = "cosine",
cores = 2, method = "TMFG", type = "case", methodArgs = list(minCase = 2))


# Bootstrap case-wise networks
## Get openness data
low &lt;- open.clean[which(open.group == "Low"),]
high &lt;- open.clean[which(open.group == "High"),]

## Run
### Inlcudes additional NRW argument: threshold
open &lt;- bootSemNeT(low, high, iter = 100, cores = 2, method = "NRW", type = "case",
methodArgs = list(type = "num", threshold = 3))


</code></pre>


</div>