<div class="container">

<table style="width: 100%;"><tr>
<td>algo.cusum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CUSUM method</h2>

<h3>Description</h3>

 
<p>Approximate one-side CUSUM method for a Poisson variate based on the 
cumulative sum of the deviation between a reference value k and the 
transformed observed values.
An alarm is raised if the cumulative sum equals or exceeds a prespecified
decision boundary h. The function can handle time varying expectations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">algo.cusum(disProgObj, control = list(range = range, k = 1.04, h = 2.26, 
           m = NULL, trans = "standard", alpha = NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>disProgObj</code></td>
<td>
<p>object of class disProg (including the observed and the state chain)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control object: 
</p>

<dl>
<dt><code>range</code></dt>
<dd>
<p>determines the desired time points which should be evaluated</p>
</dd>
<dt><code>k</code></dt>
<dd>
<p>is the reference value</p>
</dd>
<dt><code>h</code></dt>
<dd>
<p>the decision boundary</p>
</dd>
<dt><code>m</code></dt>
<dd>
<p>how to determine the expected number of cases – 
the following arguments are possible
</p>

<dl>
<dt><code>numeric</code></dt>
<dd>
<p>a vector of values having the
same length as <code>range</code>. If a single numeric
value is specified then this value is replicated
<code>length(range)</code> times.</p>
</dd>
<dt><code>NULL</code></dt>
<dd>
<p>A single value is estimated by
taking the mean of all observations previous to
the first <code>range</code> value.</p>
</dd>
<dt><code>"glm"</code></dt>
<dd>
<p> A GLM of the form </p>
<p style="text-align: center;"><code class="reqn">\log(m_t)
                      = \alpha + \beta t + \sum_{s=1}^S (\gamma_s
                      \sin(\omega_s t) + \delta_s \cos(\omega_s t)),</code>
</p>

<p>where <code class="reqn">\omega_s = \frac{2\pi}{52}s</code> are the
Fourier frequencies is fitted. Then this model is
used to predict the <code>range</code> values.</p>
</dd>
</dl>
</dd>
<dt><code>trans</code></dt>
<dd>
<p>one of the following transformations (warning: Anscombe and NegBin transformations are experimental)
</p>

<dl>
<dt><code>rossi</code></dt>
<dd>
<p>standardized variables z3 as proposed by Rossi</p>
</dd>
<dt><code>standard</code></dt>
<dd>
<p>standardized variables z1 (based
on asymptotic normality) - This is the default.</p>
</dd>
<dt><code>anscombe</code></dt>
<dd>
<p>anscombe residuals – experimental</p>
</dd>
<dt><code>anscombe2nd</code></dt>
<dd>
<p> anscombe residuals as in Pierce and Schafer (1986) based on 2nd order approximation of E(X)  – experimental</p>
</dd>
<dt><code>pearsonNegBin</code></dt>
<dd>
<p>compute Pearson residuals for NegBin – experimental</p>
</dd>
<dt><code>anscombeNegBin</code></dt>
<dd>
<p>anscombe residuals for NegBin – experimental</p>
</dd>
<dt><code>none</code></dt>
<dd>
<p> no transformation</p>
</dd>
</dl>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>parameter of the negative binomial distribution, s.t. the variance is <code class="reqn">m+\alpha *m^2</code> </p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>algo.cusum</code> gives a list of class <code>"survRes"</code> which includes the 
vector of alarm values for every timepoint in <code>range</code> and the vector 
of cumulative sums for every timepoint in <code>range</code> for the system 
specified by <code>k</code> and <code>h</code>, the range and the input object of 
class <code>"disProg"</code>.
</p>
<p>The <code>upperbound</code> entry shows for each time instance the number of diseased individuals
it would have taken the cusum to signal. Once the CUSUM signals no resetting is applied, i.e.
signals occurs until the CUSUM statistic again returns below the threshold.
</p>
<p>In case <code>control$m="glm"</code> was used, the returned
<code>control$m.glm</code> entry contains the fitted <code>"glm"</code> object.
</p>


<h3>Note</h3>

<p>This implementation is experimental, but will not be developed further.</p>


<h3>Author(s)</h3>

<p>M. Paul and M. Höhle</p>


<h3>References</h3>

<p>G. Rossi, L. Lampugnani and M. Marchi (1999), An approximate CUSUM procedure for surveillance of health events, Statistics in Medicine, 18, 2111–2122
</p>
<p>D. A. Pierce and D. W. Schafer (1986), Residuals in Generalized Linear Models, Journal of the American Statistical Association, 81, 977–986
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Xi ~ Po(5), i=1,...,500
set.seed(321)
stsObj &lt;- sts(observed = rpois(500,lambda=5))
# there should be no alarms as mean doesn't change
res &lt;- cusum(stsObj, control = list(range = 100:500, trans = "anscombe"))
plot(res, xaxis.labelFormat = NULL)

# simulated data
disProgObj &lt;- sim.pointSource(p = 1, r = 1, length = 250,
                              A = 0, alpha = log(5), beta = 0, phi = 10,
                              frequency = 10, state = NULL, K = 0)
plot(disProgObj)

# Test weeks 200 to 250 for outbreaks
surv0 &lt;- algo.cusum(disProgObj, control = list(range = 200:250))
plot(surv0, xaxis.years = FALSE)

# alternatively, using the newer "sts" interface
stsObj &lt;- disProg2sts(disProgObj)
surv &lt;- cusum(stsObj, control = list(range = 200:250))
plot(surv)
stopifnot(upperbound(surv) == surv0$upperbound)
</code></pre>


</div>