<div class="container">

<table style="width: 100%;"><tr>
<td>GenAlgForSubsetSelectionNoTest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Genetic algorithm for subset selection no given test</h2>

<h3>Description</h3>

<p>It uses a genetic algorithm to select <code class="reqn">n_{Train}</code> individuals so that optimality criterion is minimum. The test set is taken as the complement of the training individuals. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">GenAlgForSubsetSelectionNoTest(P, ntoselect, npop = 100, nelite = 5, keepbest = TRUE,
tabu = TRUE, tabumemsize = 1, mutprob=.8, mutintensity = 1,
niterations = 500, minitbefstop = 200, niterreg = 5,
lambda = 1e-06, plotiters = FALSE, plottype=1, errorstat =
 "PEVMEAN2", C = NULL, mc.cores = 1, InitPop = NULL,
 tolconv = 1e-07, Vg = NULL, Ve = NULL, Fedorov=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>

<p>depending on the criterion this is either a numeric data matrix or a symmetric similarity matrix. When it is a data matrix, the union of the identifiers of the candidate individuals should be put as rownames (and column names in case of a similarity matrix). For methods using the relationships, this is the inverse of the relationship matrix with row and column names as the the identifiers of the candidate individuals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntoselect</code></td>
<td>

<p><code class="reqn">n_{Train}:</code> number of individuals to select in the training set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npop</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nelite</code></td>
<td>

<p>genetic algorithm parameter, number of solutions selected as elite parents which will  generate the next set of solutions. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepbest</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the best solution is always kept in the next generation of solutions (elitism). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tabu</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the solutions that are saved in tabu memory will not be retried.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tabumemsize</code></td>
<td>

<p>genetic algorithm parameter, integer&gt;0. Number of generations to hold in tabu memory. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterations</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minitbefstop</code></td>
<td>

<p>genetic algorithm parameter, number of iterations before stopping if no change is observed in criterion value.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterreg</code></td>
<td>

<p>genetic algorithm parameter, number of iterations to use regressions, an integer with minimum value of 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>scalar shrinkage parameter (<code class="reqn">\lambda&gt;0</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plottype</code></td>
<td>

<p>type of plot, default is 1. possible values 1,2,3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorstat</code></td>
<td>

<p>optimality criterion: One of the optimality criterion. Default is "PEVMEAN". It is possible to use user defined functions as shown in the examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolconv</code></td>
<td>

<p>if the algorithm cannot improve the errorstat more than tolconv for the last minitbefstop iterations it will stop.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vg</code></td>
<td>

<p>covariance matrix between traits generated by the relationship K (only for multi-trait version of PEVMEANMM).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ve</code></td>
<td>

<p>residual covariance matrix for the traits (only for multi-trait version of PEVMEANMM). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fedorov</code></td>
<td>

<p>Whether the Fedorovs exchange algorithm from <code>AlgDesign</code> Package should be used for initial solutions. 
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of length nelite+1. The first nelite elements of the list are optimized training samples of size <code class="reqn">n_{train}</code> and they are listed in increasing order of the optimization criterion. The last item on the list is a vector that stores the minimum values of the objective function at each iteration. 
</p>


<h3>Note</h3>

<p>The GA does not guarantee convergence to globally optimal solutions and it is highly recommended that the algorithm is replicated to obtain ”good” training samples.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
###################### Example for three level designs for the 
#second order model in two factors with a square design region
X&lt;-matrix(0,nrow=3^2,ncol=5)
ij=0

for (i in -1:1){
  for (j in -1:1){
    ij=ij+1
    X[ij,]&lt;-c(i,j, i^2,j^2, i*j)
    
  }
}
X&lt;-cbind(1,X)
D&lt;-as.matrix(dist(X))
K&lt;-tcrossprod(X)
rownames(K)&lt;-colnames(K)&lt;-rownames(D)&lt;-colnames(D)&lt;-rownames(X)&lt;-paste("x",1:3^2, sep="")
X
library(STPGA)
ListTrain1&lt;-GenAlgForSubsetSelectionNoTest(P=X,ntoselect=4, InitPop=NULL,
             npop=100, nelite=5, mutprob=.5, mutintensity = 1,
             niterations=200,minitbefstop=20, tabu=F,tabumemsize = 0,plotiters=F,
             lambda=1e-9,errorstat="DOPT", mc.cores=1)
                                                 
                                                 
ListTrain2&lt;-GenAlgForSubsetSelectionNoTest(P=solve(K+1e-6*diag(ncol(K))),ntoselect=4, InitPop=NULL,
            npop=100, nelite=5, mutprob=.5, mutintensity = 1,
            niterations=200,minitbefstop=20, tabu=F,tabumemsize = 0,plotiters=F,
            lambda=1,errorstat="CDMEANMM", mc.cores=1)
                                                 
                                                 
  par(mfrow=c(1,2),mar=c(1,1,1,1))
  labelling1&lt;-rownames(X)%in%ListTrain1[[1]]+1
  plot(X[,2], X[,3], col=labelling1, pch=2*labelling1,cex=2*(labelling1-1),
   xlab="", ylab="", main="DOPT", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }
    labelling2&lt;-rownames(X)%in%ListTrain2[[1]]+1
  plot(X[,2], X[,3], col=labelling2, pch=2*labelling2,cex=2*(labelling2-1),
   xlab="", ylab="", main="CDMEANMM", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }

########################Dopt design three level designs for the second order 
#model in two factors with a square design region

par(mfrow=c(2,2),mar=c(1,1,1,1))
 for (ntoselect in c(5,6,7,8)){
 	ListTrain&lt;-GenAlgForSubsetSelectionNoTest(P=X,ntoselect=ntoselect, InitPop=NULL,
             npop=10, nelite=3, mutprob=.5, mutintensity = 1,
             niterations=200,minitbefstop=200, tabu=F,tabumemsize = 0,plotiters=F,
             lambda=1e-9,errorstat="DOPT", mc.cores=1)
             
  labelling&lt;-rownames(X)%in%ListTrain[[1]]+1
  plot(as.numeric(X[,2]), as.numeric(X[,3]), col=labelling, pch=2*labelling,cex=2*(labelling-1),
   xlab="", ylab="", main="DOPT", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }

}

par(mfrow=c(1,1))


## End(Not run)
</code></pre>


</div>