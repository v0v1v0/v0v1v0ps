<div class="container">

<table style="width: 100%;"><tr>
<td>SIR_threshold_opt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SIR optimally thresholded</h2>

<h3>Description</h3>

<p>Apply a single-index <code class="reqn">SIR</code> on <code class="reqn">(X,Y)</code> with <code class="reqn">H</code> slices, with a soft/hard thresholding
of the interest matrix <code class="reqn">\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n</code> by an optimal
parameter <code class="reqn">\lambda_{opt}</code>. The <code class="reqn">\lambda_{opt}</code> is found automatically among a vector
of <code>n_lambda</code> <code class="reqn">\lambda</code>, starting from 0 to the maximum value of
<code class="reqn">\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n</code>. For each feature of <code class="reqn">X</code>,
the number of <code class="reqn">\lambda</code> associated with a selection of this feature is stored
(in a vector of size <code class="reqn">p</code>). This vector is sorted in a decreasing way. Then, thanks to
<code>strucchange::breakpoints</code>, a breakpoint is found in this sorted vector. The coefficients
of the variables at the left of the breakpoint, tend to be automatically toggled to 0 due
to the thresholding operation based on <code class="reqn">\lambda_{opt}</code>, and so should be removed (useless
variables). Finally, <code class="reqn">\lambda_{opt}</code> corresponds to the first <code class="reqn">\lambda</code> such that the
associated <code class="reqn">\hat{b}</code> provides the same number of zeros as the breakpoint's value.
</p>
<p>For example, for <code class="reqn">X \in R^{10}</code> and <code>n_lambda=100</code>, this sorted vector can look like this :</p>

<table>
<tr>
<td style="text-align: left;">
   X10 </td>
<td style="text-align: left;"> X3 </td>
<td style="text-align: left;"> X8 </td>
<td style="text-align: left;"> X5 </td>
<td style="text-align: left;"> X7 </td>
<td style="text-align: left;"> X9 </td>
<td style="text-align: left;"> X4 </td>
<td style="text-align: left;"> X6 </td>
<td style="text-align: left;"> X2 </td>
<td style="text-align: left;"> X1 </td>
</tr>
<tr>
<td style="text-align: left;">
   2 </td>
<td style="text-align: left;"> 3 </td>
<td style="text-align: left;"> 3 </td>
<td style="text-align: left;"> 4 </td>
<td style="text-align: left;"> 4 </td>
<td style="text-align: left;"> 4 </td>
<td style="text-align: left;"> 6 </td>
<td style="text-align: left;"> 10 </td>
<td style="text-align: left;"> 95 </td>
<td style="text-align: left;"> 100 </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Here, the breakpoint would be 8.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SIR_threshold_opt(
  Y,
  X,
  H = 10,
  n_lambda = 100,
  thresholding = "hard",
  graph = TRUE,
  output = TRUE,
  choice = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A numeric vector representing the dependent variable (a response vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A matrix representing the quantitative explanatory variables (bind by column).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>The chosen number of slices (default is 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_lambda</code></td>
<td>
<p>The number of lambda to test. The n_lambda tested lambdas are
uniformally distributed between 0 and the maximum value of the interest matrix. (default is 100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholding</code></td>
<td>
<p>The thresholding method to choose between hard and soft (default is hard).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A boolean, set to TRUE to plot graphs (default is TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>A boolean, set to TRUE to print informations (default is TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choice</code></td>
<td>
<p>the graph to plot:
</p>

<ul>
<li>
<p> "estim_ind" Plot the estimated index by the SIR model versus Y.
</p>
</li>
<li>
<p> "opt_lambda" Plot the choice of the optimal lambda.
</p>
</li>
<li>
<p> "cos2_selec" Plot the evolution of cos^2 and variable selection according to
lambda.
</p>
</li>
<li>
<p> "regul_path" Plot the regularization path of b.
</p>
</li>
<li>
<p> "" Plot every graphs (default).
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class SIR_threshold_opt, with attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>This is the optimal estimated EDR direction, which is the principal
eigenvector of the interest matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>A vector that contains the tested lambdas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_opt</code></td>
<td>
<p>The optimal lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat_b</code></td>
<td>
<p>A matrix of size p*n_lambda that contains an estimation of beta
in the columns for each lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_lambda</code></td>
<td>
<p>The number of lambda tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vect_nb_zeros</code></td>
<td>
<p>The number of 0 in b for each lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list_relevant_variables</code></td>
<td>
<p>A list that contains the variables selected by
the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit_bp</code></td>
<td>
<p>An object of class breakpoints from the strucchange package,
that contains informations about the breakpoint which allows to deduce the
optimal lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indices_useless_var</code></td>
<td>
<p>A vector that contains p items: each variable is
associated with the number of lambda that selects this variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vect_cos_squared</code></td>
<td>
<p>A vector that contains for each lambda,
the cosine squared between vanilla SIR and SIR thresholded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The number of variables in X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>The chosen number of slices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M1</code></td>
<td>
<p>The interest matrix thresholded with the optimal lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholding</code></td>
<td>
<p>The thresholding method used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Unevaluated call to the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_reduced</code></td>
<td>
<p>The X data restricted to the variables selected by the model.
It can be used to estimate a new SIR model on the relevant variables to improve
the estimation of b.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_pred</code></td>
<td>
<p>The index Xb' estimated by SIR.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Generate Data
set.seed(2)
n &lt;- 200
beta &lt;- c(1,1,rep(0,8))
X &lt;- mvtnorm::rmvnorm(n,sigma=diag(1,10))
eps &lt;- rnorm(n)
Y &lt;- (X%*%beta)**3+eps

# Apply SIR with soft thresholding
SIR_threshold_opt(Y,X,H=10,n_lambda=300,thresholding="soft")
</code></pre>


</div>