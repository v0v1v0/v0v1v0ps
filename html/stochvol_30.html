<div class="container">

<table style="width: 100%;"><tr>
<td>svsample_roll</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rolling Estimation of Stochastic Volatility Models</h2>

<h3>Description</h3>

<p><code>svsample_roll</code> performs rolling window estimation based on svsample.
A convenience function for backtesting purposes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">svsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svtsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svlsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svtlsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric vector containing the data (usually log-returns), which
must not contain zeros. Alternatively, <code>y</code> can be an <code>svsim</code>
object. In this case, the returns will be extracted and a message is signalled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designmatrix</code></td>
<td>
<p>regression design matrix for modeling the mean. Must
have <code>length(y)</code> rows. Alternatively, <code>designmatrix</code> may be a
string of the form <code>"arX"</code>, where <code>X</code> is a nonnegative integer. To
fit a constant mean model, use <code>designmatrix = "ar0"</code> (which is
equivalent to <code>designmatrix = matrix(1, nrow = length(y))</code>). To fit an
AR(1) model, use <code>designmatrix = "ar1"</code>, and so on. If some elements of
<code>designmatrix</code> are <code>NA</code>, the mean is fixed to zero (pre-1.2.0
behavior of <span class="pkg">stochvol</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_ahead</code></td>
<td>
<p>number of time steps to predict from each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forecast_length</code></td>
<td>
<p>the time horizon at the end of the data set
that is used for backtesting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_start</code></td>
<td>
<p><em>optional</em> the starting time point for backtesting.
Computed from <code>forecast_length</code> if omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit_every</code></td>
<td>
<p>the SV model is refit every <code>refit_every</code> time steps.
Only the value <code>1</code> is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit_window</code></td>
<td>
<p>one of <code>"moving"</code> or <code>"expanding"</code>. If
<code>"expanding"</code>, then the start of the time window stays
at the beginning of the data set. If <code>"moving"</code>, then the
length of the time window is constant throughout backtesting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate_quantile</code></td>
<td>
<p>vector of numbers between 0 and 1.
These quantiles are predicted using <code>predict.svdraws</code>
for each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate_predictive_likelihood</code></td>
<td>
<p>boolean. If <code>TRUE</code>,
the <code>n_ahead</code> predictive density is evaluated at the
<code>n_ahead</code> time observation after each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_draws</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the <code>svdraws</code> and
the <code>svpredict</code> objects are kept from each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>one of <code>"no"</code> (default), <code>"multicore"</code>, or <code>"snow"</code>,
indicating what type of parallellism is to be applied. Option
<code>"multicore"</code> is not available on Windows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cpus</code></td>
<td>
<p><em>optional</em> positive integer, the number of CPUs to be used in case of
parallel computations. Defaults to <code>1L</code>. Ignored if parameter
<code>cl</code> is supplied and <code>parallel != "snow"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p><em>optional</em> so-called SNOW cluster object as implemented in package
<code>parallel</code>. Ignored unless <code>parallel == "snow"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any extra arguments will be forwarded to
<code>svsample</code>, controlling the prior setup, the starting values for the
MCMC chains, the number of independent MCMC chains, thinning and other expert
settings.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions <code>svtsample_roll</code>, <code>svlsample_roll</code>, and <code>svtlsample_roll</code> are
wrappers around <code>svsample_roll</code> with convenient default values for the SV
model with t-errors, leverage, and both t-errors and leverage, respectively.
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>svdraws_roll</code>
holding a list item for every time window. The elements of these list items are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>a list object containing two elements: <code>train</code> is the vector
of indices used for fitting the model, and <code>test</code> is the vector of indices
used for prediction. The latter is mainly useful if a <code>designmatrix</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>the input parameter <code>calculate_quantiles</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit_every</code></td>
<td>
<p>the input parameter <code>refit_every</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictive_likelihood</code></td>
<td>
<p>present only if <code>calculate_predictive_likelihood</code>
is <code>TRUE</code>. Then it is a number, the expected predictive density
of the observation. The expecation is taken over the joint <code>n_ahead</code> predictive
distribution of all model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictive_quantile</code></td>
<td>
<p>present only if <code>calculate_quantile</code> is a non-empty
vector. Then it is a vector of quantiles from the <code>n_ahead</code> predictive
distribution of <code>y</code>. It is based on MCMC simulation by using <code>predict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>present only if <code>keep_draws</code> is <code>TRUE</code>. Then it is an
<code>svdraws</code> object as returned by <code>svsample</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction</code></td>
<td>
<p>present only if <code>keep_draws</code> is <code>TRUE</code>. Then it is an
<code>svpredict</code> object as returned by <code>predict.svdraws</code>.</p>
</td>
</tr>
</table>
<p>To display the output, use <code>print</code> and <code>summary</code>. The
<code>print</code> method simply prints a short summary of the setup;
the <code>summary</code> method displays the summary statistics
of the backtesting.
</p>


<h3>Note</h3>

<p>The function executes <code>svsample</code> <code>(length(y) - arorder - n_ahead - n_start + 2) %/% refit_every</code> times.
</p>


<h3>See Also</h3>

<p><code>svsim</code>, <code>specify_priors</code>, <code>svsample</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Simulate from the true model
sim &lt;- svsim(200)

# Perform rolling estimation using the vanilla SV
# model and default priors
roll &lt;- svsample_roll(sim, draws = 5000, burnin = 2000,
                      keep_draws = TRUE,
                      forecast_length = 10,
                      n_ahead = 1, refit_every = 1,
                      refit_window = "moving",
                      calculate_predictive_likelihood = TRUE,
                      calculate_quantile = c(0.01, 0.05))

# Perform rolling estimation by making use
# of two CPU cores, advanced priors, and multiple
# chains with pre-set initial values. Let us combine
# that with an AR(2) specification
prior_beta &lt;- sv_multinormal(c(1,0,-1), rbind(c(1, 0, 0.1),
                                              c(0, 0.3, -0.04),
                                              c(0.1, -0.04, 0.1)))
priorspec &lt;- specify_priors(rho = sv_beta(4, 4),
                            latent0_variance = sv_constant(1),
                            beta = prior_beta,
                            nu = sv_exponential(0.05))
startpara &lt;- list(list(mu = -9, phi = 0.3),
                  list(mu = -11, sigma = 0.1, phi = 0.95),
                  list(phi = 0.99))
roll &lt;- svsample_roll(sim, draws = 5000, burnin = 2000,
                      designmatrix = "ar2",
                      priorspec = priorspec,
                      startpara = startpara,
                      parallel = "snow", n_cpus = 2,
                      n_chains = 3,
                      keep_draws = TRUE,
                      forecast_length = 10,
                      n_ahead = 1, refit_every = 1,
                      refit_window = "expanding",
                      calculate_predictive_likelihood = TRUE,
                      calculate_quantile = c(0.01, 0.05))

</code></pre>


</div>