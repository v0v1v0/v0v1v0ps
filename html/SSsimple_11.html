<div class="container">

<table style="width: 100%;"><tr>
<td>SS.solve.SMW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimal Estimation
</h2>

<h3>Description</h3>

<p>Solve a state space system using the Kalman Filter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SS.solve.SMW(Z, F, H, Q, inv.R, length.out, P0, beta0=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>

<p>A <em>T</em> x <em>n</em> data matrix. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F</code></td>
<td>

<p>The state matrix.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>F</code> is constant diagonal.  When a vector, <code>F</code> is diagonal.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>

<p>The measurement matrix.  Must be <em>n</em> x <em>d</em>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>The state variance.  A scalar, or vector of length <em>d</em>, or a <em>d</em> x <em>d</em> matrix.  When scalar, <code>Q</code> is constant diagonal.  When a vector, <code>Q</code> is diagonal.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.R</code></td>
<td>

<p>The inverse of the measurement variance.  A scalar, or vector of length <em>n</em>, or a <em>n</em> x <em>n</em> matrix.  When scalar, <code>inv.R</code> is constant diagonal.  When a vector, <code>inv.R</code> is diagonal.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.out</code></td>
<td>

<p>Scalar integer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P0</code></td>
<td>

<p>Initial <em>a priori</em> prediction error.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>

<p>Initial state value.  A scalar, or a vector of length <em>d</em>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>H</code> is the master argument from which system dimensionality is determined.  Otherwise identical to <code>SS.solve</code>, except that the Woodbury identity is used for inversion.  This method offers a computationally reduced means of solving the system realization of interest; however, this method must be supplied with the inverse of the measurement variance matrix, R â€“ not R.
</p>


<h3>Value</h3>

<p>A named list.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>B.apri</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate prior to observing data at time <em>i</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.apos</code></td>
<td>
<p>A <em>T</em> x <em>d</em> matrix, the <em>i</em>th row of which is the best state estimate given the observation at time <em>i</em>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For a definition of the system of interest, please see <code>SSsimple</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(999)
H &lt;- matrix(1)
R &lt;- 7
inv.R &lt;- 1 / R
x &lt;- SS.sim( 1, H, 1, R, 100, 0 )
y &lt;- SS.solve.SMW( x$Z, 1, H, 1, inv.R, 100, 10^5, 0 )

z.hat &lt;- t( H %*% t( y$B.apri ) )

plot( x$Z, type="l", col="blue" )
points( z.hat[ ,1], type="l", col="red" )
</code></pre>


</div>