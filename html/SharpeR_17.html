<div class="container">

<table style="width: 100%;"><tr>
<td>confint.sr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confidence Interval on (optimal) Signal-Noise Ratio</h2>

<h3>Description</h3>

<p>Computes approximate confidence intervals on the (optimal) Signal-Noise ratio 
given the (optimal) Sharpe ratio.
Works on objects of class <code>sr</code> and <code>sropt</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sr'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  type = c("exact", "t", "Z", "Mertens", "Bao"),
  ...
)

## S3 method for class 'sropt'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  ...
)

## S3 method for class 'del_sropt'
confint(
  object,
  parm,
  level = 0.95,
  level.lo = (1 - level)/2,
  level.hi = 1 - level.lo,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an observed Sharpe ratio statistic, of class <code>sr</code> or
<code>sropt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>ignored here, but required for the general method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.lo</code></td>
<td>
<p>the lower confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.hi</code></td>
<td>
<p>the upper confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>which method to apply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Constructs confidence intervals on the Signal-Noise ratio given observed
Sharpe ratio statistic. The available methods are:
</p>

<dl>
<dt>exact</dt>
<dd>
<p>The default, which is only exact when returns are
normal, based on inverting the non-central t distribution.</p>
</dd>
<dt>t</dt>
<dd>
<p>Uses the Johnson Welch approximation to the standard error, centered around
the sample value.</p>
</dd>
<dt>Z</dt>
<dd>
<p>Uses the Johnson Welch approximation to the standard error,
performing a simple correction for the bias of the Sharpe ratio based on 
Miller and Gehr formula.</p>
</dd>
<dt>Mertens</dt>
<dd>
<p>Uses the Mertens higher order approximation to the standard
error, centered around the sample value.</p>
</dd>
<dt>Bao</dt>
<dd>
<p>Uses the Bao higher order approximation to the standard error,
performing a higher order correction for the bias of the Sharpe ratio.</p>
</dd>
</dl>
<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). 
Let 
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}}</code>
</p>

<p>Given observations of <code class="reqn">z_*</code>, compute confidence intervals on the
population analogue, defined as
</p>
<p style="text-align: center;"><code class="reqn">\zeta_* = \sqrt{\mu^{\top} \Sigma^{-1} \mu}</code>
</p>



<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper
confidence limits for the parameter. These will be labelled as
level.lo and level.hi in %, <em>e.g.</em> <code>"2.5 %"</code>
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. "Mutual fund performance." Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>


<h3>See Also</h3>

<p><code>confint</code>, <code>se</code>, <code>predint</code>
</p>
<p>Other sr: 
<code>as.sr()</code>,
<code>dsr()</code>,
<code>is.sr()</code>,
<code>plambdap()</code>,
<code>power.sr_test()</code>,
<code>predint()</code>,
<code>print.sr()</code>,
<code>reannualize()</code>,
<code>se()</code>,
<code>sr_equality_test()</code>,
<code>sr_test()</code>,
<code>sr_unpaired_test()</code>,
<code>sr_vcov()</code>,
<code>sr</code>,
<code>summary.sr</code>
</p>
<p>Other sropt: 
<code>as.sropt()</code>,
<code>dsropt()</code>,
<code>is.sropt()</code>,
<code>pco_sropt()</code>,
<code>power.sropt_test()</code>,
<code>reannualize()</code>,
<code>sropt_test()</code>,
<code>sropt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# using "sr" class:
ope &lt;- 253
df &lt;- ope * 6
xv &lt;- rnorm(df, 1 / sqrt(ope))
mysr &lt;- as.sr(xv,ope=ope)
confint(mysr,level=0.90)
# using "lm" class
yv &lt;- xv + rnorm(length(xv))
amod &lt;- lm(yv ~ xv)
mysr &lt;- as.sr(amod,ope=ope)
confint(mysr,level.lo=0.05,level.hi=1.0)
# rolling your own.
ope &lt;- 253
df &lt;- ope * 6
zeta &lt;- 1.0
rvs &lt;- rsr(128, df, zeta, ope)
roll.own &lt;- sr(sr=rvs,df=df,c0=0,ope=ope)
aci &lt;- confint(roll.own,level=0.95)
coverage &lt;- 1 - mean((zeta &lt; aci[,1]) | (aci[,2] &lt; zeta))
# using "sropt" class
ope &lt;- 253
df1 &lt;- 4
df2 &lt;- ope * 3
rvs &lt;- as.matrix(rnorm(df1*df2),ncol=df1)
sro &lt;- as.sropt(rvs,ope=ope)
aci &lt;- confint(sro)
# on sropt, rolling your own.
zeta.s &lt;- 1.0
rvs &lt;- rsropt(128, df1, df2, zeta.s, ope)
roll.own &lt;- sropt(z.s=rvs,df1,df2,drag=0,ope=ope)
aci &lt;- confint(roll.own,level=0.95)
coverage &lt;- 1 - mean((zeta.s &lt; aci[,1]) | (aci[,2] &lt; zeta.s))
# using "del_sropt" class
nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
# hedge out the first one:
G &lt;- matrix(diag(nfac)[1,],nrow=1)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
aci &lt;- confint(asro,level=0.95)
# under the alternative
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.001,sd=0.0125),ncol=nfac)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
aci &lt;- confint(asro,level=0.95)

</code></pre>


</div>