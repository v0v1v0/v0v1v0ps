<div class="container">

<table style="width: 100%;"><tr>
<td>t_list</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transpose a List</h2>

<h3>Description</h3>

<p><code>t_list</code> transposes a list, similar to what <code>t.default</code> does for matrices.
<code>t_list</code> assumes the structure of each <code>x</code> element is the same. Tests
are done to ensure the lengths and names are the same for each <code>x</code> element.
The returned list has list elements in the same order as in <code>x[[1]]</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">t_list(x, rtn.atomic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>list where each element has the same structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtn.atomic</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned list
should be a list of atomic vectors (TRUE) rather than a list of lists (FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If any element within <code>x</code> has no names (NULL), then the transposition is
done based on positions. If all element within <code>x</code> have the same names,
then the transposition is done based on those names.
</p>


<h3>Value</h3>

<p>list where each element is from those in <code>x[[1]]</code> and each element
of the returned object has a subelement for each element in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# modeling example
iris_bySpecies &lt;- split(x = iris, f = iris$"Species")
lmObj_bySpecies &lt;- lapply(X = iris_bySpecies, FUN = function(dat) {
   lm(Sepal.Length ~ Petal.Width, data = dat)})
lmEl_bySpecies &lt;- t_list(lmObj_bySpecies)
summary(lmObj_bySpecies); summary(lmEl_bySpecies)
summary.default(lmEl_bySpecies[[1]]); summary.default(lmEl_bySpecies[[2]])

# no names
lmObj_bySpecies2 &lt;- unname(lapply(X = lmObj_bySpecies, FUN = unname))
lmEl_bySpecies2 &lt;- t_list(lmObj_bySpecies2)
summary(lmObj_bySpecies2); summary(lmEl_bySpecies2)
summary.default(lmEl_bySpecies2[[1]]); summary.default(lmEl_bySpecies2[[2]])
all(unlist(Map(name = lmEl_bySpecies, nameless = lmEl_bySpecies2,
   f = function(name, nameless) all.equal(unname(name), nameless)))) # is everything
   # but the names the same?

# atomic vector example
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3),"B" = c("a"=1,"b"=2,"c"=3),
   "C" = c("a"=1,"b"=2,"c"=3))
t_list(x, rtn.atomic = TRUE)

# names in different positions
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3),"B" = c("b"=2,"a"=1,"c"=3),
   "C" = c("c"=3,"b"=2,"a"=1))
t_list(x, rtn.atomic = TRUE)

# no names
x &lt;- list(c(1,2,3), c(1,2,3), c(1,2,3))
t_list(x, rtn.atomic = TRUE)

# lists with a single element
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3))
t_list(lmObj_bySpecies[1])
</code></pre>


</div>