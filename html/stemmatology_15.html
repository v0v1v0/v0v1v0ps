<div class="container">

<table style="width: 100%;"><tr>
<td>PCC.equipollent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
PCC Exploratory Methods: Extracting Competing Genealogies
</h2>

<h3>Description</h3>

<p>A single table of variant locations can sometimes 
reflect different competing genealogies, due to contamination, either for a single manuscript, or for the whole tradition. <code>PCC.equipollent</code> identifies the variant locations without internal conflicts, and allows to create separate databases for each internally consistent configuration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PCC.equipollent(x, ask = TRUE, scope = NULL, wits = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A <code>PCC.conflicts</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>

<p>logical; if <code>FALSE</code>, decisions will be made without asking the user for input.
Default: <code>TRUE</code>. With <code>FALSE</code>, it is mandatory to specify <code>scope</code> 
and <code>wits</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scope</code></td>
<td>
<p>should the inconsistent variant locations be neutralised for the
whole tradition (<code>"T"</code>) or only some witnesses (<code>"W"</code>)?
Use only with <code>ask = FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wits</code></td>
<td>
<p>a vector containing the names of the witnesses for which 
inconsistent variant locations should be neutralised.
Use only with <code>ask = FALSE</code> and <code>scope = 'W'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical; if <code>FALSE</code>, the function will only return the results, without information on the operations.
Default: <code>FALSE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Some over-conflicting variant locations can be algorithmically ruled out for the building of a stemma (see <code>PCC.conflicts</code>, <code>PCC.overconflicting</code> and <code>PCC.elimination</code>). Yet, in some cases, choosing between conflicting variables is algorithmically undecidable.
This might be due sometimes to contamination (see <code>PCC.contam</code>). <code>PCC.equipollent</code> helps addressing such cases. 
It tries to assess, first, the sets of variant locations that are internally consistent (no conflict among themselves), and then, creates as many different databases as sets were found. In creating these new databases, the variant location that have conflicting information with the current set are either fully neutralised (<code>scope = "T"</code>) or neutralised only for some witnesses (<code>scope = "W"</code>).
</p>


<h3>Value</h3>

<p>An object of class pccEquipollent, a list containing
</p>
<table>
<tr style="vertical-align: top;">
<td><code>databases</code></td>
<td>
<p>a list with all alternative databases that have been created, if any</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notInConflict</code></td>
<td>
<p>a list with the set(s) of VL without internal conflicts</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>This function is still experimental, and will work optimally only for simple cases, where competing genealogies can be easily identified.
</p>


<h3>Author(s)</h3>

<p>Jean-Baptiste Camps &amp; Florian Cafiero
</p>


<h3>References</h3>

<p>Camps, Jean-Baptiste, and Florian Cafiero. ‘Stemmatology: An R Package for the Computer-Assisted Analysis of Textual Traditions’. <em>Proceedings of the Second Workshop on Corpus-Based Research in the Humanities (CRH-2)</em>, edited by Andrew U. Frank et al., 2018, pp. 65–74, <a href="https://halshs.archives-ouvertes.fr/hal-01695903v1">https://halshs.archives-ouvertes.fr/hal-01695903v1</a>.
</p>
<p>Camps, Jean-Baptiste. ‘Detecting Contaminations in Textual Traditions
Computer Assisted and Traditional Methods’.  Leeds, International Medieval Congress, 2013, unpublished paper, <a href="https://www.academia.edu/3825633/Detecting_Contaminations_in_Textual_Traditions_Computer_Assisted_and_Traditional_Methods">https://www.academia.edu/3825633/Detecting_Contaminations_in_Textual_Traditions_Computer_Assisted_and_Traditional_Methods</a>.
</p>
<p>Camps, Jean-Baptiste, and Florian Cafiero. ‘Genealogical Variant Locations and Simplified Stemma: A Test Case’. <em>Analysis of Ancient and Medieval Texts and Manuscripts: Digital Approaches</em>, edited by Tara Andrews and Caroline Macé, Brepols, 2015, pp. 69–93, <a href="https://halshs.archives-ouvertes.fr/halshs-01435633">https://halshs.archives-ouvertes.fr/halshs-01435633</a>, DOI: <a href="http://dx.doi.org/10.1484/M.LECTIO-EB.5.102565">10.1484/M.LECTIO-EB.5.102565</a>.
</p>


<h3>See Also</h3>

<p><code>PCC.Exploratory</code>, <code>PCC.conflicts</code>, <code>PCC.overconflicting</code>, <code>PCC.elimination</code>, <code>PCC.contam</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load data
data("fournival")

# look for conflicts
y = PCC.conflicts(fournival)
# identify and eliminate overconflicting VL
y = PCC.overconflicting(y, ask = FALSE, threshold = 0.06)
y = PCC.elimination(y)
# look for further conflicts
y = PCC.conflicts(y)


# and now, create configurations for competing genealogies
# for instance, for one witness
newDB = PCC.equipollent(y, ask = FALSE, scope = "W", wits = "D")

# Alternatively, you can create them for the whole tradition
newDB = PCC.equipollent(y, ask = FALSE, scope = "T")
# or for several witnesses
newDB = PCC.equipollent(y, ask = FALSE, scope = "W", wits = c("A", "D"))

# and then you proceed to create one or several stemmata, e.g.
# PCC.Stemma(newDB$databases[[1]], ask = FALSE)
</code></pre>


</div>