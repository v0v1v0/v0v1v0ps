<div class="container">

<table style="width: 100%;"><tr>
<td>get_index_sims</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate a population index via simulation from the joint precision matrix</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Calculate a population index via simulation from the joint precision matrix.
Compared to <code>get_index()</code>, this version can be faster if bias correction was
turned on in <code>get_index()</code> while being approximately equivalent. <strong>This is an
experimental function.</strong> This function usually works reasonably well, but we
make no guarantees. It is recommended to use <code>get_index()</code> with <code>bias_correct = TRUE</code> for final inference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_index_sims(
  obj,
  level = 0.95,
  return_sims = FALSE,
  area = rep(1, nrow(obj)),
  est_function = stats::median,
  area_function = function(x, area) x + log(area),
  agg_function = function(x) sum(exp(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p><code>predict.sdmTMB()</code> output with <code>nsim &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The confidence level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_sims</code></td>
<td>
<p>Logical. Return simulation draws? The default (<code>FALSE</code>) is
a quantile summary of those simulation draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area</code></td>
<td>
<p>A vector of grid cell/polyon areas for each year-grid cell (row
of data) in <code>obj</code>. Adjust this if cells are not of unit area or not all
the same area (e.g., some cells are partially over land/water). Note that
the area vector is added as <code>log(area)</code> to the raw values in <code>obj</code>. In
other words, the function assumes a log link, which typically makes sense.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_function</code></td>
<td>
<p>Function to summarize the estimate (the expected value).
<code>mean()</code> would be an alternative to <code>median()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area_function</code></td>
<td>
<p>Function to apply area weighting.
Assuming a log link, the <code>function(x, area) x + log(area)</code> default makes sense.
If in natural space, <code>function(x, area) x * area</code> makes sense.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agg_function</code></td>
<td>
<p>Function to aggregate samples within each time slice.
Assuming a log link, the <code>function(x) sum(exp(x))</code> default makes sense.
If in natural space, <code>function(x) sum(x)</code> makes sense.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Can also be used to produce an index from a model fit with
<span class="pkg">tmbstan</span>.
</p>
<p>This function does nothing more than summarize and reshape the
matrix of simulation draws into a data frame.
</p>


<h3>Value</h3>

<p>A data frame. If <code>return_sims = FALSE</code>:
</p>

<ul>
<li>
<p> name of column (e.g. <code>year</code>) that was supplied to <code>sdmTMB()</code> time argument
</p>
</li>
<li> <p><code>est</code>: estimate
</p>
</li>
<li> <p><code>lwr</code>: lower confidence interval value
</p>
</li>
<li> <p><code>upr</code>: upper confidence interval value
</p>
</li>
<li> <p><code>log_est</code>: log estimate
</p>
</li>
<li> <p><code>se</code>: standard error on the log estimate
</p>
</li>
</ul>
<p>If <code>return_sims = TRUE</code>, samples from the index values in a long-format data frame:
</p>

<ul>
<li>
<p> name of column (e.g. <code>year</code>) that was supplied to <code>sdmTMB()</code> time argument
</p>
</li>
<li> <p><code>.value</code>: sample value
</p>
</li>
<li> <p><code>.iteration</code>: sample number
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>get_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
m &lt;- sdmTMB(density ~ 0 + as.factor(year),
  data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie(link = "log"),
  time = "year"
)
qcs_grid_2011 &lt;- replicate_df(qcs_grid, "year", unique(pcod_2011$year))
p &lt;- predict(m, newdata = qcs_grid_2011, nsim = 100)
x &lt;- get_index_sims(p)
x_sims &lt;- get_index_sims(p, return_sims = TRUE)

if (require("ggplot2", quietly = TRUE)) {
  ggplot(x, aes(year, est, ymin = lwr, ymax = upr)) +
    geom_line() +
    geom_ribbon(alpha = 0.4)
  ggplot(x_sims, aes(as.factor(year), .value)) +
    geom_violin()
}

# Demo custom functions if working in natural space:
ind &lt;- get_index_sims(
  exp(p),
  agg_function = function(x) sum(x),
  area_function = function(x, area) x * area
)

</code></pre>


</div>