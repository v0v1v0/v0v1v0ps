<div class="container">

<table style="width: 100%;"><tr>
<td>sylcount</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sylcount</h2>

<h3>Description</h3>

<p>A vectorized syllable counter for English language text.
</p>
<p>Because of the R memory allocations required, the operation is not thread
safe.  It is evaluated in serial.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sylcount(s, counts.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>A character vector (vector of strings).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts.only</code></td>
<td>
<p>Should only counts be returned, or words + counts?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The maximum supported word length is 64 characters. For any token having more
than 64 characters, the returned syllable count will be <code>NA</code>.
</p>
<p>The syllable counter uses a hash table of known, mostly "irregular" (with
respect to syllable counting) words.  If the word is not known to us
(i.e., not in the hash table), then we try to "approximate" the number
of syllables by counting the number of non-consecutive vowels in a word.
</p>
<p>So for example, using this scheme, each of "to", "too", and "tool" would be
classified as having one syllable.  However, "tune" would be classified as
having 2.  Fortunately, "tune" is in our table, listed as having 1 syllable.
</p>
<p>The hash table uses a perfect hash generated by gperf.
</p>


<h3>Value</h3>

<p>A list of dataframes.
</p>


<h3>See Also</h3>

<p><code>readability</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sylcount)
a &lt;- "I am the very model of a modern major general."
b &lt;- "I have information vegetable, animal, and mineral."

sylcount(c(a, b))
sylcount(c(a, b), counts.only=FALSE)

</code></pre>


</div>