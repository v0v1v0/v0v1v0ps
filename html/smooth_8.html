<div class="container">

<table style="width: 100%;"><tr>
<td>auto.gum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Automatic GUM</h2>

<h3>Description</h3>

<p>Function selects the order of GUM model based on information criteria,
using fancy branch and bound mechanism.
</p>


<h3>Usage</h3>

<pre><code class="language-R">auto.gum(y, orders = 3, lags = frequency(y), type = c("additive",
  "multiplicative", "select"), initial = c("backcasting", "optimal"),
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("restricted", "admissible", "none"), silent = c("all",
  "graph", "legend", "output", "none"), xreg = NULL, regressors = c("use",
  "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orders</code></td>
<td>
<p>The value of the max order to check. This is the upper bound
of orders, but the real orders could be lower than this because of the
increasing number of parameters in the models with higher orders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>
<p>The value of the maximum lag to check. This should usually be
a maximum frequency of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of model. Can either be <code>"additive"</code> or
<code>"multiplicative"</code>. The latter means that the GUM is fitted on
log-transformed data. If <code>"select"</code>, then this is selected automatically,
which may slow down things twice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li>
</ul>
<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words ("n",
"a", "g", "l", "o").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using es function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other non-documented parameters. For example <code>FI=TRUE</code> will
make the function also produce Fisher Information matrix, which then can be
used to calculated variances of parameters of the model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function checks several GUM models (see gum documentation)
and selects the best one based on the specified information criterion.
</p>
<p>The resulting model can be complicated and not straightforward, because GUM
allows capturing hidden orders that no ARIMA model can. It is advised to use
<code>initial="b"</code>, because optimising GUM of arbitrary order is not a simple
task.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("gum","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class "smooth" is returned. See gum for
details.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li>
<p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li>
</ul>
<ul>
<li>
<p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li>
<p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li>
<p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li>
<p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>gum, es,
ces, sim.es, ssarima</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- rnorm(50,100,3)

# The best GUM model for the data
ourModel &lt;- auto.gum(x,orders=2,lags=4,h=18,holdout=TRUE,interval="np")

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))


</code></pre>


</div>