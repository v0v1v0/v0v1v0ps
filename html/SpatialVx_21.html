<div class="container">

<table style="width: 100%;"><tr>
<td>censqdelta</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Centered on Square Domain Baddeley's Delta Metric
</h2>

<h3>Description</h3>

<p>Baddeley's delta metric is sensitive to the position of non-zero grid points within the domain, as well as to the size of the domain.  In order to obtain consistent values of the metric across cases, it is recommended to first position the sets to be compared so that they are centered with respect to one another on a square domain; where the square domain is the same for all comparison sets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">censqdelta(x, y, N, const = Inf, p = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p> Matrices representing binary images to be compared.  If they are not binary, then they will be forced to binary by setting anything above zero to one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>

<p>The size of the square domain.  If missing, it will be the size of the largest side, and if it is even, one will be added to it.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p> single numeric giving the <code>c</code> argument to <code>deltametric</code>, which is the constant value over which the distance map is reduced to this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p> single numeric giving the <code>p</code> argument to <code>deltametric</code>, which specifies the type of Lp norm used to calculate the delta maetric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Not used.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Baddeley's delta metric (Baddeley, 1992a,b) is the L_p norm over the absolute difference of distance maps for two binary images, A and B.  A concave function (e.g., f(t) = min(t, constant)) may first be applied ot each distance map before taking their absolute differences, which makes the result less sensitive to small changes in one or both images than other similar metrics.  The metric is sensitive to size, shape and location differences, which make it very practical for comparing forecasts to observations in terms of the position, area extent, and area shape  errors.  However, its sensitivity to domain size and position within the domain are undesirable, but are easily fixed by calculating the metric over a consistent, square domain with the combined verification set centerd on that domain.  See the example section below to see the issue.
</p>
<p>This function essentially takes a window of size N by N and moves so that the centroid of each pair of sets, A and B, is the center of the window before calculating the metric.
</p>
<p>Centering and squaring is recommended for carrying out a procedure such as that proposed in Gilleland et al. (2008).  Centering on a square domain alleviates the problems discovered by Schwedler and Baldwin (2011) who suggested using a small value of the constant in f(t) = min(t, constant) applied to the distance maps.  This solution is not very appealing because of the sensitivity in choice of the constant that generally diminishes as it approaches the domain size (Gilleland, 2011).
</p>
<p>After centering the sets on a square domain, the function <code>deltametric</code> from package <span class="pkg">spatstat</span> is used to calculate the metric.
</p>


<h3>Value</h3>

<p>A single numeric value is returned.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Baddeley, A. (1992a)  An error metric for binary images.  In <em>Robust Computer Vision Algorithms</em>, W. Forstner and S. Ruwiedel, Eds., Wichmann, 59–78.
</p>
<p>Baddeley, A. (1992b)  Errors in binary images and an Lp version of the Hausdorff metric.  <em>Nieuw Arch. Wiskunde</em>, <b>10</b>, 157–183.
</p>
<p>Gilleland, E. (2011) Spatial Forecast Verification: Baddeley's Delta Metric Applied to the ICP Test Cases. <em>Weather Forecast.</em>, <b>26</b> (3), 409–415.
</p>
<p>Gilleland, E. (2017) A new characterization in the spatial verification framework for false alarms, misses, and overall patterns. <em>Weather Forecast.</em>, <b>32</b> (1), 187–198, DOI: 10.1175/WAF-D-16-0134.1.
</p>
<p>Gilleland, E., Lee, T. C. M.,  Halley Gotway, J., Bullock, R. G. and Brown, B. G. (2008) Computationally efficient spatial forecast verification using Baddeley's delta image metric.  <em>Mon. Wea. Rev.</em>, <b>136</b>, 1747–1757.
</p>
<p>Schwedler, B. R. J. and Baldwin, M. E. (2011) Diagnosing the sensitivity of binary image measures to bias, location, and event frequency within a forecast verification framework. <em>Weather Forecast.</em>, <b>26</b>, 1032–1044.
</p>


<h3>See Also</h3>

<p><code>deltametric</code>, <code>locmeasures2d </code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- y &lt;- matrix( 0, 100, 200 )
x[ 45, 10 ] &lt;- 1
x &lt;- kernel2dsmooth( x, kernel.type = "disk", r = 4 )

y[ 50, 60 ] &lt;- 1
y &lt;- kernel2dsmooth( y, kernel.type = "disk", r = 10 )

censqdelta( x, y )

## Not run: 
# Example form Gilleland (2017).
#
# I1 = circle with radius = 20 centered at 100, 100
# I2 = circle with radius = 20 centered at 140, 100
# I3 = circle with radius = 20 centered at 180, 100
# I4 = circle with radius = 20 centered at 140, 140

I1 &lt;- I2 &lt;- I3 &lt;- I4 &lt;- matrix( 0, 200, 200 )

I1[ 100, 100 ] &lt;- 1
I1 &lt;- kernel2dsmooth( I1, kernel.type = "disk", r = 20 )
I1[ I1 &gt; 0 ] &lt;- 1
if( any( I1 &lt; 0 ) ) I1[ I1 &lt; 0 ] &lt;- 0

I2[ 140, 100 ] &lt;- 1
I2 &lt;- kernel2dsmooth( I2, kernel.type = "disk", r = 20 )
I2[ I2 &gt; 0 ] &lt;- 1
if( any( I2 &lt; 0 ) ) I2[ I2 &lt; 0 ] &lt;- 0

I3[ 180, 100 ] &lt;- 1
I3 &lt;- kernel2dsmooth( I3, kernel.type = "disk", r = 20 )
I3[ I3 &gt; 0 ] &lt;- 1
if( any( I3 &lt; 0 ) ) I3[ I3 &lt; 0 ] &lt;- 0

I4[ 140, 140 ] &lt;- 1
I4 &lt;- kernel2dsmooth( I4, kernel.type = "disk", r = 20 )
I4[ I4 &gt; 0 ] &lt;- 1
if( any( I4 &lt; 0 ) ) I4[ I4 &lt; 0 ] &lt;- 0

image( I1, col = c("white", "darkblue") )
contour( I2, add = TRUE )
contour( I3, add = TRUE )
contour( I4, add = TRUE )

# Each circle is the same size and shape, and the domain is square.
# I1 and I2, I2 and I3, and I2 and I4 are all the same distance
# away from each other.  I1 and I4 and I3 and I4 are also the same distance
# from each other.  I3 touches the edge of the domain.
# 

# First, calculate the Baddeley delta metric on each 
# comparison.

I1im &lt;- as.im( I1 )
I2im &lt;- as.im( I2 )
I3im &lt;- as.im( I3 )
I4im &lt;- as.im( I4 )

I1im &lt;- solutionset( I1im &gt; 0 )
I2im &lt;- solutionset( I2im &gt; 0 )
I3im &lt;- solutionset( I3im &gt; 0 )
I4im &lt;- solutionset( I4im &gt; 0 )

deltametric( I1im, I2im )
deltametric( I2im, I3im )
deltametric( I2im, I4im )

# Above are all different values.
# Below, they are all 28.84478.
censqdelta( I1, I2 )
censqdelta( I2, I3 )
censqdelta( I2, I4 )

# Similarly for I1 and I4 vs I3 and I4.
deltametric( I1im, I4im )
deltametric( I3im, I4im )

censqdelta( I1, I4 )
censqdelta( I3, I4 )

# To see why this problem exists.
dm1 &lt;- distmap( I1im )
dm1 &lt;- as.matrix( dm1 )
dm2 &lt;- distmap( I2im )
dm2 &lt;- as.matrix( dm2 )

par( mfrow = c( 2, 2 ) )
image.plot( dm1 )
contour( I1, add = TRUE, col = "white" )
image.plot( dm2 )
contour( I2, add = TRUE, col = "white" )

image.plot( abs( dm1 ) - abs( dm2 ) )
contour( I1, add = TRUE, col = "white" )
contour( I2, add = TRUE, col = "white" )


## End(Not run)

</code></pre>


</div>