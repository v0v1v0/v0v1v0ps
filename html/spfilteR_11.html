<div class="container">

<table style="width: 100%;"><tr>
<td>MI.vec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local Moran Coefficient</h2>

<h3>Description</h3>

<p>Reports the local Moran Coefficient for each unit.
</p>
<p>Tests for the presence of spatial autocorrelation
in variables as indicated by the Moran coefficient. The variance
is calculated under the normality assumption.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MI.local(x, W, alternative = "greater")

MI.vec(x, W, alternative = "greater", symmetrize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector or matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>specification of alternative hypothesis as 'greater' (default),
'lower', or 'two.sided'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetrize</code></td>
<td>
<p>symmetrizes the connectivity matrix <em><strong>W</strong></em>
by: 1/2 * (<em><strong>W</strong></em> + <em><strong>W</strong></em>') (TRUE/ FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>x</code> is a matrix, this function computes the Moran
test for spatial autocorrelation for each column.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>data.frame</code> that contains the
following information for each variable:
</p>

<dl>
<dt><code>Ii</code></dt>
<dd>
<p>observed value of local Moran's I</p>
</dd>
<dt><code>EIi</code></dt>
<dd>
<p>expected value of local Moran coefficients</p>
</dd>
<dt><code>VarIi</code></dt>
<dd>
<p>variance of local Moran's I</p>
</dd>
<dt><code>zIi</code></dt>
<dd>
<p>standardized local Moran coefficient</p>
</dd>
<dt><code>pIi</code></dt>
<dd>
<p><em>p</em>-value of the test statistic</p>
</dd>
</dl>
<p>Returns an object of class <code>data.frame</code> that contains the
following information for each variable:
</p>

<dl>
<dt><code>I</code></dt>
<dd>
<p>observed value of the Moran coefficient</p>
</dd>
<dt><code>EI</code></dt>
<dd>
<p>expected value of Moran's I</p>
</dd>
<dt><code>VarI</code></dt>
<dd>
<p>variance of Moran's I (under normality)</p>
</dd>
<dt><code>zI</code></dt>
<dd>
<p>standardized Moran coefficient</p>
</dd>
<dt><code>pI</code></dt>
<dd>
<p><em>p</em>-value of the test statistic</p>
</dd>
</dl>
<h3>Note</h3>

<p>The calculation of the statistic and its moments follows
Anselin (1995) and Sokal et al. (1998).
</p>
<p>Estimation of the variance (under the normality assumption)
follows Cliff and Ord (1981), see also Upton and Fingleton (1985).
It assumes the connectivity matrix <em><strong>W</strong></em> to be symmetric.
For inherently non-symmetric matrices, it is recommended to specify
<code>symmetrize=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Anselin, Luc (1991): Local Indicators of Spatial
Association-LISA. Geographical Analysis, 27 (2): pp. 93 - 115.
</p>
<p>Bivand, Roger S. and David W. S. Wong (2018): Comparing Implementations
of Global and Local Indicators of Spatial Association. TEST, 27:
pp. 716 - 748.
</p>
<p>Sokal, Robert R., Neal L. Oden, Barbara A. Thomson (1998): Local
Spatial Autocorrelation in a Biological Model. Geographical Analysis,
30 (4): pp. 331 - 354.
</p>
<p>Cliff, Andrew D. and John K. Ord (1981): Spatial Processes:
Models &amp; Applications. Pion, London.
</p>
<p>Upton, Graham J. G. and Bernard Fingleton (1985): Spatial Data Analysis
by Example, Volume 1. New York, Wiley.
</p>
<p>Bivand, Roger S. and David W. S. Wong (2018): Comparing Implementations
of Global and Local Indicators of Spatial Association. TEST 27:
pp. 716 - 748.
</p>


<h3>See Also</h3>

<p><code>MI.vec</code>, <code>MI.ev</code>, <code>MI.sf</code>,
<code>MI.resid</code>, <code>MI.decomp</code>
</p>
<p><code>MI.resid</code>, <code>MI.local</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(fakedata)
x &lt;- fakedataset$x2

(MIi &lt;- MI.local(x = x, W = W, alternative = "greater"))

data(fakedata)
X &lt;- cbind(fakedataset$x1, fakedataset$x2, fakedataset$x3)

(MI &lt;- MI.vec(x = X, W = W, alternative = "greater", symmetrize = TRUE))

</code></pre>


</div>