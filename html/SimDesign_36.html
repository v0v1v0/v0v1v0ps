<div class="container">

<table style="width: 100%;"><tr>
<td>RobbinsMonro</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robbins-Monro (1951) stochastic root-finding algorithm</h2>

<h3>Description</h3>

<p>Function performs stochastic root solving for the provided <code>f(x)</code>
using the Robbins-Monro (1951) algorithm. Differs from deterministic
cousins such as <code>uniroot</code> in that <code>f</code> may contain stochastic error
components, where the root is obtained through the running average method
provided by noise filter (see also <code>PBA</code>).
Assumes that <code>E[f(x)]</code> is non-decreasing in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RobbinsMonro(
  f,
  p,
  ...,
  Polyak_Juditsky = FALSE,
  maxiter = 500L,
  miniter = 100L,
  k = 3L,
  tol = 1e-05,
  verbose = TRUE,
  fn.a = function(iter, a = 1, b = 1/2, c = 0, ...) a/(iter + c)^b
)

## S3 method for class 'RM'
print(x, ...)

## S3 method for class 'RM'
plot(x, par = 1, main = NULL, Polyak_Juditsky = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>noisy function for which the root is sought</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of starting values to be passed as <code>f(p, ...)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named arguments to be passed to <code>f</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Polyak_Juditsky</code></td>
<td>
<p>logical; apply the Polyak and Juditsky (1992)
running-average method? Returns the final running average estimate
using the Robbins-Monro  updates (also applies to <code>plot</code>).
Note that this should only be
used when the step-sizes are sufficiently large so that the Robbins-Monro
have the ability to stochastically explore around the root (not just
approach it from one side, which occurs when using small steps)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations (default 500)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miniter</code></td>
<td>
<p>minimum number of iterations (default 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of consecutive <code>tol</code> criteria required before terminating</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance criteria for convergence on the changes in the
updated <code>p</code> elements. Must be achieved on <code>k</code> (default 3)
successive occasions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; should the iterations and estimate be printed to the
console?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn.a</code></td>
<td>
<p>function to create the <code>a</code> coefficient in the Robbins-Monro
noise filter. Requires the first argument is the current iteration (<code>iter</code>),
provide one or more arguments, and (optionally) the <code>...</code>. Sequence function
is of the form recommended by Spall (2000).
</p>
<p>Note that if a different function is provided it must satisfy the property
that <code class="reqn">\sum^\infty_{i=1} a_i = \infty</code> and
<code class="reqn">\sum^\infty_{i=1} a_i^2 &lt; \infty</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>RM</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>which parameter in the original vector <code>p</code> to include in the plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>plot title</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Polyak, B. T. and Juditsky, A. B. (1992). Acceleration of Stochastic
Approximation by Averaging. SIAM Journal on Control and Optimization,
30(4):838.
</p>
<p>Robbins, H. and Monro, S. (1951). A stochastic approximation method.
Ann.Math.Statistics, 22:400-407.
</p>
<p>Spall, J.C. (2000). Adaptive stochastic approximation by the simultaneous
perturbation method. IEEE Trans. Autom. Control 45, 1839-1853.
</p>


<h3>See Also</h3>

<p><code>uniroot</code>, <code>PBA</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# find x that solves f(x) - b = 0 for the following
f.root &lt;- function(x, b = .6) 1 / (1 + exp(-x)) - b
f.root(.3)

xs &lt;- seq(-3,3, length.out=1000)
plot(xs, f.root(xs), type = 'l', ylab = "f(x)", xlab='x')
abline(h=0, col='red')

retuni &lt;- uniroot(f.root, c(0,1))
retuni
abline(v=retuni$root, col='blue', lty=2)

# Robbins-Monro without noisy root, start with p=.9
retrm &lt;- RobbinsMonro(f.root, .9)
retrm
plot(retrm)

# Same problem, however root function is now noisy. Hence, need to solve
#  fhat(x) - b + e = 0, where E(e) = 0
f.root_noisy &lt;- function(x) 1 / (1 + exp(-x)) - .6 + rnorm(1, sd=.02)
sapply(rep(.3, 10), f.root_noisy)

# uniroot "converges" unreliably
set.seed(123)
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root

# Robbins-Monro provides better convergence
retrm.noise &lt;- RobbinsMonro(f.root_noisy, .9)
retrm.noise
plot(retrm.noise)

# different power (b) for fn.a()
retrm.b2 &lt;- RobbinsMonro(f.root_noisy, .9, b = .01)
retrm.b2
plot(retrm.b2)

# use Polyak-Juditsky averaging (b should be closer to 0 to work well)
retrm.PJ &lt;- RobbinsMonro(f.root_noisy, .9, b = .01,
                         Polyak_Juditsky = TRUE)
retrm.PJ   # final Polyak_Juditsky estimate
plot(retrm.PJ) # Robbins-Monro history
plot(retrm.PJ, Polyak_Juditsky = TRUE) # Polyak_Juditsky history

</code></pre>


</div>