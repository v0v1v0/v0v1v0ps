<div class="container">

<table style="width: 100%;"><tr>
<td>cov_kernel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel estimation: bootstrap method</h2>

<h3>Description</h3>

<p>This method estimates the spectral density and the autocovariances of the error process via a lag-window
(or kernel) estimator (see P.J. Brockwell and R.A. Davis (1991). Time Series: Theory and Methods. <em>Springer Science &amp; Business Media</em>,
page 330). The weights are computed according to a kernel <code class="reqn">K</code> and a bandwidth <code class="reqn">h</code> (or a lag),
to be chosen by the user. The lag can be computed automatically by using a bootstrap technique (as in Wu and Pourahmadi (2009)), via the <code>Rboot</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cov_kernel(epsilon, model_selec = -1,
 model_max = min(50,length(epsilon)/2), kernel_fonc = triangle,
 block_size = length(epsilon)/2, block_n = 100, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_selec</code></td>
<td>
<p>integer or <code>-1</code>. The order of the method. If <code>model_selec = -1</code>, the method chooses
the treshold automatically. If <code>model_selec = k</code>, then only <code>k</code> autocovariance terms are kept
and smoothed by the kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_max</code></td>
<td>
<p>integer. The maximal order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_fonc</code></td>
<td>
<p>function. Defines the kernel to use in the method. The user can give his own kernel function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block_size</code></td>
<td>
<p>integer. If <code>model_selec = -1</code>, it specifies the size of the bootstrap blocks. <code>block_size</code> must be greater than <code>model_max</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block_n</code></td>
<td>
<p>integer. If <code>model_selec = -1</code>, blocks number to use for the bootstrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code>, the risk curve is returned and the
ACF of the process.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The method returns the tapered autocovariance vector with <code>model_selec</code> autocovariance terms.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model_selec</code></td>
<td>
<p>the number of selected autocovariance terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_st</code></td>
<td>
<p>the estimated autocovariances.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>W.B. Wu, M. Pourahmadi (2009). Banding sample autocovariance matrices of stationary processes. <em>Statistica Sinica</em>, pp. 1755â€“1768.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x = arima.sim(list(ar=c(0.7)),1000)
cov_kernel(x, model_selec = -1, block_n = 10, plot = TRUE)
</code></pre>


</div>