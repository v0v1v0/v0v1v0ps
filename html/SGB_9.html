<div class="container">

<table style="width: 100%;"><tr>
<td>covest.SGB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Classical and robust asymptotic covariance matrix
</h2>

<h3>Description</h3>

<p>Computation of two covariance matrices of the estimators of parameters in a SGB regression. The first is based on the Hessian and the second is the sandwich estimator.
</p>


<h3>Usage</h3>

<pre><code class="language-R">covest.SGB(x, d, u, V, weight=rep(1,dim(d)[1]), x0 = NULL, hessian = NULL, ind = NULL, 
    shape1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>vector of parameters (shape1,coefi,shape2) where
shape1 is the overall shape, coefi is the vector of regression coefficients (see <code>initpar.SGB</code>) and shape2 the vector of the <code class="reqn">D</code> Dirichlet shape parameters; <code class="reqn">D</code>: number of parts.
shape1 and shape2 must be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>data matrix of explanatory variables (with constant vector if required in the model) <code class="reqn">(n \times m)</code>; <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>data matrix of compositions (variables to be explained) <code class="reqn">n \times D</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>

<p>full rank transformation of log(parts) into log-ratios, matrix <code class="reqn">D \times (D-1)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default <code>rep(1,n)</code>. Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>

<p>specification of the initial parameter vector of length <code class="reqn">npar</code> (optional), default: NULL, no specification.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>

<p>Hessian matrix (optional), see <code>regSGB</code>, default: NULL, no specification. In this case the Hessian is computed numerically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>

<p>vector of length equal to the number of fixed parameters; specifies the indices of the fixed components in the vector of parameters <code class="reqn">x</code> (possible for <code>shape1</code> and <code>coefi</code> (regression coefficients) only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape1</code></td>
<td>

<p>fixed value of the overall shape parameter, if <code>heq = heqa.SGB</code> or 
<code>heq = heqab.SGB</code>. Default is 1.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is internally called by regSGB. In this case the Hessian is the output of <code>auglag</code> and is numerically computed. <br>
A design based covariance matrix of the parameters can be obtained by linearization as the covariance matrix of the <code>scores</code>.
</p>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr style="vertical-align: top;">
<td><code>summary </code></td>
<td>
<p>Data frame with <br><code>Initial = x0</code> (if specified), <br><code>Estimate = x</code>, <br><code>StdErr1</code> = ordinary asymptotic standard error of parameters, <br><code>StdErr</code> = robust asymptotic standard error, <br><code>p.value</code> = asymptotic normal p-value based on <code>StdErr</code>. For <code>shape1</code>, <code class="reqn">H_0</code> is "shape1=shape1", or "shape1=1" if <code>shape1=NULL</code>. The other parameters are tested against 0. <br><code>signif</code> = significance code based on p.value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores </code></td>
<td>
<p>matrix <code class="reqn">n \times npar</code>. Each row contains the (unweighted) derivatives of the log-density at a data point w.r.t the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov1</code></td>
<td>
<p>ordinary asymptotic covariance matrix, inverse of minus the Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StdErr1</code></td>
<td>
<p>vector of ordinary asymptotic standard error of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varest2</code></td>
<td>
<p>robust asymptotic covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>StdErr</code></td>
<td>
<p>vector of robust asymptotic standard error of parameters.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Huber, P. J. (1967). The behavior of maximum likelihood estimates under nonstandard conditions. In <em>Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability</em>, Volume 1, pp. 221-233.
</p>


<h3>See Also</h3>

<p><code>regSGB</code> for creating <code>oilr</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(arc)
data(oilr)

## compositions
da &lt;- as.matrix(log(arc[["depth"]]),ncol=1)
ua &lt;- as.matrix(arc[,1:3])

## ilr transforms
 c1 &lt;- 1/sqrt(2)
 c2 &lt;- 1/sqrt(6)
 Vilr &lt;- matrix(c(-c1,c1,0,-c2,-c2,2*c2),nrow=3)
 colnames(Vilr) &lt;- c("ilr1","ilr2")
 Vilr
 
 covs &lt;- covest.SGB(oilr[["par"]], da, ua, Vilr)

## Compare the ordinary and robust correlation matrices of parameters estimates.

## (Ordinary) covariance based on inverse Hessian
vcov1 &lt;- covs[["vcov1"]] 
StdErr1 &lt;- covs[["StdErr1"]]
## Estimated correlation matrix
vcor1 &lt;- diag(1/StdErr1) %*% vcov1 %*% diag(1/StdErr1)
round(vcor1,2)

## Robust (Huber's sandwich estimator):
StdErr &lt;- covs[["StdErr"]]
vcov &lt;- covs[["vcov"]]

## Estimated correlation matrix
round(diag(1/StdErr) %*% vcov %*% diag(1/StdErr),2)

</code></pre>


</div>