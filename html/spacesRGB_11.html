<div class="container">

<table style="width: 100%;"><tr>
<td>TransferFunction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructing and Testing TransferFunction Objects</h2>

<h3>Description</h3>

<p>The function <code>TransferFunction()</code> is the constructor for <b>TransferFunction</b> objects.
</p>
<p><code>is.TransferFunction()</code> tests whether an object is a valid <b>TransferFunction</b> object.<br><code>as.TransferFunction()</code> converts other variables to a <b>TransferFunction</b> object,
and is designed to be overridden by other packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">TransferFunction( fun, funinv, domain, range, id=NULL )

is.TransferFunction(x)

## Default S3 method:
as.TransferFunction( ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function that accepts a numeric argument, and returns one of the same length.
The dimension of <code>fun</code> is determined by the arguments <code>domain</code> and <code>range</code>.
The function must be <em>injective</em> and this is checked if the function is univariate.  
The requirements for univariate and multivariate functions are very different, see <b>Details</b>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funinv</code></td>
<td>
<p>a function that the inverse for <code>fun</code>.
If <code>fun</code> is univariate and <code>funinv=NULL</code>, then an approximation for the inverse is computed
using <code>stats::splinefun()</code>.
If <code>fun</code> is multivariate and <code>funinv=NULL</code>, then it is an ERROR. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>

<p>a 2xN matrix, or a numeric vector that can be converted to such a matrix, by column.
In each column, the entry in row 1 must be strictly less than the entry in row 2.  
The columns of <code>domain</code> define N intervals whose product is a box in <code class="reqn">R^N</code>
that is the domain of <code>fun</code>.
The box must be finite.
If N=1 then the box is just an interval, and <code>fun</code> is univariate.
Otherwise, <code>fun</code> is multivariate with dimension N.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>

<p>a 2xN matrix, or a numeric vector that can be converted to such a matrix, by column.
The N here must be equal to the N for <code>domain</code>.
The matrix defines a box that encloses the image of <code>domain</code> under <code>fun</code>.
The box must be finite.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>a character string that is helpful when printing the object, and in logging messages.
If <code>id=NULL</code> then an appropriate string is created from the function call.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object to test for being a valid <b>TransferFunction</b> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments for use in other packages.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>fun</code> is univariate, then it must be able to accept a numeric vector of any length,
and apply the function to each number in the vector; i.e. <code>fun</code> must be vectorized.
If a number in the vector is NA, then the function must silently return NA for that number;
usually this is not a problem.
The function is *not* required to test whether the number is in the <code>domain</code> interval;
this is handled by the <code>TransferFunction</code> code.
<br>
If <code>fun</code> is multivariate with dimension N, then it must be able to accept a vector
of length N and return a vector of length N.
It is *not* required to accept an MxN matrix.
It is *not* required to test whether the vector is in the domain box.
<br>
The function <code>funinv</code> has the same requirements as <code>fun</code>.
</p>


<h3>Value</h3>

<p><code>TransferFunction()</code> returns a <b>TransferFunction</b> object, or <code>NULL</code> in case of ERROR.
</p>
<p><code>is.TransferFunction()</code> returns <code>TRUE</code> or <code>FALSE</code>.
It only checks the <code>class</code>, using <code>base::inherits()</code>.
</p>
<p><code>as.TransferFunction.default()</code> issues an ERROR message and returns <code>NULL</code>..
</p>


<h3>See Also</h3>

<p><code>dimension()</code>,
<code>composition()</code>,
<code>is.invertible()</code>,  
<code>metadata()</code>,
<code>inverse()</code>,
<code>transfer()</code>,
<code>orientation()</code>,
<code>validate()</code>,  
<code>print.TransferFunction()</code>,
<code>plot.TransferFunction()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#  make a test TransferFunction

myfun = function(x) {x*x}

test  = TransferFunction( myfun, sqrt, domain=c(0,3), range=c(0,9), id='test.TF' )

#  print it
test
#--------------------   test.TF    ---------------------#
## test.TF is a univariate TransferFunction.
## domain:      [0,3]  (x)
## range:       [0,9]  (y)
## invertible:  Yes
## orientation: preserving
## range-test points = 1300, max(distance)=0.
## validation:  Passed

# and now plot it
plot( test )
</code></pre>


</div>