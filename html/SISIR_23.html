<div class="container">

<table style="width: 100%;"><tr>
<td>sparseSIR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sparse SIR</h2>

<h3>Description</h3>

<p><code>sparseSIR</code> performs the second step of the method (shrinkage of ridge
SIR results
</p>


<h3>Usage</h3>

<pre><code class="language-R">sparseSIR(
  object,
  inter_len,
  adaptive = FALSE,
  sel_prop = 0.05,
  parallel = FALSE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>ridgeRes</code> as obtained from the 
function <code>ridgeSIR</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inter_len</code></td>
<td>
<p>(numeric) vector with interval lengths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>should the function returns the list of strong zeros and non
strong zeros (logical). Default to FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sel_prop</code></td>
<td>
<p>used only when <code>adaptive = TRUE</code>. Fraction of the 
coefficients that will be considered as strong zeros and strong non zeros.
Default to 0.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>whether the computation should be performed in parallel or
not. Logical. Default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>number of cores to use if <code>parallel = TRUE</code>. If left to 
NULL, all available cores minus one are used</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>S3 object of class <code>sparseRes</code>: a list consisting of
</p>

<dl>
<dt><code>sEDR</code></dt>
<dd>
<p> the estimated EDR space (a p x d matrix)</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p> the estimated shrinkage coefficients (a vector having
a length similar to <code>inter_len</code>)</p>
</dd>
<dt><code>quality</code></dt>
<dd>
<p> a vector with various qualities for the model (see
Details)</p>
</dd>
<dt><code>adapt_res</code></dt>
<dd>
<p> if <code>adaptive = TRUE</code>, a list of two vectors: 
</p>

<dl>
<dt><code>nonzeros</code></dt>
<dd>
<p> indexes of variables that are strong non zeros</p>
</dd>
<dt><code>zeros</code></dt>
<dd>
<p> indexes of variables that are strong zeros</p>
</dd>
</dl>
</dd>
<dt><code>parameters</code></dt>
<dd>
<p> a list of hyper-parameters for the method: 
</p>

<dl>
<dt><code>inter_len</code></dt>
<dd>
<p> lengths of intervals</p>
</dd>
<dt><code>sel_prop</code></dt>
<dd>
<p> if <code>adaptive = TRUE</code>, fraction of the 
coefficients which are considered as strong zeros or strong non zeros</p>
</dd>
</dl>
</dd>
<dt><code>rSIR</code></dt>
<dd>
<p> same as the input <code>object</code></p>
</dd>
<dt><code>fit</code></dt>
<dd>
<p> a list for LASSO fit with:
</p>

<dl>
<dt><code>glmnet</code></dt>
<dd>
<p> result of the <code>glmnet</code> 
function</p>
</dd>
<dt><code>lambda</code></dt>
<dd>
<p> value of the best Lasso parameter by CV</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p> exploratory variable values as passed to fit the 
model</p>
</dd>
</dl>
</dd>
</dl>
<p>@details Different quality criteria used to select the best models among a
list of models with different interval definitions. Quality criteria are:
log-likelihood (<code>loglik</code>), cross-validation error as provided by the
function <code>glmnet</code>, two versions of the AIC (<code>AIC</code> 
and <code>AIC2</code>) and of the BIC (<code>BIC</code> and <code>BIC2</code>) in which the 
number of parameters is either the number of non null intervals or the 
number of non null parameters with respect to the original variables.
</p>


<h3>Author(s)</h3>

<p>Victor Picheny, <a href="mailto:victor.picheny@inrae.fr">victor.picheny@inrae.fr</a><br>
Remi Servien, <a href="mailto:remi.servien@inrae.fr">remi.servien@inrae.fr</a><br>
Nathalie Vialaneix, <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Picheny, V., Servien, R., and Villa-Vialaneix, N. (2019) 
Interpretable sparse SIR for digitized functional data. 
<em>Statistics and Computing</em>, <strong>29</strong>(2), 255â€“267.
</p>


<h3>See Also</h3>

<p><code>ridgeSIR</code>, <code>project.sparseRes</code>, 
<code>SISIR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1140)
tsteps &lt;- seq(0, 1, length = 200)
nsim &lt;- 100
simulate_bm &lt;- function() return(c(0, cumsum(rnorm(length(tsteps)-1, sd=1))))
x &lt;- t(replicate(nsim, simulate_bm()))
beta &lt;- cbind(sin(tsteps*3*pi/2), sin(tsteps*5*pi/2))
beta[((tsteps &lt; 0.2) | (tsteps &gt; 0.5)), 1] &lt;- 0
beta[((tsteps &lt; 0.6) | (tsteps &gt; 0.75)), 2] &lt;- 0
y &lt;- log(abs(x %*% beta[ ,1]) + 1) + sqrt(abs(x %*% beta[ ,2]))
y &lt;- y + rnorm(nsim, sd = 0.1)
res_ridge &lt;- ridgeSIR(x, y, H = 10, d = 2, mu2 = 10^8)
res_sparse &lt;- sparseSIR(res_ridge, rep(10, 20))

</code></pre>


</div>