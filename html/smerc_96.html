<div class="container">

<table style="width: 100%;"><tr>
<td>scan.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial Scan Test</h2>

<h3>Description</h3>

<p><code>scan.test</code> performs the original spatial scan test
of Kulldorf (1997) based on a fixed number of cases.
Candidate zones are circular and extend from the observed
region centroids.  The clusters returned are
non-overlapping, ordered from most significant to least
significant.  The first cluster is the most  likely to be
a cluster.  If no significant clusters are found, then
the most likely cluster is returned (along with a
warning).
</p>


<h3>Usage</h3>

<pre><code class="language-R">scan.test(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  longlat = FALSE,
  cl = NULL,
  type = "poisson",
  min.cases = 2,
  simdist = "multinomial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>A cluster object created by <code>makeCluster</code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997) A spatial scan
statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>
<p>Waller, L.A. and Gotway, C.A. (2005). Applied Spatial
Statistics for Public Health Data. Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code>print.smerc_cluster</code>,
<code>summary.smerc_cluster</code>,
<code>plot.smerc_cluster</code>,
<code>scan.stat</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 0,
  alpha = 1, longlat = TRUE
)

# basic plot
plot(out, idx = 1:3)

# better plot
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf),
        col = color.clusters(out, idx = 1:3))
}

## plot output for new york state
# specify desired argument values
mapargs &lt;- list(
  database = "county", region = "new york",
  xlim = range(out$coords[, 1]),
  ylim = range(out$coords[, 2])
)
# only run this example if maps available
if (require("maps", quietly = TRUE)) {
# needed for "state" database (unless you execute library(maps))
data(countyMapEnv, package = "maps")
plot(out, usemap = TRUE, mapargs = mapargs, idx = 1:3)
}
# extract detected clusteers
clusters(out)

# a second example to match the results of Waller and Gotway (2005)
# in chapter 7 of their book (pp. 220-221).
# Note that the 'longitude' and 'latitude' used by them has
# been switched.  When giving their input to SatScan, the coords
# were given in the order 'longitude' and 'latitude'.
# However, the SatScan program takes coordinates in the order
# 'latitude' and 'longitude', so the results are slightly different
# from the example above.
# Note: the correct code below would use cbind(x, y), i.e.,
# cbind(longitude, latitude)
coords &lt;- with(nydf, cbind(y, x))
out2 &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 0,
  alpha = 1, longlat = TRUE
)
# the cases observed for the clusters in Waller and Gotway: 117, 47, 44
# the second set of results match
clusters(out2, idx = 1:3)
</code></pre>


</div>