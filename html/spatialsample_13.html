<div class="container">

<table style="width: 100%;"><tr>
<td>spatial_block_cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial block cross-validation</h2>

<h3>Description</h3>

<p>Block cross-validation splits the area of your data into a number of
grid cells, or "blocks", and then assigns all data into folds based on the
blocks their centroid falls into.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatial_block_cv(
  data,
  method = c("random", "snake", "continuous"),
  v = 10,
  relevant_only = TRUE,
  radius = NULL,
  buffer = NULL,
  ...,
  repeats = 1,
  expand_bbox = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An object of class <code>sf</code> or <code>sfc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used to sample blocks for cross validation folds.
Currently supports <code>"random"</code>, which randomly assigns blocks to folds,
<code>"snake"</code>, which labels the first row of blocks from left to right,
then the next from right to left, and repeats from there,
and <code>"continuous"</code>, which labels each row from left
to right, moving from the bottom row up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>The number of partitions for the resampling. Set to <code>NULL</code> or <code>Inf</code>
for the maximum sensible value (for leave-one-X-out cross-validation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relevant_only</code></td>
<td>
<p>For systematic sampling, should only blocks containing
data be included in fold labeling?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Numeric: points within this distance of the initially-selected
test points will be assigned to the assessment set. If <code>NULL</code>, no radius is
applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p>Numeric: points within this distance of any point in the
test set (after <code>radius</code> is applied) will be assigned to neither the analysis
or assessment set. If <code>NULL</code>, no buffer is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>sf::st_make_grid()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand_bbox</code></td>
<td>
<p>A numeric of length 1, representing a proportion to expand
the bounding box of <code>data</code> by before building a grid. Without this expansion,
grids built from data in geographic coordinates may exclude observations and
grids built from regularly spaced data might have observations fall exactly
on the boundary between folds, duplicating them. In spatialsample &lt; 0.5.0,
this was 0.00001 for data in a geographic CRS and 0 for data in a planar CRS.
In spatialsample &gt;= 0.5.0, this is 0.00001 for all data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The grid blocks can be controlled by passing arguments to
<code>sf::st_make_grid()</code> via <code>...</code>. Some particularly useful arguments include:
</p>

<ul>
<li> <p><code>cellsize</code>: Target cellsize, expressed as the "diameter" (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
</p>
</li>
<li> <p><code>n</code>: The number of grid blocks in the x and y direction (columns, rows).
</p>
</li>
<li> <p><code>square</code>: A logical value indicating whether to create square (<code>TRUE</code>) or
hexagonal (<code>FALSE</code>) cells.
</p>
</li>
</ul>
<p>If both <code>cellsize</code> and <code>n</code> are provided, then the number of blocks requested
by <code>n</code> of sizes specified by <code>cellsize</code> will be returned, likely not
lining up with the bounding box of <code>data</code>. If only <code>cellsize</code>
is provided, this function will return as many blocks of size
<code>cellsize</code> as fit inside the bounding box of <code>data</code>. If only <code>n</code> is provided,
then <code>cellsize</code> will be automatically adjusted to create the requested
number of cells.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>spatial_block_cv</code>,  <code>spatial_rset</code>, <code>rset</code>,
<code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>. The results include a column for the
data split objects and an identification variable <code>id</code>.
</p>


<h3>References</h3>

<p>D. R. Roberts, V. Bahn, S. Ciuti, M. S. Boyce, J. Elith, G. Guillera-Arroita,
S. Hauenstein, J. J. Lahoz-Monfort, B. Schr√∂der, W. Thuiller, D. I. Warton,
B. A. Wintle, F. Hartig, and C. F. Dormann. "Cross-validation strategies for
data with temporal, spatial, hierarchical, or phylogenetic structure," 2016,
Ecography 40(8), pp. 913-929, doi: 10.1111/ecog.02881.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
spatial_block_cv(boston_canopy, v = 3)

</code></pre>


</div>