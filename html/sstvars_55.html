<div class="container">

<table style="width: 100%;"><tr>
<td>in_paramspace</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine whether the parameter vector is in the parameter space</h2>

<h3>Description</h3>

<p><code>in_paramspace</code> checks whether the parameter vector is in the parameter
space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">in_paramspace(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  B_constraints = NULL,
  other_constraints = NULL,
  all_boldA,
  all_Omegas,
  weightpars,
  distpars,
  transition_weights,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li>
<p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li>
<p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>
</li>
<li>
<p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt>
<dd>
<p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu = (\nu_1,...,\nu_M)</code> <code class="reqn">(M \times 1)</code>, <code class="reqn">nu_m &gt; 2</code>.</p>
</dd>
</dl>
</li>
</ul>
<p>For models with...
</p>

<dl>
<dt>
<code>weight_function="relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt>
<code>weight_function="logistic"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>
<code>weight_function="exponential"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt>
<code>weight_function="exogenous"</code>:</dt>
<dd>
<p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt>
<dd>
<p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt>
<code>identification="heteroskedasticity"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints (only for structural models identified by heteroskedasticity):</dt>
<dd>
<p>Replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector
so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt>
<code>"relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt>
<code>"logistic"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt>
<code>"exponential"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt>
<code>"exogenous"</code>:</dt>
<dd>
<p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>
<p>See the vignette for more details about the weight functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt>
<dd>
<p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt>
<dd>
<p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt>
<dd>
<p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt>
<dd>
<p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt>
<dd>
<p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, or <code>"ind_Student"</code>,
where the latest is the Student's <code class="reqn">t</code> distribution with independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt>
<code>"reduced_form"</code>:</dt>
<dd>
<p>Reduced form model.</p>
</dd>
<dt>
<code>"recursive"</code>:</dt>
<dd>
<p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt>
<code>"heteroskedasticity"</code>:</dt>
<dd>
<p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt>
<code>"non-Gaussianity"</code>:</dt>
<dd>
<p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt>
<dd>
<p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt>
<dd>
<p>set to the string "fixed_sign_and_order"
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> "bold A" (companion form) matrices of each regime,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_Omegas</code></td>
<td>
<p>A 3D array containing the covariance matrix parameters obtain from <code>pick_Omegas</code>...
</p>

<dl>
<dt>If <code>cond_dist %in% c("Gaussian", "Student")</code>:</dt>
<dd>
<p>all covariance matrices <code class="reqn">\Omega_{m}</code> in <code>[, , m]</code>.</p>
</dd>
<dt>If <code>cond_dist=="ind_Student"</code>:</dt>
<dd>
<p>all impact matrices <code class="reqn">B_m</code> of the regimes in <code>[, , m]</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightpars</code></td>
<td>
<p>numerical vector containing the transition weight parameters, obtained from <code>pick_weightpars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distpars</code></td>
<td>
<p>A numeric vector containing the distribution parameters...
</p>

<dl>
<dt>If <code>cond_dist=="Gaussian"</code>:</dt>
<dd>
<p>Not used, i.e., a numeric vector of length zero.</p>
</dd>
<dt>If <code>cond_dist=="Student"</code>:</dt>
<dd>
<p>The degrees of freedom parameter, i.e., a numeric vector of length one.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transition_weights</code></td>
<td>
<p>(optional; only for models with <code>cond_dist="ind_Student"</code> or <code>identification="non-Gaussianity"</code>)
A <code class="reqn">T \times M</code> matrix containing the transition weights. If <code>cond_dist="ind_Student"</code> checks that the impact matrix
<code class="reqn">\sum_{m=1}^M\alpha_{m,t}^{1/2}B_m</code> is invertible for all <code class="reqn">t=1,...,T</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the "bold A" matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be "outside" the parameter space.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter vector in the argument <code>params</code> should be unconstrained and reduced form.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the given parameter values are in the parameter space and <code>FALSE</code> otherwise.
This function does NOT consider identification conditions!
</p>


<h3>References</h3>


<ul>
<li>
<p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li>
<p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li>
<p> Lanne M., Virolainen S. 2024. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li>
<p> Virolainen S. 2024. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li>
</ul>
<p>@keywords internal
</p>


</div>