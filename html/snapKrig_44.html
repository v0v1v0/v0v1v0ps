<div class="container">

<table style="width: 100%;"><tr>
<td>sk_toep_mult</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Efficiently compute yzx for symmetric Toeplitz matrices y and x</h2>

<h3>Description</h3>

<p>Computes the product <code>y %*% z</code> or <code>y %*% z %*% x</code> for symmetric Toeplitz matrices
<code>y</code> and <code>x</code> and any numeric matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_toep_mult(y, z = NULL, x = NULL, idx_obs = NULL, gdim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric matrix or vector, the symmetric Toeplitz matrix y or its first row</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>numeric matrix or vector with dimensionality conforming with y (and x)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric matrix or vector, the symmetric Toeplitz matrix x or its first row</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx_obs</code></td>
<td>
<p>integer vector, indices of the observed grid points</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Argument(s) <code>y</code> (and <code>x</code>) can be vector(s) supplying the first row of the matrix.
By default, <code>z</code> is the identity matrix, so for matrix <code>y</code>, sk_toep_mult(<code>y</code>) returns
its argument, and for vector <code>y</code>, it returns the Toeplitz matrix generated by <code>y</code>, the
same as <code>stats::toeplitz(y)</code>.
</p>
<p>Fast Fourier transforms are used to reduce the memory footprint of computations,
The first row(s) of <code>y</code> (and <code>x</code>) are embedded in a zero-padded vector representing a
circulant matrix, whose action on the zero-padded version of <code>z</code> is equivalent to
element-wise product in Fourier space. This allows the desired matrix product to be
computed without explicitly creating matrices <code>y</code> or <code>x</code> in memory.
</p>
<p>The function is optimized for grid data <code>z</code> that are sparse (many zeros). Before
computing any transformations it first scans for and removes columns and rows of
z which are all zero, replacing them afterwards.
</p>
<p>To avoid unnecessarily copying large sparse matrices, <code>z</code> can be the vector of
non-zero matrix entries only, where <code>gdim</code> specifies the full matrix dimensions and
<code>idx_obs</code> the indices of the non-zero entries.
</p>


<h3>Value</h3>

<p>numeric matrix, the product of yzx or yz (if x is NULL)
</p>


<h3>See Also</h3>

<p>base::toeplitz stats::fft
</p>
<p>Other internal variance-related functions: 
<code>sk_corr_mat()</code>,
<code>sk_corr()</code>,
<code>sk_var_mult()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># define example matrix from 1D exponential variogram
n = 10
y = exp(1-seq(n))
y_mat = sk_toep_mult(y)
max( abs(y_mat - stats::toeplitz(y))  )

# multiply by random matrix and compare with default matrix multiply
z = matrix(stats::rnorm(n^2), n)
result_default = y_mat %*% z
max( abs( result_default - sk_toep_mult(y_mat, z) ) )

# save memory by passing only the first row of the Toeplitz matrix
max( abs( result_default - sk_toep_mult(y, z) ) )

# sparsify z and repeat
idx_sparse = sample.int(n^2, n^2 - n)
z[idx_sparse] = 0
result_default = y_mat %*% z
max( abs( result_default - sk_toep_mult(y, z) ) )

# right-multiply with another kernel
x = exp( 2 *( 1-seq(n) ) )
x_mat = sk_toep_mult(x)
result_default = result_default %*% x_mat
max( abs( result_default - sk_toep_mult(y, z, x) ) )

# z can also be supplied as vector of nonzero grid values
idx_obs = which(z != 0)
gdim = c(y=n, x=n)
max( abs( result_default - sk_toep_mult(y, z=z[idx_obs], x, idx_obs, gdim) ) )

</code></pre>


</div>