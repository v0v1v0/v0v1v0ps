<div class="container">

<table style="width: 100%;"><tr>
<td>markconnect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Mark Connection Function
</h2>

<h3>Description</h3>

<p>Estimate the marked connection function
of a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">markconnect(X, i, j, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark connection function <code class="reqn">p_{ij}(r)</code>
should be evaluated. There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to <code>markcorr</code>,
or passed to the density estimation routine
(<code>density</code>, <code>loess</code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>

<p>If <code>TRUE</code>, normalise the pair connection function by
dividing it by <code class="reqn">p_i p_j</code>, the estimated probability
that randomly-selected points will have marks <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The mark connection function <code class="reqn">p_{ij}(r)</code>
of a multitype point process <code class="reqn">X</code>
is a measure of the dependence between the types of two 
points of the process a distance <code class="reqn">r</code> apart.
</p>
<p>Informally <code class="reqn">p_{ij}(r)</code> is defined
as the conditional probability,
given that there is a point of the process at a location <code class="reqn">u</code>
and another point of the process at a location <code class="reqn">v</code>
separated by a distance <code class="reqn">||u-v|| = r</code>, that the first point
is of type <code class="reqn">i</code> and the second point is of type <code class="reqn">j</code>.
See Stoyan and Stoyan (1994).
</p>
<p>If the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">p_{ij}(r) \equiv p_i p_j</code> where
<code class="reqn">p_i</code> denotes the probability that a point is of type
<code class="reqn">i</code>. Values larger than this,
<code class="reqn">p_{ij}(r) &gt; p_i p_j</code>,
indicate positive association between the two types,
while smaller values indicate negative association.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a multitype point pattern (a marked point pattern
with factor-valued marks).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">p_{ij}(r)</code> is estimated.
There is a sensible default.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code>Kest</code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt>
<dd>
<p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks) and is slow for complicated polygons.
</p>
</dd>
<dt>translate</dt>
<dd>
<p>Translation correction (Ohser, 1983).
Implemented for all window geometries.
</p>
</dd>
<dt>none</dt>
<dd>
<p>No edge correction.</p>
</dd>
</dl>
<p>The option <code>correction="none"</code> should only be used if the
number of data points is extremely large (otherwise an edge correction
is needed to correct bias).
</p>
<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The mark connection function is estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt>
<dd>
<p>which uses the standard kernel
density estimation routine <code>density</code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt>
<dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code>fv.object</code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark connection function <code class="reqn">p_{ij}(r)</code>
has been  estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">p_{ij}(r)</code>
when the marks attached to different points are independent
</p>
</td>
</tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">p_{ij}(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>Multitype pair correlation <code>pcfcross</code>
and multitype K-functions <code>Kcross</code>, <code>Kdot</code>.
</p>
<p>Use <code>alltypes</code> to compute the mark connection functions
between all pairs of types.
</p>
<p>Mark correlation <code>markcorr</code> and 
mark variogram <code>markvario</code>
for numeric-valued marks.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    M &lt;- markconnect(amacrine, "on", "off")
    plot(M)

    # Compute for all pairs of types at once
    plot(alltypes(amacrine, markconnect))
</code></pre>


</div>