<div class="container">

<table style="width: 100%;"><tr>
<td>interval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Intervals</h2>

<h3>Description</h3>

<p>Interval class for countable and uncountable numeric sets.</p>


<h3>Usage</h3>

<pre><code class="language-R">interval(l=NULL, r=l,
         bounds=c("[]", "[)", "(]", "()", "[[", "]]", "][",
                  "open", "closed", "left-open", "right-open",
                  "left-closed", "right-closed"),
         domain=NULL)

reals(l=NULL, r=NULL,
      bounds=c("[]", "[)", "(]", "()", "[[", "]]", "][",
               "open", "closed", "left-open", "right-open",
               "left-closed", "right-closed"))
integers(l=NULL, r=NULL)
naturals(l=NULL, r=NULL)
naturals0(l=NULL, r=NULL)
l %..% r

interval_domain(x)

as.interval(x)
integers2reals(x, min=-Inf, max=Inf)
reals2integers(x)

interval_complement(x, y=NULL)
interval_intersection(...)
interval_symdiff(...)
interval_union(...)

interval_difference(...)
interval_division(...)
interval_product(...)
interval_sum(...)

is.interval(x)
interval_contains_element(x, y)
interval_is_bounded(x)
interval_is_closed(x)
interval_is_countable(...)
interval_is_degenerate(x)
interval_is_empty(x)
interval_is_equal(x, y)
interval_is_less_than_or_equal(x, y)
interval_is_less_than(x, y)
interval_is_greater_than_or_equal(x, y)
interval_is_greater_than(x, y)
interval_is_finite(x)
interval_is_half_bounded(x)
interval_is_left_bounded(x)
interval_is_left_closed(x)
interval_is_left_open(...)
interval_is_left_unbounded(x)
interval_measure(x)
interval_is_proper(...)
interval_is_proper_subinterval(x, y)
interval_is_right_bounded(x)
interval_is_right_closed(x)
interval_is_right_open(...)
interval_is_right_unbounded(x)
interval_is_subinterval(x, y)
interval_is_unbounded(x)
interval_is_uncountable(x)
interval_power(x, n)
x %&lt;% y
x %&gt;% y
x %&lt;=% y
x %&gt;=% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For <code>as.interval()</code> and <code>is.interval()</code>: an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
object. For all other functions: an interval object (or any other <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object
coercible to one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>An interval object (or any other <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object coercible to
one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min, max</code></td>
<td>
<p>Integers defining the range to be coerced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l, r</code></td>
<td>
<p>Numeric values defining the bounds of the interval. For
integer domains, these will be rounded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Character string specifying whether the interval is
open, closed, or left/right-open/closed. Symbolic shortcuts such as
<code>"()"</code> or <code>"]["</code> for an open interval, etc., are also accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>Character string specifying the domain of the interval:
<code>"R"</code>, <code>"Z"</code>, <code>"N"</code>, and <code>"N0"</code> for the reals,
integers, positive integers and non-negative integers,
respectively. If unspecified, the domain will be guessed from the
mode of the numeric values specifying the bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer exponent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Interval objects (or other <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects coercible to
interval objects).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An interval object represents a multi-interval, i.e., a union of
disjoint, possibly unbounded (i.e., infinite)
ranges of numbersâ€”either the extended reals, or sequences of
integers. The usual set operations (union, complement, intersection)
and predicates (equality, (proper) inclusion) are implemented. If
(numeric) sets and interval objects are mixed, the result will be an
interval object. Some basic interval arithmetic operations
(addition, subtraction, multiplication, division, power) as well
mathematical functions (<code>log</code>, <code>log2</code>, <code>log10</code>, <code>exp</code>,
<code>abs</code>, <code>sqrt</code>, <code>trunc</code>, <code>round</code>, <code>floor</code>,
<code>ceiling</code>, <code>signif</code>, and the trigonometric functions)
are defined. Note that the rounding functions will discretize the
interval. 
</p>
<p>Coercion methods for the <code>as.numeric</code>, <code>as.list</code>, and
<code>as.set</code> generics are implemented. <code>reals2integers()</code>
discretizes a real multi-interval. <code>integers2reals()</code> returns a
multi-interval of corresponding (degenerate) real intervals.
</p>
<p>The summary functions <code>min</code>, <code>max</code>, <code>range</code>,
<code>sum</code>, <code>mean</code> and <code>prod</code> are implemented and work
on the interval bounds.
</p>
<p><code>sets_options()</code> allows to change the style of open bounds
according to the ISO 31-11 standard using reversed brackets instead of
round parentheses (see examples).
</p>


<h3>Value</h3>

<p>For the predicates: a logical value. For all other functions:
an interval object.</p>


<h3>See Also</h3>

<p><code>set</code> and <code>gset</code> for <em>finite</em> (generalized) sets.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### * general interval constructor

interval(1,5)
interval(1,5, "[)")
interval(1,5, "()")

## ambiguous notation -&gt; use alternative style
sets_options("openbounds", "][")
interval(1,5, "()")
sets_options("openbounds", "()")

interval(1,5, domain = "Z")
interval(1L, 5L)

## degenerate interval
interval(3)

## empty interval
interval()

#### * reals
reals()
reals(1,5)
reals(1,5,"()")
reals(1) ## half-unbounded

## (auto-)complement
!reals(1,5)
interval_complement(reals(1,5), reals(2, Inf))

## combine/c(reals(2,4), reals(3,5))
reals(2,4) | reals(3,5)

## intersection
reals(2,4) &amp; reals(3,5)

## overlapping intervals
reals(2,4) &amp; reals(3,5)
reals(2,4) &amp; reals(4,5,"(]")

## non-overlapping
reals(2,4) &amp; reals(7,8)
reals(2,4) | reals(7,8)
reals(2,4,"[)") | reals(4,5,"(]")

## degenerated cases
reals(2,4) | interval()
c(reals(2,4), set())

reals(2,4) | interval(6)
c(reals(2,4), set(6), 9)

## predicates
interval_is_empty(interval())
interval_is_degenerate(interval(4))
interval_is_bounded(reals(1,2))
interval_is_bounded(reals(1,Inf)) ## !! FALSE, because extended reals
interval_is_half_bounded(reals(1,Inf))
interval_is_left_bounded(reals(1,Inf))
interval_is_right_unbounded(reals(1,Inf))
interval_is_left_closed(reals(1,Inf))
interval_is_right_closed(reals(1,Inf)) ## !! TRUE

reals(1,2) &lt;= reals(1,5)
reals(1,2) &lt; reals(1,2)
reals(1,2) &lt;= reals(1,2,"[)")
reals(1,2,"[)") &lt; reals(1,2)

#### * integers
integers()
naturals()
naturals0()

3 %..% 5
integers(3, 5)
integers(3, 5) | integers(6,9)
integers(3, 5) | integers(7,9)

interval_complement(naturals(), integers())

naturals() &lt;= naturals0()
naturals0() &lt;= integers()

## mix reals and integers
c(reals(2,5), integers(7,9))
interval_complement(reals(2,5), integers())
interval_complement(integers(2,5), reals())

try(interval_complement(integers(), reals()), silent = TRUE)
## infeasible --&gt; error

integers() &lt;= reals()
reals() &lt;= integers()

### interval arithmetic
x &lt;- interval(2,4)
y &lt;- interval(3,6)
x + y
x - y
x * y
x / y

## summary functions
min(x, y)
max(y)
range(y)
mean(y)
</code></pre>


</div>