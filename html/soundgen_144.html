<div class="container">

<table style="width: 100%;"><tr>
<td>invertSpectrogram</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Invert spectrogram</h2>

<h3>Description</h3>

<p>Transforms a spectrogram into a time series with inverse STFT. The problem is
that an ordinary spectrogram preserves only the magnitude (modulus) of the
complex STFT, while the phase is lost, and without phase it is impossible to
reconstruct the original audio accurately. So there are a number of
algorithms for "guessing" the phase that would produce an audio whose
magnitude spectrogram is very similar to the target spectrogram. Useful for
certain filtering operations that modify the magnitude spectrogram followed
by inverse STFT, such as filtering in the spectrotemporal modulation domain.
</p>


<h3>Usage</h3>

<pre><code class="language-R">invertSpectrogram(
  spec,
  samplingRate,
  windowLength,
  overlap,
  step = NULL,
  wn = "hanning",
  specType = c("abs", "log", "dB")[1],
  initialPhase = c("zero", "random", "spsi")[3],
  nIter = 50,
  normalize = TRUE,
  play = TRUE,
  verbose = FALSE,
  plotError = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>the spectrogram that is to be transform to a time series: numeric
matrix with frequency bins in rows and time frames in columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingRate</code></td>
<td>
<p>sampling rate of <code>x</code> (only needed if <code>x</code> is a
numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windowLength</code></td>
<td>
<p>length of FFT window, ms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap</code></td>
<td>
<p>overlap between successive FFT frames, %</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>you can override <code>overlap</code> by specifying FFT step, ms (NB:
because digital audio is sampled at discrete time intervals of
1/samplingRate, the actual step and thus the time stamps of STFT frames
may be slightly different, eg 24.98866 instead of 25.0 ms)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wn</code></td>
<td>
<p>window type accepted by <code>ftwindow</code>, currently
gaussian, hanning, hamming, bartlett, blackman, flattop, rectangle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specType</code></td>
<td>
<p>the scale of target spectroram: 'abs' = absolute, 'log' =
log-transformed, 'dB' = in decibels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialPhase</code></td>
<td>
<p>initial phase estimate: "zero" = set all phases to zero;
"random" = Gaussian noise; "spsi" (default) = single-pass spectrogram
inversion (Beauregard et al., 2015)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>the number of iterations of the GL algorithm (Griffin &amp; Lim,
1984), 0 = don't run</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>if TRUE, normalizes the output to range from -1 to +1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>play</code></td>
<td>
<p>if TRUE, plays back the reconstructed audio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if TRUE, prints estimated time left every 10% of GL
iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotError</code></td>
<td>
<p>if TRUE, produces a scree plot of squared error over GL
iterations (useful for choosing 'nIter')</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithm: takes the spectrogram, makes an initial guess at the phase (zero,
noise, or a more intelligent estimate by the SPSI algorithm), fine-tunes over
'nIter' iterations with the GL algorithm, reconstructs the complex
spectrogram using the best phase estimate, and performs inverse STFT. The
single-pass spectrogram inversion (SPSI) algorithm is implemented as
described in Beauregard et al. (2015) following the python code at
https://github.com/lonce/SPSI_Python. The Griffin-Lim (GL) algorithm is based
on Griffin &amp; Lim (1984).
</p>


<h3>Value</h3>

<p>Returns the reconstructed audio as a numeric vector.
</p>


<h3>References</h3>


<ul>
<li>
<p> Griffin, D., &amp; Lim, J. (1984). Signal estimation from modified
short-time Fourier transform. IEEE Transactions on Acoustics, Speech, and
Signal Processing, 32(2), 236-243.
</p>
</li>
<li>
<p> Beauregard, G. T., Harish, M., &amp; Wyse, L. (2015, July). Single pass
spectrogram inversion. In 2015 IEEE International Conference on Digital
Signal Processing (DSP) (pp. 427-431). IEEE.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>spectrogram</code> <code>filterSoundByMS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create a spectrogram
samplingRate = 16000
windowLength = 40
overlap = 75
wn = 'gaussian'

s = soundgen(samplingRate = samplingRate, addSilence = 100)
spec = spectrogram(s, samplingRate = samplingRate,
  wn = wn, windowLength = windowLength, step = NULL, overlap = overlap,
  padWithSilence = FALSE, output = 'original')

# Invert the spectrogram, attempting to guess the phase
# Note that samplingRate, wn, windowLength, and overlap must be the same as
# in the original (ie you have to know how the spectrogram was created)
s_new = invertSpectrogram(spec, samplingRate = samplingRate,
  windowLength = windowLength, overlap = overlap, wn = wn,
  initialPhase = 'spsi', nIter = 100, specType = 'abs', play = FALSE)

# Verify the quality of audio reconstruction
# playme(s, samplingRate); playme(s_new, samplingRate)
</code></pre>


</div>