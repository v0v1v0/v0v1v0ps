<div class="container">

<table style="width: 100%;"><tr>
<td>dummy_aggregate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>aggregate_multiple_fun</code> using a dummy matrix</h2>

<h3>Description</h3>

<p>Wrapper to <code>aggregate_multiple_fun</code>
that uses a dummy matrix instead of the <code>by</code> parameter.
Functionality for non-dummy  matrices as well.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dummy_aggregate(
  data,
  x,
  vars,
  fun = NULL,
  dummy = TRUE,
  when_non_dummy = warning,
  keep_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li>
<p> Parameter <code>vars</code> will converted to an internal standard by the function <code>fix_vars_amf</code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code>fix_vars_amf</code>. Indices instead of variable names are allowed.
</p>
</li>
<li>
<p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li>
<p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code>fix_fun_amf</code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dummy</code></td>
<td>
<p>When <code>TRUE</code>, only 0s and 1s are assumed in <code>x</code>.
When <code>FALSE</code>, non-0s in <code>x</code> are passed as an additional first input parameter to the <code>fun</code> functions.
Thus, the same result as matrix multiplication is achieved with <code>fun = function(x, y) sum(x * y)</code>.
In this case, the data will not be subjected to <code>unlist</code>. See <code>aggregate_multiple_fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>when_non_dummy</code></td>
<td>
<p>Function to be called when <code>dummy</code> is <code>TRUE</code> and when <code>x</code> is non-dummy.  Supply <code>NULL</code> to do nothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_names</code></td>
<td>
<p>When <code>TRUE</code>, output row names are inherited from column names in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>aggregate_multiple_fun</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Internally this function make use of the <code>ind</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p><code>aggregate_multiple_fun</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Code that generates output similar to the 
# last example in aggregate_multiple_fun

d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]

x &lt;- ModelMatrix(d, formula = ~main_income:k_group - 1)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
dummy_aggregate(
   data = d, 
   x = x, 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean))


# Make a non-dummy matrix 
x2 &lt;- x
x2[17, 2:5] &lt;- c(-1, 3, 0, 10)
x2[, 4] &lt;- 0

# Now warning 
# Result is not same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, vars = "freq", fun = sum)

# Now same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, 
                vars = "freq", dummy = FALSE,
                fun = function(x, y) sum(x * y))


# Same as t(x2) %*% d[["freq"]]  + t(x2^2) %*% d[["y"]] 
dummy_aggregate(data = d, x = x2, 
                vars = list(c("freq", "y")), dummy = FALSE,
                fun = function(x, y1, y2) {sum(x * y1) + sum(x^2 * y2)})
                
</code></pre>


</div>