<div class="container">

<table style="width: 100%;"><tr>
<td>prob.guttman</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Probabilistic Guttman Model
</h2>

<h3>Description</h3>

<p>This function estimates the probabilistic Guttman model which
is a special case of an ordered latent trait model (Hanson, 2000;
Proctor, 1970).
</p>


<h3>Usage</h3>

<pre><code class="language-R">prob.guttman(dat, pid=NULL, guess.equal=FALSE,  slip.equal=FALSE,
    itemlevel=NULL, conv1=0.001, glob.conv=0.001, mmliter=500)

## S3 method for class 'prob.guttman'
summary(object,...)

## S3 method for class 'prob.guttman'
anova(object,...)

## S3 method for class 'prob.guttman'
logLik(object,...)

## S3 method for class 'prob.guttman'
IRT.irfprob(object,...)

## S3 method for class 'prob.guttman'
IRT.likelihood(object,...)

## S3 method for class 'prob.guttman'
IRT.posterior(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>An <code class="reqn">N \times I</code> data frame of dichotomous item responses
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>

<p>Optional vector of person identifiers
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guess.equal</code></td>
<td>

<p>Should the same guessing parameters for all the items estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slip.equal</code></td>
<td>

<p>Should the same slipping parameters for all the items estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemlevel</code></td>
<td>

<p>A vector of item levels of the Guttman scale for each item. If there
are <code class="reqn">K</code> different item levels, then the Guttman scale possesses
<code class="reqn">K</code> ordered trait values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv1</code></td>
<td>

<p>Convergence criterion for item parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.conv</code></td>
<td>

<p>Global convergence criterion for the deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mmliter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>prob.guttman</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>prob.guttman</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>Estimated person parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Estimated item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>
<p>Ability levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait</code></td>
<td>
<p>Estimated trait distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemdesign</code></td>
<td>
<p>Specified allocation of items to trait levels</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hanson, B. (2000). <em>IRT parameter estimation using the EM algorithm</em>.
Technical Report.
</p>
<p>Proctor, C. H. (1970). A probabilistic formulation and statistical analysis
for Guttman scaling. <em>Psychometrika, 35</em>, 73-78.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Dataset Reading
#############################################################################
data(data.read)
dat &lt;- data.read

#***
# Model 1: estimate probabilistic Guttman model
mod1 &lt;- sirt::prob.guttman( dat )
summary(mod1)

#***
# Model 2: probabilistic Guttman model with equal guessing and slipping parameters
mod2 &lt;- sirt::prob.guttman( dat, guess.equal=TRUE, slip.equal=TRUE)
summary(mod2)

#***
# Model 3: Guttman model with three a priori specified item levels
itemlevel &lt;- rep(1,12)
itemlevel[ c(2,5,8,10,12) ] &lt;- 2
itemlevel[ c(3,4,6) ] &lt;- 3
mod3 &lt;- sirt::prob.guttman( dat, itemlevel=itemlevel )
summary(mod3)

## Not run: 
#***
# Model3m: estimate Model 3 in mirt

library(mirt)
# define four ordered latent classes
Theta &lt;- scan(nlines=1)
   0 0 0    1 0 0   1 1 0   1 1 1
Theta &lt;- matrix( Theta, nrow=4, ncol=3,byrow=TRUE)

# define mirt model
I &lt;- ncol(dat)  # I=12
mirtmodel &lt;- mirt::mirt.model("
        # specify factors for each item level
        C1=1,7,9,11
        C2=2,5,8,10,12
        C3=3,4,6
        ")
# get initial parameter values
mod.pars &lt;- mirt::mirt(dat, model=mirtmodel,  pars="values")
# redefine initial parameter values
mod.pars[ mod.pars$name=="d","value" ]  &lt;- -1
mod.pars[ mod.pars$name %in% paste0("a",1:3) &amp; mod.pars$est,"value" ]  &lt;- 2
mod.pars
# define prior for latent class analysis
lca_prior &lt;- function(Theta,Etable){
  # number of latent Theta classes
  TP &lt;- nrow(Theta)
  # prior in initial iteration
  if ( is.null(Etable) ){ prior &lt;- rep( 1/TP, TP ) }
  # process Etable (this is correct for datasets without missing data)
  if ( ! is.null(Etable) ){
    # sum over correct and incorrect expected responses
    prior &lt;- ( rowSums(Etable[, seq(1,2*I,2)]) + rowSums(Etable[,seq(2,2*I,2)]) )/I
                 }
  prior &lt;- prior / sum(prior)
  return(prior)
}
# estimate model in mirt
mod3m &lt;- mirt::mirt(dat, mirtmodel, pars=mod.pars, verbose=TRUE,
            technical=list( customTheta=Theta, customPriorFun=lca_prior) )
# correct number of estimated parameters
mod3m@nest &lt;- as.integer(sum(mod.pars$est) + nrow(Theta)-1 )
# extract log-likelihood and compute AIC and BIC
mod3m@logLik
( AIC &lt;- -2*mod3m@logLik+2*mod3m@nest )
( BIC &lt;- -2*mod3m@logLik+log(mod3m@Data$N)*mod3m@nest )
# compare with information criteria from prob.guttman
mod3$ic
# model fit in mirt
mirt::M2(mod3m)
# extract coefficients
( cmod3m &lt;- sirt::mirt.wrapper.coef(mod3m) )
# compare estimated distributions
round( cbind( "sirt"=mod3$trait$prob, "mirt"=mod3m@Prior[[1]] ), 5 )
  ##           sirt    mirt
  ##   [1,] 0.13709 0.13765
  ##   [2,] 0.30266 0.30303
  ##   [3,] 0.15239 0.15085
  ##   [4,] 0.40786 0.40846
# compare estimated item parameters
ipars &lt;- data.frame( "guess.sirt"=mod3$item$guess,
                     "guess.mirt"=plogis( cmod3m$coef$d ) )
ipars$slip.sirt &lt;- mod3$item$slip
ipars$slip.mirt &lt;- 1-plogis( rowSums(cmod3m$coef[, c("a1","a2","a3","d") ] ) )
round( ipars, 4 )
  ##      guess.sirt guess.mirt slip.sirt slip.mirt
  ##   1      0.7810     0.7804    0.1383    0.1382
  ##   2      0.4513     0.4517    0.0373    0.0368
  ##   3      0.3203     0.3200    0.0747    0.0751
  ##   4      0.3009     0.3007    0.3082    0.3087
  ##   5      0.5776     0.5779    0.1800    0.1798
  ##   6      0.3758     0.3759    0.3047    0.3051
  ##   7      0.7262     0.7259    0.0625    0.0623
  ##   [...]

#***
# Model 4: Monotone item response function estimated in mirt

# define four ordered latent classes
Theta &lt;- scan(nlines=1)
   0 0 0    1 0 0   1 1 0   1 1 1
Theta &lt;- matrix( Theta, nrow=4, ncol=3,byrow=TRUE)

# define mirt model
I &lt;- ncol(dat)  # I=12
mirtmodel &lt;- mirt::mirt.model("
        # specify factors for each item level
        C1=1-12
        C2=1-12
        C3=1-12
        ")
# get initial parameter values
mod.pars &lt;- mirt::mirt(dat, model=mirtmodel,  pars="values")
# redefine initial parameter values
mod.pars[ mod.pars$name=="d","value" ]  &lt;- -1
mod.pars[ mod.pars$name %in% paste0("a",1:3) &amp; mod.pars$est,"value" ]  &lt;- .6
# set lower bound to zero ton ensure monotonicity
mod.pars[ mod.pars$name %in% paste0("a",1:3),"lbound" ]  &lt;- 0
mod.pars
# estimate model in mirt
mod4 &lt;- mirt::mirt(dat, mirtmodel, pars=mod.pars, verbose=TRUE,
            technical=list( customTheta=Theta, customPriorFun=lca_prior) )
# correct number of estimated parameters
mod4@nest &lt;- as.integer(sum(mod.pars$est) + nrow(Theta)-1 )
# extract coefficients
cmod4 &lt;- sirt::mirt.wrapper.coef(mod4)
cmod4
# compute item response functions
cmod4c &lt;- cmod4$coef[, c("d", "a1", "a2", "a3" ) ]
probs4 &lt;- t( apply( cmod4c, 1, FUN=function(ll){
                 plogis(cumsum(as.numeric(ll))) } ) )
matplot( 1:4,  t(probs4), type="b", pch=1:I)

## End(Not run)
</code></pre>


</div>