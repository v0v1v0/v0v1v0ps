<div class="container">

<table style="width: 100%;"><tr>
<td>sem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General Structural Equation Models</h2>

<h3>Description</h3>

<p><code>sem</code> fits general structural equation models (with both observed and
unobserved variables). Observed variables are also called <em>indicators</em> or 
<em>manifest variables</em>; unobserved variables are also called <em>factors</em>
or <em>latent variables</em>. Normally, the generic function (<code>sem</code>) is
called directly with a <code>semmod</code> first argument produced by <code>specifyModel</code>,
<code>specifyEquations</code>, or <code>cfa</code>, invoking the <code>sem.semmod</code>
method, which in turn sets up a call to the <code>sem.default</code> method; thus, the user
may wish to specify arguments accepted by the <code>semmod</code> and <code>default</code> methods.
Similarly, for a multigroup model, <code>sem</code> would normally be called with a
<code>semmodList</code> object produced by <code>multigroupModel</code> as its first argument,
and would then generate a call to the code <code>msemmod</code> method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'semmod'
sem(model, S, N, data, 
    raw=identical(na.action, na.pass), obs.variables=rownames(S), 
  	fixed.x=NULL, formula= ~ ., na.action=na.omit, 
    robust=!missing(data), debug=FALSE, 
    optimizer=optimizerSem, objective=objectiveML, ...)
    
## Default S3 method:
sem(model, S, N, raw=FALSE, data=NULL, start.fn=startvalues,
    pattern.number=NULL, valid.data.patterns=NULL,
    use.means=TRUE, param.names, 
  	var.names, fixed.x=NULL, robust=!is.null(data), semmod=NULL, debug=FALSE,
		analytic.gradient=!identical(objective, objectiveFIML), 
        warn=FALSE, maxiter=1000, par.size=c("ones", "startvalues"), 
		start.tol=1E-6, optimizer=optimizerSem, objective=objectiveML, cls, ...)
		
## S3 method for class 'semmodList'
sem(model, S, N, data, raw=FALSE, fixed.x=NULL, 
		robust=!missing(data), formula, group="Group", debug=FALSE, ...)
		
## S3 method for class 'msemmod'
sem(model, S, N, start.fn=startvalues,
        group="Group", groups=names(model), raw=FALSE, fixed.x, 
		param.names, var.names, debug=FALSE, analytic.gradient=TRUE, warn=FALSE,
		maxiter=5000, par.size = c("ones", "startvalues"), start.tol = 1e-06, 
		start=c("initial.fit", "startvalues"), initial.maxiter=1000,
		optimizer = optimizerMsem, objective = msemObjectiveML, ...)
    
startvalues(S, ram, debug=FALSE, tol=1E-6)
startvalues2(S, ram, debug=FALSE, tol=1E-6)

## S3 method for class 'sem'
coef(object, standardized=FALSE, ...)
## S3 method for class 'msem'
coef(object, ...)
## S3 method for class 'sem'
vcov(object, robust=FALSE, 
	analytic=inherits(object, "objectiveML") &amp;&amp; object$t &lt;= 500, ...)
## S3 method for class 'msem'
vcov(object, robust=FALSE, 
    analytic=inherits(object, "msemObjectiveML") &amp;&amp; object$t &lt;= 500, ...)
## S3 method for class 'sem'
df.residual(object, ...)
## S3 method for class 'msem'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>RAM specification, which is a simple encoding of the path
diagram for the model. The model may be given either in symbolic 
form (as a <code>semmod</code> object, as returned by the <code>specifyModel</code>,  
<code>specifyEquations</code>, or <code>cfa</code> function,
or as a character matrix), invoking <code>sem.semmod</code>, which calls <code>sem.default</code> 
after setting up the model,
or (less conveniently) in numeric form, invoking <code>sem.default</code> directly, which is
not recommended (see <b>Details</b> below). The <code>model</code> argument may also be a
multigroup-model specification, as produced by <code>multigroupModel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>covariance matrix among observed variables; may be input as a symmetric matrix,
or as a lower- or upper-triangular matrix. <code>S</code> may also be a raw (i.e., “uncorrected”)
moment matrix — that is, a sum-of-squares-and-products matrix divided by <code>N</code>. This
form of input is useful for fitting models with intercepts, in which case the moment matrix
should include the mean square and cross-products for a unit variable all of whose entries are 1;
of course, the raw mean square for the unit variable is 1. Raw-moment matrices may be computed
by <code>rawMoments</code>. If the <code>ram</code> argument is given in symbolic form, then
the observed-variable covariance or raw-moment matrix may contain variables that do not appear in the model,
in which case a warning is printed. <code>S</code> may also be a list of covariance or moment matrices for each
group in a multigroup model.
As an alternative to specifying <code>S</code> the user may
supply a data frame containing the data for the model (see the argument <code>data</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of observations on which the covariance matrix is based; for a multigroup model, a vector
of group <code class="reqn">N</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>As a generally preferable alternative to specifying <code>S</code> and 
<code>N</code>, the user may supply a data frame containing the data to which the model is to be fit.
In a multigroup model, the <code>data</code> argument may be a list of data frames or a single data frame;
in the later event, the factor given as the <code>group</code> argument is used to split the data into groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.fn</code></td>
<td>
<p>a function to compute startvalues for the free parameters of the model;
two functions are supplied, <code>startvalues</code> and a older version, <code>startvalues2</code>,
the first of which is the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function to process missing data, if raw data are supplied in the <code>data</code> argument.
The default is <code>na.omit</code>, which returns only complete cases; specify <code>na.action=na.pass</code> to
get FIML estimates in the presence of missing data from the <code>objectiveFIML</code> 
and <code>objectiveFIML2</code> objective functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p><code>TRUE</code> if <code>S</code> is a raw moment matrix or if a raw moment matrix —  as
opposed to a covariance matrix — is to be
computed from <code>data</code>; the default is <code>FALSE</code> unless the <code>na.action</code> argument
is set to <code>na.pass</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern.number, valid.data.patterns</code></td>
<td>
<p>these arguments pass information about valid (i.e.,
non-missing) data patterns and normally would not be specified directly by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.means</code></td>
<td>
<p>When raw data are supplied and intercepts are included in the model, use the
observed-variable means as start values for the intercepts; the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.variables</code></td>
<td>
<p>names of observed variables, by default taken from the row names of
the covariance or moment matrix <code>S</code>, which may be given directly or generated according to the
<code>data</code> and <code>formula</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.x</code></td>
<td>
<p>names (if the <code>ram</code> matrix is given in symbolic form) or indices 
(if it is in numeric form) of fixed exogenous variables. Specifying these obviates
the necessity of having to fix the variances and covariances among these 
variables (and produces correct degrees of freedom for the model chisquare).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a one-sided formula, to be applied to <code>data</code> to generate the variables for
which covariances or raw moments are computed. The default formula is <code>~.</code>, i.e., all of the
variables in the data, including an implied intercept; if a covariance matrix is to be computed,
the constant is suppressed. In a multigroup model, alternatively a list one one-sided formulas as be
given, to be applied individually to the groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>In <code>sem</code>: if <code>TRUE</code>, then quantities are calculated that can be used to compute robust
estimates of coefficient standard errors and robust tests when the model is fit by multinormal maximum likelihood;
the default is <code>TRUE</code> when the <code>data</code> argument is <code>TRUE</code>, and this option is only
available when the <code>data</code> argument is given. In <code>vcov</code>: if <code>TRUE</code>, return a robust coefficient covariance matrix
(if <code>object</code> contains the requisite information).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>semmod</code></td>
<td>
<p>a <code>semmod</code> object containing the description of the model; optional, and normally supplied
not directly by the user but via the <code>semmod</code> method for <code>sem</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if <code>TRUE</code>, some information is printed to help you debug the symbolic
model specification; for example, if a variable name is misspelled, <code>sem</code> will
assume that the variable is a (new) latent variable. Information about
the optimization will also be printed, but details will vary with the optimizer employed. 
The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed down, including from <code>sem.default</code> to the 
optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param.names</code></td>
<td>
<p>names of the <code class="reqn">t</code> free parameters, given in their numerical order;
default names are <code>Param1</code>, ..., <code>Param</code><em>t</em>. Note: Should not be
specified when the model is given in symbolic form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.names</code></td>
<td>
<p>names of the <code class="reqn">m</code> entries of the <code class="reqn">v</code> vector
(typically the observed and latent variables — see below), given in their
numerical order; default names are <code>Var1</code>, ..., <code>Var</code><em>m</em>.
Note: Should not be specified when the model is given in symbolic form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analytic.gradient</code></td>
<td>
<p>if <code>TRUE</code> (the default, except for the <code>objectiveFIML</code> objective function,
where, at present, an analytic gradient slows down the computation), then analytic first derivatives are
used in the maximization of the likelihood if the optimzer employed will accept them; 
otherwise numeric derivatives are used, again if the optimizer will compute them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>if <code>TRUE</code>, warnings produced by the optimization function will be printed.
This should generally not be necessary, since <code>sem</code> prints its own warning, and saves
information about convergence. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations for the optimization of the objective function,
to be passed to the optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.size</code></td>
<td>
<p>the anticipated size of the free parameters; if <code>"ones"</code>,
a vector of ones is used; if <code>"startvalues"</code>, taken from the start values.
You can try changing this argument if you encounter convergence problems.
The default is <code>"startvalues"</code> if the largest input variance is at
least 100 times the smallest, and <code>"ones"</code> otherwise. Whether this argument is actually
used depends upon the optimizer employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.tol, tol</code></td>
<td>
<p>if the magnitude of an automatic start value is less than <code>start.tol</code>, then
it is set to <code>start.tol</code>; defaults to 1E-6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>a function to be used to minimize the objective function; the default for single-group models is 
<code>optimizerSem</code>.
Alternatives are <code>nlm</code>, which employs the standard R optimizer <code>nlm</code>;
<code>optimizerOptim</code>, which employs <code>optim</code>;
and <code>optimizerNlminb</code>, which uses <code>nlminb</code> — or
the user can supply an optimizer. For multigroup model, the default is <code>optimizerMsem</code>, and
<code>msemOptimizerNlm</code>, based on <code>nlm</code>, is provided as an alternative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>
<p>An objective function to be minimized, sometimes called a “fit” function 
in the SEM literature. The default for single-group models is <code>objectiveML</code>,
which produces maximum-likelihood estimates assuming multinormality. An alternative is 
<code>objectiveGLS</code>, which produced generalized least squares estimates — or the user
can supply an objective function to be minimized. For multigroup models, the default is
available is <code>msemObjectiveML</code> for ML estimates and an alternative is <code>msemObjectiveGLS</code>
for GLS estiamtes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cls</code></td>
<td>
<p>primary class to be assigned to the result; normally this is not specified directly, but
raither is inferred from the objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ram</code></td>
<td>
<p>numeric RAM matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>"sem"</code> or <code>"msem"</code>, returned by <code>sem</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>if <code>TRUE</code>, return standardized coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analytic</code></td>
<td>
<p>return an analytic (as opposed to numeric) estimate of the coefficient covariance matrix;
at present only available for the <code>objectiveML</code> objective function. The default is <code>FALSE</code>
for this objective function if there are no more than 100 parameters and <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>for a multigroup model, the quoted name of the group variable; if the <code>data</code> argument is given,
snd is a single data frame, then this should be a factor in the data set or a variable coercible to a factor,
to be used to split the data into groups; otherwise, the name is arbitrary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>a character vector giving the names of the groups; will be ignored if <code>group</code> is a factor
in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>if <code>"initial.fit"</code> (the default), start values 
for a multi-group model are computed by first fitting the intra-group models separately by group;
if <code>"startvalues"</code>, then start values are computed as for a single-group model.
In some cases, the intra-group models may not be identified even if the multi-group model is, and
then <code>start="initial.fit"</code> should not be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.maxiter</code></td>
<td>
<p>if <code>start="initial.fit"</code> for a multi-group model, then
<code>initial.maxiter</code> gives the maximum number of iterations for each initial intra-group fit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model is set up using either RAM (“reticular action model” – don't ask!) 
notation – a simple format
for specifying general structural equation models by coding the
“arrows” in the path diagram for the model (see, e.g., McArdle and McDonald, 1984) –
typically using the <code>specifyModel</code> function; in equation format using the
<code>specifyEquations</code> function; or, for a simple confirmatory factor analysis model,
via the <code>cfa</code> function. In any case, the model is represented internally in RAM format.
</p>
<p>The variables in the <code class="reqn">v</code> vector in the model (typically, the observed and
unobserved variables, but not error variables) are numbered from 1 to <code class="reqn">m</code>.  
the RAM matrix contains one row for each (free or constrained) parameter of the model, and
may be specified either in symbolic format or in numeric format.
</p>
<p>A symbolic <code>ram</code> matrix consists of three columns, as follows:
</p>

<dl>
<dt>1. Arrow specification:</dt>
<dd>
<p>This is a simple formula, of the form
<code>"A -&gt; B"</code> or, equivalently, <code>"B &lt;- A"</code> for a regression
coefficient (i.e., a single-headed or directional arrow); 
<code>"A &lt;-&gt; A"</code> for a variance or <code>"A &lt;-&gt; B"</code> for a covariance
(i.e., a double-headed or bidirectional arrow). Here, <code>A</code> and
<code>B</code> are variable names in the model. If a name does not correspond
to an observed variable, then it is assumed to be a latent variable.
Spaces can appear freely in an arrow specification, and
there can be any number of hyphens in the arrows, including zero: Thus,
e.g., <code>"A-&gt;B"</code>, <code>"A --&gt; B"</code>, and <code>"A&gt;B"</code> are all legitimate
and equivalent.</p>
</dd>
<dt>2. Parameter name:</dt>
<dd>
<p>The name of the regression coefficient, variance,
or covariance specified by the arrow. Assigning the same name to two or
more arrows results in an equality constraint. Specifying the parameter name
as <code>NA</code> produces a fixed parameter.</p>
</dd>
<dt>3. Value:</dt>
<dd>
<p>start value for a free parameter or value of a fixed parameter.
If given as <code>NA</code>, <code>sem</code> will compute the start value.</p>
</dd>
</dl>
<p>It is simplest to construct the RAM matrix with the <code>specifyModel</code>, <code>specifyEquations</code>,
or <code>cfa</code> function,
all of which return an object of class <code>semmod</code>, and also incorporate some model-specification
convenience shortcuts. This process is illustrated in the examples below. 
</p>
<p>A numeric <code>ram</code> matrix consists of five columns, as follows:
</p>

<dl>
<dt>1. Number of arrow heads:</dt>
<dd>
<p>1 (directed arrow) or 2 (covariance).</p>
</dd>
<dt>2. Arrow <em>to</em>:</dt>
<dd>
<p>index of the variable at the head of
a directional arrow, or at one end of a bidirectional arrow.
Observed variables should be assigned the numbers 1 to <code class="reqn">n</code>, where
<code class="reqn">n</code> is the number of rows/columns in the covariance matrix <code>S</code>,
with the indices corresponding to the variables' positions in <code>S</code>.
Variable indices above <code class="reqn">n</code> represent latent variables.</p>
</dd>
<dt>3. Arrow <em>from</em>:</dt>
<dd>
<p>the index of the variable at the tail of 
a directional arrow, or at the other end of a bidirectional arrow.</p>
</dd>
<dt>4. Parameter number:</dt>
<dd>
<p>free parameters are numbered from 1 to <code class="reqn">t</code>,
but do not necessarily appear in consecutive order. Fixed parameters are given
the number 0. Equality contraints are specified by assigning two or more 
parameters the same number.</p>
</dd>
<dt>5. Value:</dt>
<dd>
<p>start value for a free parameter, or value of a fixed parameter. If given
as <code>NA</code>, the program will compute a start value, by a slight modification of the
method described by McDonald and Hartmann (1992). <em>Note:</em> In some circumstances,
some start values are selected randomly; this might produce small differences in
the parameter estimates when the program is rerun.</p>
</dd>
</dl>
<p>The numeric <code>ram</code> matrix is normally generated automatically, not specified directly by the user.
</p>
<p>For <code>specifyEquations</code>, each input line is either a regression equation or the specification
of a variance or covariance. Regression equations are of the form
</p>
<p><code>y = par1*x1 + par2*x2 + ... + park*xk</code>
</p>
<p>where <code>y</code> and the <code>x</code>s are variables in the model (either observed or latent),
and the <code>par</code>s are parameters. If a parameter is given as a numeric value (e.g.,
<code>1</code>) then it is treated as fixed. Note that no “error” variable is included in
the equation; “error variances” are specified via either the <code>covs</code> argument,
via <code>V(y) = par</code> (see immediately below), or are added automatically to the model
when, as by default, <code>endog.variances=TRUE</code>.
</p>
<p>Variances are specified in the form <code>V(var) = par</code> and covariances in the form
<code>C(var1, var2) = par</code>, where the <code>var</code>s are variables (observed or unobserved) in
the model. The symbols <code>V</code> and <code>C</code> may be in either lower- or upper-case. If <code>par</code>
is a numeric value (e.g., <code>1</code>) then it is treated as fixed. In conformity with the RAM model,
a variance or covariance for an endogenous variable in the model is an “error” variance or
covariance.
</p>
<p>To set a start value for a free parameter, enclose the numeric start value in parentheses after the
parameter name, as <code>parameter(value)</code>.
</p>
<p><code>sem</code> fits the model by calling the optimizer specified in the <code>optimizer</code> argument
to minimize the objective function specified in the <code>objective</code> argument.
If the optimization fails to converge, a warning message is printed.
</p>
<p>The RAM formulation of the general structural equation model is given by the basic equation
</p>
<p style="text-align: center;"><code class="reqn">v = Av + u</code>
</p>

<p>where <code class="reqn">v</code> and <code class="reqn">u</code> are vectors of random variables (observed or unobserved), and
the parameter matrix <code class="reqn">A</code> contains regression coefficients, symbolized by single-headed arrows
in a path diagram. Another parameter matrix, 
</p>
<p style="text-align: center;"><code class="reqn">P = E(uu')</code>
</p>

<p>contains covariances among the elements of <code class="reqn">u</code> (assuming that the elements of <code class="reqn">u</code> have zero
means). Usually <code class="reqn">v</code> contains endogenous and exogenous observed and unobserved variables, but not
error variables (see the examples below).
</p>
<p>The <code>startvalues</code> function may be called directly, but is usually called by <code>sem.default</code>; <code>startvalues2</code> is an older version of this function that may be used alternatively; see the <code>startvalues</code> argument to <code>sem</code>.
</p>


<h3>Value</h3>

<p><code>sem</code> returns an object of class <code>c(</code><em>objective</em><code>, "sem")</code>, where <em>objective</em>
is the name of the objective function that was optimized (e.g., <code>"objectiveML"</code>), with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>var.names</code></td>
<td>
<p>vector of variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ram</code></td>
<td>
<p>RAM matrix, including any rows generated for covariances
among fixed exogenous variables; column 5 includes computed start values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>observed covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>RAM selection matrix, <code class="reqn">J</code>, which picks out observed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.fix</code></td>
<td>
<p>number of fixed exogenous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of variables (observed plus unobserved).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>number of free parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p><code>TRUE</code> if the model is fit to a raw moment matrix, <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the observed-variable data matrix, or <code>NULL</code> if data are not supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>semmod</code></td>
<td>
<p>the <code>semmod</code> specification object for the model, if one was supplied; otherwise <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>the optimizer function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>
<p>the objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeff</code></td>
<td>
<p>estimates of free parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>estimated asymptotic covariance matrix of parameter estimates, based on a numeric Hessian,
if supplied by the optimizer; otherwise <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.posn</code></td>
<td>
<p>indices of free parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, depending upon whether the optimization apparently converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>number of iterations performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>value of the objective function at the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>model-reproduced covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>RAM <code class="reqn">A</code> matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>RAM <code class="reqn">P</code> matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.obj</code></td>
<td>
<p>robust adjusted value of the objective function; <code>NULL</code> if
<code>robust</code> is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust.vcov</code></td>
<td>
<p>robust estimated coefficient covariance matrix; <code>NULL</code> if
<code>robust</code> is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<p>For multigroup models, <code>sem</code> returns an object of class <code>c("msemObjectiveML", "msem")</code>.
</p>


<h3>Warning</h3>

<p>A common error is to fail to specify variance or covariance terms in the model, which are denoted 
by double-headed arrows, <code>&lt;-&gt;</code>.
</p>
<p>In general, every observed or latent variable in the model should be associated 
with a variance or error variance. 
This may be
a free parameter to estimate or a fixed constant (as in the case of a latent exogenous 
variable for which you wish to fix the variance, e.g.,
to 1). Again in general, there will be an <em>error variance</em> associated with each 
endogenous variable in the model (i.e., each variable
to which at least one single-headed arrow points — including observed indicators of latent variables), 
and a <em>variance</em> associated with each exogenous variable (i.e., each variable that
appears only at the tail of single-headed arrows, never at the head).
</p>
<p>To my knowledge, the only <em>apparent</em> exception to this rule is for observed variables that 
are declared to be fixed exogenous variables.
In this case, the program generates the necessary (fixed-constant) variances and covariances automatically.
</p>
<p>If there are missing variances, a warning message will be printed, and estimation will almost surely 
fail in some manner. Missing
variances might well indicate that there are missing covariances too, but it is not possible 
to deduce this in a mechanical manner. The <code>specifyModel</code> funciton will by default supply
error-variance parameters if these are missing.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Zhenghua Nie, and Jarrett Byrnes</p>


<h3>References</h3>

<p>Fox, J. (2006)
Structural equation modeling with the sem package in R.
<em>Structural Equation Modeling</em> 
<b>13</b>:465–486.
</p>
<p>Bollen, K. A. (1989) 
<em>Structural Equations With Latent Variables.</em> Wiley.
</p>
<p>Bollen, K. A. and Long, J. S. (eds.)
<em>Testing Structural Equation Models</em>, Sage.
</p>
<p>McArdle, J. J. and Epstein, D. (1987)
Latent growth curves within developmental structural equation models.
<em>Child Development</em>
<b>58</b>, 110–133.
</p>
<p>McArdle, J. J. and McDonald, R. P. (1984)
Some algebraic properties of the reticular action model.
<em>British Journal of Mathematical and Statistical Psychology</em>
<b>37</b>, 234–251.
</p>
<p>McDonald, R. P. and Hartmann, W. M. (1992)
A procedure for obtaining initial values of parameters in
the RAM model. <em>Multivariate Behavioral Research</em>
<b>27</b>, 57–76.
</p>
<p>Raftery, A. E. (1993)
Bayesian model selection in structural equation models.
In Bollen, K. A. and Long, J. S. (eds.)
<em>Testing Structural Equation Models</em>, Sage.
</p>
<p>Raftery, A. E. (1995)
Bayesian model selection in social research (with discussion).
<em>Sociological Methodology</em> <b>25</b>, 111–196.
</p>
<p>Satorra, A. (2000)
Scaled and adjusted restricted tests in multi-sample analysis of moment structures. 
pp. 233–247 in Heijmans, R.D.H., Pollock, D.S.G. &amp; Satorra, A. (eds.)
<em>Innovations in Multivariate Statistical Analysis. A Festschrift for Heinz Neudecker </em>, Kluwer. 
</p>


<h3>See Also</h3>

<p><code>rawMoments</code>, <code>startvalues</code>, 
<code>objectiveML</code>, <code>objectiveGLS</code>,  
<code>optimizerNlm</code>, <code>optimizerOptim</code>, <code>optimizerNlminb</code>,
<code>nlm</code>, <code>optim</code>, <code>nlminb</code>,
<code>specifyModel</code>, <code>specifyEquations</code>, <code>cfa</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# The following example illustrates the use the text argument to 
#   readMoments() and specifyEquations():

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"),
                text="
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
")

model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp", text="
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp
")

sem.dhp.1 &lt;- sem(model.dhp.1, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)

# Note: The following set of examples can't be run via example() because the default file
#  argument of specifyeEquations, specifyModel(), and readMoments() requires that the model 
#  specification and covariances, correlations, or raw moments be entered in an interactive
#  session at the command prompt. The examples can be copied and run in the R console,
#  however. See ?specifyModel and ?readMoments for further information.
#  These examples are repeated below using file input to specifyModel() and
#  readMoments(). The second version of the examples may be executed through example().

    ## Not run: 

# ------------- Duncan, Haller and Portes peer-influences model ----------------------
# A nonrecursive SEM with unobserved endogenous variables and fixed exogenous variables

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
            
# Fit the model using a symbolic ram specification

model.dhp &lt;- specifyModel()
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA
    
# an equivalent specification, allowing specifyModel() to generate
#  variance parameters for endogenous variables (and suppressing the
#  unnecessary NAs):
 
model.dhp &lt;- specifyModel()
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42
RGenAsp &lt;-&gt; FGenAsp, ps12

# Another equivalent specification, telling specifyModel to add paths for 
#   variances and covariance of RGenAsp and FGenAsp:
 
model.dhp &lt;- specifyModel(covs="RGenAsp, FGenAsp")
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42

# Yet another equivalent specification using specifyEquations():

model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp")
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp
 
sem.dhp.1 &lt;- sem(model.dhp.1, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)

# Fit the model using a numerical ram specification (not recommended!)

ram.dhp &lt;- matrix(c(
#               heads   to      from    param  start
                1,       1,     11,      0,     1,
                1,       2,     11,      1,     NA, # lam21
                1,       3,     12,      0,     1,
                1,       4,     12,      2,     NA, # lam42
                1,      11,      5,      3,     NA, # gam11
                1,      11,      6,      4,     NA, # gam12
                1,      11,      7,      5,     NA, # gam13
                1,      11,      8,      6,     NA, # gam14
                1,      12,      7,      7,     NA, # gam23
                1,      12,      8,      8,     NA, # gam24
                1,      12,      9,      9,     NA, # gam25
                1,      12,     10,     10,     NA, # gam26
                1,      11,     12,     11,     NA, # beta12
                1,      12,     11,     12,     NA, # beta21
                2,       1,      1,     13,     NA, # theta1
                2,       2,      2,     14,     NA, # theta2
                2,       3,      3,     15,     NA, # theta3
                2,       4,      4,     16,     NA, # theta4
                2,      11,     11,     17,     NA, # psi11
                2,      12,     12,     18,     NA, # psi22
                2,      11,     12,     19,     NA  # psi12
                ), ncol=5, byrow=TRUE)

params.dhp &lt;- c('lam21', 'lam42', 'gam11', 'gam12', 'gam13', 'gam14',
                 'gam23',  'gam24',  'gam25',  'gam26',
                 'beta12', 'beta21', 'theta1', 'theta2', 'theta3', 'theta4',
                 'psi11', 'psi22', 'psi12')
                 
vars.dhp &lt;- c('ROccAsp', 'REdAsp', 'FOccAsp', 'FEdAsp', 'RParAsp', 'RIQ',
                'RSES', 'FSES', 'FIQ', 'FParAsp', 'RGenAsp', 'FGenAsp')
                
sem.dhp.2 &lt;- sem(ram.dhp, R.DHP, 329, param.names=params.dhp, var.names=vars.dhp, 
	fixed.x=5:10)
summary(sem.dhp.2)


# -------------------- Wheaton et al. alienation data ----------------------
    

S.wh &lt;- readMoments(names=c('Anomia67','Powerless67','Anomia71',
                                    'Powerless71','Education','SEI'))
   11.834                                    
    6.947    9.364                            
    6.819    5.091   12.532                    
    4.783    5.028    7.495    9.986            
   -3.839   -3.889   -3.841   -3.625   9.610     
  -21.899  -18.831  -21.748  -18.775  35.522  450.288

# This is the model in the SAS manual for PROC CALIS: A Recursive SEM with
# latent endogenous and exogenous variables.
# Curiously, both factor loadings for two of the latent variables are fixed.

model.wh.1 &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,     1
    Alienation67   -&gt;  Powerless67,   NA,     0.833
    Alienation71   -&gt;  Anomia71,      NA,     1
    Alienation71   -&gt;  Powerless71,   NA,     0.833 
    SES            -&gt;  Education,     NA,     1     
    SES            -&gt;  SEI,           lamb,   NA
    SES            -&gt;  Alienation67,  gam1,   NA
    Alienation67   -&gt;  Alienation71,  beta,   NA
    SES            -&gt;  Alienation71,  gam2,   NA
    Anomia67       &lt;-&gt; Anomia67,      the1,   NA
    Anomia71       &lt;-&gt; Anomia71,      the1,   NA
    Powerless67    &lt;-&gt; Powerless67,   the2,   NA
    Powerless71    &lt;-&gt; Powerless71,   the2,   NA
    Education      &lt;-&gt; Education,     the3,   NA
    SEI            &lt;-&gt; SEI,           the4,   NA
    Anomia67       &lt;-&gt; Anomia71,      the5,   NA
    Powerless67    &lt;-&gt; Powerless71,   the5,   NA
    Alienation67   &lt;-&gt; Alienation67,  psi1,   NA
    Alienation71   &lt;-&gt; Alienation71,  psi2,   NA
    SES            &lt;-&gt; SES,           phi,    NA
                           
sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932)
summary(sem.wh.1)

# The same model in equation format:

model.wh.1 &lt;- specifyEquations()
Anomia67 = 1*Alienation67
Powerless67 = 0.833*Alienation67
Anomia71 = 1*Alienation71
Powerless71 = 0.833*Alienation71
Education = 1*SES
SEI = lamb*SES
Alienation67 = gam1*SES
Alienation71 = gam2*SES + beta*Alienation67
V(Anomia67) = the1
V(Anomia71) = the1
V(Powerless67) = the2
V(Powerless71) = the2
V(SES) = phi
C(Anomia67, Anomia71) = the5
C(Powerless67, Powerless71) = the5

# The same model, but treating one loading for each latent variable as free
# (and equal to each other).

model.wh.2 &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,        1
    Alienation67   -&gt;  Powerless67,   lamby,    NA
    Alienation71   -&gt;  Anomia71,      NA,        1
    Alienation71   -&gt;  Powerless71,   lamby,    NA 
    SES            -&gt;  Education,     NA,        1     
    SES            -&gt;  SEI,           lambx,    NA
    SES            -&gt;  Alienation67,  gam1,     NA
    Alienation67   -&gt;  Alienation71,  beta,     NA
    SES            -&gt;  Alienation71,  gam2,     NA
    Anomia67       &lt;-&gt; Anomia67,      the1,     NA
    Anomia71       &lt;-&gt; Anomia71,      the1,     NA
    Powerless67    &lt;-&gt; Powerless67,   the2,     NA
    Powerless71    &lt;-&gt; Powerless71,   the2,     NA
    Education      &lt;-&gt; Education,     the3,     NA
    SEI            &lt;-&gt; SEI,           the4,     NA
    Anomia67       &lt;-&gt; Anomia71,      the5,     NA
    Powerless67    &lt;-&gt; Powerless71,   the5,     NA
    Alienation67   &lt;-&gt; Alienation67,  psi1,     NA
    Alienation71   &lt;-&gt; Alienation71,  psi2,     NA
    SES            &lt;-&gt; SES,           phi,      NA 


sem.wh.2 &lt;- sem(model.wh.2, S.wh, 932)
summary(sem.wh.2)

# And again, in equation format:

model.wh &lt;- specifyEquations()
Anomia67 = 1*Alienation67
Powerless67 = lamby*Alienation67
Anomia71 = 1*Alienation71
Powerless71 = lamby*Alienation71
Education = 1*SES
SEI = lambx*SES
Alienation67 = gam1*SES
Alienation71 = gam2*SES + beta*Alienation67
V(Anomia67) = the1
V(Anomia71) = the1
V(Powerless67) = the2
V(Powerless71) = the2
V(SES) = phi
C(Anomia67, Anomia71) = the5
C(Powerless67, Powerless71) = the5


# Compare the two models by a likelihood-ratio test:

anova(sem.wh.1, sem.wh.2)


# ----------------------- Thurstone data ---------------------------------------
#  Second-order confirmatory factor analysis, from the SAS manual for PROC CALIS

R.thur &lt;- readMoments(diag=FALSE, names=c('Sentences','Vocabulary',
        'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
        'Letter.Series','Pedigrees', 'Letter.Group'))
    .828                                              
    .776   .779                                        
    .439   .493    .46                                 
    .432   .464    .425   .674                           
    .447   .489    .443   .59    .541                    
    .447   .432    .401   .381    .402   .288              
    .541   .537    .534   .35    .367   .32   .555        
    .38   .358    .359   .424    .446   .325   .598   .452  
            
model.thur &lt;- specifyModel()
    F1 -&gt; Sentences,                      lam11
    F1 -&gt; Vocabulary,                     lam21
    F1 -&gt; Sent.Completion,                lam31
    F2 -&gt; First.Letters,                  lam42
    F2 -&gt; 4.Letter.Words,                 lam52
    F2 -&gt; Suffixes,                       lam62
    F3 -&gt; Letter.Series,                  lam73
    F3 -&gt; Pedigrees,                      lam83
    F3 -&gt; Letter.Group,                   lam93
    F4 -&gt; F1,                             gam1
    F4 -&gt; F2,                             gam2
    F4 -&gt; F3,                             gam3
    F1 &lt;-&gt; F1,                            NA,     1
    F2 &lt;-&gt; F2,                            NA,     1
    F3 &lt;-&gt; F3,                            NA,     1
    F4 &lt;-&gt; F4,                            NA,     1

sem.thur &lt;- sem(model.thur, R.thur, 213)
summary(sem.thur)

# The model in equation format:

model.thur &lt;- specifyEquations()
Sentences = lam11*F1
Vocabulary = lam21*F1
Sent.Completion = lam31*F1
First.Letters = lam42*F2
4.Letter.Words = lam52*F2
Suffixes = lam62*F2
Letter.Series = lam73*F3
Pedigrees = lam83*F3
Letter.Group = lam93*F3
F1 = gam1*F4
F2 = gam2*F4
F3 = gam3*F4
V(F1) = 1
V(F2) = 1
V(F3) = 1
V(F4) = 1


#------------------------- Kerchoff/Kenney path analysis ---------------------
# An observed-variable recursive SEM from the LISREL manual

R.kerch &lt;- readMoments(diag=FALSE, names=c('Intelligence','Siblings',
                        'FatherEd','FatherOcc','Grades','EducExp','OccupAsp'))
    -.100                                
     .277  -.152                          
     .250  -.108  .611                     
     .572  -.105  .294   .248               
     .489  -.213  .446   .410   .597         
     .335  -.153  .303   .331   .478   .651   
    
model.kerch &lt;- specifyModel()
    Intelligence -&gt; Grades,       gam51
    Siblings -&gt; Grades,           gam52
    FatherEd -&gt; Grades,           gam53
    FatherOcc -&gt; Grades,          gam54
    Intelligence -&gt; EducExp,      gam61
    Siblings -&gt; EducExp,          gam62
    FatherEd -&gt; EducExp,          gam63
    FatherOcc -&gt; EducExp,         gam64
    Grades -&gt; EducExp,            beta65
    Intelligence -&gt; OccupAsp,     gam71
    Siblings -&gt; OccupAsp,         gam72
    FatherEd -&gt; OccupAsp,         gam73
    FatherOcc -&gt; OccupAsp,        gam74
    Grades -&gt; OccupAsp,           beta75
    EducExp -&gt; OccupAsp,          beta76
                       
sem.kerch &lt;- sem(model.kerch, R.kerch, 737, 
    fixed.x=c('Intelligence', 'Siblings', 'FatherEd', 'FatherOcc'))
summary(sem.kerch)

# The model in equation format:

model.kerch &lt;- specifyEquations()
Grades = gam51*Intelligence + gam52*Siblings + gam53*FatherEd 
           + gam54*FatherOcc
EducExp = gam61*Intelligence + gam62*Siblings + gam63*FatherEd 
            + gam64*FatherOcc + beta65*Grades
OccupAsp = gam71*Intelligence + gam72*Siblings + gam73*FatherEd 
            + gam74*FatherOcc + beta75*Grades + beta76*EducExp


#------------------- McArdle/Epstein latent-growth-curve model -----------------
# This model, from McArdle and Epstein (1987, p.118), illustrates the use of a 
# raw moment matrix to fit a model with an intercept. (The example was suggested
# by Mike Stoolmiller.)

M.McArdle &lt;- readMoments(
    names=c('WISC1', 'WISC2', 'WISC3', 'WISC4', 'UNIT'))
    365.661                                      
    503.175     719.905                           
    675.656     958.479    1303.392                
    890.680    1265.846    1712.475    2278.257     
     18.034      25.819      35.255      46.593     1.000
 
mod.McArdle &lt;- specifyModel()
    C -&gt; WISC1, NA, 6.07
    C -&gt; WISC2, B2, NA
    C -&gt; WISC3, B3, NA
    C -&gt; WISC4, B4, NA
    UNIT -&gt; C, Mc, NA
    C &lt;-&gt; C, Vc, NA,
    WISC1 &lt;-&gt; WISC1, Vd, NA
    WISC2 &lt;-&gt; WISC2, Vd, NA
    WISC3 &lt;-&gt; WISC3, Vd, NA
    WISC4 &lt;-&gt; WISC4, Vd, NA

sem.McArdle &lt;- sem(mod.McArdle, M.McArdle, 204, fixed.x="UNIT", raw=TRUE)
summary(sem.McArdle)

# The model in equation format:

mod.McArdle &lt;- specifyEquations()
WISC1 = 6.07*C
WISC2 = B2*C
WISC3 = B3*C
WISC4 = b4*C
C = Mc*UNIT
v(C) = Vc
v(WISC1) = Vd
v(WISC2) = Vd
v(WISC3) = Vd
v(WISC4) = Vd

    
#------------ Bollen industrialization and democracy example -----------------
# This model, from Bollen (1989, Ch. 8), illustrates the use in sem() of a
# case-by-variable data (see ?Bollen) set rather than a covariance or moment matrix

model.bollen &lt;- specifyModel()
	Demo60 -&gt; y1, NA, 1
	Demo60 -&gt; y2, lam2, 
	Demo60 -&gt; y3, lam3, 
	Demo60 -&gt; y4, lam4, 
	Demo65 -&gt; y5, NA, 1
	Demo65 -&gt; y6, lam2, 
	Demo65 -&gt; y7, lam3, 
	Demo65 -&gt; y8, lam4, 
	Indust -&gt; x1, NA, 1
	Indust -&gt; x2, lam6, 
	Indust -&gt; x3, lam7, 
	y1 &lt;-&gt; y5, theta15
	y2 &lt;-&gt; y4, theta24
	y2 &lt;-&gt; y6, theta26
	y3 &lt;-&gt; y7, theta37
	y4 &lt;-&gt; y8, theta48
	y6 &lt;-&gt; y8, theta68
	Indust -&gt; Demo60, gamma11, 
	Indust -&gt; Demo65, gamma21, 
	Demo60 -&gt; Demo65, beta21, 
	Indust &lt;-&gt; Indust, phi
	
sem.bollen &lt;- sem(model.bollen, data=Bollen)
summary(sem.bollen)
summary(sem.bollen, robust=TRUE) # robust SEs and tests
summary(sem.bollen, analytic.se=FALSE) # uses numeric rather than analytic Hessian

  # GLS rather than ML estimator:
sem.bollen.gls &lt;- sem(model.bollen, data=Bollen, objective=objectiveGLS) 
summary(sem.bollen.gls)

# The model in equation format:

model.bollen &lt;- specifyEquations()
y1 = 1*Demo60
y2 = lam2*Demo60
y3 = lam3*Demo60
y4 = lam4*Demo60
y5 = 1*Demo65
y6 = lam2*Demo65
y7 = lam3*Demo65
y8 = lam4*Demo65
x1 = 1*Indust
x2 = lam6*Indust
x3 = lam7*Indust
c(y1, y5) = theta15
c(y2, y4) = theta24
c(y2, y6) = theta26
c(y3, y7) = theta37
c(y4, y8) = theta48
c(y6, y8) = theta68
Demo60 = gamma11*Indust
Demo65 = gamma21*Indust + beta21*Demo60
v(Indust) = phi


# -------------- A simple CFA model for the Thurstone mental tests data --------------

R.thur &lt;- readMoments(diag=FALSE, 
  names=c('Sentences','Vocabulary',
          'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
          'Letter.Series','Pedigrees', 'Letter.Group'))
.828                                              
.776   .779                                        
.439   .493    .46                                 
.432   .464    .425   .674                           
.447   .489    .443   .59    .541                    
.447   .432    .401   .381    .402   .288              
.541   .537    .534   .35    .367   .32   .555        
.38   .358    .359   .424    .446   .325   .598   .452

	#  (1) in CFA format:

mod.cfa.thur.c &lt;- cfa(reference.indicators=FALSE)
FA: Sentences, Vocabulary, Sent.Completion
FB: First.Letters, 4.Letter.Words, Suffixes
FC: Letter.Series, Pedigrees, Letter.Group

cfa.thur.c &lt;- sem(mod.cfa.thur.c, R.thur, 213)
summary(cfa.thur.c)

	#  (2) in equation format:

mod.cfa.thur.e &lt;- specifyEquations(covs="F1, F2, F3")
Sentences = lam11*F1
Vocabulary = lam21*F1
Sent.Completion = lam31*F1
First.Letters = lam42*F2
4.Letter.Words = lam52*F2
Suffixes = lam62*F2
Letter.Series = lam73*F3
Pedigrees = lam83*F3
Letter.Group = lam93*F3
V(F1) = 1
V(F2) = 1
V(F3) = 1

cfa.thur.e &lt;- sem(mod.cfa.thur.e, R.thur, 213)
summary(cfa.thur.e)

	#  (3) in path format:

mod.cfa.thur.p &lt;- specifyModel(covs="F1, F2, F3")
F1 -&gt; Sentences,                      lam11
F1 -&gt; Vocabulary,                     lam21
F1 -&gt; Sent.Completion,                lam31
F2 -&gt; First.Letters,                  lam41
F2 -&gt; 4.Letter.Words,                 lam52
F2 -&gt; Suffixes,                       lam62
F3 -&gt; Letter.Series,                  lam73
F3 -&gt; Pedigrees,                      lam83
F3 -&gt; Letter.Group,                   lam93
F1 &lt;-&gt; F1,                            NA,     1
F2 &lt;-&gt; F2,                            NA,     1
F3 &lt;-&gt; F3,                            NA,     1

cfa.thur.p &lt;- sem(mod.cfa.thur.p, R.thur, 213)
summary(cfa.thur.p)

# -----  a CFA model fit by FIML to the mental-tests dataset with missing data -----

mod.cfa.tests &lt;- cfa(raw=TRUE)
verbal: x1, x2, x3
math: y1, y2, y3

cfa.tests &lt;- sem(mod.cfa.tests, data=Tests, na.action=na.pass, 
                objective=objectiveFIML, fixed.x="Intercept")
summary(cfa.tests)
summary(cfa.tests, saturated=TRUE) # takes time to fit saturated model for comparison


# ---  a multigroup CFA model fit to the Holzinger-Swineford mental-tests data  -----

mod.hs &lt;- cfa()
spatial: visual, cubes, paper, flags
verbal: general, paragrap, sentence, wordc, wordm
memory: wordr, numberr, figurer, object, numberf, figurew
math: deduct, numeric, problemr, series, arithmet

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg)

	# with cross-group equality constraints:
	
mod.mg.eq &lt;- multigroupModel(mod.hs, groups=c("Female", "Male"), allEqual=TRUE)

sem.mg.eq &lt;- sem(mod.mg.eq, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
                general + paragrap + sentence + wordc + wordm +
                wordr + numberr + figurer + object + numberf + figurew +
                deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg.eq)

anova(sem.mg, sem.mg.eq) # test equality constraints
	
## End(Not run)

## ===============================================================================
	
# The following examples use file input and may be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files

#   to get all fit indices (not recommended, but for illustration):

opt &lt;- options(fit.indices = c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", 
         "CFI", "RNI", "IFI", "SRMR", "AIC", "AICc", "BIC", "CAIC"))

# ------------- Duncan, Haller and Portes peer-influences model ----------------------
# A nonrecursive SEM with unobserved endogenous variables and fixed exogenous variables

(R.DHP &lt;- readMoments(file=file.path(etc, "R-DHP.txt"),
				diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp")))
(model.dhp &lt;- specifyModel(file=file.path(etc, "model-DHP.txt")))
sem.dhp.1 &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)


# -------------------- Wheaton et al. alienation data ----------------------

(S.wh &lt;- readMoments(file=file.path(etc, "S-Wheaton.txt"),
					names=c('Anomia67','Powerless67','Anomia71',
                            'Powerless71','Education','SEI')))

# This is the model in the SAS manual for PROC CALIS: A Recursive SEM with
# latent endogenous and exogenous variables.
# Curiously, both factor loadings for two of the latent variables are fixed.

(model.wh.1 &lt;- specifyModel(file=file.path(etc, "model-Wheaton-1.txt")))                    
sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932)
summary(sem.wh.1)

# The same model, but treating one loading for each latent variable as free
# (and equal to each other).

(model.wh.2 &lt;- specifyModel(file=file.path(etc, "model-Wheaton-2.txt")))
sem.wh.2 &lt;- sem(model.wh.2, S.wh, 932)
summary(sem.wh.2)

# Compare the two models by a likelihood-ratio test:

anova(sem.wh.1, sem.wh.2)


# ----------------------- Thurstone data ---------------------------------------

#  Second-order confirmatory factor analysis, from the SAS manual for PROC CALIS

(R.thur &lt;- readMoments(file=file.path(etc, "R-Thurstone.txt"),
		diag=FALSE, names=c('Sentences','Vocabulary',
        'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
        'Letter.Series','Pedigrees', 'Letter.Group')))
(model.thur &lt;- specifyModel(file=file.path(etc, "model-Thurstone.txt")))
sem.thur &lt;- sem(model.thur, R.thur, 213)
summary(sem.thur)


#------------------------- Kerchoff/Kenney path analysis ---------------------

# An observed-variable recursive SEM from the LISREL manual

(R.kerch &lt;- readMoments(file=file.path(etc, "R-Kerchoff.txt"),
					   diag=FALSE, names=c('Intelligence','Siblings',
                        'FatherEd','FatherOcc','Grades','EducExp','OccupAsp')))
(model.kerch &lt;- specifyModel(file=file.path(etc, "model-Kerchoff.txt")))
sem.kerch &lt;- sem(model.kerch, R.kerch, 737, 
    fixed.x=c('Intelligence', 'Siblings', 'FatherEd', 'FatherOcc'))
summary(sem.kerch)


#------------------- McArdle/Epstein latent-growth-curve model -----------------

# This model, from McArdle and Epstein (1987, p.118), illustrates the use of a 
# raw moment matrix to fit a model with an intercept. (The example was suggested
# by Mike Stoolmiller.)

(M.McArdle &lt;- readMoments(file=file.path(etc, "M-McArdle.txt"),
    names=c('WISC1', 'WISC2', 'WISC3', 'WISC4', 'UNIT')))
(mod.McArdle &lt;- specifyModel(file=file.path(etc, "model-McArdle.txt")))
sem.McArdle &lt;- sem(mod.McArdle, M.McArdle, 204, fixed.x="UNIT", raw=TRUE)
summary(sem.McArdle)


#------------ Bollen industrialization and democracy example -----------------

# This model, from Bollen (1989, Ch. 8), illustrates the use in sem() of a
# case-by-variable data set (see ?Bollen) rather than a covariance or moment matrix

(model.bollen &lt;- specifyModel(file=file.path(etc, "model-Bollen.txt")))
sem.bollen &lt;- sem(model.bollen, data=Bollen)
summary(sem.bollen)
summary(sem.bollen, robust=TRUE) # robust SEs and tests
summary(sem.bollen, analytic.se=FALSE) # uses numeric rather than analytic Hessian

  # GLS rather than ML estimator:
sem.bollen.gls &lt;- sem(model.bollen, data=Bollen, objective=objectiveGLS) 
summary(sem.bollen.gls)

# -----  a CFA model fit by FIML to the mental-tests dataset with missing data -----

(mod.cfa.tests &lt;- cfa(file=file.path(etc, "model-Tests.txt"), raw=TRUE))
cfa.tests &lt;- sem(mod.cfa.tests, data=Tests, na.action=na.pass, 
                optimizer=optimizerNlm, objective=objectiveFIML, fixed.x="Intercept")
summary(cfa.tests)

#------------ Holzinger and Swineford muiltigroup CFA example ----------------

mod.hs &lt;- cfa(file=file.path(etc, "model-HS.txt"))

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg)

	# with cross-group equality constraints:
	
mod.mg.eq &lt;- multigroupModel(mod.hs, groups=c("Female", "Male"), allEqual=TRUE)

sem.mg.eq &lt;- sem(mod.mg.eq, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
                general + paragrap + sentence + wordc + wordm +
                wordr + numberr + figurer + object + numberf + figurew +
                deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg.eq)

anova(sem.mg, sem.mg.eq) # test equality constraints

options(opt) # restore fit.indices option

</code></pre>


</div>