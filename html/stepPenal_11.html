<div class="container">

<table style="width: 100%;"><tr>
<td>tuneParam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tune parameters w and lamda using the CL penalty</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation with the function optimPenalLik and returns
the values of lamda and w that maximize the area under the ROC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tuneParam(Data, nfolds = nfolds, grid, algorithm = c("hjk", "QN"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Data</code></td>
<td>
<p>a data frame, as a first column should have the response variable y and the other columns the predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>the number of folds used for cross-validation. OBS! nfolds&gt;=2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a grid (data frame) with values of lamda and w that will be used for tuning
to tune the model. It is created by expand.grid see example below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>choose between BFGS ("QN") and hjk (Hooke-Jeeves optimization free) to be used for optmization</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It supports the BFGS optimization method ('QN') from the optim stats function, the Hooke-Jeeves derivative-free
minimization algorithm ('hjk')
The value of lamda and w that yield the maximum AUC on the
cross-validating data set is selected.
</p>


<h3>Value</h3>

<p>A matrix with the following: the average (over folds) cross-validated AUC, the totalVariables selected on the training set,
and the standard deviation of the AUC over the nfolds.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
set.seed(14)
beta    &lt;- c(3, 2, -1.6, -4)
noise   &lt;- 5
simData &lt;- SimData(N=100, beta=beta, noise=noise, corr=TRUE)

nfolds  &lt;- 3
grid &lt;- expand.grid(w = c( 0.3, 0.7),
                   lamda = c(1.5))

before &lt;- Sys.time()
paramCV &lt;- tuneParam(simData, nfolds, grid, algorithm=c("QN"))
(totalTime &lt;- Sys.time() - before)


maxAUC    &lt;- paramCV[which.max(paramCV$AUC),]$AUC
allmaxAUC &lt;- paramCV[which(paramCV$AUC==maxAUC),] # checks if the value of AUC
# is unique; if is not unique then it will take the combination of lamda and
# w where lamda has the largest value- thus achieving higher sparsity

runQN   &lt;- optimPenaLik(simData, lamda= allmaxAUC[nrow(allmaxAUC),]$lamda,
                         w= allmaxAUC[nrow(allmaxAUC),]$w,
                         algorithms=c("QN"))
(coefQN  &lt;- runQN$varQN)


# check the robustness of the choice of lamda

runQN2   &lt;- optimPenaLik(simData, lamda= allmaxAUC[1,]$lamda,
                         w= allmaxAUC[1,]$w,
                         algorithms=c("QN"))
(coefQN2  &lt;- runQN2$varQN)


## End(Not run)
</code></pre>


</div>