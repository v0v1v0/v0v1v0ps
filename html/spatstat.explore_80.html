<div class="container">

<table style="width: 100%;"><tr>
<td>compileK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generic Calculation of K Function and Pair Correlation Function
</h2>

<h3>Description</h3>

<p>Low-level functions which 
calculate the estimated <code class="reqn">K</code> function
and estimated pair correlation function
(or any similar functions)
from a matrix of pairwise distances and optional weights.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compileK(D, r, weights = NULL, denom = 1,
         check = TRUE, ratio = FALSE, fname = "K",
         samplesize=denom)

compilepcf(D, r, weights = NULL, denom = 1,
         check = TRUE, endcorrect = TRUE, ratio=FALSE,
	 ..., fname = "g", samplesize=denom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>

<p>A square matrix giving the distances between all pairs of points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>An equally spaced, finely spaced sequence of distance values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional numerical weights for the pairwise distances.
A numeric matrix with the same dimensions as <code>D</code>.
If absent, the weights are taken to equal 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denom</code></td>
<td>

<p>Denominator for the estimator.
A single number, or a numeric vector with the same length
as <code>r</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>

<p>Logical value specifying whether to check that <code>D</code> is a
valid matrix of pairwise distances.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>

<p>Logical value indicating whether to store ratio information.
See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Optional arguments passed to <code>density.default</code>
controlling the kernel smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endcorrect</code></td>
<td>

<p>Logical value indicating whether to apply End Correction of
the pair correlation estimate at <code>r=0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fname</code></td>
<td>

<p>Character string giving the name of the function being estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplesize</code></td>
<td>

<p>The sample size that should be used as the denominator when
<code>ratio=TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These low-level functions construct estimates of
the <code class="reqn">K</code> function or pair correlation function,
or any similar functions, given only the matrix of pairwise
distances and optional weights associated with these distances.
</p>
<p>These functions are useful for code development and for teaching,
because they perform a common task, and do the housekeeping required to
make an object of class <code>"fv"</code> that represents the estimated
function. However, they are not very efficient. 
</p>
<p><code>compileK</code> calculates the weighted estimate
of the <code class="reqn">K</code> function,
</p>
<p style="text-align: center;"><code class="reqn">
    \hat K(r) = (1/v(r)) \sum_i \sum_j 1\{ d_{ij} \le r\} w_{ij}
  </code>
</p>

<p>and <code>compilepcf</code> calculates the weighted estimate of the
pair correlation function,
</p>
<p style="text-align: center;"><code class="reqn">
    \hat g(r) = (1/v(r)) \sum_i \sum_j \kappa( d_{ij} - r ) w_{ij}
  </code>
</p>

<p>where <code class="reqn">d_{ij}</code> is the distance between spatial points
<code class="reqn">i</code> and <code class="reqn">j</code>, with corresponding weight <code class="reqn">w_{ij}</code>,
and <code class="reqn">v(r)</code> is a specified denominator. Here <code class="reqn">\kappa</code>
is a fixed-bandwidth smoothing kernel. 
</p>
<p>For a point pattern in two dimensions, the usual denominator <code class="reqn">v(r)</code>
is constant for the <code class="reqn">K</code> function, and proportional to <code class="reqn">r</code>
for the pair correlation function. See the Examples.
</p>
<p>The result is an object of class <code>"fv"</code> representing the
estimated function. This object has only one column of function
values. Additional columns (such as a column giving the theoretical
value) must be added by the user, with the aid of
<code>bind.fv</code>.
</p>
<p>If <code>ratio=TRUE</code>, the result also belongs to class <code>"rat"</code>
and has attributes containing the numerator and denominator
of the function estimate.
(If <code>samplesize</code> is given, the numerator and denominator are
rescaled by a common factor so that the denominator is
equal to <code>samplesize</code>.)
This allows function estimates from
several datasets to be pooled using <code>pool</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> representing the estimated function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>Kest</code>,
<code>pcf</code> for definitions of the <code class="reqn">K</code> function
and pair correlation function.
</p>
<p><code>bind.fv</code> to add more columns.
</p>
<p><code>compileCDF</code> for the corresponding low-level utility
for estimating a cumulative distribution function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## Equivalent to Kest(japanesepines) and pcf(japanesepines)
  X &lt;- japanesepines
  D &lt;- pairdist(X)
  Wt &lt;- edge.Ripley(X, D)
  lambda &lt;- intensity(X)
  a &lt;- (npoints(X)-1) * lambda
  r &lt;- seq(0, 0.25, by=0.01)
  K &lt;- compileK(D=D, r=r, weights=Wt, denom=a)
  g &lt;- compilepcf(D=D, r=r, weights=Wt, denom= a * 2 * pi * r)
</code></pre>


</div>