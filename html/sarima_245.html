<div class="container">

<table style="width: 100%;"><tr>
<td>SarimaModel-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class SarimaModel in package sarima</h2>

<h3>Description</h3>

<p>Class SarimaModel in package sarima.</p>


<h3>Objects from the Class</h3>

<p>Class <code>"SarimaModel"</code> represents standard SARIMA models.  Objects
can be created by calls of the form
<code>new("SarimaModel", ..., ar, ma, sar, sma)</code>,
using named arguments in the form <code>slotname = value</code>, where
<code>slotname</code> is one of the slots, see below.  The arguments have
natural defaults. It may be somewhat surprising though that the
default for the variance of the innovations (slot <code>"sigma2"</code>) is
<code>NA</code>. The rationale for this choice is that for some calculations
the innovations' variance is not needed and, more importantly, it is
far too easy to forget to include it in the model (at least for the
author) when the variance matters. The latter may may lead silently to
wrong results if the "natural" default value of one is used when
<code>sigma2</code> matters.
</p>
<p>The models may be specified in intercept (<code>center = 0</code>) or
mean-corrected (<code>intercept = 0</code>) form. Setting both to non-zero
values is accepted but rarely needed.
</p>
<p>If you waih to modify an existing object from class
<code>"SarimaModel"</code>, give it as an unnamed argument to <code>"new"</code>
and specify only the slots to be changed, see the examples.
</p>
<p>Use <code>as.SarimaModel</code> to convert a model fitted with
<code>stats::arima()</code> to <code>"SarimaModel"</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>center</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
a number, the ARIMA equation is for <code>X(t) - center</code>.
</p>
</dd>
<dt>
<code>intercept</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
a number, the intercept in the ARIMA equation.
</p>
</dd>
<dt>
<code>sigma2</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
a positive number, the innovations variance.
</p>
</dd>
<dt>
<code>nseasons</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
a positive integer, the number of seasons. For non-seasonal models
this is NA.
</p>
</dd>
<dt>
<code>iorder</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
non-negative integer, the integration order.
</p>
</dd>
<dt>
<code>siorder</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>,
non-negative integer, the seasonal integration order.
</p>
</dd>
<dt>
<code>ar</code>:</dt>
<dd>
<p>Object of class <code>"BJFilter"</code>,
the non-seasonal AR part of the model.
</p>
</dd>
<dt>
<code>ma</code>:</dt>
<dd>
<p>Object of class <code>"SPFilter"</code>,
the non-seasonal MA part of the model.
</p>
</dd>
<dt>
<code>sar</code>:</dt>
<dd>
<p>Object of class <code>"BJFilter"</code>,
the seasonal AR part of the model.
</p>
</dd>
<dt>
<code>sma</code>:</dt>
<dd>
<p>Object of class <code>"SPFilter"</code>,
the seasonal MA part of the model.
</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"VirtualFilterModel"</code>, directly.
Class <code>"SarimaSpec"</code>, directly.
Class <code>"SarimaFilter"</code>, by class "SarimaSpec", distance 2.
Class <code>"VirtualSarimaFilter"</code>, by class "SarimaSpec", distance 3.
Class <code>"VirtualCascadeFilter"</code>, by class "SarimaSpec", distance 4.
Class <code>"VirtualMonicFilter"</code>, by class "SarimaSpec", distance 5.
</p>


<h3>Methods</h3>

<p>SARIMA models contain as special cases a number of models.
The one-argument method of <code>modelCoef</code> is essentially a
definition of model coefficients for SARIMA models. The two-argument
methods request the model coefficients according to the convention of
the class of the second argument. The second argument may also be a
character string naming the target class.
</p>
<p>Essentially, the methods for <code>modelCoef</code> are a generalisation of
<code>as()</code> methods and can be interpreted as such (to an extent, the
result is not necessarilly from the target class, not least because
the target class may be virtual).
</p>

<dl>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Converts <code>object</code> to "SarimaFilter".
</p>
</dd>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "SarimaFilter")</code>:
Converts <code>object</code> to "SarimaFilter", equivalent to the
one-argument call <code>modelCoef(object)</code>.
</p>
</dd>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention	= "ArFilter")</code>:
Convert <code>object</code> to "ArFilter". An error is raised if
<code>object</code> has non-trivial moving average part.
</p>
</dd>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention	= "MaFilter")</code>:
Convert <code>object</code> to "MaFilter". An error is raised if
<code>object</code> has non-trivial autoregressive part.
</p>
</dd>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention	= "ArmaFilter")</code>:
Convert <code>object</code> to "ArmaFilter". This operation always successeds.
</p>
</dd>
<dt>modelCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention	= "character")</code>:
The second argument gives the name of the target class.
This is conceptually equivalent to <code>modelCoef(object, new(convention))</code>.
</p>
</dd>
</dl>
<p><code>modelOrder</code> gives the order of the model according to the
conventions of the target class. An error is raised if <code>object</code>
is not compatible with the target class.
</p>

<dl>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArmaModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "MaFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "MaModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "missing")</code>: ... </p>
</dd>
</dl>
<p>The polynomials associated with <code>object</code> can be obtained with the
following methods. Note that target "ArmaFilter" gives the fully
expanded products of the AR and MA polynomials, as needed, e.g., for
filtering.
</p>

<dl>
<dt>modelPoly</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>:
'      Gives the fully expanded polynomials as a list
</p>
</dd>
<dt>modelPoly</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Gives the polynomials associated with the model as a list.
</p>
</dd>
<dt>modelPolyCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>:
Give the coefficients of the fully expanded polynomials as a list.
</p>
</dd>
<dt>modelPolyCoef</dt>
<dd>
<p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Gives the coefficients of the polynomials associated with the model as a list.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>ArmaModel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ar1 &lt;- new("SarimaModel", ar = 0.9)
ar1c &lt;- new("SarimaModel", ar = 0.9, intercept = 3)
ar1c
ar1m &lt;- new("SarimaModel", ar = 0.9, center = 1)
ar1m

sm0 &lt;- new("SarimaModel", nseasons = 12)
sm1 &lt;- new("SarimaModel", nseasons = 12, intercept = 3)
sm1
## alternatively, pass a model and modify with named arguments
sm1b &lt;- new("SarimaModel", sm0, intercept = 3)
identical(sm1, sm1b) # TRUE

## in the above models sigma2 is NA

## sm2 - from scratch, the rest modefy an existing model
sm2  &lt;- new("SarimaModel", ar = 0.9, nseasons = 12, intercept = 3, sigma2 = 1)
sm2a &lt;- new("SarimaModel", sm0, ar = 0.9, intercept = 3, sigma2 = 1)
sm2b &lt;- new("SarimaModel", sm1, ar = 0.9, sigma2 = 1)
sm2c &lt;- new("SarimaModel", ar1c, nseasons =12, sigma2 = 1)
identical(sm2, sm2a) # TRUE
identical(sm2, sm2b) # TRUE
identical(sm2, sm2c) # TRUE

sm3 &lt;- new("SarimaModel", ar = 0.9, sar = 0.8, nseasons = 12, intercept = 3,
           sigma2 = 1)
sm3b &lt;- new("SarimaModel", sm2, sar = 0.8)
identical(sm3, sm3b) # TRUE

## The classic 'airline model' (from examples for AirPassengers)
(fit &lt;- arima(log10(AirPassengers), c(0, 1, 1),
              seasonal = list(order = c(0, 1, 1), period = 12)))

as.SarimaModel(fit)
</code></pre>


</div>