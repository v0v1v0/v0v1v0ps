<div class="container">

<table style="width: 100%;"><tr>
<td>std</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standardize and center variables</h2>

<h3>Description</h3>

<p><code>std()</code> computes a z-transformation (standardized and centered)
on the input. <code>center()</code> centers the input. <code>std_if()</code> and
<code>center_if()</code> are scoped variants of <code>std()</code> and <code>center()</code>,
where transformation will be applied only to those variables that match the
logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">std(
  x,
  ...,
  robust = c("sd", "2sd", "gmd", "mad"),
  include.fac = FALSE,
  append = TRUE,
  suffix = "_z"
)

std_if(
  x,
  predicate,
  robust = c("sd", "2sd", "gmd", "mad"),
  include.fac = FALSE,
  append = TRUE,
  suffix = "_z"
)

center(x, ..., include.fac = FALSE, append = TRUE, suffix = "_c")

center_if(x, predicate, include.fac = FALSE, append = TRUE, suffix = "_c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>Character vector, indicating the method applied when
standardizing variables with <code>std()</code>. By default, standardization is
achieved by dividing the centered variables by their standard deviation
(<code>robust = "sd"</code>). However, for skewed distributions, the median
absolute deviation (MAD, <code>robust = "mad"</code>) or Gini's mean difference
(<code>robust = "gmd"</code>) might be more robust measures of dispersion. For
the latter option, <a href="https://CRAN.R-project.org/package=sjstats"><span class="pkg">sjstats</span></a> needs to be installed.
<code>robust = "2sd"</code> divides the centered variables by two standard
deviations, following a suggestion by <em>Gelman (2008)</em>, so the
rescaled input is comparable to binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.fac</code></td>
<td>
<p>Logical, if <code>TRUE</code>, factors will be converted to numeric
vectors and also standardized or centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>std()</code> and <code>center()</code> also work on grouped data frames
(see <code>group_by</code>). In this case, standardization
or centering is applied to the subsets of variables in <code>x</code>.
See 'Examples'.
<br><br>
For more complicated models with many predictors, Gelman and Hill (2007)
suggest leaving binary inputs as is and only standardize continuous predictors
by dividing by two standard deviations. This ensures a rough comparability
in the coefficients.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a vector, returns a vector with standardized or
centered variables. If <code>x</code> is a data frame, for <code>append = TRUE</code>,
<code>x</code> including the transformed variables as new columns is returned;
if <code>append = FALSE</code>, only the transformed variables will be returned.
If <code>append = TRUE</code> and <code>suffix = ""</code>, recoded variables will
replace (overwrite) existing variables.
</p>


<h3>Note</h3>

<p><code>std()</code> and <code>center()</code> only return a vector, if <code>x</code> is
a vector. If <code>x</code> is a data frame and only one variable is specified
in the <code>...</code>-ellipses argument, both functions do return a
data frame (see 'Examples').
</p>


<h3>References</h3>

<p>Gelman A (2008) Scaling regression inputs by dividing by two
standard deviations. <em>Statistics in Medicine 27: 2865-2873.</em>
<a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf</a>
<br><br>
Gelman A, Hill J (2007) Data Analysis Using Regression and Multilevel/Hierarchical
Models. Cambdridge, Cambdrige University Press: 55-57
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(efc)
std(efc$c160age) %&gt;% head()
std(efc, e17age, c160age, append = FALSE) %&gt;% head()

center(efc$c160age) %&gt;% head()
center(efc, e17age, c160age, append = FALSE) %&gt;% head()

# NOTE!
std(efc$e17age) # returns a vector
std(efc, e17age) # returns a data frame

# with quasi-quotation
x &lt;- "e17age"
center(efc, !!x, append = FALSE) %&gt;% head()

# works with mutate()
library(dplyr)
efc %&gt;%
  select(e17age, neg_c_7) %&gt;%
  mutate(age_std = std(e17age), burden = center(neg_c_7)) %&gt;%
  head()

# works also with grouped data frames
mtcars %&gt;% std(disp)

# compare new column "disp_z" w/ output above
mtcars %&gt;%
  group_by(cyl) %&gt;%
  std(disp)

data(iris)
# also standardize factors
std(iris, include.fac = TRUE, append = FALSE)
# don't standardize factors
std(iris, include.fac = FALSE, append = FALSE)

# standardize only variables with more than 10 unique values
p &lt;- function(x) dplyr::n_distinct(x) &gt; 10
std_if(efc, predicate = p, append = FALSE)

</code></pre>


</div>