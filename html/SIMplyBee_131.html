<div class="container">

<table style="width: 100%;"><tr>
<td>getCastePop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Access individuals of a caste</h2>

<h3>Description</h3>

<p>Level 1 function that returns individuals of a caste. These
individuals stay in the colony (compared to <code>pullCastePop</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">getCastePop(
  x,
  caste = "all",
  nInd = NULL,
  use = "rand",
  removeFathers = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getQueen(x, collapse = FALSE, simParamBee = NULL)

getFathers(x, nInd = NULL, use = "rand", collapse = FALSE, simParamBee = NULL)

getWorkers(x, nInd = NULL, use = "rand", collapse = FALSE, simParamBee = NULL)

getDrones(
  x,
  nInd = NULL,
  use = "rand",
  removeFathers = TRUE,
  collapse = FALSE,
  simParamBee = NULL
)

getVirginQueens(
  x,
  nInd = NULL,
  use = "rand",
  collapse = FALSE,
  simParamBee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>Colony-class</code> or <code>MultiColony-class</code>,
exceptionally <code>Pop-class</code> for calling <code>getFathers</code>
on a queen population</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caste</code></td>
<td>
<p>character, "queen", "fathers", "workers", "drones",
"virginQueens", or "all"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nInd</code></td>
<td>
<p>numeric, number of individuals to access, if <code>NULL</code> all
individuals are accessed; if there are less individuals than requested,
we return the ones available - this can return <code>NULL</code>.
If input is <code>MultiColony-class</code>,
the input could also be a vector of the same length as the number of colonies. If
a single value is provided, the same value will be applied to all the colonies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use</code></td>
<td>
<p>character, all options provided by <code>selectInd</code> and
<code>"order"</code> that selects <code>1:nInd</code> individuals (meaning it always
returns at least one individual, even if <code>nInd = 0</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeFathers</code></td>
<td>
<p>logical, removes <code>drones</code> that have already mated;
set to <code>FALSE</code> if you would like to get drones for mating with multiple
virgin queens, say via insemination</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>logical, whether to return a single merged population</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simParamBee</code></td>
<td>
<p><code>SimParamBee</code>, global simulation parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>when <code>x</code> is <code>Colony-class</code> return is
<code>Pop-class</code> for <code>caste != "all"</code> or list for <code>caste
  == "all"</code> with nodes named by caste; when <code>x</code> is
<code>MultiColony-class</code> return is a named list of
<code>Pop-class</code> for <code>caste != "all"</code> or named list of lists of
<code>Pop-class</code> for <code>caste == "all"</code>. You can merge
all the populations in the list with <code>mergePops</code> function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getQueen()</code>: Access the queen
</p>
</li>
<li> <p><code>getFathers()</code>: Access fathers (drones the queen mated with)
</p>
</li>
<li> <p><code>getWorkers()</code>: Access workers
</p>
</li>
<li> <p><code>getDrones()</code>: Access drones
</p>
</li>
<li> <p><code>getVirginQueens()</code>: Access virgin queens
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>getQueen</code>, <code>getFathers</code>,
<code>getVirginQueens</code>, <code>getWorkers</code>, and
<code>getDrones</code>
</p>
<p><code>getCasteId</code> and <code>getCaste</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])

# Build-up and add virgin queens
colony &lt;- buildUp(x = colony)
apiary &lt;- buildUp(x = apiary)
colony &lt;- addVirginQueens(x = colony)
apiary &lt;- addVirginQueens(x = apiary)

# Get the queen of the colony
getCastePop(colony, caste = "queen")
getQueen(colony)

# Comparison of getCastePop() and getWorkers()
getCastePop(colony, caste = "workers")
getCastePop(colony, caste = "workers")
getCastePop(colony, caste = "workers", nInd = 2)
# Or aliases
getWorkers(colony)
# Same aliases exist for all the castes!

# Input is a MultiColony class - same behaviour as for the Colony!
getCastePop(apiary, caste = "queen")
# Or alias
getQueen(apiary)

# Sample individuals from all the castes
getCastePop(colony, nInd = 5, caste = "all")

# Get different number of workers per colony
getCastePop(apiary, caste = "workers", nInd = c(10, 20))
# Or alias
getWorkers(apiary, nInd = c(10, 20))

# Obtain individuals from MultiColony as a single population
getCastePop(apiary, caste = "queen", collapse = TRUE)
getQueen(apiary, collapse = TRUE)
getWorkers(apiary, nInd = 10, collapse = TRUE)
getDrones(apiary, nInd = 3, collapse = TRUE)
</code></pre>


</div>