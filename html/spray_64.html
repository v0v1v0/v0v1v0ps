<div class="container">

<table style="width: 100%;"><tr>
<td>pmax</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel maxima and minima for sprays</h2>

<h3>Description</h3>

<p>Parallel (pairwise) maxima and minima for sprays. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">maxpair_spray(S1,S2)
minpair_spray(S1,S2)
## S3 method for class 'spray'
pmax(x, ...)
## S3 method for class 'spray'
pmin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,S1,S2</code></td>
<td>
<p>Spray objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>spray objects to be compared</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>maxpair_spray()</code> finds the pairwise maximum for two
sprays.  Specifically, if <code>S3 &lt;- maxpair_spray(S1,S2)</code>, then
<code>S3[v] == max(S1[v],S2[v])</code> for every index vector <code>v</code>.
</p>
<p>Function <code>pmax.spray()</code> is the method for the generic
<code>pmax()</code>, which takes any number of arguments.  If <code>S3 &lt;-
maxpair_spray(S1,S2,...)</code>, then <code>S3[v] == max(S1[v],S2[v],...)</code> for
every index vector <code>v</code>.
</p>
<p>Function <code>pmax.spray()</code> operates right-associatively:
</p>
<p><code>pmax(S1,S2,S3,S4) == f(S1,f(S2,f(S3,S4)))</code> where <code>f()</code> is
short for <code>maxpair_spray()</code>.  So if performance is important, put
the smallest spray (in terms of number of nonzero entries) last.
</p>
<p>In these functions, a scalar is interpreted as a sort of global maximum.
Thus if <code>S3 &lt;- pmax(S,x)</code> we have <code>S3[v] == max(S[v],x)</code> for
every index <code>v</code>.  Observe that this operation is not defined if
<code>x&gt;0</code>, for then there would be an infinity of <code>v</code> for which
<code>S3[v] != 0</code>, an impossibility (or at least counter to the
principles of a sparse array).  The <a href="https://CRAN.R-project.org/package=frab"><span class="pkg">frab</span></a> package discussses
this issue in vignette <code>inst/wittgenstein.Rmd</code>.  Note also that
<code>x</code> cannot have length <code class="reqn">&gt;1</code> as the elements of a spray
object are stored in an arbitrary order, following <code>disordR</code>
discipline.
</p>
<p>Functions <code>minpair_spray()</code> and <code>pmin.spray()</code> are analogous.
Note that <code>minpair_spray(S1,S2)</code> is algebraically equivalent to
<code>-pmax_spray(-S1,-S2)</code>; see the examples.
</p>
<p>The value of <code>pmax(S)</code> is problematic.  Suppose
<code>all(coeffs(S)&lt;0)</code>; the current implementation returns
<code>pmax(S)==S</code> but there is a case for returning the null polynomial.
</p>


<h3>Value</h3>

<p>Returns a spray object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">
S1 &lt;- rspray(100,vals=sample(100)-50)
S2 &lt;- rspray(100,vals=sample(100)-50)
S3 &lt;- rspray(100,vals=sample(100)-50)


# following comparisons should all be TRUE:

jj &lt;- pmax(S1,S2,S3)
jj ==  maxpair_spray(S1,maxpair_spray(S2,S3))
jj ==  maxpair_spray(maxpair_spray(S1,S2),S3)

pmax(S1,S2,S3)  == -pmin(-S1,-S2,-S3)
pmin(S1,S2,S3)  == -pmax(-S1,-S2,-S3)

pmax(S1,-Inf) == S1
pmin(S1, Inf) == S2


pmax(S1,-3)

## Not run: 
pmax(S1,3) # not defined

## End(Not run)


</code></pre>


</div>