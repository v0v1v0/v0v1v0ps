<div class="container">

<table style="width: 100%;"><tr>
<td>linear2ph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sieve maximum likelihood estimator (SMLE) for two-phase linear regression problems</h2>

<h3>Description</h3>

<p>Performs efficient semiparametric estimation for general two-phase measurement error models when there are errors in both the outcome and covariates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">linear2ph(
  Y_unval = NULL,
  Y = NULL,
  X_unval = NULL,
  X = NULL,
  Z = NULL,
  Bspline = NULL,
  data = NULL,
  hn_scale = 1,
  noSE = FALSE,
  TOL = 1e-04,
  MAX_ITER = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y_unval</code></td>
<td>
<p>Column name of the error-prone or unvalidated continuous outcome. Subjects with missing values of <code>Y_unval</code> are omitted from the analysis. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Column name that stores the validated value of <code>Y_unval</code> in the second phase. Subjects with missing values of <code>Y</code> are considered as those not selected in the second phase. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_unval</code></td>
<td>
<p>Specifies the columns of the error-prone covariates. Subjects with missing values of <code>X_unval</code> are omitted from the analysis. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Specifies the columns that store the validated values of <code>X_unval</code> in the second phase. Subjects with missing values of <code>X</code> are considered as those not selected in the second phase. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Specifies the columns of the accurately measured covariates. Subjects with missing values of <code>Z</code> are omitted from the analysis. This argument is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bspline</code></td>
<td>
<p>Specifies the columns of the B-spline basis. Subjects with missing values of <code>Bspline</code> are omitted from the analysis. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Specifies the name of the dataset. This argument is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hn_scale</code></td>
<td>
<p>Specifies the scale of the perturbation constant in the variance estimation. For example, if <code>hn_scale = 0.5</code>, then the perturbation constant is <code class="reqn">0.5n^{-1/2}</code>, where <code class="reqn">n</code> is the first-phase sample size. The default value is <code>1</code>. This argument is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noSE</code></td>
<td>
<p>If <code>TRUE</code>, then the variances of the parameter estimators will not be estimated. The default value is <code>FALSE</code>. This argument is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TOL</code></td>
<td>
<p>Specifies the convergence criterion in the EM algorithm. The default value is <code>1E-4</code>. This argument is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAX_ITER</code></td>
<td>
<p>Maximum number of iterations in the EM algorithm. The default number is <code>1000</code>. This argument is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, then show details of the analysis. The default value is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>Stores the analysis results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Stores the residual standard error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariance</code></td>
<td>
<p>Stores the covariance matrix of the regression coefficient estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge</code></td>
<td>
<p>In parameter estimation, if the EM algorithm converges, then <code>converge = TRUE</code>. Otherwise, <code>converge = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge_cov</code></td>
<td>
<p>In variance estimation, if the EM algorithm converges, then <code>converge_cov = TRUE</code>. Otherwise, <code>converge_cov = FALSE</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Tao, R., Mercaldo, N. D., Haneuse, S., Maronge, J. M., Rathouz, P. J., Heagerty, P. J., &amp; Schildcrout, J. S. (2021). Two-wave two-phase outcome-dependent sampling designs, with applications to longitudinal binary data. <em>Statistics in Medicine, 40</em>(8), 1863â€“1876. https://doi.org/10.1002/sim.8876
</p>


<h3>See Also</h3>

<p><code>cv_linear2ph()</code> to calculate the average predicted log likelihood of this function.
</p>


<h3>Examples</h3>

<pre><code class="language-R"> rho = -.3
 p = 0.3
 hn_scale = 1
 nsieve = 20

 n = 100
 n2 = 40
 alpha = 0.3
 beta = 0.4
 set.seed(12345)

 ### generate data
 simX = rnorm(n)
 epsilon = rnorm(n)
 simY = alpha+beta*simX+epsilon
 error = MASS::mvrnorm(n, mu=c(0,0), Sigma=matrix(c(1, rho, rho, 1), nrow=2))
 
 simS = rbinom(n, 1, p)
 simU = simS*error[,2]
 simW = simS*error[,1]
 simY_tilde = simY+simW
 simX_tilde = simX+simU
 
 id_phase2 = sample(n, n2)
 
 simY[-id_phase2] = NA
 simX[-id_phase2] = NA
 
 # # histogram basis
 # Bspline = matrix(NA, nrow=n, ncol=nsieve)
 # cut_x_tilde = cut(simX_tilde, breaks=quantile(simX_tilde, probs=seq(0, 1, 1/nsieve)), 
 #   include.lowest = TRUE)
 # for (i in 1:nsieve) {
 #     Bspline[,i] = as.numeric(cut_x_tilde == names(table(cut_x_tilde))[i])
 # }
 # colnames(Bspline) = paste("bs", 1:nsieve, sep="")
 # # histogram basis
 
 # # linear basis
 # Bspline = splines::bs(simX_tilde, df=nsieve, degree=1,
 #   Boundary.knots=range(simX_tilde), intercept=TRUE)
 # colnames(Bspline) = paste("bs", 1:nsieve, sep="")
 # # linear basis
 
 # # quadratic basis
 # Bspline = splines::bs(simX_tilde, df=nsieve, degree=2, 
 #   Boundary.knots=range(simX_tilde), intercept=TRUE)
 # colnames(Bspline) = paste("bs", 1:nsieve, sep="")
 # # quadratic basis
 
 # cubic basis
 Bspline = splines::bs(simX_tilde, df=nsieve, degree=3, 
   Boundary.knots=range(simX_tilde), intercept=TRUE)
 colnames(Bspline) = paste("bs", 1:nsieve, sep="")
 # cubic basis
 
 data = data.frame(Y_tilde=simY_tilde, X_tilde=simX_tilde, Y=simY, X=simX, Bspline)

 res = linear2ph(Y="Y", X="X", Y_unval="Y_tilde", X_unval="X_tilde", 
   Bspline=colnames(Bspline), data=data, hn_scale=0.1)
</code></pre>


</div>