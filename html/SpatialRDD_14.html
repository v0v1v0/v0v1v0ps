<div class="container">

<table style="width: 100%;"><tr>
<td>spatialrd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>non-parametric Spatial RD / GRD</h2>

<h3>Description</h3>

<p>This function loops over all boundary points and locally estimates a non-parametric RD (using local linear regression)
using the <code>rdrobust</code> function from the <code>rdrobust</code> package from Calonico, Cattaneo, Titiunik (2014).
It takes in the discretized cutoff point file (the RDcutoff, a linestring chopped into parts by the <code>discretise_border</code> function)
and the sf object (which essentially is just a conventional data.frame with a <code>geometry()</code> column) containing all the observations (treated and untreated).
The treated indicator variable has to be assigned before (potentially with <code>assign_treated</code>) and be part of the sf object as a column.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatialrd(
  y,
  data,
  cutoff.points,
  treated,
  minobs = 50,
  bwfix_m = NA,
  sample = FALSE,
  samplesize = NA,
  sparse.exclusion = FALSE,
  store.CIs = FALSE,
  spatial.object = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The name of the dependent variable in the points frame in the form of a string</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>sf data.frame with points that describe the observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff.points</code></td>
<td>
<p>sf object of borderpoints (provided by user or obtained with <code>discretise_border</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treated</code></td>
<td>
<p>column that contains the treated dummy (as string)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minobs</code></td>
<td>
<p>the minimum amount of observations in each estimation for the point estimate to be included (default is 50)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwfix_m</code></td>
<td>
<p>fixed bandwidth in meters (in case you want to impose one yourself)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>draw a random sample of points (default is FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplesize</code></td>
<td>
<p>if random, how many points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse.exclusion</code></td>
<td>
<p>in case we want to try to exclude sparse border points before the estimation (should reduce warnings)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.CIs</code></td>
<td>
<p>set TRUE of confidence intervals should be stored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial.object</code></td>
<td>
<p>return a spatial object (deafult is TRUE, needed if you want to plot the point estimates on a map)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>in addition you can use all options in <code>rdrobust</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function nests <code>rdrobust</code>. All its options (aside from running variable <code>x</code> and cutoff <code>c</code>) are available here as well (e.g. bw selection, cluster level, kernel, weights).
Check the documentation in the <code>rdrobust</code> package for details. (bandwidth selection default in <code>rdrobust</code> is bwselect = 'mserd')
</p>
<p>To visualise the output, use <code>plotspatialrd</code> for a graphical representation. You can use <code>printspatialrd</code> (or an R package of your choice) for a table output. .
</p>


<h3>Value</h3>

<p>a data.frame or spatial data.frame (sf object) in case spatial.object = TRUE (default)
</p>


<h3>References</h3>

<p>Calonico, Cattaneo and Titiunik (2014): Robust Nonparametric Confidence Intervals for Regression-Discontinuity Designs, Econometrica 82(6): 2295-2326.
</p>


<h3>Examples</h3>

<pre><code class="language-R">points_samp.sf &lt;- sf::st_sample(polygon_full, 1000) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
# assign treatment:
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
# first we define a variable for the number of "treated" and control
NTr &lt;- length(points_samp.sf$id[points_samp.sf$treated == 1])
NCo &lt;- length(points_samp.sf$id[points_samp.sf$treated == 0])
# the treated areas get a 10 percentage point higher literacy rate
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- 0.7
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- 0.6
# and we add some noise, otherwise we would obtain regression coeffictions with no standard errors
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- rnorm(NTr, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 1]
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- rnorm(NCo, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 0]

# create distance to cutoff
points_samp.sf$dist2cutoff &lt;- as.numeric(sf::st_distance(points_samp.sf, cut_off))

points_samp.sf$distrunning &lt;- points_samp.sf$dist2cutoff
# give the non-treated one's a negative score
points_samp.sf$distrunning[points_samp.sf$treated == 0] &lt;- -1 *
 points_samp.sf$distrunning[points_samp.sf$treated == 0]

# create borderpoints
borderpoints.sf &lt;- discretise_border(cutoff = cut_off, n = 10)
borderpoints.sf$id &lt;- 1:nrow(borderpoints.sf)

# finally, carry out estimation alongside the boundary:
results &lt;- spatialrd(y = "education", data = points_samp.sf, cutoff.points = borderpoints.sf,
treated = "treated", minobs = 20, spatial.object = FALSE)


</code></pre>


</div>