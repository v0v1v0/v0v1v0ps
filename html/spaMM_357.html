<div class="container">

<table style="width: 100%;"><tr>
<td>spaMM_glm.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting generalized linear models without initial-value or divergence headaches</h2>

<h3>Description</h3>

<p><code>spaMM_glm.fit</code> is a stand-in replacement for <code>glm.fit</code>, which can be called through <code>glm</code> by using
<code>glm(&lt;&gt;, method="spaMM_glm.fit")</code>. Input and output structure are exactly as for <code>glm.fit</code>. It uses a Levenberg-Marquardt algorithm to prevent divergence of estimates. For models families such as <code>Gamma()</code> (with default inverse link) where the linear predictor is constrained to be positive, if the <span class="pkg">rcdd</span> package is installed, the function can automatically find valid starting values or else indicate that no parameter value is feasible. It also automatically provides good starting values in some cases where the base functions request them from the user (notably, for <code>gaussian(log)</code> with some negative response). 
<code>spaMM_glm</code> is a convenient wrapper, calling <code>glm</code> with default method <code>glm.fit</code>, then calling method <code>spaMM_glm.fit</code>, with possibly different initial values, if <code>glm.fit</code> failed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spaMM_glm.fit(x, y, weights = rep(1, nobs), start = NULL, etastart = NULL, 
              mustart = NULL, offset = rep(0, nobs), family = gaussian(), 
              control = list(maxit=200), intercept = TRUE, singular.ok = TRUE)
spaMM_glm(formula, family = gaussian, data, weights, subset,
          na.action, start = NULL, etastart, mustart, offset,
          control = list(...), model = TRUE, method = c("glm.fit","spaMM_glm.fit"),
          x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, strict=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<p>All arguments except <code>strict</code> are common to these functions and their <code>stats</code> package equivalents, <code>glm</code> and <code>glm.fit</code>. Most arguments operate as for the latter functions, whose documentation is repeated  below. The <code>control</code> argument may operate differently. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>"formula"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
in the ‘Details’ section of <code>glm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model.  For <code>spaMM_glm</code> this can be a
character string naming a family function, a family function or the
result of a call to a family function.  For <code>spaMM_glm.fit</code> only the
third option is supported.  (See <code>family</code> for details of
family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>glm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of ‘prior weights’ to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code>options</code>, and is
<code>na.fail</code> if that is unset.  The ‘factory-fresh’
default is <code>na.omit</code>.  Another possible value is
<code>NULL</code>, no action.  Value <code>na.exclude</code> can be useful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector of length equal to
the number of cases.  One or more <code>offset</code> terms can be
included in the formula instead or as well, and if more than one is
specified their sum is used.  See <code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of parameters for controlling the fitting
process.  This is passed to <code>glm.control</code>, as for <code>glm.fit</code>. 
Because one can assume that <code>spaMM_glm.fit</code> will converge in many cases where <code>glm.fit</code> does not, <code>spaMM_glm.fit</code> allows more iterations (200) by default. However, if <code>spaMM_glm.fit</code> is called through <code>glm(. . ., method="spaMM_glm.fit")</code>, then the number of iterations is controlled by the <code>glm.control</code> call within <code>glm</code>, so that it is 25 by default, overriding the <code>spaMM_glm.fit</code> default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A 2-elements vector specifying first the method to be used by <code>spaMM_glm</code> in the first attempt to fit the model, second the method to be used in a second attempt if the first failed. Possible methods include those shown in the default, <code>"model.frame"</code>, which returns the model frame and does no fitting, or user-supplied fitting functions. These functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>glm.fit</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>For <code>spaMM_glm</code>: <code>x</code> is a design matrix of dimension
<code>n * p</code>, and <code>y</code> is a vector of observations of length
<code>n</code>.
</p>
<p>For <code>spaMM_glm.fit</code>: <code>x</code> is a design matrix of dimension
<code>n * p</code>, and <code>y</code> is a vector of observations of length
<code>n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singular.ok</code></td>
<td>
<p>logical; if <code>FALSE</code> a singular fit is an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical. Should an intercept be included in the
<em>null</em> model?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical. Whether to perform a fit by <code>spaMM_glm.fit</code> if <code>glm.fit</code> returned the warning <code>"glm.fit: algorithm did not converge"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>arguments to be used to form the default
<code>control</code> argument if it is not supplied directly.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object inheriting from class <code>glm</code>. See <code>glm</code> for details.</p>


<h3>Note</h3>

<p>The source and documentation is derived in large part from those of <code>glm.fit</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(8.752,20.27,24.71,32.88,27.27,19.09)
y &lt;- c(5254,35.92,84.14,641.8,1.21,47.2)

# glm(.) fails:
(check_error &lt;- try(glm(y~ x,data=data.frame(x,y),family=Gamma(log)), silent=TRUE))
if ( ! inherits(check_error,"try-error")) stop("glm(.) call unexpectedly succeeded")

spaMM_glm(y~ x,data=data.frame(x,y),family=Gamma(log))

## Gamma(inverse) examples
x &lt;- c(43.6,46.5,21.7,18.6,17.3,16.7)
y &lt;- c(2420,708,39.6,16.7,46.7,10.8)

# glm(.) fails (can't find starting value)
(check_error &lt;- suppressWarnings(try(glm(y~ x,data=data.frame(x,y),family=Gamma()) , silent=TRUE)))
if ( ! inherits(check_error,"try-error")) stop("glm(.) call unexpectedly succeeded.")

if (requireNamespace("rcdd",quietly=TRUE)) {
  spaMM_glm(y~ x,data=data.frame(x,y),family=Gamma())
}

## A simple exponential regression with some negative response values

set.seed(123)
x &lt;- seq(50)
y &lt;- exp( -0.1 * x) + rnorm(50, sd = 0.1)
glm(y~ x,data=data.frame(x,y),family=gaussian(log), method="spaMM_glm.fit")

# =&gt; without the 'method' argument, stats::gaussian(log)$initialize() is called 
# and stops on negative response values. 



</code></pre>


</div>