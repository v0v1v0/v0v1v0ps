<div class="container">

<table style="width: 100%;"><tr>
<td>sig_auto_extract</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Signatures through the Automatic Relevance Determination Technique</h2>

<h3>Description</h3>

<p>A bayesian variant of NMF algorithm to enable optimal inferences for the
number of signatures through the automatic relevance determination technique.
This functions delevers highly interpretable and sparse representations for
both signature profiles and attributions at a balance between data fitting and
model complexity (this method may introduce more signatures than expected,
especially for copy number signatures (thus <strong>I don't recommend you to use this feature
to extract copy number signatures</strong>)). See detail part and references for more.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sig_auto_extract(
  nmf_matrix = NULL,
  result_prefix = "BayesNMF",
  destdir = tempdir(),
  method = c("L1W.L2H", "L1KL", "L2KL"),
  strategy = c("stable", "optimal", "ms"),
  ref_sigs = NULL,
  K0 = 25,
  nrun = 10,
  niter = 2e+05,
  tol = 1e-07,
  cores = 1,
  optimize = FALSE,
  skip = FALSE,
  recover = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result_prefix</code></td>
<td>
<p>prefix for result data files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>destdir</code></td>
<td>
<p>path to save data runs, default is <code>tempdir()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>default is "L1W.L2H", which uses an exponential prior for W and
a half-normal prior for H (This method is used by PCAWG project, see reference #3).
You can also use "L1KL" to set expoential priors for both W and H, and "L2KL" to
set half-normal priors for both W and H. The latter two methods are originally
implemented by SignatureAnalyzer software.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strategy</code></td>
<td>
<p>the selection strategy for returned data. Set 'stable' for getting optimal
result from the most frequent K. Set 'optimal' for getting optimal result from all Ks.
Set 'ms' for getting result with maximum mean cosine similarity with provided reference
signatures. See <code>ref_sigs</code> option for details.
If you want select other solution, please check get_bayesian_result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref_sigs</code></td>
<td>
<p>A Signature object or matrix or string for specifying
reference signatures, only used when <code>strategy = 'ms'</code>.
See <code>Signature</code> and <code>sig_db</code> options in get_sig_similarity for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K0</code></td>
<td>
<p>number of initial signatures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrun</code></td>
<td>
<p>number of independent simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with QP method, see sig_fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>if <code>TRUE</code>, it will skip running a previous stored result. This can be used to
extend run times, e.g. you try running 10 times firstly and then you want to extend it to
20 times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recover</code></td>
<td>
<p>if <code>TRUE</code>, try to recover result from previous runs based on input <code>result_prefix</code>,
<code>destdir</code> and <code>nrun</code>. This is pretty useful for reproducing result. Please use <code>skip</code> if you want
to recover an unfinished job.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are three methods available in this function: "L1W.L2H", "L1KL" and "L2KL".
They use different priors for the bayesian variant of NMF algorithm
(see <code>method</code> parameter) written by reference #1 and implemented in
SignatureAnalyzer software
(reference #2).
</p>
<p>I copied source code for the three methods from Broad Institute and supplementary
files of reference #3, and wrote this higher function. It is more friendly for users
to extract, visualize and analyze signatures by combining with other powerful functions
in <strong>sigminer</strong> package. Besides, I implemented parallel computation to speed up
the calculation process and a similar input and output structure like <code>sig_extract()</code>.
</p>


<h3>Value</h3>

<p>a <code>list</code> with <code>Signature</code> class.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Tan, Vincent YF, and Cédric Févotte. "Automatic relevance determination in nonnegative matrix factorization with the/spl beta/-divergence."
IEEE Transactions on Pattern Analysis and Machine Intelligence 35.7 (2012): 1592-1605.
</p>
<p>Kim, Jaegil, et al. "Somatic ERCC2 mutations are associated with a distinct genomic signature in urothelial tumors."
Nature genetics 48.6 (2016): 600.
</p>
<p>Alexandrov, Ludmil, et al. "The repertoire of mutational signatures in human cancer." BioRxiv (2018): 322859.
</p>


<h3>See Also</h3>

<p>sig_tally for getting variation matrix,
sig_extract for extracting signatures using <strong>NMF</strong> package, sig_estimate for
estimating signature number for sig_extract.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
res &lt;- sig_auto_extract(cn_tally_W$nmf_matrix, result_prefix = "Test_copynumber", nrun = 1)
# At default, all run files are stored in tempdir()
dir(tempdir(), pattern = "Test_copynumber")

laml.maf &lt;- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
laml &lt;- read_maf(maf = laml.maf)
mt_tally &lt;- sig_tally(
  laml,
  ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
  use_syn = TRUE
)

x &lt;- sig_auto_extract(mt_tally$nmf_matrix,
  strategy = "ms", nrun = 3, ref_sigs = "legacy"
)
x

</code></pre>


</div>