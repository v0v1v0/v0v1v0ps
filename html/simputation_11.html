<div class="container">

<table style="width: 100%;"><tr>
<td>impute_proxy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute by variable derivation</h2>

<h3>Description</h3>

<p>Impute missing values by a constant, by copying another variable computing 
transformations from other variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">impute_proxy(dat, formula, add_residual = c("none", "observed", "normal"), ...)

impute_const(dat, formula, add_residual = c("none", "observed", "normal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (See Model description)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_residual</code></td>
<td>
<p><code>[character]</code> Type of residual to add. <code>"normal"</code> 
means that the imputed value is drawn from <code>N(mu,sd)</code> where <code>mu</code>
and <code>sd</code> are estimated from the model's residuals (<code>mu</code> should equal
zero in most cases). If <code>add_residual = "observed"</code>, residuals are drawn
(with replacement) from the model's residuals. Ignored for non-numeric 
predicted variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently unused</p>
</td>
</tr>
</table>
<h3>Model Specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. 
</p>
<p>For <code>impute_const</code>, the <code>MODEL_SPECIFICATION</code> is a single
value and <code>GROUPING_VARIABLES</code> are ignored.
</p>
<p>For <code>impute_proxy</code>, the <code>MODEL_SPECIFICATION</code> is a variable or
expression in terms of variables in the dataset that must result in either a
single number of in a vector of length <code>nrow(dat)</code>.
</p>
<p>If grouping variables are specified, the data set is split according to the 
values of those variables, and model estimation and imputation occur 
independently for each group.
</p>
<p>Grouping using <code>dplyr::group_by</code> is also supported. If groups are 
defined in both the formula and using <code>dplyr::group_by</code>, the data is 
grouped by the union of grouping variables. Any missing value in one of the 
grouping variables results in an error.
</p>


<h3>Examples</h3>

<pre><code class="language-R">irisNA &lt;- iris
irisNA[1:3,1] &lt;- irisNA[3:7,2] &lt;- NA

# impute a constant 

a &lt;- impute_const(irisNA, Sepal.Width ~ 7)
head(a)

a &lt;- impute_proxy(irisNA, Sepal.Width ~ 7)
head(a)

# copy a value from another variable (where available)
a &lt;- impute_proxy(irisNA, Sepal.Width ~ Sepal.Length)
head(a)

# group mean imputation
a &lt;- impute_proxy(irisNA
  , Sepal.Length ~ mean(Sepal.Length,na.rm=TRUE) | Species)
head(a)

# random hot deck imputation
a &lt;- impute_proxy(irisNA, Sepal.Length ~ mean(Sepal.Length, na.rm=TRUE)
, add_residual = "observed")

# ratio imputation (but use impute_lm for that)
a &lt;- impute_proxy(irisNA, 
  Sepal.Length ~ mean(Sepal.Length,na.rm=TRUE)/mean(Sepal.Width,na.rm=TRUE) * Sepal.Width)

</code></pre>


</div>