<div class="container">

<table style="width: 100%;"><tr>
<td>sk_sample_pt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sub-grid point sampler for grid data</h2>

<h3>Description</h3>

<p>Sample <code>n</code> locations from the non-NA points in the input grid <code>g</code>, optionally using
them as centers to place <code>n</code> sub-grids of the specified size and resolution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_sample_pt(
  g,
  n = 100,
  lag_max = 0,
  up = 0,
  over = FALSE,
  sk_out = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>an sk grid object or any other object accepted by <code>sk</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer &gt; 0, the maximum number of center points to sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag_max</code></td>
<td>
<p>integer, Moore neighborhood radius (ie the maximum queen's distance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>up</code></td>
<td>
<p>integer, the up-scaling factor for sampling sub-grids of <code>g</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>over</code></td>
<td>
<p>logical, indicates to allow overlapping sub-grids (when they can be avoided)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sk_out</code></td>
<td>
<p>logical, if TRUE (the default) the function returns an sk grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer seed, passed to <code>base::set.seed</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>sk_out=TRUE</code> (the default), the function returns an sk grid containing the sampled
points. If multiple samples are requested, a multi-layer grid is returned. When
<code>sk_out=FALSE</code>, the function returns the vector index of the sampled grid points,
or if multiple samples are requested, a list of vectors.
</p>
<p>By default the function simply draws a sample of <code>n</code> locations (uniformly at random)
from the non-NA points in the input grid <code>g</code>.
</p>
<p>When <code>lag_max &gt; 1</code>, the function instead returns the the Moore neighbourhood of
radius <code>lag_max</code> around each of the sample points (including the center point). These
sub-grids are returned as distinct layers (or list entries, if <code>sk_out=FALSE</code>). Their
resolution can be coarsened (up-scaled) by increasing <code>up</code> from its default 0. <code>up</code>
must either be 0 or else a positive integer that evenly divides <code>lag_max</code>
(see <code>sk_rescale</code>).
</p>
<p>For a given <code>up</code>, the grid <code>g</code> can be partitioned into <code>(up+1)^2</code> distinct
non-overlapping sub-grids. When <code>over=FALSE</code> (the default), the function apportions
its <code>n</code> point samples as evenly as possible among these disjoint subsets. This ensures
that if <code>n</code> is less than or equal to <code>(up+1)^2</code>, and there are no <code>NA</code>s, there can be
no repetition (overlap) of points in the returned sub-grids.
</p>
<p>Note that with the default <code>sk_out=TRUE</code>, <code>lag_max &gt; 1</code> is only supported for complete
grids <code>g</code>. This is because with missing data it is hard (and sometimes impossible) to
ensure that the Moore neighborhoods have identical <code>NA</code> structure (and this is a
requirement for multi-layer sk grids).
</p>
<p>Note also that multi-layer sk grids are not fully supported yet. If you pass a
multi-layer grid to g, the function returns results for the first layer only.
</p>


<h3>Value</h3>

<p>If <code>lag_max == 0</code> (the default), the function returns a single-layer sk grid when
<code>sk_out=TRUE</code>, or else the sample indices in <code>g</code> as a length-<code>n</code> integer vector. If
<code>lag_max &gt; 0</code>, the function returns a multi-layer sk grid <code>sk_out=TRUE</code>, or else a list of
<code>n</code> vectors indexing the sampled points in each sub-grid of <code>g</code>.
</p>


<h3>See Also</h3>

<p>sk sk_sample_vg
</p>


<h3>Examples</h3>

<pre><code class="language-R"># define an empty grid
g_empty = sk(gdim = c(100, 100))

# get an ordinary random sample with default settings
g_sample = sk_sample_pt(g_empty)
plot(g_sample)

# same call with index return mode
idx_sample = sk_sample_pt(g_empty, sk_out=FALSE)
str(idx_sample)

# reduce or increase number of center points from default 100
g_sample = sk_sample_pt(g_empty, n=10)
plot(g_sample)

# add some data to g and repeat
pars = sk_pars(g_empty)
pars$eps = 1e-6
g = sk_sim(g_empty, pars)
plot(g)
g_sample = sk_sample_pt(g)
plot(g_sample)

# sample 3 subgrids from Moore neighbourhoods of radius 6 (index output mode)
n = 3
idx_sample = sk_sample_pt(g, n=n, lag_max=6L, sk_out=FALSE, seed=42)

# plot each list element a different color
group_sample = rep(0L, length(g))
for(i in seq(n)) group_sample[ idx_sample[[i]] ] = i
sk_plot(group_sample, dim(g), breaks=c('not sampled', seq(n)), zlab='sub-grid')

# plot all the sub-grid data
g_plot = g_empty
g_plot[unlist(idx_sample)] = g[unlist(idx_sample)]
plot(g_plot)

# default sk_out=TRUE returns them as multi-layer grid object
g_sample = sk_sample_pt(g, n=n, lag_max=6L, seed=42)
plot(g_sample, layer=1, zlim=range(g_plot, na.rm=TRUE))
plot(g_sample, layer=2, zlim=range(g_plot, na.rm=TRUE))
plot(g_sample, layer=3, zlim=range(g_plot, na.rm=TRUE))



# When up &gt; 0 the function will attempts to avoid overlap whenever possible
up = 1
n = (up+1)^2 # to get disjoint results n must be less than or equal to (up+1)^2
lag_max = 10 * (up+1) # vary to get larger/smaller subsets. max allowable: min(gdim)/2
idx_sample = sk_sample_pt(g, n=n, up=up, lag_max=lag_max, sk_out=FALSE)
idx_overlap = rowSums( sapply(idx_sample, function(i) seq_along(g) %in% i) )

# plot each list element a different color
group_sample = rep(0L, length(g))
for(i in seq(n)) group_sample[ idx_sample[[i]] ] = i
sk_plot(group_sample, dim(g), breaks=c('not sampled', seq(n)), zlab='sub-grid')

# no overlap
sk_plot(as.integer(idx_overlap), dim(g), zlab='times sampled')

# compare with over=TRUE (usually results in overlap - try running a few times)
idx_sample_compare = sk_sample_pt(g, n=n, up=up, lag_max=lag_max, over=TRUE, sk_out=FALSE)
idx_overlap_compare = rowSums( sapply(idx_sample_compare, function(i) seq_along(g) %in% i) )
sk_plot(as.integer(idx_overlap_compare), dim(g), zlab='times sampled')

# incomplete input data example
g_sample = sk_sample_pt(g, n=10)
sk_plot(g_sample)

# draw a sample of center points and indicate sub-grids in color
idx_sample = sk_sample_pt(g_sample, n=10, lag_max=6, up=1, over=FALSE, sk_out=FALSE)
g_sample_grid = g_empty
g_sample_grid[] = rep('not sampled', length(g_empty))
g_sample_grid[unlist(idx_sample)] = 'sub-grid sample'
plot(g_sample_grid)

</code></pre>


</div>