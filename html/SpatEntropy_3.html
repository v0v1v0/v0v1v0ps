<div class="container">

<table style="width: 100%;"><tr>
<td>areapart</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Area partition.</h2>

<h3>Description</h3>

<p>This function partitions the observation area in a number of sub-areas,
and assigns the data points/pixels to the areas. This function is useful either
when a random partition wants to be created, or when the user wants to set the
area's centroids and is happy with an area tessellation in Voronoi polygons according
to the defined centroids.
</p>


<h3>Usage</h3>

<pre><code class="language-R">areapart(data, G, cell.size = 1, win = NULL, plotout = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>An integer if sub-areas are randomly generated, determining the number <code class="reqn">G</code> of sub-areas.
Alternatively, a 2-column matrix with the sub-areas centroids' coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.size</code></td>
<td>
<p>A single number. If data are lattice, the length of the side of each pixel.
Default to 1. Ignored if data are points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>win</code></td>
<td>
<p>Optional, the observation area given as a <code>owin</code> object. If
data are a point pattern <code>ppp</code> object, this argument is ignored
and the observation area is extracted from the object. If data are
given as a matrix and the area is not specified, the default is a
rectangle with x range from 0 to the number of columns of the data, and
y range from 0 to the number of rows of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function is preliminary to the computation of Batty's or Karlstrom and Ceccato's entropy.
An event of interest (in the form of a point or binary areal dataset) occurs
over an observation area divided into sub-areas. If the partition is random,
this function generates the sub-areas by randomly drawing the areas' centroids
over the observation window. Then, data points/pixels are assigned to the area with
the closest centroid. When data are pixels, each pixel is assigned to an area according to
the coordinates of its own centroid.
The function also works for non-binary datasets and marked ppp objects.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>G.pp</code> a point pattern containing the <code class="reqn">G</code> areas' centroids
</p>
</li>
<li> <p><code>data.assign</code> a four column matrix, with all pairs of data coordinates and data values
matched to one of the <code class="reqn">G</code> areas (numbered 1 to <code class="reqn">G</code>). If the dataset is an unmarked ppp
object, the data category column is a vector of 1s.
</p>
</li>
</ul>
<p>Moreover, a plot is produced showing the data and the area partition.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#LATTICE DATA

data=matrix(sort(sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
partition=areapart(data, G=5)
partition=areapart(data, G=5, cell.size=2)

#providing a pre-fixed area partition
data=matrix(sort(sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
win=square(nrow(data))
GG=cbind(runif(5, win$xrange[1], win$xrange[2]),
         runif(5, win$yrange[1], win$yrange[2]))
partition=areapart(data, G=GG)

#POINT DATA

data=ppp(x=runif(100), y=runif(100), window=square(1))
partition=areapart(data, 10)

#with marks
data=ppp(x=runif(100), y=runif(100), window=square(1),
         marks=(sample(c("a","b","c"), 100, replace=TRUE)))
GG=cbind(runif(10, data$window$xrange[1], data$window$xrange[2]),
         runif(10, data$window$yrange[1], data$window$yrange[2]))
partition=areapart(data, G=GG)

</code></pre>


</div>