<div class="container">

<table style="width: 100%;"><tr>
<td>SparseVFC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Vector Field Consensus</h2>

<h3>Description</h3>

<p>The main function for the SparseVFC algorithm.
See <code>References</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SparseVFC(
  X,
  Y,
  M = 16,
  MaxIter = 500,
  gamma = 0.9,
  beta = 0.1,
  lambda = 3,
  theta = 0.75,
  a = 10,
  ecr = 1e-05,
  minP = 1e-05,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The position of the vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The value of the vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The number of the basis functions used for sparse approximation. Default value is 16.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxIter</code></td>
<td>
<p>Maximum iteration times. Default value is 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Percentage of inliers in the samples. This is an initial value for EM iteration, and it is not important. Default value is 0.9.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Parameter of Gaussian Kernel, <code class="reqn">k(x, y) = exp(-beta*||x-y||^2)</code>. Default value is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Represents the trade-off between the goodness of data fit and smoothness of the field. Default value is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>If the posterior probability of a sample being an inlier is larger than theta, then it will be regarded as an inlier. Default value is 0.75.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Parameter of the uniform distribution. We assume that the outliers obey a uniform distribution <code class="reqn">1/a</code>. Default Value is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ecr</code></td>
<td>
<p>The minimum limitation of the energy change rate in the iteration process. Default value is 1e-5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minP</code></td>
<td>
<p>The posterior probability Matrix P may be singular for matrix inversion. We set the minimum value of P as <code>minP</code>. Default value is 1e-5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Should the messages be suppressed? Default value is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>VFC</code> object, which is a list containing the following elements:
</p>

<dl>
<dt>X</dt>
<dd>
<p>A matrix of the positions of kernels.</p>
</dd>
<dt>Y</dt>
<dd>
<p>A matrix of the input vectors.</p>
</dd>
<dt>beta</dt>
<dd>
<p>The input value of <code>beta</code>.</p>
</dd>
<dt>V</dt>
<dd>
<p>A matrix of the estimated vectors.</p>
</dd>
<dt>C</dt>
<dd>
<p>A matrix of the coefficients of each kernel.</p>
</dd>
<dt>P</dt>
<dd>
<p>A vector of the posterior probability of the input vectors (<code>Y</code>) being an inlier.</p>
</dd>
<dt>VFCIndex</dt>
<dd>
<p>A vector of indices of the inliers.</p>
</dd>
<dt>sigma2</dt>
<dd>
<p>The <code class="reqn">\sigma^2</code> of the estimations weighted by <code>P</code>.</p>
</dd>
</dl>
<h3>References</h3>

<p>The algorithm is described in Ma et al. (2013) <a href="https://doi.org/10.1016/j.patcog.2013.05.017">doi:10.1016/j.patcog.2013.05.017</a>.
This function is translated with permission from Jiayi Ma's Matlab function at <a href="https://github.com/jiayi-ma/VFC">https://github.com/jiayi-ma/VFC</a>.
Also see Zhao et al. (2011) <a href="https://doi.org/10.1109/CVPR.2011.5995336">doi:10.1109/CVPR.2011.5995336</a> for the earlier VFC algorithm.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(church)
set.seed(1614)
VecFld &lt;- SparseVFC(norm_vecs(church$X), norm_vecs(church$Y) - norm_vecs(church$X))
predict(VecFld, c(0, 0))
</code></pre>


</div>