<div class="container">

<table style="width: 100%;"><tr>
<td>corrvar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generation of Correlated Ordinal, Continuous (mixture and non-mixture), and/or Count (Poisson and Negative Binomial,
regular and zero-inflated) Variables: Correlation Method 1</h2>

<h3>Description</h3>

<p>This function simulates <code>k_cat</code> ordinal (<code class="reqn">r \ge 2</code> categories), <code>k_cont</code> continuous non-mixture,
<code>k_mix</code> continuous mixture, <code>k_pois</code> Poisson (regular and zero-inflated), and/or <code>k_nb</code> Negative Binomial
(regular and zero-inflated) variables with a specified correlation matrix <code>rho</code>.  The variables are generated from
multivariate normal variables with intermediate correlation matrix <code>Sigma</code>, calculated by <code>intercorr</code>,
and then transformed.  The intermediate correlations involving count variables are determined using <strong>correlation method 1</strong>.
The <em>ordering</em> of the variables in <code>rho</code> must be 1st ordinal, 2nd continuous non-mixture,
3rd components of the continuous mixture, 4th regular Poisson, 5th zero-inflated Poisson, 6th regular NB, and 7th zero-inflated NB.
Note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_mix</code>, <code>k_pois</code>, and/or <code>k_nb</code> to be 0.
Simulation occurs at the component-level for continuous mixture distributions.  The target correlation matrix is specified in terms of
correlations with components of continuous mixture variables.  There are no parameter input checks
in order to decrease simulation time.  All inputs should be checked prior to simulation with <code>validpar</code>
and <code>validcorr</code>.  Summaries for the simulation results can be obtained with <code>summary_var</code>.
</p>
<p>All continuous variables are simulated using either Fleishman's third-order (<code>method</code> = "Fleishman", doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order
(<code>method</code> = "Polynomial", doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) power method transformation.  It works by matching standardized
cumulants â€“ the first four (mean, variance, skew, and standardized kurtosis) for Fleishman's method, or the first six (mean,
variance, skew, standardized kurtosis, and standardized fifth and sixth cumulants) for Headrick's method.  The transformation is
expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = c_0 + c_1 * Z + c_2 * Z^2 + c_3 * Z^3 + c_4 * Z^4 + c_5 * Z^5,  Z \sim N(0,1),</code>
</p>

<p>where <code class="reqn">c_4</code> and <code class="reqn">c_5</code> both equal <code class="reqn">0</code> for Fleishman's method.  The real constants are calculated by <br><code>find_constants</code>.  Continuous mixture variables are generated componentwise and then transformed to
the desired mixture variables based on random multinomial variables generated from the mixing probabilities.  Ordinal variables
(<code class="reqn">r \ge 2</code> categories) are generated by discretizing the standard normal
variables at quantiles.  These quantiles are determined by evaluating the inverse standard normal CDF at the cumulative
probabilities defined by each variable's marginal distribution.  Count variables are generated using the inverse CDF method.  The
CDF of a standard normal variable has a uniform distribution.  The appropriate quantile function (F_Y)^(-1) is applied to
this uniform variable with the designated parameters to generate the count variable: Y = (F_Y)^(-1)(Phi(Z)).  The Negative
Binomial variable represents the number of failures which occur in a sequence of Bernoulli trials before the target number of
successes is achieved.  Zero-inflated Poisson or NB variables are obtained by setting the probability of a structural zero to be
greater than 0.  The optional error loop attempts to correct the final pairwise correlations to be within a user-specified
precision value (<code>epsilon</code>) of the target correlations.
</p>
<p>The vignette <b>Variable Types</b> discusses how each of the different variables are generated and describes the required parameters.
</p>
<p>The vignette <b>Overall Workflow for Generation of Correlated Data</b> provides a detailed example discussing the step-by-step simulation process and comparing correlation methods 1 and 2.
</p>


<h3>Usage</h3>

<pre><code class="language-R">corrvar(n = 10000, k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0,
  k_nb = 0, method = c("Fleishman", "Polynomial"), means = NULL,
  vars = NULL, skews = NULL, skurts = NULL, fifths = NULL,
  sixths = NULL, Six = list(), mix_pis = list(), mix_mus = list(),
  mix_sigmas = list(), mix_skews = list(), mix_skurts = list(),
  mix_fifths = list(), mix_sixths = list(), mix_Six = list(),
  marginal = list(), support = list(), lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, rho = NULL,
  seed = 1234, errorloop = FALSE, epsilon = 0.001, maxit = 1000,
  use.nearPD = TRUE, nrand = 100000, Sigma = NULL, cstart = list(),
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable; default = 10000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables.
"Fleishman" uses Fleishman's third-order polynomial transformation and "Polynomial" uses Headrick's fifth-order transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>a vector of means for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>a vector of variances for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br>
ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>; if no correction is desired for <code class="reqn">Y_{cont_i}</code>, set the i-th
list component equal to <code>NULL</code>; if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_Six</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = "Fleishman")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector containing the r ordered support values;
if not provided (i.e. <code>support = list()</code>), the default is for the i-th element to be the vector 1, ..., r</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorloop</code></td>
<td>
<p>if TRUE, uses <code>corr_error</code> to attempt to correct final pairwise correlations to be within
<code>epsilon</code> of target pairwise correlations (default = FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlations (default = 0.001)
in the calculation of ordinal intermediate correlations with <code>ord_norm</code> or in the error loop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code>ord_norm</code> or in the error loop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.nearPD</code></td>
<td>
<p>TRUE to convert the overall intermediate correlation matrix to the nearest positive definite matrix with <code>Matrix::nearPD</code> if
necessary; if FALSE the negative eigenvalues are replaced with 0 if necessary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating intermediate correlations with
<code>intercorr</code> (default = 10000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>an intermediate correlation matrix to use if the user wants to provide one, else it is calculated within by
<code>intercorr</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cstart</code></td>
<td>
<p>a list of length equal to <code>k_cont</code> + the total number of mixture components containing initial values for root-solving
algorithm used in <code>find_constants</code>.  If user specified, each list element must be input as a matrix.
For <code>method</code> = "Fleishman", each should have 3 columns for <code class="reqn">c_1, c_2, c_3</code>;
for <code>method</code> = "Polynomial", each should have 5 columns for <code class="reqn">c_1, c_2, c_3, c_4, c_5</code>.  If no starting values are specified for
a given component, that list element should be <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>if FALSE prints simulation messages, if TRUE suppresses message printing</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list whose components vary based on the type of simulated variables.
</p>
<p>If <b>ordinal variables</b> are produced: <code>Y_cat</code> the ordinal variables,
</p>
<p>If <b>continuous variables</b> are produced:
</p>
<p><code>constants</code> a data.frame of the constants,
</p>
<p><code>Y_cont</code> the continuous non-mixture variables,
</p>
<p><code>Y_comp</code> the components of the continuous mixture variables,
</p>
<p><code>Y_mix</code> the continuous mixture variables,
</p>
<p><code>sixth_correction</code> a list of sixth cumulant correction values,
</p>
<p><code>valid.pdf</code> a vector where the i-th element is "TRUE" if the constants for the i-th continuous variable generate a valid PDF, else "FALSE"
</p>
<p>If <b>Poisson variables</b> are produced: <code>Y_pois</code> the regular and zero-inflated Poisson variables,
</p>
<p>If <b>Negative Binomial variables</b> are produced: <code>Y_nb</code> the regular and zero-inflated Negative Binomial variables,
</p>
<p>Additionally, the following elements:
</p>
<p><code>Sigma</code> the intermediate correlation matrix (after the error loop),
</p>
<p><code>Error_Time</code> the time in minutes required to use the error loop,
</p>
<p><code>Time</code> the total simulation time in minutes,
</p>
<p><code>niter</code> a matrix of the number of iterations used for each variable in the error loop,
</p>


<h3>Overview of Correlation Method 1</h3>

<p>The intermediate correlations used in method 1 are more simulation based than those in method 2, which means that accuracy
increases with sample size and the number of repetitions.  In addition, specifying the seed allows for reproducibility.  In
addition, method 1 differs from method 2 in the following ways:
</p>
<p>1) The intermediate correlation for <b>count variables</b> is based on the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>), which
uses a simulation based, logarithmic transformation of the target correlation.  This method becomes less accurate as the variable mean
gets closer to zero.
</p>
<p>2) The <b>ordinal - count variable</b> correlations are based on an extension of the method of Amatya &amp; Demirtas (2015,
doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>), in which
the correlation correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between the count
variable and the normal variable used to generate it and a simulated upper bound on the correlation between an ordinal variable
and the normal variable used to generate it (see Demirtas &amp; Hedeker, 2011, doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>).
</p>
<p>3) The <b>continuous - count variable</b> correlations are based on an extension of the methods of Amatya &amp; Demirtas (2015) and
Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>), in which the correlation correction factor is the product of the upper Frechet-Hoeffding bound
on the correlation between the count variable and the normal variable used to generate it and the power method correlation
between the continuous variable and the normal variable used to generate it (see Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>).
The intermediate correlations are the ratio of the target correlations to the correction factor.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for more information and a step-by-step overview of the simulation process.
</p>


<h3>Choice of Fleishman's third-order or Headrick's fifth-order method</h3>

<p>Using the fifth-order approximation allows additional control over the fifth and sixth moments of the generated distribution, improving
accuracy.  In addition, the range of feasible standardized kurtosis (<code class="reqn">\gamma_2</code>) values, given skew (<code class="reqn">\gamma_1</code>) and standardized fifth (<code class="reqn">\gamma_3</code>) and sixth
(<code class="reqn">\gamma_4</code>) cumulants, is larger than with Fleishman's method (see <code>calc_lower_skurt</code>).
For example, the Fleishman method can not be used to generate a non-normal distribution with a ratio of
<code class="reqn">\gamma_1^2/\gamma_2 &gt; 9/14</code> (see Headrick &amp; Kowalchuk, 2007).  This eliminates the Chi-squared family of distributions, which has
a constant ratio of <code class="reqn">\gamma_1^2/\gamma_2 = 2/3</code>.  The fifth-order method also generates more distributions with valid PDF's.
However, if the fifth and sixth cumulants are unknown or do not exist, the Fleishman approximation should be used.
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code>fleish</code> or
<code>poly</code> converged when using <code>find_constants</code>.  If this happens,
the simulation will stop.  It may help to first use <code>find_constants</code> for each continuous variable to
determine if a sixth cumulant correction value is needed.  The solutions can be used as starting values (see <code>cstart</code> below).
If the standardized cumulants are obtained from <code>calc_theory</code>, the user may need to use rounded values as inputs (i.e.
<code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code>calc_lower_skurt</code> to determine the boundary for a given set of cumulants.
</p>
<p>3) The feasibility of the final correlation matrix <code>rho</code>, given the
distribution parameters, should be checked first using <code>validcorr</code>.  This function either checks
if a given <code>rho</code> is plausible or returns the lower and upper final correlation limits.  It should be noted that even if a target
correlation matrix is within the "plausible range," it still may not be possible to achieve the desired matrix.  This happens most
frequently when generating ordinal variables or using negative correlations.  The error loop frequently fixes these problems.
</p>


<h3>References</h3>

<p>Please see references for <code>SimCorrMix</code>.
</p>


<h3>See Also</h3>

<p><code>find_constants</code>, <code>validpar</code>, <code>validcorr</code>,
<code>intercorr</code>, <code>corr_error</code>, <code>summary_var</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Sim1 &lt;- corrvar(n = 1000, k_cat = 1, k_cont = 1, method = "Polynomial",
  means = 0, vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), support = list(0:2),
  rho = matrix(c(1, 0.4, 0.4, 1), 2, 2), quiet = TRUE)

## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, rho = Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed)

# simulate without the error loop
Sim2 &lt;- corrvar(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed, epsilon = 0.01)

names(Sim2)

# simulate with the error loop
Sim2_EL &lt;- corrvar(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial",
  means, vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus,
  mix_sigmas, mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six,
  marginal, support, lam, p_zip, size, prob, mu = NULL, p_zinb, Rey,
  seed, errorloop = TRUE, epsilon = 0.01)

names(Sim2_EL)

## End(Not run)


</code></pre>


</div>