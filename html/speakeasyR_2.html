<div class="container">

<table style="width: 100%;"><tr>
<td>cluster_genes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster a gene expression matrix</h2>

<h3>Description</h3>

<p>Use the Speakeasy 2 community detection algorithm to cluster genes based on
their gene expression. A gene coexpression network is created by taking
correlating the input gene expression matrix to genes that tend to be
expressed together. This matrix is then clustered to find gene modules.
</p>
<p>Note: This is intended for gene expression sampled from bulk sequencing.
Samples from single cell sequencing may work but will need to be
preprocessed due to the greater noise-to-signal ratio. See the speakeasyR
vignette for an example of single cell preprocessing. For more information
about working with single cell data see:
Malte D Luecken &amp; Fabian J Theis (2019) Current Best Practices in
Single‐cell Rna‐seq Analysis: a Tutorial, Molecular Systems Biology.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cluster_genes(
  gene_expression,
  k = NULL,
  discard_transient = 3,
  independent_runs = 10,
  max_threads = 0,
  seed = 0,
  target_clusters = 0,
  target_partitions = 5,
  subcluster = 1,
  min_clust = 5,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gene_expression</code></td>
<td>
<p>a matrix of gene expression data with data from
multiple samples (in the form genes x samples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of neighbors to include if converting to a k-nearest
neighbor graph. Should be a non-negative integer less than the number of
genes. If this value is not set the raw GCN is clustered. The kNN graph is
a sparse directed graph with binary edges between a node and it's most
similar k neighbors. Conversion to a kNN graph can provide good clustering
results much faster than using the full graph in cases with a large number
of genes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discard_transient</code></td>
<td>
<p>The number of partitions to discard before tracking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>independent_runs</code></td>
<td>
<p>How many runs SpeakEasy2 should perform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_threads</code></td>
<td>
<p>The maximum number of threads to use. By default this is
the same as the number of independent runs. If max_threads is greater than
or equal to the number of processing cores, all cores may run. If
max_threads is less than the number of cores, at most max_threads cores
will run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed to use for reproducible results. SpeakEasy2 uses a
different random number generator than R, but if the seed is not
explicitly set, R's random number generator is used create one. Because of
this, setting R's RNG will also cause reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_clusters</code></td>
<td>
<p>The number of random initial labels to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_partitions</code></td>
<td>
<p>Number of partitions to find per independent run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subcluster</code></td>
<td>
<p>Depth of clustering. If greater than 1, perform recursive
clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_clust</code></td>
<td>
<p>Smallest clusters to recursively cluster. If subcluster not
set to a value greater than 1, this has no effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to provide additional information about the
clustering or not.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A membership vector. If subclustering, returns a matrix with number
of rows equal to the number of recursive clustering. Each row is the
membership at different hierarchical scales, such that the last rows are
the highest resolution.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Set parameters
set.seed(123) # For reproducibility
ngene &lt;- 200
nsample &lt;- 1000
ncluster &lt;- 5

# Create a function to simulate gene expression data
simulate_gene_expression &lt;- function(ngene, nsample, ncluster) {
  # Initialize the expression matrix
  expr_matrix &lt;- matrix(0, nrow = ngene, ncol = nsample)

  # Create cluster centers for genes
  cluster_centers &lt;- matrix(rnorm(ncluster * nsample, mean = 5, sd = 2),
    nrow = ncluster, ncol = nsample
  )

  # Assign genes to clusters
  gene_clusters &lt;- sample(1:ncluster, ngene, replace = TRUE)

  for (i in 1:ngene) {
    cluster &lt;- gene_clusters[i]
    expr_matrix[i, ] &lt;- cluster_centers[cluster, ] +
      rnorm(nsample, mean = 0, sd = 1)
  }

  return(list(expr_matrix = expr_matrix, gene_clusters = gene_clusters))
}

# Simulate the data
simulated_data &lt;- simulate_gene_expression(ngene, nsample, ncluster)

# Extract the expression matrix and gene clusters
expr_matrix &lt;- simulated_data$expr_matrix
gene_clusters &lt;- simulated_data$gene_clusters

# Cluster and test quality of results
modules &lt;- cluster_genes(expr_matrix, max_threads = 2)
</code></pre>


</div>