<div class="container">

<table style="width: 100%;"><tr>
<td>run_method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run one or more methods on simulated data.</h2>

<h3>Description</h3>

<p>Given a <code>Method</code> object or list of <code>Method</code> objects,
this function runs the method(s) on the draws passed through <code>object</code>.
The output of each method is saved to file.
</p>


<h3>Usage</h3>

<pre><code class="language-R">run_method(object, methods, out_loc = "out", parallel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>DrawsRef</code> (or a list of
such objects) as returned by <code>link{simulate_from_model}</code>. If
<code>object</code> is a <code>Simulation</code>, then function is applied
to the referenced draws in that simulation and returns the same
<code>Simulation</code> object but with references added to the new outputs
created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>a list of <code>Method</code> and/or
<code>ExtendedMethod</code> objects or a single <code>Method</code>
or object <code>ExtendedMethod</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_loc</code></td>
<td>
<p>(optional) a length-1 character vector that gives location
(relative to model's path) that method outputs are stored.This can be
useful for staying organized when multiple simulations are based on
the same Model and Draws objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>either <code>NULL</code> or a list containing <code>socket_names</code>
and (optionally) <code>libraries</code> and <code>save_locally</code>
(see Details for more information)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function creates objects of class <code>Output</code> and saves each to
file (at dir/model_name/&lt;out_loc&gt;/r&lt;index&gt;_&lt;method_name&gt;.Rdata. If parallel
is not NULL, then it must be a list containing <code>socket_names</code>, which can
either be a positive integer specifying the number of copies to run on
localhost or else a character vector of machine names (e.g.,
"mycluster-0-0").  The list <code>parallel</code> can also contain
<code>libraries</code>, a character vector of R packages that will be needed on the
slaves and <code>save_locally</code>, a logical that indicates whether the files
generated should be saved on the slaves (i.e., locally) or on the master.
</p>
<p>Before running each method on index i, the RNG state is restored to what it
was at the end of calling <code>simulate_from_model</code> on this index.
This is only relevant for randomized methods.  The choice to do this ensures
that one will get identical results regardless of the order in which methods
and indices are run in.  When <code>ExtendedMethod</code> objects are
passed, these are run after all <code>Method</code> objects have been run.  This is
because each <code>ExtendedMethod</code> object depends on the output of its base
method.  Furthermore, before an <code>ExtendedMethod</code> is called, the RNG
state is restored to what it was after the base method had been called.
</p>


<h3>See Also</h3>

<p><code>generate_model</code> <code>simulate_from_model</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
 # suppose previously we had run the following:
 sim &lt;- new_simulation(name = "normal-example",
                       label = "Normal Mean Estimation",
                       dir = tempdir()) %&gt;%
   generate_model(make_my_example_model, n = 20) %&gt;%
   simulate_from_model(nsim = 50, index = 1:3)
 # then we could add
 sim &lt;- run_method(sim, my_example_method)
 
## End(Not run)
</code></pre>


</div>