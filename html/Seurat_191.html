<div class="container">

<table style="width: 100%;"><tr>
<td>IntegrateEmbeddings</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Integrate low dimensional embeddings</h2>

<h3>Description</h3>

<p>Perform dataset integration using a pre-computed Anchorset of specified low
dimensional representations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">IntegrateEmbeddings(anchorset, ...)

## S3 method for class 'IntegrationAnchorSet'
IntegrateEmbeddings(
  anchorset,
  new.reduction.name = "integrated_dr",
  reductions = NULL,
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'TransferAnchorSet'
IntegrateEmbeddings(
  anchorset,
  reference,
  query,
  query.assay = NULL,
  new.reduction.name = "integrated_dr",
  reductions = "pcaproject",
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  reuse.weights.matrix = TRUE,
  sd.weight = 1,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>anchorset</code></td>
<td>
<p>An AnchorSet object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Reserved for internal use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.reduction.name</code></td>
<td>
<p>Name for new integrated dimensional reduction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reductions</code></td>
<td>
<p>Name of reductions to be integrated. For a
TransferAnchorSet, this should be the name of a reduction present in the
anchorset object (for example, "pcaproject"). For an IntegrationAnchorSet,
this should be a <code>DimReduc</code> object containing all cells present
in the anchorset object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims.to.integrate</code></td>
<td>
<p>Number of dimensions to return integrated values for</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li>
<p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li>
<p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li>
<p>A vector of <code>DimReduc</code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li>
<p>NULL, in which case the full corrected space is used for computing
anchor weights.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code>hclust</code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>Reference object used in anchorset construction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>Query object used in anchorset construction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reuse.weights.matrix</code></td>
<td>
<p>Can be used in conjunction with the store.weights
parameter in TransferData to reuse a precomputed weights matrix.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main steps of this procedure are identical to <code>IntegrateData</code>
with one key distinction. When computing the weights matrix, the distance
calculations are performed in the full space of integrated embeddings when
integrating more than two datasets, as opposed to a reduced PCA space which
is the default behavior in <code>IntegrateData</code>.
</p>


<h3>Value</h3>

<p>When called on a TransferAnchorSet (from FindTransferAnchors), this
will return the query object with the integrated embeddings stored in a new
reduction. When called on an IntegrationAnchorSet (from IntegrateData), this
will return a merged object with the integrated reduction stored.
</p>


</div>