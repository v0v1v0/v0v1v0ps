<div class="container">

<table style="width: 100%;"><tr>
<td>condrmaxstab</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Conditional simulation of max-stable processes
</h2>

<h3>Description</h3>

<p>This function performs conditional simulation of various max-stable processes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">condrmaxstab(k = 1, coord, cond.coord, cond.data, cov.mod = "powexp",
..., do.sim = TRUE, thin = n.cond, burnin = 50, parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer. The number of conditional simulations to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of each
location. Each row corresponds to one location - if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond.coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of
each conditional location. Each row corresponds to one location - if
any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond.data</code></td>
<td>
<p>A vector that gives the conditional values at the
corresponding conditioning locations. Each row corresponds to one
location - if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.mod</code></td>
<td>
<p>A character string that gives the max-stable
model. This must be one of "brown" for the Brown-Resnick model, or
"whitmat", "cauchy", "powexp" and "bessel" for the Schlather model
with the given correlation family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The parameters of the max-stable model. See
<code>rmaxstab</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.sim</code></td>
<td>
<p>A logical value. If <code>TRUE</code> (the default), the
conditional simulations are performed; otherwise only the simulated
random partitions, i.e., the hitting scenarios, are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>A positive integer giving by which amount the generated Markov
chain should be thinned. This is only useful when the number of
conditioning locations is greater than 7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>A positive integer giving the duration of the burnin
period of the Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parts</code></td>
<td>
<p>A matrix giving the hitting scenarios. Each row
corresponds to one hitting scenarios. If missing then a Gibbs
sampler will  be used to generate such hitting scenarios.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm consists in three steps:
</p>

<ol>
<li>
<p> Draw a random partition <code class="reqn">\theta</code> from
</p>
<p style="text-align: center;"><code class="reqn">\Pr\{\theta = \tau \mid Z(x) = z\}</code>
</p>

</li>
<li>
<p> Given the random partition, draw the extremal functions from
</p>
<p style="text-align: center;"><code class="reqn">\Pr\{\varphi^+ \in \cdot \mid Z(x) = z, \theta =
      \tau\}</code>
</p>

</li>
<li>
<p> Independently, draw the sub-extremal functions, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\max_{i \ge 1} \varphi_i 1_{\{\varphi_i(x) &lt; z\}}</code>
</p>

</li>
</ol>
<p>The distribution in Step 1 is usually intractable and in such cases a
random scan Gibbs sampler will be used to sample from this
distribution.
</p>


<h3>Value</h3>

<p>This function returns a list whose components are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>The conditional simulations. Beware the first values
corresponds to the conditioning values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.ext.fct</code></td>
<td>
<p>The values of the sub-extremal functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ext.fct</code></td>
<td>
<p>The values of the extremal functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timings</code></td>
<td>
<p>The timings in seconds for each step of the algorithm.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>This function can be extremely time consuming when the number of
conditioning locations is large.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Dombry, C. and Eyi-Minko, F. (2012) Regular conditional distributions
of max infinitely divisible processes. <em>Submitted</em>.
</p>
<p>Dombry, C., Eyi-Minko, F. and Ribatet, M. (2012) Conditional
simulation of max-stable processes. To appear in <em>Biometrika</em>.
</p>


<h3>See Also</h3>

<p><code>rmaxstab</code>, <code>condrgp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">n.sim &lt;- 50
n.cond &lt;- 5

range &lt;- 10
smooth &lt;- 1.5

n.site &lt;- 200
coord &lt;- seq(-5, 5, length = n.site)
cond.coord &lt;- seq(-4, 4, length = n.cond)
all.coord &lt;- c(cond.coord, coord)

all.cond.data &lt;- rmaxstab(1, all.coord, "powexp", nugget = 0, range = range,
                      smooth = smooth)
cond.data &lt;- all.cond.data[1:n.cond]

ans &lt;- condrmaxstab(n.sim, coord, cond.coord, cond.data, range = range,
                    smooth = smooth, cov.mod = "powexp")

idx &lt;- order(all.coord)
matplot(coord, t(log(ans$sim)), type = "l", col = "grey", lty = 1,
        xlab = expression(x), ylab = expression(Z(x)))
lines(all.coord[idx], log(all.cond.data)[idx])
points(cond.coord, log(cond.data), pch = 15, col = 2)
</code></pre>


</div>