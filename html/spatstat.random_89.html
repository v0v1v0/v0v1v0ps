<div class="container">

<table style="width: 100%;"><tr>
<td>rmhcontrol</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set Control Parameters for Metropolis-Hastings Algorithm.</h2>

<h3>Description</h3>

<p>Sets up a list of parameters controlling the iterative behaviour
of the Metropolis-Hastings algorithm. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">   rmhcontrol(...)

   ## Default S3 method:
rmhcontrol(..., p=0.9, q=0.5, nrep=5e5,
                      expand=NULL, periodic=NULL, ptypes=NULL,
                      x.cond=NULL, fixall=FALSE, nverb=0,
                      nsave=NULL, nburn=nsave, track=FALSE,
                      pstage=c("block", "start"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Probability of proposing a shift (as against a birth/death).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Conditional probability of proposing a death given that a
birth or death will be proposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>Total number of steps (proposals) of Metropolis-Hastings
algorithm that should be run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>

<p>Simulation window or expansion rule.
Either a window (object of class <code>"owin"</code>)
or a numerical expansion factor, specifying that
simulations are to be performed in a domain other than the
original data window, then clipped to the original data window.
This argument is passed to <code>rmhexpand</code>.
A numerical expansion factor can be in several formats:
see <code>rmhexpand</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>periodic</code></td>
<td>

<p>Logical value (or <code>NULL</code>) indicating whether to simulate
“periodically”, i.e. identifying opposite edges of the rectangular
simulation window. A <code>NULL</code> value means “undecided.”
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptypes</code></td>
<td>
<p>For multitype point processes, the distribution of
the mark attached to a new random point (when a birth is
proposed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.cond</code></td>
<td>
<p>Conditioning points for conditional simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixall</code></td>
<td>
<p>(Logical) for multitype point processes,
whether to fix the number of points of each type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nverb</code></td>
<td>
<p>Progress reports will be printed every <code>nverb</code>
iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsave,nburn</code></td>
<td>

<p>If these values are specified, then
intermediate states of the simulation algorithm will be saved
every <code>nsave</code> iterations, after an initial burn-in period of
<code>nburn</code> iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>track</code></td>
<td>

<p>Logical flag indicating whether to save the transition
history of the simulations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pstage</code></td>
<td>

<p>Character string specifying when to generate
proposal points. Either <code>"start"</code> or <code>"block"</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Metropolis-Hastings algorithm, implemented as <code>rmh</code>,
generates simulated realisations of point process models.
The function <code>rmhcontrol</code>
sets up a list of parameters which control the 
iterative behaviour
and termination of the Metropolis-Hastings algorithm, for use in a
subsequent call to <code>rmh</code>. It also checks that the
parameters are valid.
</p>
<p>(A separate function <code>rmhstart</code>
determines the initial state of the algorithm,
and <code>rmhmodel</code> determines the model to be simulated.)
</p>
<p>The parameters are as follows:
</p>

<dl>
<dt>p</dt>
<dd>
<p>The probability of proposing a “shift”
(as opposed to a birth or death) in the Metropolis-Hastings
algorithm.
</p>
<p>If <code class="reqn">p = 1</code> then the algorithm only alters existing points,
so the number of points never changes, i.e. we are
simulating conditionally upon the number of points.
The number of points is determined by the initial state
(specified by <code>rmhstart</code>).
</p>
<p>If <code class="reqn">p=1</code> and <code>fixall=TRUE</code> and the model
is a multitype point process model, then the algorithm
only shifts the locations of existing points and does not
alter their marks (types). 
This is equivalent to simulating conditionally
upon the number of points of each type.
These numbers are again specified by the initial state.
</p>
<p>If <code class="reqn">p = 1</code> then no expansion of the simulation window
is allowed (see <code>expand</code> below).
</p>
<p>The default value of <code>p</code> can be changed by setting
the parameter <code>rmh.p</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>q</dt>
<dd>
<p>The conditional probability of proposing a death
(rather than a birth) given that a shift is not proposed.
This is of course ignored if <code>p</code> is equal to 1.
</p>
<p>The default value of <code>q</code> can be changed by setting
the parameter <code>rmh.q</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>nrep</dt>
<dd>
<p>The number of repetitions or iterations 
to be made by the Metropolis-Hastings algorithm.  It should
be large.
</p>
<p>The default value of <code>nrep</code> can be changed by setting
the parameter <code>rmh.nrep</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>expand</dt>
<dd>
<p>Either a number or a window (object of class <code>"owin"</code>).
Indicates that the process is to be simulated on a 
domain other than the original data window <code>w</code>,
then clipped to <code>w</code> when the algorithm has finished.
This would often be done in order to approximate the
simulation of a stationary process (Geyer, 1999)
or more generally a process existing in the
whole plane, rather than just in the window <code>w</code>.
</p>
<p>If <code>expand</code> is a window object, it is taken as the
larger domain in which simulation is performed.
</p>
<p>If <code>expand</code> is numeric, it is interpreted
as an expansion factor or expansion distance
for determining the simulation domain from the data window.
It should be a <em>named</em> scalar, such as
<code>expand=c(area=2)</code>, <code>expand=c(distance=0.1)</code>,
<code>expand=c(length=1.2)</code>.  See <code>rmhexpand()</code> for
more details. If the name is omitted, it defaults to <code>area</code>.
</p>
<p>Expansion is not permitted if the number of points has been
fixed by setting <code>p = 1</code> or if the
starting configuration has been specified via the
argument <code>x.start</code> in <code>rmhstart</code>.
</p>
<p>If <code>expand</code> is <code>NULL</code>, this is interpreted to mean
“not yet decided”. An expansion rule will be determined
at a later stage, using appropriate defaults.
See <code>rmhexpand</code>.
</p>
</dd>
<dt>periodic</dt>
<dd>
<p>A logical value (or <code>NULL</code>)
determining whether to simulate “periodically”.
If <code>periodic</code> is <code>TRUE</code>, and if the simulation window
is a rectangle, then the simulation algorithm effectively
identifies opposite edges of the rectangle. Points
near the right-hand edge of the rectangle are deemed to be close
to points near the left-hand edge. Periodic simulation usually
gives a better approximation to a stationary point process.
For periodic simulation, the simulation window must be a rectangle.
(The simulation window is determined by <code>expand</code> as described
above.)
</p>
<p>The value <code>NULL</code> means ‘undecided’.
The decision is postponed until <code>rmh</code> is called.
Depending on the point process model to be simulated,
<code>rmh</code> will then set <code>periodic=TRUE</code> if the simulation window
is expanded <em>and</em> the expanded simulation window is rectangular;
otherwise <code>periodic=FALSE</code>.
</p>
<p>Note that <code>periodic=TRUE</code> is only permitted when the
simulation window (i.e. the expanded window) is rectangular.       
</p>
</dd>
<dt>ptypes</dt>
<dd>
<p>A vector of probabilities (summing to 1) to be used
in assigning a random type to a new point.  Defaults to a vector
each of whose entries is <code class="reqn">1/nt</code> where <code class="reqn">nt</code> is the number
of types for the process.  Convergence of the simulation
algorithm should be improved if <code>ptypes</code> is close to the
relative frequencies of the types which will result from the
simulation.
</p>
</dd>
<dt>x.cond</dt>
<dd>
<p>If this argument is given,
then <em>conditional simulation</em> will be performed,
and <code>x.cond</code> specifies the location of the
fixed points as well as the type of conditioning.
It should be either a point pattern
(object of class <code>"ppp"</code>) or a <code>list(x,y)</code>
or a <code>data.frame</code>.
See the section on Conditional Simulation.
</p>
</dd>
<dt>fixall</dt>
<dd>
<p>A logical scalar specifying whether to condition on
the number of points of each type.  Meaningful only if a marked
process is being simulated, and if <code class="reqn">p = 1</code>.  A warning message
is given if <code>fixall</code> is set equal to <code>TRUE</code> when it is
not meaningful.
</p>
</dd>
<dt>nverb</dt>
<dd>
<p>An integer specifying how often “progress reports”
(which consist simply of the number of repetitions completed)
should be printed out.  If nverb is left at 0, the default,
the simulation proceeds silently.
</p>
</dd>
<dt>nsave,nburn</dt>
<dd>
<p>If these integers are given, then the
current state of the simulation algorithm (i.e. the current
random point pattern) will be saved every <code>nsave</code> iterations,
starting from iteration <code>nburn</code>.
(Alternatively <code>nsave</code> can be a vector, specifying
different numbers of iterations between each successive save.
This vector will be recycled until the end of the simulations.)
</p>
</dd>
<dt>track</dt>
<dd>
<p>Logical flag indicating whether to save the transition
history of the simulations (i.e. information specifying
what type of proposal was made, and whether it was accepted
or rejected, for each iteration).
</p>
</dd>
<dt>pstage</dt>
<dd>
<p>Character string specifying the stage of the algorithm
at which the randomised proposal points should be generated.
If <code>pstage="start"</code> or if <code>nsave=0</code>,
the entire sequence of <code>nrep</code>
random proposal points is generated at the start of the
algorithm. This is the original
behaviour of the code, and should be used in order to maintain
consistency with older versions of <span class="pkg">spatstat</span>.
If <code>pstage="block"</code> and <code>nsave &gt; 0</code>, then
a set of <code>nsave</code> random proposal points will be generated
before each block of <code>nsave</code> iterations. This is much more
efficient.
The default is <code>pstage="block"</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>An object of class <code>"rmhcontrol"</code>, which is essentially
a list of parameter values for the algorithm.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the parameters chosen.
</p>


<h3>Conditional Simulation</h3>

<p>For a Gibbs point process <code class="reqn">X</code>,
the Metropolis-Hastings algorithm easily accommodates several
kinds of conditional simulation:
</p>

<dl>
<dt>conditioning on the total number of points:</dt>
<dd>
<p>We fix the total number of points <code class="reqn">N(X)</code> to be equal to
<code class="reqn">n</code>. We simulate from the conditional distribution of
<code class="reqn">X</code> given <code class="reqn">N(X) = n</code>. 
</p>
</dd>
<dt>conditioning on the number of points of each type:</dt>
<dd>
<p>In a multitype point process, where <code class="reqn">Y_j</code> denotes the
process of points of type <code class="reqn">j</code>, we fix the number
<code class="reqn">N(Y_j)</code> of points of type <code class="reqn">j</code> to be equal to
<code class="reqn">n_j</code>, for <code class="reqn">j=1,2,\ldots,m</code>.
We simulate from the conditional distribution of <code class="reqn">X</code>
given <code class="reqn">N(Y_j)=n_j</code> for
<code class="reqn">j=1,2,\ldots,m</code>. 
</p>
</dd>
<dt>conditioning on the realisation in a subwindow:</dt>
<dd>
<p>We require that the point process <code class="reqn">X</code> should,
within a specified sub-window <code class="reqn">V</code>,
coincide with a specified point pattern <code class="reqn">y</code>.
We simulate from the conditional distribution of <code class="reqn">X</code>
given <code class="reqn">X \cap V = y</code>.
</p>
</dd>
<dt>Palm conditioning:</dt>
<dd>
<p>We require that the point process <code class="reqn">X</code> include
a specified list of points <code class="reqn">y</code>. We simulate from
the point process with probability density
<code class="reqn">g(x) = c f(x \cup y)</code>
where <code class="reqn">f</code> is the probability density of the original
process <code class="reqn">X</code>, and <code class="reqn">c</code> is a normalising constant.
</p>
</dd>
</dl>
<p>To achieve each of these types of conditioning we
do as follows:
</p>

<dl>
<dt>conditioning on the total number of points:</dt>
<dd>
<p>Set <code>p=1</code>.
The number of points is determined by the initial state
of the simulation: see <code>rmhstart</code>.
</p>
</dd>
<dt>conditioning on the number of points of each type:</dt>
<dd>
<p>Set <code>p=1</code> and <code>fixall=TRUE</code>.
The number of points of each type is determined by the initial state
of the simulation: see <code>rmhstart</code>.
</p>
</dd>
<dt>conditioning on the realisation in a subwindow:</dt>
<dd>
<p>Set <code>x.cond</code> to be a point pattern (object of
class <code>"ppp"</code>). Its window <code>V=Window(x.cond)</code> becomes the
conditioning subwindow <code class="reqn">V</code>.
</p>
</dd>
<dt>Palm conditioning:</dt>
<dd>
<p>Set <code>x.cond</code> to be a <code>list(x,y)</code> or <code>data.frame</code>
with two columns containing the coordinates of the points, or a 
<code>list(x,y,marks)</code> or <code>data.frame</code> with three columns
containing the coordinates and marks of the points.
</p>
</dd>
</dl>
<p>The arguments <code>x.cond</code>, <code>p</code> and <code>fixall</code> can be
combined.   
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79–140.
</p>


<h3>See Also</h3>

<p><code>rmh</code>,
<code>rmhmodel</code>,
<code>rmhstart</code>,
<code>rmhexpand</code>,
<code>spatstat.options</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   # parameters given as named arguments
   c1 &lt;- rmhcontrol(p=0.3,periodic=TRUE,nrep=1e6,nverb=1e5)

   # parameters given as a list
   liz &lt;- list(p=0.9, nrep=1e4)
   c2 &lt;- rmhcontrol(liz)

   # parameters given in rmhcontrol object
   c3 &lt;- rmhcontrol(c1)
</code></pre>


</div>