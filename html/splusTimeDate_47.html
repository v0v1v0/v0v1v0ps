<div class="container">

<table style="width: 100%;"><tr>
<td>timeDate-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Time and Date Class
</h2>

<h3>Description</h3>

<p>The <code>timeDate</code> class represents times and dates.
</p>


<h3>Details</h3>

<p>This class holds a vector of times and/or dates.
It extends the <code>groupVec</code> class, as well as the
<code>positionsCalendar</code> class (see the documentation for the <code>positions</code> class).
</p>
<p>The <code>groupVec</code> portion of a time object holds a
date portion, stored as a vector of the days since January 1, 1960, and a
time portion, stored as a vector of the number of milliseconds since
midnight, GMT.  The <code>groupVec</code> column names are <code>"julian.day"</code> and
<code>"milliseconds"</code>, and the column classes are <code>integer</code>.
</p>
<p>The string in the <code>time.zome</code> slot must be one of the names
from the time zone list (see the <code>timeZoneList</code>
documentation).  Because times are stored
internally always in GMT, the time-zone string is used for
printing and for converting to calendar times and dates
(month/day/year, hour/minute/second/millisecond). You can change these directly.
You can also change the format directly, but we do not recommend changing the
<code>groupVec</code> slots directly.
</p>


<h3>Slots</h3>


<dl>
<dt>columns</dt>
<dd>
<p>(<code>list</code>) (from <code>groupVec</code>).
</p>
</dd>
<dt>names</dt>
<dd>
<p>(<code>character</code>) (from <code>groupVec</code>).
</p>
</dd>
<dt>classes</dt>
<dd>
<p>(<code>character</code>) (from <code>groupVec</code>).
</p>
</dd>
<dt>format</dt>
<dd>
<p>(<code>character</code>) output format string.
</p>
</dd>
<dt>time.zone</dt>
<dd>
<p>(<code>character</code>) time zone string.
</p>
</dd>
</dl>
<h3>Time functions</h3>

<p>Objects of <code>class.time</code> can be created using the <code>new</code> function, in
which case they are constructed to have length 0 and the default format and
zone from <code>timeDateOptions("time.out.format")</code> and <code>timeDateOptions("time.zone")</code>
respectively.  Alternatively, they can be created using the <code>timeDate</code> and
<code>timeCalendar</code> functions.
</p>
<p>There are <code>as</code> relationships set up for <code>timeDate</code> objects to coerce them to
and from <code>character</code>, <code>numeric</code>, and <code>integer</code>.
</p>
<p>For numbers, the integer part is the julian day, and the fractional part is the
fraction of the day given by the number of milliseconds divided by the
number of milliseconds in a day, in GMT. 
</p>
<p>Addition of numbers to time objects and subtraction of numerics from time objects works as
though the time were converted to a number, the operation were
performed, and the number was converted back to a
time. Their subtraction results in a <code>timeSpan</code> object, and a
<code>timeSpan</code> object can be added to or subtracted from a time.
</p>
<p>Only a few other mathematical functions make sense for time objects:
<code>floor</code>, <code>ceiling</code>, <code>min</code>, <code>max</code>, <code>mean</code>, and <code>range</code>.
Multiplication, division, and other operations that do not
make sense for times and dates (in the absence of an origin) result in
numbers, via automatic coercion to class <code>numeric</code>.
</p>
<p>Note that while conversion to/from numerics is always in GMT, <code>floor</code>
and <code>ceiling</code> take account of
the time zone to ouput time objects whose time is midnight in their
time zone, and whose date is no later than the input time's date for
<code>floor</code>, and no earlier for <code>ceiling</code>.  In addition to these mathematical
operations, all of the standard comparison operators have methods for
comparing two time objects.
</p>
<p>There are also functions for time objects that pick out particular
parts.  See <code>days</code>, <code>hours</code>, and <code>mdy</code> for more information.
</p>
<p>Various options are used by the time class, primarily for printing to and
reading from character strings.  See <code>timeDateOptions</code> for documentation.
</p>


<h3>Formatting</h3>

<p>The input and output format specifications look familiar to C and IMOX
programmers and are patterned on the
<code>strptime</code> function under Solaris.
</p>


<h3>Input formats</h3>

<p>Input format strings are used to convert character strings to time objects.
When reading time objects, the default of January 1, 1960, Midnight GMT
is supplied, and the input format specifications below can be used
to override this default time.  They are read in from left to right.
If the entire input string is not matched by the format string, or if
the resulting time or date is not valid, an <code>NA</code> is inserted into the time
vector.  (To skip characters in a string, use %c or %w.)
</p>
<p><strong>NOTE</strong>: If you are reading a time zone from your
character string, the notation used for the time zone in your character
string must be one of the components of the time zone list.  See
documentation for <code>timeZoneList</code> for more information.
</p>

<dl>
<dt>*</dt>
<dd>
<p>anything not in this list matches itself explicitly.
</p>
</dd>
<dt>%c</dt>
<dd>
<p>any single character, which is skipped. This is useful for skipping entries like days of the week, which, if
abbreviated, could be skipped by "%3c" (see also %w). To skip the rest of the string, use "%$c".
</p>
</dd>
<dt>%d</dt>
<dd>
<p>input day, within a month, as integer.
</p>
</dd>
<dt>%H</dt>
<dd>
<p>input hour as integer.
</p>
</dd>
<dt>%m</dt>
<dd>
<p>input month as integer or as alpha string.  If an alpha
string, case does not matter, and any substring of a month in
<code>timeDateOptions("time.month.name")</code> that distinguishes it from the other
months is accepted.
</p>
</dd>
<dt>%M</dt>
<dd>
<p>input minute as integer.
</p>
</dd>
<dt>%n</dt>
<dd>
<p>input milliseconds as integer, without considering field width as in %N.
</p>
</dd>
<dt>%N</dt>
<dd>
<p>input milliseconds as integer.  A field width (either given
explicitly or inferred from input string) of 1 or 2 causes input
of 10ths or 100ths of a second instead, as if the digits were
following a period.  Field widths greater than 3 are likely to
result in illegal input.
</p>
</dd>
<dt>%p</dt>
<dd>
<p>accepts strings from <code>timeDateOptions("time.am.pm")</code>, defining <code>am</code> and <code>pm</code>, with
matching as for months.  If <code>pm</code> is given, and the hour is before 13, the time is
bumped into the afternoon.  If <code>am</code> is given, and the hour is 12, the time
is bumped into the morning.  Note that this modifies previously-parsed hours only.
</p>
</dd>
<dt>%S</dt>
<dd>
<p>input seconds as integer.
</p>
</dd>
<dt>%w</dt>
<dd>
<p>a whitespace-delimited word, which is skipped (no width or
delimiter specification. For that, use %c).
</p>
</dd>
<dt>%y</dt>
<dd>
<p>input year as integer.  If less than 100,
<code>timeDateOptions("time.century")</code> is used to determine the actual year.
</p>
</dd>
<dt>%Y</dt>
<dd>
<p>input year as integer, without considering the century.
</p>
</dd>
<dt>%Z</dt>
<dd>
<p>a time zone string.  Accepts a whitespace-delimited word, unless
another delimiter or width is specified.  The legal time zones are
the names of <code>timeZoneList()</code>.
</p>
</dd>
<dt>%(digits)(char)</dt>
<dd>
<p>if there are one or more digits between "%" and the
specification character, these are parsed as an integer, and specify
the field width to be used.  The following (digits) characters are
scanned for the specified item.
</p>
</dd>
<dt>%:(delim)(char)</dt>
<dd>
<p>if there is a colon and any single character
between a "%" and the specification character, the field is taken to
be all the characters up to but not including the given delimiter
character.  The delimiter itself is not scanned or skipped by the
format.
</p>
</dd>
<dt>%$(char)</dt>
<dd>
<p>If there is a $ between a % and a specification character,
the field goes to the end of the input string.
</p>
</dd>
<dt>whitespace</dt>
<dd>
<p>whitespace (spaces, tabs, carriage returns, and so on) is ignored in
the input format string.  In the string being
parsed, any amount of white space can appear between elements of the
date/time.  Thus, the parse format string " %H:%M: %S " parses "5: 6:45".
</p>
</dd>
<dt>[...]</dt>
<dd>
<p>specify optional specification.  Text and specifications
within the brackets optionally can be included.  This does not
support fancy backtracking between multiple optional specs.
</p>
</dd>
<dt>%%,%[,%]</dt>
<dd>
<p>the %, [, and ] characters, which must be matched in
the input string.
</p>
</dd>
</dl>
<p>The default format for input is initially:<br><code>"%m[/][.]%d[/][,]%y [%H[:%M[:%S[.%N]]][%p][[(]%3Z[)]]]"</code><br>
This allows reading strings such as:<br><code>"Jan 22 1997"</code>, <code>"January 22, 1997"</code>, <code>"1/22/97"</code>, <code>"1/22/97 2PM"</code>
</p>


<h3>Output formats</h3>

<p>Output formats are used to convert time objects to character strings.
They are stored in the format slot of the time object. During output,
if a given field width is too short to hold the output, if that
output field is a character field, the leftmost characters are
printed, but if it is a numeric field, the output string becomes "NA".
The following format specifications can be used:
</p>

<dl>
<dt>*</dt>
<dd>
<p>anything not in this list matches itself explicitly (including
whitespace, unlike in input specs).
</p>
</dd>
<dt>%a</dt>
<dd>
<p>print abbreviated weekday ("Mon", and so on) from timeDateOptions("time.day.abb").
</p>
</dd>
<dt>%A</dt>
<dd>
<p>print full weekday ("Monday", and so on) from timeDateOptions("time.day.name").
</p>
</dd>
<dt>%b</dt>
<dd>
<p>print month as abbreviation, from timeDateOptions("time.month.abb").
</p>
</dd>
<dt>%B</dt>
<dd>
<p>print month as full name, from timeDateOptions("time.month.name").
</p>
</dd>
<dt>%C</dt>
<dd>
<p>print year within century as integer: 0-99.
</p>
</dd>
<dt>%d</dt>
<dd>
<p>print day within month as integer: 1-31.
</p>
</dd>
<dt>%D</dt>
<dd>
<p>print day within year as integer: 1-366.
</p>
</dd>
<dt>%H</dt>
<dd>
<p>print hour (24-hour clock) as integer, 0-23.
</p>
</dd>
<dt>%I</dt>
<dd>
<p>print hour (12-hour clock) as integer, 1-12.
</p>
</dd>
<dt>%m</dt>
<dd>
<p>print month as integer: 1-12.
</p>
</dd>
<dt>%M</dt>
<dd>
<p>print minutes as integer: 0-59.
</p>
</dd>
<dt>%N</dt>
<dd>
<p>print milliseconds as integer.  It is a good idea to pad with zeros if this is
after a decimal point!  A width of less than 3 causes printing
of 10ths or 100ths of a second instead: 0-999.
</p>
</dd>
<dt>%p</dt>
<dd>
<p>print  "am" or "pm", using strings from timeDateOptions("time.am.pm").
</p>
</dd>
<dt>%q</dt>
<dd>
<p>print quarter of the year, as integer: 1-4.
</p>
</dd>
<dt>%Q</dt>
<dd>
<p>print quarter of the year, as Roman numeral: I-IV.
</p>
</dd>
<dt>%S</dt>
<dd>
<p>print seconds as integer: 0-59 (60 for leap second).
</p>
</dd>
<dt>%y</dt>
<dd>
<p>print year as two-digit integer if year is in century specified
by timeDateOptions("time.century"), otherwise full year.
</p>
</dd>
<dt>%Y</dt>
<dd>
<p>print full year as integer (see also %C).
</p>
</dd>
<dt>%Z</dt>
<dd>
<p>print the time zone string from the objects <code>time.zone</code> slot.
</p>
</dd>
<dt>%z</dt>
<dd>
<p>print the time zone string from the objects <code>time.zone</code> slot,
using the part before the first <code>"/"</code> character if it is standard
time, and the part after the first <code>"/"</code> character if it is daylight
savings time (that is, if the time zone is <code>"PST/PDT"</code>).  If there is no
<code>"/"</code> character, the entire time zone is used for both.
</p>
</dd>
<dt>%%</dt>
<dd>
<p>print the % character
</p>
</dd>
<dt>%(digits)(char)</dt>
<dd>
<p>if there are one or more digits between "%" and the
specification character, these are parsed as an integer, and specify
the field width to use.  The value is printed, right justified
using (digits) characters.  If (digits) begins with zero, the field
is left-padded with zeros if it is a numeric field, otherwise it is
left-padded with spaces. If a numeric value is too long for the field
width, the field is replaced with asterix "*" characters to indicate
overflow; character strings can be abbreviated by specifying short fields.
</p>
</dd>
</dl>
<p>The default format for output is initially:<br><code>"%02m/%02d/%Y %02H:%02M:%02S.%03N"</code><br>
Another choice would be:<br><code>"%A %B %d, %Y %I:%02M %p"</code><br>
These would result in the following output:<br><code>"01/22/1997 14:34:45.025"</code> and <code>"Thursday January 22, 1997 2:34 PM"</code><br></p>


<h3>Note</h3>

<p>The calendar follows the conventions of the British Empire, which
changed from Julian to Gregorian calendars in September of 1752.
Calendar dates prior to 1920 were different in many countries.  See
the "Calendar FAQ" posted regularly to Usenet news groups soc.history,
sci.astro, sci.answers, soc.answers, and news.answers, and to a web
site at http://www.pip.dknet.dk/~c-t/calendar.html for more
information on the history of calendars around the world.
The time objects allow days with leap seconds, but calculated times
of day for days containing leap seconds might be off by a second; they
are treated as though the leap second occurred at the very end of the day,
because there is currenly no provision in the splusTimeDate package
for keeping track of leap seconds.
</p>


<h3>See Also</h3>

<p><code>groupVec</code> class, <code>timeSpan</code> class, <code>timeDateOptions</code>, <code>timeDate</code> function, <code>timeCalendar</code>, <code>format.timeDate</code>.
</p>


</div>