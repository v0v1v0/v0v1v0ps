<div class="container">

<table style="width: 100%;"><tr>
<td>sasfclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse and Smooth Functional Data Clustering</h2>

<h3>Description</h3>

<p>Sparse and smooth functional clustering (SaS-Funclust) allows to cluster a sample of curves
into homogeneous groups while jointly detecting the most informative portion of domain. (Centofanti et al., 2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sasfclust(
  X = NULL,
  timeindex = NULL,
  curve = NULL,
  grid = NULL,
  q = 30,
  lambda_l = 10,
  lambda_s = 10,
  G = 2,
  tol = 10^-7,
  maxit = 50,
  par_LQA = list(eps_diff = 1e-06, MAX_iter_LQA = 200, eps_LQA = 1e-05),
  plot = F,
  trace = F,
  init = "kmeans",
  varcon = "diagonal",
  lambda_s_ini = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For functional data observed over a regular grid: a matrix of where  the rows must correspond to argument values and columns to replications.
For functional data observed over an irregular grid:  a vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>, with <code class="reqn">N</code>  the number of curves,
where the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are elements representing the observations for curve <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeindex</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> provide the locations on <code>grid</code> of curve  <code class="reqn">k</code>.
So for example, if the <code class="reqn">k</code>th curve is observed at time points <code class="reqn">t_l,t_m</code> of the <code>grid</code> then the the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> would be <code class="reqn">l,m</code>, being <code class="reqn">n_k=2</code>.
If X is a matrix, timeindex is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curve</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are equal to  <code class="reqn">k</code>.
If X is a matrix, curve is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>The vector of time points where the curves are sampled.
For Functional data observed over an irregular grid, <code>timeindex</code> and <code>grid</code> provide the time points for each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The dimension of the set of B-spline functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_l</code></td>
<td>
<p>Tuning parameter of the functional adaptive pairwise fusion penalty (FAPFP).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_s</code></td>
<td>
<p>Tuning parameter of the smoothness penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>The number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance for the stopping condition of the expectation conditional maximization (ECM) algorithms.
The algorithm stops when the log-likelihood difference between two consecutive iterations is less or equal than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the ECM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_LQA</code></td>
<td>
<p>A list of parameters for the local quadratic approximation (LQA) in the ECM algorithm.
<code>eps_diff</code> is the lower bound for the coefficient mean differences, values below <code>eps_diff</code> are set to zero.
<code>MAX_iter_LQA</code> is the maximum number of iterations allowed in the LQA.
<code>eps_LQA</code> is the tolerance for the stopping condition of LQA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>If TRUE, the estimated cluster means are plotted at each iteration of the ECM algorithm. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If TRUE, information are shown at each iteration of the ECM algorithm. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>It is the way to initialize the ECM algorithm. There are three ways of initialization: "kmeans", "model-based", and "hierarchical", that
provide initialization through the k-means algorithm,  model-based clustering based on parameterized finite Gaussian mixture model, and  hierarchical clustering, respectively.
Default is "kmeans".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcon</code></td>
<td>
<p>A vector of character strings indicating the type of coefficient covariance matrix. Three values are allowed: "full", "diagonal", and "equal".
"full" means unrestricted cluster coefficient covariance matrices allowed to be different among clusters.
"diagonal" means diagonal cluster coefficient covariance matrices that are equal among clusters.
"equal" means diagonal cluster coefficient covariance matrices, with equal diagonal entries, that are equal among clusters.
Default is "diagonal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_s_ini</code></td>
<td>
<p>The tuning parameter used to obtain the functional data through smoothing B-splines before applying the initialization algorithm.
If NULL a Generalized cross validation procedure is used as described in Ramsay (2005). Default is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following arguments:
<code>mod</code> that is a list composed by
</p>

<ul>
<li> <p><code>data</code>: A list containing the vectorized form of <code>X</code>, <code>timeindex</code>, and <code>curve</code>. For functional data observed over a regular grid <code>timeindex</code> and <code>curve</code> are trivially obtained.
</p>
</li>
<li> <p><code>parameters</code>: A list containing all the estimated parameters.
</p>
</li>
<li> <p><code>vars</code>: A list containing results from the Expectation step of the ECM algorithm.
</p>
</li>
<li> <p><code>FullS</code>: The matrix of B-spline computed over <code>grid</code>.
</p>
</li>
<li> <p><code>grid</code>: The vector of time points where the curves are sampled.
</p>
</li>
<li> <p><code>W</code>: The basis roughness penalty matrix containing the inner products of pairs of basis function second derivatives.
</p>
</li>
<li> <p><code>AW_vec</code>: Vectorized version of the diagonal matrix used in the approximation of FAPFP.
</p>
</li>
<li> <p><code>P_tot</code>: Sparse Matrix used to compute all the pairwise comparisons in the FAPFP.
</p>
</li>
<li> <p><code>lambda_s</code>: Tuning parameter of the smoothness penalty.
</p>
</li>
<li> <p><code>lambda_l</code>: Tuning parameter of the FAPFP.
</p>
</li>
</ul>
<p>A list, named <code>clus</code>, containing the following arguments:
</p>

<ul>
<li> <p><code>classes</code>: The vector of cluster membership.
</p>
</li>
<li> <p><code>po_pr</code>: Posterior probabilities of cluster membership.
</p>
</li>
</ul>
<p><code>mean_fd</code> The estimated cluster mean functions.
</p>
<p><code>class</code> A label for the output type.
</p>


<h3>References</h3>

<p>Centofanti, F., Lepore, A., &amp; Palumbo, B. (2021).
Sparse and Smooth Functional Data Clustering.
<em>arXiv preprint arXiv:2103.15224</em>.
</p>
<p>Ramsay, J., Ramsay, J., &amp; Silverman, B. W. (2005). Functional Data Analysis. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

<p><code>sasfclust_cv</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
mod&lt;-sasfclust(X=train$X,grid=train$grid,lambda_s = 10^-6,lambda_l =10,G = 2,maxit = 5,q=10)
plot(mod)
</code></pre>


</div>