<div class="container">

<table style="width: 100%;"><tr>
<td>regexpr2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Locate Pattern Occurrences</h2>

<h3>Description</h3>

<p><code>regexpr2</code> and <code>gregexpr2</code> locate, respectively, first and all
(i.e., <b>g</b>lobally) occurrences of a pattern.
<code>regexec2</code> and <code>gregexec2</code> can additionally
pinpoint the matches to parenthesised subexpressions (regex capture groups).
</p>


<h3>Usage</h3>

<pre><code class="language-R">regexpr2(x, pattern, ..., ignore_case = FALSE, fixed = FALSE)

gregexpr2(x, pattern, ..., ignore_case = FALSE, fixed = FALSE)

regexec2(x, pattern, ..., ignore_case = FALSE, fixed = FALSE)

gregexec2(x, pattern, ..., ignore_case = FALSE, fixed = FALSE)

regexpr(
  pattern,
  x = text,
  ...,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  text
)

gregexpr(
  pattern,
  x = text,
  ...,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  text
)

regexec(
  pattern,
  x = text,
  ...,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  text
)

gregexec(
  pattern,
  x = text,
  ...,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  text
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>character vector whose elements are to be examined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>character vector of nonempty search patterns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>stri_locate</code>,
e.g., <code>omit_empty</code>, <code>locale</code>, <code>dotall</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_case, ignore.case</code></td>
<td>
<p>single logical value; indicates whether matching
should be case-insensitive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>single logical value;
<code>FALSE</code> for matching with regular expressions
(see about_search_regex);
<code>TRUE</code> for fixed pattern matching
(about_search_fixed);
<code>NA</code> for the Unicode collation algorithm
(about_search_coll)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl, useBytes</code></td>
<td>
<p>not used (with a warning if
attempting to do so) [DEPRECATED]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text</code></td>
<td>
<p>alias to the <code>x</code> argument [DEPRECATED]</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are fully vectorised with respect to both <code>x</code> and
<code>pattern</code>.
</p>
<p>Use <code>substrl</code> and <code>gsubstrl</code>
to extract or replace the identified chunks.
Also, consider using <code>regextr2</code> and
<code>gregextr2</code> directly instead.
</p>


<h3>Value</h3>

<p><code>regexpr2</code> and [DEPRECATED] <code>regexpr</code> return an integer vector
which gives the start positions of the first substrings matching a pattern.
The <code>match.length</code> attribute gives the corresponding
match lengths. If there is no match, the two values are set to -1.
</p>
<p><code>gregexpr2</code> and [DEPRECATED] <code>gregexpr</code> yield
a list whose elements are integer vectors with <code>match.length</code>
attributes, giving the positions of all the matches.
For consistency with <code>regexpr2</code>, a no-match is denoted with
a single -1, hence the output is guaranteed to consist of non-empty integer
vectors.
</p>
<p><code>regexec2</code> and [DEPRECATED] <code>regexec</code> return
a list of integer vectors giving the positions of the first matches
and the locations of matches to the consecutive parenthesised subexpressions
(which can only be recognised if <code>fixed=FALSE</code>).
Each vector is equipped with the <code>match.length</code> attribute.
</p>
<p><code>gregexec2</code> and [DEPRECATED] <code>gregexec</code> generate
a list of matrices, where each column corresponds to a separate match;
the first row is the start index of the match, the second row gives the
position of the first captured group, and so forth.
Their <code>match.length</code> attributes are matrices of corresponding sizes.
</p>
<p>These functions preserve the attributes of the longest inputs (unless they
are dropped due to coercion). Missing values in the inputs are propagated
consistently.
</p>


<h3>Differences from Base R</h3>

<p>Replacements for base <code>gregexpr</code> (and others)
implemented with <code>stri_locate</code>.
</p>

<ul>
<li>
<p> there are inconsistencies between the argument order and naming
in <code>grepl</code>, <code>strsplit</code>,
and <code>startsWith</code> (amongst others); e.g.,
where the needle can precede the haystack, the use of the forward
pipe operator, <code>|&gt;</code>, is less convenient
<b>[fixed here]</b>
</p>
</li>
<li>
<p> base R implementation is not portable as it is based on
the system PCRE or TRE library
(e.g., some Unicode classes may not be available or matching thereof
can depend on the current <code>LC_CTYPE</code> category
<b>[fixed here]</b>
</p>
</li>
<li>
<p> not suitable for natural language processing
<b>[fixed here â€“ use <code>fixed=NA</code>]</b>
</p>
</li>
<li>
<p> two different regular expression libraries are used
(and historically, ERE was used in place of TRE)
<b>[here, <span class="pkg">ICU</span> Java-like regular expression engine
is only available, hence the <code>perl</code> argument has no meaning]</b>
</p>
</li>
<li>
<p> not vectorised w.r.t. <code>pattern</code>
<b>[fixed here]</b>
</p>
</li>
<li> <p><code>ignore.case=TRUE</code> cannot be used with <code>fixed=TRUE</code>
<b>[fixed here]</b>
</p>
</li>
<li>
<p> no attributes are preserved
<b>[fixed here; see Value]</b>
</p>
</li>
<li>
<p> in <code>regexec</code>, <code>match.length</code> attribute is unnamed
even if the capture groups are (but <code>gregexec</code> sets dimnames
of both start positions and lengths)
<b>[fixed here]</b>
</p>
</li>
<li> <p><code>regexec</code> and <code>gregexec</code> with <code>fixed</code> other than
<code>FALSE</code> make little sense.
<b>[this argument is [DEPRECATED] in <code>regexec2</code>
and <code>gregexec2</code>]</b>
</p>
</li>
<li> <p><code>gregexec</code> does not always yield a list of matrices
<b>[fixed here]</b>
</p>
</li>
<li>
<p> a no-match to a conditional capture group is assigned length 0
<b>[fixed here]</b>
</p>
</li>
<li>
<p> no-matches result in a single -1, even if capture groups are
defined in the pattern
<b>[fixed here]</b>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringx</span> at <a href="https://stringx.gagolewski.com/">https://stringx.gagolewski.com/</a>
</p>
<p>Related function(s): <code>paste</code>, <code>nchar</code>,
<code>strsplit</code>, <code>gsub2</code>,
<code>grepl2</code>, <code>gregextr2</code>, <code>gsubstrl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(aca1="acacaca", aca2="gaca", noaca="actgggca", na=NA)
regexpr2(x, "(A)[ACTG]\\1", ignore_case=TRUE)
regexpr2(x, "aca") &gt;= 0  # like grepl2
gregexpr2(x, "aca", fixed=TRUE, overlap=TRUE)

# two named capture groups:
regexec2(x, "(?&lt;x&gt;a)(?&lt;y&gt;cac?)")
gregexec2(x, "(?&lt;x&gt;a)(?&lt;y&gt;cac?)")

# extraction:
gsubstrl(x, gregexpr2(x, "(A)[ACTG]\\1", ignore_case=TRUE))
gregextr2(x, "(A)[ACTG]\\1", ignore_case=TRUE)  # equivalent

</code></pre>


</div>