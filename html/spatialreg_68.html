<div class="container">

<table style="width: 100%;"><tr>
<td>lextrB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find extreme eigenvalues of binary symmetric spatial weights</h2>

<h3>Description</h3>

<p>The functions find extreme eigenvalues of binary symmetric spatial weights, when these form planar graphs; general weights are not permiited. <code>l_max</code> finds the largest eigenvalue using Rayleigh quotient methods of any “listw” object. <code>lextrB</code> first calls <code>l_max</code>, and uses its output to find the smallest eigenvalue in addition for binary symmetric spatial weights. <code>lextrW</code> extends these to find the smallest eigenvalue for intrinsically symmetric row-standardized binary weights matrices (transformed to symmetric through similarity internally). <code>lextrS</code> does the same for variance-stabilized (“S” style) intrinsically symmetric binary weights matrices (transformed to symmetric through similarity internally).</p>


<h3>Usage</h3>

<pre><code class="language-R">lextrB(lw, zero.policy = TRUE, control = list())
lextrW(lw, zero.policy=TRUE, control=list())
lextrS(lw, zero.policy=TRUE, control=list())
l_max(lw, zero.policy=TRUE, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lw</code></td>
<td>
<p>a binary symmetric <code>listw</code> object from, for example, <code>nb2listw</code> with style “B” for <code>lextrB</code>, style “W” for <code>lextrW</code> and style “S” for <code>lextrS</code>; for <code>l_max</code>, the object may be asymmetric and does not have to be binary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The functions return approximations to the extreme eigenvalues with the eigenvectors returned as attributes of this object.
</p>


<h3>Control arguments</h3>


<dl>
<dt>trace</dt>
<dd>
<p>report values in while loops, default NULL assuming FALSE; logical</p>
</dd>
<dt>tol</dt>
<dd>
<p>tolerance for breaking while loops, default <code>.Machine$double.eps^(1/2)</code>; numeric</p>
</dd>
<dt>maxiter</dt>
<dd>
<p>maximum number of iterations in while loops, default <code>6 * (length(lw$neighbours) - 2</code>; integer</p>
</dd>
<dt>useC</dt>
<dd>
<p>use C code, default TRUE, logical (not in <code>l_max</code>)</p>
</dd>
</dl>
<h3>Note</h3>

<p>It may be necessary to modify control arguments if warnings about lack of convergence are seen.</p>


<h3>Author(s)</h3>

<p>Roger Bivand, Yongwan Chun, Daniel Griffith</p>


<h3>References</h3>

<p>Griffith, D. A. (2004). Extreme eigenfunctions of adjacency matrices for planar graphs employed in spatial analyses. <em>Linear Algebra and its Applications</em>, 388:201–219.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(boston, package="spData")
#require(spdep, quietly=TRUE)
ab.listb &lt;- spdep::nb2listw(boston.soi, style="B")
er &lt;- range(eigenw(ab.listb))
er
res_1 &lt;- lextrB(ab.listb)
c(res_1)
run &lt;- FALSE
if (require("RSpectra", quietly=TRUE)) run &lt;- TRUE
if (run) {
B &lt;- as(ab.listb, "CsparseMatrix")
eigs(B, k=1, which="SR")$values
}
if (run) {
eigs(B, k=1, which="LR")$values
}
k5 &lt;- spdep::knn2nb(spdep::knearneigh(boston.utm, k=5))
c(l_max(spdep::nb2listw(k5, style="B")))
max(Re(eigenw(spdep::nb2listw(k5, style="B"))))
c(l_max(spdep::nb2listw(k5, style="C")))
max(Re(eigenw(spdep::nb2listw(k5, style="C"))))
ab.listw &lt;- spdep::nb2listw(boston.soi, style="W")
er &lt;- range(eigenw(similar.listw(ab.listw)))
er
res_1 &lt;- lextrW(ab.listw)
c(res_1)
if (run) {
B &lt;- as(similar.listw(ab.listw), "CsparseMatrix")
eigs(B, k=1, which="SR")$values
}
if (run) {
eigs(B, k=1, which="LR")$values
}
## Not run: 
ab.listw &lt;- spdep::nb2listw(boston.soi, style="S")
er &lt;- range(eigenw(similar.listw(ab.listw)))
er
res_1 &lt;- lextrS(ab.listw)
c(res_1)

## End(Not run)
if (run) {
B &lt;- as(similar.listw(ab.listw), "CsparseMatrix")
eigs(B, k=1, which="SR")$values
}
if (run) {
eigs(B, k=1, which="LR")$values
}
</code></pre>


</div>