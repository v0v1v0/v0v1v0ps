<div class="container">

<table style="width: 100%;"><tr>
<td>semPower.powerLI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>semPower.powerLI</h2>

<h3>Description</h3>

<p>Convenience function for performing power analyses for hypothesis arising
in longitudinal measurement invariance models concerning a specific level of invariance.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">semPower.powerLI(
  type,
  comparison = NULL,
  nullEffect = NULL,
  autocorResiduals = TRUE,
  Phi = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparison</code></td>
<td>
<p>comparison model, either <code>'saturated'</code> or one of <code>'configural'</code>, <code>'metric'</code>, <code>'scalar'</code>, <code>'residual'</code>, <code>'covariances'</code>, <code>'means'</code>, or a vector of restrictions in <code>lavaan</code> format (with <code>'none'</code> for no restrictions). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullEffect</code></td>
<td>
<p>defines the hypothesis (i.e., level of invariance) of interest. Accepts the same arguments as <code>comparison</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>the factor correlation matrix. Can be <code>NULL</code> for uncorrelated factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code>semPower.aPriori()</code>, <code>semPower.postHoc()</code>, and <code>semPower.compromise()</code>, and parameters specifying the factor model. See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in the context of longitudinal measurement invariance, where a single attribute is measured repeatedly. The typical - but not in all parts necessary -
sequence concerning the measurement part is (a) configural, (b) metric, (c) scalar, (d) residual invariance,
and concerning the structural part  (e) latent covariances, (f) latent means, where each level of invariance is
compared against the previous level (e.g., scalar vs. metric). Power analysis provides
the power (or the required N) to reject a particular level of invariance.
</p>
<p>For hypotheses regarding multiple group invariance, see <code>semPower.powerMI()</code>. For hypotheses regarding autoregressive models, see <code>semPower.powerAutoreg()</code>. For hypotheses in an ARMA model, see <code>semPower.powerARMA()</code>.
</p>
<p>There are two ways to specify the models defined in the <code>comparison</code> and the <code>nullEffect</code> arguments. Either, one may
specify a specific level of invariance that includes all previous levels:
</p>

<ul>
<li> <p><code>'configural'</code>: no invariance constraints. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>'metric'</code>: all loadings are restricted to equality over measurement occasions. Note that reference scaling is used, so the first indicator should be invariant.
</p>
</li>
<li> <p><code>'scalar'</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>'residual'</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>'covariances'</code>: all loadings, (indicator-)intercepts, (indicator-)residuals, and latent covariances are restricted to equality.
</p>
</li>
<li> <p><code>'means'</code>: all loadings, (indicator-)intercepts, (indicator-)residuals, latent covariances, and latent means are restricted to equality.
</p>
</li>
</ul>
<p>For example, setting <code>comparison = 'metric'</code> and <code>nullEffect = 'scalar'</code> determines power
to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the
metric invariance model (restricting only the loadings) are defensible.
</p>
<p>For greater flexibility, the models can also be defined using <code>lavaan</code> style restrictions as a vector, namely
<code>'none'</code> (no restrictions), <code>'loadings'</code> (loadings), <code>'intercepts'</code> (intercepts), <code>'residuals'</code> (residuals), <code>'lv.covariances'</code> (latent covariances), <code>'means'</code> (latent means).
For instance:
</p>

<ul>
<li> <p><code>'none'</code>: no invariance constraints and thus representing a configural invariance model. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>c('loadings')</code>: all loadings are restricted to equality. Note that reference scaling is used, so the first indicator should be invariant.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts')</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'residuals')</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'residuals')</code>: all loadings and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'means')</code>: all loadings, (indicator-)intercepts, and latent factor means are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'residuals', 'lv.covariances')</code>: all loadings, (indicator-)residuals, and latent factor covariances are restricted to equality.
</p>
</li>
</ul>
<p>For example, setting <code>comparison = c('loadings')</code> and <code style="white-space: pre;">⁠nullEffect = 'c('loadings', 'intercepts')'⁠</code>
determines power to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the  metric invariance model (restricting only the loadings) are defensible.
Note that variance scaling is used, so invariance of variances (<code>'lv.variances'</code>) is always met. Latent means are identified using single occasion identification.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li>
<li> <p><code>Theta</code>: Variance-covariance matrix of the indicator residuals, which should be a diagonal matrix. Required when residual non-invariance is to be detected. When <code>NULL</code>, Theta is a diagonal matrix with elements such that all variances are 1.
</p>
</li>
<li> <p><code>tau</code>: Defines the indicator intercepts, required whenever a model involves hypotheses about means (e.g., scalar invariance). If <code>NULL</code> and <code>Alpha</code> is set, all intercepts are assumed to equal zero.
</p>
</li>
<li> <p><code>Alpha</code>: Defines the latent means, required whenever a model involves hypotheses about latent means (e.g., latent mean invariance). If <code>NULL</code> and <code>tau</code> is set, all latent means are assumed to equal zero. Because variance scaling is used so that all factor variances are 1, latent mean differences can be interpreted akin to Cohen's d as standardized mean differences.
</p>
</li>
</ul>
<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> always need to be defined,
and <code>Theta</code>, <code>tau</code> and <code>Alpha</code> need to be defined for particular levels of invariance.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li>
<p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li>
</ul>
<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li>
</ul>
<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>semPower.genSigma()</code> <code>semPower.aPriori()</code> <code>semPower.postHoc()</code> <code>semPower.compromise()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 


# obtain the required N to reject the hypothesis of metric invariance
# in comparison to the configural invariance model
# with a power of 80% on alpha = 5%
# for amodel involving a two factors (= two measurements) which
# is measured by 5 indicators
# loading by .5 each at the first measurement occasion
# loading by .6 each in the second measurement occasion,
# and assuming autocorrelated residuals
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)

# show summary
summary(powerLI)

# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerLI$modelH1, sample.cov = powerLI$Sigma,
            sample.nobs = 1000, sample.cov.rescale = FALSE)
lavaan::sem(powerLI$modelH0, sample.cov = powerLI$Sigma,
            sample.nobs = 1000, sample.cov.rescale = FALSE)



# same as above, but determine power with N = 500 on alpha = .05
powerLI &lt;- semPower.powerLI(
  type = 'post-hoc', alpha = .05, N = 500, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but determine the critical chi-square with N = 500 in each
# group so that alpha = beta
powerLI &lt;- semPower.powerLI(
  type = 'compromise', abratio = 1, N = 500, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but compare to the saturated model
# (rather than to the configural invariance model)
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'saturated',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but provide individual factor loadings by group using a
# reduced loading matrix to define a  single factor model with three indicators
# loading by .4, .6, .5 at the first measurement occasion and
# loading by .5, .6, .7 at the second measurement occasion 
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'configural',
  nullEffect = 'metric',
  loadings = list(
    c(.4, .6, .5),
    c(.5, .6, .7)
  ),
  autocorResiduals = TRUE
)

# obtain the required N to reject the hypothesis of scalar invariance
# in comparison to the metric invariance model
# with a power of 80% on alpha = 5%
# for a two factor model, where both factors are
# measured by 3 indicators each and all loadings equal .5 (at both measurements),
# all intercepts are 0.0 at the first measurement occasion, but
# all intercepts are 0.2 at the second measurement occasion and
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'metric',
  nullEffect = 'scalar',
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = c(0, 0, 0, 0, 0, 
          .2, .2, .2, .2, .2),
  autocorResiduals = TRUE
)

# same as above, but use lavaan strings 
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = c('loadings'),
  nullEffect = c('loadings', 'intercepts'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = c(0, 0, 0, 0, 0, 
          .2, .2, .2, .2, .2),
  autocorResiduals = TRUE
)


# obtain the required N to reject the hypothesis of equal latent means
# in comparison to the scalar invariance model;
# all intercepts are zero in both groups,
# at the first measurement occasion, the latent mean is 0.0,
# at the first measurement occasion, the latent mean is 0.5
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = c('loadings', 'intercepts'),
  nullEffect = c('loadings', 'intercepts', 'means'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = rep(0, 10),
  Alpha = c(0, .5),
  autocorResiduals = TRUE
)

# obtain the required N to reject the hypothesis of equal covariances
# in comparison to the residual invariance model;
 Phi &lt;- matrix(c(
  c(1, .3, .1),
   c(.3, 1, .2),
   c(.1, .2, 1)
 ), nrow=3, byrow = TRUE)
 powerLI &lt;- semPower.powerLI(
   type = 'a-priori', alpha = .05, power = .80,
   comparison = 'residual',
   nullEffect = 'covariances',
   nIndicator = c(3, 3, 3),
   loadM = c(.5, .5, .5),
   Phi = Phi,
   tau = rep(0, 9)
)   
 
# request a simulated post-hoc power analysis with 250 replications
# to reject the hypothesis of equal latent means.
set.seed(300121)
powerLI &lt;- semPower.powerLI(
  type = 'post-hoc', alpha = .05, N = 500, 
  comparison = c('loadings', 'intercepts'),
  nullEffect = c('loadings', 'intercepts', 'means'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = rep(0, 10),
  Alpha = c(0, .5),
  autocorResiduals = TRUE,
  simulatedPower = TRUE,
  simOptions = list(nReplications = 250)  
)

## End(Not run)
</code></pre>


</div>