<div class="container">

<table style="width: 100%;"><tr>
<td>check_design_rule</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal helper to test the design rules for any string and setting of <code>to_any_case()</code>
</h2>

<h3>Description</h3>

<p>Internal helper to test the design rules for any string and setting of <code>to_any_case()</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">check_design_rule(string, sep_in = NULL, transliterations = NULL,
  sep_out = NULL, prefix = "", postfix = "", unique_sep = NULL,
  empty_fill = NULL, parsing_option = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep_in</code></td>
<td>
<p>String that will be wrapped internally into <code>stringr::regex()</code>. 
All matches will be treated as additional splitting parameters besides the default ones 
(<code>"_"</code> and <code>" "</code>), when parsing the input string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like "Latin-ASCII", which is often useful) or names of lookup tables (currently
only "german" is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep_out</code></td>
<td>
<p>String that will be used as separator. The defaults are <code>"_"</code> 
and <code>""</code>, regarding the specified <code>case</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>prefix (string).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postfix</code></td>
<td>
<p>postfix (string).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique_sep</code></td>
<td>
<p>A string. If it is supplied, then duplicated names will get a suffix integer
in the order of their appearance. The suffix is separated by the supplied string to this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empty_fill</code></td>
<td>
<p>A string. If it is supplied, then each entry that matches "" will be replaced
by the supplied string to this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parsing_option</code></td>
<td>
<p>An integer that will determine the parsing_option.
</p>

<ul>
<li>
<p>1: <code>RRRStudio -&gt; RRR_Studio</code>
</p>
</li>
<li>
<p>2: <code>RRRStudio -&gt; RRRS_tudio</code>
</p>
</li>
<li>
<p>3: parses at the beginning like option 1 and the rest like option 2.
</p>
</li>
<li>
<p>4: parses at the beginning like option 2 and the rest like option 1.
</p>
</li>
<li>
<p>5: parses like option 1 but suppresses "_" around non special characters.
In this way case conversion won't apply after these characters. See examples.
</p>
</li>
<li>
<p>6: parses like option 1, but digits directly behind/in front non-digits, will stay as is.
</p>
</li>
<li>
<p>any other integer &lt;= 0: no parsing"
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A character vector separated by underscores, containing the parsed string.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>


</div>