<div class="container">

<table style="width: 100%;"><tr>
<td>neighbours</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Count Number of Neighbours on a Rectangular Grid.</h2>

<h3>Description</h3>

<p>This is the base function for the simulation
of deterministic and stochastic cellular automata on rectangular
grids.</p>


<h3>Usage</h3>

<pre><code class="language-R">  neighbours(x, state = NULL, wdist = NULL, tol = 1e-4, bounds = 0)
  neighbors(x, state = NULL, wdist = NULL, tol = 1e-4, bounds = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix. The cellular grid, in which each cell can have a specific
state value, e.g. zero (dead cell) or one (living cell) or the age
of an individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>A value, whose existence is checked within the
neighbourhood of each cell.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wdist</code></td>
<td>
<p>The neighbourhood weight matrix. It has to be a square matrix
with an odd number of rows and columns).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance value for the comparision of <code>state</code> with the
state of each cell. If <code>tol</code> is a large value, then more than
one state can be checked simultaneously.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>A vector with either one or four values specifying
the type of boundaries, where 0 means open boundaries and 1 torus-like
boundaries. The values are specified in the order bottom, left, 
top, right.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The performance of the function depends on the size of the matrices and the
type of the boundaries, where open boundaries are faster than torus like
boundaries. Function <code>eightneighbours</code> is even faster.
</p>


<h3>Value</h3>

<p>A matrix with the same structure as <code>x</code> with the weighted
sum of the neigbours with values between <code>state - tol</code> and
<code>state + tol</code>.
</p>


<h3>See Also</h3>

<p><code>seedfill</code>, <code>eightneighbours</code>, <code>conway</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ==================================================================
## Demonstration of the neighborhood function alone
## ==================================================================

## weight matrix for neighbourhood determination
wdist &lt;- matrix(c(0.5,0.5,0.5,0.5,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,0.5,0.5,0.5,0.5), nrow=5)

## state matrix                  
n &lt;- 20; m &lt;- 20
x &lt;- matrix(rep(0, m * n), nrow = n)

## set state of some cells to 1
x[10, 10] &lt;- 1
x[1, 5]   &lt;- 1
x[n, 15]  &lt;- 1
x[5, 2]   &lt;- 1
x[15, m]  &lt;- 1
#x[n, 1]   &lt;- 1 # corner

opar &lt;- par(mfrow = c(2, 2))
## start population
image(x)
## open boundaries
image(matrix(neighbours(x, wdist = wdist, bounds = 0), nrow = n))
## torus (donut like)
image(matrix(neighbours(x, wdist = wdist, bounds = 1), nrow = n))
## cylinder (left and right boundaries connected)
image(matrix(neighbours(x, wdist = wdist, bounds = c(0, 1, 0, 1)), nrow = n))
par(opar) # reset graphics area                  
                  
## ==================================================================
## The following example demonstrates a "plain implementation" of a
## stochastic cellular automaton i.e. without the simecol structure.
##
## A simecol implementation of this can be found in
## the example directory of this package (file: stoch_ca.R).
## ==================================================================                  
mycolors &lt;- function(n) {
  col &lt;- c("wheat", "darkgreen")
  if (n&gt;2) col &lt;- c(col, heat.colors(n - 2))
  col
}

pj &lt;- 0.99  # survival probability of juveniles
pa &lt;- 0.99  # survival probability of adults
ps &lt;- 0.1   # survival probability of senescent
ci &lt;- 1.0   # "seeding constant"
adult &lt;- 5  # age of adolescence
old   &lt;- 10 # age of senescence

## Define a start population
n &lt;- 80
m &lt;- 80
x &lt;- rep(0, m*n)

## stochastic seed
## x[round(runif(20,1,m*n))] &lt;- adult
dim(x)&lt;- c(n, m)

## rectangangular seed in the middle
x[38:42, 38:42] &lt;- 5

## plot the start population
image(x, col = mycolors(2))

## -----------------------------------------------------------------------------
## Simulation loop (hint: increase loop count)
## -----------------------------------------------------------------------------
for (i in 1:10){

  ## rule 1: reproduction
  ## 1.1 which cells are adult? (only adults can generate)
  ad &lt;- ifelse(x &gt;= adult &amp; x &lt; old, x, 0)

  ## 1.2 how much (weighted) adult neighbours has each cell?
  nb &lt;- neighbours(ad, wdist = wdist)

  ## 1.3 a proportion of the seeds develops juveniles
  ## simplified version, you can also use probabilities
  genprob &lt;- nb * runif(nb) * ci
  xgen  &lt;- ifelse(x == 0 &amp; genprob &gt;= 1, 1, 0)

  ## rule 2: growth and survival of juveniles
  xsurvj &lt;- ifelse(x &gt;= 1 &amp; x &lt; adult &amp; runif(x) &lt;= pj, x+1, 0)
  ## rule 2: growth and survival of adults
  xsurva &lt;- ifelse(x &gt;= adult &amp; x &lt; old &amp; runif(x) &lt;= pa, x+1, 0)
  ## rule 2: growth and survival of senescent
  xsurvs &lt;- ifelse(x &gt;= old &amp; runif(x) &lt;= ps, x+1, 0)

  ## make resulting grid of complete population
  x     &lt;- xgen + xsurvj + xsurva + xsurvs

  ## plot resulting grid
  image(x, col = mycolors(max(x) + 1), add = TRUE)
  if (max(x) == 0) stop("extinction", call. = FALSE)
}

## modifications:  pa&lt;-pj&lt;-0.9

## additional statistics of population structure
## with table, hist, mean, sd, ...
</code></pre>


</div>