<div class="container">

<table style="width: 100%;"><tr>
<td>averageSP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Average a group of snow profiles</h2>

<h3>Description</h3>

<p>The functions dbaSP and averageSP implement Dynamic Time Warping Barycenter Averaging of snow profiles.
The convenient wrapper averageSP takes care of choosing several appropriate initial conditions and picking the optimal end result (by minimizing the mean squared error
between the average profile and the profile set). To pay appropriate attention to (thin) weak layers, weak layers need to be labeled in the profiles.
You can either do that manually before calling this routine to suit your personal needs, or you can provide specific properties (in <code>classifyPWLs</code>)
so that weak layers be labeled according to these properties by sarp.snowprofile::labelPWL.
For more details, refer to the reference paper.
</p>


<h3>Usage</h3>

<pre><code class="language-R">averageSP(
  SPx,
  n = 5,
  sm = summary(SPx),
  progressbar = requireNamespace("progress", quietly = TRUE),
  progressbar_pretext = NULL,
  classifyPWLs = list(pwl_gtype = c("SH", "DH")),
  classifyCRs = list(pwl_gtype = c("MFcr", "IF", "IFsc", "IFrc")),
  proportionPWL = 0.5,
  breakAtSim = 0.9,
  breakAfter = 2,
  verbose = FALSE,
  tz = "auto",
  n_cores = NULL,
  ...
)

dbaSP(
  SPx,
  Avg,
  sm = summary(SPx),
  resamplingRate = 0.5,
  proportionPWL = 0.3,
  maxiter = 10,
  breakAtSim = 0.99,
  breakAfter = 1,
  plotChanges = FALSE,
  verbose = TRUE,
  tz = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SPx</code></td>
<td>
<p>SPx a sarp.snowprofile::snowprofileSet object. Note that the profile layers need to contain a column
called <code style="white-space: pre;">⁠$layerOfInterest⁠</code> which classifies weak layers. While averageSP will label weak layers automatically if not done by the user beforehand, dbaSP won't do that but fail instead!;
consider thinking about how you want to label weak layers, see Description, <code>classifyPWLs</code> below, and the references.
Also note, that if you wish to average the <em>rescaled</em> profile set, do so manually before calling this function (see examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of initial conditions that will be used to run dbaSP; see also chooseICavg.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sm</code></td>
<td>
<p>a summary of <code>SPx</code> metadata</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressbar</code></td>
<td>
<p>should a progressbar be displayed (the larger n, the more meaningful the progressbar)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressbar_pretext</code></td>
<td>
<p>a character string to be prepended to the progressbar (mainly used by higher level cluster function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifyPWLs</code></td>
<td>
<p>an argument list for a function call to sarp.snowprofile::findPWL which returns relevant PWLs for identifying initial conditions. <strong>Importantly</strong>, these arguments will also be used
to label weak layers in the profiles, if these labels do not yet exist in the layers objects as column <code style="white-space: pre;">⁠$layerOfInterest⁠</code>.
Check out the documentation of <code>findPWL</code> to familiarize yourself with your manifold options!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifyCRs</code></td>
<td>
<p>an argument list for a function call to sarp.snowprofile::findPWL which returns relevant crusts for identifying initial conditions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proportionPWL</code></td>
<td>
<p>decimal number that specifies the proportion required to average an ensemble of grain types as weak layer type.
A value of 0.3, for example, means that layers will get averaged to a PWL type if 30% of the layers are of PWL type.
Meaningful range is between <code style="white-space: pre;">⁠[0.1, 0.5]⁠</code>. Values larger than 0.5 get set to 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breakAtSim</code></td>
<td>
<p>stop iterations when simSP between the last average profiles is beyond that value. Can range between <code style="white-space: pre;">⁠[0, 1]⁠</code>. Default values differ between dbaSP and averageSP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breakAfter</code></td>
<td>
<p>integer specifying how many values of simSP need to be above <code>breakAtSim</code> to stop iterating. Default values differ between dbaSP and averageSP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print similarities between old and new average in between iterations?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tz</code></td>
<td>
<p>timezone of profiles; necessary for assigning the correct timezone to the average profile's ddate/bdate. Either <code>'auto'</code> or a timezone known to <code style="white-space: pre;">⁠[as.POSIXct]⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>number of nodes to create for a cluster using the  parallel package to speed up calculations (default = NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>alignment configurations which are passed on to dbaSP and then further to dtwSP. Note, that you can't provide <code>rescale2refHS</code>, which is always set to FALSE. If you wish to rescale
the profiles, read the description of the <code>SPx</code> parameter and the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Avg</code></td>
<td>
<p>the initial average snow profile: either a sarp.snowprofile::snowprofile object or an index to an initial average profile in SPx</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resamplingRate</code></td>
<td>
<p>Resampling rate for a regular depth grid among the profiles</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotChanges</code></td>
<td>
<p>specify whether and how you want to plot the dba process: either <code>FALSE</code>, 'TRUE<code>==</code>'iterations'<code style="white-space: pre;">⁠, or ⁠</code>'averages+last''</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Technical note: Since the layer characteristics of the average profile represent the median characteristics of the individual profiles, it can happen that ddates of the
averaged layers are not in a monotonic order. That is, of course non-physical, but we specifically decided not to override these values to highlight these slight inconsistencies
to users, so that they can decide how to deal with them. As a consequence, the function sarp.snowprofile::deriveDatetag does not work for these average profiles with ddate
inconsistencies, but throws an error. The suggested workaround for this issue is to apply that function to all individual profiles <em>before</em> computing the average profile. This
ensures that bdates or datetags are also included in the average profile.
</p>
<p>For developers: Including new variables into the averaging/dba routines can be done easily by following commit #9f9e6f9
</p>


<h3>Value</h3>

<p>A list of class <code>avgSP</code> that contains the fields
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$avg⁠</code>: the resulting average profile
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$set⁠</code>: the corresponding resampled profiles of the group
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$call⁠</code>: (only with <code>averageSP</code>) the function call
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$prelabeledPWLs⁠</code>: (only with <code>averageSP</code>) boolean scalar whether PWLs (or any other layers of interest) were prelabeled before this routine (<code>TRUE</code>) or
labeled by this routine with the defaults specified in <code>classifyPWLs</code> (<code>FALSE</code>)
</p>
</li>
</ul>
<p>The profile layers of the average profile refer to the median properties of the predominant layers. For example, if you labeled all SH/DH layers as your 'layersOfInterest',
and you find a SH or DH layer in the average profile, then it means that the predominant grain type is SH/DH (i.e., more profiles than specified in <code>proportionPWL</code> have that layer)
and layer properties like hardness, p_unstable, etc refer to the median properties of these SH/DH layers. If you find a RG layer in your average profile, it means that most
profiles have that RG layer and the layer properties refer to the median properties of all these RG layers. There are two exceptions to this rule, one for <code>height</code>/<code>depth</code>, and one
for layer properties with the ending <code style="white-space: pre;">⁠_all⁠</code>, such as <code>ppu_all</code>:
</p>

<ul>
<li> <p><code>height</code> and <code>depth</code> provide the vertical grid of the average profile, and for algorithmic reasons, this grid is not always equal to the actual median height or depth
of the predominant layers. To account for that, two layer columns exist called <code>medianPredominantHeight</code> and <code>medianPredominantDepth</code>.
</p>
</li>
<li>
<p> Properties ending with <code style="white-space: pre;">⁠_all⁠</code>: For example, while <code>ppu</code> refers to the proportion of profiles, whose <em>predominant</em> layers are unstable (i.e., <code>p_unstable</code> &gt;= 0.77),
<code>ppu_all</code> refers to the the proportion of profiles, whose layers are unstable while taking into account <em>all</em> individual layers matched to this average layer
(i.e., despite grain type, etc).
</p>
</li>
<li>
<p> Other layer properties specific to the average profile: <code>distribution</code> ranges between <code style="white-space: pre;">⁠[0, 1]⁠</code> and specifies the proportion of profiles that contain the predominant layer described in the other properties.
</p>
</li>
</ul>
<h3>Functions</h3>


<ul>
<li> <p><code>averageSP()</code>: convenient wrapper function
</p>
</li>
<li> <p><code>dbaSP()</code>: DTW barycenter averaging of snow profiles (low level worker function)
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>fherla
</p>


<h3>References</h3>

<p>Herla, F., Haegeli, P., and Mair, P. (2022). A data exploration tool for averaging and accessing large data sets of snow stratigraphy profiles useful for avalanche forecasting,
The Cryosphere, 16(8), 3149–3162, https://doi.org/10.5194/tc-16-3149-2022
</p>


<h3>See Also</h3>

<p>averageSPalongSeason
</p>


<h3>Examples</h3>

<pre><code class="language-R">## EXAMPLES OF averageSP
this_example_runs_about_10s &lt;- TRUE
if (!this_example_runs_about_10s) {  # exclude from cran checks

## compute the average profile of the demo object 'SPgroup'
## * by labeling SH/DH layers as weak layers,
##   - choosing 3 initial conditions with an above average number of weak layers
##   - in as many depth ranges as possible
## * and neglecting crusts for initial conditions

  avgList &lt;- averageSP(SPgroup, n = 3,
                       classifyPWLs = list(pwl_gtype = c("SH", "DH")),
                       classifyCRs = NULL)

  opar &lt;- par(mfrow = c(1, 2))
  plot(avgList$avg, ymax = max(summary(avgList$set)$hs))
  plot(avgList$set, SortMethod = "unsorted", xticklabels = "originalIndices")
  par(opar)


## compute the average profile of the demo object 'SPgroup'
## * by labeling SH/DH/FC/FCxr layers with an RTA threshold of 0.65 as weak layers,
## * otherwise as above

  SPx &lt;- computeRTA(SPgroup)
  avgList &lt;- averageSP(SPx, n = 3,
                       classifyPWLs = list(pwl_gtype = c("SH", "DH", "FC", "FCxr"),
                                           threshold_RTA = 0.65),
                       classifyCRs = NULL)

  opar &lt;- par(mfrow = c(1, 2))
  plot(avgList$avg, ymax = max(summary(avgList$set)$hs))
  plot(avgList$set, SortMethod = "unsorted", xticklabels = "originalIndices")
  par(opar)

## compute the average profile of the other demo object 'SPgroup2', which
## contains more stability indices, such as SK38 or p_unstable
## * by labeling SH/DH/FC/FCxr layers that either
##   - have an SK38 below 0.95, *or*
##   - have a p_unstable above 0.77

  SPx &lt;- snowprofileSet(SPgroup2)
  avgList &lt;- averageSP(SPx,
                       classifyPWLs = list(pwl_gtype = c("SH", "DH", "FC", "FCxr"),
                                           threshold_SK38 = 0.95, threshold_PU = 0.77))

  opar &lt;- par(mfrow = c(1, 2))
  plot(avgList$avg, ymax = max(summary(avgList$set)$hs))
  plot(avgList$set, SortMethod = "unsorted", xticklabels = "originalIndices")
  par(opar)

}



## EXAMPLES OF dbaSP
## either rescale profiles beforehand...
if (FALSE) {  # don't run in package check to save time
  SPx &lt;- reScaleSampleSPx(SPgroup)$set          # rescale profiles
  SPx &lt;- snowprofileSet(lapply(SPx, labelPWL))  # label PWLs
  DBA &lt;- dbaSP(SPx, 5, plotChanges = TRUE)      # average profiles
}

## or use unscaled snow heights:
if (FALSE) {  # don't run in package check to save time
  SPx &lt;- snowprofileSet(lapply(SPgroup, labelPWL))  # label PWLs
  DBA &lt;- dbaSP(SPx, 5, plotChanges = TRUE)          # average profiles
}
</code></pre>


</div>