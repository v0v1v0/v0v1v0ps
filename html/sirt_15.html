<div class="container">

<table style="width: 100%;"><tr>
<td>brm-Methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Functions for the Beta Item Response Model
</h2>

<h3>Description</h3>

<p>Functions for simulating and estimating the Beta item response model
(Noel &amp; Dauvier, 2007). <code>brm.sim</code> can be used for
simulating the model, <code>brm.irf</code> computes the item response
function. The Beta item response model is estimated as a discrete
version to enable estimation in <em>standard</em> IRT software like
<span class="pkg">mirt</span> or <span class="pkg">TAM</span> packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># simulating the beta item response model
brm.sim(theta, delta, tau, K=NULL)

# computing the item response function of the beta item response model
brm.irf( Theta, delta, tau, ncat, thdim=1, eps=1E-10 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>

<p>Ability vector of <code class="reqn">\theta</code> values
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>Vector of item difficulty parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>Vector item dispersion parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>Number of discretized categories. The default is <code>NULL</code> which
means that the simulated item responses are real number values
between 0 and 1. If an integer <code>K</code> chosen, then values
are discretized such that values of 0, 1, ..., <code class="reqn">K</code>-1 arise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>Matrix of the ability vector <code class="reqn">\bold{\theta}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncat</code></td>
<td>
<p>Number of categories</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thdim</code></td>
<td>
<p>Theta dimension in the matrix <code>Theta</code> on
which the item loads.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Nuisance parameter which stabilize probabilities.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The discrete version of the beta item response model is defined as follows.
Assume that for item <code class="reqn">i</code> there are <code class="reqn">K</code> categories resulting in
values <code class="reqn">k=0,1,\dots,K-1</code>. Each value <code class="reqn">k</code> is associated with a
corresponding the transformed value in <code class="reqn">[0,1]</code>, namely
<code class="reqn"> q (k)=1/(2 \cdot K), 1/(2 \cdot K) + 1/K, \ldots,  1 - 1/(2 \cdot K) </code>.
The item response model is defined as
</p>
<p style="text-align: center;"><code class="reqn"> P( X_{pi}=x_{pi} | \theta_p)  \propto
      q( x_{pi} )^{ m_{pi} - 1 } [ 1- q( x_{pi} ) ]^{ n_{pi} - 1 } </code>
</p>

<p>This density is a discrete version of a Beta distribution with
shape parameters <code class="reqn">m_{pi}</code> and <code class="reqn">n_{pi}</code>. These parameters are
defined as
</p>
<p style="text-align: center;"><code class="reqn"> m_{pi}=\mathrm{exp} \left[ ( \theta_p - \delta_i + \tau_i ) / 2 \right]
    \qquad \mbox{and} \qquad
    n_{pi}=\mathrm{exp} \left[ ( - \theta_p + \delta_i + \tau_i ) / 2 \right]
                </code>
</p>

<p>The item response function can also be formulated as
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{log} \left[ P( X_{pi}=x_{pi} | \theta_p) \right]  \propto
      ( m_{pi} - 1 ) \cdot \mathrm{log} [ q( x_{pi} ) ] +
      ( n_{pi} - 1 )  \cdot \mathrm{log} [ 1- q( x_{pi} ) ]
                      </code>
</p>

<p>The item parameters can be reparameterized as
<code class="reqn"> a_{i}=\mathrm{exp} \left[ ( - \delta_i + \tau_i ) / 2 \right]</code> and
<code class="reqn"> b_{i}=\mathrm{exp} \left[ ( \delta_i + \tau_i ) / 2 \right]</code>.
</p>
<p>Then, the original item parameters can be retrieved by
<code class="reqn">\tau_i=\mathrm{log} ( a_i b_i)</code> and
<code class="reqn">\delta_i=\mathrm{log} ( b_i / a_i)</code>.
Using <code class="reqn"> \gamma _p=\mathrm{exp} ( \theta_p / 2) </code>, we obtain
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{log} \left[ P( X_{pi}=x_{pi} | \theta_p) \right]  \propto
       a_{i} \gamma_p  \cdot \mathrm{log} [ q( x_{pi} ) ] +
       b_i / \gamma_p   \cdot \mathrm{log} [ 1- q( x_{pi} ) ] -
      \left[ \mathrm{log} q( x_{pi} ) + \mathrm{log} [ 1- q( x_{pi} ) ] \right]
                      </code>
</p>

<p>This formulation enables the specification of the Beta item response
model as a structured latent class model
(see <code>TAM::tam.mml.3pl</code>;
Example 1).
</p>
<p>See Smithson and Verkuilen (2006) for motivations for treating
continuous indicators not as normally distributed variables.
</p>


<h3>Value</h3>

<p>A simulated dataset of item responses if <code>brm.sim</code> is applied.
</p>
<p>A matrix of item response probabilities if <code>brm.irf</code> is applied.
</p>


<h3>References</h3>

<p>Gruen, B., Kosmidis, I., &amp; Zeileis, A. (2012). Extended Beta regression
in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: Shaken, stirred, mixed, and partitioned.
<em>Journal of Statistical Software, 48</em>(11), 1-25.
<a href="https://doi.org/10.18637/jss.v048.i11">doi:10.18637/jss.v048.i11</a>
</p>
<p>Noel, Y., &amp; Dauvier, B. (2007). A beta item response model for continuous
bounded responses. <em>Applied Psychological Measurement,
31</em>(1), 47-73. <a href="https://doi.org/10.1177/0146621605287691">doi:10.1177/0146621605287691</a>
</p>
<p>Smithson, M., &amp; Verkuilen, J. (2006). A better lemon squeezer?
Maximum-likelihood regression with beta-distributed dependent variables.
<em>Psychological Methods, 11</em>(1), 54-71.
doi: 10.1037/1082-989X.11.1.54
</p>


<h3>See Also</h3>

<p>See also the <span class="pkg">betareg</span> package for fitting Beta regression
regression models in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> (Gruen, Kosmidis &amp; Zeileis, 2012).
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Simulated data beta response model
#############################################################################

#*** (1) Simulation of the beta response model
# Table 3 (p. 65) of Noel and Dauvier (2007)
delta &lt;- c( -.942, -.649, -.603, -.398, -.379, .523, .649, .781, .907 )
tau &lt;- c( .382, .166, 1.799, .615, 2.092, 1.988, 1.899, 1.439, 1.057 )
K &lt;- 5        # number of categories for discretization
N &lt;- 500        # number of persons
I &lt;- length(delta) # number of items

set.seed(865)
theta &lt;- stats::rnorm( N )
dat &lt;- sirt::brm.sim( theta=theta, delta=delta, tau=tau, K=K)
psych::describe(dat)

#*** (2) some preliminaries for estimation of the model in mirt
#*** define a mirt function
library(mirt)
Theta &lt;- matrix( seq( -4, 4, len=21), ncol=1 )

# compute item response function
ii &lt;- 1     # item ii=1
b1 &lt;- sirt::brm.irf( Theta=Theta, delta=delta[ii], tau=tau[ii],  ncat=K )
# plot item response functions
graphics::matplot( Theta[,1], b1, type="l" )

#*** defining the beta item response function for estimation in mirt
par &lt;- c( 0, 1,  1)
names(par) &lt;- c( "delta", "tau","thdim")
est &lt;- c( TRUE, TRUE, FALSE )
names(est) &lt;- names(par)
brm.icc &lt;- function( par, Theta, ncat ){
     delta &lt;- par[1]
     tau &lt;- par[2]
     thdim &lt;- par[3]
     probs &lt;- sirt::brm.irf( Theta=Theta, delta=delta, tau=tau,  ncat=ncat,
            thdim=thdim)
     return(probs)
            }
name &lt;- "brm"
# create item response function
brm.itemfct &lt;- mirt::createItem(name, par=par, est=est, P=brm.icc)
#*** define model in mirt
mirtmodel &lt;- mirt::mirt.model("
           F1=1-9
            " )
itemtype &lt;- rep("brm", I )
customItems &lt;- list("brm"=brm.itemfct)

# define parameters to be estimated
mod1.pars &lt;- mirt::mirt(dat, mirtmodel, itemtype=itemtype,
                   customItems=customItems, pars="values")

## Not run: 
#*** (3) estimate beta item response model in mirt
mod1 &lt;- mirt::mirt(dat,mirtmodel, itemtype=itemtype, customItems=customItems,
               pars=mod1.pars, verbose=TRUE  )
# model summaries
print(mod1)
summary(mod1)
coef(mod1)
# estimated coefficients and comparison with simulated data
cbind( sirt::mirt.wrapper.coef( mod1 )$coef, delta, tau )
mirt.wrapper.itemplot(mod1,ask=TRUE)

#---------------------------
# estimate beta item response model in TAM
library(TAM)

# define the skill space: standard normal distribution
TP &lt;- 21                   # number of theta points
theta.k &lt;- diag(TP)
theta.vec &lt;-  seq( -6,6, len=TP)
d1 &lt;- stats::dnorm(theta.vec)
d1 &lt;- d1 / sum(d1)
delta.designmatrix &lt;- matrix( log(d1), ncol=1 )
delta.fixed &lt;- cbind( 1, 1, 1 )

# define design matrix E
E &lt;- array(0, dim=c(I,K,TP,2*I + 1) )
dimnames(E)[[1]] &lt;- items &lt;- colnames(dat)
dimnames(E)[[4]] &lt;- c( paste0( rep( items, each=2 ),
        rep( c("_a","_b" ), I) ), "one" )
for (ii in 1:I){
    for (kk in 1:K){
      for (tt in 1:TP){
        qk &lt;- (2*(kk-1)+1)/(2*K)
        gammap &lt;- exp( theta.vec[tt] / 2 )
        E[ii, kk, tt, 2*(ii-1) + 1 ] &lt;- gammap * log( qk )
        E[ii, kk, tt, 2*(ii-1) + 2 ] &lt;- 1 / gammap * log( 1 - qk )
        E[ii, kk, tt, 2*I+1 ] &lt;- - log(qk) - log( 1 - qk )
                    }
            }
        }
gammaslope.fixed &lt;- cbind( 2*I+1, 1 )
gammaslope &lt;- exp( rep(0,2*I+1) )

# estimate model in TAM
mod2 &lt;- TAM::tam.mml.3pl(resp=dat, E=E,control=list(maxiter=100),
              skillspace="discrete", delta.designmatrix=delta.designmatrix,
              delta.fixed=delta.fixed, theta.k=theta.k, gammaslope=gammaslope,
              gammaslope.fixed=gammaslope.fixed, notA=TRUE )
summary(mod2)

# extract original tau and delta parameters
m1 &lt;- matrix( mod2$gammaslope[1:(2*I) ], ncol=2, byrow=TRUE )
m1 &lt;- as.data.frame(m1)
colnames(m1) &lt;- c("a","b")
m1$delta.TAM &lt;- log( m1$b / m1$a)
m1$tau.TAM &lt;- log( m1$a * m1$b )

# compare estimated parameter
m2 &lt;- cbind( sirt::mirt.wrapper.coef( mod1 )$coef, delta, tau )[,-1]
colnames(m2) &lt;- c(  "delta.mirt", "tau.mirt", "thdim","delta.true","tau.true"   )
m2 &lt;- cbind(m1,m2)
round( m2, 3 )

## End(Not run)
</code></pre>


</div>