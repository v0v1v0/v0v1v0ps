<div class="container">

<table style="width: 100%;"><tr>
<td>st_extract</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract cell values at point locations</h2>

<h3>Description</h3>

<p>Extract cell values at point locations
</p>


<h3>Usage</h3>

<pre><code class="language-R">st_extract(x, ...)

## S3 method for class 'stars'
st_extract(
  x,
  at,
  ...,
  bilinear = FALSE,
  time_column = attr(at, "time_column") %||% attr(at, "time_col"),
  interpolate_time = bilinear,
  FUN = mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>stars</code> or <code>stars_proxy</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed on to aggregate.stars when geometries are not exclusively POINT geometries</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code> with geometries, or two-column matrix with coordinate points in rows, indicating where to extract values of <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bilinear</code></td>
<td>
<p>logical; use bilinear interpolation rather than nearest neighbour?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_column</code></td>
<td>
<p>character or integer; name or index of a column with time or date values that will be matched to values of the first temporal dimension (matching classes <code>POSIXct</code>, <code>POSIXt</code>, <code>Date</code>, or <code>PCICt</code>), in <code>x</code>, after which this dimension is reduced. This is useful to extract data cube values along a trajectory; see https://github.com/r-spatial/stars/issues/352 .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate_time</code></td>
<td>
<p>logical; should time be interpolated? if FALSE, time instances are matched using the coinciding or the last preceding time in the data cube.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>function used to aggregate pixel values when geometries of <code>at</code> intersect with more than one pixel</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>points outside the raster are returned as <code>NA</code> values. For
large sets of points for which extraction is needed, passing a matrix as
to <code>at</code> may be much faster than passing an <code>sf</code> or <code>sfc</code> object.
</p>


<h3>Value</h3>

<p>if <code>at</code> is of class <code>matrix</code>, a matrix with extracted values is returned; 
otherwise: if <code>x</code> has more dimensions than only x and y (raster), an 
object of class <code>stars</code> with POINT geometries replacing x and y raster
dimensions, if this is not the case, an object of <code>sf</code> with extracted values.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tif = system.file("tif/L7_ETMs.tif", package = "stars")
r = read_stars(tif)
pnt = st_sample(st_as_sfc(st_bbox(r)), 10)
st_extract(r, pnt)
st_extract(r, pnt) %&gt;% st_as_sf()
st_extract(r[,,,1], pnt)
st_extract(r, st_coordinates(pnt)) # "at" is a matrix: return a matrix
</code></pre>


</div>