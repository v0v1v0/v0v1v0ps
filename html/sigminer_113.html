<div class="container">

<table style="width: 100%;"><tr>
<td>sigprofiler</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Signatures with SigProfiler</h2>

<h3>Description</h3>

<p>This function provides an interface to software SigProfiler.
More please see <a href="https://github.com/AlexandrovLab/SigProfilerExtractor">https://github.com/AlexandrovLab/SigProfilerExtractor</a>.
Typically, a reference genome is not required because the input is a matrix (my understanding).
<strong>If you are using refitting result by SigProfiler, please make sure you have input the matrix same order as examples at <a href="https://github.com/AlexandrovLab/SigProfilerMatrixGenerator/tree/master/SigProfilerMatrixGenerator/references/matrix/BRCA_example">https://github.com/AlexandrovLab/SigProfilerMatrixGenerator/tree/master/SigProfilerMatrixGenerator/references/matrix/BRCA_example</a></strong>. If not, use <code>sigprofiler_reorder()</code> firstly.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sigprofiler_extract(
  nmf_matrix,
  output,
  output_matrix_only = FALSE,
  range = 2:5,
  nrun = 10L,
  refit = FALSE,
  refit_plot = FALSE,
  is_exome = FALSE,
  init_method = c("random", "nndsvd_min", "nndsvd", "nndsvda", "nndsvdar"),
  cores = -1L,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  use_conda = FALSE,
  py_path = NULL,
  sigprofiler_version = "1.1.3"
)

sigprofiler_import(
  output,
  order_by_expo = FALSE,
  type = c("suggest", "refit", "all")
)

sigprofiler_reorder(
  nmf_matrix,
  type = c("SBS96", "SBS6", "SBS12", "SBS192", "SBS1536", "SBS3072", "DBS78", "DBS312",
    "DBS1248", "DBS4992")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>output directory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_matrix_only</code></td>
<td>
<p>if <code>TRUE</code>, only generate matrix file for SigProfiler
so user can call SigProfiler with the input by himself.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>signature number range, i.e. <code>2:5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrun</code></td>
<td>
<p>the number of iteration to be performed to extract each signature number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with nnls. Same
meaning as <code>optimize</code> option in sig_extract or sig_auto_extract.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit_plot</code></td>
<td>
<p>if <code>TRUE</code>, SigProfiler will make
denovo to COSMIC sigantures decompostion plots. However, this may fail due
to some matrix cannot be identified by SigProfiler plot program.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_exome</code></td>
<td>
<p>if <code>TRUE</code>, the exomes will be extracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_method</code></td>
<td>
<p>the initialization algorithm for W and H matrix of NMF.
Options are 'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'alexandrov-lab-custom'
and 'nndsvd_min'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cores used for computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genome_build</code></td>
<td>
<p>I think this option is useless when input is <code>matrix</code>, keep it
in case it is useful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_conda</code></td>
<td>
<p>if <code>TRUE</code>, create an independent conda environment to run SigProfiler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py_path</code></td>
<td>
<p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigprofiler_version</code></td>
<td>
<p>version of <code>SigProfilerExtractor</code>. If this
package is not installed, the specified package will be installed.
If this package is installed, this option is useless.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by_expo</code></td>
<td>
<p>if <code>TRUE</code>, order the import signatures by their exposures, e.g. the signature
contributed the most exposure in all samples will be named as <code>Sig1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>mutational signature type.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>sigprofiler_extract()</code>, returns nothing. See <code>output</code> directory.
</p>
<p>For <code>sigprofiler_import()</code>, a <code>list</code> containing <code>Signature</code> object.
</p>
<p>A NMF matrix for input of <code>sigprofiler_extract()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (FALSE) {
  load(system.file("extdata", "toy_copynumber_tally_W.RData",
    package = "sigminer", mustWork = TRUE
  ))

  reticulate::conda_list()

  sigprofiler_extract(cn_tally_W$nmf_matrix, "~/test/test_sigminer",
    use_conda = TRUE
  )

  sigprofiler_extract(cn_tally_W$nmf_matrix, "~/test/test_sigminer",
    use_conda = FALSE, py_path = "/Users/wsx/anaconda3/bin/python"
  )
}

data("simulated_catalogs")
sigprofiler_reorder(t(simulated_catalogs$set1))
</code></pre>


</div>