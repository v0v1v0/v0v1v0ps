<div class="container">

<table style="width: 100%;"><tr>
<td>samLL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Training function of Sparse Additive Logistic Regression</h2>

<h3>Description</h3>

<p>The logistic model is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">samLL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.1,
  thol = 1e-05,
  max.ite = 1e+05,
  regfunc = "L1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The <code>n</code>-dimensional label vector of the training set, where <code>n</code> is sample size. Labels must be coded in 1 and 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samLL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 20.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regfunc</code></td>
<td>
<p>A string indicating the regularizer. The default value is "L1". You can also assign "MCP" or "SCAD" to it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by "warm-start" and "active-set" tricks.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p+1</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion with the intercept, the length of each column is <code>d*p+1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>SAM</code>,<code>plot.samLL,print.samLL,predict.samLL</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## generating training data
n = 200
d = 100
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)
y = sign(((X[,1]-0.5)^2 + (X[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
y = y*sign(runif(n)-0.05)
y = sign(y==1)

## Training
out.trn = samLL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)

yt = sign(((Xt[,1]-0.5)^2 + (Xt[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
yt = yt*sign(runif(nt)-0.05)
yt = sign(yt==1)

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>


</div>