<div class="container">

<table style="width: 100%;"><tr>
<td>syncsa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SYNCSA</h2>

<h3>Description</h3>

<p>This function integrates several steps for the analysis of phylogenetic
assembly patterns and their links to traits and ecological processes in a
metacommunity (Pillar et al. 2009, Pillar &amp; Duarte 2010, Debastiani &amp; Pillar 2012). The
function implement methods that have been available in the SYNCSA
application written in C++ (by Valerio Pillar, available at
http://ecoqua.ecologia.ufrgs.br/SYNCSA.html). See details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">syncsa(
  comm,
  traits = NULL,
  phylodist = NULL,
  envir = NULL,
  checkdata = TRUE,
  ro.method = "mantel",
  method = "pearson",
  dist = "euclidean",
  scale = TRUE,
  scale.envir = TRUE,
  ranks = TRUE,
  ord,
  put.together = NULL,
  na.rm = FALSE,
  strata = NULL,
  permutations = 999,
  parallel = NULL,
  notification = TRUE
)

## S3 method for class 'syncsa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
traits, phylodist, envir and put.together must be null. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traits</code></td>
<td>
<p>Data frame or matrix data of species described by traits, with traits as
columns and species as rows (Default traits = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species.
Must be a complete matrix, not a half diagonal matrix (Default phylodist = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environmental variables for each community, with variables as
columns and sampling units as rows (Default envir = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the
trait and in the phylodist matrices and if sampling units in the community data follows
the same order as the one in the environmental data (Default checkdata = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ro.method</code></td>
<td>
<p>Method to obtain the correlation, "mantel" or "procrustes"
(Default ro.method = "mantel").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Mantel correlation method, as accepted by cor: "pearson",
"spearman" or "kendall" (Default method = "pearson").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Dissimilarity index used for Mantel correlation, as accepted by
vegdist: "manhattan", "euclidean", "canberra", "bray", "kulczynski",
"jaccard", "gower", "altGower", "morisita", "horn", "mountford", "raup" ,
"binomial" or "chao" (Default dist = "euclidean").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the traits are
measured on different scales (Default Scale = TRUE). When scale = TRUE traits
are measured on different scales the the matrix T is subjected to
standardization within each trait. When scale = FALSE traits are measured on
the same scale and the matrix T is not subjected to standardization.
Furthermore, if scale = TRUE the matrix of traits is subjected to
standardization within each trait, and Gower Index is used to calculate the
degree of belonging to the species, and if scale = FALSE the matrix of
traits is not subjected to standardization, and Euclidean distance is
calculated to determine the degree of belonging to the species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.envir</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the
environmental variables are measured on different scales. If the
enviromental variables are measured on different scales, the scale.envir
= TRUE the matrix with enviromental variables is subjected to centralization
and standardization within each variable. (Default scale.envir = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks (Default ranks = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>Method to be used for ordinal variables, see <code>gowdis</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>put.together</code></td>
<td>
<p>List to specify group of traits. Each group specify receive the
same weight that one trait outside any group, in the way each group is considered
as unique trait (Default put.together = NULL). This argument must be a list, see
examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if pairwise
distances should be deleted in cases of missing observations (Default na.rm
= FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>Strata named vector to specify restricting permutations within species
groups (Default strata = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permutations</code></td>
<td>
<p>Number of permutations in assessing significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Number of parallel processes. Tip: use parallel::detectCores() (Default parallel = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notification of missing observations should to be shown (Default
notification = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class syncsa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters for the respective functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Package <strong>SYNCSA</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all dataframe/matrices.
The function <code>organize.syncsa</code> organizes the data for the functions
of the package, placing the matrices of community, traits, phylogenetic distance,
environmental varibles and strata vector in the same order. The function
use of function organize.syncsa is not requered for run the functions, but
is recommended. It requires data organized into the following matrices: (1) the
presences or abundances of species in a set of communities (<strong>W</strong>); (2) the
phylogenetic pairwise dissimilarities of these species (<strong>DF</strong>); (3) a set of
functional traits describing the species (<strong>B</strong>), which
may be a mixture of binary and quantitative traits (continual and ordinal),
but not nominal ones (these should be expanded into binary traits); and (4)
the ecological gradient of interest, which may be one or more factors to
which the communities respond or ecosystem effects of the communities
(<strong>E</strong>). In this way the arguments comm, traits, phylodist, envir,
as well as the arguments put.together and strata, can be specified them as normal
arguments or by passing them with the object returned by the function
<code>organize.syncsa</code> using, in this case only the argument comm. Using the
object returned by organize.syncsa, the comm argument is used as an alternative way
of entering to set all data.frames/matrices, and therefore the other arguments
(traits, phylodist, envir, put.together and strata) must be null.
</p>
<p><strong>Correlations</strong>
</p>
<p>The function computes several correlations (Mantel or
Procrustes) that express trait-convergence assembly patterns (TCAP),
trait-divergence assembly patterns (TDAP), and phylogenetic signal in
functional traits at the species pool level and at the metacomunity level.
This function also generates P-values by permutation testing based on null
models (Pillar et al. 2009, Pillar &amp; Duarte 2010).
</p>
<p><strong>ro(TE)</strong>
</p>
<p>This correlation refers to trait-convergence assembly patterns related to
the ecological gradient (TCAP, Pillar et al. 2009). For evaluating TCAP, by
matrix multiplication we define <strong>T = WB</strong>, which with previous
standardization of <strong>W</strong> to unit column totals will contain the trait
averages in each community. The elements in <strong>T</strong> are community
weighted mean values or community functional parameters (Violle et al.
2007). Standardization of the traits (rows) in <strong>T</strong> is needed if the
trait set contains traits measured with different scales. By using matrix
correlation, we evaluate how the trait patterns in <strong>T</strong> are associated
to ecological gradients in <strong>E</strong>. For relating <strong>T</strong> to
<strong>E</strong>, using Mantel correlation we define a distance matrix of the
communities (<strong>DT</strong>) using <strong>T</strong>, and another distance matrix of
the community sites (<strong>DE</strong>) using <strong>E</strong>. The matrix correlation
ro(<strong>TE</strong>) = ro(<strong>DT</strong>;<strong>DE</strong>) measures the level of
congruence between TCAP and <strong>E</strong>. A strong correlation ro(<strong>TE</strong>)
indicates the factors directly or indirectly represented in <strong>E</strong> are
involved in ecological filtering of species that, at least for the traits
considered in the analysis, consistently produce trait-convergence assembly
patterns along the gradient comprising the metacommunity.
</p>
<p><strong>ro(XE) and ro(XE.T)</strong>
</p>
<p>These matrix correlations refer to trait-divergence assembly patterns
related to the ecological gradient (TDAP, Pillar et al. 2009). For the
identification of TDAP, in a first step the species pairwise similarities
(in the range 0 to 1) in matrix <strong>SB</strong> based on traits in <strong>B</strong>
are used to define matrix <strong>U</strong> with degrees of belonging of species to
fuzzy sets. By matrix multiplication <strong>X = WU</strong> will contain the
species composition of the communities after fuzzy-weighting by their trait
similarities (each row in <strong>X</strong> will refer to a species). Matrix
<strong>X</strong> expresses both TCAP and TDAP (Pillar et al. 2009). By using
matrix correlation, we evaluate how the trait patterns in <strong>X</strong> (TCAP
and TDAP) are associated to ecological gradients in <strong>E</strong>. For relating
<strong>X</strong> to <strong>E</strong>, we define a distance matrix of the communities
(<strong>DX</strong>) using <strong>X</strong>, and another distance matrix of the community
sites (<strong>DE</strong>) using <strong>E</strong>. The matrix correlation ro(<strong>XE</strong>)
= ro(<strong>DX</strong>;<strong>DE</strong>) between <strong>X</strong> and <strong>E</strong> is defined.
We then remove the trait-convergence component ro(<strong>TE</strong>) from
ro(<strong>XE</strong>) by computing the partial matrix correlation
ro(<strong>XE.T</strong>), which measures the level of congruence between TDAP and
<strong>E</strong>. Trait-divergence assembly patterns (TDAP, Pillar et al. 2009)
may result from community assembly processes related to biotic interactions
(Stubbs &amp; Wilson 2004; Wilson 2007).
</p>
<p><strong>ro(PE)</strong>
</p>
<p>This matrix correlation refers to the phylogenetic structure related to the
ecological gradient comprising the metacommunity. The phylogenetic pairwise
dissimilarities in <strong>DF</strong> are transformed into similarities and used to
define degrees of belonging qij to fuzzy sets. This is analogous to the
definition of functional fuzzy sets (Pillar &amp; Orloci 1991; Pillar et al.
2009). Based on the phylogenetic similarities, every species i among s
species in the metacommunity specifies a fuzzy set to which every species j
(j = 1 to s species, including species i) belongs with a certain degree of
belonging in the interval [0, 1]. In our definition, each row in matrix
<strong>Q</strong> with the degrees of belonging must add to unit, i.e., the degrees
of belonging of a given species across the fuzzy sets are standardized to
unit total. By matrix multiplication <strong>P = WQ</strong> will contain the
composition of the communities after fuzzy-weighting of species presences or
abundances by the species' phylogenetic similarities. Each column in matrix
<strong>P</strong> holds the phylogenetic structure of a community. The
standardization of <strong>Q</strong> is essential for the community totals in each
column in <strong>W</strong> remaining the same in <strong>P</strong>. Further, matrix
<strong>W</strong> is adjusted to unit column totals prior to multiplication, so
that the total richness or abundance within each community in <strong>W</strong>
will be standardized. Matrix correlation ro(<strong>PE</strong>) =
ro(<strong>DP</strong>;<strong>DE</strong>) measures the strength of the association between
community distances based on their phylogenetic structure in <strong>DP</strong> and
distances based on their ecological conditions (<strong>DE</strong>). Further,
<strong>P</strong> can be explored for phylogenetic patterns at the metacommunity
level by using, e.g., ordination techniques.
</p>
<p><strong>ro(PT) and ro(PX.T)</strong>
</p>
<p>These matrix correlations measure phylogenetic signal at the metacommunity
level related to TCAP and to TDAP. We define phylogenetic signal at the
metacommunity level related to TCAP (PSMT) as the correlation between the
phylogenetic structure described in matrix <strong>P</strong> and the
trait-convergence structure described in matrix <strong>T</strong>. For this, a
proper distance matrix (e.g. Euclidean distances) of communities
(<strong>DP</strong>) is computed using <strong>P</strong> and another distance matrix of
the same communities (<strong>DT</strong>) is computed using <strong>T</strong>. Then matrix
correlation ro(<strong>PT</strong>) = ro(<strong>DP</strong>;<strong>DT</strong>) will measure the
level of congruence between variation in <strong>P</strong> and <strong>T</strong>, which is
a measure of PSMT. A strong phylogenetic signal at the metacommunity level
is expected when communities that are more similar in terms of phylogenetic
structure are also similar regarding their average trait values. We also
define phylogenetic signal at the metacommunity level related to TDAP
(PSMX.T) as the partial matrix correlation ro(<strong>PX.T</strong>) =
ro(<strong>DP</strong>;<strong>DX.DT</strong>) between community distances DP computed on
phylogenetic structure and community distances <strong>DX</strong> computed on
species composition after fuzzy-weighting by the species, or trait
similarities, removing the effect of TCAP (<strong>DT</strong>). This is analogous
to TDAP.
</p>
<p><strong>ro(BF)</strong>
</p>
<p>This matrix correlation measures phylogenetic signal at the species pool
level (PSS, Pillar &amp; Duarte 2010). We define PSS as the matrix correlation
ro(<strong>FB</strong>) = ro(<strong>DF</strong>;<strong>DB</strong>) between species phylogenetic
dissimilarities (already defined as matrix <strong>DF</strong>) and species trait
dissimilarities (derived from already defined matrix <strong>SB</strong>) computed
on any number of traits from matrix <strong>B</strong>. The species pool refers to
the species present in the metacommunity.
</p>
<p><strong>Additional matrix correlations</strong>
</p>
<p>The matrix correlations ro(<strong>TE.P</strong>) and ro(<strong>XE.P</strong>) are also
computed, which may be useful for evaluating causal models in path analysis.
</p>
<p><strong>Mantel correlations</strong>
</p>
<p>The Mantel and Partial Mantel statistics are calculated simply as the correlation
entries the dissimilarity matrices, using standard Mantel test (see
<code>mantel</code> and <code>cor.mantel</code>). Partial Mantel
statistic use paired correlation between the three matrices and obtains the partial
correlation using the formula of first-order partial correlation coefficient. The
significances are obtained using a different procedure than standard Mantel test,
see section Testing against null models below.
</p>
<p><strong>Procrustes correlations</strong>
</p>
<p>The Procrustes correlation uses symmetric Procrustes as a measure of concordance
between the data matrices (see <code>procrustes</code> and
<code>cor.procrustes</code>). Procrustes procedure use rotation, translation,
and rescaling for minimizing sum of squared differences between two data sets.
The correlation of Procrustes is calculated as the statistic derived from the
symmetric Procrustes sum of squares, representing the optimal fit between the two
data matrices. Partial Procrustes correlation is obtained by Procrustes correlation
between residuals matrices. Firstly one Principal Components Analysis (PCA,
see <code>prcomp</code>) is performed in the matrix Z for dimensionality reduction.
The max number of axis kept in the analysis is the number of sampling units divided
by 2, this axes of PCA represent the total variation in the Z matrix. After the
kept axes are used as predictor in one linear model for each variable of the
matrices X and Y. For this a linear model is build using as response one variable
of X (same via for Y matrix) and as predictor all remaining axes of PCA, after model
fitted and the residual are extracted with the aim of form the residual matrix. The linear
model is repeated in the other variables, only with the changed the response variable.
The same procedure is performed in the matrix
Y. Both residual matrices are submitted to Procrustes analysis and the statistic is
returned as a partial correlation, the Partial Procrustes statistic. The significances
are obtained using the same procedure than Mantel test, see section Testing against
null models below.
</p>
<p><strong>Testing against null models</strong>
</p>
<p>All the matrix correlations are tested against null models. The null model
is defined accoding to the correlation being tested. Usually in the SYNCSA package
the null models are based in permutation of species rather than permutation
of sample units. For ro(<strong>TE</strong>),each permutation generates a random
matrix <strong>T</strong> calculated after the
permutation among the species vectors in matrix <strong>B</strong>. For
ro(<strong>XE</strong>) and ro(<strong>XE.T</strong>), each permutation generates a random
matrix <strong>X</strong> after the permutation among species fuzzy sets (rows) in
matrix <strong>U</strong>. For ro(<strong>PE</strong>), ro(<strong>PT</strong>), and
ro(<strong>PX.T</strong>), each permutation generates a random matrix <strong>P</strong>
after the permutation among species fuzzy sets (rows) in matrix <strong>Q</strong>.
For ro(<strong>BF</strong>), a conventional Mantel test is performed with
dissimilarity matrices <strong>DF</strong> and <strong>DB</strong>. Analogous null models
are used for testing the additional matrix correlations; that is, the same
null model for ro(<strong>TE</strong>) is used for ro(<strong>TE.P</strong>), the same model
for ro(<strong>XE</strong>) is used for ro(<strong>XE.P</strong>). The permutation can be restrict
within species groups specifying the strata argument.
</p>
<p><strong>Traits types</strong>
</p>
<p>Traits data can be numeric, factor or ordered factor. For this be considered in the
analyses traits data must be of data.frame class and containing each variable type
determined. Gower index is used to calculate the similarity between species, using
the function gowdis of package FD. For additional details and requirements of function
please see <code>gowdis</code>.
</p>
<p><strong>Missing data</strong>
</p>
<p>The functions ignore missing data when specified. In the case of direct
multiplication of matrices the missing data are replaced by 0, ignoring the cell with missing value. For the
matrix <strong>T = WB</strong> an adjustment is done by divide each cell of the product
matrix (<strong>T</strong>) by the sum of species proportion with trait data in <strong>B</strong>. Result
matrices are shown without missing values. Where the matrices are calculated
using a dissimilarity index (matrix <strong>U</strong> and correlations between
matrices) the missing data are ignored as in <code>vegdist</code> function.
In some cases the dissimilarity matrices obtained by the function
<code>vegdist</code> still contain some missing values. In these cases the
rest of the procedure will be affected. In these cases you can find
solutions in impute the missing values.
</p>
<p><strong>Error messenger and options</strong>
</p>
<p>The data pass by several ckeck points that can produce error messenger. The
matrices or data frames must be contain only numeric, binary or ordinal
variables, in the way that nominal variable should be expanded into binary
(see <code>var.dummy</code>). For enhance the code speed some functions use
by default matrix algebra, this option can produce error under certain circumstances. This
global option can be changed using options("SYNCSA.speed" = FALSE). If SYNCSA.speed = TRUE
for use matrix algebra and if SYNCSA.speed = FALSE use not another function of same procedure.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notes</code></td>
<td>
<p>Some notes about the statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistics</code></td>
<td>
<p>Correlations roTE, roXE, roPE, roPT, roPX.T, roXE.T, roTE.P, roXE.P
and roBF, and their significance levels based on permutations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrices</code></td>
<td>
<p>The matrices
produced for the functions, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FunRao</code></td>
<td>
<p>Rao
quadratic entropy within each community, considering trait distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Weight for each trait.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function calculates the correlations despite the lack of one of
the matrices, provided that community data had been entered. Correlations
including unspecified matrices will appear with NA.
</p>
<p><strong>IMPORTANT</strong>: The sequence of species in the community data matrix
MUST be the same as that in the phylogenetic distance matrix and in traits
matrix. Similarly, the sequence of communities in the community data matrix
MUST be the same as that in the environmental data. See details and
<code>organize.syncsa</code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Debastiani, V.J &amp; Pillar, V.D., (2012). SYNCSA-R tool for analysis of metacommunities
based on functional traits and phylogeny of the community components. Bioinformatics,
28(15), 2067–2068.
</p>
<p>Pillar, V.D.; Duarte, L.d.S., (2010). A framework for metacommunity analysis
of phylogenetic structure. Ecology Letters, 13, 587:596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>
<p>Pillar, V.D. &amp; Orloci, L., (1991). Fuzzy components in community level
comparisons. In: Computer Assisted Vegetation Analysis (eds Feoli, E. &amp;
Orloci, L.). Kluwer, Dordrecht, 87:93.
</p>
<p>Stubbs, W.J. &amp; Wilson, J.B., (2004). Evidence for limiting similarity in a
sand dune community. Journal of Ecology, 92, 557:567.
</p>
<p>Violle, C., Navas, M.L., Vile, D., Kazakou, E., Fortunel, C., Hummel, I. &amp;
Garnier, E., (2007). Let the concept of trait be functional! Oikos, 116,
882:892.
</p>
<p>Wilson, J.B., (2007). Trait-divergence assembly rules have been demonstrated:
limiting similarity lives! A reply to Grime. Journal of Vegetation Science,
18, 451:452.
</p>


<h3>See Also</h3>

<p><code>organize.syncsa</code>, <code>matrix.t</code>,
<code>matrix.x</code>, <code>matrix.p</code>, <code>optimal</code>,
<code>rao.diversity</code>, <code>cor.matrix</code>, <code>var.type</code>,
<code>var.dummy</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(ADRS)
syncsa(ADRS$community, ADRS$traits, ADRS$phylo, ADRS$envir, permutations = 99)
data(flona)
put.together&lt;-list(c("fol","sem"), c("tam", "red"))
put.together
res&lt;-syncsa(flona$community, flona$traits, envir = flona$environment,
   put.together = put.together, permutations = 99)
res$weights
</code></pre>


</div>