<div class="container">

<table style="width: 100%;"><tr>
<td>relErr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relative Error When Appropriate, Absolute Otherwise</h2>

<h3>Description</h3>


<dl>
<dt>
<code>relErrV()</code>:</dt>
<dd>
<p>Compute the signed relative error componentwise (“vectorized”)
between the <code>target</code> and <code>current</code> vectors,
using the <em>absolute</em> error, i.e., the difference
in case the relative error is not well defined, i.e., when <code>target</code>
is zero or infinite.</p>
</dd>
<dt>
<code>relErr()</code>:</dt>
<dd>
<p>simply the <em>mean</em> absolute value of the
relative errors between <code>target</code> and <code>current</code> vectors;
typically the “same” as
<code>all.equal.numeric(target, vector, tolerance=0, countEQ=TRUE)</code>.
</p>
<p>Currently useful only when both vectors are finite.
</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">relErrV(target, current, eps0 = .Machine$double.xmin)
relErr (target, current)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>numeric, possibly scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>current</code></td>
<td>
<p>numeric vector of <code>length()</code> a multiple of
<code>length(target)</code>; if an <code>array</code> (incl
<code>matrix</code>), dimensions are preserved; for vectors,
<code>names(target)</code> are preserved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps0</code></td>
<td>
<p>non-negative number; values <code>abs(target) &lt; eps0</code> should
be treated as zero (and hence <em>absolute</em> instead of relative error
be computed).  This may be crucial when <code>target</code> is an
<code>"mpfr"</code>-number vector.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<dl>
<dt>
<code>relErrV()</code>:</dt>
<dd>
<p>a numeric vector of the same length (or array
of the same dimension) as <code>current</code>.</p>
</dd>
</dl>
<dl>
<dt>
<code>relErr()</code>:</dt>
<dd>
<p>a single number.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Martin Maechler,
originally as part of <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package's ‘<span class="file">test-tools.R</span>’.
</p>


<h3>See Also</h3>

<p><code>all.equal.numeric()</code> is similar in spirit but returns <code>TRUE</code> or
string containing the <em>mean</em> relative or absolute error.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## relErrV() test example: showing how it works fine with {NA, Inf, 0} :
eps &lt;- 1e-4*c(-9, -8, -6, -4, 0.5, 1, 5)
target  &lt;- c(-1:1, 0,   0, NA, NaN, Inf, -Inf, Inf, 0 , Inf, 1 , -3:3)
current &lt;- c(-1:1,1e-7,NaN,NA,  0 , Inf,  Inf,  0, Inf,  1, Inf, -3:3+ eps)
cbind(target, current, absE = current-target,
                       relE = relErrV(target,current)) -&gt; M ; M
stopifnot(exprs = {
         is.logical(isFr &lt;- is.finite(rF &lt;- M[,"relE"]))
  target==current | isFr == is.finite(aF &lt;- M[,"absE"])
  identical(aF[!isFr] , rF[!isFr])
  identical(numeric(), relErrV(numeric(), integer())) # length 0 {used to fail}
})
tools::assertError(relErrV(1, numeric()), verbose=TRUE) # no longer allowed
## relErr() is pretty simple --- (possibly too simple, currently)
relErr
relErr(target, current) # NA (of course)
all.equal.numeric(target, current) ## "'is.NA' value mismatch ..."

## comparison after dropping NA's :
hasN &lt;- is.na(target) | is.na(current)
all.equal(target[!hasN], current[!hasN], tolerance=0) # "Mean abs. diff.: Inf"
   relErr(target[!hasN], current[!hasN]) # NaN  (to improve?)

## comparison after only keeping cases where both are finite:
finN &lt;- is.finite(target) &amp; is.finite(current)
all.equal(target[finN], current[finN], tol=0)          # "Mean abs.d.: 0.000279.."
all.equal(target[finN], current[finN], tol=0, countEQ=TRUE) #   "  " : 0.000239..
   relErr(target[finN], current[finN]) # 0.0002392929
</code></pre>


</div>