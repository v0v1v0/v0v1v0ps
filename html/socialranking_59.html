<div class="container">

<table style="width: 100%;"><tr>
<td>LPScores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LP Ranking</h2>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{p}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPScores(powerRelation, elements = powerRelation$elements)

LPRanking(powerRelation)

lexcelPScores(powerRelation, elements = powerRelation$elements)

lexcelPRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>For <code class="reqn">i, j \in N</code>, the social ranking solution <code class="reqn">L^p</code> then ranks <code class="reqn">i</code> strictly above <code class="reqn">j</code> if one of the following conditions hold:
</p>

<ol>
<li> <p><code class="reqn">\lbrace i \rbrace \succ \lbrace j \rbrace</code>;
</p>
</li>
<li> <p><code class="reqn">\lbrace i \rbrace, \lbrace j \rbrace \in \Sigma_k</code> and there exists a row <code class="reqn">p_0 \in \lbrace 2, \dots, |N|\rbrace</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{q &lt; k} (M^\succsim_i)_{p,q} = \sum_{q &lt; k} (M^\succsim_j)_{p,q}\quad \forall p &lt; p_0,\text{ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{q &lt; k} (M^\succsim_i)_{p_0,q} &gt; \sum_{q &lt; k} (M^\succsim_j)_{p_0,q}.</code>
</p>

</li>
</ol>
<p>In <code>R</code>, given two matrices <code>M_i</code> and <code>M_j</code>, this comparison could be expressed as
</p>
<pre>
# function that returns TRUE if i should be ranked strictly above j
k_i &lt;- which(M_i[1,] == 1)
k_j &lt;- which(M_j[1,] == 1)
if(k_i != k_j) return(k_i &lt; k_j)
if(k_i == 1)   return(FALSE)
# get sum for each row
# removing the first row implies that we start in row 2
sums_i &lt;- apply(M_i[-1,seq(k_i-1)], 1, sum)
sums_j &lt;- apply(M_j[-1,seq(k_j-1)], 1, sum)
# apply lexcel comparison
i &lt;- which(a != b)
return(length(i) &gt; 0 &amp;&amp; a[i[1]] &gt; b[i[1]])
</pre>


<h3>Value</h3>

<p>Score function returns a list of type <code>LPScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>length(powerRelation$elements)</code>.
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 12 \sim 2) \succ (13 \sim 23) \succ (1 \sim 3 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
0 &amp; 2 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p><code class="reqn">(M^\succsim_2)_{2,3}</code> in this context refers to the value in the second row and third column of element 2, in this case <code class="reqn">1</code>.
</p>
<p>In the example, <code class="reqn">2</code> will be immediately put above <code class="reqn">1</code> and <code class="reqn">3</code> because <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 1 \rbrace</code> and <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 3 \rbrace</code>.
Since <code class="reqn">\lbrace 1 \rbrace \sim \lbrace 3 \rbrace</code>, we next consider the coalitions of size 2. Here, it turns out that <code class="reqn">(M^\succsim_1)_{2,1} + (M^\succsim_1)_{2,2} = 1 + 1</code>
is equal to <code class="reqn">(M^\succsim_3)_{2,1} + (M^\succsim_3)_{2,2} = 0 + 2</code>.
For obvious reasons the grand coalition does not have to be considered, thus <code class="reqn">1</code> and <code class="reqn">3</code> are considered equally powerful by the <code class="reqn">L^p</code> solution.
</p>
<p><code class="reqn">L^{p}</code> is a social ranking solution belonging to the family of lexicographical ranking functions.
While related to <code>L1Ranking()</code>, it incorporates the property of "standardness", stating that if the
singleton coalition <code class="reqn">\lbrace i\rbrace \succ \lbrace j\rbrace</code>, then the ranking solution
should also prefer <code class="reqn">i</code> over <code class="reqn">j</code>.
</p>
<p>If <code class="reqn">\lbrace i\rbrace \sim \lbrace j\rbrace</code>, then all coalitions from size 2 and upward are inspected,
giving higher precedence to coalitions with a lower number of elements.
While this preference is similar to the <code class="reqn">L^{(1)}</code>, it differs in two notable ways:
</p>

<ol>
<li>
<p> If <code class="reqn">\lbrace i\rbrace, \lbrace j\rbrace \in \Sigma_k</code>, then only coalitions
<code class="reqn">S \succsim (\lbrace i \rbrace \sim \lbrace j \rbrace)</code> are considered,
</p>
</li>
<li>
<p> From this subset of coalitions, consider the total number of coalitions <code class="reqn">i</code> (or <code class="reqn">j</code>) belongs to, given each coalition size.
This may ignore information about the distribution of these coalitions within the different equivalence classes,
which <code class="reqn">L^{(1)}</code> and the slight variation <code class="reqn">L^{p^*}</code> of the <code class="reqn">L^p</code> solution take into account.
</p>
</li>
</ol>
<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
“Lexicographic solutions for coalitional rankings based on individual and collective performances.”
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code>L1Scores()</code> function.
</p>
<p>For efficiency, <code>LPScores()</code> discards much of the redundant information.
Instead of a matrix for each element, it returns a vector of size <code class="reqn">|N|</code>.
</p>
<p>Given a score vector <code>v</code> for an element <code>i</code>, <code>v[1]</code> is the position of the singleton coalition <code>{i}</code>.
This implies that if <code>v[1] &lt; w[1]</code>, where <code>w</code> is the score vector of an element <code>j</code>, then <code>i</code> is ranked strictly above <code>j</code>.
</p>
<p><code>v[2]</code>, <code>v[3]</code>, ..., <code>v[n]</code> then indicates the number of coalitions of size <code>2</code>, <code>3</code>, ..., <code>n</code> that the element <code>i</code> appears in.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcelPScores()</code> and <code>lexcelPRanking()</code> serve as aliases for <code>LPScores()</code> and <code>LPRanking()</code>, respectively.
</p>


<h3>References</h3>

<p>Béal S, Rémila E, Solal P (2022).
“Lexicographic solutions for coalitional rankings based on individual and collective performances.”
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code>L1Scores()</code>,
<code>L2Scores()</code>,
<code>LPSScores()</code>,
<code>copelandScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>lexcelScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("(123 ~ 13 ~ 2) &gt; (12 ~ 1 ~ 3) &gt; (23 ~ {})")
scores &lt;- LPScores(pr)
scores$`2`
# [1] 1 0 0

LPRanking(pr)
# 2 &gt; 1 ~ 3

# Since L^(1) also the relation {1,2}, which ranks above {2,3}, it will place 1 above 3
L1Ranking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>


</div>