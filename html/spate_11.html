<div class="container">

<table style="width: 100%;"><tr>
<td>loglike</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Log-likelihood of the hyperparameters.
</h2>

<h3>Description</h3>

<p>Evaluates the log-likelihood of the hyperparameters given the data (Gaussian case) or
given the latent variable w (in the Tobit case).
</p>


<h3>Usage</h3>

<pre><code class="language-R">loglike(par=NULL,w=NULL,wFT=NULL,x=NULL,spec=NULL,Gvec=NULL,tau2=NULL,n,T,
         NF=n*n,indCos=(1:((n*n-4)/2)*2+3),ns=4,nu=1,dt=1,logScale=FALSE,
         logInd=c(1,2,3,4,5,9),negative=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p> Vector of parameters for the SPDE in the following order: rho_0, sigma^2, zeta,
rho_1, gamma, alpha, mu_x, mu_y, tau^2, regression coefficients beta. rho_0 and sigma^2 are the range
and marginal variance of the Whittle covariance funtion for the
innovation term epsilon. zeta is the damping parameter. rho_1, gamma,
and alpha parametrize the diffusion matrix with rho_1 being a range
parameter, gamma and alpha determining the amount and the direction,
respectively, of anisotropy. mu_x and mu_y are the two components of
the drift vector. tau^2 denotes the variance of nugget effect or
measurment error. Subsequently in par are the
regression coefficients beta, if there are covariates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>Matrix of size T x N, where T and N denote the number of points in time
and space. In the case of a Gaussian data model, w contains the
observed values, with the Tobit model, w denotes the latent normal variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wFT</code></td>
<td>
<p> A vector with the (discrete) Fourier transform of the observed or latent w, depending
on which data model is used. Note that, in contrast to w, this needs to
be in stacked vector format. Use 'TSmat.to.vect'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> Covariates in an array of dimensions p x T X N, where p denotes the
number of covariates, T the number of time points, and n the number of
spatial points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>

<p>A vector containing the spectrum of the innovation term epsilon. If 'spec' is not given, it is constructed based on 'par'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gvec</code></td>
<td>

<p>The propagator matrix G in vector format obtained from 'get.G.vec'. If 'Gvec' is not given, it is constructed based on 'par'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>

<p>Measurement error variance tau2. If 'NULL'; tau2=par[9].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>Number of grid points on each axis. n x n is the total number of spatial points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>

<p>Number of points in time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NF</code></td>
<td>
<p>Number of Fourier functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indCos</code></td>
<td>
<p> Vector of integers indicating the position of wavenumbers of cosine-only terms. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ns</code></td>
<td>
<p> Number of real Fourier functions that have only a cosine and no sine
term. 'ns' is maximal 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p> Smoothness parameter of the Matern covariance function for the innovations. By
default this equals 1 corresponding to the Whittle covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p> Temporal lag between two time points. By default, this equals 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logScale</code></td>
<td>

<p>logical; if 'TRUE' the parameters specified in 'logInd' are on the
logarithmic scale. This is used for constraining parameters to be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logInd</code></td>
<td>

<p>Vector of integers indicating which parameters are on the log-scale.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negative</code></td>
<td>

<p>logical; if 'TRUE' the negative log-likelihood is returned otherwise the
positive log-likelihood is returned.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Value of the log-likelihood evaluated at 'par'.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 20
T &lt;- 20
##Specify hyper-parameters
par &lt;- c(rho0=0.1,sigma2=0.2,zeta=0.5,rho1=0.1,gamma=2,alpha=pi/4,muX=0.2,muY=-0.2,tau2=0.01)
##Simulate data
spateSim &lt;- spate.sim(par=par,n=n,T=T,seed=4)
w &lt;- spateSim$w

##Initial values for optim. This takes a couple of seconds.
parI &lt;- c(rho0=0.2,sigma2=0.1,zeta=0.25,rho1=0.01,gamma=1,alpha=0.3,muX=0,muY=0,tau2=0.005)
logInd=c(1,2,3,4,5,9)
##Transform to log-scale
parI[logInd] &lt;- log(parI[logInd])

##Fourier transform needs to be done only once
wFT &lt;- real.fft.TS(w,n=n,T=T)
##ML estimation using optim, takes a couple of seconds
##Load the precomputed object a line below to save time
##spateMLE &lt;- optim(par=parI,loglike,control=list(trace=TRUE,maxit=1000),wFT=wFT,method="L-BFGS-B",
##     lower=c(-10,-10,-10,-10,-10,0,-0.5,-0.5,-10),
##     upper=c(10,10,10,10,10,pi/2,0.5,0.5,10),negative=TRUE,
##     logScale=TRUE,hessian=TRUE,n=n,T=T)
data("spateMLE")

mle &lt;- spateMLE$par
mle[logInd] &lt;- exp(mle[logInd])
sd=sqrt(diag(solve(spateMLE$hessian)))

MleConfInt &lt;- data.frame(array(0,c(4,9)))
colnames(MleConfInt) &lt;- names(par)
rownames(MleConfInt) &lt;- c("True","Estimate","Lower","Upper")
MleConfInt[1,] &lt;- par
MleConfInt[2,] &lt;- mle
MleConfInt[3,] &lt;- spateMLE$par-2*sd
MleConfInt[4,] &lt;- spateMLE$par+2*sd
MleConfInt[c(3,4),logInd] &lt;- exp(MleConfInt[c(3,4),logInd])
cat("\n")
round(MleConfInt,digits=4)

</code></pre>


</div>