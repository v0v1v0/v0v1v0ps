<div class="container">

<table style="width: 100%;"><tr>
<td>lacov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Local Autocovariance Matrices
</h2>

<h3>Description</h3>

<p>Computation of local autocovariance matrices for a multivariate space-time dataset based on a given set of spatio-temporal kernel functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lacov(x, coords, time, kernel_type, kernel_parameters, 
      lags, kernel_list = NULL, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the space-time random field and the <code>n</code> rows are the observations. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the spatial coordinates of the corresponding observation over a 2D spatial domain.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>

<p>a numeric vector of length <code>n</code> where each entry represents the temporal coordinate of the corresponding observation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>

<p>either a string or a string vector of length <code>K</code> (or <code>1</code>) indicating which spatio-temporal kernel function to use. Implemented choices are <code>'ring'</code>, <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector of length <code>K</code> (or <code>1</code>) for the <code>'ball'</code> and <code>'gauss'</code> kernel function or a list of length <code>K</code> (or <code>1</code>) for the <code>'ring'</code> kernel, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>

<p>an integer vector of length <code>K</code> (or <code>1</code>) that provides the temporal lags for the spatio-temporal kernel functions, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list of spatio-temporal kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code>stkmat</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is centered prior computing the local covariance matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Local autocovariance matrices are defined by </p>
<p style="text-align: center;"><code class="reqn"> LACov(f) = 1/(n F_{f,n}) \sum_{i,j} f(s_i-s_j,t_i-t_j) (x(s_i,t_i)-\bar{x}) (x(s_j,t_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F^2_{f,n} = 1 / n \sum_{i,j} f^2(s_i-s_j,t_i-t_j).</code>
</p>
<p> Here, <code class="reqn">x(s_i,t_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i,t_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the space-time kernel function <code class="reqn">f</code> determines the locality. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: the spatial parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(r_i &lt; d_s \le r_o)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'ball'</code>: the spatial parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = I(d_s \le r)I(d_t = u)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the spatial parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>, the temporal parameter is the temporal lag <code class="reqn">u</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d_s,d_t) = exp(-0.5 (\Phi^{-1}(0.95) d_s/r)^2)I(d_t = u)</code>
</p>

</li>
</ul>
<p>Above, <code class="reqn">I()</code> represents the indicator function. The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>lags</code> provides the used temporal lags for the kernel functions (<code class="reqn">u</code> in the above formulas) and the argument <code>kernel_parameters</code> gives the spatial parameters for the kernel function. Each of the arguments <code>kernel_type</code>, <code>lags</code> and <code>kernel_parameters</code> can be of length <code>K</code> or <code>1</code>. Specifically, <code>kernel_type</code> can be either one kernel, then each local autocovariance matrix use the same kernel type, or of length <code>K</code> which leads to different kernel functions for the provided kernel parameters. <code>lags</code> can be either one integer, then for each kernel the same temporal lag is used, or an integer vector of length  <code>K</code> which leads to different temporal lags. In the same fashion <code>kernel_parameters</code> is a vector of length <code>K</code> or <code>1</code>. If <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then the corresponding entry of <code>kernel_parameters</code> gives the single spatial radius parameter. In contrast, if (at least one entry of) <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a list of length <code>K</code> (or <code>1</code>) where each entry is a numeric vector of length <code>2</code> defining the inner and outer spatial radius. See examples below.
</p>
<p>Alternatively, a list of kernel matrices can be given directly to the function <code>lacov</code> through the <code>kernel_list</code> argument. A list with kernel matrices can be computed with the function <code>stkmat</code>.
</p>


<h3>Value</h3>

<p><code>lacov</code> returns a list of length <code>K</code> where each entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a local autocovariance matrix. 
</p>


<h3>References</h3>

<p><cite>Muehlmann, C., De Iaco, S. and Nordhausen, K. (2023), Blind Recovery of Sources for Multivariate Space-Time Environmental Data. <em>Stochastic and Environmental Research and Risk Assessment</em>,  <b>37</b>, 1593â€“1613, &lt;doi:10.1007/s00477-022-02348-2&gt;.</cite>
</p>


<h3>See Also</h3>

<p><code>stkmat</code>, <code>stbss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># space and time coordinates
n_t &lt;- 50
n_sp &lt;- 10
st_coords &lt;- as.matrix(expand.grid(1:n_sp, 1:n_sp, 1:n_t))

# simulate three latent white noise fields
field_1 &lt;- rnorm(nrow(st_coords))
field_2 &lt;- rnorm(nrow(st_coords))
field_3 &lt;- rnorm(nrow(st_coords))

# compute the observed field
latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

# lacov with different ring kernels and same lags
lacov_r &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'ring', 
                 kernel_parameters = list(c(0, 1), c(1, 2)), lags = 1)

# lacov with same ball kernels and different lags
lacov_b &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'ball', kernel_parameters = 1, lags = c(1, 2, 3))

# lacov with different gauss kernels and different lags
lacov_g &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = 'gauss', kernel_parameters = 1, lags = 1:3)

# lacov mixed kernels
lacov_m &lt;- lacov(observed_field, coords = st_coords[, 1:2], time = st_coords[, 3], 
                 kernel_type = c('ball', 'ring', 'gauss'), 
                 kernel_parameters = list(1, c(1:2), 3), lags = 1:3)

# lacov with a kernel list
kernel_list &lt;- stkmat(coords = st_coords[, 1:2], time = st_coords[, 3], 
                      kernel_type = 'ring', 
                      kernel_parameters = list(c(0, 1)), lags = 1)
lacov_k &lt;- lacov(observed_field, kernel_list = kernel_list)
</code></pre>


</div>