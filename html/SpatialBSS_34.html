<div class="container">

<table style="width: 100%;"><tr>
<td>snss_sd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spatial Non-Stationary Source Separation Simultaneous Diagonalization
</h2>

<h3>Description</h3>

<p><code>snss_sd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant covariance by simultaneously diagonalizing two covariance matrices computed for two corresponding different sub-domains.
</p>


<h3>Usage</h3>

<pre><code class="language-R">snss_sd(x, ...)

## Default S3 method:
snss_sd(x, coords, direction = c('x', 'y'), 
     ordered = TRUE, ...)
## S3 method for class 'list'
snss_sd(x, coords, ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_sd(x, ...)
## S3 method for class 'sf'
snss_sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length two defining the subdivision of the domain, an object of class <code>sf</code> or an object of class <code>SpatialPointsDataFrame</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length two if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>

<p>a string indicating on which coordinate axis the domain is halved. Either <code>'x'</code> (default) or <code>'y'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered according to the decreasingly ordered eigenvalues. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments to be passed to or from methods.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant variances. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain in half according to the first coordinate (argument <code>direction</code> equals <code>'x'</code>) or the second coodinate (argument <code>direction</code> equals <code>'y'</code>) and simultaneously diagonalizing the sample covariance matrices for each of the two sub-domains.
</p>
<p>Alternatively the domain subdivison can be defined by providing lists of length two for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain.
</p>


<h3>Value</h3>

<p>Similarly as <code>sbss</code> the function <code>snss_sd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>diagonal matrix containing the eigenvalues of the eigendecomposition.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix for the first sub-domain.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>sp</code>, <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field %*% t(mixing_matrix)

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                              data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_sd with split in x 
res_x &lt;- snss_sd(observed_field, coords, direction = 'x')
JADE::MD(W.hat = coef(res_x), A = mixing_matrix)

# apply snss_sd with split in y
# should be much worse as field shows only variation in x
res_y &lt;- snss_sd(observed_field, coords, direction = 'y')
JADE::MD(W.hat = coef(res_y), A = mixing_matrix)

# print object
print(res_x)

# plot latent field
plot(res_x, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_x, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_x)

# apply snss_sd with SpatialPointsDataFrame object 
res_x_sp &lt;- snss_sd(observed_field_sp, direction = 'x')

# apply with list arguments
# first axis split by 5
flag_coords &lt;- coords[, 1] &lt; 5
coords_list &lt;- list(coords[flag_coords, ],
                    coords[!flag_coords, ])
field_list &lt;- list(observed_field[flag_coords, ],
                   observed_field[!flag_coords, ])
plot(coords, col = flag_coords + 1)

res_list &lt;- snss_sd(x = field_list,
                    coords = coords_list)
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>


</div>