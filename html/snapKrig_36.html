<div class="container">

<table style="width: 100%;"><tr>
<td>sk_rescale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Up or down-scale a sk grid by an integer factor</h2>

<h3>Description</h3>

<p>Changes the resolution of a sk grid by a factor of <code>up</code> or <code>down</code>. For down-scaling, this
introduces <code>NA</code>s at unobserved grid points (and does no interpolation).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_rescale(g, up = NULL, down = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a sk grid or any grid object accepted by <code>sk</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>up</code></td>
<td>
<p>integer &gt; 0, or vector of two, the up-scaling factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>down</code></td>
<td>
<p>integer &gt; 0, or vector of two, the down-scaling factors</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Users should specify a sk grid <code>g</code> to re-scale and an integer scaling factor; either <code>up</code>
or <code>down</code> (and not both). This effects the scaling of resolution (<code>g[['gres']]</code>) by <code>up</code>
or <code>1/down</code>.
</p>
<p><code>up</code> (or <code>down</code>) should be a vector of two positive integers, the desired re-scaling
factors in the y and x dimensions, in that order, or a single value to be used for both.
</p>
<p>When <code>up</code> is supplied, a lower resolution grid is returned comprising every <code>up</code>th grid
line of <code>g</code> along each dimension. All other grid lines, and any data values lying on them,
are ignored. <code>up</code> should be no greater than <code>dim(g) - 1</code>. Note that if <code>up</code> does not
evenly divide this number, the bounding box will shrink slightly.
</p>
<p>When <code>down</code> is supplied, the function returns a higher resolution grid (say <code>g_fine</code>) with
the same bounding box as <code>g</code>. Along each dimension, every <code>down</code>th grid line of <code>g_fine</code>
coincides with a grid line of <code>g</code>. Any non-NA values found in <code>g[]</code> are copied to <code>g_fine</code>,
and <code>g</code> can be recovered from <code>g_fine</code> with <code>sk_rescale(g_fine, up=down)</code>.
</p>


<h3>Value</h3>

<p>a sk grid of the requested resolution
</p>


<h3>See Also</h3>

<p>sk sk_cmean
</p>
<p>Other indexing functions: 
<code>sk_mat2vec()</code>,
<code>sk_sub_find()</code>,
<code>sk_sub_idx()</code>,
<code>sk_vec2mat()</code>
</p>
<p>Other sk constructors: 
<code>sk_snap()</code>,
<code>sk_sub()</code>,
<code>sk()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example data
gdim = c(50, 53)
pars = utils::modifyList(sk_pars(gdim), list(eps=1e-2))
g = sk_sim(gdim, pars)
plot(g)

# upscale
plot(sk_rescale(g, up=1)) # does nothing
plot(sk_rescale(g, up=2))

# downscale
sk_plot(sk_rescale(g, down=1)) # does nothing
sk_plot(sk_rescale(g, down=2))

# length-2 vectors to rescale differently in x and y directions
plot(sk_rescale(g, up=c(2,3)))
plot(sk_rescale(g, down=c(2,3)))

# invert a down-scaling
g_compare = sk_rescale(sk_rescale(g, down=c(5,3)), up=c(5,3))
all.equal(g, g_compare)

# multi-layer example with about 50% of points missing
idx_miss = sample.int(length(g), round(0.5*length(g)))
g_multi = sk_sim(gdim, pars, n_layer=3)
g_multi[idx_miss,] = NA

# plot third layer, then down-scaled and up-scaled versions
sk_plot(g_multi, layer=3)
sk_plot(sk_rescale(g=g_multi, down=2), layer=3)
sk_plot(sk_rescale(g=g_multi, up=2), layer=3)

</code></pre>


</div>