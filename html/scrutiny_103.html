<div class="container">

<table style="width: 100%;"><tr>
<td>rounding-common</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Common rounding procedures</h2>

<h3>Description</h3>

<p><code>round_up()</code> rounds up from 5, <code>round_down()</code> rounds down from
5. Otherwise, both functions work like <code>base::round()</code>.
</p>
<p><code>round_up()</code> and <code>round_down()</code> are special cases of <code>round_up_from()</code> and
<code>round_down_from()</code>, which allow users to choose custom thresholds for
rounding up or down, respectively.
</p>


<h3>Usage</h3>

<pre><code class="language-R">round_up_from(x, digits = 0L, threshold, symmetric = FALSE)

round_down_from(x, digits = 0L, threshold, symmetric = FALSE)

round_up(x, digits = 0L, symmetric = FALSE)

round_down(x, digits = 0L, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric. The decimal number to round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Integer. Number of digits to round <code>x</code> to. Default is <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Integer. Only in <code>round_up_from()</code> and <code>round_down_from()</code>.
Threshold for rounding up or down, respectively. Value is <code>5</code> in
<code>round_up()</code>'s internal call to <code>round_up_from()</code> and in <code>round_down()</code>'s
internal call to <code>round_down_from()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>Logical. Set <code>symmetric</code> to <code>TRUE</code> if the rounding of
negative numbers should mirror that of positive numbers so that their
absolute values are equal. Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions differ from <code>base::round()</code> mainly insofar as the
decision about rounding 5 up or down is not based on the integer portion of
<code>x</code> (i.e., no "rounding to even"). Instead, in <code>round_up_from()</code>, that
decision is determined by the <code>threshold</code> argument for rounding up, and
likewise with <code>round_down_from()</code>. The threshold is constant at <code>5</code> for
<code>round_up()</code> and <code>round_down()</code>.
</p>
<p>As a result, these functions are more predictable and less prone to
floating-point number quirks than <code>base::round()</code>. Compare <code>round_down()</code>
and <code>base::round()</code> in the data frame for rounding 5 created in the
Examples section below: <code>round_down()</code> yields a continuous sequence of
final digits from 0 to 9, whereas <code>base::round()</code> behaves in a way that
can only be explained by floating point issues.
</p>
<p>However, this surprising behavior on the part of <code>base::round()</code> is not
necessarily a flaw (see its documentation, or this vignette:
https://rpubs.com/maechler/Rounding). In the present version of R (4.0.0 or
later), <code>base::round()</code> works fine, and the functions presented here are
not meant to replace it. Their main purpose as helpers within scrutiny is
to reconstruct the computations of researchers who might have used
different software. See <code>vignette("rounding-options")</code>.
</p>


<h3>Value</h3>

<p>Numeric. <code>x</code> rounded to <code>digits</code>.
</p>


<h3>See Also</h3>

<p><code>round_ceiling()</code> always rounds up, <code>round_floor()</code> always
rounds down, <code>round_trunc()</code> always rounds toward 0, and
<code>round_anti_trunc()</code> always round away from 0.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Both `round_up()` and `round_down()` work like
# `base::round()` unless the closest digit to be
# cut off by rounding is 5:

   round_up(x = 9.273, digits = 1)     # 7 cut off
 round_down(x = 9.273, digits = 1)     # 7 cut off
base::round(x = 9.273, digits = 1)     # 7 cut off

   round_up(x = 7.584, digits = 2)     # 4 cut off
 round_down(x = 7.584, digits = 2)     # 4 cut off
base::round(x = 7.584, digits = 2)     # 4 cut off


# Here is the borderline case of 5 rounded by
# `round_up()`, `round_down()`, and `base::round()`:

original &lt;- c(    # Define example values
  0.05, 0.15, 0.25, 0.35, 0.45,
  0.55, 0.65, 0.75, 0.85, 0.95
)
tibble::tibble(   # Output table
  original,
  round_up = round_up(x = original, digits = 1),
  round_down = round_down(x = original, digits = 1),
  base_round = base::round(x = original, digits = 1)
)

# (Note: Defining `original` as `seq(0.05:0.95, by = 0.1)`
# would lead to wrong results unless `original` is rounded
# to 2 or so digits before it's rounded to 1.)
</code></pre>


</div>