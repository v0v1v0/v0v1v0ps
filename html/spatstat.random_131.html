<div class="container">

<table style="width: 100%;"><tr>
<td>rPSNCP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate Product Shot-noise Cox Process</h2>

<h3>Description</h3>

<p>Generate a random multitype point pattern, a realisation of the
product shot-noise Cox process.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> rPSNCP(lambda=rep(100, 4), kappa=rep(25, 4), omega=rep(0.03, 4), 
        alpha=matrix(runif(16, -1, 3), nrow=4, ncol=4), 
        kernels=NULL, nu.ker=NULL, win=owin(), nsim=1, drop=TRUE,
        ...,
        cnames=NULL, epsth=0.001)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>List of intensities of component processes. Either a
numeric vector determining the constant (homogeneous) intensities 
or a list of pixel images (objects of class <code>"im"</code>) determining 
the (inhomogeneous) intensity functions of  component processes. 
The length of <code>lambda</code> determines the number of component processes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>

<p>Numeric vector of intensities of the Poisson process of cluster centres
for component processes. Must have the same size as <code>lambda</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>

<p>Numeric vector of bandwidths of cluster dispersal kernels
for component processes. Must have the same size as <code>lambda</code> 
and <code>kappa</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Matrix of interaction parameters. Square numeric matrix with the same 
number of rows and columns as the length of <code>lambda</code>,
<code>kappa</code> and <code>omega</code>.
All entries of <code>alpha</code> must be greater than -1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernels</code></td>
<td>

<p>Vector of character string determining the cluster dispersal kernels
of component processes. Implemented kernels are Gaussian 
kernel (<code>"Thomas"</code>) with bandwidth <code>omega</code>, 
Variance-Gamma (Bessel) kernel (<code>"VarGamma"</code>) with 
bandwidth <code>omega</code> and shape parameter <code>nu.ker</code> 
and Cauchy kernel (<code>"Cauchy"</code>) with bandwidth <code>omega</code>.
Must have the same length as <code>lambda</code>, <code>kappa</code> and <code>omega</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.ker</code></td>
<td>

<p>Numeric vector of bandwidths of shape parameters for Variance-Gamma
kernels. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cnames</code></td>
<td>

<p>Optional vector of character strings giving the names of
the component processes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Optional arguments passed to <code>as.mask</code>
to determine the pixel array geometry.
See <code>as.mask</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsth</code></td>
<td>

<p>Numerical threshold to determine the maximum interaction range for 
cluster kernels.


</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates a realisation of a product shot-noise Cox
process (PSNCP). This is a multitype (multivariate) Cox point process 
in which each element of the multivariate random intensity
<code class="reqn">\Lambda(u)</code> 
of the process is obtained by 
</p>
<p style="text-align: center;"><code class="reqn">
    \Lambda_i(u) = \lambda_i(u) S_i(u) \prod_{j \neq i} E_{ji}(u)
  </code>
</p>

<p>where <code class="reqn">\lambda_i(u)</code> is the intensity
of component <code class="reqn">i</code> of the process,
</p>
<p style="text-align: center;"><code class="reqn">
    S_i(u) = \frac{1}{\kappa_{i}} \sum_{v \in \Phi_i} k_{i}(u - v)
  </code>
</p>

<p>is the shot-noise random field for component <code class="reqn">i</code> and 
</p>
<p style="text-align: center;"><code class="reqn">
      E_{ji}(u) = \exp(-\kappa_{j} \alpha_{ji} / k_{j}(0)) \prod_{v \in \Phi_{j}} {1 + \alpha_{ji} \frac{k_j(u-v)}{k_j(0)}}
    </code>
</p>

<p>is a product field controlling impulses from the parent Poisson process 
<code class="reqn">\Phi_j</code> with constant intensity <code class="reqn">\kappa_j</code> of 
component process <code class="reqn">j</code> on <code class="reqn">\Lambda_i(u)</code>.
Here <code class="reqn">k_i(u)</code> is an isotropic kernel (probability
density) function on <code class="reqn">R^2</code> with bandwidth <code class="reqn">\omega_i</code> and 
shape parameter <code class="reqn">\nu_i</code>,
and <code class="reqn">\alpha_{ji}&gt;-1</code> is the interaction parameter.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>, or a
list of point patterns if <code>nsim &gt; 1</code>.  Each point pattern is
multitype (it carries a vector of marks which is a factor).
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian.
Modified by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Jalilian, A., Guan, Y., Mateu, J. and Waagepetersen, R. (2015)
Multivariate product-shot-noise Cox point process models. 
<em>Biometrics</em>  <b>71</b>(4), 1022â€“1033.
</p>


<h3>See Also</h3>

<p><code>rmpoispp</code>,
<code>rThomas</code>,
<code>rVarGamma</code>,
<code>rCauchy</code>,
<code>rNeymanScott</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  online &lt;- interactive()
  # Example 1: homogeneous components
  lambda &lt;- c(250, 300, 180, 400)
  kappa &lt;- c(30, 25, 20, 25)
  omega &lt;- c(0.02, 0.025, 0.03, 0.02)
  alpha &lt;- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  if(!online) {
     lambda &lt;- lambda[1:2]/10
     kappa  &lt;- kappa[1:2]
     omega  &lt;- omega[1:2]
     alpha  &lt;- alpha[1:2, 1:2]
  }
  X &lt;- rPSNCP(lambda, kappa, omega, alpha)
  if(online) {
    plot(X)
    plot(split(X))
  }

  #Example 2: inhomogeneous components
  z1 &lt;- scaletointerval.im(bei.extra$elev, from=0, to=1)
  z2 &lt;- scaletointerval.im(bei.extra$grad, from=0, to=1)
  if(!online) {
    ## reduce resolution to reduce check time
    z1 &lt;- as.im(z1, dimyx=c(40,80))
    z2 &lt;- as.im(z2, dimyx=c(40,80))
  } 
  lambda &lt;- list(
         exp(-8 + 1.5 * z1 + 0.5 * z2),
         exp(-7.25 + 1 * z1  - 1.5 * z2),
         exp(-6 - 1.5 * z1 + 0.5 * z2),
         exp(-7.5 + 2 * z1 - 3 * z2))
  kappa &lt;- c(35, 30, 20, 25) / (1000 * 500)
  omega &lt;- c(15, 35, 40, 25)
  alpha &lt;- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  if(!online) {
     lambda &lt;- lapply(lambda[1:2], "/", e2=10)
     kappa  &lt;- kappa[1:2]
     omega  &lt;- omega[1:2]
     alpha  &lt;- alpha[1:2, 1:2]
  } else {
     sapply(lambda, integral)
  }
  X &lt;- rPSNCP(lambda, kappa, omega, alpha, win = Window(bei), dimyx=dim(z1))
  if(online) {
    plot(X)
    plot(split(X), cex=0.5)
  }
</code></pre>


</div>