<div class="container">

<table style="width: 100%;"><tr>
<td>subsetFun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter results by function</h2>

<h3>Description</h3>

<p>Create a SQM object containing only the ORFs with a given function, and the contigs and bins that contain them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">subsetFun(
  SQM,
  fun,
  columns = NULL,
  ignore_case = TRUE,
  fixed = FALSE,
  trusted_functions_only = FALSE,
  ignore_unclassified_functions = FALSE,
  rescale_tpm = FALSE,
  rescale_copy_number = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SQM</code></td>
<td>
<p>SQM object to be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>character. Pattern to search for in the different functional classifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p>character. Restrict the search to the provided column names from <code>SQM$orfs$table</code>. If not provided the search will be performed in all the columns containing functional information (default <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_case</code></td>
<td>
<p>logical Make pattern matching case-insensitive (default <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>logical. If <code>TRUE</code>, pattern is a string to be matched as is. If <code>FALSE</code> the pattern is treated as a regular expression (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trusted_functions_only</code></td>
<td>
<p>logical. If <code>TRUE</code>, only highly trusted functional annotations (best hit + best average) will be considered when generating aggregated function tables. If <code>FALSE</code>, best hit annotations will be used (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unclassified_functions</code></td>
<td>
<p>logical. If <code>FALSE</code>, ORFs with no functional classification will be aggregated together into an "Unclassified" category. If <code>TRUE</code>, they will be ignored (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_tpm</code></td>
<td>
<p>logical. If <code>TRUE</code>, TPMs for KEGGs, COGs, and PFAMs will be recalculated (so that the TPMs in the subset actually add up to 1 million). Otherwise, per-function TPMs will be calculated by aggregating the TPMs of the ORFs annotated with that function, and will thus keep the scaling present in the parent object (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_copy_number</code></td>
<td>
<p>logical. If <code>TRUE</code>, copy numbers with be recalculated using the RecA/RadA coverages in the subset. Otherwise, RecA/RadA coverages will be taken from the parent object. By default it is set to <code>FALSE</code>, which means that the returned copy numbers for each function will represent the average copy number of that function per genome in the parent object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>SQM object containing only the requested function.
</p>


<h3>See Also</h3>

<p><code>subsetTax</code>, <code>subsetORFs</code>, <code>subsetSamples</code>, <code>combineSQM</code>. The most abundant items of a particular table contained in a SQM object can be selected with <code>mostAbundant</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Hadza)
Hadza.iron = subsetFun(Hadza, "iron")
Hadza.carb = subsetFun(Hadza, "Carbohydrate metabolism")
# Search for multiple patterns using regular expressions
Hadza.twoKOs = subsetFun(Hadza, "K00812|K00813", fixed=FALSE)
</code></pre>


</div>