<div class="container">

<table style="width: 100%;"><tr>
<td>Kscaled</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Locally Scaled K-function</h2>

<h3>Description</h3>

<p>Estimates the locally-rescaled <code class="reqn">K</code>-function of
a point process.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  Kscaled(X, lambda=NULL, ..., r = NULL, breaks = NULL,
    rmax = 2.5, 
    correction=c("border", "isotropic", "translate"),
    renormalise=FALSE, normpower=1,
    sigma=NULL, varcov=NULL)

  Lscaled(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the locally scaled <code class="reqn">K</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location,
or a fitted point process model (object of class <code>"ppm"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed from <code>Lscaled</code> to <code>Kscaled</code>
and from <code>Kscaled</code> to <code>density.ppp</code>
if <code>lambda</code> is omitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the locally scaled <code class="reqn">K</code> function
should be evaluated. (These are rescaled distances.)
Not normally given by the user; there is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmax</code></td>
<td>

<p>maximum value of the argument <code class="reqn">r</code> that should be used.
(This is the rescaled distance).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, 
<code>"isotropic"</code>, <code>"Ripley"</code>,
<code>"translate"</code>, <code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>renormalise</code></td>
<td>

<p>Logical. Whether to renormalise the estimate. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma,varcov</code></td>
<td>

<p>Optional arguments passed to  <code>density.ppp</code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Kscaled</code> computes an estimate of the <code class="reqn">K</code> function
for a locally scaled point process.
<code>Lscaled</code> computes the corresponding <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>
<p>Locally scaled point processes are a class of models
for inhomogeneous point patterns, introduced by Hahn et al (2003).
They include inhomogeneous Poisson processes, and many other models.
</p>
<p>The template <code class="reqn">K</code> function of a locally-scaled process is a counterpart
of the “ordinary” Ripley <code class="reqn">K</code> function, in which
the distances between points of the process are measured
on a spatially-varying scale (such that the locally rescaled
process has unit intensity).
</p>
<p>The template <code class="reqn">K</code> function is an indicator of interaction
between the points. For an inhomogeneous Poisson process, the
theoretical template <code class="reqn">K</code> function is approximately equal
to <code class="reqn">K(r) = \pi r^2</code>.
Values <code class="reqn">K_{\rm scaled}(r) &gt; \pi r^2</code>
are suggestive of clustering.
</p>
<p><code>Kscaled</code> computes an estimate of the template <code class="reqn">K</code> function
and <code>Lscaled</code> computes the corresponding <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>.
</p>
<p>The locally scaled interpoint distances are computed
using an approximation proposed by Hahn (2007). The Euclidean
distance between two points is multiplied by the average of the
square roots of the intensity values at the two points.
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>.
It may be either
</p>

<dl>
<dt>a numeric vector</dt>
<dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt>
<dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a function</dt>
<dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt>
<dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother.
</p>
</dd>
</dl>
<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code>blur</code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother,
as described in Baddeley, Moller
and Waagepetersen (2000).  The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code>density.ppp</code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code>density.ppp</code> along with any extra arguments.
</p>
<p>If <code>renormalise=TRUE</code>, the estimated intensity <code>lambda</code>
is multiplied by <code class="reqn">c^(normpower/2)</code> before performing other calculations,
where <code class="reqn">c = area(W)/sum[i] (1/lambda(x[i]))</code>. This 
renormalisation has about the same effect as in <code>Kinhom</code>,
reducing the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
</p>
<p>Edge corrections are used to correct bias in the estimation
of <code class="reqn">K_{\rm scaled}</code>. First the interpoint distances are 
rescaled, and then edge corrections are applied as in <code>Kest</code>.
See <code>Kest</code> for details of the edge corrections
and the options for the argument <code>correction</code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kscaled</code>; see <code>pcf</code> and <code>pcf.fv</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code>fv.object</code>).
</p>
<p>Essentially a data frame containing at least the following columns,
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the pair correlation function <code class="reqn">g(r)</code> has been  estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>vector of values of <code class="reqn">\pi r^2</code>,
the theoretical value of <code class="reqn">K_{\rm scaled}(r)</code>
for an inhomogeneous Poisson process
</p>
</td>
</tr>
</table>
<p>and containing additional columns
according to the choice specified in the <code>correction</code>
argument. The additional columns are named
<code>border</code>, <code>trans</code> and <code>iso</code>
and give the estimated values of 
<code class="reqn">K_{\rm scaled}(r)</code>
using the border correction, translation correction,
and Ripley isotropic correction, respectively.
</p>


<h3>Author(s)</h3>

<p>Ute Hahn,
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.,
Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329–350.
</p>
<p>Hahn, U. (2007)
<em>Global and Local Scaling in the
Statistics of Spatial Point Processes</em>. Habilitationsschrift,
Universitaet Augsburg.
</p>
<p>Hahn, U., Jensen, E.B.V., van Lieshout, M.N.M. and Nielsen, L.S. (2003)
Inhomogeneous spatial point processes by location-dependent scaling.
<em>Advances in Applied Probability</em> <b>35</b>, 319–336.
</p>
<p>Prokesova, M.,
Hahn, U. and Vedel Jensen, E.B. (2006)
Statistics for locally scaled point patterns.
In A. Baddeley, P. Gregori, J. Mateu, R. Stoica and D. Stoyan (eds.)
<em>Case Studies in Spatial Point Pattern Modelling</em>.
Lecture Notes in Statistics 185. New York: Springer Verlag.
Pages 99–123.
</p>


<h3>See Also</h3>

<p><code>Kest</code>,
<code>pcf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  X &lt;- unmark(bronzefilter)
  K &lt;- Kscaled(X)
  if(require("spatstat.model")) {
    fit &lt;- ppm(X, ~x)
    lam &lt;- predict(fit)
    K &lt;- Kscaled(X, lam)
  }
</code></pre>


</div>