<div class="container">

<table style="width: 100%;"><tr>
<td>sparsegl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularization paths for sparse group-lasso models</h2>

<h3>Description</h3>

<p>Fits regularization paths for sparse group-lasso penalized learning problems at a
sequence of regularization parameters <code>lambda</code>.
Note that the objective function for least squares is
</p>
<p style="text-align: center;"><code class="reqn">RSS/(2n) + \lambda penalty</code>
</p>

<p>Users can also tweak the penalty by choosing a different penalty factor.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sparsegl(
  x,
  y,
  group = NULL,
  family = c("gaussian", "binomial"),
  nlambda = 100,
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  pf_group = sqrt(bs),
  pf_sparse = rep(1, nvars),
  intercept = TRUE,
  asparse = 0.05,
  standardize = TRUE,
  lower_bnd = -Inf,
  upper_bnd = Inf,
  weights = NULL,
  offset = NULL,
  warm = NULL,
  trace_it = 0,
  dfmax = as.integer(max(group)) + 1L,
  pmax = min(dfmax * 1.2, as.integer(max(group))),
  eps = 1e-08,
  maxit = 3e+06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Double. A matrix of predictors, of dimension
<code class="reqn">n \times p</code>; each row
is a vector of measurements and each column is a feature. Objects of class
<code>Matrix::sparseMatrix</code> are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Double/Integer/Factor. The response variable.
Quantitative for <code>family="gaussian"</code> and for other exponential families.
If <code>family="binomial"</code> should be either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Character or function. Specifies the generalized linear model
to use. Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code> - least squares loss (regression, the default),
</p>
</li>
<li> <p><code>"binomial"</code> - logistic loss (classification)
</p>
</li>
</ul>
<p>For any other type, a valid <code>stats::family()</code> object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, <code>family = "gaussian"</code> and
<code>family = gaussian()</code> will produce the same results, but the first
will be much faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.factor</code></td>
<td>
<p>A multiplicative factor for the minimal lambda in the
<code>lambda</code> sequence, where <code>min(lambda) = lambda.factor * max(lambda)</code>.
<code>max(lambda)</code> is the smallest value of <code>lambda</code> for which all coefficients
are zero. The default depends on the relationship between <code class="reqn">n</code>
(the number of rows in the matrix of predictors) and <code class="reqn">p</code>
(the number of predictors). If <code class="reqn">n \geq p</code>, the
default is <code>0.0001</code>.  If <code class="reqn">n &lt; p</code>, the default is <code>0.01</code>.
A very small value of <code>lambda.factor</code> will lead to a
saturated fit. This argument has no effect if there is user-defined
<code>lambda</code> sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence. The default, <code>NULL</code>
results in an automatic computation based on <code>nlambda</code>, the smallest value
of <code>lambda</code> that would give the null model (all coefficient estimates equal
to zero), and <code>lambda.factor</code>. Supplying a value of <code>lambda</code> overrides
this behaviour. It is likely better to supply a
decreasing sequence of <code>lambda</code> values than a single (small) value. If
supplied, the user-defined <code>lambda</code> sequence is automatically sorted in
decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf_group</code></td>
<td>
<p>Penalty factor on the groups, a vector of the same
length as the total number of groups. Separate penalty weights can be applied
to each group of <code class="reqn">\beta</code>s to allow differential shrinkage.
Can be 0 for some
groups, which implies no shrinkage, and results in that group always being
included in the model (depending on <code>pf_sparse</code>). Default value for each
entry is the square-root of the corresponding size of each group.
Because this default is typical, these penalties are not rescaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf_sparse</code></td>
<td>
<p>Penalty factor on l1-norm, a vector the same length as the
total number of columns in <code>x</code>. Each value corresponds to one predictor
Can be 0 for some predictors, which
implies that predictor will be receive only the group penalty.
Note that these are internally rescaled so that the sum is the same as
the number of predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Whether to include intercept in the model. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asparse</code></td>
<td>
<p>The relative weight to put on the <code class="reqn">\ell_1</code>-norm in
sparse group lasso. Default is <code>0.05</code> (resulting in <code>0.95</code> on the
<code class="reqn">\ell_2</code>-norm).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for variable standardization (scaling) prior
to fitting the model. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower_bnd</code></td>
<td>
<p>Lower bound for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-positive numbers only.
Default value for each entry is <code>-Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_bnd</code></td>
<td>
<p>Upper for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-negative numbers only.
Default value for each entry is <code>Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Double vector. Optional observation weights. These can
only be used with a <code>stats::family()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
<code>stats::family()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm</code></td>
<td>
<p>List created with <code>make_irls_warmup()</code>. These can only be used
with a <code>stats::family()</code> object, and is not typically necessary even then.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace_it</code></td>
<td>
<p>Scalar integer. Larger values print more output during
the irls loop. Typical values are <code>0</code> (no printing), <code>1</code> (some printing
and a progress bar), and <code>2</code> (more detailed printing).
These can only be used with a <code>stats::family()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmax</code></td>
<td>
<p>Limit the maximum number of groups in the model. Default is
no limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>
<p>Limit the maximum number of groups ever to be nonzero. For
example once a group enters the model, no matter how many times it exits or
re-enters model through the path, it will be counted only once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence termination tolerance. Defaults value is <code>1e-8</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of outer-loop iterations allowed at fixed lambda
value. Default is <code>3e8</code>. If models do not converge, consider increasing
<code>maxit</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with S3 class <code>"sparsegl"</code>. Among the list components:
</p>

<ul>
<li> <p><code>call</code> The call that produced this object.
</p>
</li>
<li> <p><code>b0</code> Intercept sequence of length <code>length(lambda)</code>.
</p>
</li>
<li> <p><code>beta</code> A <code>p</code> x <code>length(lambda)</code> sparse matrix of coefficients.
</p>
</li>
<li> <p><code>df</code> The number of features with nonzero coefficients for each value of
<code>lambda</code>.
</p>
</li>
<li> <p><code>dim</code> Dimension of coefficient matrix.
</p>
</li>
<li> <p><code>lambda</code> The actual sequence of <code>lambda</code> values used.
</p>
</li>
<li> <p><code>npasses</code> Total number of iterations summed over all <code>lambda</code> values.
</p>
</li>
<li> <p><code>jerr</code> Error flag, for warnings and errors, 0 if no error.
</p>
</li>
<li> <p><code>group</code> A vector of consecutive integers describing the grouping of the
coefficients.
</p>
</li>
<li> <p><code>nobs</code> The number of observations used to estimate the model.
</p>
</li>
</ul>
<p>If <code>sparsegl()</code> was called with a <code>stats::family()</code> method, this may also
contain information about the deviance and the family used in fitting.
</p>


<h3>References</h3>

<p>Liang, X., Cohen, A., SÃ³lon Heinsfeld, A., Pestilli, F., and
McDonald, D.J. 2024.
<em>sparsegl: An <code>R</code> Package for Estimating Sparse Group Lasso.</em>
Journal of Statistical Software, Vol. 110(6): 1â23.
<a href="https://doi.org/10.18637/jss.v110.i06">doi:10.18637/jss.v110.i06</a>.
</p>


<h3>See Also</h3>

<p><code>cv.sparsegl()</code> and the <code>plot()</code>,
<code>predict()</code>, and <code>coef()</code>
methods for <code>"sparsegl"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit &lt;- sparsegl(X, y, group = groups)

yp &lt;- rpois(n, abs(X %*% beta_star))
fit_pois &lt;- sparsegl(X, yp, group = groups, family = poisson())
</code></pre>


</div>