<div class="container">

<table style="width: 100%;"><tr>
<td>sarima</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit extended SARIMA models</h2>

<h3>Description</h3>

<p>Fit extended SARIMA models, which can include lagged exogeneous
variables, general unit root non-stationary factors, multiple
periodicities, and multiplicative terms in the SARIMA
specification. The models are specified with a flexible formula syntax
and contain as special cases many models with specialised names, such
as ARMAX and reg-ARIMA.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sarima(model, data = NULL, ss.method = "sarima", use.symmetry = FALSE, 
       SSinit = "Rossignol2011")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model formula specifying the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list or data frame, usually can be omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ss.method</code></td>
<td>
<p>state space engine to use, defaults to
<code>"sarima"</code>. (<strong>Note:</strong> this argument will
probably be renamed.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.symmetry</code></td>
<td>
<p>a logical argument indicating whether 
symmetry should be used to estimate the unit polynomial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSinit</code></td>
<td>
<p>method to use for computation of the stationary part of
the initial covariance matrix, one of "Rossignol2011", "gnb",
"Gardner1980".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sarima</code> fits extended SARIMA models, which can include
exogeneous variables, general unit root non-stationary factors and
multiplicative terms in the SARIMA specification.
</p>
<p>Let <code class="reqn">\{Y_t\}</code> be a time series and <code class="reqn">f(t)</code> and <code class="reqn">g(t)</code> be
functions of time and/or (possibly lagged) exogeneous variables.
</p>
<p>An extended pure SARIMA model for <code class="reqn">Y_t</code> can be written with the
help of the backward shift operator as
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">\{\varepsilon_t\}</code> is white noise, and 
<code class="reqn">U(z)</code>, <code class="reqn">\Phi(z)</code>, and <code class="reqn">\Theta(z)</code> are polynomials,
such that all roots of <code class="reqn">U(z)</code> are on the unit circle, while the
roots of <code class="reqn">\Phi(z)</code> and <code class="reqn">\Theta(z)</code> are outside the unit
circle. If unit roots are missing, ie <code class="reqn">U(z)\equiv 1</code>, the
model is stationary with mean zero.
</p>
<p>A reg-SARIMA or X-SARIMA model can be defined as a regression with
SARIMA residuals: 
</p>
<p style="text-align: center;"><code class="reqn">Y_t = f(t) + Y^c_t</code>
</p>

<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y^c_t = \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">Y^c_t = Y_t - f(t)</code> is the centred <code class="reqn">Y_t</code>.
This can be written equivalently as a single equation:
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)(Y_t - f(t)) = \Theta(B)\varepsilon_t.</code>
</p>

<p>The regression function <code class="reqn">f(t)</code> can depend on
time and/or (possibly lagged) exogeneous variables.  We call it
centering function. If <code class="reqn">Y^c_t</code> is stationary with mean zero,
<code>f(t)</code> is the mean of <code class="reqn">Y_t</code>. If <code>f(t)</code> is constant, say
<code>mu</code>, <code class="reqn">Y_t</code> is stationary with mean <code>mu</code>. Note that the
two-equation form above shows that in that case <code>mu</code> is the
intercept in the first equation, so it is perfectly reasonable to
refer to it also as intercept but to avoid confusion we reserve
the term <strong>intercept</strong> for  <code>g(t)</code> below.
</p>
<p>If the SARIMA part is stationary, then <code class="reqn">EY_t = f(t)</code>, so
<code class="reqn">f(t)</code> can be interpreted as trend. In this case the above
specification is often referred to as <strong>mean corrected form</strong> of
the model. 
</p>
<p>An alternative way to specify the regression part is to add the
regression function, say <code class="reqn">\{g(t)\}</code>, to the right-hand side of the SARIMA
equation:
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = g(t) + \Theta(B)\varepsilon_t.</code>
</p>

<p>In the stationary case this is the classical ARMAX specification. 
This can be written in two-stage form in various ways, eg
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = (1 - \Theta(B))\varepsilon_t + u_t,</code>
</p>

<p style="text-align: center;"><code class="reqn">u_t = g(t) + \varepsilon_t .</code>
</p>

<p>So, in a sense, g(t) is a trend associated with the residuals from the
SARIMA modelling. We refer to this form as intercept form of the
model (as opposed to the mean-corrected form discussed previously). 
</p>
<p>In general, if there are no exogeneous variables the mean-corrected
model is equivalent to some intercept model, which gives some
justification of the terminology, as well. If there are exogeneous
variables equivalence may be achievable but at the expense of
introducing more lags in the model, whish is not desirable in general.
</p>
<p>Some examples of equivalence. Let Y be a stationary SARIMA
process (<code class="reqn">U(z)=1</code>) with mean <code class="reqn">\mu</code>. Then the
mean-corrected form of the SARIMA model is 
</p>
<p style="text-align: center;"><code class="reqn">\Phi(B)(Y_t - \mu) = \Theta(B)\varepsilon_t,</code>
</p>

<p>while the intercept form is
</p>
<p style="text-align: center;"><code class="reqn">\Phi(B)Y_t = c + \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">c = \Phi(B)\mu</code>. So, in this case the mean-corrected model
X-SARIMA model with <code class="reqn">f(t) = \mu</code> is equivalent to the
intercept model with <code class="reqn">g(t) = \Phi(B)\mu</code>.
</p>
<p>As another example, with <code class="reqn">f(t) = bt</code>, the mean-corrected model is
<code class="reqn">(1-B)(Y_t - bt) = \varepsilon_t</code>. Expanding the left-hand side
we obtain the intercept form  <code class="reqn">(1-B)Y_t = b + \varepsilon_t</code>,
which demonstrates that <code class="reqn">Y_t</code> is a random walk with drift <code class="reqn">g(t) = b</code>. 
</p>
<p><strong>Model specification</strong>
</p>
<p>Argument <code>model</code> specifies the model with a syntax similar to
other model fitting functions in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.  A formula can be given for each
of the components discussed above as <code>y ~ f | SARIMA | g</code>, where
<code>f</code>, <code>SARIMA</code> and <code>g</code> are model formulas giving the
specifications for the centering function <code>f</code>, the <code>SARIMA</code>
specification, and the intercept function <code>g</code>.  In normal use
only one of <code>f</code> or <code>g</code> will be different from zero. <code>f</code>
should always be given (use <code>0</code> to specify that it is identical
to zero), but <code>g</code> can be omitted altogether.  Sometimes we refer
to the terms specified by <code>f</code> and <code>g</code> by <code>xreg</code> and
<code>regx</code>, respectively.
</p>
<p><strong>Model formulas for trends and exogeneous regressions</strong>

</p>
<p>The formulas for the centering and intercept (ie <code>f</code> and
<code>g</code>) use the same syntax as in linear models with some additional
functions for trigonometric trends, polynomial trends and lagged
variables.
</p>
<p>Here are the available specialised terms:
</p>

<dl>
<dt>.p(d)</dt>
<dd>
<p>Orthogonal polynomials over <code>1:length(y)</code> of degree d
(starting from degree 1, no constant).
</p>
</dd>
<dt>t</dt>
<dd>
<p>Stands for <code>1:length(y)</code>. Note that powers need to be
protected by I(), e.g. <code>y ~ 1 + .t + I(.t^2)</code>.
</p>
</dd>
<dt>.cs(s, k)</dt>
<dd>
<p>cos/sin pair for the k-th harmonic of 2pi/s. Use vector k to
specify several harmonics.
</p>
</dd>
<dt>.B(x, lags)</dt>
<dd>
<p>Include lagged terms of x, <code class="reqn">B^{lags}(x[t]) = x[t - lags]</code>.
<code>lags</code> can be a vector.
If <code>x</code> is a matrix, the specified lags are taken from each
column. 
</p>
</dd>
</dl>
<p><strong>Model formulas for SARIMA models</strong>
</p>
<p>A flexible syntax is provided for the specification of the SARIMA part
of the model.  It is formed using a number of primitives for
stationary and unit root components, which have 
non-seasonal and seasonal variants. Arbitrary number of multiplicative
factors and multiple seasonalities can be specified.  
</p>
<p>The SARIMA part of the model can contain any of the following
terms. They can be repeated as needed. The first argument for all
seasonal operators is the number of seasons. 
</p>

<dl>
<dt>ar(p)</dt>
<dd>
<p>autoregression term of order p</p>
</dd>
<dt>ma(q)</dt>
<dd>
<p>moving average term of order q</p>
</dd>
<dt>sar(s,p)</dt>
<dd>
<p>seasonal autoregression term (s seasons, order p)</p>
</dd>
<dt>sma(s,q)</dt>
<dd>
<p>seasonal moving average term (s seasons, order q)</p>
</dd>
<dt>i(d)</dt>
<dd>
<p><code class="reqn">(1-B)^d</code></p>
</dd>
<dt>s(seas)</dt>
<dd>
<p>summation operator,
<code class="reqn">(1 + B + \cdots + B^{seas -1})</code>
</p>
</dd>
<dt>u(x)</dt>
<dd>
<p>quadratic unit root term, corresponding to a complex pair on the
unit circle. If <code class="reqn">x</code> is real, it specifies the argument of one
of the roots as a fraction of <code class="reqn">2\pi</code>. If <code class="reqn">z</code> is
complex, it is the root itself.
</p>
<p>The real roots of modulus one (1 and <code class="reqn">-1</code>) should be specified
using <code>i(1)</code> and <code>s(2)</code>, which correspond to <code class="reqn">1-B</code>
and <code class="reqn">1+B</code>, respectively.
</p>
</dd>
<dt>su(s, h)</dt>
<dd>
<p>quadratic unit root terms corresponding to seasonal
differencing factors. h specifies the desired harmonic which
should be one of 1,2, ..., [s/2]. Several harmonics can be
specified by setting h to a vector. 
</p>
</dd>    
<dt>ss(s, p)</dt>
<dd>
<p>seasonal summation operator,
<code class="reqn">(1 + B^s + \cdots + B^{(s-1)p})</code>
</p>
</dd>
</dl>
<p>Terms with parameters can contain additional arguments specifying
initial values, fixed parameters, and transforms. For <code>ar</code>,
<code>ma</code>, <code>sar</code>, <code>sma</code>, values of the coefficients can be
specified by an unnamed argument after the parameters given in the
descriptions above. In estimation these values will be taken as
initial values for optimisation.  By default, all coefficients are
taken to be non-fixed.
</p>
<p>Argument <code>fixed</code> can be used to fix some of them.  If it is a
logical vector it should be of length one or have the same length as
the coefficients. If <code>fixed</code> is of length one and <code>TRUE</code>, all
coefficients are fixed. If FALSE, all are non-fixed. Otherwise, the
TRUE/FALSE values in <code>fixed</code> determine the fixedness of the
corresponding coefficients.
</p>
<p><code>fixed</code> can also be a vector of positive integer numbers
specifying the indices of fixed coefficients, the rest are non-fixed.
</p>
<p>Sometimes it may be easier to declare more (e.g. all) coefficients as
fixed and then ‘unfix’ selectively. Argument <code>nonfixed</code> can be
used to mark some coefficients as non-fixed after they have been
declared fixed. Its syntax is the same as for <code>fixed</code>.
</p>
<p>TODO: streamline "atanh.tr"
</p>
<p>TODO: describe <code>SSinit</code>
</p>


<h3>Value</h3>

<p>an object from S3 class Sarima
</p>
<p>(<strong>Note:</strong> the format of the object is still under development
and may change; use accessor functions, such as <code>coef()</code>, where provided.)
</p>


<h3>Note</h3>

<p>Currently the implementation of the intercept form (ie the third
part of the model formula) is incomplete. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Halliday J, Boshnakov GN (2022).
“Partial autocorrelation parameterisation of models with unit roots on the unit circle.”
<a href="https://doi.org/10.48550/ARXIV.2208.05055">doi:10.48550/ARXIV.2208.05055</a>, <a href="https://arxiv.org/abs/2208.05055">https://arxiv.org/abs/2208.05055</a>.
</p>


<h3>See Also</h3>

<p><code>arima</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## AirPassengers example
## fit the classic airline model using arima()
ap.arima &lt;- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1))

## same model using two equivalent ways to specify it
ap.baseA &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1), 
                   ss.method = "base")
ap.baseB &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(12), 
                   ss.method = "base")

ap.baseA
summary(ap.baseA)
ap.baseB
summary(ap.baseB)

## as above, but drop 1-B from the model:
ap2.arima &lt;- arima(log(AirPassengers), order = c(0,0,1), seasonal = c(0,1,1))
ap2.baseA &lt;- sarima(log(AirPassengers) ~ 
                    0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) +     si(12,1), 
                    ss.method = "base")
ap2.baseB &lt;- sarima(log(AirPassengers) ~ 
                    0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + s(12), 
                    ss.method = "base")

## for illustration, here the non-stationary part is 
##     (1-B)^2(1+B+...+B^5) = (1-B)(1-B^6)
##     (  compare to (1-B)(1-B^{12}) = (1-B)(1-B^6)(1+B^6) ) 
ap3.base &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(6), 
                   ss.method = "base")

## further unit roots, equivalent specifications for the airline model
tmp.su &lt;- sarima(log(AirPassengers) ~ 
                 0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + su(12,1:5), 
                 ss.method = "base")
tmp.su$interna$delta_poly
prod(tmp.su$interna$delta_poly)
zapsmall(coef(prod(tmp.su$interna$delta_poly)))
tmp.su

tmp.u &lt;- sarima(log(AirPassengers) ~ 
                0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + u((1:5)/12), 
                ss.method = "base")
tmp.u
</code></pre>


</div>