<div class="container">

<table style="width: 100%;"><tr>
<td>sfaselectioncross</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample selection in stochastic frontier estimation using cross-section data</h2>

<h3>Description</h3>

<p><code>sfaselectioncross</code> is a symbolic formula based function for the
estimation of the stochastic frontier model in the presence of sample
selection. The model accommodates cross-sectional or pooled cross-sectional data.
The model can be estimated using different quadrature approaches or
maximum simulated likelihood (MSL). See Greene (2010).
</p>
<p>Only the half-normal distribution is possible for the one-sided error term.
Eleven optimization algorithms are available.
</p>
<p>The function also accounts for heteroscedasticity in both one-sided and
two-sided error terms, as in Reifschneider and Stevenson (1991), Caudill and
Ford (1993), Caudill <em>et al.</em> (1995) and Hadri (1999).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sfaselectioncross(
  selectionF,
  frontierF,
  uhet,
  vhet,
  modelType = "greene10",
  logDepVar = TRUE,
  data,
  subset,
  weights,
  wscale = TRUE,
  S = 1L,
  udist = "hnormal",
  start = NULL,
  method = "bfgs",
  hessianType = 2L,
  lType = "ghermite",
  Nsub = 100,
  uBound = Inf,
  simType = "halton",
  Nsim = 100,
  prime = 2L,
  burn = 10,
  antithetics = FALSE,
  seed = 12345,
  itermax = 2000,
  printInfo = FALSE,
  intol = 1e-06,
  tol = 1e-12,
  gradtol = 1e-06,
  stepmax = 0.1,
  qac = "marquardt"
)

## S3 method for class 'sfaselectioncross'
print(x, ...)

## S3 method for class 'sfaselectioncross'
bread(x, ...)

## S3 method for class 'sfaselectioncross'
estfun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>selectionF</code></td>
<td>
<p>A symbolic (formula) description of the selection equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frontierF</code></td>
<td>
<p>A symbolic (formula) description of the outcome (frontier) equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uhet</code></td>
<td>
<p>A one-part formula to consider heteroscedasticity in the
one-sided error variance (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vhet</code></td>
<td>
<p>A one-part formula to consider heteroscedasticity in the
two-sided error variance (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelType</code></td>
<td>
<p>Character string. Model used to solve the selection bias. Only the
model discussed in Greene (2010) is currently available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logDepVar</code></td>
<td>
<p>Logical. Informs whether the dependent variable is logged
(<code>TRUE</code>) or not (<code>FALSE</code>). Default = <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data frame containing the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the optimization process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of weights to be used for weighted log-likelihood.
Should be <code>NULL</code> or numeric vector with positive values. When <code>NULL</code>,
a numeric vector of 1 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wscale</code></td>
<td>
<p>Logical. When <code>weights</code> is not <code>NULL</code>, a scaling transformation
is used such that the <code>weights</code> sum to the sample size. Default <code>TRUE</code>.
When <code>FALSE</code> no scaling is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>If <code>S = 1</code> (default), a production (profit) frontier is
estimated: <code class="reqn">\epsilon_i = v_i-u_i</code>. If <code>S = -1</code>, a cost frontier is
estimated: <code class="reqn">\epsilon_i = v_i+u_i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>udist</code></td>
<td>
<p>Character string. Distribution specification for the one-sided
error term. Only the half normal distribution <code>'hnormal'</code> is currently
implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Numeric vector. Optional starting values for the maximum
likelihood (ML) estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization algorithm used for the estimation.  Default =
<code>'bfgs'</code>. 11 algorithms are available: </p>
 <ul>
<li> <p><code>'bfgs'</code>,
for Broyden-Fletcher-Goldfarb-Shanno (see
<code>maxBFGS</code>) </p>
</li>
<li> <p><code>'bhhh'</code>, for
Berndt-Hall-Hall-Hausman (see <code>maxBHHH</code>) </p>
</li>
<li>
<p><code>'nr'</code>, for Newton-Raphson (see <code>maxNR</code>)
</p>
</li>
<li> <p><code>'nm'</code>, for Nelder-Mead (see <code>maxNM</code>)
</p>
</li>
<li> <p><code>'cg'</code>, for Conjugate Gradient (see <code>maxCG</code>)
</p>
</li>
<li> <p><code>'sann'</code>, for Simulated Annealing (see <code>maxSANN</code>)
</p>
</li>
<li> <p><code>'ucminf'</code>, for a quasi-Newton type optimization with BFGS updating of the
inverse Hessian and soft line search with a trust region type monitoring of
the input to the line search algorithm (see <code>ucminf</code>)
</p>
</li>
<li> <p><code>'mla'</code>, for general-purpose optimization based on
Marquardt-Levenberg algorithm (see <code>mla</code>)
</p>
</li>
<li> <p><code>'sr1'</code>, for Symmetric Rank 1 (see
<code>trust.optim</code>) </p>
</li>
<li> <p><code>'sparse'</code>, for trust
regions and sparse Hessian (see <code>trust.optim</code>) </p>
</li>
<li>
<p><code>'nlminb'</code>, for optimization using PORT routines (see
<code>nlminb</code>)</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessianType</code></td>
<td>
<p>Integer. If <code>1</code>, analytic Hessian is
returned. If <code>2</code>, bhhh Hessian is estimated (<code class="reqn">g'g</code>). bhhh hessian is
estimated by default as the estimation is conducted in two steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lType</code></td>
<td>
<p>Specifies the way the likelihood is estimated. Five possibilities are
available: <code>kronrod</code> for Gauss-Kronrod quadrature
(see <code>integrate</code>), <code>hcubature</code> and
<code>pcubature</code> for adaptive integration over hypercubes
(see <code>hcubature</code> and
<code>pcubature</code>), <code>ghermite</code> for Gauss-Hermite
quadrature (see <code>gaussHermiteData</code>), and
<code>msl</code> for maximum simulated likelihood. Default <code>ghermite</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsub</code></td>
<td>
<p>Integer. Number of subdivisions/nodes used for quadrature approaches.
Default <code>Nsub = 100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uBound</code></td>
<td>
<p>Numeric. Upper bound for the inefficiency component when solving
integrals using quadrature approaches except Gauss-Hermite for which the upper
bound is automatically infinite (<code>Inf</code>). Default <code>uBound = Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simType</code></td>
<td>
<p>Character string. If <code>simType = 'halton'</code> (Default),
Halton draws are used for maximum simulated likelihood (MSL). If
<code>simType = 'ghalton'</code>, Generalized-Halton draws are used for MSL. If
<code>simType = 'sobol'</code>, Sobol draws are used for MSL. If <code>simType =
'uniform'</code>, uniform draws are used for MSL. (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsim</code></td>
<td>
<p>Number of draws for MSL (default 100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prime</code></td>
<td>
<p>Prime number considered for Halton and Generalized-Halton
draws. Default = <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>Number of the first observations discarded in the case of Halton
draws. Default = <code>10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>antithetics</code></td>
<td>
<p>Logical. Default = <code>FALSE</code>. If <code>TRUE</code>,
antithetics counterpart of the uniform draws is computed. (see section
‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Numeric. Seed for the random draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>Maximum number of iterations allowed for optimization.
Default = <code>2000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printInfo</code></td>
<td>
<p>Logical. Print information during optimization. Default =
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intol</code></td>
<td>
<p>Numeric. Integration tolerance for quadrature approaches
(<code>kronrod, hcubature, pcubature</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric. Convergence tolerance. Default = <code>1e-12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol</code></td>
<td>
<p>Numeric. Convergence tolerance for gradient. Default =
<code>1e-06</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepmax</code></td>
<td>
<p>Numeric. Step max for <code>ucminf</code> algorithm. Default =
<code>0.1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qac</code></td>
<td>
<p>Character. Quadratic Approximation Correction for <code>'bhhh'</code>
and <code>'nr'</code> algorithms. If <code>'stephalving'</code>, the step length is
decreased but the direction is kept. If <code>'marquardt'</code> (default), the
step length is decreased while also moving closer to the pure gradient
direction. See <code>maxBHHH</code> and
<code>maxNR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class sfaselectioncross (returned by the function <code>sfaselectioncross</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments of frontier are passed to sfaselectioncross;
additional arguments of the print, bread, estfun, nobs methods are currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current model is an extension of Heckman (1976, 1979) sample selection model to
nonlinear models particularly stochastic frontier model. The model has first been discussed in
Greene (2010), and an application can be found in Dakpo et al. (2021). Practically, we have:
</p>
<p style="text-align: center;"><code class="reqn">
y_{1i} =  \left\{ \begin{array}{ll}
1 &amp; \mbox{if} \quad y_{1i}^* &gt; 0  \\
0 &amp; \mbox{if} \quad y_{1i}^* \leq 0 \\
\end{array}
\right.
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
y_{1i}^*=\mathbf{Z}_{si}^{\prime} \mathbf{\gamma} + w_i, \quad 
w_i \sim \mathcal{N}(0, 1)
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
y_{2i} =  \left\{ \begin{array}{ll}
y_{2i}^* &amp; \mbox{if} \quad y_{1i}^* &gt; 0  \\
NA &amp; \mbox{if} \quad y_{1i}^* \leq 0 \\
\end{array}
\right.
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
y_{2i}^*=\mathbf{x_{i}^{\prime}} \mathbf{\beta} + v_i - Su_i, \quad 
v_i = \sigma_vV_i \quad \wedge \quad V_i \sim \mathcal{N}(0, 1), \quad 
u_i = \sigma_u|U_i| \quad \wedge \quad U_i \sim \mathcal{N}(0, 1)
</code>
</p>

<p><code class="reqn">y_{1i}</code> describes the selection equation while <code class="reqn">y_{2i}</code> represents
the frontier equation. The selection bias arises from the correlation
between the two symmetric random components <code class="reqn">v_i</code> and <code class="reqn">w_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">
(v_i, w_i) \sim \mathcal{N}_2\left\lbrack(0,0), (1, \rho \sigma_v, \sigma_v^2) \right\rbrack
</code>
</p>

<p>Conditionaly on <code class="reqn">|U_i|</code>, the probability associated to each observation is:
</p>
<p style="text-align: center;"><code class="reqn">
Pr \left\lbrack y_{1i}^* \leq 0 \right\rbrack^{1-y_{1i}} \cdot \left\lbrace 
f(y_{2i}|y_{1i}^* &gt; 0) \times Pr\left\lbrack y_{1i}^* &gt; 0 
\right\rbrack \right\rbrace^{y_{1i}}
</code>
</p>

<p>Using the conditional probability formula:
</p>
<p style="text-align: center;"><code class="reqn">
P\left(A\cap B\right) = P(A) \cdot P(B|A) = P(B) \cdot P(A|B)
</code>
</p>

<p>Therefore:
</p>
<p style="text-align: center;"><code class="reqn">
f(y_{2i}|y_{1i}^* \geq 0) \cdot Pr\left\lbrack y_{1i}^* \geq 0\right\rbrack = 
f(y_{2i}) \cdot Pr(y_{1i}^* \geq 0|y_{2i})
</code>
</p>

<p>Using the properties of a bivariate normal distribution, we have:
</p>
<p style="text-align: center;"><code class="reqn">
y_{i1}^* | y_{i2} \sim N\left(\mathbf{Z_{si}^{\prime}} \bm{\gamma}+\frac{\rho}{
\sigma_v}v_i, 1-\rho^2\right)
</code>
</p>

<p>Hence conditionally on <code class="reqn">|U_i|</code>, we have:
</p>
<p style="text-align: center;"><code class="reqn">
f(y_{2i}|y_{1i}^* \geq 0) \cdot Pr\left\lbrack y_{1i}^* \geq 0\right\rbrack = 
\frac{1}{\sigma_v}\phi\left(\frac{v_i}{\sigma_v}\right)\Phi\left(\frac{
\mathbf{Z_{si}^{\prime}} \bm{\gamma}+\frac{\rho}{\sigma_v}v_i}{
\sqrt{1-\rho^2}}\right)
</code>
</p>

<p>The conditional likelihood is equal to:
</p>
<p style="text-align: center;"><code class="reqn">
L_i\big||U_i| = \Phi(-\mathbf{Z_{si}^{\prime}} \bm{\gamma})^{1-y_{1i}} \times 
\left\lbrace \frac{1}{\sigma_v}\phi\left(\frac{y_{2i}-\mathbf{x_{i}^{\prime}} 
\bm{\beta} + S\sigma_u|U_i|}{\sigma_v}\right)\Phi\left(\frac{
\mathbf{Z_{si}^{\prime}} \bm{\gamma}+\frac{\rho}{\sigma_v}\left(y_{2i}-
\mathbf{x_{i}^{\prime}} \bm{\beta} + S\sigma_u|U_i|\right)}{\sqrt{1-\rho^2}}
\right) \right\rbrace ^{y_{1i}}
</code>
</p>

<p>Since the non-selected observations bring no additional information,
the conditional likelihood to be considered is:
</p>
<p style="text-align: center;"><code class="reqn">
L_i\big||U_i| = \frac{1}{\sigma_v}\phi\left(\frac{y_{2i}-\mathbf{x_{i}^{\prime}} 
\bm{\beta} + S\sigma_u|U_i|}{\sigma_v}\right) \Phi\left(\frac{\mathbf{Z_{si}^{\prime}} 
\bm{\gamma}+\frac{\rho}{\sigma_v}\left(y_{2i}-\mathbf{x_{i}^{\prime}} \bm{\beta} + 
S\sigma_u|U_i|\right)}{\sqrt{1-\rho^2}}\right) 
</code>
</p>

<p>The unconditional likelihood is obtained by integrating <code class="reqn">|U_i|</code> out of the conditional likelihood. Thus
</p>
<p style="text-align: center;"><code class="reqn">
L_i\\ = \int_{|U_i|} \frac{1}{\sigma_v}\phi\left(\frac{y_{2i}-\mathbf{x_{i}^{\prime}} 
\bm{\beta} + S\sigma_u|U_i|}{\sigma_v}\right) \Phi\left(\frac{\mathbf{Z_{si}^{\prime}} 
\bm{\gamma}+ \frac{\rho}{\sigma_v}\left(y_{2i}-\mathbf{x_{i}^{\prime}} \bm{\beta} + 
S\sigma_u|U_i|\right)}{\sqrt{1-\rho^2}}\right)p\left(|U_i|\right)d|U_i|
</code>
</p>

<p>To simplifiy the estimation, the likelihood can be estimated using a two-step approach.
In the first step, the probit model can be run and estimate of <code class="reqn">\gamma</code> can be obtained.
Then, in the second step, the following model is estimated:
</p>
<p style="text-align: center;"><code class="reqn">
L_i\\ = \int_{|U_i|} \frac{1}{\sigma_v}\phi\left(\frac{y_{2i}-\mathbf{x_{i}^{\prime}} 
\bm{\beta} + S\sigma_u|U_i|}{\sigma_v}\right) \Phi\left(\frac{a_i + 
\frac{\rho}{\sigma_v}\left(y_{2i}-\mathbf{x_{i}^{\prime}} \bm{\beta} + 
S\sigma_u|U_i|\right)}{\sqrt{1-\rho^2}}\right)p\left(|U_i|\right)d|U_i| 
</code>
</p>

<p>where <code class="reqn">a_i = \mathbf{Z_{si}^{\prime}} \hat{\bm{\gamma}}</code>. This likelihood can be estimated using
five different approaches: Gauss-Kronrod quadrature, adaptive integration over hypercubes
(hcubature and pcubature), Gauss-Hermite quadrature, and
maximum simulated likelihood. We also use the BHHH estimator to obtain
the asymptotic standard errors for the parameter estimators.
</p>
<p><code>sfaselectioncross</code> allows for the maximization of weighted log-likelihood.
When option <code>weights</code> is specified and <code>wscale = TRUE</code>, the weights
are scaled as:
</p>
<p style="text-align: center;"><code class="reqn">
new_{weights} = sample_{size} \times \frac{old_{weights}}{\sum(old_{weights})}
</code>
</p>

<p>For complex problems, non-gradient methods (e.g. <code>nm</code> or <code>sann</code>) can be
used to warm start the optimization and zoom in the neighborhood of the
solution. Then a gradient-based methods is recommended in the second step. In the case
of <code>sann</code>, we recommend to significantly increase the iteration limit
(e.g. <code>itermax = 20000</code>). The Conjugate Gradient (<code>cg</code>) can also be used
in the first stage.
</p>
<p>A set of extractor functions for fitted model objects is available for objects of class
<code>'sfaselectioncross'</code> including methods to the generic functions <code>print</code>,
<code>summary</code>, <code>coef</code>,
<code>fitted</code>, <code>logLik</code>,
<code>residuals</code>, <code>vcov</code>,
<code>efficiencies</code>, <code>ic</code>,
<code>marginal</code>,
<code>estfun</code> and
<code>bread</code> (from the <a href="https://CRAN.R-project.org/package=sandwich"><span class="pkg">sandwich</span></a> package),
<code>lmtest::coeftest()</code> (from the <a href="https://CRAN.R-project.org/package=lmtest"><span class="pkg">lmtest</span></a> package).
</p>


<h3>Value</h3>

<p><code>sfaselectioncross</code> returns a list of class <code>'sfaselectioncross'</code>
containing the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectionF</code></td>
<td>
<p>The selection equation formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frontierF</code></td>
<td>
<p>The frontier equation formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>The argument <code>'S'</code>. See the section ‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeSfa</code></td>
<td>
<p>Character string. 'Stochastic Production/Profit Frontier, e =
v - u' when <code>S = 1</code> and 'Stochastic Cost Frontier, e = v + u' when
<code>S = -1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ninit</code></td>
<td>
<p>Number of initial observations in all samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nobs</code></td>
<td>
<p>Number of observations used for optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nXvar</code></td>
<td>
<p>Number of explanatory variables in the production or cost
frontier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logDepVar</code></td>
<td>
<p>The argument <code>'logDepVar'</code>. See the section
‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nuZUvar</code></td>
<td>
<p>Number of variables explaining heteroscedasticity in the
one-sided error term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvZVvar</code></td>
<td>
<p>Number of variables explaining heteroscedasticity in the
two-sided error term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nParm</code></td>
<td>
<p>Total number of parameters estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>udist</code></td>
<td>
<p>The argument <code>'udist'</code>. See the section
‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startVal</code></td>
<td>
<p>Numeric vector. Starting value for M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataTable</code></td>
<td>
<p>A data frame (tibble format) containing information on data
used for optimization along with residuals and fitted values of the OLS and
M(S)L estimations, and the individual observation log-likelihood. When argument <code>weights</code>
is specified, an additional variable is provided in <code>dataTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpmObj</code></td>
<td>
<p>Linear probability model used for initializing the first step
probit model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probitObj</code></td>
<td>
<p>Probit model. Object of class <code>'maxLik'</code> and <code>'maxim'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepParam</code></td>
<td>
<p>Numeric vector. OLS second step estimates for
selection correction. Inverse Mills Ratio is introduced as an additional
explanatory variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepStder</code></td>
<td>
<p>Numeric vector. Standard errors of OLS second step estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepSigmasq</code></td>
<td>
<p>Numeric. Estimated variance of OLS second step random error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepLoglik</code></td>
<td>
<p>Numeric. Log-likelihood value of OLS second step estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepSkew</code></td>
<td>
<p>Numeric. Skewness of the residuals of the OLS second step estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ols2stepM3Okay</code></td>
<td>
<p>Logical. Indicating whether the residuals of the OLS
second step estimation have the expected skewness.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CoelliM3Test</code></td>
<td>
<p>Coelli's test for OLS residuals skewness. (See Coelli,
1995).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AgostinoTest</code></td>
<td>
<p>D'Agostino's test for OLS residuals skewness. (See
D'Agostino and Pearson, 1973).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isWeights</code></td>
<td>
<p>Logical. If <code>TRUE</code> weighted log-likelihood is
maximized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lType</code></td>
<td>
<p>Type of likelihood estimated. See the section ‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optType</code></td>
<td>
<p>Optimization algorithm used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>Number of iterations of the ML estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optStatus</code></td>
<td>
<p>Optimization algorithm termination message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startLoglik</code></td>
<td>
<p>Log-likelihood at the starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mlLoglik</code></td>
<td>
<p>Log-likelihood value of the M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mlParam</code></td>
<td>
<p>Parameters obtained from M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>Each variable gradient of the M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradL_OBS</code></td>
<td>
<p>Matrix. Each variable individual observation gradient of
the M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradientNorm</code></td>
<td>
<p>Gradient norm of the M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invHessian</code></td>
<td>
<p>Covariance matrix of the parameters obtained from the
M(S)L estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessianType</code></td>
<td>
<p>The argument <code>'hessianType'</code>. See the section
‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mlDate</code></td>
<td>
<p>Date and time of the estimated model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simDist</code></td>
<td>
<p>The argument <code>'simDist'</code>, only if <code>lType =
'msl'</code>. See the section ‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsim</code></td>
<td>
<p>The argument <code>'Nsim'</code>, only if <code>lType = 'msl'</code>.
See the section ‘Arguments’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FiMat</code></td>
<td>
<p>Matrix of random draws used for MSL, only if <code>lType =
'msl'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gHermiteData</code></td>
<td>
<p>List. Gauss-Hermite quadrature rule as provided by
<code>gaussHermiteData</code>. Only if <code>lType = 
'ghermite'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsub</code></td>
<td>
<p>Number of subdivisions used for quadrature approaches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uBound</code></td>
<td>
<p>Upper bound for the inefficiency component when solving
integrals using quadrature approaches except Gauss-Hermite for which the upper
bound is automatically infinite (<code>Inf</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intol</code></td>
<td>
<p>Integration tolerance for quadrature approaches except Gauss-Hermite.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For the Halton draws, the code is adapted from the <span class="pkg">mlogit</span>
package.
</p>


<h3>References</h3>

<p>Caudill, S. B., and Ford, J. M. 1993. Biases in frontier estimation due to
heteroscedasticity. <em>Economics Letters</em>, <b>41</b>(1), 17–20.
</p>
<p>Caudill, S. B., Ford, J. M., and Gropper, D. M. 1995. Frontier estimation
and firm-specific inefficiency measures in the presence of
heteroscedasticity. <em>Journal of Business &amp; Economic Statistics</em>,
<b>13</b>(1), 105–111.
</p>
<p>Coelli, T. 1995. Estimators and hypothesis tests for a stochastic frontier
function - a Monte-Carlo analysis. <em>Journal of Productivity Analysis</em>,
<b>6</b>:247–268.
</p>
<p>D'Agostino, R., and E.S. Pearson. 1973. Tests for departure from normality.
Empirical results for the distributions of <code class="reqn">b_2</code> and <code class="reqn">\sqrt{b_1}</code>.
<em>Biometrika</em>, <b>60</b>:613–622.
</p>
<p>Dakpo, K. H., Latruffe, L., Desjeux, Y., Jeanneaux, P., 2022.
Modeling heterogeneous technologies in the presence of sample selection:
The case of dairy farms and the adoption of agri-environmental schemes in France.
<em>Agricultural Economics</em>, <b>53</b>(3), 422-438.
</p>
<p>Greene, W., 2010. A stochastic frontier model with correction
for sample selection. <em>Journal of Productivity Analysis</em>. <b>34</b>, 15–24.
</p>
<p>Hadri, K. 1999. Estimation of a doubly heteroscedastic stochastic frontier
cost function. <em>Journal of Business &amp; Economic Statistics</em>,
<b>17</b>(3), 359–363.
</p>
<p>Heckman, J., 1976. Discrete, qualitative and limited dependent variables.
<em>Ann Econ Soc Meas.</em> <b>4</b>, 475–492.
</p>
<p>Heckman, J., 1979. Sample Selection Bias as a Specification Error.
<em>Econometrica</em>. <b>47</b>, 153–161.
</p>
<p>Reifschneider, D., and Stevenson, R. 1991. Systematic departures from the
frontier: A framework for the analysis of firm inefficiency.
<em>International Economic Review</em>, <b>32</b>(3), 715–723.
</p>


<h3>See Also</h3>

<p><code>print</code> for printing <code>sfaselectioncross</code> object.
</p>
<p><code>summary</code> for creating and printing
summary results.
</p>
<p><code>coef</code> for extracting coefficients of the
estimation.
</p>
<p><code>efficiencies</code> for computing
(in-)efficiency estimates.
</p>
<p><code>fitted</code> for extracting the fitted frontier
values.
</p>
<p><code>ic</code> for extracting information criteria.
</p>
<p><code>logLik</code> for extracting log-likelihood
value(s) of the estimation.
</p>
<p><code>marginal</code> for computing marginal effects of
inefficiency drivers.
</p>
<p><code>residuals</code> for extracting residuals of the
estimation.
</p>
<p><code>vcov</code> for computing the variance-covariance
matrix of the coefficients.
</p>
<p><code>bread</code> for bread for sandwich estimator.
</p>
<p><code>estfun</code> for gradient extraction for each
observation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

## Simulated example

N &lt;- 2000  # sample size
set.seed(12345)
z1 &lt;- rnorm(N)
z2 &lt;- rnorm(N)
v1 &lt;- rnorm(N)
v2 &lt;- rnorm(N)
e1 &lt;- v1
e2 &lt;- 0.7071 * (v1 + v2)
ds &lt;- z1 + z2 + e1
d &lt;- ifelse(ds &gt; 0, 1, 0)
u &lt;- abs(rnorm(N))
x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
y &lt;- x1 + x2 + e2 - u
data &lt;- cbind(y = y, x1 = x1, x2 = x2, z1 = z1, z2 = z2, d = d)

## Estimation using quadrature (Gauss-Kronrod)

selecRes1 &lt;- sfaselectioncross(selectionF = d ~ z1 + z2, frontierF = y ~ x1 + x2, 
modelType = 'greene10', method = 'bfgs',
logDepVar = TRUE, data = as.data.frame(data),
S = 1L, udist = 'hnormal', lType = 'kronrod', Nsub = 100, uBound = Inf,
simType = 'halton', Nsim = 300, prime = 2L, burn = 10, antithetics = FALSE,
seed = 12345, itermax = 2000, printInfo = FALSE)

summary(selecRes1)

## Estimation using maximum simulated likelihood

selecRes2 &lt;- sfaselectioncross(selectionF = d ~ z1 + z2, frontierF = y ~ x1 + x2, 
modelType = 'greene10', method = 'bfgs',
logDepVar = TRUE, data = as.data.frame(data),
S = 1L, udist = 'hnormal', lType = 'msl', Nsub = 100, uBound = Inf,
simType = 'halton', Nsim = 300, prime = 2L, burn = 10, antithetics = FALSE,
seed = 12345, itermax = 2000, printInfo = FALSE)

summary(selecRes2)


## End(Not run)

</code></pre>


</div>