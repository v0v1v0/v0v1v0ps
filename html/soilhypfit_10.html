<div class="container">

<table style="width: 100%;"><tr>
<td>control_fit_wrc_hcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Controlling fit_wrc_hcc</h2>

<h3>Description</h3>

<p>This page documents options to control <code>fit_wrc_hcc</code>.  It
describes the arguments of the functions <code>control_fit_wrc_hcc</code>,
<code>param_boundf</code>, <code>param_transf</code>, <code>fwd_transf</code>,
<code>dfwd_transf</code>, <code>bwd_transf</code>, <code>control_nloptr</code>,
<code>control_sce</code> and <code>control_pcmp</code>, which all serve to steer
<code>fit_wrc_hcc</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">control_fit_wrc_hcc(
    settings = c("uglobal", "ulocal", "clocal", "cglobal", "sce"),
    method = c("ml", "mpd", "wls"), hessian,
    nloptr = control_nloptr(), sce = control_sce(),
    wrc_model = "vg", hcc_model = "vgm",
    initial_param = c(alpha = 2., n = 1.5, tau = 0.5),
    approximation_alpha_k0 =
        c(c0 = 1, c1 = 5.55, c2 = 1.204, c3 = 2.11, c4 = 1.71),
    variable_weight = c(wrc = 1, hcc = 1),
    gam_k = 6, gam_n_newdata = 101, precBits = 256,
    min_nobs_wc = 5, min_nobs_hc = 5,
    keep_empty_fits = FALSE,
    param_bound = param_boundf(), param_tf = param_transf(),
    fwd_tf = fwd_transf(), deriv_fwd_tfd = dfwd_transf(), bwd_tf = bwd_transf(),
    pcmp = control_pcmp())

param_boundf(alpha = c(0 + 10 * sqrt(.Machine$double.eps), 500),
    n = c(1 + 10 * sqrt(.Machine$double.eps), 20), tau = c(-2, 20),
    thetar = c(0, 1), thetas = c(0, 1), k0 = c(0, Inf))

param_transf(alpha = c("log", "identity"), n = c("log1", "identity"),
    tau = c("logitlu", "identity"), k0 = c("log", "identity"))

fwd_transf(...)

dfwd_transf(...)

bwd_transf(...)

control_nloptr(...)

control_sce(reltol = 1.e-8, maxtime = 20, ...)

control_pcmp(ncores = detectCores() - 1L,
    fork = !identical(.Platform[["OS.type"]], "windows"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>a keyword with possible values <code>"uglobal"</code>
(default), <code>"ulocal"</code>, <code>"clocal"</code>, <code>"cglobal"</code> or
<code>"sce"</code> to choose the approach for the nonlinear optimisation, see
<em>Details</em> and <code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a keyword with possible values <code>"ml"</code> (maximum
likelihood, default), <code>"mpd"</code> (maximum posterior density) or
<code>"wls"</code> (weighted least squares) to choose the method for estimating
the nonlinear parameters <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code>, see
<code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>a logical scalar controlling whether the Hessian matrix of
the objective function should be computed with respect to the possibly
transformed nonlinear parameters <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code> at the solution
(default: <code>TRUE</code> if <code>settings %in% c("uglobal", "ulocal",
  "sce") &amp;&amp; method %in% c("mpd", "ml")</code> and <code>FALSE</code> otherwise).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nloptr</code></td>
<td>
<p>a list of arguments passed to the optimiser
<code>nloptr</code> by its argument <code>opts</code>, or a function
such as <code>control_nloptr</code> that generates such a list.<br> Note that
<code>control_fit_wrc_hcc</code> chooses sensible default values for the
various components of the list in dependence of the value chosen for
<code>settings</code>, but these defaults can be overridden by the arguments of
<code>control_nloptr</code>, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sce</code></td>
<td>
<p>a list of arguments passed to the optimiser
<code>SCEoptim</code> by its argument <code>control</code>, or a
function such as <code>control_sce</code> that generates such a list.<br> Note
that <code>control_fit_wrc_hcc</code> chooses sensible default values for the
various components of the list, but these defaults can be overridden by
the arguments of <code>control_sce</code>, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrc_model</code></td>
<td>
<p>a keyword choosing the parametrical model for the
water retention curve.  Currently, only the <em>Van Genuchten</em> model
(<code>"vg"</code>) is implemented, see <code>wc_model</code>
and <code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hcc_model</code></td>
<td>
<p>a keyword choosing the parametrical model for the
hydraulic conductivity function.  Currently, only the <em>Van
Genuchten-Mualem</em> model (<code>"vgm"</code>) is implemented, see
<code>hc_model</code> and <code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_param</code></td>
<td>
<p>a named numeric vector with default initial values
for the <em>nonlinear</em> parameters <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code>
of the models for the water retention curve and/or hydraulic conductivity
function.  Currently, initial values must be defined for the parameters
<code class="reqn">\alpha</code> (default 1.5 [<code class="reqn">\mathrm{m}^{-1}</code>]), <code class="reqn">n</code>
(default 2 [-]) and <code class="reqn">\tau</code> (default 0.5 [-]), hence the elements of
<code>initial_param</code> must be named <code>"alpha"</code>, <code>"n"</code> and
<code>"tau"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approximation_alpha_k0</code></td>
<td>
<p>a named numeric vector with constants to
approximate the parameter <code class="reqn">\alpha</code> and the saturated hydraulic
conductivity <code class="reqn">K_0</code> when constraining the estimated <em>nonlinear</em>
parameters <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code> of the Van
Genuchten-Mualem model by the <em>characteristic evaporative length</em>
(<cite>Lehmann et al., 2020</cite>), see <code>evaporative-length</code> and
<code>soilhypfitIntro</code>.  For consistency with other quantities,
the following units should be used for the constants:
</p>

<ul>
<li> <p><code>c1</code>: <code class="reqn">\mathrm{m}^{-1}</code>,
</p>
</li>
<li> <p><code>c3</code>: <code class="reqn">\mathrm{m}\,\mathrm{d}^{-1}</code>.
</p>
</li>
</ul>
<p> The remaining constants are
dimensionless.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable_weight</code></td>
<td>
<p>a named numeric vector of length 2 that defines
the weights of water content and hydraulic conductivity measurements in
the objective function for <code>method = "wls"</code>.  If equal to 1
(default) the weights of the variables are equal to the inverse variances
of the water content and (possibly log-transformed) hydraulic
conductivity measurements.  If different from 1, then the inverse
variances are multiplied by <code>variable_weight</code> to get the variable
weights <code class="reqn">w_\theta</code> and <code class="reqn">w_K</code>, see <code>fit_wrc_hcc</code> and
<code>soilhypfitIntro</code>.  Note that for estimation methods mpd and
ml the variable weights are equal to 1 but the case weights
<code class="reqn">w^\prime_{\theta,i}</code> and <code class="reqn">w^\prime_{K,j}</code> may differ from 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam_k</code></td>
<td>
<p>the dimension of the basis of the additive model for
the water retention data when computing initial values of the
parameters <code class="reqn">\alpha</code> and <code class="reqn">n</code>, see <code>s</code> and<br><code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam_n_newdata</code></td>
<td>
<p>the number of evaluation points of the additive
model for the water retention data when computing initial values of the
parameters <code class="reqn">\alpha</code> and <code class="reqn">n</code>, see <code>soilhypfitIntro</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precBits</code></td>
<td>
<p>an integer scalar defining the default precision (in
bits) to be used in high-precision computations by
<code>mpfr</code>, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_nobs_wc</code></td>
<td>
<p>an integer scalar defining the minimum number of
water content measurements per sample required for fitting a model to the
water content data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_nobs_hc</code></td>
<td>
<p>an integer scalar defining the minimum number of
hydraulic conductivity measurements per sample required for fitting a
model to hydraulic conductivity data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_empty_fits</code></td>
<td>
<p>a logical scalar controlling whether missing
fitting results should be dropped for samples without any data or failed
fits (<code>FALSE</code>, default) or kept (<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_bound</code></td>
<td>
<p>a named list of numeric vectors of length 2 that
define the allowed lower and upper bounds (box constraints) for the
parameters of the models or a function such as <code>param_boundf</code> which
generates this list, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_tf</code></td>
<td>
<p>a named vector of keywords that define the
transformations to be applied to the model parameters before estimation
or a function such as <code>param_transf</code>, which generates this vector,
see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fwd_tf</code></td>
<td>
<p>a named list of invertible functions to be used to
transform model parameters or a function such as <code>fwd_transf</code>, which
generates this list, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv_fwd_tfd</code></td>
<td>
<p>a named list of functions corresponding to the first
derivatives of the functions defined in <code>fwd_tf</code> or a function such
as <code>dfwd_transf</code>, which generates this list, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwd_tf</code></td>
<td>
<p>a named list of inverse functions corresponding the
functions defined in <code>fwd_tf</code> or a function such as <code>bwd_transf</code>,
which generates this list, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcmp</code></td>
<td>
<p>a list to control parallel computations or a function such as
<code>control_pcmp</code> that generates this list, see <code>control_pcmp</code> for
allowed arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>either a numeric vector of length 2 defining the allowed
lower and upper bounds for the nonlinear parameter <code class="reqn">\alpha</code>
(<code>param_boundf</code>), or a keyword defining the transformation
to be applied to the parameter <code class="reqn">\alpha</code> before estimation
(<code>param_transf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>either a numeric vector of length 2 defining the allowed lower
and upper bounds for the nonlinear parameter <code class="reqn">n</code>
(<code>param_boundf</code>), or a keyword defining the transformation
to be applied to the parameter <code class="reqn">n</code> before estimation
(<code>param_transf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>either a numeric vector of length 2 defining the allowed
lower and upper bounds for the nonlinear parameter <code class="reqn">\tau</code>
(<code>param_boundf</code>), or a keyword defining the transformation
to be applied to the parameter <code class="reqn">\tau</code> before estimation
(<code>param_transf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thetar</code></td>
<td>
<p>a numeric vector of length 2 defining the allowed
lower and upper bounds for the linear parameter <code class="reqn">\theta_r</code>
(<code>param_boundf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thetas</code></td>
<td>
<p>a numeric vector of length 2 defining the allowed
lower and upper bounds for the linear parameter <code class="reqn">\theta_s</code>
(<code>param_boundf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k0</code></td>
<td>
<p>either a numeric vector of length 2 defining the allowed
lower and upper bounds for the linear parameter <code class="reqn">K_0</code>
(<code>param_boundf</code>), or a keyword defining the transformation
to be applied to the parameter <code class="reqn">K_0</code> before estimation
(<code>param_transf</code>), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>a numeric scalar defining (one possible) convergence
criterion for the optimiser <code>SCEoptim</code>, see argument <code>control</code>
of <code>SCEoptim</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxtime</code></td>
<td>
<p>a numeric scalar defining the maximum duration of
optimisation in seconds by the optimiser <code>SCEoptim</code>, see see
argument <code>control</code> of <code>SCEoptim</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>an integer defining the number of cores for
parallel computations.  Defaults to the number of available cores
minus one. <code>ncores = 1</code> suppresses parallel computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fork</code></td>
<td>
<p>a logical scalar controlling whether forking should be used
for parallel computations (default: <code>TRUE</code> on Unix and MacOS and
<code>FALSE</code> on Windows operating systems).  Note that stetting
<code>fork = TRUE</code> on Windows suppresses parallel computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments, such as details on parameter
transformations (<code>fwd_transf</code>, <code>dfwd_transf</code>,
<code>bwd_transf</code>) or control options passed to the
optimisers <code>nloptr</code> and
<code>SCEoptim</code>, see <em>Details</em>.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Enforcing bounds on the estimated parameters</h4>

<p>Parameters of models for the water retention curve and the hydraulic
conductivity function may vary only within certain bounds (see
<code>param_boundf</code> for allowed ranges).  <code>fit_wrc_hcc</code>
uses two mechanisms to constrain parameter estimates to permissible
ranges:
</p>

<ol>
<li> <p><em>Parameter transformations</em>
</p>
<p>If a local algorithm is used for nonlinear optimisation
(<code>settings = "ulocal"</code> or <code>settings = "clocal"</code>) and a
transformation not equal to <code>"identity"</code> is specified in
<code>param_tf</code> for any of the <em>nonlinear</em> parameters
<code class="reqn">\boldsymbol{\nu}^\mathrm{} </code>, then the elements of <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code> are
transformed by the functions given in <code>param_tf</code>.  The values
of the transformed parameters vary then over the whole real line,
and an unconstrained algorithm can be used for nonlinear
optimisation.
</p>
<p>Note that the <em>linear</em> parameters <code class="reqn">\theta_r</code> (residual)
and <code class="reqn">\theta_s</code> (saturated water content) are never transformed
and for the saturated hydraulic conductivity, <code class="reqn">K_0</code>, only
<code>"log"</code> (default) or <code>"identity"</code> can be chosen.
Quadratic programming (see <code>solve.QP</code>) is
employed to enforce the box constraints specified in the argument
<code>param_bound</code> for <code class="reqn">\theta_r</code> and <code class="reqn">\theta_s</code>.
Quadratic programming is also used to enforce the positivity
constraint on <code class="reqn">K_0</code> if <code class="reqn">K_0</code> is not log-transformed
(<code>"identity"</code>).  Otherwise, the logarithm of <code class="reqn">K_0</code> is
estimated unconstrainedly, see <code>soilhypfitIntro</code> for
further details.
</p>
</li>
<li> <p><em>Box constraints</em>
</p>
<p>If a global algorithm is used for the optimisation (<code>settings</code>
equal to <code>"uglobal"</code> <code>"cglobal"</code> or <code>"sce"</code>) or if
<code>"identity"</code> transformations are specified for all elements of
<code class="reqn">\boldsymbol{\nu}^\mathrm{} </code>, then an optimisation algorithm is deployed that
respects the box constraints given in <code>param_bound</code>.  If
parameters are estimated for several soil samples in a single call
of <code>fit_wrc_hcc</code> and if sample-specific box constraints
should be used then the lower and upper bounds of the
box-constraints must be specified by the arguments
<code>lower_param</code> and <code>upper_param</code> of the function
<code>fit_wrc_hcc</code>, see explanations there.
</p>
<p>Further note that the transformations specified by <code>param_tf</code>
for the nonlinear parameters <code class="reqn">\boldsymbol{\nu}^\mathrm{} </code> are ignored when a
global optimisation algorithm is used.
</p>
</li>
</ol>
<h4>Parameter transformations</h4>

<p>The arguments <code>param_tf</code>, <code>fwd_tf</code>, <code>deriv_fwd_tfd</code>,
<code>bwd_tf</code> define how the model parameters are transformed for
estimation by local optimisation algortihms (see above and
<code>soilhypfitIntro</code>).  The following transformations are
currently available:
</p>

<dl>
<dt>
<code>"log"</code>:</dt>
<dd>
<p><code class="reqn">\log(x)</code>,</p>
</dd>
<dt>
<code>"log1"</code>:</dt>
<dd>
<p><code class="reqn">\log(x-1)</code>,</p>
</dd>
<dt>
<code>"logitlu"</code>:</dt>
<dd>
<p><code class="reqn">\log((x - l) / (u - x))</code> with <code class="reqn">l</code>
and <code class="reqn">u</code> the allowed lower and upper bounds for a parameter, see
<code>param_boundf</code>,</p>
</dd>
<dt>
<code>"identity"</code>:</dt>
<dd>
<p>no transformation.</p>
</dd>
</dl>
<p>These are the possible values that the various arguments of the
function <code>param_transf</code> accept (as quoted character strings), and
these are the names of the list components returned by
<code>fwd_transf</code>, <code>dfwd_transf</code> and <code>bwd_transf</code>.
</p>
<p>Additional transformations can be implemented by:
</p>

<ol>
<li>
<p> Extending the function definitions by arguments like
</p>
<p><code>fwd_tf = fwd_transf(my_fun = function(x) your transformation)</code>,<br><code>deriv_fwd_tfd = dfwd_transf(my_fun = function(x) your derivative)</code>,<br><code>bwd_tf = bwd_transf(my_fun = function(x) your back-transformation)</code>,
</p>
</li>
<li>
<p> Assigning to a given argument of <code>param_transf</code> the name
of the new function, e.g.<br><code>alpha = "my_fun"</code>.  </p>
</li>
</ol>
<p>Note that the values given to the arguments of <code>param_transf</code> must
match the names of the functions returned by <code>fwd_transf</code>,
<code>dfwd_transf</code> and <code>bwd_transf</code>.
</p>



<h4>High-precision numerical computations</h4>

<p>Estimation of <code class="reqn">\log(K_0)</code> is somewhat delicate for large
values of the shape parameter <code class="reqn">n</code> and/or small values of
<code class="reqn">\alpha</code>.  The water saturation and the relative conductivity are
then close to zero for capillary pressure head exceeding
<code class="reqn">1/\alpha</code>.  To avoid numerical problems caused by limited accuracy
of double precision numbers, <code>fit_wrc_hcc</code> uses the
function <code>mpfr</code> of the package <span class="pkg">Rmpfr</span> for
high-accuracy computations.  The argument <code>precBits</code> of
<code>control_fit_wrc_hcc</code> controls the accuracy.  Increase its
value if computation fails with a respective diagnostic message.
</p>



<h4>Options to choose the approach for nonlinear optimisation</h4>

<p>The argument <code>settings</code> defines sets of default options to control
the optimisers.  The following <code>settings</code> are currently defined:
</p>

<dl>
<dt>
<code>"uglobal"</code>:</dt>
<dd>
<p>unconstrained optimisation by any of the
global algorithms (named <code>"NLOPT_G..."</code>) of the NLopt library.</p>
</dd>
<dt>
<code>"cglobal"</code>:</dt>
<dd>
<p>constrained optimisation by the global
algorithm <code>"NLOPT_GN_ISRES"</code> of NLopt that allows for inequality
constraints.</p>
</dd>
<dt>
<code>"ulocal"</code>:</dt>
<dd>
<p>unconstrained optimisation by any of the
local algorithms<br> (named <code>"NLOPT_L..."</code>) of
NLopt.</p>
</dd>
<dt>
<code>"clocal"</code>:</dt>
<dd>
<p>constrained optimisation by any of the local
algorithms<br> (<code>"NLOPT_LN_COBYLA"</code>, <code>"NLOPT_LN_AUGLAG"</code>,
<code>"NLOPT_LD_AUGLAG"</code>, <code>"NLOPT_LD_SLSQP"</code>,<br><code>"NLOPT_LD_MMA"</code>), <code>"NLOPT_LD_CCSAQ"</code>) of NLopt that allow
for inequality constraints.</p>
</dd>
<dt>
<code>"sce"</code>:</dt>
<dd>
<p>unconstrained optimisation by the global
algorithm implemented in <code>SCEoptim</code>.</p>
</dd>
</dl>
<p>The functions <code>control_nloptr</code> and <code>control_sce</code> allow finer
control of the optimisers.

<code>control_nloptr</code> and <code>control_sce</code> take any
argument available to pass controlling options to the optimisers
<code>nloptr</code> (by its argument <code>opts</code>) and
<code>SCEoptim</code> (by its argument <code>control</code>),
respectively.
</p>


<h5>Controlling nloptr</h5>

<p>The function <code>nloptr.print.options</code> prints all
options available to control <code>nloptr</code> by its
argument <code>opts</code>.  Detailed information on the options can be
found in the
<a href="https://nlopt.readthedocs.io/en/latest/NLopt_manual/">NLopt
documentation</a>.<br></p>
<p>The function <code>control_fit_wrc_hcc</code> sets meaningful defaults for
<code>opts</code> in dependence of the chosen optimisation approach as
specified by the argument <code>settings</code>, and it checks the
consistency of the arguments of <code>control_nloptr</code> if they are
explicitly passed to <code>fit_wrc_hcc</code>.<br></p>
<p>The following defaults are set by <code>control_fit_wrc_hcc</code> for the
argument <code>opts</code> of <code>nloptr</code> (:
</p>


<ol>
<li>
<p> Unconstrained, global optimisation (<code>settings =
        "uglobal"</code>):
</p>
<pre>
nloptr = control_nloptr(
  algorithm = "NLOPT_GN_MLSL_LDS",
  local_opts = list(
    algorithm = "NLOPT_LN_BOBYQA",
    xtol_rel = -1.,
    ftol_rel = 1.e-6
  ),
  xtol_rel = -1,
  ftol_rel = -1,
  maxeval = 125,
  maxtime = -1)
        </pre>
<p>In addition, any parameter transformations specified by
<code>param_tf</code> are overridden and the untransformed parameters
(<code>"identity"</code>) are estimated when <code>settings = "uglobal"</code> is
chosen.
</p>

</li>
<li>
<p> Constrained, global optimisation (<code>settings =
        "cglobal"</code>):
</p>
<pre>
nloptr = control_nloptr(
  algorithm = "NLOPT_GN_ISRES",
  xtol_rel = -1,
  ftol_rel = -1,
  maxeval = 1000,
  maxtime = -1)
        </pre>
<p>In addition, any parameter transformations specified by
<code>param_tf</code> are overridden and the untransformed parameters
(<code>"identity"</code>) are estimated when <code>settings = "cglobal"</code>
is chosen.
</p>

</li>
<li>
<p> Unconstrained, local optimisation (<code>settings =
        "ulocal"</code>):
</p>
<pre>
nloptr = control_nloptr(
  algorithm = "NLOPT_LN_BOBYQA",
  xtol_rel = -1,
  ftol_rel = 1.e-8,
  maxeval = 250,
  maxtime = -1)
        </pre>

</li>
<li>
<p> Constrained, local optimisation (<code>settings = "clocal"</code>):
</p>
<pre>
nloptr = control_nloptr(
  algorithm = "NLOPT_LD_CCSAQ",
  xtol_rel = -1,
  ftol_rel = 1.e-8,
  maxeval = 1000,
  maxtime = -1)
        </pre>
<p>If the algorithm <code>"NLOPT_LD_AUGLAG"</code> is used for constrained,
local optimisation then
</p>
<pre>
nloptr = control_nloptr(
  algorithm = "NLOPT_LD_AUGLAG",
  local_opts = list(
    algorithm = "NLOPT_LD_LBFGS",
    xtol_rel = -1.,
    ftol_rel = 1.e-6
  ),
  xtol_rel = -1,
  ftol_rel = 1.e-8,
  maxeval = 1000,
  maxtime = -1)
        </pre>
</li>
</ol>
<p>For other, unspecified elements of <code>opts</code> default values as
listed by <code>nloptr.print.options</code> are used.
</p>



<h5>Controlling SCEoptim</h5>

<p>The function <code>control_sce</code> sets meaningful defaults for the
argument <code>control</code> of <code>SCEoptim</code>.
Currently, the following defaults are defined:
</p>
<pre>
sce = control_sce(
  reltol = 1e-08,
  maxtime = 20)
      </pre>
<p>In addition, any parameter transformations specified by
<code>param_tf</code> are overridden and the untransformed parameters
(<code>"identity"</code>) are estimated when <code>settings = "sce"</code> is
chosen.
</p>




<h3>Value</h3>

<p><code>control_fit_wrc_hcc</code> creates a list with components
<code>settings</code>, <code>hessian</code>, <code>method</code>, <code>nloptr</code>,
<code>sce</code>, <code>wrc_model</code>, <code>hcc_model</code>, <code>initial_param</code>,
<code>approximation_alpha_k0</code>, <code>variable_weight</code>, <code>gam_k</code>,
<code>gam_n_newdata</code>, <code>precBits</code>, <code>min_nobs_wc</code>,
<code>min_nobs_hc</code>, <code>keep_empty_fits</code>, <code>param_bound</code>,
<code>param_tf</code>, <code>fwd_tf</code>, <code>deriv_fwd_tfd</code>, <code>bwd_tf</code>,
<code>pcmp</code> corresponding to its arguments and some further components
(<code>delta_sat_0</code>, <code>grad_eps</code>, <code>use_derivative</code>) that cannot
be changed by the user.
</p>
<p><code>control_nloptr</code> and <code>control_sce</code>
create lists with control parameters passed to
<code>nloptr</code> and <code>SCEoptim</code>,
respectively, see <em>Details</em>.
</p>
<p><code>param_boundf</code> generates a list with allowed lower and upper bounds of
the model parameters.
</p>
<p><code>param_transf</code> generates a list with keywords that
define what transformations are used for estimating the model
parameters, and <code>fwd_transf</code>, <code>bwd_transf</code> and
<code>dfwd_transf</code> return lists of functions with forward and backward
transformations and the first derivatives of the forward
transformations, see <em>Details</em>.
</p>
<p><code>control_pcmp</code> generates a list with control parameters for parallel
computations.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Johnson, S.G. The NLopt nonlinear-optimisation package.
<a href="https://github.com/stevengj/nlopt">https://github.com/stevengj/nlopt</a>.
</p>
<p>Lehmann, P., Assouline, S., Or, D. (2008) Characteristic lengths
affecting evaporative drying of porous media.  <em>Physical Review E</em>,
<b>77</b>, 056309, <a href="https://doi.org/10.1103/PhysRevE.77.056309">doi:10.1103/PhysRevE.77.056309</a>.
</p>
<p>Lehmann, P., Bickel, S., Wei, Z., Or, D. (2020) Physical Constraints for
Improved Soil Hydraulic Parameter Estimation by Pedotransfer Functions.
<em>Water Resources Research</em> <b>56</b>, e2019WR025963,
<a href="https://doi.org/10.1029/2019WR025963">doi:10.1029/2019WR025963</a>.
</p>


<h3>See Also</h3>

<p><code>soilhypfitIntro</code> for a description of the models and a brief
summary of the parameter estimation approach;
</p>
<p><code>fit_wrc_hcc</code> for (constrained) estimation of parameters of
models for soil water retention and hydraulic conductivity data;
</p>



<p><code>soilhypfitmethods</code> for common S3 methods for class
<code>fit_wrc_hcc</code>;
</p>
<p><code>vcov</code> for computing (co-)variances of the estimated
nonlinear parameters;
</p>
<p><code>prfloglik_sample</code> for profile loglikelihood
computations;
</p>
<p><code>wc_model</code> and <code>hc_model</code> for currently
implemented models for soil water retention curves and hydraulic
conductivity functions;
</p>
<p><code>evaporative-length</code> for physically constraining parameter
estimates of soil hydraulic material functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# use of \donttest{} because execution time exceeds 5 seconds
data(sim_wrc_hcc)

# estimate parameters for a single soil sample by maximizing loglikelihood ...

# ... with unconstrained, global optimisation algorithm NLOPT_GN_MLSL
coef(
  fit1 &lt;- fit_wrc_hcc(
    wrc_formula = wc ~ head, hcc_formula = hc ~ head,
    data = sim_wrc_hcc, subset = id == 2
  ), gof = TRUE)

# ... as fit1 but fitting parameter tau as well
coef(
  fit2 &lt;- update(fit1,
    fit_param = default_fit_param(tau = TRUE)
  ), gof = TRUE)

plot(fit1, y = fit2)

# ... with unconstrained, local optimisation algorithm NLOPT_LN_BOBYQA,
#     initial values for alpha and n are computed from data and
#     transformed nonlinear parameters are estimated without box-constraints
coef(
  fit3 &lt;- update(
    fit2,
    control = control_fit_wrc_hcc(settings = "ulocal"),
    verbose = 2), gof = TRUE)

# estimate parameters by unconstrained, weighted least squares minimisation with
#     algorithm NLOPT_LD_LBFGS, giving larger weight to conductivity data,
#     using specified initial values for alpha and n and
#     fitting untransformed nonlinear parameters with default box constraints
#     defined by param_boundf()
#     diagnostic output directly from nloptr
coef(
  fit4 &lt;- update(
    fit2,
    param = c(alpha = 1.7, n = 2),
    control = control_fit_wrc_hcc(
      settings = "ulocal", method = "wls",
      variable_weight = c(wrc = 1, hcc = 2),
      nloptr = control_nloptr(algorithm = "NLOPT_LD_LBFGS", print_level = 3),
      param_tf = param_transf(alpha = "identity", n = "identity", tau = "identity")
    ), verbose = 0), gof = TRUE)

# ... as fit4 but giving even larger weight to conductivity data
coef(
  fit5 &lt;- update(
    fit4,
    control = control_fit_wrc_hcc(
      settings = "ulocal", method = "wls",
      variable_weight = c(wrc = 1, hcc = 5),
      nloptr = control_nloptr(algorithm = "NLOPT_LD_LBFGS", print_level = 3),
      param_tf = param_transf(alpha = "identity", n = "identity", tau = "identity")
    ), verbose = 0), gof = TRUE)

plot(fit4, y = fit5)

</code></pre>


</div>