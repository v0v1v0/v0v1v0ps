<div class="container">

<table style="width: 100%;"><tr>
<td>densityfun.lpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Kernel Estimate of Intensity on a Linear Network as a Spatial Function
</h2>

<h3>Description</h3>

<p>Computes a kernel estimate of the intensity of a point process on a linear
network, and returns the intensity estimate as a function of spatial location.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'lpp'
densityfun(X, sigma, ..., weights=NULL, nsigma=1, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Bandwidth of kernel (standard deviation of Gaussian kernel),
in the same units of length as <code>X</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to <code>density.lpp</code> to control
the discretisation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional numeric vector of weights associated
with the points of <code>X</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsigma</code></td>
<td>

<p>Integer. The number of different bandwidths for which a result
should be returned.
If <code>nsigma=1</code> (the default), the result is a function giving
kernel estimate with bandwidth <code>sigma</code>. If <code>nsigma &gt; 1</code>,
the result is a function with an additional argument <code>k</code>
containing the kernel estimates for the <code>nsigma+1</code>
equally-spaced time steps from <code>0</code> to <code>sigma^2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>X</code>
using the diffusion algorithm of McSwiggan et al (2016).
The result is a function on the linear network
(object of class <code>"linfun"</code>) that can be printed, plotted
and evaluated at any location. 
</p>
<p>This is a method for the generic function
<code>densityfun</code> for the class
<code>"lpp"</code> of point patterns on a linear network.
</p>


<h3>Value</h3>

<p>Function on a linear network (object of class <code>"linfun"</code>).
</p>
<p>If <code>nsigma=1</code> (the default), the result is a function giving
kernel estimate with bandwidth <code>sigma</code>.
</p>
<p>If <code>nsigma &gt; 1</code>, the result is a function
with an additional argument <code>k</code>. If <code>k</code> is specified,
the function returns the kernel estimate for
bandwidth <code>tau = sigma * sqrt(k/nsigma)</code>.
If <code>k</code> is not specified, results are returned
for all <code>k = 1, 2, ..., nsigma</code>.
</p>
<p>The result also has attributes
</p>

<ul>
<li> <p><code>attr(result, "dt")</code> giving the
time step <code class="reqn">\Delta t</code>;
</p>
</li>
<li> <p><code>attr(result, "dx")</code> giving the spacing <code class="reqn">\Delta x</code>
between sample points in the numerical algorithm;
</p>
</li>
<li> <p><code>attr(result, "sigma")</code>
giving the smoothing bandwidth <code class="reqn">\sigma</code> used
(or the successive bandwidths used at each sampled time step,
if <code>nsigma &gt; 1</code>).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Greg McSwiggan, with tweaks by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>McSwiggan, G., Baddeley, A. and Nair, G. (2016)
Kernel Density Estimation on a Linear Network.
<em>Scandinavian Journal of Statistics</em> <b>44</b>, 324â€“345.
</p>


<h3>See Also</h3>

<p><code>density.lpp</code> which returns a pixel image
on the linear network.
</p>
<p><code>methods.linfun</code> for methods applicable to
<code>"linfun"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  X &lt;- unmark(chicago)
  # single bandwidth
  g &lt;- densityfun(X, 30)
  plot(g)
  Y &lt;- X[1:5]
  g(Y)
  # weighted
  gw &lt;- densityfun(X, 30, weights=runif(npoints(X)))
  # sequence of bandwidths 
  g10 &lt;- densityfun(X, 30, nsigma=10)
  g10(Y, k=10)
  g10(Y)
  plot(as.linim(g10, k=5))
</code></pre>


</div>