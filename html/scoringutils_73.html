<div class="container">

<table style="width: 100%;"><tr>
<td>score</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate forecasts</h2>

<h3>Description</h3>

<p>This function allows automatic scoring of forecasts using a
range of metrics. For most users it will be the workhorse for
scoring forecasts as it wraps the lower level functions package functions.
However, these functions are also available if you wish to make use of them
independently.
</p>
<p>A range of forecasts formats are supported, including quantile-based,
sample-based, binary forecasts. Prior to scoring, users may wish to make use
of <code>check_forecasts()</code> to ensure that the input data is in a supported
format though this will also be run internally by <code>score()</code>. Examples for
each format are also provided (see the documentation for <code>data</code> below or in
<code>check_forecasts()</code>).
</p>
<p>Each format has a set of required columns (see below). Additional columns may
be present to indicate a grouping of forecasts. For example, we could have
forecasts made by different models in various locations at different time
points, each for several weeks into the future. It is important, that there
are only columns present which are relevant in order to group forecasts.
A combination of different columns should uniquely define the
<em>unit of a single forecast</em>, meaning that a single forecast is defined by the
values in the other columns. Adding additional unrelated columns may alter
results.
</p>
<p>To obtain a quick overview of the currently supported evaluation metrics,
have a look at the metrics data included in the package. The column
<code>metrics$Name</code> gives an overview of all available metric names that can be
computed. If interested in an unsupported metric please open a <a href="https://github.com/epiforecasts/scoringutils/issues">feature request</a> or consider
contributing a pull request.
</p>
<p>For additional help and examples, check out the <a href="https://epiforecasts.io/scoringutils/articles/scoringutils.html">Getting Started Vignette</a>
as well as the paper <a href="https://arxiv.org/abs/2205.07090">Evaluating Forecasts with scoringutils in R</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">score(data, metrics = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame or data.table with the predictions and observations.
For scoring using <code>score()</code>, the following columns need to be present:
</p>

<ul>
<li> <p><code>true_value</code> - the true observed values
</p>
</li>
<li> <p><code>prediction</code> - predictions or predictive samples for one
true value. (You only don't need to provide a prediction column if
you want to score quantile forecasts in a wide range format.)</p>
</li>
</ul>
<p>For scoring integer and continuous forecasts a <code>sample</code> column is needed:
</p>

<ul><li> <p><code>sample</code> - an index to identify the predictive samples in the
prediction column generated by one model for one true value. Only
necessary for continuous and integer forecasts, not for
binary predictions.</p>
</li></ul>
<p>For scoring predictions in a quantile-format forecast you should provide
a column called <code>quantile</code>:
</p>

<ul><li> <p><code>quantile</code>: quantile to which the prediction corresponds
</p>
</li></ul>
<p>In addition a <code>model</code> column is suggested and if not present this will be
flagged and added to the input data with all forecasts assigned as an
"unspecified model").
</p>
<p>You can check the format of your data using <code>check_forecasts()</code> and there
are examples for each format (example_quantile, example_continuous,
example_integer, and example_binary).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>the metrics you want to have in the output. If <code>NULL</code> (the
default), all available metrics will be computed. For a list of available
metrics see <code>available_metrics()</code>, or  check the metrics data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed down to <code>score_quantile()</code> (internal
function used for scoring forecasts in a quantile-based format).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.table with unsummarised scores. There will be one score per
quantile or sample, which is usually not desired, so you should almost
always run <code>summarise_scores()</code> on the unsummarised scores.
</p>


<h3>Author(s)</h3>

<p>Nikos Bosse <a href="mailto:nikosbosse@gmail.com">nikosbosse@gmail.com</a>
</p>


<h3>References</h3>

<p>Funk S, Camacho A, Kucharski AJ, Lowe R, Eggo RM, Edmunds WJ
(2019) Assessing the performance of real-time epidemic forecasts: A
case study of Ebola in the Western Area region of Sierra Leone, 2014-15.
PLoS Comput Biol 15(2): e1006785. <a href="https://doi.org/10.1371/journal.pcbi.1006785">doi:10.1371/journal.pcbi.1006785</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(magrittr) # pipe operator


check_forecasts(example_quantile)
score(example_quantile) %&gt;%
  add_coverage(by = c("model", "target_type")) %&gt;%
  summarise_scores(by = c("model", "target_type"))

# set forecast unit manually (to avoid issues with scoringutils trying to
# determine the forecast unit automatically), check forecasts before scoring
example_quantile %&gt;%
  set_forecast_unit(
    c("location", "target_end_date", "target_type", "horizon", "model")
  ) %&gt;%
  check_forecasts() %&gt;%
  score()

# forecast formats with different metrics
## Not run: 
score(example_binary)
score(example_quantile)
score(example_integer)
score(example_continuous)

## End(Not run)

# score point forecasts (marked by 'NA' in the quantile column)
score(example_point) %&gt;%
  summarise_scores(by = "model", na.rm = TRUE)

</code></pre>


</div>