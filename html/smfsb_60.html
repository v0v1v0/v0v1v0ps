<div class="container">

<table style="width: 100%;"><tr>
<td>StepODE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a function for advancing the state of an ODE model by using the deSolve package</h2>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an ODE model
using an integration method from the <code>deSolve</code> package. The
resulting function (closure) can be used in conjunction with other
functions (such as <code>simTs</code>) for simulating realisations of
ODE models. This function is used similarly to <code>StepEuler</code>,
but <code>StepODE</code> should be more accurate and efficient.
</p>


<h3>Usage</h3>

<pre><code class="language-R">StepODE(RHSfun)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>RHSfun</code></td>
<td>
<p>A function representing the RHS of the ODE model. <code>RHSfun</code> should have prototype <code>RHSfun(x,t,parms,...)</code>, with <code>t</code> representing current system time, <code>x</code> representing current system state and <code>parms</code> representing the model parameters. The value of the function should be a vector of the same dimension as <code>x</code>, representing the infinitesimal change in state.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>An R function which can be used to advance the state of the ODE model
<code>RHSfun</code> by using an efficient ODE solver. The function closure has interface <code>function(x0,t0,deltat,parms,...)</code>, where <code>t0</code> and <code>x0</code> represent the initial time and state, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code>StepEulerSPN</code>, <code>StepEuler</code>,
<code>simTs</code>, <code>ode</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Build a RHS for the Lotka-Volterra system
LVrhs &lt;- function(x,t,parms)
{
        with(as.list(c(x,parms)),{
                c( c1*x1 - c2*x1*x2 ,
                      c2*x1*x2 - c3*x2 )
        })
}
# create a stepping function
stepLV = StepODE(LVrhs)
# step the function
print(stepLV(c(x1=50,x2=100),0,1,parms=c(c1=1,c2=0.005,c3=0.6)))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,50,0.1,stepLV,parms=c(c1=1,c2=0.005,c3=0.6))
plot(out,plot.type="single",lty=1:2)
</code></pre>


</div>