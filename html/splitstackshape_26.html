<div class="container">

<table style="width: 100%;"><tr>
<td>stratified</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Take a Stratified Sample From a Dataset</h2>

<h3>Description</h3>

<p>The <code>stratified</code> function samples from a <code>data.table</code> in which one or more
columns can be used as a "stratification" or "grouping" variable. The result
is a new <code>data.table</code> with the specified number of samples from each group.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stratified(indt, group, size, select = NULL, replace = FALSE,
  keep.rownames = FALSE, bothSets = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>indt</code></td>
<td>
<p>The input <code>data.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The column or columns that should be used to create the groups.
Can be a character vector of column names (recommended) or a numeric vector
of column positions. Generally, if you are using more than one variable to
create your "strata", you should list them in the order of <em>slowest</em> varying
to <em>quickest</em> varying. This can be a vector of names or column indexes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>The desired sample size.
</p>

<ul>
<li>
<p> If <code>size</code> is a value between <code>0</code> and <code>1</code> expressed as a decimal, size is
set to be proportional to the number of observations per group.
</p>
</li>
<li>
<p> If <code>size</code> is a single positive integer, it will be assumed that you want
the same number of samples from each group.
</p>
</li>
<li>
<p> If <code>size</code> is a named vector, the function will check to see whether the
length of the vector matches the number of groups and that the names match
the group names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>A named list containing levels from the <code>"group"</code> variables in
which you are interested. The list names must be present as variable names
for the input dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Logical. Should sampling be with replacement? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.rownames</code></td>
<td>
<p>Logical. If the input is a <code>data.frame</code> with <code>rownames</code>,
<code>as.data.table</code> would normally drop the rownames. If <code>TRUE</code>, the rownames
would be retained in a column named <code>rn</code>. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bothSets</code></td>
<td>
<p>Logical. Should both the sampled and non-sampled sets be
returned as a <code>list</code>? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments to <code>base::sample()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>bothSets = TRUE</code>, a <code>list</code> of two <code>data.tables</code>; otherwise, a <code>data.table</code>.
</p>


<h3>Note</h3>

<p><em>Slightly different sizes than requested</em>: Because of how computers
deal with floating-point arithmetic, and because R uses a "round to even"
approach, the size per strata that results when specifying a proportionate
sample may be one sample higher or lower per strata than you might have expected.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code>sampling::strata()</code> from the "strata" package; <code>dplyr::sample_n()</code>
and <code>dplyr::sample_frac()</code> from "dplyr".
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Generate a sample data.frame to play with
set.seed(1)
DF &lt;- data.frame(
  ID = 1:100,
  A = sample(c("AA", "BB", "CC", "DD", "EE"), 100, replace = TRUE),
  B = rnorm(100), C = abs(round(rnorm(100), digits=1)),
  D = sample(c("CA", "NY", "TX"), 100, replace = TRUE),
  E = sample(c("M", "F"), 100, replace = TRUE))

# Take a 10% sample from all -A- groups in DF
stratified(DF, "A", .1)

# Take a 10% sample from only "AA" and "BB" groups from -A- in DF
stratified(DF, "A", .1, select = list(A = c("AA", "BB")))

# Take 5 samples from all -D- groups in DF, specified by column number
stratified(DF, group = 5, size = 5)

# Use a two-column strata: -E- and -D-
stratified(DF, c("E", "D"), size = .15)

# Use a two-column strata (-E- and -D-) but only use cases where -E- == "M"
stratified(DF, c("E", "D"), .15, select = list(E = "M"))

## As above, but where -E- == "M" and -D- == "CA" or "TX"
stratified(DF, c("E", "D"), .15, select = list(E = "M", D = c("CA", "TX")))

# Use a three-column strata: -E-, -D-, and -A-
stratified(DF, c("E", "D", "A"), size = 2)

## Not run: 
# The following will produce errors
stratified(DF, "D", c(5, 3))
stratified(DF, "D", c(5, 3, 2))

## End(Not run)

# Sizes using a named vector
stratified(DF, "D", c(CA = 5, NY = 3, TX = 2))

# Works with multiple groups as well
stratified(DF, c("D", "E"), 
           c("NY F" = 2, "NY M" = 3, "TX F" = 1, "TX M" = 1,
             "CA F" = 5, "CA M" = 1))

</code></pre>


</div>