<div class="container">

<table style="width: 100%;"><tr>
<td>exportRandomState</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Export Permuted Congruential Generator
</h2>

<h3>Description</h3>

<p>Export all the bits needed for seeding Permuted Congruential Generator.
</p>


<h3>Usage</h3>

<pre><code class="language-R">exportRandomState(seed)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>An integer or an integer vector of size 4 (128 bits). See
</p>
<p>&lt;http://www.pcg-random.org/&gt;.
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The returned integer vector <code>Value</code> supplies all the bits necessary for determining the state of a <code>pcg64</code> generator. <code>Value</code> can seed for all functions that need a RNG in this package. It will change after the function call, ready for seeding the <code>pcg64</code> generator in the next function call.
</p>


<h3>Value</h3>

<p>An integer vector of size 4.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Make a random PMF.
set.seed(456)
val = seq(0, 15, len = 100)
pmf = data.frame(
  val = val, P = dgamma(val, shape = 2, scale = 2) + runif(100) * 0.1)
pmf$P = pmf$P / sum(pmf$P)


completeRandomState = SimJoint::exportRandomState(456)
# `completeRandomState` comprises all the bits of a pcg64
# engine seeded by 456. It is similar to R's `.Random.seed`.
pmfSample1 = SimJoint::LHSpmf(pmf, 1000, completeRandomState)
pmfSample2 = SimJoint::LHSpmf(pmf, 1000, completeRandomState)
pmfSample3 = SimJoint::LHSpmf(pmf, 1000, completeRandomState)
# `completeRandomState` is changed in each run of `LHSpmf()`.


targetCor = rbind(
c(1,   0.3, 0.5),
c(0.3,   1, 0.3),
c(0.5, 0.3,   1))


result = SimJoint::SJpearson(
  X = cbind(sort(pmfSample1), sort(pmfSample2), sort(pmfSample3)),
  cor = targetCor, seed = completeRandomState, errorType = "maxRela")


cor(result$X)
</code></pre>


</div>