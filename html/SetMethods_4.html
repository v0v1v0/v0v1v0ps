<div class="container">

<table style="width: 100%;"><tr>
<td>cluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Diagnostic tool for clustered data.
</h2>

<h3>Description</h3>

<p>Function returns pooled, within, and between consistencies for the relationship between two sets, for an       object of class "qca", and for a Boolean expression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cluster(data=NULL, results, outcome, 
      unit_id, cluster_id, sol = 1, 
      necessity = FALSE, wicons = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A data frame in the long format containing both a colum with the unit names and a column with 
the cluster names. Column names should be in capital letters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>results</code></td>
<td>

<p>An object of class "qca". For performing cluster diagnostics of the sufficient solution for the negated        outcome one must only use the <code>minimize()</code> result from the sufficiency analysis of the negated outcome.
The argument results can also be a vector, a character string, or a boolean expression of the form 
e.g. "A*~B + ~B*C".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>

<p>A character string with the name of the outcome in capital letters. When performing cluster 
diagnostics of the sufficient solution for the negated outcome one must only use the <code>minimize()</code>            result from the sufficiency analysis of the negated outcome in the argument <code>results</code>. 
When performing cluster diagnostics for boolean expressions or vectors the negated outcome can be used by      inserting a tilde in the outcome name in the argument <code>outcome</code>.
The outcome can also be a vector. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit_id</code></td>
<td>

<p>A character string with the name of the vector containing the units (e.g. countries).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_id</code></td>
<td>

<p>A character string with the name of the vector containing the clustering units (e.g. years).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sol</code></td>
<td>

<p>A vector where the first number indicates the number of the conservative or parsimonious solution 
according to the order in the "qca" object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form "c1p3i2" where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>necessity</code></td>
<td>

<p>Logical. Perform the diagnostic for the relationship of necessity?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wicons</code></td>
<td>

<p>Logical. Should within consistencies and coverages be printed?
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Garcia-Castro, Roberto, and Miguel A. Arino. 2016. "A General Approach to Panel Data Set-Theoretic Research."" Journal of Advances in Management Sciences &amp; Information Systems 2: 6376.
</p>


<h3>See Also</h3>

<p><code>minimize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Import your clustered data in the long format. 
# For example:

data(SCHLF)

# Get the intermediate solution:

sol_yi &lt;- minimize(SCHLF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE, dir.exp = c(0,0,0,0,0,0))

# Get pooled, within, and between consistencies for the intermediate solution:

cluster(SCHLF, sol_yi, "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", sol = 1)
              
# or:

cluster(SCHLF, sol_yi, "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", sol = "c1p1i1")

# Get pooled, within, and between consistencies for EMP as necessary for EXPORT:

cluster(SCHLF, results="EMP", outcome="EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", necessity=TRUE)
# or:

cluster(results=SCHLF$EMP, outcome=SCHLF$EXPORT, unit_id = SCHLF$COUNTRY, 
              cluster_id = SCHLF$YEAR, necessity=TRUE)
              
# Get pooled, within, and between consistencies for ~EMP as necessary for EXPORT:

cluster(SCHLF, results="~EMP", outcome="EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", necessity=TRUE)
# or:

cluster(results=1-SCHLF$EMP, outcome=SCHLF$EXPORT, unit_id = SCHLF$COUNTRY, 
              cluster_id = SCHLF$YEAR, necessity=TRUE)                  
              
# Get pooled, within, and between consistencies for EMP*~MA*STOCK as sufficient for EXPORT:

cluster(SCHLF, "EMP*~MA*STOCK", "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR") 
              
# Get pooled, within, and between consistencies for EMP*MA + ~STOCK as sufficient for ~EXPORT:

cluster(SCHLF, "EMP*MA + ~STOCK", "~EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR")              
</code></pre>


</div>