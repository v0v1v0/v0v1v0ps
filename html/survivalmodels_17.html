<div class="container">

<table style="width: 100%;"><tr>
<td>pchazard</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PC-Hazard Survival Neural Network</h2>

<h3>Description</h3>

<p>Logistic-Hazard fits a discrete neural network based on a cross-entropy loss
and predictions of a discrete hazard function, also known as Nnet-Survival.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pchazard(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  cuts = 10,
  cutpoints = NULL,
  scheme = c("equidistant", "quantiles"),
  cut_min = 0,
  activation = "relu",
  custom_net = NULL,
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  reduction = c("mean", "none", "sum"),
  dropout = NULL,
  device = NULL,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>(formula(1))</code><br>
Object specifying the model fit, left-hand-side of formula should describe a <code>survival::Surv()</code>
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>(data.frame(1))</code><br>
Training data of <code>data.frame</code> like object, internally is coerced with <code>stats::model.matrix()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_variable</code></td>
<td>
<p><code>(character(1))</code><br>
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status_variable</code></td>
<td>
<p><code>(character(1))</code><br>
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>(data.frame(1))</code><br>
Alternative method to call the function. Required if <code style="white-space: pre;">⁠formula, time_variable⁠</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code style="white-space: pre;">⁠([survival::Surv()])⁠</code><br>
Alternative method to call the function. Required if <code style="white-space: pre;">⁠formula, time_variable⁠</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frac</code></td>
<td>
<p><code>(numeric(1))</code> <br>
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cuts</code></td>
<td>
<p><code>(integer(1))</code><br>
If <code>discretise</code> is <code>TRUE</code> then determines number of cut-points for discretisation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutpoints</code></td>
<td>
<p><code>(numeric())</code> <br>
Alternative to <code>cuts</code> if <code>discretise</code> is true, provide exact cutpoints for discretisation.
<code>cuts</code> is ignored if <code>cutpoints</code> is non-NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheme</code></td>
<td>
<p><code>(character(1))</code><br>
Method of discretisation, either <code>"equidistant"</code> (default) or <code>"quantiles"</code>.
See <code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut_min</code></td>
<td>
<p><code>(integer(1))</code><br>
Starting duration for discretisation, see
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activation</code></td>
<td>
<p><code>(character(1))</code> <br>
See get_pycox_activation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom_net</code></td>
<td>
<p><code>(torch.nn.modules.module.Module(1))</code><br>
Optional custom network built with build_pytorch_net, otherwise default architecture used.
Note that if building a custom network the number of output channels depends on <code>cuts</code> or
<code>cutpoints</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_nodes, batch_norm, dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br>
See build_pytorch_net.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p><code>(character(1))</code><br>
How to reduce the loss, see to <code>reticulate::py_help(pycox$models$loss$NLLPCHazardLoss)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br>
Passed to <code>pycox.models.PCHazard</code>, specifies device to compute models on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping, best_weights, min_delta, patience</code></td>
<td>
<p><code style="white-space: pre;">⁠(logical(1)/logical(1)/numeric(1)/integer(1)⁠</code> <br>
See get_pycox_callbacks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.PCHazard.fit</code>, elements in each batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.PCHazard.fit</code>, number of epochs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>(logical(1))</code><br>
Passed to <code>pycox.models.PCHazard.fit</code>, should information be displayed during
fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_workers</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.PCHazard.fit</code>, number of workers used in the
dataloader.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle</code></td>
<td>
<p><code>(logical(1))</code><br>
Passed to <code>pycox.models.PCHazard.fit</code>, should order of dataset be shuffled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>ANY</code> <br>
Passed to get_pycox_optim.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.PCHazard</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>pchazard</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Kvamme, H., &amp; Borgan, Ø. (2019).
Continuous and discrete-time survival prediction with neural networks.
https://doi.org/arXiv:1910.06724.
</p>


</div>