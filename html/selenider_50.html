<div class="container">

<table style="width: 100%;"><tr>
<td>elem_expect_all</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test conditions on multiple elements</h2>

<h3>Description</h3>

<p><code>elem_expect_all()</code> and <code>elem_wait_until_all()</code> are complements to
<code>elem_expect()</code> and <code>elem_wait_until()</code> that test conditions on
multiple elements in an element collection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">elem_expect_all(x, ..., testthat = NULL, timeout = NULL)

elem_wait_until_all(x, ..., timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>selenider_elements()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>&lt;<code>dynamic-dots</code>&gt; Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be <code>TRUE</code> for the test to pass. See <code>elem_expect()</code> for more
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testthat</code></td>
<td>
<p>Whether to treat the expectation as a <code>testthat</code> test. You
<em>do not</em> need to explicitly provide this most of the time, since by
default, we can use <code>testthat::is_testing()</code> to figure out whether
<code>elem_expect()</code> is being called from within a <code>testthat</code> test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeout</code></td>
<td>
<p>The number of seconds to wait for a condition to pass. If not
specified, the timeout used for <code>x</code> will be used, or the timeout of the
local session if an element is not given.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>x</code> does not contain any elements, <code>elem_expect_all()</code> and
<code>elem_wait_until_all()</code> will succeed. You may want to first verify that
at least one element exists with <code>has_at_least()</code>.
</p>
<p><code>elem_expect_all()</code> and <code>elem_wait_until_all()</code> can be thought of as
alternatives to the use of <code>all(vapply(FUN.VALUE = logical(1)))</code> (or
<code>purrr::every()</code>) within <code>elem_expect()</code> and <code>elem_wait_until()</code>.
</p>
<p>For example, the following two expressions are equivalent (where <code>x</code> is an
element collection).
</p>
<div class="sourceCode"><pre>elem_expect(
  x,
  \(element) all(vapply(as.list(element), is_present, logical(1)))
)
elem_expect_all(x, is_present)
</pre></div>
<p>However, the second example will give a more detailed error message on
failure.
</p>


<h3>Value</h3>

<p><code>elem_expect_all()</code> returns <code>x</code>, invisibly.
</p>
<p><code>elem_wait_until_all()</code> returns a boolean flag: TRUE if the test passes,
FALSE otherwise.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>elem_expect()</code> and <code>elem_wait_until()</code>.
</p>
</li>
<li> <p><code>is_present()</code> and other conditions for predicates for HTML elements.
(If you scroll down to the <em>See also</em> section, you will find the rest).
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
html &lt;- "
&lt;div id='div1'&gt;Content 1&lt;/div&gt;
&lt;div id='div2'&gt;Content 2&lt;/div&gt;
&lt;div id='div3' style='display:none;'&gt;Content 3&lt;/div&gt;
&lt;div id='div4'&gt;Content 4&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

ss("div") |&gt;
  elem_expect_all(is_visible, timeout = 0.1) |&gt;
  try()

ss("div")[-3] |&gt;
  elem_expect_all(is_visible)

</code></pre>


</div>