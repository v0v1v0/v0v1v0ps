<div class="container">

<table style="width: 100%;"><tr>
<td>empirical.varD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Empirical Variance of H-T Density Estimate
</h2>

<h3>Description</h3>

<p>Compute Horvitz-Thompson-like estimate of population density from a
previously fitted spatial detection model, and estimate its sampling
variance using the empirical spatial variance of the number observed
in replicate sampling units. Wrapper functions are provided for
several different scenarios, but all ultimately call
<code>derivednj</code>. The function <code>derived</code> also computes
Horvitz-Thompson-like estimates, but it assumes a Poisson or binomial
distribution of total number when computing the sampling variance.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
derivednj ( nj, esa, se.esa = NULL, method = c("SRS", "R2", "R3", "local",
    "poisson", "binomial"), xy = NULL, alpha = 0.05, loginterval = TRUE, 
    area = NULL, independent.esa = FALSE )

derivedMash ( object, sessnum = NULL,  method = c("SRS", "local"),
    alpha = 0.05, loginterval = TRUE)

derivedCluster ( object, method = c("SRS", "R2", "R3", "local", "poisson", "binomial"),
    alpha = 0.05, loginterval = TRUE)

derivedSession ( object,  method = c("SRS", "R2", "R3", "local", "poisson", "binomial"), 
    xy = NULL, alpha = 0.05, loginterval = TRUE, area = NULL, independent.esa = FALSE )

derivedExternal ( object, sessnum = NULL, nj, cluster, buffer = 100,
    mask = NULL, noccasions = NULL,  method = c("SRS", "local"), xy = NULL,
    alpha = 0.05, loginterval = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>fitted secr model </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nj</code></td>
<td>
<p> vector of number observed in each sampling unit (cluster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>esa</code></td>
<td>
<p>estimate of effective sampling area (<code class="reqn">\hat{a}</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.esa</code></td>
<td>
<p> estimated standard error of effective sampling
area (<code class="reqn">\widehat{SE}(\hat{a})</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> character string ‘SRS’ or ‘local’ </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p> dataframe of x- and y- coordinates (<code>method = "local"</code> only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loginterval</code></td>
<td>
<p> logical for whether to base interval on log(N)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area</code></td>
<td>
<p> area of region for method = "binomial" (hectares) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>independent.esa</code></td>
<td>
<p>logical; controls variance contribution from esa (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sessnum</code></td>
<td>
<p> index of session in object$capthist for which output required </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> ‘traps’ object for a single cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p> width of buffer in metres (ignored if <code>mask</code>
provided) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p> mask object for a single cluster of detectors </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p>number of occasions (for <code>nj</code>) </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>derivednj</code> accepts a vector of counts (<code>nj</code>), along with
<code class="reqn">\hat{a}</code> and <code class="reqn">\widehat{SE}(\hat{a})</code>.  The
argument <code>esa</code> may be a scalar or (if se.esa is NULL) 
a 2-column matrix with <code class="reqn">\hat{a_j}</code> and
<code class="reqn">\widehat{SE}(\hat{a_j})</code> for each replicate <code class="reqn">j</code> (row). 
In the special case that <code>nj</code>
is of length 1, or <code>method</code> takes the values ‘poisson’ or
‘binomial’, the variance is computed using a theoretical variance
rather than an empirical estimate. The value of <code>method</code>
corresponds to ‘distribution’ in <code>derived</code>, and defaults to
‘poisson’. For <code>method = 'binomial'</code> you must specify <code>area</code>
(see Examples).
</p>
<p>If <code>independent.esa</code> is TRUE then independence is assumed among 
cluster-specific estimates of esa, and esa variances are summed. The default 
is a weighted sum leading to higher overall variance.
</p>
<p><code>derivedCluster</code> accepts a model fitted to data from clustered
detectors; each cluster is interpreted as a replicate
sample. It is assumed that the sets of individuals sampled by
different clusters do not intersect, and that all clusters have the
same geometry (spacing, detector number etc.).
</p>
<p><code>derivedMash</code> accepts a model fitted to clustered data that have
been ‘mashed’ for fast processing (see <code>mash</code>); each
cluster is a replicate sample: the function uses the vector of cluster
frequencies (<code class="reqn">n_j</code>) stored as an attribute of the mashed
<code>capthist</code> by <code>mash</code>.
</p>
<p><code>derivedExternal</code> combines detection parameter estimates from a
fitted model with a vector of frequencies <code>nj</code> from replicate
sampling units configured as in <code>cluster</code>. Detectors in
<code>cluster</code> are assumed to match those in the fitted model with
respect to type and efficiency, but sampling duration
(<code>noccasions</code>), spacing etc. may differ. The <code>mask</code> should
match <code>cluster</code>; if <code>mask</code> is missing, one will be
constructed using the <code>buffer</code> argument and defaults from
<code>make.mask</code>.
</p>
<p><code>derivedSession</code> accepts a single fitted model that must span
multiple sessions; each session is interpreted as a replicate sample.
</p>
<p>Spatial variance is calculated by one of these methods
</p>

<table>
<tr>
<td style="text-align: left;">
  Method </td>
<td style="text-align: left;"> Description </td>
</tr>
<tr>
<td style="text-align: left;">

<code>"SRS"</code> </td>
<td style="text-align: left;"> simple random sampling with identical clusters </td>
</tr>
<tr>
<td style="text-align: left;">
<code>"R2"</code> </td>
<td style="text-align: left;"> variable cluster size cf Thompson (2002:70) estimator for line transects </td>
</tr>
<tr>
<td style="text-align: left;">
<code>"R3"</code> </td>
<td style="text-align: left;"> variable cluster size cf Buckland et al. (2001)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>"local"</code> </td>
<td style="text-align: left;"> neighbourhood variance estimator (Stevens and Olsen 2003) SUSPENDED in 4.4.7 </td>
</tr>
<tr>
<td style="text-align: left;"> 
<code>"poisson"</code> </td>
<td style="text-align: left;"> theoretical (model-based) variance </td>
</tr>
<tr>
<td style="text-align: left;">
<code>"binomial"</code> </td>
<td style="text-align: left;"> theoretical (model-based) variance in given <code>area</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The weighted options R2 and R3 substitute <code class="reqn">\hat{a_j}</code> for line length <code class="reqn">l_k</code> in the corresponding formulae of Fewster et al. (2009, Eq 3,5). Density is estimated by <code class="reqn">D = n/A</code> where <code class="reqn">A = \sum a_j</code>. The variance of <code class="reqn">A</code> is estimated as the sum of the cluster-specific variances, assuming independence among clusters. Fewster et al. (2009) found that an alternative estimator for line transects derived by Thompson (2002) performed better when there were strong density gradients correlated with line length (R2 in Fewster et al. 2009, Eq 3).
</p>
<p>The neighborhood variance estimator is implemented in package <span class="pkg">spsurvey</span> and was originally proposed for generalized random tessellation stratified (GRTS) samples.  For ‘local’ variance
estimates, the centre of each replicate must be provided in <code>xy</code>,
except where centres may be inferred from the data. It is unclear whether ‘local’ can or should be used when clusters vary in size.
</p>
<p><code>derivedSystematic</code>, now defunct, was an experimental function in earlier versions of <span class="pkg">secr</span>.
</p>


<h3>Value</h3>

<p>Dataframe with one row for each derived parameter (‘esa’, ‘D’) and
columns as below
</p>

<table>
<tr>
<td style="text-align: left;">
estimate    </td>
<td style="text-align: left;"> estimate of derived parameter </td>
</tr>
<tr>
<td style="text-align: left;">
SE.estimate </td>
<td style="text-align: left;"> standard error of the estimate </td>
</tr>
<tr>
<td style="text-align: left;">
lcl         </td>
<td style="text-align: left;"> lower 100(1--alpha)% confidence limit </td>
</tr>
<tr>
<td style="text-align: left;">
ucl         </td>
<td style="text-align: left;"> upper 100(1--alpha)% confidence limit </td>
</tr>
<tr>
<td style="text-align: left;">
CVn         </td>
<td style="text-align: left;"> relative SE of number observed (across sampling units) </td>
</tr>
<tr>
<td style="text-align: left;">
CVa         </td>
<td style="text-align: left;"> relative SE of effective sampling area </td>
</tr>
<tr>
<td style="text-align: left;">
CVD         </td>
<td style="text-align: left;"> relative SE of density estimate </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Note</h3>

<p>The variance of a Horvitz-Thompson-like estimate of density may be
estimated as the sum of two components, one due to uncertainty in the
estimate of effective sampling area (<code class="reqn">\hat{a}</code>) and the
other due to spatial variance in the total number of animals <code class="reqn">n</code>
observed on <code class="reqn">J</code> replicate sampling units (<code class="reqn">n =
    \sum_{j=1}^{J}{n_j}</code>). We use a delta-method approximation
that assumes independence of the components:
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{\mbox{var}}(\hat{D}) = \hat{D}^2
    \{\frac{\widehat{\mbox{var}}(n)}{n^2} +
    \frac{\widehat{\mbox{var}}(\hat{a})}{\hat{a}^2}\} </code>
</p>

<p>where <code class="reqn">\widehat{\mbox{var}}(n) = \frac{J}{J-1}
  \sum_{j=1}^{J}(n_j-n/J)^2</code>. The
estimate of <code class="reqn">\mbox{var}(\hat{a})</code> is model-based while
that of <code class="reqn">\mbox{var}(n)</code> is design-based. This formulation follows
that of Buckland et al. (2001, p. 78) for conventional distance
sampling. Given sufficient independent replicates, it is a robust way
to allow for unmodelled spatial overdispersion.
</p>
<p>There is a complication in SECR owing to the fact that
<code class="reqn">\hat{a}</code> is a derived quantity (actually an integral)
rather than a model parameter. Its sampling variance
<code class="reqn">\mbox{var}(\hat{a})</code> is estimated indirectly in
<span class="pkg">secr</span> by combining the asymptotic estimate of the covariance
matrix of the fitted detection parameters <code class="reqn">\theta</code> with a
numerical estimate of the gradient of <code class="reqn">a(\theta)</code> with
respect to <code class="reqn">\theta</code>. This calculation is performed in
<code>derived</code>.
</p>


<h3>References</h3>

<p>Buckland, S. T., Anderson, D. R., Burnham, K. P., Laake, J. L., Borchers,
D. L. and Thomas, L. (2001) <em>Introduction to Distance Sampling:
Estimating Abundance of Biological Populations</em>. Oxford University
Press, Oxford.
</p>
<p>Fewster, R. M. (2011) Variance estimation for systematic designs in spatial 
surveys. <em>Biometrics</em> <b>67</b>, 1518–1531.
</p>
<p>Fewster, R. M., Buckland, S. T., Burnham, K. P., Borchers, D. L., Jupp, P. E., 
Laake, J. L. and Thomas, L. (2009) Estimating the encounter rate variance in 
distance sampling. <em>Biometrics</em> <b>65</b>, 225–236. 
</p>
<p>Stevens, D. L. Jr and Olsen, A. R. (2003) Variance estimation for
spatially balanced samples of environmental resources.
<em>Environmetrics</em> <b>14</b>, 593–610.
</p>
<p>Thompson, S. K. (2002) <em>Sampling</em>. 2nd edition. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code>derived</code>, <code>esa</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## The `ovensong' data are pooled from 75 replicate positions of a
## 4-microphone array. The array positions are coded as the first 4
## digits of each sound identifier. The sound data are initially in the
## object `signalCH'. We first impose a 52.5 dB signal threshold as in
## Dawson &amp; Efford (2009, J. Appl. Ecol. 46:1201--1209). The vector nj
## includes 33 positions at which no ovenbird was heard. The first and
## second columns of `temp' hold the estimated effective sampling area
## and its standard error.

## Not run: 

signalCH.525 &lt;- subset(signalCH, cutval = 52.5)
nonzero.counts &lt;- table(substring(rownames(signalCH.525),1,4))
nj &lt;- c(nonzero.counts, rep(0, 75 - length(nonzero.counts)))
temp &lt;- derived(ovensong.model.1, se.esa = TRUE)
derivednj(nj, temp["esa",1:2])

## The result is very close to that reported by Dawson &amp; Efford
## from a 2-D Poisson model fitted by maximizing the full likelihood.

## If nj vector has length 1, a theoretical variance is used...
msk &lt;- ovensong.model.1$mask
A &lt;- nrow(msk) * attr(msk, "area")
derivednj (sum(nj), temp["esa",1:2], method = "poisson")
derivednj (sum(nj), temp["esa",1:2], method = "binomial", area = A)

## Set up an array of small (4 x 4) grids,
## simulate a Poisson-distributed population,
## sample from it, plot, and fit a model.
## mash() condenses clusters to a single cluster

testregion &lt;- data.frame(x = c(0,2000,2000,0),
    y = c(0,0,2000,2000))
t4 &lt;- make.grid(nx = 4, ny = 4, spacing = 40)
t4.16 &lt;- make.systematic (n = 16, cluster = t4,
    region = testregion)
popn1 &lt;- sim.popn (D = 5, core = testregion,
    buffer = 0)
capt1 &lt;- sim.capthist(t4.16, popn = popn1)
fit1 &lt;- secr.fit(mash(capt1), CL = TRUE, trace = FALSE)

## Visualize sampling
tempmask &lt;- make.mask(t4.16, spacing = 10, type =
    "clusterbuffer")
plot(tempmask)
plot(t4.16, add = TRUE)
plot(capt1, add = TRUE)

## Compare model-based and empirical variances.
## Here the answers are similar because the data
## were simulated from a Poisson distribution,
## as assumed by \code{derived}

derived(fit1)
derivedMash(fit1)

## Now simulate a patchy distribution; note the
## larger (and more credible) SE from derivedMash().

popn2 &lt;- sim.popn (D = 5, core = testregion, buffer = 0,
    model2D = "hills", details = list(hills = c(-2,3)))
capt2 &lt;- sim.capthist(t4.16, popn = popn2)
fit2 &lt;- secr.fit(mash(capt2), CL = TRUE, trace = FALSE)
derived(fit2)
derivedMash(fit2)

## The detection model we have fitted may be extrapolated to
## a more fine-grained systematic sample of points, with
## detectors operated on a single occasion at each...
## Total effort 400 x 1 = 400 detector-occasions, compared
## to 256 x 5 = 1280 detector-occasions for initial survey.

t1 &lt;- make.grid(nx = 1, ny = 1)
t1.100 &lt;- make.systematic (cluster = t1, spacing = 100,
    region = testregion)
capt2a &lt;- sim.capthist(t1.100, popn = popn2, noccasions = 1)
## one way to get number of animals per point
nj &lt;- attr(mash(capt2a), "n.mash")
derivedExternal (fit2, nj = nj, cluster = t1, buffer = 100,
    noccasions = 1)

## Review plots
base.plot &lt;- function() {
    MASS::eqscplot( testregion, axes = FALSE, xlab = "",
        ylab = "", type = "n")
    polygon(testregion)
}
par(mfrow = c(1,3), xpd = TRUE, xaxs = "i", yaxs = "i")
base.plot()
plot(popn2, add = TRUE, col = "blue")
mtext(side=3, line=0.5, "Population", cex=0.8, col="black")
base.plot()
plot (capt2a, add = TRUE,title = "Extensive survey")
base.plot()
plot(capt2, add = TRUE, title = "Intensive survey")
par(mfrow = c(1,1), xpd = FALSE, xaxs = "r", yaxs = "r")  ## defaults


## Weighted variance

derivedSession(ovenbird.model.1, method = "R2")


## End(Not run)

</code></pre>


</div>