<div class="container">

<table style="width: 100%;"><tr>
<td>RadixTree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RadixTree</h2>

<h3>Description</h3>

<p>Radix Tree (trie) class implementation
</p>


<h3>Details</h3>

<p>The RadixTree class is a trie implementation. The primary usage is to be able to search of similar sequences based on a dynamic programming framework.
This can be done using the <em>search</em> method which searches for similar sequences based on the Global, Anchored or Hamming distance metrics.
</p>
<p>Three types of distance metrics are supported, based on the form of alignment performed. These are: Hamming, Global (Levenshtein) and Anchored.
</p>
<p>An anchored alignment is a form of semi-global alignment, where the query sequence is "anchored" (global) to the beginning of both the query and target sequences,
but is semi-global in that the end of the either the query sequence or target sequence (but not both) can be unaligned. This type of alignment is sometimes called an "extension" alignment in literature.
</p>
<p>In contrast a global alignment must align the entire query and target sequences. When mismatch and indel costs are equal to 1, this is also known as the Levenshtein distance.
</p>
<p>By default, if mode == "global" or "anchored", all mismatches and indels are given a cost of 1. However, you can define your own distance metric by setting the cost_matrix and gap parameters.
The cost_matrix is a strictly positive square integer matrix and should include all characters in query and target as column- and rownames.
To set the cost of a gap (insertion or deletion) you can include a row and column named "gap" in the cost_matrix <em>OR</em> set the gap_cost parameter (a single positive integer).
Similarly, the affine gap alignment can be set by including a row and column named "gap_open" in the cost_matrix <em>OR</em> setting the gap_open_cost parameter (a single positive integer).
If affine alignment is used, the cost of a gap is defined as:
TOTAL_GAP_COST = gap_open_cost + (gap_cost * gap_length).
</p>
<p>If mode == "hamming" all alignment parameters are ignored; mismatch is given a distance of 1 and gaps are not allowed.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>root_pointer</code></dt>
<dd>
<p>Root of the RadixTree</p>
</dd>
<dt><code>char_counter_pointer</code></dt>
<dd>
<p>Character count data for the purpose of validating input</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RadixTree-new"><code>RadixTree$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-show"><code>RadixTree$show()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-to_string"><code>RadixTree$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-graph"><code>RadixTree$graph()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-to_vector"><code>RadixTree$to_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-size"><code>RadixTree$size()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-insert"><code>RadixTree$insert()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-erase"><code>RadixTree$erase()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-find"><code>RadixTree$find()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-prefix_search"><code>RadixTree$prefix_search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-search"><code>RadixTree$search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-validate"><code>RadixTree$validate()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-RadixTree-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new RadixTree object
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$new(sequences = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt>
<dd>
<p>A character vector of sequences to insert into the tree</p>
</dd>
</dl>
</div>


<hr>
<a id="method-RadixTree-show"></a>



<h4>Method <code>show()</code>
</h4>

<p>Print the tree to screen
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$show()</pre></div>


<hr>
<a id="method-RadixTree-to_string"></a>



<h4>Method <code>to_string()</code>
</h4>

<p>Print the tree to a string
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$to_string()</pre></div>



<h5>Returns</h5>

<p>A string representation of the tree
</p>


<hr>
<a id="method-RadixTree-graph"></a>



<h4>Method <code>graph()</code>
</h4>

<p>Plot of the tree using igraph (needs to be installed separately)
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$graph(depth = -1, root_label = "root", plot = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>depth</code></dt>
<dd>
<p>The tree depth to plot. If -1 (default), plot the entire tree.</p>
</dd>
<dt><code>root_label</code></dt>
<dd>
<p>The label of the root node in the plot.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>Whether to create a plot or return the data used to generate the plot.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A data frame of parent-child relationships used to generate the igraph plot OR a ggplot2 object
</p>


<hr>
<a id="method-RadixTree-to_vector"></a>



<h4>Method <code>to_vector()</code>
</h4>

<p>Output all sequences held by the tree as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$to_vector()</pre></div>



<h5>Returns</h5>

<p>A character vector of all sequences contained in the tree. Return order is not guaranteed.
</p>


<hr>
<a id="method-RadixTree-size"></a>



<h4>Method <code>size()</code>
</h4>

<p>Output the size of the tree (i.e. how many sequences are contained)
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$size()</pre></div>



<h5>Returns</h5>

<p>The size of the tree
</p>


<hr>
<a id="method-RadixTree-insert"></a>



<h4>Method <code>insert()</code>
</h4>

<p>Insert new sequences into the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$insert(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt>
<dd>
<p>A character vector of sequences to insert into the tree</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was inserted (TRUE) or already existing in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-erase"></a>



<h4>Method <code>erase()</code>
</h4>

<p>Erase sequences from the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$erase(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt>
<dd>
<p>A character vector of sequences to erase from the tree</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was erased (TRUE) or not found in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-find"></a>



<h4>Method <code>find()</code>
</h4>

<p>Find sequences in the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$find(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt>
<dd>
<p>A character vector of sequences to find in the tree</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was found (TRUE) or not found in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-prefix_search"></a>



<h4>Method <code>prefix_search()</code>
</h4>

<p>Search for sequences in the tree that start with a specified prefix.
E.g.: a query of "CAR" will find "CART", "CARBON", "CARROT", etc. but not "CATS".
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$prefix_search(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt>
<dd>
<p>A character vector of sequences to search for in the tree</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A data frame of all matches with columns "query" and "target".
</p>


<hr>
<a id="method-RadixTree-search"></a>



<h4>Method <code>search()</code>
</h4>

<p>Search for sequences in the tree that are with a specified distance metric to a specified query.
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$search(
  query,
  max_distance = NULL,
  max_fraction = NULL,
  mode = "levenshtein",
  cost_matrix = NULL,
  gap_cost = NULL,
  gap_open_cost = NULL,
  nthreads = 1,
  show_progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt>
<dd>
<p>A character vector of query sequences.</p>
</dd>
<dt><code>max_distance</code></dt>
<dd>
<p>how far to search in units of absolute distance. Can be a single value or a vector. Mutually exclusive with max_fraction.</p>
</dd>
<dt><code>max_fraction</code></dt>
<dd>
<p>how far to search in units of relative distance to each query sequence length. Can be a single value or a vector. Mutually exclusive with max_distance.</p>
</dd>
<dt><code>mode</code></dt>
<dd>
<p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</dd>
<dt><code>cost_matrix</code></dt>
<dd>
<p>A custom cost matrix for use with the "global" or "anchored" distance metrics. See details.</p>
</dd>
<dt><code>gap_cost</code></dt>
<dd>
<p>The cost of a gap for use with the "global" or "anchored" distance metrics. See details.</p>
</dd>
<dt><code>gap_open_cost</code></dt>
<dd>
<p>The cost of a gap opening. See details.</p>
</dd>
<dt><code>nthreads</code></dt>
<dd>
<p>The number of threads to use for parallel computation.</p>
</dd>
<dt><code>show_progress</code></dt>
<dd>
<p>Whether to show a progress bar.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The output is a data.frame of all matches with columns "query" and "target".
For anchored searches, the output also includes attributes "query_size" and "target_size" which are vectors containing the portion of the query and target sequences that are aligned.
</p>


<hr>
<a id="method-RadixTree-validate"></a>



<h4>Method <code>validate()</code>
</h4>

<p>Validate the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$validate()</pre></div>



<h5>Returns</h5>

<p>A logical indicating whether the tree is valid (TRUE) or not (FALSE). This is mostly an internal function for debugging purposes and should always return TRUE.
</p>




<h3>See Also</h3>

<p>https://en.wikipedia.org/wiki/Radix_tree
</p>


<h3>Examples</h3>

<pre><code class="language-R">tree &lt;- RadixTree$new()
tree$insert(c("ACGT", "AAAA"))
tree$erase("AAAA")
tree$search("ACG", max_distance = 1, mode = "levenshtein")
#   query target distance
# 1   ACG   ACGT        1

tree$search("ACG", max_distance = 1, mode = "hamming")
# query    target   distance
# &lt;0 rows&gt; (or 0-length row.names)
</code></pre>


</div>