<div class="container">

<table style="width: 100%;"><tr>
<td>mpost.euc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Median Posterior for Subset Posterior Samples in Euclidean Space</h2>

<h3>Description</h3>

<p><code>mpost.euc</code> is a general framework to <em>merge</em> multiple 
empirical measures <code class="reqn">Q_1,Q_2,\ldots,Q_M \subset R^p</code> from independent subset of data by finding a median 
</p>
<p style="text-align: center;"><code class="reqn">\hat{Q} = \textrm{argmin}_Q \sum_{m=1}^M d(Q,Q_m)</code>
</p>

<p>where <code class="reqn">Q</code> is a weighted combination and <code class="reqn">d(P_1,P_2)</code> is distance in RKHS between two empirical measures <code class="reqn">P_1</code> and <code class="reqn">P_2</code>. 
As in the references, we use RBF kernel with bandwidth parameter <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mpost.euc(
  splist,
  sigma = 0.1,
  maxiter = 121,
  abstol = 1e-06,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>splist</code></td>
<td>
<p>a list of length <code class="reqn">M</code> containing vectors or matrices of univariate or multivariate subset posterior samples respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>bandwidth parameter for RBF kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations for Weiszfeld algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>stopping criterion for Weiszfeld algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.progress</code></td>
<td>
<p>a logical; <code>TRUE</code> to show iteration mark, <code>FALSE</code> otherwise.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a named list containing:
</p>

<dl>
<dt>med.atoms</dt>
<dd>
<p>a vector or matrix of all atoms aggregated.</p>
</dd>
<dt>med.weights</dt>
<dd>
<p>a weight vector that sums to 1 corresponding to <code>med.atoms</code>.</p>
</dd>
<dt>weiszfeld.weights</dt>
<dd>
<p>a weight for <code class="reqn">M</code> subset posteriors.</p>
</dd>
<dt>weiszfeld.history</dt>
<dd>
<p>updated parameter values. Each row is for iteration, while columns are weights corresponding to <code>weiszfeld.weights</code>.</p>
</dd>
</dl>
<h3>References</h3>

<p>Minsker S, Srivastava S, Lin L, Dunson DB (2014).
“Scalable and Robust Bayesian Inference via the Median Posterior.”
In <em>Proceedings of the 31st International Conference on International Conference on Machine Learning - Volume 32</em>,  ICML’14, II–1656–II–1664.
event-place: Beijing, China.
</p>
<p>Minsker S, Srivastava S, Lin L, Dunson DB (2017).
“Robust and Scalable Bayes via a Median of Subset Posterior Measures.”
<em>Journal of Machine Learning Research</em>, <b>18</b>(124), 1–40.
<a href="https://jmlr.org/papers/v18/16-655.html">https://jmlr.org/papers/v18/16-655.html</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Median Posteior from 2-D Gaussian Samples
#  Step 1. let's build a list of atoms whose numbers differ
set.seed(8128)                   # for reproducible results
mydata = list()
mydata[[1]] = cbind(rnorm(96, mean= 1), rnorm(96, mean= 1))
mydata[[2]] = cbind(rnorm(78, mean=-1), rnorm(78, mean= 0))
mydata[[3]] = cbind(rnorm(65, mean=-1), rnorm(65, mean= 1))
mydata[[4]] = cbind(rnorm(77, mean= 2), rnorm(77, mean=-1))

#  Step 2. Let's run the algorithm
myrun = mpost.euc(mydata, show.progress=TRUE)

#  Step 3. Visualize
#  3-1. show subset posterior samples
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), no.readonly=TRUE)
for (i in 1:4){
  plot(mydata[[i]], cex=0.5, col=(i+1), pch=19, xlab="", ylab="", 
       main=paste("subset",i), xlim=c(-4,4), ylim=c(-3,3))
}

#  3-2. 250 median posterior samples via importance sampling
id250 = base::sample(1:nrow(myrun$med.atoms), 250, prob=myrun$med.weights, replace=TRUE)
sp250 = myrun$med.atoms[id250,]
plot(sp250, cex=0.5, pch=19, xlab="", ylab="", 
     xlim=c(-4,4), ylim=c(-3,3), main="median samples")

#  3-3. convergence over iterations
matplot(myrun$weiszfeld.history, xlab="iteration", ylab="value",
        type="b", main="convergence of weights")
par(opar)
        
</code></pre>


</div>