<div class="container">

<table style="width: 100%;"><tr>
<td>sobol_matrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creation of the sample matrices</h2>

<h3>Description</h3>

<p>It creates the sample matrices to compute Sobol' first and total-order indices.
If needed, it also creates the sample matrices required to compute second,
third and fourth-order indices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sobol_matrices(
  matrices = c("A", "B", "AB"),
  N,
  params,
  order = "first",
  type = "QRN",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrices</code></td>
<td>
<p>Character vector with the required matrices. The default
is <code>matrices = c("A", "B", "AB")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Positive integer, initial sample size of the base sample matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>One of "first", "second", "third" or "fourth" to create a matrix to
compute first, second, third or up to fourth-order Sobol' indices. The default is
<code>order = "first"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Approach to construct the sample matrix. Options are:
</p>

<ul>
<li> <p><code>type = "QRN"</code> (default): It uses Sobol' (1967) Quasi-Random Numbers.
through a call to the function <code>sobol</code> of the <code>randtoolbox</code> package.
</p>
</li>
<li> <p><code>type = "LHS"</code>: It uses a Latin Hypercube Sampling Design
(McKay et al. 1979) through a call
to the function <code>randomLHS</code> of the <code>lhs</code> package.
</p>
</li>
<li> <p><code>type = "R"</code>: It uses random numbers.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments in <code>sobol</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Before calling <code>sobol_matrices</code>, the user must decide which estimators
will be used to compute first and total-order indices, for this option conditions
the design of the sample matrix and therefore the argument <code>matrices</code>.
See Table 3 in the vignette for further details on the specific sampling designs required by
the estimators.
</p>
<p>The user can select one of the following sampling designs:
</p>

<ul>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{A}_B^{(i)}</code>.
</p>
</li>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{B}_A^{(i)}</code>.
</p>
</li>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{A}_B^{(i)}</code>, <code class="reqn">\mathbf{B}_A^{(i)}</code>.
</p>
</li>
</ul>
<p>If <code>order = "first"</code>, the function creates an <code class="reqn">(N, 2k)</code> matrix according to the approach defined by
<code>type</code>, where the leftmost and the rightmost <code class="reqn">k</code> columns are respectively allocated
to the <code class="reqn">\mathbf{A}</code> and the <code class="reqn">\mathbf{B}</code> matrix. Depending on the sampling design, it
also creates <code class="reqn">k</code> <code class="reqn">\mathbf{A}_B^{(i)}</code> (<code class="reqn">\mathbf{B}_A^{(i)}</code>) matrices, where all
columns come from <code class="reqn">\mathbf{A}</code> (<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th, which comes from
<code class="reqn">\mathbf{B}</code> (<code class="reqn">\mathbf{A}</code>). All matrices are returned row-binded.
</p>
<p>If <code>order = "second"</code>, <code class="reqn">\frac{k!}{2!(k-2)!}</code> extra <code class="reqn">(N, k)</code> <code class="reqn">\mathbf{A}_B^{(ij)}</code>
(<code class="reqn">\mathbf{B}_A^{(ij)}</code>) matrices are created, where all columns come from <code class="reqn">\mathbf{A}</code>
(<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th and <code class="reqn">j</code>-th, which come from <code class="reqn">\mathbf{B}</code>
(<code class="reqn">\mathbf{A}</code>). These matrices allow the computation of second-order effects, and are row-bound
to those created for first and total-order indices.
</p>
<p>If <code>order = "third"</code>, <code class="reqn">\frac{k!}{3!(k-3)!}</code> extra <code class="reqn">(N, k)</code> <code class="reqn">\mathbf{A}_B^{(ijl)}</code>
(<code class="reqn">\mathbf{B}_A^{(ijl)}</code>) matrices are bound below those created
for the computation of second-order effects. In these matrices, all columns come from <code class="reqn">\mathbf{A}</code>
(<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th, the <code class="reqn">j</code>-th and the <code class="reqn">l</code>-th, which come from <code class="reqn">\mathbf{B}</code>
(<code class="reqn">\mathbf{A}</code>). These matrices are needed to compute third-order effects, and are row-bound below
those created for second-order effects.
</p>
<p>The same process applies to create the matrices to compute fourth-order effects.
</p>
<p>All columns are distributed in (0,1). If the uncertainty in some parameter(s) is better described with
another distribution, the user should apply the required quantile inverse transformation to the column of
interest once the sample matrix is produced.
</p>


<h3>Value</h3>

<p>A numeric matrix where each column is a model input distributed in (0,1) and each row
a sampling point.
</p>


<h3>References</h3>

<p>McKay MD, Beckman RJ, Conover WJ (1979).
“Comparison of three methods for selecting values of input variables in the analysis of output from a computer code.”
<em>Technometrics</em>, <b>21</b>(2), 239–245.
<a href="https://doi.org/10.1080/00401706.1979.10489755">doi:10.1080/00401706.1979.10489755</a>.<br><br> Sobol' IM (1967).
“On the distribution of points in a cube and the approximate evaluation of integrals.”
<em>USSR Computational Mathematics and Mathematical Physics</em>, <b>7</b>(4), 86–112.
<a href="https://doi.org/10.1016/0041-5553%2867%2990144-9">doi:10.1016/0041-5553(67)90144-9</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define settings
N &lt;- 100; params &lt;- paste("X", 1:10, sep = ""); order &lt;-  "third"

# Create sample matrix using Sobol' Quasi Random Numbers.
mat &lt;- sobol_matrices(N = N, params = params, order = order)

# Let's assume that the uncertainty in X3 is better described
# with a normal distribution with mean 0 and standard deviation 1:
mat[, 3] &lt;- qnorm(mat[, 3], 0, 1)
</code></pre>


</div>