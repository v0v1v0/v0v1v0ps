<div class="container">

<table style="width: 100%;"><tr>
<td>psMle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum pseudo-likelihood estimation by wrapped pseudo-likelihoods</h2>

<h3>Description</h3>

<p>Maximum pseudo-likelihood using the Euler and Shoji–Ozaki
pseudo-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">psMle(data, delta, method = c("E", "SO", "SO2"), b, jac.b, sigma2, b1, b2,
  start, lower, upper, circular = TRUE, maxK = 2, vmApprox = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>discretization step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string for choosing <code>"E"</code> (Euler), <code>"SO"</code>
(Shoji–Ozaki) or <code>"SO2"</code> (Shoji–Ozaki with Ito's expansion in the
drift) method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>drift function. Must return a matrix of the same size as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jac.b</code></td>
<td>
<p>jacobian of the drift function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>diagonal of the diffusion matrix (if univariate, this is the
square of the diffusion coefficient). Must return an object of the same
size as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>first derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b2</code></td>
<td>
<p>second derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circular</code></td>
<td>
<p>flag to indicate circular data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vmApprox</code></td>
<td>
<p>flag to indicate von Mises approximation to wrapped normal.
See<br><code>momentMatchWnVm</code> and <code>scoreMatchWnBvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters passed to <code>mleOptimWrapper</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See Section 3.2 in García-Portugués et al. (2019) for details.
<code>"SO2"</code> implements Shoji and Ozai (1998)'s expansion with for
<code>p = 1</code>. <code>"SO"</code> is the same expansion, for arbitrary <code>p</code>,
but considering null second derivatives.
</p>


<h3>Value</h3>

<p>Output from <code>mleOptimWrapper</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1–22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>
<p>Shoji, I. and Ozaki, T. (1998) A statistical method of estimation and
simulation for systems of stochastic differential equations.
<em>Biometrika</em>, 85(1):240–243. <a href="https://doi.org/10.1093/biomet/85.1.240">doi:10.1093/biomet/85.1.240</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Example in 1D

delta &lt;- 0.5
pars &lt;- c(0.25, 0, 2)
set.seed(12345678)
samp &lt;- rTrajWn1D(x0 = 0, alpha = pars[1], mu = pars[2], sigma = pars[3],
                  N = 100, delta = delta)
b &lt;- function(x, pars) driftWn1D(x = x, alpha = pars[1], mu = pars[2],
                                 sigma = pars[3], maxK = 2, expTrc = 30)
b1 &lt;- function(x, pars, h = 1e-4) {
  l &lt;- length(x)
  res &lt;- b(x = c(x + h, x - h), pars = pars)
  drop(res[1:l] - res[(l + 1):(2 * l)])/(2 * h)
}
b2 &lt;- function(x, pars, h = 1e-4) {
  l &lt;- length(x)
  res &lt;- b(x = c(x + h, x, x - h), pars = pars)
  drop(res[1:l] - 2 * res[(l + 1):(2 * l)] + res[(2 * l + 1):(3 * l)])/(h^2)
}
sigma2 &lt;- function(x, pars) rep(pars[3]^2, length(x))
lower &lt;- c(0.1, -pi, 0.1)
upper &lt;- c(10, pi, 10)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO2", b = b, b1 = b1,
      b2 = b2, sigma2 = sigma2, start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "SO2", b = b, b1 = b1,
      b2 = b2, sigma2 = sigma2, start = pars, lower = lower,
      upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO", b = b, b1 = b1,
      lower = lower, upper = upper, sigma2 = sigma2, start = pars)
approxMleWn1D(data = samp, delta = delta, start = pars)
mlePde1D(data = samp, delta = delta, b = b, sigma2 = sigma2,
         start = pars, lower = lower, upper = upper)

# Example in 2D

delta &lt;- 0.5
pars &lt;- c(1, 0.5, 0, 0, 0, 1, 2)
set.seed(12345678)
samp &lt;- rTrajWn2D(x0 = c(0, 0), alpha = pars[1:3], mu = pars[4:5],
                  sigma = pars[6:7], N = 100, delta = delta)
b &lt;- function(x, pars) driftWn2D(x = x, A = alphaToA(alpha = pars[1:3],
                                                     sigma = pars[6:7]),
                                 mu = pars[4:5], sigma = pars[6:7], maxK = 2,
                                 expTrc = 30)
jac.b &lt;- function(x, pars, h = 1e-4) {
  l &lt;- nrow(x)
  res &lt;- b(x = rbind(cbind(x[, 1] + h, x[, 2]),
                     cbind(x[, 1] - h, x[, 2]),
                     cbind(x[, 1], x[, 2] + h),
                     cbind(x[, 1], x[, 2] - h)), pars = pars)
  cbind(res[1:l, ] - res[(l + 1):(2 * l), ],
        res[2 * l + 1:l, ] - res[2 * l + (l + 1):(2 * l), ]) / (2 * h)
}
sigma2 &lt;- function(x, pars) matrix(pars[6:7]^2, nrow = length(x) / 2L,
                                   ncol = 2)
lower &lt;- c(0.01, 0.01, -25, -pi, -pi, 0.01, 0.01)
upper &lt;- c(25, 25, 25, pi, pi, 25, 25)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO", b = b, jac.b = jac.b,
      sigma2 = sigma2, start = pars, lower = lower, upper = upper)
approxMleWn2D(data = samp, delta = delta, start = c(pars, 0))
# Set maxit = 5 to test and avoid a very long evaluation
mlePde2D(data = samp, delta = delta, b = b, sigma2 = sigma2, start = pars,
         lower = lower, upper = upper, maxit = 5)

</code></pre>


</div>