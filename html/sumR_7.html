<div class="container">

<table style="width: 100%;"><tr>
<td>precompiled</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>List of precompiled functions in the sumR package</h2>

<h3>Description</h3>

<p>More functions are periodically added to this list for convenience and speed.
These functions are all evaluated in the log scale and pass the ratio test,
that is, the limit of
a<sub>n+1</sub>/a<sub>n</sub> as n
goes to infinity is a value <code class="reqn">0 \le L &lt; 1</code>. The value of <code class="reqn">L</code> is
indicated in each entry. It is calculated automatically when the precompiled
functions are used in the summation.
</p>


<h3>Conway-Maxwell-Poisson normalizing constant</h3>

<p>This series is the kernel of the Conway-Maxwell-Poisson distribution, which
generalizes the Poisson and Geometric distributions. Its form is
</p>
<div style="text-align: center;">a<sub>n</sub> = λ<sup>n</sup> / (n!)<sup>ν</sup>
</div> 
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">\lambda &gt; 0</code> and <code class="reqn">\nu &gt; 0</code>.
</p>
<p>When <code class="reqn">\nu = 1</code>, this series reduces to the Poisson distribution kernel
and the sum (in the log scale) is known to be <code class="reqn">\lambda</code>. When
<code class="reqn">\nu = 0</code> and <code class="reqn">0 &lt; \lambda &lt; 1</code>, the series reduces to the Geometric
distribution kernel with parameter <code class="reqn">1 - \lambda</code>. The series is known to
sum to <code class="reqn">1</code>. Finally, as <code class="reqn">\nu</code> goes to <code class="reqn">\infty</code> the distribution
approaches a Bernoulli distribution with parameter
<code class="reqn">\lambda / (1 - \lambda)</code>.
</p>
<p>Another known result is when <code class="reqn">\nu = 2</code>, in which case the sum is the
modified Bessel function of the first kind of order 0 evaluated at
<code class="reqn">2\sqrt{\lambda}</code>.
</p>

<ul>
<li>
<p> String to access the precompiled function: <code>"COMP"</code>.
</p>
</li>
<li>
<p> parameter vector: <code>c(lambda, nu)</code>.
</p>
</li>
</ul>
<h3>Double Poisson normalizing constant</h3>

<p>This series is the kernel of the double Poisson distribution, which is a
special case of the double exponential family, which extends it. Its form is
</p>
<p>GP8hIamkYKW8vjk522fKO6UJeQQQJDLi</p>
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">\lambda &gt; 0</code> and <code class="reqn">\phi &gt; 0</code>.
</p>
<p>When <code class="reqn">\phi = 1</code>, this series reduces to the Poisson distribution kernel
and the sum (in the log scale) is known to be 0.
</p>

<ul>
<li>
<p> String to acccess the precompiled function: <code>"double_poisson"</code>.
</p>
</li>
<li>
<p> parameter vector: <code>c(mu, phi)</code>
</p>
</li>
</ul>
<h3>Modified Bessel function of the first kind</h3>

<p>This is the series form solution for the function. There are more time
efficient methods for its evaluation however they don't guarantee good
approximations with large parameters. Its form is
</p>
<p>eIRg2OKn53IgRwNmD9X5651peTXEIwvW-1</p>
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">x &gt; 0</code> and <code class="reqn">\alpha</code> any real value.
</p>
<p>The modified Bessel function of the second kind can be obtained with
</p>
<div style="text-align: center;"> K<sub>α</sub>(x) = π / 2 (I<sub>-α</sub>(x) - I<sub>α</sub>(x)) / (sin α π)</div> 
<p>where <code class="reqn">I</code> represents the modified function of the first kind and <code class="reqn">K</code>
of the second kind. It is worth remembering the <code>infiniteSum()</code>
function returns the sum in the log scale, which must be adjusted for the
formula above.
</p>

<ul>
<li>
<p> String to access the precompiled function: <code>"bessel_I"</code>
</p>
</li>
<li>
<p> parameter vector: <code>c(x, alpha)</code>
</p>
</li>
</ul>
<h3>Modified Bessel function of the first kind with log argument</h3>

<p>This is the same function as the one above, except that parameter <code class="reqn">x</code> is
given in the log scale. This is provided for numerical stability. For the
cases where <code>x</code> is not very large, sums using this function and the
above should return the same sum.
</p>

<ul>
<li>
<p> String to access the precompiled function: <code>"bessel_I_logX"</code>
</p>
</li>
<li>
<p> parameter vector: <code>c(logx, alpha)</code>
</p>
</li>
</ul>
<h3>Note</h3>

<p>In some cases, the sum of the series is known in closed form for some
values of the parameters. The package function does not check for these cases
and just performs the approximation. If the exact value is desired by the
user when it is known, they must take responsibility for checking and
providing these values.
</p>
<p>Another important thing to note is that the precompiled functions perform all
calculations with twice the numerical precision than R. Therefore, in some
cases, there might be very small differences in the sum when comparing the
results of the function using the precompiled function and the same function
defined at the R level.
</p>


<h3>See Also</h3>

<p><code>infiniteSum()</code>, <code>finiteSum()</code> and
<code>infiniteSum_batches()</code>
</p>


</div>