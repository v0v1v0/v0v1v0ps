<div class="container">

<table style="width: 100%;"><tr>
<td>unifyLandmarks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimally align a set of partial landmark sets</h2>

<h3>Description</h3>

<p>This function aligns two or more landmark sets using shared points. Corresponding landmarks are identified by matching row names. The function selects a sequence of alignments that minimizes the step-wise alignment error.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unifyLandmarks(lm.array, min.common = dim(lm.array)[2], return.on.error = FALSE)

## S3 method for class 'unifyLandmarks'
summary(object, print.tab = '', verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lm.array</code></td>
<td>
<p>an array of 2D or 3D landmark matrices. These can be read in from a file or files using <code>readLandmarksToArray</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.common</code></td>
<td>
<p>a minimum number of landmarks to use in the alignment. Must be greater than <code>dim(lm.array)[2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.on.error</code></td>
<td>
<p>Logical whether to return <code>NULL</code> if there are an insufficient common points for unification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a list of class <code>"unifyLandmarks"</code> (the output of <code>unifyLandmarks()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical whether to print full error report.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input <code>lm.array</code> should be an array of 2D or 3D landmark matrices with row names, such as created by <code>readLandmarksToArray</code>. The first two dimensions of <code>lm.array</code> correspond to the rows and columns of each matrix, respectively. The last dimension of <code>lm.array</code> corresponds to each separate landmark matrix.
</p>
<p><code>unifyLandmarks()</code> first aligns all pair combinations of landmark sets that share the minimum number of points specified by <code>min.common</code>. The two sets that align with the lowest root-mean-square (RMS) error are aligned and the mean positions of all points saved. If there are additional landmark sets, <code>unifyLandmarks()</code> aligns each of these with the combined matrix, again identifying the set that aligns with the least RMS error. The alignment with the least error is saved as the new combined landmark matrix. This is repeated for each remaining landmark set, sequentially aligning remaining landmark sets to the combined landmark matrix.
</p>
<p>To align two 2D landmark sets, the sets must share at least two landmarks and to align two 3D landmark sets, the sets must share at least three landmarks. These are the default minimum number of points for alignment. A greater number of common points can be specified using the <code>min.common</code> parameter. Additionally, in the 3D case, these landmarks must not be collinear. If <code>lm.array</code> contains more than two landmark matrices, it is not necessarily required that each landmark set share these minimum number of points with every other landmark set. For example, it may be that two landmark sets do not each separately share the minimum number of landmarks required for alignment with a third landmark set. But if these two landmark sets are combined, they may then share the required number of landmarks with the third set. During each alignment step, <code>unifyLandmarks()</code> skips pairs of matrices that do not share the required number of landmarks. As long as there is some combination of alignments that provide a sufficient number of shared landmarks, all landmark sets can be combined into a single matrix.
</p>
<p>If an array consisting of only one landmark matrix is input, the matrix is returned without an alignment operation.
</p>


<h3>Value</h3>

<p>a list of class <code>"unifyLandmarks"</code> with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lm.matrix</code></td>
<td>
<p>a 2D or 3D landmark matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unify.seq</code></td>
<td>
<p>a vector of the order in which landmark sets were aligned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unify.error</code></td>
<td>
<p>a matrix of the alignment error for each shared landmark for each alignment (the number of sets minus one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unify.rmse</code></td>
<td>
<p>a vector of the root-mean-square error of each alignment (the number of sets minus one).</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function was modified by A Olsen from the R function <code>unifyVD()</code> written by A Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>References</h3>

<p>Rohlf, F.J. (1990) "Chapter 10. Rotational fit (Procrustes) Methods." <em>Proceedings of the Michigan Morphometrics Workshop</em>. Ed. F. James Rohlf and Fred L. Bookstein. The University of Michigan Museum of Zoology, 1990. 227â€“236. <a href="http://deepblue.lib.umich.edu/handle/2027.42/49535">Info page at lib.umich.edu</a>
</p>


<h3>See Also</h3>

<p><code>findOptimalPointAlignment</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET LANDMARK FILES
file &lt;- paste0(fdir, "lm_3d_even_a", 1:3, ".txt")

## READ LANDMARKS INTO ARRAY
lm.array &lt;- readLandmarksToArray(file, row.names=1)

## UNIFY LANDMARKS
unify_lm &lt;- unifyLandmarks(lm.array)

## PRINT UNIFICATION SUMMARY
print(summary(unify_lm))
</code></pre>


</div>