<div class="container">

<table style="width: 100%;"><tr>
<td>make.systematic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Construct Systematic Detector Design </h2>

<h3>Description</h3>

<p>A rectangular grid of clusters within a polygonal region.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
make.systematic(n, cluster, region, spacing = NULL, origin = NULL, 
    originoffset = c(0,0), chequerboard = c('all','black','white'), 
    order = c('x', 'y', 'xb', 'yb'), rotate = 0,  centrexy = NULL,
    keep.design = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer approximate number of clusters (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>traps object defining a single cluster </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p>dataframe or SpatialPolygonsDataFrame with coordinates
of perimeter </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacing</code></td>
<td>
<p> scalar distance between cluster centres </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p>vector giving x- and y-cooordinates of fixed grid origin
(origin is otherwise random)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>originoffset</code></td>
<td>
<p> numeric; 2-vector (x,y offsets); see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chequerboard</code></td>
<td>
<p> logical; if not ‘all’ then alternate clusters are omitted </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p> character; sort order for clusters (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate</code></td>
<td>
<p>numeric; number of degrees by which to rotate entire design clockwise 
about centroid of region bounding box</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centrexy</code></td>
<td>
<p>numeric; 2-vector for centre of rotation, if any </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.design</code></td>
<td>
<p>logical; if TRUE then input argument values are retained</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to <code>trap.builder</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>region</code> may be any shape. 
</p>
<p><code>region</code> may be one of the spatial classes described 
in <code>boundarytoSF</code>. Otherwise,
<code>region</code> should be a dataframe with columns ‘x’ and ‘y’.
</p>
<p><code>spacing</code> may be a vector with separate values for spacing in x-
and y- directions. If <code>spacing</code> is provided then <code>n</code> is ignored.
</p>
<p>If <code>n</code> is a scalar, the spacing of clusters is determined from
the area of the bounding box of <code>region</code> divided by the requested
number of clusters (this does not necessarily result in exactly n
clusters). If <code>n</code> is a vector of two integers these are taken to be
the number of columns and the number of rows.
</p>
<p>After preparing a frame of cluster centres, <code>make.systematic</code>
calls <code>trap.builder</code> with method = ‘all’; ... allows the
arguments ‘rotation’, ‘edgemethod’, ‘plt’, and ‘detector’ to be
passed. Setting the <code>trap.builder</code> arguments <code>frame</code>,
<code>method</code>, and <code>samplefactor</code> has no effect.
</p>
<p>Note the distinction between argument <code>rotate</code> and the <code>trap.builder</code> 
argument <code>rotation</code> that is applied separately to each cluster.
</p>
<p>If <code>origin</code> is not specified then a random uniform origin is chosen within a box (width = spacing) placed with its bottom left corner at the bottom left of the bounding box of <code>region</code>, shifted by <code>originoffset</code>. Before version 3.1.8 the behaviour of <code>make.systematic</code> was equivalent to <code>originoffset = c(wx,wy)</code> where <code>wx,wy</code> are the cluster half widths.   
</p>
<p><code>chequerboard = "black"</code> retains black ‘squares’ and <code>chequerboard = "white"</code> retains white ‘squares’, where the lower left cluster in the candidate rectangle of cluster origins is black, as on a chess board. The effect is the same as increasing spacing by sqrt(2) and rotating through 45 degrees.
</p>
<p><code>order</code> determines the ordering of clusters in the resulting traps object. The options are a subset of those for <code>ID</code> argument of <code>make.grid</code>:
</p>

<table>
<tr>
<td style="text-align: left;">
     Option </td>
<td style="text-align: left;"> Sort order </td>
</tr>
<tr>
<td style="text-align: left;">
     x </td>
<td style="text-align: left;">  column-dominant </td>
</tr>
<tr>
<td style="text-align: left;">
     y </td>
<td style="text-align: left;">  row-dominant </td>
</tr>
<tr>
<td style="text-align: left;">
     xb </td>
<td style="text-align: left;">  column-dominant boustrophedonical (alternate columns reversed) </td>
</tr>
<tr>
<td style="text-align: left;">
     yb </td>
<td style="text-align: left;">  row-dominant boustrophedonical (alternate rows reversed) </td>
</tr>
<tr>
<td style="text-align: left;">
     </td>
</tr>
</table>
<p><code>rotate</code> rotates the array about the given centre (default is centroid of the bounding box of <code>region</code>). 
</p>


<h3>Value</h3>

<p>A single-session ‘traps’ object.
</p>
<p>From 3.2.0 these additional attributes are set –
</p>

<table>
<tr>
<td style="text-align: left;">
origin </td>
<td style="text-align: left;"> coordinates of grid origin </td>
</tr>
<tr>
<td style="text-align: left;">
centres </td>
<td style="text-align: left;"> coordinates of true cluster centres (cf <code>cluster.centres</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
originbox </td>
<td style="text-align: left;"> vertices of rectangular spatial sampling frame for random origin </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>From 4.2.0 if <code>keep.design</code> is TRUE then the input argument values are retained in attribute ‘design’ (a list with first component <code>function = 'make.systematic'</code>).
</p>


<h3>Note</h3>

<p>Do not confuse with the simpler function <code>make.grid</code>,
which places single detectors in a rectangular array.
</p>


<h3>See Also</h3>

<p><code>trap.builder</code>, 
<code>make.lacework</code>,
<code>cluster.centres</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
mini &lt;- make.grid(nx = 2, ny = 2, spacing = 100)
region &lt;- cbind(x=c(0,2000,2000,0), y=c(0,0,2000,2000))
temp &lt;- make.systematic(25, mini, region, plt = TRUE)
temp &lt;- make.systematic(c(6, 6), mini, region, plt = TRUE,
    rotation = -1)

## Example using shapefile "possumarea.shp" in
## "extdata" folder. By default, each cluster is 
## a single multi-catch detector

## Not run: 

library(sf)
shpfilename &lt;- system.file("extdata/possumarea.shp", package = "secr")
possumarea &lt;- st_read(shpfilename)

possumgrid &lt;- make.systematic(spacing = 100, region =
    possumarea, plt = TRUE)

## or with 2 x 2 clusters
possumgrid2 &lt;- make.systematic(spacing = 300,
    cluster = make.grid(nx = 2, ny = 2, spacing = 100),
    region = possumarea, plt = TRUE, edgemethod =
    "allinside")
## label clusters
text(cluster.centres(possumgrid2), levels(clusterID
    (possumgrid2)), cex=0.7)

## If you have GPSBabel installed and on the Path
## then coordinates can be projected and uploaded
## to a GPS with `writeGPS', which also requires the
## package `proj4'. Defaults are for a Garmin GPS
## connected by USB.

if (interactive()) {
    writeGPS(possumgrid, proj = "+proj=nzmg")
}


## End(Not run)

</code></pre>


</div>