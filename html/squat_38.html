<div class="container">

<table style="width: 100%;"><tr>
<td>kmeans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>QTS K-Means Alignment Algorithm</h2>

<h3>Description</h3>

<p>This function massages the input quaternion time series to feed them into the
k-means alignment algorithm for jointly clustering and aligning the input
QTS.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kmeans(x, n_clusters, ...)

## Default S3 method:
kmeans(
  x,
  n_clusters = 1,
  iter_max = 10,
  nstart = 1,
  algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  trace = FALSE,
  ...
)

## S3 method for class 'qts_sample'
kmeans(
  x,
  n_clusters = 1L,
  seeds = NULL,
  seeding_strategy = c("kmeans++", "exhaustive-kmeans++", "exhaustive", "hclust"),
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  metric = c("l2", "pearson"),
  cluster_on_phase = FALSE,
  use_fence = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns) or an object of class qts_sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters to be
look for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_max</code></td>
<td>
<p>An integer value specifying the maximum number of iterations
for terminating the k-mean algorithm. Defaults to <code>10L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>if <code>centers</code> is a number, how many random sets
should be chosen?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character: may be abbreviated.  Note that
<code>"Lloyd"</code> and <code>"Forgy"</code> are alternative names for one
algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical or integer number, currently only used in the
default method (<code>"Hartigan-Wong"</code>): if positive (or true),
tracing information on the progress of the algorithm is
produced.  Higher values may produce more tracing information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>An integer value or vector specifying the indices of the initial
centroids. If an integer vector, it is interpreted as the indices of the
intial centroids and should therefore be of length <code>n_clusters</code>. If an
integer value, it is interpreted as the index of the first initial centroid
and subsequent centroids are chosen according to the k-means++ strategy. It
can be <code>NULL</code> in which case the argument <code>seeding_strategy</code> is used to
automatically provide suitable indices. Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeding_strategy</code></td>
<td>
<p>A character string specifying the strategy for
choosing the initial centroids in case the argument <code>seeds</code> is set to
<code>NULL</code>. Choices are
<a href="https://en.wikipedia.org/wiki/K-means%2B%2B"><code>"kmeans++"</code></a>,
<code>"exhaustive-kmeans++"</code> which performs an exhaustive search over the choice
of the first centroid, <code>"exhaustive"</code> which tries on all combinations of
initial centroids or <code>"hclust"</code> which first performs hierarchical
clustering using Ward's linkage criterion to identify initial centroids.
Defaults to <code>"kmeans++"</code>, which is the fastest strategy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code> or <code>"pearson"</code>. Defaults to <code>"l2"</code>. Used only when
<code>warping_class != "srsf"</code>. For the boundary-preserving warping class, the
L2 distance between the SRSFs of the original curves is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>stats::kmeans</code> or <code>stats::hclust</code> or
<code>dbscan_fast</code> if the input <code>x</code> is NOT of class <code>qts_sample</code>. Otherwise,
an object of class <code>qtsclust</code> which is effectively a list with four
components:
</p>

<ul>
<li> <p><code>qts_aligned</code>: An object of class <code>qts_sample</code> storing the sample of
aligned QTS;
</p>
</li>
<li> <p><code>qts_centers</code>: A list of objects of class <code>qts</code> representing the centers
of the clusters;
</p>
</li>
<li> <p><code>best_clustering</code>: An object of class <code>fdacluster::caps</code> storing the
results of the best k-mean alignment result among all initialization that
were tried.
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the clustering structure;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">out &lt;- kmeans(vespa64$igp[1:10], n_clusters = 2)
</code></pre>


</div>