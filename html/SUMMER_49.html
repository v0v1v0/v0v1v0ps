<div class="container">

<table style="width: 100%;"><tr>
<td>aggPop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate populations to the specified areal level</h2>

<h3>Description</h3>

<p>Takes simulated populations and aggregates 
them to the specified areal level. Also calculates the aggregated risk and prevalence.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pixelPopToArea(
  pixelLevelPop,
  eaSamples,
  areas,
  stratifyByUrban = TRUE,
  targetPopMat = NULL,
  doFineScaleRisk = !is.null(pixelLevelPop$fineScaleRisk$p),
  doSmoothRisk = !is.null(pixelLevelPop$smoothRisk$p)
)

areaPopToArea(
  areaLevelPop,
  areasFrom,
  areasTo,
  stratifyByUrban = TRUE,
  doFineScaleRisk = !is.null(areaLevelPop$aggregationResults$pFineScaleRisk),
  doSmoothRisk = !is.null(areaLevelPop$aggregationResults$pSmoothRisk)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pixelLevelPop</code></td>
<td>
<p>pixel level population information that we want aggregate. In the same format as output from <code>simPopCustom</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eaSamples</code></td>
<td>
<p>nIntegrationPoint x nsim matrix of the number of enumeration areas per pixel sampled in the input pixel level population</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areas</code></td>
<td>
<p>character vector of length nIntegrationPoints of area names over which we 
want to aggregate. Can also be subareas</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stratifyByUrban</code></td>
<td>
<p>whether or not to stratify simulations by urban/rural classification</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetPopMat</code></td>
<td>
<p>pixellated grid data frame with variables 'lon', 'lat', 'pop' (target population), 'area', 'subareas' (if subareaLevel is TRUE), 'urban' (if stratifyByUrban is TRUE), 'east', and 'north'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doFineScaleRisk</code></td>
<td>
<p>whether or not to calculate the fine scale risk in addition to the prevalence. See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doSmoothRisk</code></td>
<td>
<p>Whether or not to calculate the smooth risk in addition to the prevalence. See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areaLevelPop</code></td>
<td>
<p>output of <code>simPopCustom</code> containing pixel level information 
about the population of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areasFrom</code></td>
<td>
<p>character vector of length equal to the number of areas from which 
we would like to aggregate containing the unique names of the areas. 
Can also be subareas, but these are smaller than the "to areas", and 
each "from area" must be entirely contained in a single "to area"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areasTo</code></td>
<td>
<p>character vector of length equal to the number of areas from which 
we would like to aggregate containing the names of the areas containing 
with each respective ‘from’ area. Can also be a set of subareas, 
but these are larger than the "from areas".</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing elements 'fineScalePrevalence' and 'fineScaleRisk'. Each 
of these are in turn lists with aggregated prevalence and risk for the area of 
interest, containg the following elements, were paranethesis indicate the elements 
for the fineScaleRisk model rather than fineScalePrevalence:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Aggregated prevalence (risk), calculated as aggregate of Z divided by 
aggregate of N</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Aggregated (expected) population numerator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Aggregated (expected) population denominator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pUrban</code></td>
<td>
<p>Aggregated prevalence (risk) in urban part of the area, calculated 
as aggregate of Z divided by aggregate of N</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZUrban</code></td>
<td>
<p>Aggregated (expected) population numerator in urban part of the area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NUrban</code></td>
<td>
<p>Aggregated (expected) population denominator in urban part of the area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pRural</code></td>
<td>
<p>Aggregated prevalence (risk) in rural part of the area, calculated 
as aggregate of Z divided by aggregate of N</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZRural</code></td>
<td>
<p>Aggregated (expected) population numerator in rural part of the area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NRural</code></td>
<td>
<p>Aggregated (expected) population denominator in rural part of the area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Aggregation matrix used to aggregate from pixel level to areal level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AUrban</code></td>
<td>
<p>Aggregation matrix used to aggregate from pixel level to urban part of the areal level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ARural</code></td>
<td>
<p>Aggregation matrix used to aggregate from pixel level to rural part of the areal level</p>
</td>
</tr>
</table>
<h3>Functions</h3>


<ul>
<li> <p><code>pixelPopToArea()</code>: Aggregate from pixel to areal level
</p>
</li>
<li> <p><code>areaPopToArea()</code>: Aggregate areal populations to another areal level
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>John Paige
</p>


<h3>References</h3>

<p>In Preparation
</p>


<h3>See Also</h3>

<p><code>areaPopToArea</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##### Now we make a model for the risk. We will use an SPDE model with these 
##### parameters for the linear predictor on the logist scale, which are chosen 
##### to be of practical interest:
beta0=-2.9 # intercept
gamma=-1 # urban effect
rho=(1/3)^2 # spatial variance
effRange = 400 # effective spatial range in km
sigmaEpsilon=sqrt(1/2.5) # cluster (nugget) effect standard deviation

# simulate the population! Note that this produces multiple dense 
# nEA x nsim and nIntegrationPoint x nsim matrices. In the future 
# sparse matrices will and chunk by chunk computations may be incorporated.
simPop = simPopSPDE(nsim=1, easpa=easpaKenyaNeonatal, 
                    popMat=popMatKenya, targetPopMat=popMatKenyaNeonatal, 
                    poppsub=poppsubKenya, spdeMesh=kenyaMesh, 
                    margVar=rho, sigmaEpsilonSq=sigmaEpsilon^2, 
                    gamma=gamma, effRange=effRange, beta0=beta0, 
                    seed=123, inla.seed=12, nHHSampled=25, 
                    stratifyByUrban=TRUE, subareaLevel=TRUE, 
                    doFineScaleRisk=TRUE, 
                    min1PerSubarea=TRUE)

pixelPop = simPop$pixelPop
subareaPop = pixelPopToArea(pixelLevelPop=pixelPop, eaSamples=pixelPop$eaSamples, 
  areas=popMatKenya$subarea, stratifyByUrban=TRUE, 
  targetPopMat=popMatKenyaNeonatal, doFineScaleRisk=TRUE)

# get areas associated with each subarea for aggregation
tempAreasFrom = popMatKenya$subarea
tempAreasTo = popMatKenya$area
areasFrom = sort(unique(tempAreasFrom))
areasToI = match(areasFrom, tempAreasFrom)
areasTo = tempAreasTo[areasToI]

# do the aggregation from subareas to areas
outAreaLevel = areaPopToArea(areaLevelPop=subareaPop, 
  areasFrom=areasFrom, areasTo=areasTo, 
  stratifyByUrban=TRUE, doFineScaleRisk=TRUE)

## End(Not run)
</code></pre>


</div>