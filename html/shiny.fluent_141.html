<div class="container">

<table style="width: 100%;"><tr>
<td>ComboBox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ComboBox</h2>

<h3>Description</h3>

<p>A combo box (<code>ComboBox</code>) combines a text field and a drop-down menu, giving people a way to select an option from a list or enter their own choice.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/ComboBox">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ComboBox(...)

VirtualizedComboBox(...)

ComboBox.shinyInput(inputId, ..., value = defaultValue)

updateComboBox.shinyInput(
  session = shiny::getDefaultReactiveDomain(),
  inputId,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputId</code></td>
<td>
<p>ID of the component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>Starting value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>Object passed as the <code>session</code> argument to Shiny server.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li> <p><b> allowFreeform </b> <code>boolean</code> <br> Whether the ComboBox is free form, meaning that the user input is not bound to provided options. Defaults to false.
</p>
</li>
<li> <p><b> ariaDescribedBy </b> <code>string</code> <br> Optional prop to add a string id that can be referenced inside the aria-describedby attribute
</p>
</li>
<li> <p><b> autoComplete </b> <code>'on' | 'off'</code> <br> Whether the ComboBox auto completes. As the user is inputing text, it will be suggested potential matches from the list of options. If the combo box is expanded, this will also scroll to the suggested option, and give it a selected style.
</p>
</li>
<li> <p><b> autofill </b> <code>IAutofillProps</code> <br> The AutofillProps to be passed into the Autofill component inside combobox
</p>
</li>
<li> <p><b> buttonIconProps </b> <code>IIconProps</code> <br> The IconProps to use for the button aspect of the combobox
</p>
</li>
<li> <p><b> caretDownButtonStyles </b> <code style="white-space: pre;">⁠Partial&lt;IButtonStyles&gt;⁠</code> <br> Styles for the caret down button.
</p>
</li>
<li> <p><b> comboBoxOptionStyles </b> <code style="white-space: pre;">⁠Partial&lt;IComboBoxOptionStyles&gt;⁠</code> <br> Default styles that should be applied to ComboBox options, in case an option does not come with user-defined custom styles
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;IComboBox&gt;⁠</code> <br> Optional callback to access the IComboBox interface. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> dropdownMaxWidth </b> <code>number</code> <br> Custom max width for dropdown
</p>
</li>
<li> <p><b> dropdownWidth </b> <code>number</code> <br> Custom width for dropdown (unless useComboBoxAsMenuWidth is undefined or false)
</p>
</li>
<li> <p><b> getClassNames </b> <code style="white-space: pre;">⁠(theme: ITheme, isOpen: boolean, disabled: boolean, required: boolean, focused: boolean, allowFreeForm: boolean, hasErrorMessage: boolean, className?: string) =&gt; IComboBoxClassNames⁠</code> <br> Custom function for providing the classNames for the ComboBox. Can be used to provide all styles for the component instead of applying them on top of the default styles.
</p>
</li>
<li> <p><b> iconButtonProps </b> <code>IButtonProps</code> <br> Optional iconButton props on combo box
</p>
</li>
<li> <p><b> isButtonAriaHidden </b> <code>boolean</code> <br> Sets the 'aria-hidden' attribute on the ComboBox's button element instructing screen readers how to handle the element. This element is hidden by default because all functionality is handled by the input element and the arrow button is only meant to be decorative.
</p>
</li>
<li> <p><b> keytipProps </b> <code>IKeytipProps</code> <br> Optional keytip for this combo box
</p>
</li>
<li> <p><b> multiSelectDelimiter </b> <code>string</code> <br> When multiple items are selected, this will be used to separate values in the combobox input.
</p>
</li>
<li> <p><b> onChange </b> <code style="white-space: pre;">⁠(event: React.FormEvent&lt;IComboBox&gt;, option?: IComboBoxOption, index?: number, value?: string) =&gt; void⁠</code> <br> Callback issued when either: 1) the selected option changes 2) a manually edited value is submitted. In this case there may not be a matched option if allowFreeform is also true (and hence only value would be true, the other parameter would be null in this case)
</p>
</li>
<li> <p><b> onItemClick </b> <code style="white-space: pre;">⁠(event: React.FormEvent&lt;IComboBox&gt;, option?: IComboBoxOption, index?: number) =&gt; void⁠</code> <br> Callback issued when a ComboBox item is clicked.
</p>
</li>
<li> <p><b> onMenuDismiss </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Function that gets invoked before the menu gets dismissed
</p>
</li>
<li> <p><b> onMenuDismissed </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Function that gets invoked when the ComboBox menu is dismissed
</p>
</li>
<li> <p><b> onMenuOpen </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Function that gets invoked when the ComboBox menu is launched
</p>
</li>
<li> <p><b> onPendingValueChanged </b> <code style="white-space: pre;">⁠(option?: IComboBoxOption, index?: number, value?: string) =&gt; void⁠</code> <br> Callback issued when the user changes the pending value in ComboBox. This will be called any time the component is updated and there is a current pending value. Option, index, and value will all be undefined if no change has taken place and the previously entered pending value is still valid.
</p>
</li>
<li> <p><b> onRenderLabel </b> <code style="white-space: pre;">⁠IRenderFunction&lt;IOnRenderComboBoxLabelProps&gt;⁠</code> <br> Custom render function for the label text.
</p>
</li>
<li> <p><b> onRenderLowerContent </b> <code style="white-space: pre;">⁠IRenderFunction&lt;IComboBoxProps&gt;⁠</code> <br> Add additional content below the callout list.
</p>
</li>
<li> <p><b> onRenderUpperContent </b> <code style="white-space: pre;">⁠IRenderFunction&lt;IComboBoxProps&gt;⁠</code> <br> Add additional content above the callout list.
</p>
</li>
<li> <p><b> onResolveOptions </b> <code style="white-space: pre;">⁠(options: IComboBoxOption[]) =&gt; IComboBoxOption[] | PromiseLike&lt;IComboBoxOption[]&gt;⁠</code> <br> Callback issued when the options should be resolved, if they have been updated or if they need to be passed in the first time
</p>
</li>
<li> <p><b> onScrollToItem </b> <code style="white-space: pre;">⁠(itemIndex: number) =&gt; void⁠</code> <br> Callback issued when the ComboBox requests the list to scroll to a specific element
</p>
</li>
<li> <p><b> options </b> <code>IComboBoxOption[]</code> <br> Collection of options for this ComboBox
</p>
</li>
<li> <p><b> persistMenu </b> <code>boolean</code> <br> Menu will not be created or destroyed when opened or closed, instead it will be hidden. This will improve perf of the menu opening but could potentially impact overall perf by having more elements in the dom. Should only be used when perf is important. Note: This may increase the amount of time it takes for the comboBox itself to mount.
</p>
</li>
<li> <p><b> scrollSelectedToTop </b> <code>boolean</code> <br> When options are scrollable the selected option is positioned at the top of the callout when it is opened (unless it has reached the end of the scrollbar).
</p>
</li>
<li> <p><b> shouldRestoreFocus </b> <code>boolean</code> <br> When specified, determines whether the callout (the menu which drops down) should restore the focus after being dismissed or not. If false, then the menu will not try to set focus to whichever element had focus before the menu was opened.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠Partial&lt;IComboBoxStyles&gt;⁠</code> <br> Custom styles for this component
</p>
</li>
<li> <p><b> text </b> <code>string</code> <br> Value to show in the input, does not have to map to a combobox option
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme provided by HOC.
</p>
</li>
<li> <p><b> useComboBoxAsMenuWidth </b> <code>boolean</code> <br> Whether to use the ComboBoxes width as the menu's width
</p>
</li>
<li> <p><b> multiselectAccessibleText </b> <code>string</code> <br> Accessible text for label when combobox is multiselected.
</p>
</li>
<li> <p><b> props </b> <code>IComboBoxProps</code> <br> Props to render the combobox.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
The update functions return nothing (called for side effects).
</p>


<h3>Best practices</h3>



<h4>Layout</h4>


<ul><li>
<p> Use a combo box when there are multiple choices that can be collapsed under one title, when the list of items is long, or when space is constrained.
</p>
</li></ul>
<h4>Content</h4>


<ul>
<li>
<p> Use single words or shortened statements as options.
</p>
</li>
<li>
<p> Don't use punctuation at the end of options.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(shiny)
library(shiny.fluent)

options &lt;- list(
  list(key = "A", text = "Option A"),
  list(key = "B", text = "Option B"),
  list(key = "C", text = "Option C")
)

ui &lt;- function(id) {
  ns &lt;- NS(id)
  div(
    ComboBox.shinyInput(ns("combo"), value = list(text = "some text"),
      options = options, allowFreeform = TRUE
    ),
    textOutput(ns("comboValue"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    output$comboValue &lt;- renderText({
      sprintf("Value: %s", input$combo$text)
    })
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>