<div class="container">

<table style="width: 100%;"><tr>
<td>PenalisedGraphical</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graphical LASSO</h2>

<h3>Description</h3>

<p>Runs the graphical LASSO algorithm for estimation of a Gaussian Graphical
Model (GGM). This function is not using stability.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PenalisedGraphical(
  xdata,
  pk = NULL,
  Lambda,
  Sequential_template = NULL,
  scale = TRUE,
  start = "cold",
  output_omega = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>matrix with observations as rows and variables as columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pk</code></td>
<td>
<p>optional vector encoding the grouping structure. Only used for
multi-block stability selection where <code>pk</code> indicates the number of
variables in each group. If <code>pk=NULL</code>, single-block stability
selection is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>matrix of parameters controlling the level of sparsity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sequential_template</code></td>
<td>
<p>logical matrix encoding the type of procedure to
use for data with multiple blocks in stability selection graphical
modelling. For multi-block estimation, the stability selection model is
constructed as the union of block-specific stable edges estimated while the
others are weakly penalised (<code>TRUE</code> only for the block currently being
calibrated and <code>FALSE</code> for other blocks). Other approaches with joint
calibration of the blocks are allowed (all entries are set to <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical indicating if the correlation (<code>scale=TRUE</code>) or
covariance (<code>scale=FALSE</code>) matrix should be used as input of
<code>glassoFast</code> if
<code>implementation=PenalisedGraphical</code>. Otherwise, this argument must be
used in the function provided in <code>implementation</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>character string indicating if the algorithm should be
initialised at the estimated (inverse) covariance with previous penalty
parameters (<code>start="warm"</code>) or not (<code>start="cold"</code>). Using
<code>start="warm"</code> can speed-up the computations, but could lead to
convergence issues (in particular with small <code>Lambda_cardinal</code>). Only
used for <code>implementation=PenalisedGraphical</code> (see argument
<code>"start"</code> in <code>glassoFast</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_omega</code></td>
<td>
<p>logical indicating if the estimated precision matrices
should be stored and returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to the function provided in
<code>implementation</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The use of the procedure from Equation (4) or (5) is controlled by
the argument "Sequential_template".
</p>


<h3>Value</h3>

<p>An array with binary and symmetric adjacency matrices along the third
dimension.
</p>


<h3>References</h3>

<p>Friedman J, Hastie T, Tibshirani R (2008).
“Sparse inverse covariance estimation with the graphical lasso.”
<em>Biostatistics</em>, <b>9</b>(3), 432–441.
</p>


<h3>See Also</h3>

<p><code>GraphicalModel</code>
</p>
<p>Other underlying algorithm functions: 
<code>CART()</code>,
<code>ClusteringAlgo()</code>,
<code>PenalisedOpenMx()</code>,
<code>PenalisedRegression()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Data simulation
set.seed(1)
simul &lt;- SimulateGraphical()

# Running graphical LASSO
myglasso &lt;- PenalisedGraphical(
  xdata = simul$data,
  Lambda = matrix(c(0.1, 0.2), ncol = 1)
)

# Returning estimated precision matrix
myglasso &lt;- PenalisedGraphical(
  xdata = simul$data,
  Lambda = matrix(c(0.1, 0.2), ncol = 1),
  output_omega = TRUE
)
</code></pre>


</div>