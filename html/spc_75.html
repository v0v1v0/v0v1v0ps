<div class="container">

<table style="width: 100%;"><tr>
<td>xgrsr.arl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute (zero-state) ARLs of Shiryaev-Roberts schemes</h2>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for Shiryaev-Roberts schemes monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class="language-R">xgrsr.arl(k, g, mu, zr = 0, hs=NULL, sided = "one", q = 1, MPT = FALSE, r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>reference value of the Shiryaev-Roberts scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>control limit (alarm threshold) of Shiryaev-Roberts scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>true mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zr</code></td>
<td>
<p>reflection border to enable the numerical algorithms used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>so-called headstart (enables fast initial response). If <code>hs=NULL</code>, then
the classical headstart -Inf is used (corresponds to 0 for the non-log scheme).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p>distinguishes between one- and two-sided schemes by choosing 
<code>"one"</code> and<code>"two"</code>, respectively. Currently only one-sided schemes are
implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MPT</code></td>
<td>
<p>switch between the old implementation (<code>FALSE</code>) and the new one (<code>TRUE</code>) that considers the complete
likelihood ratio. MPT stands for the initials of G. Moustakides, A. Polunchenko and A. Tartakovsky.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>xgrsr.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
</p>


<h3>Value</h3>

<p>Returns a vector of length <code>q</code> which resembles the ARL and the sequence of conditional expected delays for
<code>q</code>=1 and <code>q</code>&gt;1, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2006),
The art of evaluating monitoring schemes â€“
how to measure the performance of control charts?
S. Lenz, H. &amp; Wilrich, P. (ed.),
<em>Frontiers in Statistical Quality Control 8</em>, Physica Verlag, Heidelberg, Germany, 74-99.
</p>
<p>G. Moustakides, A. Polunchenko, A. Tartakovsky (2009),
Numerical comparison of CUSUM and Shiryaev-Roberts procedures for detecting changes in distributions,
<em>Communications in Statistics: Theory and Methods 38</em>, 3225-3239.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>xcusum-arl</code> for zero-state ARL computation of EWMA and CUSUM control charts,
respectively, and <code>xgrsr.ad</code> for the steady-state ARL.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Small study to identify appropriate reflection border to mimic unreflected schemes
k &lt;- .5
g &lt;- log(390)
zrs &lt;- -(0:10)
ZRxgrsr.arl &lt;- Vectorize(xgrsr.arl, "zr")
arls &lt;- ZRxgrsr.arl(k, g, 0, zr=zrs)
data.frame(zrs, arls)

## Table 2 from Knoth (2006)
## original values are
#  mu   arl
#  0    697
#  0.5  33
#  1    10.4
#  1.5  6.2
#  2    4.4
#  2.5  3.5
#  3    2.9
#
k &lt;- .5
g &lt;- log(390)
zr &lt;- -5 # see first example
mus &lt;- (0:6)/2
Mxgrsr.arl &lt;- Vectorize(xgrsr.arl, "mu")
arls &lt;- round(Mxgrsr.arl(k, g, mus, zr=zr), digits=1)
data.frame(mus, arls)

XGRSR.arl  &lt;- Vectorize("xgrsr.arl", "g")
zr &lt;- -6

## Table 2 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   47.17      50.29        41.40
#  100   94.34     100.28        72.32
#  500  471.70     500.28       209.44
# 1000  943.41    1000.28       298.50
# 5000 4717.04    5000.24       557.87
#10000 9434.08   10000.17       684.17

theta &lt;- .1
As2 &lt;- c(47.17, 94.34, 471.7, 943.41, 4717.04, 9434.08)
gs2 &lt;- log(As2)
arls0 &lt;- round(XGRSR.arl(theta/2, gs2, 0, zr=-5, r=300, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs2, theta, zr=-5, r=300, MPT=TRUE), digits=2)
data.frame(As2, arls0, arls1)

## Table 3 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   37.38      49.45        12.30
#  100   74.76      99.45        16.60
#  500  373.81     499.45        28.05
# 1000  747.62     999.45        33.33
# 5000 3738.08    4999.45        45.96
#10000 7476.15    9999.24        51.49

theta &lt;- .5
As3 &lt;- c(37.38, 74.76, 373.81, 747.62, 3738.08, 7476.15)
gs3 &lt;- log(As3)
arls0 &lt;- round(XGRSR.arl(theta/2, gs3, 0, zr=-5, r=70, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs3, theta, zr=-5, r=70, MPT=TRUE), digits=2)
data.frame(As3, arls0, arls1)

## Table 4 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   28.02      49.78         4.98
#  100   56.04      99.79         6.22
#  500  280.19     499.79         9.30
# 1000  560.37     999.79        10.66
# 5000 2801.85    5000.93        13.86
#10000 5603.70    9999.87        15.24

theta &lt;- 1
As4 &lt;- c(28.02, 56.04, 280.19, 560.37, 2801.85, 5603.7)
gs4 &lt;- log(As4)
arls0 &lt;- round(XGRSR.arl(theta/2, gs4, 0, zr=-6, r=40, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs4, theta, zr=-6, r=40, MPT=TRUE), digits=2)
data.frame(As4, arls0, arls1)
</code></pre>


</div>