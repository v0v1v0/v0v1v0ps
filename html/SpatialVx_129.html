<div class="container">

<table style="width: 100%;"><tr>
<td>lossdiff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Test for Equal Predictive Ability on Average Over a Regularly Gridded Space
</h2>

<h3>Description</h3>

<p>Test for equal predictive ability (for two forecast models) on average over a regularly gridded space using the method of Hering and Genton (2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">lossdiff(x, ...)

## Default S3 method:
lossdiff(x, ..., xhat1, xhat2, threshold = NULL,
    lossfun = "corrskill", loc = NULL, zero.out = FALSE)

## S3 method for class 'SpatialVx'
lossdiff(x, ..., time.point = 1, obs = 1, model = c(1, 2),
    threshold = NULL, lossfun = "corrskill", zero.out = FALSE)

empiricalVG.lossdiff( x, trend = 0, maxrad, dx = 1, dy = 1 )

flossdiff(object, vgmodel = "expvg", ...)

## S3 method for class 'lossdiff'
summary(object, ...)

## S3 method for class 'lossdiff'
plot(x, ..., icol = c("gray", tim.colors(64)))

## S3 method for class 'lossdiff'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,xhat1, xhat2</code></td>
<td>

<p><code>lossdiff</code>: m by n matrices defining the (gridded) verification set where <code>xhat1</code> and <code>xhat2</code> are the two forecast models being compared.  <code>plot.lossdiff</code>: <code>x</code> is a list returned by <code>lossdiff</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p><code>flossdiff</code> this is the output returned by <code>lossdiff</code>.  <code>summary.lossdiff</code>: list object returned by <code>lossdiff</code> or <code>flossdiff</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>numeric vector of length one, two or three giving a threshold under which (non-inclusive) all values will be set to zero.  If length is one, the same threshold is used for all fields (observed, and both models).  If length is two, the same threshold will be used for both models (the second value of <code>threshold</code>).  Otherwise, the first entry is used for the observed field, the second for the first model and the third for the second model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lossfun</code></td>
<td>

<p>character anming a loss function to use in finding the loss differential for the fields.  Default is to use correlation as the loss function.  Must have arguments <code>x</code> and <code>y</code>, and may have any additional arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>a matrix (of appropriate dimension) or single numeric (if constant trend) giving the value of the spatial trend.  the value is simply subtracted from the loss differential field before finding the empirical variogram.  If <code>zero.out</code> is TRUE, then wherever the original three fields all had zero-valued grid points are returned back to zero before continuing (hence ignored in the computation of the variogram).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>(optional) mn by 2 matrix giving location coordinates for each grid point.  If NULL, they are taken to be the grid expansion of the dimension of <code>x</code> (i.e., cbind(rep(1:dim(x)[1],dim(x)[2]), rep(1:dim(x)[2],each=dim(x)[1]))).  This argument is not used by <code>lossdiff</code>, but may be used subsequently by the <code>plot</code> method function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxrad</code></td>
<td>

<p>numeric giving the maximum radius for finding variogram differences per the <code>R</code> argument of <code>vgram.matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx, dy</code></td>
<td>

<p><code>dx</code> and <code>dy</code> of <code>vgram.matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.out</code></td>
<td>
<p>logical, should the variogram be computed only over non-zero values of the process?  If TRUE, a modified version of <code>vgram.matrix</code> is used (<code>variogram.matrix</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vgmodel</code></td>
<td>
<p>character string naming a variogram model function to use.  Default is the exponential variogram, <code>expvg</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.point</code></td>
<td>
<p>numeric or character indicating which time point from the “SpatialVx” verification set to select for analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs, model</code></td>
<td>
<p>numeric indicating which observation/forecast model to select for the analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icol</code></td>
<td>
<p>(optional) color scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p><code>lossdiff</code>: optional additional arguments to <code>lossfun</code>.  Not used by the summary or plot functions.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Hering and Genton (2011) introduce a test procedure for comparing spatial fields, which is based on a time series test introduced by Diebold and Mariano (1995).  First, a loss function, g(x,y), is calculated, which can be any appropriate loss function.  This is calculated for each of two forecast fields.  The loss differential field is then given by:
</p>
<p>D(s) = g(x(s),y1(s)) - g(x(s),y2(s)), where s are the spatial locations, x is the verification field, and y1 and y2 are the two forecast fields.
</p>
<p>It is assumed that D(s) = phi(s) + psi(s), where phi(s) is the mean trend and psi(s) is a mean zero stationary process with unknown covariance function C(h) = cov(psi(s),psi(s+h)).  In particular, the argument trend represents phi(s), and the default is that the mean is equal (and zero) over the entire domain.  If it is believed that this is not the case, then it should be removed before finding the covariance.
</p>
<p>To estimate the trend, see e.g. Hering and Genton (2011) and references therein.
</p>
<p>A test is constructed to test the null hypothesis of equal predictive ability on average.  That is,
</p>
<p>H_0: 1/|D| int_D E[D(s)]ds = 0, where |D| is the area of the domain, 
</p>
<p>The test statistic is given by
</p>
<p>S_V = mean(D(s))/sqrt(mean(C(h))),
</p>
<p>where C(h) = gamma(infinity|p) - gamma(h|p) is a fitted covariance function for the loss differential field.  The test statistic is assumed to be N(0,1) so that if the p-value is smaller than the desired level of significance, the null hypothesis is not accepted.
</p>
<p>For 'flossdiff', an exponential variogram is used. Specifically,
</p>
<p>gamma(h | theta=(s,r)) = s^2*(1 - exp(-h/r)),
</p>
<p>where s is sqrt(sill) and r is the range (nugget effects are not accounted for here).  If <code>flossdiff</code> should fail, and the empirical variogram appears to be reasonable (e.g., use the <code>plot</code> method function on <code>lossdiff</code> output to check that the empirical variogram is concave), then try giving alternative starting values for the <code>nls</code> function by using the <code>start.list</code> argument.  The default is to use the variogram value for the shortest separation distance as an initial estimate for s, and <code>maxrad</code> as the initial estimate for r.
</p>
<p>Currently, it is not possible to fit other variogram models with this function.  Such flexibility may possibly be added in a future release.  In the meantime, use <code>flossdiff</code> as a template to make your own similar function; just be sure to return an object of class “nls”, and it should work seamlessly with the <code>plot</code> and <code>summary</code> method functions for a “lossdiff” object.  For example, if it is desired to include the nugget or an extra factor (e.g., 3 as used in Hering and Genton, 2011), then a new similar function would need to be created.
</p>
<p>Also, although the testing procedure can be applied to irregularly spaced locations (non-gridded), this function is set up only for gridded fields in order to take advantage of computational efficiencies (i.e., use of vgram.matrix), as these are the types of verification sets in mind for this package.  For irregularly spaced grids, the function <code>spct</code> can be used.
</p>
<p>The above test assumes constant spatial trend.  It is possible to remove any spatial trend in D(s) before applying the test.
</p>
<p>The procedure requires four steps (hence four functions).  The first is to calculate the loss differential field using <code>lossdiff</code>.  Next, calculate the empirical variogram of the loss differential field using <code>empiricalVG.lossdiff</code>.  This second step was originally included within the first step in <code>lossdiff</code>, but that setup presented a problem for determining if a spatial trend exists or not.  It is important to determine if a trend exists, and if so, to (with care) estimate the trend, and remove it.  If a trend is detected (and estimated), it can be removed before calling <code>empiricalVG.lossdiff</code> (then use the default <code>trend</code> = 0), or it can be passed in via the <code>trend</code> argument; the advantage (or disadvantage) of which is that the trend term will be included in the output object.  The third step is to fit a parametric variogram model to the empirical one using <code>flossdiff</code>.  The final, fourth step, is to conduct the test, which is performed by the <code>summary</code> function.
</p>
<p>In each step, different aspects of the model assumptions can be checked.  For example, isotropy can be checked by the plot in the lower right panel of the result of the <code>plot</code> method function after having called <code>empiricalVG.lossdiff</code>.  The function <code>nlminb</code> is used to fit the variogram model.
</p>
<p>For application to precipitation fields, and introduction to the image warp (coming soon) and distance map loss functions, see Gilleland (2013).
</p>


<h3>Value</h3>

<p>A list object is returned with possible components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>character vector naming the fields under comparison</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lossfun,lossfun.args,vgram.args </code></td>
<td>
<p>same as the arguments input to the lossdiff function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>m by n matrix giving the loss differential field, D(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend.fit</code></td>
<td>
<p>An OLS trend fitting the locations to the field via lm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>the self-same value as the argument passed in, or if NULL, it is the expanded grid coordinates.</p>
</td>
</tr>
</table>
<p>empiricalVG.lossdiff returns all of the above (carried over) along with 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lossdiff.vgram</code></td>
<td>
<p>list object as returned by vgram.matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>it is the self-same as the value passed in.</p>
</td>
</tr>
</table>
<p>flossdiff returns all of the above plus:
</p>
<table><tr style="vertical-align: top;">
<td><code>vgmodel</code></td>
<td>
<p>list object as returned by nls containing the fitted exponential variogram model where s is the estimate of sqrt(sill), and r of the range parameter (assuming 'flossdiff' was used to fit the variogram model).</p>
</td>
</tr></table>
<p>summary.lossdiff invisibly returns the same list object as above with additional components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Dbar</code></td>
<td>
<p>the estimated mean loss differential (over the entire field).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.statistic</code></td>
<td>
<p>the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>list object with components: two.sided–the two-sided alternative hypothesis–, less–the one-sided alternative hypothesis that the true value mu(D) &lt; 0–and greater–the one-sided alternative hypothesis that mu(D) &gt; 0–, p-values under the assumption of standard normality of the test statistic.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Diebold, F. X. and Mariano, R. S. (1995) Comparing predictive accuracy. <em>Journal of Business and Economic Statistics</em>, <b>13</b>, 253–263.
</p>
<p>Gilleland, E. (2013) Testing competing precipitation forecasts accurately and efficiently: The spatial prediction comparison test.  <em>Mon. Wea. Rev.</em>, <b>141</b>, (1), 340–355.
</p>
<p>Hering, A. S. and Genton, M. G. (2011) Comparing spatial predictions.  <em>Technometrics</em> <b>53</b>, (4), 414–425.
</p>


<h3>See Also</h3>

<p><code>vgram.matrix</code>, <code>nls</code>, <code>corrskill</code>, <code>abserrloss</code>, <code>sqerrloss</code>, <code>distmaploss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">grid&lt;- list( x = seq( 0, 5,, 25), y = seq(0,5,,25) )
obj&lt;-Exp.image.cov( grid = grid, theta = .5, setup = TRUE)

look&lt;- sim.rf( obj )
look[ look &lt; 0 ] &lt;- 0
look &lt;- zapsmall( look )
     
look2 &lt;- sim.rf( obj ) * .25
look2[ look2 &lt; 0 ] &lt;- 0
look2 &lt;- zapsmall( look2 )

look3 &lt;- sim.rf( obj) * 2 + 5
look3[ look3 &lt; 0 ] &lt;- 0 
look3 &lt;- zapsmall( look3 )

res &lt;- lossdiff( x = look, xhat1 = look2, xhat2 = look3, lossfun = "abserrloss" )
res &lt;- empiricalVG.lossdiff( res, maxrad = 8 )
res &lt;- flossdiff( res )
res &lt;- summary( res )

plot( res )

</code></pre>


</div>