<div class="container">

<table style="width: 100%;"><tr>
<td>ss.nonadh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find sample sizes accounting for nonadherence</h2>

<h3>Description</h3>

<p>Calculate sample sizes needed for a two-sample difference in means test accounting for nonadherence 
(i.e., noncompliance) in a proportion of subjects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ss.nonadh(mu0 = NULL, mu1 = NULL, delta = NULL, sigma0.sq = 1, 
    rho0 = 0, rho1 = 0, ss.ratio = 1, var.ratio = 1, deltaB = 0, 
    sig.level = 0.05, power = 0.8, alternative = c("two.sided", "one.sided"), 
    refinement = NULL,error.fisher=10^-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mu0</code></td>
<td>
<p> mean of control group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu1</code></td>
<td>
<p>mean of treatment group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>mu0 - mu1 </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma0.sq</code></td>
<td>
<p>variance of control group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho0</code></td>
<td>
<p>probability that a subject randomized to control will switch to treatment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho1</code></td>
<td>
<p>probability that a subject randomized to treatment will switch to control 
(or respond like control subjects)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ss.ratio</code></td>
<td>
<p>n1/n0, where n0 (n1) is sample size of control (treatment) group for proposed study</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.ratio</code></td>
<td>
<p><code class="reqn">\sigma_1^2/\sigma_0^2</code>, where <code class="reqn">\sigma_0</code> (<code class="reqn">\sigma_1</code>) is standard deviation of 
control (treatment) group for proposed study</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltaB</code></td>
<td>
<p> boundary value between null and alternative hypotheses for one-sided tests (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig.level</code></td>
<td>
<p>significance level (Type I error)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p> minimum power that you want the sample size to achieve</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refinement</code></td>
<td>
<p>More precise sample size estimates for certain types of responses, 
possible values: NULL (use asymptotic method), ‘Normal’ or 'N','Bernoulli' or 'B',
and 'Fisher.exact' or 'F'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.fisher</code></td>
<td>
<p>bound on the abolute error of the power calculations for the Fisher.exact refinement</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates the sample sizes for a study designed to test the difference between the means of two groups, 
where a proportion of those randomized to the control regimin switch to the treatment regimin (rho0) 
and a proportion of those randomized to the treatment regimin switch to the control regimin (rho1).
</p>
<p>You must supply either <code>mu0</code> and <code>mu1</code> or <code>delta</code>=mu0-mu1. 
The one-sided tests are designed to test either 
<code class="reqn">H_0: \delta \leq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &gt; \delta_B</code> or to test 
<code class="reqn">H_0: \delta \geq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &lt; \delta_B</code>.
The choice of hypotheses is determined by the value of <code>delta</code>; 
if <code>delta</code> <code class="reqn">&gt;</code> <code>deltaB</code> 
then the former hypotheses are tested, otherwise the latter are.
</p>
<p>The responses may be continuous, discrete, or even binary. 
The value <code>refinement</code> defines different methods related to the response type.
When refinement=NULL, the method is based on asymptotic normal approximation. 
For refinement='Normal' the method is based on the t-distribution derived when the responses are normal. 
For refinement='Bernoulli' the <code>sigma0.sq</code> and <code>var.ratio</code> values are defined by 
<code>mu0</code> and <code>mu1</code>, and the sample sizes do not use any continuity correction. 
For refinement='Fisher.exact' only the two-sided alternative is allowed and the sample size related to 
exact powers for the 2X2 Fisher exact test are calculated.  
</p>
<p>See Fay, Halloran and Follmann (2007) for details. 
</p>


<h3>Value</h3>

<p>Object of class "power.htest", a list of the arguments
(including the computed sample sizes) augmented with 'METHOD' and 'NOTE'
elements. The values 'n0' and 'n1' are the samples sizes for the two groups, rounded up to the nearest integer.
</p>


<h3>Note</h3>

 
<p>If you have a two-sided hypotheses with binary data, then refinement='Fisher.exact' is 
more accurate than refinement='Bernoulli',  but it  takes  considerably longer to run. 
If 'Fisher.exact' is chosen the method uses the <code>uniroot.integer</code> function, and 
if you ‘Esc’ during the calculation, intermediate 
exact powers will print. 
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

 <p><code>uniroot.integer</code>,
<code>ss.fromdata.neff</code>, 
<code>ss.fromdata.pois</code>,  
<code>ss.fromdata.nvar</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### Suppose treatment will not work on about 30 percent of subjects 
### then rho0=.3 and clinically significant difference in means is .5 
ss.nonadh(delta=.5,rho0=.3)

## Binary data, quick calculation
ss.nonadh(mu0=.1,mu1=.4,refinement="B")
# Calculate Fisher.exact before packaging, took about 8 seconds
#example.of.Fisher.exact&lt;-ss.nonadh(mu0=.1,mu1=.4,refinement="Fisher.exact")
data(example.of.Fisher.exact)
example.of.Fisher.exact

</code></pre>


</div>