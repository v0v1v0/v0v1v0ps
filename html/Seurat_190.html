<div class="container">

<table style="width: 100%;"><tr>
<td>IntegrateData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Integrate data</h2>

<h3>Description</h3>

<p>Perform dataset integration using a pre-computed <code>AnchorSet</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">IntegrateData(
  anchorset,
  new.assay.name = "integrated",
  normalization.method = c("LogNormalize", "SCT"),
  features = NULL,
  features.to.integrate = NULL,
  dims = 1:30,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  eps = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>anchorset</code></td>
<td>
<p>An <code>AnchorSet</code> object generated by
<code>FindIntegrationAnchors</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.assay.name</code></td>
<td>
<p>Name for the new assay containing the integrated data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>features</code></td>
<td>
<p>Vector of features to use when computing the PCA to determine
the weights. Only set if you want a different set from those used in the
anchor finding process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>features.to.integrate</code></td>
<td>
<p>Vector of features to integrate. By default,
will use the features used in anchor finding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Number of dimensions to use in the anchor weighting procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li>
<p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li>
<p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li>
<p>A vector of <code>DimReduc</code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li>
<p>NULL, in which case a new PCA will be calculated and used to
calculate anchor weights
</p>
</li>
</ul>
<p>Note that, if specified, the requested dimension reduction will only be used
for calculating anchor weights in the first merge between reference and
query, as the merged object will subsequently contain more cells than was in
query, and weights will need to be calculated for all cells in the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code>hclust</code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code>RANN</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>For pairwise integration:
</p>

<ul>
<li>
<p>Construct a weights matrix that defines the association between each
query cell and each anchor. These weights are computed as 1 - the distance
between the query cell and the anchor divided by the distance of the query
cell to the <code>k.weight</code>th anchor multiplied by the anchor score
computed in <code>FindIntegrationAnchors</code>. We then apply a Gaussian
kernel width a bandwidth defined by <code>sd.weight</code> and normalize across
all <code>k.weight</code> anchors.
</p>
</li>
<li>
<p>Compute the anchor integration matrix as the difference between the
two expression matrices for every pair of anchor cells
</p>
</li>
<li>
<p>Compute the transformation matrix as the product of the integration
matrix and the weights matrix.
</p>
</li>
<li>
<p>Subtract the transformation matrix from the original expression
matrix.
</p>
</li>
</ul>
<p>For multiple dataset integration, we perform iterative pairwise integration.
To determine the order of integration (if not specified via
<code>sample.tree</code>), we
</p>

<ul>
<li>
<p>Define a distance between datasets as the total number of cells in
the smaller dataset divided by the total number of anchors between the two
datasets.
</p>
</li>
<li>
<p>Compute all pairwise distances between datasets
</p>
</li>
<li>
<p>Cluster this distance matrix to determine a guide tree
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns a <code>Seurat</code> object with a new integrated
<code>Assay</code>. If <code>normalization.method = "LogNormalize"</code>, the
integrated data is returned to the <code>data</code> slot and can be treated as
log-normalized, corrected data. If <code>normalization.method = "SCT"</code>, the
integrated data is returned to the <code>scale.data</code> slot and can be treated
as centered, corrected Pearson residuals.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")

# perform standard preprocessing on each object
for (i in 1:length(pancreas.list)) {
  pancreas.list[[i]] &lt;- NormalizeData(pancreas.list[[i]], verbose = FALSE)
  pancreas.list[[i]] &lt;- FindVariableFeatures(
    pancreas.list[[i]], selection.method = "vst",
    nfeatures = 2000, verbose = FALSE
  )
}

# find anchors
anchors &lt;- FindIntegrationAnchors(object.list = pancreas.list)

# integrate data
integrated &lt;- IntegrateData(anchorset = anchors)

## End(Not run)

</code></pre>


</div>