<div class="container">

<table style="width: 100%;"><tr>
<td>ssn_lm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Linear Models for Spatial Stream Networks</h2>

<h3>Description</h3>

<p>This function works on spatial stream network objects to fit
linear models with spatially autocorrelated errors using likelihood methods, allowing for
non-spatial random effects, anisotropy, partition factors, big data methods, and more.
The spatial formulation is described in Ver Hoef and Peterson (2010)
and Peterson and Ver Hoef (2010).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssn_lm(
  formula,
  ssn.object,
  tailup_type = "none",
  taildown_type = "none",
  euclid_type = "none",
  nugget_type = "nugget",
  tailup_initial,
  taildown_initial,
  euclid_initial,
  nugget_initial,
  additive,
  estmethod = "reml",
  anisotropy = FALSE,
  random,
  randcov_initial,
  partition_factor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms on the right, separated by <code>+</code> operators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssn.object</code></td>
<td>
<p>A spatial stream network object with class <code>SSN</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tailup_type</code></td>
<td>
<p>The tailup covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>taildown_type</code></td>
<td>
<p>The taildown covariance function type. Available options
include <code>"linear"</code>, <code>"spherical"</code>, <code>"exponential"</code>,
<code>"mariah"</code>, <code>"epa"</code>, and <code>"none"</code>. Parameterizations are
described in Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>euclid_type</code></td>
<td>
<p>The euclidean covariance function type. Available options
include <code>"spherical"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"cosine"</code>, <code>"cubic"</code>, <code>"pentaspherical"</code>, <code>"wave"</code>,
<code>"jbessel"</code>, <code>"gravity"</code>, <code>"rquad"</code>, <code>"magnetic"</code>, and
<code>"none"</code>. Parameterizations are
described in Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nugget_type</code></td>
<td>
<p>The nugget covariance function type. Available options
include <code>"nugget"</code> or <code>"none"</code>. Parameterizations are
described in Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tailup_initial</code></td>
<td>
<p>An object from <code>tailup_initial()</code> specifying initial and/or
known values for the tailup covariance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>taildown_initial</code></td>
<td>
<p>An object from <code>taildown_initial()</code> specifying initial and/or
known values for the taildown covariance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>euclid_initial</code></td>
<td>
<p>An object from <code>euclid_initial()</code> specifying initial and/or
known values for the euclidean covariance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nugget_initial</code></td>
<td>
<p>An object from <code>nugget_initial()</code> specifying initial and/or
known values for the nugget covariance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>additive</code></td>
<td>
<p>The name of the variable in <code>ssn.object</code> that is used
to define spatial weights. Can be quoted or unquoted. For the tailup covariance functions, these additive
weights are used for branching. Technical details that describe the role
of the additive variable in the tailup covariance function are available
in Ver Hoef and Peterson (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood. The default is <code>"reml"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anisotropy</code></td>
<td>
<p>A logical indicating whether (geometric) anisotropy should
be modeled. Not required if <code>spcov_initial</code> is provided with 1) <code>rotate</code>
assumed unknown or assumed known and non-zero or 2) <code>scale</code> assumed unknown
or assumed known and less than one. When <code>anisotropy</code> is <code>TRUE</code>,
computational times can significantly increase. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances. See <code>spmodel::randcov_initial()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to <code>stats::optim()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The linear model for spatial stream networks can be written as
<code class="reqn">y = X \beta + zu + zd + ze + n</code>, where <code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">zu</code> is tailup random error,
<code class="reqn">zd</code> is taildown random error, and <code class="reqn">ze</code> is Euclidean random error,
and <code class="reqn">n</code> is nugget random error. The tailup random errors capture spatial
covariance moving downstream (and depend on downstream distance), the taildown
random errors capture spatial covariance moving upstream (and depend on upstream)
distance, the Euclidean random errors capture spatial covariance that depends on
Euclidean distance, and the nugget random errors captures variability
independent of spatial locations. The response <code class="reqn">y</code> is modeled using a
spatial covariance function expressed as
<code class="reqn">de(zu) * R(zu) + de(zd) * R(zd) + de(ze) * R(ze) + nugget * I</code>.
<code class="reqn">de(zu)</code>, <code class="reqn">de(zu)</code>, and <code class="reqn">de(zd)</code> represent the tailup, taildown, and Euclidean
variances, respectively. <code class="reqn">R(zu)</code>, <code class="reqn">R(zd)</code>, and <code class="reqn">R(ze)</code> represent the tailup,
taildown, and Euclidean correlation matrices, respectively. Each correlation
matrix depends on a range parameter that controls the distance-decay behavior
of the correlation. <code class="reqn">nugget</code> represents the nugget variance and
<code class="reqn">I</code> represents an identity matrix.
</p>
<p><code>tailup_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">W</code> be a diagonal matrix of weights from <code>additive</code>, <code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be
an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zu)</code> are given below:
</p>

<ul>
<li>
<p> linear: <code class="reqn">(1 - r) * (r &lt;= 1) * W</code>
</p>
</li>
<li>
<p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1) * W</code>
</p>
</li>
<li>
<p> exponential: <code class="reqn">exp(-r) * W</code>
</p>
</li>
<li>
<p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0) * W</code>
</p>
</li>
<li>
<p> epa: <code class="reqn">(D - range)^2 * F * (r &lt;= 1) * W / 16range^5</code>
</p>
</li>
<li>
<p> none: <code class="reqn">I</code> * W
</p>
</li>
</ul>
<p>Details describing the <code>F</code> matrix in the <code>epa</code> covariance are given in Garreta et al. (2010).
Flow-unconnected elements of <code class="reqn">R(zu)</code> are assumed uncorrelated.
Observations on different networks are also assumed uncorrelated.
</p>
<p><code>taildown_type</code> Details: Let <code class="reqn">D</code> be a matrix of hydrologic distances,
<code class="reqn">r = D / range</code>,
and <code class="reqn">I</code> be an identity matrix. Then parametric forms for flow-connected
elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li>
<p> linear: <code class="reqn">(1 - r) * (r &lt;= 1)</code>
</p>
</li>
<li>
<p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li>
<p> exponential: <code class="reqn">exp(-r)</code>
</p>
</li>
<li>
<p> mariah: <code class="reqn">log(90r + 1) / 90r * (D &gt; 0) + 1 * (D = 0)</code>
</p>
</li>
<li>
<p> epa: <code class="reqn">(D - range)^2 * F1 * (r &lt;= 1) / 16range^5</code>
</p>
</li>
<li>
<p> none: <code class="reqn">I</code>
</p>
</li>
</ul>
<p>Now let <code class="reqn">A</code> be a matrix that contains the shorter of the two distances
between two sites and the common downstream junction, <code class="reqn">r1 = A / range</code>,
<code class="reqn">B</code> be a matrix that contains the longer of the two distances between two sites and the
common downstream junction, <code class="reqn">r2 = B / range</code>,  and <code class="reqn">I</code> be an identity matrix.
Then parametric forms for flow-unconnected elements of <code class="reqn">R(zd)</code> are given below:
</p>

<ul>
<li>
<p> linear: <code class="reqn">(1 - r2) * (r2 &lt;= 1)</code>
</p>
</li>
<li>
<p> spherical: <code class="reqn">(1 - 1.5r1 + 0.5r2) * (1 - r2)^2 * (r2 &lt;= 1)</code>
</p>
</li>
<li>
<p> exponential: <code class="reqn">exp(-(r1 + r2))</code>
</p>
</li>
<li>
<p> mariah: <code class="reqn">(log(90r1 + 1) - log(90r2 + 1)) / (90r1 - 90r2) * (A =/ B) + (1 / (90r1 + 1)) * (A = B)</code>
</p>
</li>
<li>
<p> epa: <code class="reqn">(B - range)^2 * F2 * (r2 &lt;= 1) / 16range^5</code>
</p>
</li>
<li>
<p> none: <code class="reqn">I</code>
</p>
</li>
</ul>
<p>Details describing the <code>F1</code> and <code>F2</code> matrices in the <code>epa</code>
covariance are given in Garreta et al. (2010).
Observations on different networks are assumed uncorrelated.
</p>
<p><code>euclid_type</code> Details: Let <code class="reqn">D</code> be a matrix of Euclidean distances,
<code class="reqn">r = D / range</code>, and <code class="reqn">I</code> be an identity matrix. Then parametric
forms for elements of <code class="reqn">R(ze)</code> are given below:
</p>

<ul>
<li>
<p> exponential: <code class="reqn">exp(- r )</code>
</p>
</li>
<li>
<p> spherical: <code class="reqn">(1 - 1.5r + 0.5r^3) * (r &lt;= 1)</code>
</p>
</li>
<li>
<p> gaussian: <code class="reqn">exp(- r^2 )</code>
</p>
</li>
<li>
<p> cubic: <code class="reqn">(1 - 7r^2 + 8.75r^3 - 3.5r^5 + 0.75r^7) * (r &lt;= 1)</code>
</p>
</li>
<li>
<p> pentaspherical: <code class="reqn">(1 - 1.875r + 1.25r^3 - 0.375r^5) * (r &lt;= 1)</code>
</p>
</li>
<li>
<p> cosine: <code class="reqn">cos(r)</code>
</p>
</li>
<li>
<p> wave: <code class="reqn">sin(r) * (h &gt; 0) / r + (h = 0)</code>
</p>
</li>
<li>
<p> jbessel: <code class="reqn">Bj(h * range)</code>, Bj is Bessel-J function
</p>
</li>
<li>
<p> gravity: <code class="reqn">(1 + r^2)^{-0.5}</code>
</p>
</li>
<li>
<p> rquad: <code class="reqn">(1 + r^2)^{-1}</code>
</p>
</li>
<li>
<p> magnetic: <code class="reqn">(1 + r^2)^{-1.5}</code>
</p>
</li>
<li>
<p> none: <code class="reqn">I</code>
</p>
</li>
</ul>
<p><code>nugget_type</code> Details: Let <code class="reqn">I</code> be an identity matrix and <code class="reqn">0</code>
be the zero matrix. Then parametric
forms for elements the nugget variance are given below:
</p>

<ul>
<li>
<p> nugget: <code class="reqn">I</code>
</p>
</li>
<li>
<p> none: <code class="reqn">0</code>
</p>
</li>
</ul>
<p>In short, the nugget effect is modeled when <code>nugget_type</code> is <code>"nugget"</code>
and omitted when <code>nugget_type</code> is <code>"none"</code>.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li>
</ul>
<p><code>anisotropy</code> Details: By default, all Euclidean covariance parameters except <code>rotate</code>
and <code>scale</code> are assumed unknown, requiring estimation. If either <code>rotate</code> or <code>scale</code>
are given initial values other than 0 and 1 (respectively) or are assumed unknown
in <code>euclid_initial()</code>, <code>anisotropy</code> is implicitly set to <code>TRUE</code>.
(Geometric) Anisotropy is modeled by transforming a Euclidean covariance function that
decays differently in different directions to one that decays equally in all
directions via rotation and scaling of the original Euclidean coordinates. The rotation is
controlled by the <code>rotate</code> parameter in <code class="reqn">[0, \pi]</code> radians. The scaling
is controlled by the <code>scale</code> parameter in <code class="reqn">[0, 1]</code>. The anisotropy
correction involves first a rotation of the coordinates clockwise by <code>rotate</code> and then a
scaling of the coordinates' minor axis by the reciprocal of <code>scale</code>. The Euclidean
covariance is then computed using these transformed coordinates.
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + W1\gamma 1 + ... Wj\gamma j + zu + zd + ze + n</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details: The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Other Details: Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>.
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object and has class <code>ssn_lm</code>. Many generic functions that
summarize model fit are available for <code>ssn_lm</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>.
</p>
<p>This fitted model list contains the following elements:
</p>

<ul>
<li> <p><code>additive</code>: The name of the additive function value column.
</p>
</li>
<li> <p><code>anisotropy</code>: Whether euclidean anisotropy was modeled.
</p>
</li>
<li> <p><code>call</code>: The function call.
</p>
</li>
<li> <p><code>coefficients</code>: Model coefficients.
</p>
</li>
<li> <p><code>contrasts</code>: Any user-supplied contrasts.
</p>
</li>
<li> <p><code>cooks_distance</code>: Cook's distance values.
</p>
</li>
<li> <p><code>crs</code>: The geographic coordinate reference system.
</p>
</li>
<li> <p><code>deviance</code>: The model deviance.
</p>
</li>
<li> <p><code>diagtol</code>: A tolerance value that may be added to the diagonal
of  ovariance matrices to encourage decomposition stability.
</p>
</li>
<li> <p><code>estmethod</code>: The estimation method.
</p>
</li>
<li> <p><code>euclid_max</code>: The maximum euclidean distance.
</p>
</li>
<li> <p><code>fitted</code>: Fitted values.
</p>
</li>
<li> <p><code>formula</code>: The model formula.
</p>
</li>
<li> <p><code>hatvalues</code>: The hat (leverage) values.
</p>
</li>
<li> <p><code>is_known</code>: An object that identifies which parameters are known.
</p>
</li>
<li> <p><code>local_index</code>: An index identifier used internally for sorting.
</p>
</li>
<li> <p><code>missing_index</code>: Which rows in the "obs" object had missing responses.
</p>
</li>
<li> <p><code>n</code>: The sample size.
</p>
</li>
<li> <p><code>npar</code>: The number of estimated covariance parameters.
</p>
</li>
<li> <p><code>observed_index</code>: Which rows in the "obs" object had observed responses.
</p>
</li>
<li> <p><code>optim</code>: The optimization output.
</p>
</li>
<li> <p><code>p</code>: The number of fixed effects.
</p>
</li>
<li> <p><code>partition_factor</code>: The partition factor formula.
</p>
</li>
<li> <p><code>pseudoR2</code>: The pseudo R-squared.
</p>
</li>
<li> <p><code>random</code>: The random effect formula.
</p>
</li>
<li> <p><code>residuals</code>: The residuals.
</p>
</li>
<li> <p><code>sf_column_name</code>: The name of the geometry columns <code>ssn.object</code>
</p>
</li>
<li> <p><code>ssn.object</code>: An updated <code>ssn.object</code>.
</p>
</li>
<li> <p><code>tail_max</code>: The maximum stream distance.
</p>
</li>
<li> <p><code>terms</code>: The model terms.
</p>
</li>
<li> <p><code>vcov</code>: Variance-covariance matrices
</p>
</li>
<li> <p><code>xlevels</code>: The levels of factors in the model matrix.
</p>
</li>
</ul>
<p>These list elements are meant to be used with various generic functions
(<code>e.g., residuals()</code> that operate on the model object.
While possible to access elements of the fitted model list directly, we strongly
advise against doing so when there is a generic available to return the element
of interest. For example, we strongly recommend using <code>residuals()</code> to
obtain model residuals instead of accessing the fitted model list directly via
<code>object$residuals</code>.
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>References</h3>

<p>Garreta, V., Monestiez, P. and Ver Hoef, J.M. (2010) Spatial modelling and
prediction on river networks: up model, down model, or hybrid?
<em>Environmetrics</em> <b>21(5)</b>, 439–456.
</p>
<p>Peterson, E.E. and Ver Hoef, J.M. (2010) A mixed-model moving-average approach
to geostatistical modeling in stream networks. <em>Ecology</em> <b>91(3)</b>,
644–651.
</p>
<p>Ver Hoef, J.M. and Peterson, E.E. (2010) A moving average approach for spatial
statistical models of stream networks (with discussion).
<em>Journal of the American Statistical Association</em> <b>105</b>, 6–18.
DOI: 10.1198/jasa.2009.ap08248.  Rejoinder pgs. 22–24.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Copy the mf04p .ssn data to a local directory and read it into R
# When modeling with your .ssn object, you will load it using the relevant
# path to the .ssn data on your machine
copy_lsn_to_temp()
temp_path &lt;- paste0(tempdir(), "/MiddleFork04.ssn")
mf04p &lt;- ssn_import(temp_path, overwrite = TRUE)

ssn_mod &lt;- ssn_lm(
  formula = Summer_mn ~ ELEV_DEM,
  ssn.object = mf04p,
  tailup_type = "exponential",
  additive = "afvArea"
)
summary(ssn_mod)

</code></pre>


</div>