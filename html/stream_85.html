<div class="container">

<table style="width: 100%;"><tr>
<td>DSC_DStream</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>D-Stream Data Stream Clustering Algorithm</h2>

<h3>Description</h3>

<p>Micro Clusterer with reclustering.
Implements the grid-based D-Stream data stream clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">DSC_DStream(
  formula = NULL,
  gridsize,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  Cl = 0.8,
  attraction = FALSE,
  epsilon = 0.3,
  Cm2 = Cm,
  k = NULL,
  N = 0
)

get_attraction(x, relative = FALSE, grid_type = "dense", dist = FALSE)

## S3 method for class 'DSC_DStream'
plot(
  x,
  dsd = NULL,
  n = 500,
  type = c("auto", "micro", "macro", "both"),
  grid = FALSE,
  grid_type = "used",
  assignment = FALSE,
  ...
)

DSOutlier_DStream(
  formula = NULL,
  gridsize,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  Cl = 0.8,
  outlier_multiplier = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model formula of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridsize</code></td>
<td>
<p>a single number defining the size of grid cells in each dimension.
For example for 3d data, the cells would be of size <code style="white-space: pre;">⁠gridsize x gridsize x gridsize⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Fading constant used function to calculate the decay factor
<code class="reqn">2^-lambda</code>.  (Note: in the paper the authors use lamba to denote the
decay factor and not the fading constant!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gaptime</code></td>
<td>
<p>sporadic grids are removed every gaptime number of points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cm</code></td>
<td>
<p>density threshold used to detect dense grids as a proportion of
the average expected density (Cm &gt; 1). The average density is given by the
total weight of the clustering over <code class="reqn">N</code>, the number of grid cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cl</code></td>
<td>
<p>density threshold to detect sporadic grids (0 &gt; Cl &gt; Cm).
Transitional grids have a density between Cl and Cm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attraction</code></td>
<td>
<p>compute and store information about the attraction between
adjacent grids. If <code>TRUE</code> then attraction is used to create
macro-clusters, otherwise macro-clusters are created by merging adjacent
dense grids.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>overlap parameter for attraction as a proportion of
<code>gridsize</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cm2</code></td>
<td>
<p>threshold on attraction to join two dense grid cells (as a
proportion on the average expected attraction).  In the original algorithm
<code>Cm2</code> is equal to <code>Cm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>alternative to Cm2 (not in the original algorithm).  Create k
clusters based on attraction. In case of more than k unconnected components,
closer groups of MCs are joined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Fix the number of grid cells used for the calculation of the
density thresholds with Cl and Cm. If <code>N</code> is not given (0) then the
algorithm tries to determine N from the data. Note that this means that N
potentially increases over time and outliers might produce an extremely
large value which will lead to a sudden creation of too many dense
micro-clusters. The original paper assumed that N is known a priori.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>DSC_DStream object to get attraction values from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>
<p>calculates relative attraction (normalized by the cluster
weight).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_type</code></td>
<td>
<p>the attraction between what grid types should be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>make attraction symmetric and transform into a distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dsd</code></td>
<td>
<p>a DSD data stream object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of plots taken from <code>dsd</code> to plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Plot micro clusters (<code>type = "micro"</code>), macro clusters (<code>type = "macro"</code>),
both micro and macro clusters (<code>type = "both"</code>), outliers(<code>type = "outliers"</code>),
or everything together (<code>type = "all"</code>). <code>type = "auto"</code> leaves to the class of DSC to decide.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>logical; show the D-Stream grid instead of circles for micro-clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignment</code></td>
<td>
<p>logical; show assignment area of micro-clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further argument are passed on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outlier_multiplier</code></td>
<td>
<p>multiplier for assignment grid width to declare outliers.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>D-Stream creates an equally spaced grid and estimates the density in each
grid cell using the count of points falling in the cells. Grid cells are
classified based on density into dense, transitional and sporadic cells.
The density is faded after every new point by a factor of <code class="reqn">2^{-lambda}</code>.
Every gaptime number of points sporadic grid cells are removed.
</p>
<p>For reclustering D-Stream (2007 version) merges adjacent dense grids to form
macro-clusters and then assigns adjacent transitional grids to
macro-clusters. This behavior is implemented as <code>attraction = FALSE</code>.
</p>
<p>The 2009 version of the algorithm adds the concept of attraction between
grids cells. If <code>attraction = TRUE</code> is used then the algorithm produces
macro-clusters based on attraction between dense adjacent grids (uses
<code>Cm2</code> which in the original algorithm is equal to <code>Cm</code>).
</p>
<p>For many functions (e.g., <code>get_centers()</code>, <code>plot()</code>), D-Stream
adds a parameter <code>grid_type</code> with possible values of <code>"dense"</code>,
<code>"transitional"</code>, <code>"sparse"</code>, <code>"all"</code> and <code>"used"</code>. This
only returns the selected type of grid cells. <code>"used"</code> includes dense
and adjacent transitional cells which are used in D-Stream for reclustering.
For <code>plot()</code> D-Stream also provides extra parameters <code>"grid"</code> and
<code>"grid_type"</code> to show micro-clusters as grid cells (density represented
by gray values).
</p>
<p><code>DSOutlier_DStream</code> classifies points that do not fall into a dense grid cell as
outlier/noise. Parameter <code>outlier_multiplier</code> specifies
how far the point needs to be away from a dense cell to be classified as an outlier by multiplying the grid
size.
</p>
<p>Note that <code>DSC_DStream</code> currently cannot be saved to disk using
save() or saveRDS(). This functionality will be added later!
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_DStream</code> (subclass of DSC,
DSC_R, DSC_Micro).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Yixin Chen and Li Tu. 2007. Density-based clustering for
real-time stream data. In <em>Proceedings of the 13th ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining (KDD '07).</em>
ACM, New York, NY, USA, 133-142.
</p>
<p>Li Tu and Yixin Chen. 2009. Stream data clustering based on grid density and
attraction. <em>ACM Transactions on Knowledge Discovery from Data,</em> 3(3),
Article 12 (July 2009), 27 pages.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code>DSC_BICO()</code>,
<code>DSC_BIRCH()</code>,
<code>DSC_DBSTREAM()</code>,
<code>DSC_Micro()</code>,
<code>DSC_Sample()</code>,
<code>DSC_Window()</code>,
<code>DSC_evoStream()</code>
</p>
<p>Other DSC_TwoStage: 
<code>DSC_DBSTREAM()</code>,
<code>DSC_TwoStage()</code>,
<code>DSC_evoStream()</code>
</p>
<p>Other DSOutlier: 
<code>DSC_DBSTREAM()</code>,
<code>DSOutlier()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">stream &lt;- DSD_BarsAndGaussians(noise = .05)
plot(stream)

dstream1 &lt;- DSC_DStream(gridsize = 1, Cm = 1.5)
update(dstream1, stream, 1000)
dstream1

# micro-clusters (these are "used" grid cells)
nclusters(dstream1)
head(get_centers(dstream1))

# plot (DStream provides additional grid visualization)
plot(dstream1, stream)
plot(dstream1, stream, grid = TRUE)

# look only at dense grids
nclusters(dstream1, grid_type = "dense")
plot(dstream1, stream, grid = TRUE, grid_type = "dense")

# look at transitional and sparse cells
plot(dstream1, stream, grid = TRUE, grid_type = "transitional")
plot(dstream1, stream, grid = TRUE, grid_type = "sparse")

### Macro-clusters
# standard D-Stream uses reachability
nclusters(dstream1, type = "macro")
get_centers(dstream1, type = "macro")
plot(dstream1, stream, type = "macro")
evaluate_static(dstream1, stream, measure = "crand", type = "macro")

# use attraction for reclustering
dstream2 &lt;- DSC_DStream(gridsize = 1, attraction = TRUE, Cm = 1.5)
update(dstream2, stream, 1000)
dstream2

plot(dstream2, stream, grid = TRUE)
evaluate_static(dstream2, stream, measure = "crand", type = "macro")
</code></pre>


</div>