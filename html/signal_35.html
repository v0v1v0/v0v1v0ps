<div class="container">

<table style="width: 100%;"><tr>
<td>ellip</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Elliptic or Cauer filter </h2>

<h3>Description</h3>

<p>Generate an Elliptic or Cauer filter (discrete and continuous).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
ellip(n, Rp, Rs, W, type = c("low", "high", "stop",
"pass"), plane = c("z", "s"), ...)

## S3 method for class 'FilterOfOrder'
ellip(n, Rp = n$Rp, Rs = n$Rs, W = n$Wc, type = n$type, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> filter order or generic filter model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rp</code></td>
<td>
<p> dB of pass band ripple </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rs</code></td>
<td>
<p> dB of stop band ripple </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p> critical frequencies of the filter. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. For digital filters, <code>W</code> must be between 0 and 1
where 1 is the Nyquist frequency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> Filter type, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band (band-reject)
filter, or <code>"pass"</code> for a pass-band filter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plane</code></td>
<td>
 <p><code>"z"</code> for a digital filter or <code>"s"</code> for an
analog filter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments passed to <code>ellip</code>,
overriding those given by <code>n</code> of class <code>FilterOfOrder</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Because <code>ellip</code> is generic, it can be extended to accept other
inputs, using <code>"ellipord"</code> to generate filter criteria for example.
</p>


<h3>Value</h3>

<p>An <code>Arma</code> object with list elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Original Octave version by Paulo Neis
<a href="mailto:p_neis@yahoo.com.br">p_neis@yahoo.com.br</a>.
Modified by Doug Stewart. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Oppenheim, Alan V., <em>Discrete Time Signal Processing</em>,
Hardcover, 1999.
</p>
<p>Parente Ribeiro, E., Notas de aula da disciplina TE498 -  Processamento 
Digital de Sinais, UFPR, 2001/2002.
</p>
<p><a href="https://en.wikipedia.org/wiki/Elliptic_filter">https://en.wikipedia.org/wiki/Elliptic_filter</a>
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code>Arma</code>, <code>filter</code>, <code>butter</code>,
<code>cheby1</code>, and <code>ellipord</code></p>


<h3>Examples</h3>

<pre><code class="language-R">  # compare the frequency responses of 5th-order Butterworth and elliptic filters.
  bf &lt;- butter(5, 0.1)
  ef &lt;- ellip(5, 3, 40, 0.1)
  bfr &lt;- freqz(bf)
  efr &lt;- freqz(ef)
  plot(bfr$f, 20 * log10(abs(bfr$h)), type = "l", ylim = c(-50, 0),
       xlab = "Frequency, radians", ylab = c("dB"))
  lines(efr$f, 20 * log10(abs(efr$h)), col = "red")
</code></pre>


</div>