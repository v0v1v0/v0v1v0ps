<div class="container">

<table style="width: 100%;"><tr>
<td>Spatial location</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate location estimates based on spatial signs and signed ranks</h2>

<h3>Description</h3>

<p> Iterative algorithms to find spatial median, multivariate Hodges-Lehmann estimate of
location, their affine equivariant versions and k-step versions of these. </p>


<h3>Usage</h3>

<pre><code class="language-R">
spatial.location(X, score = c("sign", "signrank"), init = NULL, 
shape = TRUE, steps = Inf, maxiter = 500, eps = 1e-6, 
na.action = na.fail) 

ae.spatial.median(X, init = NULL, shape = TRUE, steps = Inf, 
maxiter = 500, eps = 1e-6, na.action = na.fail)

ae.hl.estimate(X, init = NULL, shape = TRUE, steps = Inf, 
maxiter = 500, eps = 1e-06, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix or a data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>an optional vector giving the initial point of the iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>logical, or a matrix. See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>fixed number of iteration steps to take, if <code>Inf</code> iteration is repeated until convergence (or until <code>maxiter</code> steps)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>tolerance for convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iteration steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Spatial median and Hodges-Lehmann estimator (spatial median of the pairwise differences) are not affine equivariant. Affine
equivariance can be achieved by simultaneously estimating the
corresponding shape, as proposed for the spatial median by
Hettmansperger and Randles (2002). For spatial median the corresponding
shape is <code>signs.shape</code> and for the Hodges-Lehmann estimate it
is <code>signrank.shape</code>.
</p>
<p><code>spatial.location</code> is a wrapper function for a unified access to
both location estimates. The choice of estimate is done via
<code>score</code>:
</p>

<ul>
<li> <p><code>"sign"</code> for spatial median 
</p>
</li>
<li> <p><code>"signrank"</code> for Hodges-Lehmann estimate 
</p>
</li>
</ul>
<p>If a matrix (must be symmetric and positive definite, but this is not
checked) is given as <code>shape</code> the location estimate is found with
respect to that shape and no further shape estimation is done. If a
logical <code>TRUE</code> is given as <code>shape</code> the shape is estimated
and consequently the affine equivariant version of the location
estimate is found.  If <code>shape</code> is <code>FALSE</code> then shape
estimation is not done and the non affine equivariant versions of the
location estimate, that is the spatial median and the Hodges-Lehmann estimate are found.
</p>


<h3>Value</h3>

<p>The estimate vector with the (final estimate of or given) shape matrix 
as attribute <code>"shape"</code>.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a>, Jari Miettinen, <a href="mailto:jari.p.miettinen@aalto.fi">jari.p.miettinen@aalto.fi</a></p>


<h3>References</h3>

<p>Hettmansperger, T. and Randles, R. (2002) A Practical Affine Equivariant Multivariate Median, Biometrika, 89, pp. 851-860</p>


<h3>See Also</h3>

<p><code>spatial.median</code>, <code>signrank.shape</code></p>


<h3>Examples</h3>

<pre><code class="language-R">A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(3000),ncol=3)%*%t(A)
spatial.location(X,score="signrank")
spatial.location(X,score="sign")
#compare with:
colMeans(X)
ae.hl.estimate(X,shape=A%*%t(A))
ae.hl.estimate(X,shape=FALSE)
</code></pre>


</div>