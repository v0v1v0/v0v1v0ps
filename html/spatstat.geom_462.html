<div class="container">

<table style="width: 100%;"><tr>
<td>interp.im</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolate a Pixel Image</h2>

<h3>Description</h3>

<p>Interpolates the values of a pixel image at any
desired location in the frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interp.im(Z, x, y=NULL, bilinear=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>)
with numeric or integer values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>

<p>Vectors of Cartesian coordinates.
Alternatively <code>x</code> can be a point pattern and <code>y</code> can be missing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bilinear</code></td>
<td>

<p>Logical value specifying the choice of interpolation rule.
If <code>bilinear=TRUE</code> then a bilinear interpolation rule is used.
If <code>bilinear=FALSE</code> (the default) then a slightly biased rule
is used; this rule is consistent with earlier versions of
<span class="pkg">spatstat</span>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A value at each location <code>(x[i],y[i])</code> will be
interpolated using the pixel values of <code>Z</code> at the four
surrounding pixel centres, by simple bilinear interpolation.
</p>
<p>At the boundary (where <code>(x[i],y[i])</code> is not surrounded by
four pixel centres) the value at the nearest pixel
is taken.
</p>
<p>The arguments <code>x,y</code> can be anything acceptable to
<code>xy.coords</code>.
</p>


<h3>Value</h3>

<p>Vector of interpolated values, with <code>NA</code> for points that lie
outside the domain of the image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
with a contribution from an anonymous user.
</p>


<h3>Examples</h3>

<pre><code class="language-R">   opa &lt;- par(mfrow=c(1,2))
   # coarse image
   V &lt;- as.im(function(x,y) { x^2 + y }, owin(), dimyx=10)
   plot(V, main="coarse image", col=terrain.colors(256))

   # lookup value at location (0.5,0.5)
   V[list(x=0.5,y=0.5)]
   # interpolated value at location (0.5,0.5)
   interp.im(V, 0.5, 0.5)
   interp.im(V, 0.5, 0.5, bilinear=TRUE)
   # true value is 0.75

   # how to obtain an interpolated image at a desired resolution
   U &lt;- as.im(interp.im, W=owin(), Z=V, dimyx=256)
   plot(U, main="interpolated image", col=terrain.colors(256))
   par(opa)
</code></pre>


</div>