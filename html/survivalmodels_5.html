<div class="container">

<table style="width: 100%;"><tr>
<td>coxtime</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cox-Time Survival Neural Network</h2>

<h3>Description</h3>

<p>Cox-Time fits a neural network based on the Cox PH with
possibly time-dependent effects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coxtime(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  standardize_time = FALSE,
  log_duration = FALSE,
  with_mean = TRUE,
  with_std = TRUE,
  activation = "relu",
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  dropout = NULL,
  device = NULL,
  shrink = 0,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>(formula(1))</code><br>
Object specifying the model fit, left-hand-side of formula should describe a <code>survival::Surv()</code>
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>(data.frame(1))</code><br>
Training data of <code>data.frame</code> like object, internally is coerced with <code>stats::model.matrix()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_variable</code></td>
<td>
<p><code>(character(1))</code><br>
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status_variable</code></td>
<td>
<p><code>(character(1))</code><br>
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>(data.frame(1))</code><br>
Alternative method to call the function. Required if <code style="white-space: pre;">⁠formula, time_variable⁠</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code style="white-space: pre;">⁠([survival::Surv()])⁠</code><br>
Alternative method to call the function. Required if <code style="white-space: pre;">⁠formula, time_variable⁠</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frac</code></td>
<td>
<p><code>(numeric(1))</code> <br>
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize_time</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code>, the time outcome is standardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_duration</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code> and <code>standardize_time</code> is <code>TRUE</code> then time variable is log transformed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_mean</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code> (default) and <code>standardize_time</code> is <code>TRUE</code> then time variable is centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_std</code></td>
<td>
<p><code>(logical(1))</code><br>
If <code>TRUE</code> (default) and <code>standardize_time</code> is <code>TRUE</code> then time variable is scaled to unit
variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activation</code></td>
<td>
<p><code>(character(1))</code> <br>
See get_pycox_activation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_nodes, batch_norm, dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br>
See build_pytorch_net.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br>
Passed to <code>pycox.models.Coxtime</code>, specifies device to compute models on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrink</code></td>
<td>
<p><code>(numeric(1))</code><br>
Passed to <code>pycox.models.Coxtime</code>, shrinkage parameter for regularization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping, best_weights, min_delta, patience</code></td>
<td>
<p><code style="white-space: pre;">⁠(logical(1)/logical(1)/numeric(1)/integer(1)⁠</code> <br>
See get_pycox_callbacks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.Coxtime.fit</code>, elements in each batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.Coxtime.fit</code>, number of epochs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>(logical(1))</code><br>
Passed to <code>pycox.models.Coxtime.fit</code>, should information be displayed during
fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_workers</code></td>
<td>
<p><code>(integer(1))</code><br>
Passed to <code>pycox.models.Coxtime.fit</code>, number of workers used in the
dataloader.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle</code></td>
<td>
<p><code>(logical(1))</code><br>
Passed to <code>pycox.models.Coxtime.fit</code>, should order of dataset be shuffled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>ANY</code> <br>
Passed to get_pycox_optim.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.Coxtime</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>coxtime</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Kvamme, H., Borgan, Ø., &amp; Scheel, I. (2019).
Time-to-event prediction with neural networks and Cox regression.
Journal of Machine Learning Research, 20(129), 1–30.
</p>


</div>