<div class="container">

<table style="width: 100%;"><tr>
<td>SMMA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Soft Maximin Estimation for Large Scale Array Data with Known Groups</h2>

<h3>Description</h3>

<p>Efficient design matrix free procedure for solving a soft maximin problem for
large scale array-tensor structured models, see  <cite>Lund et al., 2020</cite>.
Currently Lasso and SCAD penalized estimation is implemented.
</p>


<h3>Usage</h3>

<pre><code class="language-R">softmaximin(X,
            Y,
            zeta,
            penalty = c("lasso", "scad"),
            alg = c("npg", "fista"),
            nlambda = 30,
            lambda.min.ratio = 1e-04,
            lambda = NULL,
            penalty.factor = NULL,
            reltol = 1e-05,
            maxiter = 15000,
            steps = 1,
            btmax = 100,
            c = 0.0001,
            tau = 2,
            M = 4,
            nu = 1,
            Lmin = 0,
            log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>list containing the Kronecker components (1, 2 or 3) of the Kronecker design matrix.
These are  matrices of sizes <code class="reqn">n_i \times p_i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>array of size <code class="reqn">n_1 \times\cdots\times n_d \times G</code> containing the response values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>
<p>strictly positive float controlling  the softmaximin approximation accuracy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>string specifying the penalty type. Possible values are <code>"lasso", "scad"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg</code></td>
<td>
<p>string specifying the optimization algorithm. Possible values are <code>"npg", "fista"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>positive integer giving the number of <code>lambda</code> values. Used when lambda is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>strictly positive float giving the smallest value for <code>lambda</code>, as a fraction of
<code class="reqn">\lambda_{max}</code>; the (data dependent) smallest value for which all coefficients are zero.
Used when lambda is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>sequence of strictly positive floats used  as penalty parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>array of size <code class="reqn">p_1 \times \cdots \times p_d</code> of positive floats. Is multiplied
with each element in <code>lambda</code> to allow differential penalization on the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>strictly positive float giving the convergence tolerance for the inner loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>positive integer giving the maximum number of  iterations allowed for each <code>lambda</code>
value, when  summing over all outer iterations for said <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>strictly positive integer giving the number of steps used in the multi-step adaptive lasso algorithm for non-convex penalties.
Automatically set to 1 when <code>penalty = "lasso"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>btmax</code></td>
<td>
<p>strictly positive integer giving the maximum number of backtracking steps allowed in each iteration. Default is <code>btmax = 100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>strictly positive float used in the NPG algorithm. Default is <code>c = 0.0001</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>strictly positive float used to control the stepsize for NPG. Default is <code>tau = 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>positive integer giving the look back for the NPG. Default is <code>M = 4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>strictly positive float used to control the stepsize. A  value less that 1 will decrease
the stepsize and a value larger than one will increase it. Default is <code>nu = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lmin</code></td>
<td>
<p>non-negative float used by the NPG algorithm to control the stepsize. For the default  <code>Lmin = 0</code>
the maximum step size is the same as for the FISTA algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical variable indicating whether to use log-loss.  TRUE is default and yields the loss below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Following <cite>Lund et al., 2020</cite>  this package solves the optimization problem for a linear
model for heterogeneous <code class="reqn">d</code>-dimensional array data (<code class="reqn">d=1,2,3</code>) organized in <code class="reqn">G</code> known groups,
and with identical tensor structured design matrix <code class="reqn">X</code> across all groups.  Specifically <code class="reqn">n = \prod_i^d n_i</code> is the
number of observations in each group, <code class="reqn">Y_g</code>  the  <code class="reqn">n_1\times \cdots \times n_d</code> response array
for group <code class="reqn">g \in \{1,\ldots,G\}</code>, and <code class="reqn">X</code>  a <code class="reqn">n\times p</code> design matrix, with tensor structure
</p>
<p style="text-align: center;"><code class="reqn">X = \bigotimes_{i=1}^d X_i.</code>
</p>

<p>For <code class="reqn">d =1,2,3</code>, <code class="reqn">X_1,\ldots, X_d</code> are the marginal <code class="reqn">n_i\times p_i</code> design matrices (Kronecker components).
Using the GLAM framework  the model equation for group <code class="reqn">g\in \{1,\ldots,G\}</code> is expressed as
</p>
<p style="text-align: center;"><code class="reqn">Y_g = \rho(X_d,\rho(X_{d-1},\ldots,\rho(X_1,B_g))) + E_g,</code>
</p>

<p>where <code class="reqn">\rho</code> is the so called rotated <code class="reqn">H</code>-transfrom (see  <cite>Currie et al., 2006</cite>),
<code class="reqn">B_g</code> for each <code class="reqn">g</code> is a (random) <code class="reqn">p_1\times\cdots\times p_d</code> parameter array
and <code class="reqn">E_g</code>  is  a <code class="reqn">n_1\times \cdots \times n_d</code> error array.
</p>
<p>This package solves the penalized soft maximin problem from <cite>Lund et al., 2020</cite>, given by
</p>
<p style="text-align: center;"><code class="reqn">\min_{\beta}\frac{1}{\zeta}\log\bigg(\sum_{g=1}^G \exp(-\zeta \hat V_g(\beta))\bigg) + \lambda  \Vert\beta\Vert_1, \quad \zeta &gt; 0,\lambda \geq 0</code>
</p>

<p>for the setup described above. Note that
</p>
<p style="text-align: center;"><code class="reqn">\hat V_g(\beta):=\frac{1}{n}(2\beta^\top X^\top vec(Y_g)-\beta^\top X^\top X\beta),</code>
</p>

<p>is the empirical explained variance from <cite>Meinshausen and Buhlmann, 2015</cite>.  See <cite>Lund et al., 2020</cite> for more details and references.
</p>
<p>For <code class="reqn">d=1,2,3</code>, using only the marginal matrices <code class="reqn">X_1,X_2,\ldots</code> (for <code class="reqn">d=1</code> there is only one marginal), the function <code>softmaximin</code>
solves the soft maximin problem for a sequence of penalty parameters <code class="reqn">\lambda_{max}&gt;\ldots &gt;\lambda_{min}&gt;0</code>.
</p>
<p>Two optimization algorithms  are implemented, a non-monotone
proximal gradient (NPG) algorithm and a fast iterative soft thresholding algorithm (FISTA).
We note that this package also solves the problem above with the penalty given by the SCAD
penalty, using the multiple step adaptive lasso procedure to loop over the proximal algorithm.
</p>


<h3>Value</h3>

<p>An object with S3 Class "SMMA".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>A string indicating the array dimension (1, 2 or 3) and the penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>A <code class="reqn">p_1\cdots p_d \times</code> <code>nlambda</code> matrix containing the estimates of
the model coefficients (<code>beta</code>) for each <code>lambda</code>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector containing the sequence of penalty values used in the estimation procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Obj</code></td>
<td>
<p>A matrix containing the objective values for each iteration and each model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimcoef</code></td>
<td>
<p>A vector giving the dimension of the model coefficient array <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimobs</code></td>
<td>
<p>A vector giving the dimension of the observation (response) array <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Iter</code></td>
<td>
<p>A list with 4 items:
<code>bt_iter</code>  is total number of backtracking steps performed,
<code>bt_enter</code> is the number of times the backtracking is initiated,
and <code>iter_mat</code> is a vector containing the  number of  iterations for each <code>lambda</code> value
and  <code>iter</code> is total number of iterations i.e. <code>sum(Iter)</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam Lund
</p>
<p>Maintainer: Adam Lund, <a href="mailto:adam.lund@math.ku.dk">adam.lund@math.ku.dk</a>
</p>


<h3>References</h3>

<p>Lund, A., S. W. Mogensen and N. R. Hansen (2020). Soft Maximin Estimation for Heterogeneous Array Data.
<em>Preprint</em>.
</p>
<p>Meinshausen, N and P. Buhlmann (2015). Maximin effects in inhomogeneous large-scale data.
<em>The Annals of Statistics</em>. 43, 4, 1801-1830. url = https://doi.org/10.1214/15-AOS1325.
</p>
<p>Currie, I. D., M. Durban, and P. H. C. Eilers (2006). Generalized linear
array models with applications to multidimensional smoothing.
<em>Journal of the Royal Statistical Society. Series B</em>. 68, 259-280. url = http://dx.doi.org/10.1111/j.1467-9868.2006.00543.x.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##size of example
n1 &lt;- 65; n2 &lt;- 26; n3 &lt;- 13; p1 &lt;- 13; p2 &lt;- 5; p3 &lt;- 4

##marginal design matrices (Kronecker components)
X1 &lt;- matrix(rnorm(n1 * p1), n1, p1)
X2 &lt;- matrix(rnorm(n2 * p2), n2, p2)
X3 &lt;- matrix(rnorm(n3 * p3), n3, p3)
X &lt;- list(X1, X2, X3)

component &lt;- rbinom(p1 * p2 * p3, 1, 0.1)
Beta1 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu1 &lt;- RH(X3, RH(X2, RH(X1, Beta1)))
Y1 &lt;- array(rnorm(n1 * n2 * n3), dim = c(n1, n2, n3)) + mu1
Beta2 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu2 &lt;- RH(X3, RH(X2, RH(X1, Beta2)))
Y2 &lt;- array(rnorm(n1 * n2 * n3), dim = c(n1, n2, n3)) + mu2
Beta3 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu3 &lt;- RH(X3, RH(X2, RH(X1, Beta3)))
Y3 &lt;- array(rnorm(n1 * n2 * n3), dim = c(n1, n2, n3)) + mu3
Beta4 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu4 &lt;- RH(X3, RH(X2, RH(X1, Beta4)))
Y4 &lt;- array(rnorm(n1 * n2 * n3), dim = c(n1, n2, n3)) + mu4
Beta5 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu5 &lt;- RH(X3, RH(X2, RH(X1, Beta5)))
Y5 &lt;- array(rnorm(n1 * n2 * n3), dim = c(n1, n2, n3)) + mu5

Y &lt;- array(NA, c(dim(Y1), 5))
Y[,,, 1] &lt;- Y1; Y[,,, 2] &lt;- Y2; Y[,,, 3] &lt;- Y3; Y[,,, 4] &lt;- Y4; Y[,,, 5] &lt;- Y5;

fit &lt;- softmaximin(X, Y, zeta = 10, penalty = "lasso", alg = "npg")
Betafit &lt;- fit$coef

modelno &lt;- 15
m &lt;- min(Betafit[ , modelno], c(component))
M &lt;- max(Betafit[ , modelno], c(component))
plot(c(component), type="l", ylim = c(m, M))
lines(Betafit[ , modelno], col = "red")

</code></pre>


</div>