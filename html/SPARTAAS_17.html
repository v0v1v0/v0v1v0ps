<div class="container">

<table style="width: 100%;"><tr>
<td>hclustcompro_select_alpha</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate the optimal value(s) of the <code class="reqn">\alpha</code> parameter.</h2>

<h3>Description</h3>

<p>The following criterion "balances" the weight of <code class="reqn">D_1</code> and <code class="reqn">D_2</code> in the final clustering. The <code class="reqn">\alpha</code> value is only a point estimate but the confidence interval gives a range of possible values.
<br><br>
Based on a resampling process, we generate clones and recalculate the criteria according to <code class="reqn">\alpha</code> (see below).</p>


<h3>Usage</h3>

<pre><code class="language-R">hclustcompro_select_alpha(
    D1,
    D2,
    acc=2,
    resampling=TRUE,
    method="ward.D2",
    iter=5,
    suppl_plot=TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D1</code></td>
<td>

<p>First dissimilarity matrix or contingency table (square matrix).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D2</code></td>
<td>

<p>Second dissimilarity matrix or network data (square matrix) of the same size as D1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc</code></td>
<td>

<p>Number of digits after the decimal point for the alpha value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>

<p>Logical for estimating the confidence interval with a resampling strategy. If you have a lot of data, you can save computation time by setting this option to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The agglomeration method to be used. This should be (an unambiguous abbreviation of) one of "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>

<p>The number of clones checked per observation. (200 observations iter=1: ~30 sec, 1000 observations iter=1: ~40 min).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppl_plot</code></td>
<td>

<p>Logical defines whether additional plots should be displayed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Definition of the criterion:</strong><br><br></p>
<p>A criterion for choosing <code class="reqn">\alpha \in [0;1]</code> must be determined by balancing the weights between the two sources of information in the final classification. To obtain <code class="reqn">\alpha</code>, we define the following criterion
</p>
<p style="text-align: center;"><code class="reqn">CorCrit_\alpha = |Cor(dist_{cophenetic},D_1) - Cor(dist_{cophenetic},D_2)|</code>
</p>
  <p style="text-align: center;"><code class="reqn">Equation (1)</code>
</p>

<p>The <code class="reqn">CorCrit_\alpha</code> criterion in (1) represents the difference in absolute value between two cophenetic correlations (cophenetic correlation is defined as the correlation between two distance matrices. It is calculated by considering the half distance matrices as vectors. It measures how faithfully a dendrogram preserves the pairwise distances between the original unmodeled data points). The first correlation is related to the comparison between <code class="reqn">D_1</code> and the ultrametric distances of the clustering with <code class="reqn">\alpha</code> fixed, while the second compares <code class="reqn">D_2</code> and the ultrametric distances of the clustering with <code class="reqn">\alpha</code> fixed. Then, in order to compromise between the information provided by <code class="reqn">D_1</code> and <code class="reqn">D_2</code>, we decided to estimate <code class="reqn">\alpha</code> with <code class="reqn">\hat{\alpha}</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha} = min CorCrit_\alpha</code>
</p>

<p style="text-align: center;"><code class="reqn">Equation (2)</code>
</p>

<p><strong>Resampling strategy:</strong><br><br></p>
<p>This is done by creating a set of "clones" for each observation <code class="reqn">i</code>. A clone <code class="reqn">c</code> of observation <code class="reqn">i</code> is a copy of observation <code class="reqn">i</code> for which the distances from the second source have been modified. The modification is made by copying the distances for the second source from another observation <code class="reqn">j</code>. A clustering is then performed using the combination defined in (1) with <code class="reqn">D_1^{(c)}</code> an <code class="reqn">(n+1)\times(n+1)</code> matrix where observations <code class="reqn">i</code> and <code class="reqn">c</code> are identical and <code class="reqn">D_2^{(c)}</code> an <code class="reqn">(n+1)\times(n+1)</code> matrix where the clone <code class="reqn">c</code> of <code class="reqn">i</code> has different distances from those of <code class="reqn">i</code>. A set of clones is generated by varying <code class="reqn">j</code> for all observations except <code class="reqn">i</code>. We can generate a set of <code class="reqn">n-1</code> clones for each element <code class="reqn">i</code> in <code class="reqn">n</code>, so <code class="reqn">n(n-1)</code> clones in total.
</p>
<p>Intuitively, by varying <code class="reqn">\alpha</code> between 0 and 1, we will be able to identify when the clone and the original observation are separated on the dendrogram. This moment will correspond to the value of alpha above which the weight given to the information about the connection between observations contained in <code class="reqn">D_2</code> has too much influence on the results compared to that of <code class="reqn">D_1</code>.
</p>
<p>Let <code class="reqn">CorCrit_\alpha^{(c)}</code> define the same criterion as in (1), where <code class="reqn">D_1</code> and <code class="reqn">D_2</code> are replaced by <code class="reqn">D_1^{(c)}</code> and <code class="reqn">D_2^{(c)}</code> respectively.
The estimated <code class="reqn">\alpha</code> is the mean of the estimated values for each clone.<br>
For each clone <code class="reqn">c</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}^{(c)} = min   CorCrit_\alpha^{(c)}</code>
</p>

<p style="text-align: center;"><code class="reqn">Equation (3)</code>
</p>

<p><code class="reqn">\hat{\alpha}^*</code> is the mean of <code class="reqn">\hat{\alpha}^{(c)}</code>. In the same spirit as confidence intervals based on bootstrap percentiles (Efron &amp; Tibshirani, 1993), a percentile confidence interval based on replication is also be obtained using the empirical percentiles of the distribution of <code class="reqn">\hat{\alpha}^{(c)}</code>.
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}^* = \frac{1}{n(n-1)} \sum{ \hat\alpha^{(c)} }</code>
</p>

<p style="text-align: center;"><code class="reqn">Equation (4)</code>
</p>

<p style="text-align: center;"><code class="reqn">c  \in [1; n(n-1)]</code>
</p>

<p><strong>Warnings:</strong><br><br>
It is possible to observe an <code class="reqn">\alpha</code> value outside the confidence interval. In some cases, this problem can be solved by increasing the number of iterations or by changing the number of axes used to construct the matrix D1 after the correspondence analysis. If the <code class="reqn">\alpha</code> value remains outside the interval, it means that the data are noisy and the resampling procedure is affected.
</p>


<h3>Value</h3>

<p>The function returns a list (class: selectAlpha_obj).
</p>
<table>
<tr style="vertical-align: top;">
<td><code>alpha </code></td>
<td>
<p>The estimated value of the alpha parameter (min CorCrit_alpha)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.plot </code></td>
<td>
<p>The CorCrit curve for alpha between 0 and 1</p>
</td>
</tr>
</table>
<p>If resampling = TRUE
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sd </code></td>
<td>
<p>The standard deviation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf </code></td>
<td>
<p>The confidence interval of alpha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxplot </code></td>
<td>
<p>The boxplot of alpha estimation with resampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values </code></td>
<td>
<p>All potential alpha values obtained from each clone</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>A. COULON
</p>
<p>L. BELLANGER
</p>
<p>P. HUSI
</p>


<h3>Examples</h3>

<pre><code class="language-R">#################################

##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
library(SPARTAAS)
data(datangkor)

#network stratigraphic data (Network)
network &lt;- datangkor$stratigraphy

#contingency table
cont &lt;- datangkor$contingency

dissimilarity &lt;- CAdist(cont,nPC="max",graph=FALSE)
constraint &lt;- adjacency(network)

hclustcompro_select_alpha(D1 = dissimilarity, D2 = constraint)
hclustcompro_select_alpha(D1 = dissimilarity, D2 = constraint, acc = 3, resampling = TRUE)

</code></pre>


</div>