<div class="container">

<table style="width: 100%;"><tr>
<td>PBA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Probabilistic Bisection Algorithm</h2>

<h3>Description</h3>

<p>The function <code>PBA</code> searches a specified <code>interval</code> for a root
(i.e., zero) of the function <code>f(x)</code> with respect to its first argument.
However, this function differs from deterministic cousins such as
<code>uniroot</code> in that <code>f</code> may contain stochastic error
components, and instead provides a Bayesian interval where the root
is likely to lie. Note that it is assumed that <code>E[f(x)]</code> is non-decreasing
in <code>x</code> and that the root is between the search interval (evaluated
approximately when <code>check.interval=TRUE</code>).
See Waeber, Frazier, and Henderson (2013) for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PBA(
  f,
  interval,
  ...,
  p = 0.6,
  integer = FALSE,
  tol = if (integer) 0.01 else 1e-04,
  maxiter = 300L,
  miniter = 100L,
  wait.time = NULL,
  f.prior = NULL,
  resolution = 10000L,
  check.interval = TRUE,
  check.interval.only = FALSE,
  verbose = TRUE
)

## S3 method for class 'PBA'
print(x, ...)

## S3 method for class 'PBA'
plot(x, type = "posterior", main = "Probabilistic Bisection Posterior", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>noisy function for which the root is sought</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>a vector containing the end-points of the interval
to be searched for the root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named arguments to be passed to <code>f</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>assumed constant for probability of correct responses (must be &gt; 0.5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integer</code></td>
<td>
<p>logical; should the values of the root be considered integer
or numeric? The former uses a discreet grid to track the updates, while the
latter currently creates a grid with <code>resolution</code> points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance criteria for convergence based on average of the
<code>f(x)</code> evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations (default 300)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miniter</code></td>
<td>
<p>minimum number of iterations (default 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wait.time</code></td>
<td>
<p>(optional) instead of terminating after specific estimate criteria
are satisfied (e.g., <code>tol</code>), terminate after a specific
wait time. Input is specified either as a numeric vector in seconds or as a character
vector to be formatted by <code>timeFormater</code>.
Note that users should increase the number of <code>maxiter</code> as well
so that termination can occur if either the maximum iterations are satisfied
or the specified wait time has elapsed (whichever occurs first)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.prior</code></td>
<td>
<p>density function indicating the likely location of the prior
(e.g., if root is within [0,1] then <code>dunif</code> works, otherwise custom
functions will be required)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>constant indicating the
number of equally spaced grid points to track when <code>integer = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.interval</code></td>
<td>
<p>logical; should an initial check be made to determine
whether <code>f(interval[1L])</code> and <code>f(interval[2L])</code> have opposite
signs? Default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.interval.only</code></td>
<td>
<p>logical; return only TRUE or FALSE to test
whether there is a likely root given <code>interval</code>? Setting this to TRUE
can be useful when you are unsure about the root location interval and
may want to use a higher <code>replication</code> input from <code>SimSolve</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; should the iterations and estimate be printed to the
console?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>PBA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of plot to draw for PBA object. Can be either 'posterior' or
'history' to plot the PBA posterior distribution or the mediation iteration
history</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>plot title</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Horstein, M. (1963). Sequential transmission using noiseless feedback.
IEEE Trans. Inform. Theory, 9(3):136-143.
</p>
<p>Waeber, R., Frazier, P. I. &amp; Henderson, S. G. (2013). Bisection Search
with Noisy Responses. SIAM Journal on Control and Optimization,
Society for Industrial &amp; Applied Mathematics (SIAM), 51, 2261-2279.
</p>


<h3>See Also</h3>

<p><code>uniroot</code>, <code>RobbinsMonro</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# find x that solves f(x) - b = 0 for the following
f.root &lt;- function(x, b = .6) 1 / (1 + exp(-x)) - b
f.root(.3)

xs &lt;- seq(-3,3, length.out=1000)
plot(xs, f.root(xs), type = 'l', ylab = "f(x)", xlab='x', las=1)
abline(h=0, col='red')

retuni &lt;- uniroot(f.root, c(0,1))
retuni
abline(v=retuni$root, col='blue', lty=2)

# PBA without noisy root
retpba &lt;- PBA(f.root, c(0,1))
retpba
retpba$root
plot(retpba)
plot(retpba, type = 'history')

# Same problem, however root function is now noisy. Hence, need to solve
#  fhat(x) - b + e = 0, where E(e) = 0
f.root_noisy &lt;- function(x) 1 / (1 + exp(-x)) - .6 + rnorm(1, sd=.02)
sapply(rep(.3, 10), f.root_noisy)

# uniroot "converges" unreliably
set.seed(123)
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root
uniroot(f.root_noisy, c(0,1))$root

# probabilistic bisection provides better convergence
retpba.noise &lt;- PBA(f.root_noisy, c(0,1))
retpba.noise
plot(retpba.noise)
plot(retpba.noise, type = 'history')

## Not run: 
# ignore termination criteria and instead run for 30 seconds or 30000 iterations
retpba.noise_30sec &lt;- PBA(f.root_noisy, c(0,1), wait.time = "0:30", maxiter=30000)
retpba.noise_30sec


## End(Not run)

</code></pre>


</div>