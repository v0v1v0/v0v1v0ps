<div class="container">

<table style="width: 100%;"><tr>
<td>A3_calcGef</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Irradiation and irradiance on the generator plane.</h2>

<h3>Description</h3>

<p>This function obtains the global, diffuse and direct irradiation and
irradiance on the generator plane from the values of <em>daily</em> or <em>intradaily</em> global
irradiation on the horizontal plane. It makes use of the functions
<code>calcG0</code>, <code>fTheta</code>,
<code>fInclin</code>. Besides, it can calculate the shadows effect with
the <code>calcShd</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calcGef(lat,
        modeTrk = 'fixed',
        modeRad = 'prom',
        dataRad,
        sample = 'hour',
        keep.night = TRUE,
        sunGeometry = 'michalsky',
        corr, f,
        betaLim = 90, beta = abs(lat)-10, alfa = 0,
        iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE,
        modeShd = '',
        struct = list(),
        distances = data.frame(),
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeTrk</code></td>
<td>
<p>character, to be chosen from <code>'fixed'</code>, <code>'two'</code> or <code>'horiz'</code>. When <code>modeTrk = 'fixed'</code> the surface is fixed (inclination and azimuth angles are constant). The performance of a two-axis tracker is calculated with <code>modeTrk = 'two'</code>, and <code>modeTrk = 'horiz'</code> is the option for an horizontal N-S tracker. Its default value is <code>modeTrk = 'fixed'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeRad, dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code>calcG0</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample, keep.night</code></td>
<td>
<p>See <code>calcSol</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code>calcSol</code>, <code>fSolD</code> and <code>fSolI</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr, f</code></td>
<td>
<p>See <code>calcG0</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>numeric, inclination angle of the surface
(degrees). It is only needed when <code>modeTrk = 'fixed'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betaLim</code></td>
<td>
<p>numeric, maximum value of the inclination angle
for a tracking surface. Its default value is 90 (no
limitation))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alfa</code></td>
<td>
<p>numeric, azimuth angle of the surface (degrees). It is
measured from the south (<code>alfa = 0</code>), and it is negative to the
east and positive to the west. It is only needed when
<code>modeTrk = 'fixed'</code>. Its default value is <code>alfa = 0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iS</code></td>
<td>
<p>integer, degree of dirtiness. Its value must be included in
the set (1,2,3,4). <code>iS = 1</code> corresponds to a clean surface while
<code>iS = 4</code> is the selection for a dirty surface. Its default value is
2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alb</code></td>
<td>
<p>numeric, albedo reflection coefficient. Its default value is 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeShd, struct, distances</code></td>
<td>
<p>See <code>calcShd</code> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>horizBright</code></td>
<td>
<p>logical, if TRUE, the horizon brightness correction proposed by Reind et al. is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HCPV</code></td>
<td>
<p>logical, if TRUE the diffuse and albedo components of the
<em>effective</em> irradiance are set to zero. HCPV is the acronym of
High Concentration PV system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for <code>calcSol</code> and
<code>calcG0</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>Gef</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro.</p>


<h3>References</h3>


<ul>
<li>
<p> Hay, J. E. and McKay, D. C.: Estimating Solar Irradiance on Inclined Surfaces: A Review and Assessment of Methodologies. Int. J. Solar Energy, (3):pp. 203, 1985.
</p>
</li>
<li>
<p> Martin, N. and Ruiz, J.M.: Calculation of the PV modules angular losses under field conditions by means of an analytical model. Solar Energy Materials &amp; Solar Cells, 70:25–38, 2001.
</p>
</li>
<li>
<p> D. T. Reindl and W. A. Beckman and J. A. Duffie: Evaluation of
hourly tilted surface radiation models, Solar Energy, 45:9-17,
1990.
</p>
</li>
<li>
<p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li>
<p> Perpiñán, O. (2012), "solaR: Solar Radiation and Photovoltaic
Systems with R", Journal of Statistical Software, 50(9), 1-32,
doi: <a href="https://doi.org/10.18637/jss.v050.i09">10.18637/jss.v050.i09</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>calcG0</code>,
<code>fTheta</code>,
<code>fInclin</code>,
<code>calcShd</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">lat &lt;- 37.2

###12 Average days.

G0dm = c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919, 7.027, 5.369,
         3.562, 2.814, 2.179)*1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2, 17.2,
       15.2)

##Fixed surface, default values of inclination and azimuth.

gef &lt;- calcGef(lat = lat, modeRad = 'prom', dataRad = list(G0dm = G0dm, Ta = Ta))
print(gef)
xyplot(gef)

##Two-axis surface, no limitation angle.

gef2 &lt;- calcGef(lat = lat, modeRad = 'prom',
                dataRad = list(G0dm = G0dm, Ta = Ta),
                modeTrk = 'two')
print(gef2)
xyplot(gef2)

struct = list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)
distances = data.frame(Lew = 40, Lns = 30, H = 0)

gefShd &lt;- calcGef(lat = lat, modeRad = 'prom',
                  dataRad = list(G0dm = G0dm, Ta = Ta),
                  modeTrk = 'two',
                  modeShd = c('area', 'prom'), 
                  struct = struct, distances = distances)
print(gefShd)

## Not run: 
##Fixed surface using Aguiar method
gefAguiar &lt;- calcGef(lat = lat, modeRad = 'aguiar', dataRad = G0dm)

##Two-axis tracker, using the previous result.
##'gefAguiar' is internally coerced to a 'G0' object.

gefAguiar2 &lt;- calcGef(lat = lat, modeRad = 'prev', dataRad = gefAguiar, modeTrk = 'two')
print(gefAguiar2)
xyplot(gefAguiar2)

###Shadows between two-axis trackers, again using the gefAguiar result.

struct = list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)
distances = data.frame(Lew = 40, Lns = 30, H = 0)

gefShdAguiar &lt;- calcGef(lat = lat, modeRad = 'prev', 
                        dataRad = gefAguiar, modeTrk = 'two', 
                        modeShd = c('area', 'prom'), 
                        struct = struct, distances = distances)
print(gefShdAguiar)

## End(Not run)
</code></pre>


</div>