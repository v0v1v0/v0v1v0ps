<div class="container">

<table style="width: 100%;"><tr>
<td>dofuture</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Interface for parallel computations
</h2>

<h3>Description</h3>

<p>interface to apply some function <code>fn</code> in parallel on columns of a matrix. It is not logically restricted to mixed-effect applications, hence it can be used more widely. Depending on the <code>nb_cores</code> argument, parallel or serial computation is performed, calling the <code>future.apply::future_apply</code> function. A socket cluster is used by default for parallel computations, but a fork cluster can be requested on linux and alike operating systems by using argument <code>cluster_args=list(type="FORK")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dofuture(newresp, fn, nb_cores=NULL, fit_env, control=list(), 
      cluster_args=NULL, debug.=FALSE, iseed=NULL, 
      showpbar="ignored", pretest_cores="ignored",
      ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>newresp</code></td>
<td>

<p>A matrix on whose columns <code>fn</code> will be applied (e.g., as used internally in <span class="pkg">spaMM</span>, the return value of a <code>simulate.HLfit()</code> call); or an integer, then converted to a trivial matrix <code>matrix(seq(newresp),ncol=newresp,nrow=1)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>

<p>Function whose first argument is named <code>y</code>. The function will be applied for <code>y</code> taken to be each column of <code>newresp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb_cores</code></td>
<td>

<p>Integer. Number of cores to use for parallel computations. If &gt;1, a cluster of <code>nb_cores</code> nodes is used. Otherwise, no parallel computation is performed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit_env</code></td>
<td>

<p>(for socket clusters only:)  An environment, or a list, containing variables to be exported on the nodes of the cluster (by <code>parallel::clusterExport</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>A list. The only effective control is <code>.combine="rbind"</code> (mimicking the <code>foreach</code> syntax used in the alternative interface <code>dopar</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_args</code></td>
<td>

<p>A list of arguments passed to <code>parallel::makeCluster</code> or <code>parallel::makeForkCluster</code>. E.g., <code>outfile="log.txt"</code> may be useful to collect output from the nodes, and <code>type="FORK"</code> to force a fork cluster on linux(-alikes).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug.</code></td>
<td>

<p>(for socket clusters only:)   For debugging purposes. Effect, if any, is to be defined by the <code>fn</code> as provided by the user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>

<p>Integer, or NULL. If an integer, it is used to initialize <code>"L'Ecuyer-CMRG"</code> random-number generator (<code>iseed</code> argument of <code>clusterSetRNGStream</code>), with identical effect across different models of parallelisation. If <code>iseed</code> is <code>NULL</code>, the seed is not controlled. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showpbar,pretest_cores</code></td>
<td>

<p>Currently ignored; for consistency with <code>dopar</code> formal arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed (unevaluated) to <code>future.apply</code> (and then possibly to <code>fn</code>).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The result of calling <code>future.apply</code>.  If the <code>progressr</code> package is loaded, a side-effect of <code>dofuture</code> is to show a progress bar with character 'S' or 'P' or 'F' depending on parallelisation status (serial/socket/fork).
</p>


<h3>See Also</h3>

<p><code>dopar</code> for an alternative implementation of (essentially) the same functionalities, and <code>wrap_parallel</code> for its differences from <code>dofuture</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
if (requireNamespace("future.apply", quietly = TRUE)) {

 # Useless function, but requiring some argument beyond the first
 foo &lt;- function(y, somearg, ...) {
   if ( is.null(somearg) || TRUE ) length(y)
 }

 # Whether FORK can be used depends on OS and whether Rstudio is used:
   dofuture(matrix(1,ncol=4,nrow=3), foo, fit_env=list(), somearg=NULL, 
     nb_cores=2, cluster_args=list(type="FORK"))
}

## End(Not run)
</code></pre>


</div>