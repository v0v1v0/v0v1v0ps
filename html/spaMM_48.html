<div class="container">

<table style="width: 100%;"><tr>
<td>ARp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Random effect with AR(p) (autoregressive of order p) or ARMA(p,q) structure.
</h2>

<h3>Description</h3>

<p>These times-series correlation models can be declared as correlation models for random effect. 
The AR(p) model is here parametrized by the <b>partial</b> correlation coefficients of the levels of the random effect, {U_t}, corr(U_s,U_t|U_(s+1),...,U_(t-1)), with valid values in the hypercube ]-1,,1[^p (Barndorff-Nielsen and Schou, 1973). 
In the autoregressive-moving average ARMA(p,q) model, the AR part is parametrized in the same way. AR parameters are named <code>"p1"</code>, <code>"p2"</code>..., and MA parameters are named <code>"q1"</code>, <code>"q2"</code>... .
</p>
<p>Implementation of the AR(p) model uses the sparsity of the inverse covariance matrix. In the ARMA(p,q) model, neither the covariance nor its inverse are sparse, so fits are expected to be more time- and memory-consuming. 
</p>


<h3>Usage</h3>

<pre><code class="language-R"># corrFamily constructors:
ARp(p=1L, fixed=NULL, corr=TRUE, tpar=1/(1+seq(p)))
ARMA(p=1L, q=1L, fixed=NULL, tpar=c(1/(1+seq_len(p)),1/(1+seq_len(q))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Integer: order of the autoregressive process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Integer: order of the moving-average process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tpar</code></td>
<td>

<p>Numeric vector: template values of the <b>partial coefficient coefficients</b> of the autoregressive process, and the traditional coefficients of the moving-average processe, in this order. The <code>tpar</code> vector must always have full length, even when some parameters are fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>NULL or numeric vector, to fix the parameters of this model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr</code></td>
<td>
<p>For development purposes, better ignored in normal use.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The <code>ARp</code> and <code>ARMA</code> functions return a <code>corrFamily</code> descriptor, hence a <code>list</code> including element <code>Cf</code>, a function returning, for given ARMA or AR parameters, the correlation matrix for <code>ARMA</code>, or its <b>inverse</b> for <code>ARp</code>.
</p>
<p>The fitted correlation matrix can be extracted from a fit object, as for any autocorrelated random effect, by <code>Corr(</code>&lt;fit object&gt;<code>)[[</code>&lt;random-effect index&gt;<code>]]</code>. 
</p>


<h3>References</h3>

<p>Barndorff-Nielsen 0. and Schou G., 1973 On the parametrization of autoregressive models by partial autocorrelations. J. Multivariate Analysis 3: 408-419. <a href="https://doi.org/10.1016/0047-259X%2873%2990030-4">doi:10.1016/0047-259X(73)90030-4</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (spaMM.getOption("example_maxtime")&gt;2) {
ts &lt;- data.frame(lh=lh,time=seq(48)) ## using 'lh' data from 'stats' package

## Default 'tpar' =&gt; AR1 model 
#
(ARpfit &lt;-  fitme(lh ~ 1 + ARp(1|time), data=ts, method="REML"))
#
## which is equivalent to
#
(AR1fit &lt;- fitme(lh ~ 1 +AR1(1|time), data=ts, method="REML"))

## AR(3) model 
#
(AR3fit &lt;- fitme(lh ~ 1 + ARp(1|time, p=3), data=ts, method="REML"))

## Same but with fixed 2-lag partial autocorrelation 
#
(AR3fix &lt;- fitme(lh ~ 1 + ARp(1|time, p=3, fixed=c(p2=0)), data=ts, method="REML"))
#      
# The fit should be statistically equivalent to
#
(AR3_fix &lt;- fitme(lh ~ 1 + ARp(1|time, p=3), data=ts, method="REML",
                 fixed=list(corrPars=list("1"=c(p2=0)))))
#                 
# with subtle differences in the structure of the fit objects:
#
get_ranPars(AR3fix)$corrPars     # p2 was not a parameter of the model
get_ranPars(AR3_fix)$corrPars    # p2 was a fixed parameter of the model
#
# get_fittefPars() expectedly ignores 'p2' whichever way it was fixed.    


## Same as 'AR3fix' but with an additional MA(1) component
#
(ARMAfit &lt;- fitme(lh ~ 1 + ARMA(1|time, p=3, q=1, fixed=c(p2=0)), 
                  data=ts, method="REML"))
}


</code></pre>


</div>