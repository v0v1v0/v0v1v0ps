<div class="container">

<table style="width: 100%;"><tr>
<td>hotspot_gistar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify significant spatial clusters of points</h2>

<h3>Description</h3>

<p>Identify hotspot and coldspot locations, that is cells in a regular grid in
which there are more/fewer points than would be expected if the points were
distributed randomly.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hotspot_gistar(
  data,
  cell_size = NULL,
  grid_type = "rect",
  kde = TRUE,
  bandwidth = NULL,
  bandwidth_adjust = 1,
  grid = NULL,
  weights = NULL,
  nb_dist = NULL,
  include_self = TRUE,
  p_adjust_method = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>sf</code> data frame containing points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kde</code></td>
<td>
<p><code>TRUE</code> (the default) or <code>FALSE</code> indicating whether
kernel density estimates (KDE) should be produced for each grid cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p><code>numeric</code> value specifying the bandwidth to be used in
calculating the kernel density estimates. If this argument is <code>NULL</code>
(the default), the bandwidth will be specified automatically using the mean
result of <code>bandwidth.nrd</code> called on the <code>x</code> and
<code>y</code> co-ordinates separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth_adjust</code></td>
<td>
<p>single positive <code>numeric</code> value by which the
value of <code>bandwidth</code> is multiplied. Useful for setting the bandwidth
relative to the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p><code>sf</code> data frame containing polygons, which will
be used as the grid for which counts are made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p><code>NULL</code> or the name of a column in <code>data</code> to be used
as weights for weighted counts and KDE values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb_dist</code></td>
<td>
<p>The distance around a cell that contains the neighbours of
that cell, which are used in calculating the statistic. If this argument is
<code>NULL</code> (the default), <code>nb_dist</code> is set as <code>cell_size *
  sqrt(2)</code> so that only the cells immediately adjacent to each cell are
treated as being its neighbours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_self</code></td>
<td>
<p>Should points in a given cell be counted as well as
counts in neighbouring cells when calculating the values of
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = TRUE</code>, the default) or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = FALSE</code>) values? You are unlikely to want to change
the default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_adjust_method</code></td>
<td>
<p>The method to be used to adjust <em>p</em>-values for
multiple comparisons. <code>NULL</code> (the default) uses the default method
used by <code>p.adjust</code>, but any of the character values in
<code>stats::p.adjust.methods</code> may be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>kde</code> or
ignored if <code>kde = FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calculates the Getis-Ord
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(gi-star) or
<i>G</i><sub><i>i</i></sub><sup>*</sup><code class="reqn">Z</code>-score statistic for identifying clusters of point locations. The
underlying implementation uses the <code>localG</code> function to
calculate the <code class="reqn">Z</code> scores and then <code>p.adjustSP</code>
function to adjust the corresponding <code class="reqn">p</code>-values for multiple comparison.
The function also returns counts of points in each cell and (by default but
optionally) kernel density estimates using the <code>kde</code>
function.
</p>


<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values for cells that are outside the area for which data were provided,
which could be misleading. To handle this, consider cropping the output layer
to the area for which data are available. For example, if you only have crime
data for a particular district, crop the output dataset to the district
boundary using <code>st_intersection</code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>Value</h3>

<p>An <code>sf</code> tibble of regular grid cells with
corresponding point counts,
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values and (optionally) kernel density estimates for each cell. Values
greater than zero indicate more points than would be expected for randomly
distributed points and values less than zero indicate fewer points.
Critical values of
<i>G</i><sub><i>i</i></sub><sup>*</sup> and
<i>G</i><sub><i>i</i></sub><sup>*</sup>
are given in the manual page for <code>localG</code>.
</p>
<p>The output from this function can be plotted in the same way as for other
SF objects, for which see <code>vignette("sf5", package = "sf")</code>.
</p>


<h3>References</h3>

<p>Getis, A. &amp; Ord, J. K. (1992). The Analysis of Spatial Association by Use of
Distance Statistics. <em>Geographical Analysis</em>, 24(3), 189-206.
doi:<a href="https://doi.org/10.1111/j.1538-4632.1992.tb00261.x">doi:10.1111/j.1538-4632.1992.tb00261.x</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf)

# Transform data to UTM zone 15N so that cell_size and bandwidth can be set
# in metres
memphis_robberies_utm &lt;- st_transform(memphis_robberies_jan, 32615)

# Automatically set grid-cell size, bandwidth and neighbour distance

hotspot_gistar(memphis_robberies_utm)


# Manually set grid-cell size in metres, since the `memphis_robberies`
# dataset uses a co-ordinate reference system (UTM zone 15 north) that is
# specified in metres

hotspot_gistar(memphis_robberies_utm, cell_size = 200)


# Automatically set grid-cell size and bandwidth for lon/lat data, since it
# is not intuitive to set these values manually in decimal degrees. To do
# this it is necessary to not calculate KDEs due to a limitation in the
# underlying function.

hotspot_gistar(memphis_robberies, kde = FALSE)


</code></pre>


</div>