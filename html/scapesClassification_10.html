<div class="container">

<table style="width: 100%;"><tr>
<td>conditions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>scapesClassification conditions</h2>

<h3>Description</h3>

<p>Check for spelling and syntax errors in conditions (<code>cond</code> argument) and
detect the type of conditions being used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">conditions(names_attTbl, cond, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>names_attTbl</code></td>
<td>
<p>character vector, the column (i.e. variable) names of the
attribute table returned by the function <code>attTbl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>
<p>character string, the condition string used by the <code>cond.*</code>
functions to classify raster cells (see <code>conditions</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logic, when true, the function returns only error messages.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Conditions (alias classification rules)</strong>
</p>

<ul>
<li>
<p> Classification rules evaluate either to true or false and determine what
raster cells have to be classified.
</p>
</li>
<li>
<p> Conditions are passed to <code>scapesClassification</code> functions as a
single character string. They can consist of combination of variables names
(as named in the attribute table, see <code>attTbl</code>), arithmetic
<code>(+|-|*|/|^|%%|%/%)</code>, relational <code>(&gt;|&lt;|&gt;=|&lt;=|==|!=|%/%)</code> and
logic operators <code>(&amp;||)</code> and base R functions (e.g.,
<code>abs(variable_name)</code>).
</p>
</li>
<li>
<p> All variables included in an attribute table (see <code>attTbl</code>)
can be included in a condition string by name (e.g., var name =
<code>"dummy_var"</code>; condition = <code>"dummy_var &gt; 1"</code>).<br></p>
</li>
</ul>
<p><strong>Class vectors</strong>
</p>

<ul>
<li>
<p> Class vectors map raster cells to numeric classes.
</p>
</li>
<li>
<p> The n^th^ element of a class vector stores the class of the raster cell
stored in the n^th^ row of the corresponding attribute table (see
<code>attTbl</code>).
</p>
</li>
<li>
<p> Class vectors can serve also as a function input. As inputs, they provide
information about the groups of cells that have already been classified.
</p>
</li>
<li>
<p> Every time a class vector is provided as a function input, it is
<em>updated</em> by assigning a numeric class to <em>unclassified cells</em> that meet
function conditions.
</p>
</li>
<li>
<p> Unclassified cells are represented as NA values.<br></p>
</li>
</ul>
<p><strong>Rule evaluation: Global evaluation</strong>
</p>

<ul>
<li>
<p> Classification rules are applied to all unclassified raster
cells.
</p>
</li>
<li>
<p> Function using <em>global evaluation</em>: <code>cond.4.all</code>.
</p>
</li>
</ul>
<p><strong>Rule evaluation: Focal evaluation</strong>
</p>

<ul>
<li>
<p> Classification rules are applied only to raster cells at specific
locations and are based on class (dis)contiguity and class continuity.
</p>
</li>
<li> <p><strong>Class contiguity:</strong> <br> classification rules are applied only to raster
cells contiguous to focal cells (identified in the <code>cond.*</code> functions
by the argument <code>nbs_of</code>).
</p>
</li>
<li> <p><strong>Class continuity:</strong> <br> join into the same class cells that respect the
same rules and that are connected to the same focal cells. This means that,
at each iteration, newly classified cells become focal cells and conditions
are tested in their neighborhood.
</p>
</li>
<li>
<p> Function using <em>focal evaluation</em>: <code>anchor.seed</code>,
<code>cond.4.nofn</code>, <code>cond.reclass</code>,
<code>reclass.nbs</code> and <code>classify.all</code>.<br></p>
</li>
</ul>
<p><strong>Focal evaluation: Definitions</strong>
</p>

<ul>
<li> <p><strong>Cell neighborhood:</strong> a cell with coordinates <code>(x, y)</code> has 8
neighbors with coordinates: <code>(x±1, y)</code>,  <code>(x, y±1)</code> and
<code>(x±1, y±1)</code>. Cells on the edge of a raster have less than 8
neighbors. See <code>ngbList</code>.
</p>
</li>
<li> <p><strong>Focal cell:</strong> cells whose neighbors are evaluated against the
classification rule(s). In the classification functions <em>focal cells</em> are
identified by the argument <code>nbs_of</code>.
</p>
</li>
<li> <p><strong>Test cell:</strong> the cell in the neighborhood of the focal cell that is
being tested. At turns all cells in the neighborhood of a focal cell are
tested against the classification rule(s).
</p>
</li>
<li> <p><strong>Directional neighborhood:</strong> it consists of the intersection between the
focal and the test cell neighborhoods.<br></p>
</li>
</ul>
<p><strong>Condition type: Absolute conditions</strong>
</p>
<p><strong>1) Absolute test cell condition:</strong> compares cell values against a
threshold value.
</p>

<ul>
<li>
<p> This type of condition applies to all functions with a <code>conditions</code>
argument.
</p>
</li>
<li>
<p> In global evaluations all cells meeting absolute conditions receive a
classification number. In focal evaluations all <code>test cells</code> meeting
absolute conditions receive a classification number.
</p>
</li>
<li> <p><em>Examples of valid conditions:</em> <code>"variable_A &gt; 1 &amp; variable_B !=
  0"</code>; <code>"(variable_A^2 &lt; 50 &amp; variable_B == 0) | abs(variable_C) &gt; 50"</code>.<br><em>Functions:</em> <code>anchor.seed</code>, <code>cond.4.all</code>,
<code>cond.4.nofn</code> and <code>cond.reclass</code>.<br></p>
</li>
</ul>
<p><strong>2) Absolute neighborhood condition:</strong> compares the values of the
<code>test cell</code> and of its <code>neighborhood</code> against a threshold value.
</p>

<ul>
<li>
<p> An absolute neighborhood condition is identified by a variable name
followed by curly brackets (e.g., <code>"variable_name{}"</code>).
</p>
</li>
<li>
<p> A maximum of 9 evaluations are performed for each test cell (the test
cell itself and the cells of its neighborhood are compared against a
threshold value).
</p>
</li>
<li>
<p> Test cells receive a classification number if the rule is true for at
least as many evaluations as the ones specified by the argument
<code>peval</code>. The argument <code>peval</code> ranges from 0 to 1. When 9
evaluations are performed, <code>peval = 1</code> means that all <code>9</code>
evaluations have to be true; <code>peval = 0.5</code> means that at least
<code>4.5</code> (rounded to <code>5</code>) evaluations have to be true.
</p>
</li>
<li>
<p> Only one neighborhood rule is allowed for each condition string (e.g., it
is not possible to have a condition string like <code>"variable_A{} &gt; 0 &amp;
  variable_B{} &gt; 1"</code>).
</p>
</li>
<li>
<p> The function <code>cond.4.nofn</code> can consider a <code>directional
  neighborhood</code> instead of the test cell neighborhood by setting the argument
<code>directional = TRUE</code>.
</p>
</li>
<li> <p><em>Example of valid conditions:</em> <code>"variable_A{} &gt; 1 &amp; abs(variable_B)
  != 0"</code>. <br><em>Functions:</em> <code>cond.4.nofn</code> and
<code>cond.reclass</code>.<br></p>
</li>
</ul>
<p><strong>Condition type: Relative conditions</strong>
</p>
<p><strong>1) Relative focal cell condition:</strong> compares the <code>test cell</code> value
against the <code>focal cell</code> value.
</p>

<ul>
<li>
<p> A relative focal cell condition is identified by a variable name followed
by square brackets (e.g., <code>"variable_name[]"</code>).
</p>
</li>
<li>
<p> Rules are defined repeating twice the same variable name, once with
square brackets and once without. Square brackets indicate the focal cell
value. As an example, the rule <code>"dummy_var &lt; dummy_var[]"</code> compares
the value of the the test cell (<code>"dummy_var"</code>) against the value of
the focal cell (<code>"dummy_var[]"</code>).
</p>
</li>
<li>
<p> Test cells are classified if the rule is true.
</p>
</li>
<li> <p><em>Examples of valid conditions:</em> <code>"variable_A &gt; variable_A[]"</code>;
<code>"(variable_A &gt; variable_A[] &amp; variable_B{} &lt; 10) | variable_C &gt; 1"</code>.
Note that the last example is a combination of absolute and focal cell
conditions. <br><em>Functions:</em> <code>anchor.seed</code> and
<code>cond.4.nofn</code>.
</p>
</li>
</ul>
<p><strong>2) Relative neighborhood condition:</strong> compares the values of the <code>test
  cell</code> against the values of the <code>test cell neighborhood</code>.
</p>

<ul>
<li>
<p> A relative neighborhood condition is identified by a variable name
followed by curly brackets (e.g., <code>"variable_name{}"</code>).
</p>
</li>
<li>
<p> Rules are defined repeating twice the same variable name, once with curly
brackets and once without. Curly brackets indicate the test cell
neighborhood. As an example, the rule <code>'dummy_var &lt; dummy_var{}'</code>
compares the value of the the test cell (<code>dummy_var</code>) against the
values of cells included in the test cell neighborhood
(<code>dummy_var{}</code>).
</p>
</li>
<li>
<p> A maximum of 8 evaluations are performed for each test cell (the test
cell is compared against each cell included in its neighborhood).
</p>
</li>
<li>
<p> Test cells receive a classification number if the rule is true for at
least as many evaluations as the ones specified by the argument
<code>peval</code>. The argument <code>peval</code> ranges from 0 to 1. When 8
evaluations are performed, <code>peval = 1</code> means that all <code>8</code>
evaluations have to be true; <code>peval = 0.5</code> means that at least
<code>4</code> evaluations have to be true.
</p>
</li>
<li>
<p> Only one neighborhood rule is allowed for each condition string (e.g., it
is not possible to have a condition string like <code>"variable_A{} &gt; 0 &amp;
  variable_B{} &gt; variable_B"</code>).
</p>
</li>
<li>
<p> The function <code>cond.4.nofn</code> can consider a <code>directional
  neighborhood</code> instead of the test cell neighborhood by setting the argument
<code>directional = TRUE</code>.
</p>
</li>
<li> <p><em>Example of valid conditions:</em> <code>"variable_A &gt; variable_A{}"</code>;
<code>"(variable_A &gt; variable_A{} &amp; variable_B != variable_B[]) |
  variable_C &gt; 1"</code>. Note that the last example is a combination of absolute
and relative conditions. <br><em>Functions:</em> <code>cond.4.nofn</code> and
<code>cond.reclass</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>An error message if the function finds spelling or syntax errors or a
string with the types of rules detected in the condition string.
</p>


<h3>See Also</h3>

<p><code>cond.4.all()</code>, <code>cond.4.nofn()</code>, <code>anchor.seed()</code>, <code>cond.reclass()</code>,
<code>conditions()</code>
</p>
<p><code>anchor.seed()</code>, <code>attTbl()</code>, <code>cond.4.all()</code>, <code>cond.4.nofn()</code>,
<code>cond.reclass()</code>, <code>classify.all()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># LOAD LIBRARIES
library(scapesClassification)
library(terra)

################################################################################
# TYPES OF CONDITIONS
################################################################################

# As an example consider an attribute with the following columns
names_attTbl &lt;- c("bathymetry", "slope")

# And the following conditions
cond &lt;- "bathymetry&gt;10"
conditions(names_attTbl, cond)

cond &lt;- "bathymetry[]&gt;bathymetry | abs(slope{}) &lt; 5"
conditions(names_attTbl, cond)

cond &lt;- "bathymetry[]&gt;bathymetry | abs(slope{}) &lt; slope"
conditions(names_attTbl, cond)

################################################################################
# FOCAL EVALUATION DEFINITIONS
################################################################################

# CELL NUMBERS OF A DUMMY RASTER (7X7)
r   &lt;- terra::rast(matrix(1:49, nrow = 7, byrow = TRUE), extent=c(0,7,0,7))
nbs &lt;- ngbList(r)

# CLASS VECTOR WITH ONE TEST AND ONE FOCAL CELL
cv &lt;- as.numeric(rep(NA, 49))
cv[c(32, 25)] &lt;- c(1, 2) # tc (class 1), fc (class 2)
r_cv &lt;- cv.2.rast(r, classVector = cv)

# POLYGONS REPRESENTING NEIGHBORHOODS
fcn &lt;- rbind(c(2,5), c(5,5), c(5,2), c(2,2), c(2,5))
fcn &lt;- terra::vect(fcn, type="polygons")

tcn &lt;- rbind(c(2,4), c(5,4), c(5,1), c(2,1), c(2,4))
tcn &lt;- terra::vect(tcn, type="polygons")

# PLOT - FOCAL EVALUATION DEFINITIONS
m &lt;- c(3.5, 8, 1.2, 8)
plot(r_cv, type = "class", asp = NA, legend = FALSE, axes = FALSE, mar = m,
     col = c("goldenrod3","#1088a0"), colNA= "grey90")
text(r)
mtext(side=3, line=0, adj=0, cex=1, font=2, "FOCAL EVALUATION")
mtext(side=1, line=0, adj=0, cex=0.9,
      "Focal cell neighborhood: 17, 18, 19, 24, 26, 31, 32, 33")
mtext(side=1, line=1, cex=0.9, adj=0,
      "Test cell neighborhood: 24, 25, 26, 31, 33, 38, 39, 40")
mtext(side=1, line=2, cex=0.9, adj=0,
     "Directional neighborhood: 24, 25, 26, 31, 32, 33")
lines(fcn, col="#1088a0", lwd=2)
lines(tcn, col="#cfad8999", lwd=2)
legend("bottomleft", ncol = 1, bg = "white", y.intersp= 1.3,
       legend = c("Focal cell", "Test cell"), fill = c("#1088a0", "goldenrod3"))
</code></pre>


</div>