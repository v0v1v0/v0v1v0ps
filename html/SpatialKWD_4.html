<div class="container">

<table style="width: 100%;"><tr>
<td>CompareOneToOne-function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compare a pair of spatial histograms
</h2>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein between a pair of spatial histograms defined over the same grid map.
</p>
<p>The grid map is described by the two lists of <code>N</code> coordinates <code>Xs</code> and <code>Ys</code>, which specify the coordinates of the centroid of each tile of the map.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have the two lists of weights, one for the first histograms and the other for the second histogram.
</p>
<p>The two lists of coordinates are passed to <code>compareOneToOne</code> as a matrix with <code>N</code> rows and two columns.
The two lists of weights are passed as a matrix with <code>N</code> rows and two columns, a column for each histogram.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compareOneToOne(Coordinates, Weights, L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           unbalanced = FALSE, unbal_cost = 1e+09, convex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li>
<p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li>
<p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li>
<p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the first spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li>
<p><code>Weights[,2]</code>: <em>(Second Column)</em> Weights of the second spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unbalanced</code></td>
<td>
<p>If equal to <code>True</code>, solve the problem with unbalanced masses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unbal_cost</code></td>
<td>
<p>Cost for the arcs going from each point to the extra artificial bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>If equal to <code>True</code>, compute the convex hull of the input points.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>compareOneToOne(Coordinates, Weights, ...)</code> computes the distance between the two histograms specified by the weights given in the two columns of matrix <code>Weights</code>. 
The support points (i.e., centroids of each tile of the map) are defined by the coordinates given in <code>Xs</code> and <code>Ys</code> in the two columns of matrix <code>Coordinates</code>. 
The algorithm used to compute such distance depends on the parameters specified as optional arguments of the function.
</p>
<p>The most important is the parameter <code>L</code>, which by default is equal to 3. The following table shows the worst-case approximation ratio as a function of the value assigned to <code>L</code>.
The table also reports the number of arcs in the network flow model as a function of the number of bins <em>n</em> contained in the convex hull of the support points of the histograms given in input with matrix <code>Coordinates</code>.
</p>

<table>
<tr>
<td style="text-align: left;">
    <b>L</b> </td>
<td style="text-align: left;"> <b>1</b> </td>
<td style="text-align: left;"> <b>2</b> </td>
<td style="text-align: left;"> <b>3</b> </td>
<td style="text-align: left;"> <b>5</b> </td>
<td style="text-align: left;"> <b>10</b>
</td>
<td style="text-align: left;"> <b>15</b> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Worst-case error</code>  </td>
<td style="text-align: left;"> 7.61% </td>
<td style="text-align: left;">  2.68% </td>
<td style="text-align: left;">  1.29% </td>
<td style="text-align: left;"> 0.49%  </td>
<td style="text-align: left;"> 0.12%  </td>
<td style="text-align: left;">   0.06%  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Number of arcs</code> </td>
<td style="text-align: left;"> <em>O(8n)</em> </td>
<td style="text-align: left;"> <em>O(16n)</em> </td>
<td style="text-align: left;"> <em>O(32n)</em>  </td>
<td style="text-align: left;"> <em>O(80n)</em> </td>
<td style="text-align: left;"> <em>O(256n)</em> </td>
<td style="text-align: left;"> <em>O(576n)</em> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p>The following two figures show the network build on a grid with 8x8 nodes and using <em>L=2</em> and <em>L=3</em>.
</p>
<p><img src="../help/figures/figL2.png" width="35%" alt="L=2"></p>
<p><img src="../help/figures/figL3.png" width="35%" alt="L=3"></p>




<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li>
<p><code>distance</code>: The value of the KW-distance between the two input histograms.
</p>
</li>
<li>
<p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li>
<p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li>
<p><code>iterations</code>: Overall number of iterations of the Network Simplex algorithm.
</p>
</li>
<li>
<p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li>
<p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>See also <code>compareOneToMany</code>, <code>compareAll</code>, <code>focusArea</code>, <code>Histogram2D</code>, and <code>Solver</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
test1 &lt;- matrix(runif(2*N, 0, 1), ncol=2, nrow=N)

# Compute distance
print("Compare one-to-one with exact algorithm:")
d &lt;- compareOneToOne(coordinates, Weights=test1, method="exact",
                     recode=TRUE, verbosity = "info")
cat("runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")

print("Compare one-to-one with approximate algorithm:")
d &lt;- compareOneToOne(coordinates, Weights=test1, L=2, recode=TRUE)
cat("L: 2, runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")

d &lt;- compareOneToOne(coordinates, Weights=test1, L=3)
cat("L: 3 runtime:", d$runtime, " distance:", d$distance, "\n")

d &lt;- compareOneToOne(coordinates, Weights=test1, L=10)
cat("L: 10, runtime:", d$runtime, " distance:", d$distance, "\n")
</code></pre>


</div>