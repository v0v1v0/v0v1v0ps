<div class="container">

<table style="width: 100%;"><tr>
<td>unround</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reconstruct rounding bounds</h2>

<h3>Description</h3>

<p><code>unround()</code> takes a rounded number and returns the range of the
original value: lower and upper bounds for the hypothetical earlier number
that was later rounded to the input number. It also displays a range with
inequation signs, showing whether the bounds are inclusive or not.
</p>
<p>By default, the presumed rounding method is rounding up (or down) from 5.
See the <code>Rounding</code> section for other methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unround(x, rounding = "up_or_down", threshold = 5, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>String or numeric. Rounded number. <code>x</code> must be a string unless
<code>digits</code> is specified (most likely by a function that uses <code>unround()</code> as a
helper).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rounding</code></td>
<td>
<p>String. Rounding method presumably used to create <code>x</code>.
Default is <code>"up_or_down"</code>. For more, see section <code>Rounding</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Integer. Number from which to round up or down. Other
rounding methods are not affected. Default is <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Integer. This argument is meant to make <code>unround()</code> more
efficient to use as a helper function so that it doesn't need to
redundantly count decimal places. Don't specify it otherwise. Default is
<code>NULL</code>, in which case decimal places really are counted internally and <code>x</code>
must be a string.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function is vectorized over <code>x</code> and <code>rounding</code>. This can be
useful to unround multiple numbers at once, or to check how a single number
is unrounded with different assumed rounding methods.
</p>
<p>If both vectors have a length greater than 1, it must be the same
length. However, this will pair numbers with rounding methods, which can be
confusing. It is recommended that at least one of these input vectors has
length 1.
</p>
<p>Why does <code>x</code> need to be a string if <code>digits</code> is not specified? In that
case, <code>unround()</code> must count decimal places by itself. If <code>x</code> then was
numeric, it wouldn't have any trailing zeros because these get dropped from
numerics.
</p>
<p>Trailing zeros are as important for reconstructing boundary values as any
other trailing digits would be. Strings don't drop trailing zeros, so they
are used instead.
</p>


<h3>Value</h3>

<p>A tibble with seven columns: <code>range</code>, <code>rounding</code>, <code>lower</code>,
<code>incl_lower</code>, <code>x</code>, <code>incl_upper</code>, and <code>upper</code>. The <code>range</code> column is a handy
representation of the information stored in the columns from <code>lower</code> to
<code>upper</code>, in the same order.
</p>


<h3>Rounding</h3>

<p>Depending on how <code>x</code> was rounded, the boundary values can
be inclusive or exclusive. The <code>incl_lower</code> and <code>incl_upper</code> columns in the
resulting tibble are <code>TRUE</code> in the first case and <code>FALSE</code> in the second.
The <code>range</code> column reflects this with equation and inequation signs.
</p>
<p>However, these ranges are based on assumptions about the way <code>x</code> was
rounded. Set <code>rounding</code> to the rounding method that hypothetically lead to
<code>x</code>:</p>

<table>
<tr>
<td style="text-align: left;">
   <strong>Value of <code>rounding</code></strong> </td>
<td style="text-align: left;"> <strong>Corresponding range</strong> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"up_or_down"</code> (default) </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠lower &lt;= x &lt;= upper⁠</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"up"</code> </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠lower &lt;= x &lt; upper⁠</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"down"</code> </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠lower &lt; x &lt;= upper⁠</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"even"</code> </td>
<td style="text-align: left;"> (no fix range) </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"ceiling"</code> </td>
<td style="text-align: left;"> <code>lower &lt; x = upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"floor"</code> </td>
<td style="text-align: left;"> <code>lower = x &lt; upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"trunc"</code> (positive <code>x</code>) </td>
<td style="text-align: left;"> <code>lower = x &lt; upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"trunc"</code> (negative <code>x</code>) </td>
<td style="text-align: left;"> <code>lower &lt; x = upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"trunc"</code> (zero <code>x</code>) </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠lower &lt; x &lt; upper⁠</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"anti_trunc"</code> (positive <code>x</code>) </td>
<td style="text-align: left;"> <code>lower &lt; x = upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"anti_trunc"</code> (negative <code>x</code>) </td>
<td style="text-align: left;"> <code>lower = x &lt; upper</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"anti_trunc"</code> (zero <code>x</code>) </td>
<td style="text-align: left;"> (undefined; <code>NA</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Base R's own <code>round()</code> (R version &gt;= 4.0.0), referenced by <code>rounding = "even"</code>, is reconstructed in the same way as <code>"up_or_down"</code>, but whether the
boundary values are inclusive or not is hard to predict. Therefore,
<code>unround()</code> checks if they are, and informs you about it.
</p>


<h3>See Also</h3>

<p>For more about rounding <code>"up"</code>, <code>"down"</code>, or to <code>"even"</code>, see
<code>round_up()</code>.
</p>
<p>For more about the less likely <code>rounding</code> methods, <code>"ceiling"</code>, <code>"floor"</code>,
<code>"trunc"</code>, and <code>"anti_trunc"</code>, see <code>round_ceiling()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># By default, the function assumes that `x`
# was either rounded up or down:
unround(x = "2.7")

# If `x` was rounded up, run this:
unround(x = "2.7", rounding = "up")

# Likewise with rounding down...
unround(x = "2.7", rounding = "down")

# ...and with `base::round()` which, broadly
# speaking, rounds to the nearest even number:
unround(x = "2.7", rounding = "even")

# Multiple input number-strings return
# multiple rows in the output data frame:
unround(x = c(3.6, "5.20", 5.174))
</code></pre>


</div>