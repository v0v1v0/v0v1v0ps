<div class="container">

<table style="width: 100%;"><tr>
<td>snowprofileCsv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read csv file into a snowprofile object</h2>

<h3>Description</h3>

<p>Read csv file into a snowprofile object
</p>


<h3>Usage</h3>

<pre><code class="language-R">snowprofileCsv(
  path,
  header = TRUE,
  sep = ",",
  use.swisscode = FALSE,
  height = "height",
  gtype = "gtype",
  hardness = "hardness",
  ...,
  crust.val = 2,
  tz = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>'path/to/file.csv'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>is there a header line in the csv file to explain the column names? If not, specify a character vector of column names in the correct order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>csv column separator as string</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.swisscode</code></td>
<td>
<p>boolean; are grain types given as (numeric) <code>swisscode</code> (<code>TRUE</code>) or as character strings (<code>FALSE</code>)? If <code>TRUE</code>, grain types can be given
as three-digit code (gt1|gt2|gt3), or as one-digit code specifying the primary grain type <em>if</em> another column is provided that specifies crusts.
See Details and Examples for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>character string referring to the csv column of the top layer interfaces</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gtype</code></td>
<td>
<p>character string referring to the csv column of the grain types</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hardness</code></td>
<td>
<p>character string referring to the csv column of the layer hardnesses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>provide name-value pairs of additional csv columns (in the form <code>gsize = 'csv-GrainSize-ColName'</code>), e.g.
</p>

<ul>
<li>
<p> profile specific info: <code>station</code>, <code>station_id</code>, <code>datetime</code>, <code>latlon</code>, <code>elev</code>, <code>angle</code>, <code>aspect</code>, <code>type</code> (see snowprofile)
</p>
</li>
<li>
<p> layer specific info: deposition date, grain size, ssi, ... (see snowprofileLayers)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crust.val</code></td>
<td>
<p>If a column 'crust' is provided, what value of 'crust' defines MFcr? Mostly, either 2 (default) or 1. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The minimum information required to construct a valid snowprofile object is <code>height</code>, <code>gtype</code> and <code>hardness</code>. Currently, substituting <code>height</code> with
a depth vector is not supported.
</p>
<p>If profile specific information is provided in the csv table, it can only be included into the snowprofile object through the exact field names (see above).
However, layer specific information can be named arbitrarily (except for the three required fields).
</p>
<p>Regarding <strong>swisscode</strong>: The SNOWPACK documentation specifies that MFcr are encoded as (gt1|gt2|gt3) = (7|x|2), i.e. gt1 == 7 and gt3 == 2. This is
also how this routine handles the grain type encoding per default. However, some csv tables might be provided using swisscode encoding and
providing gt1, gt2, and gt3 as individual one-digit columns. In those cases, gt3 could be defined as a boolean (0 or 1), where gt1 == 7 and gt3 == 1
represent crusts, instead of the aforementioned standard definition of gt1 == 7 and gt3 == 2. To handle these cases, <code>crust.val</code> can be set to 1, instead
of its default <code>crust.val = 2</code>.
</p>


<h3>Value</h3>

<p>snowprofile object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p>snowprofileCsv_advanced
</p>


<h3>Examples</h3>

<pre><code class="language-R">## imagine a csv table with a very straightforward format,
## similar to the following data.frame:
(DF &lt;- data.frame(height = c(50, 80, 100), gtype = c('FC', 'RG', 'PP'), hardness = c(1, 3, 2)))
## write DF to a temporary file:
write.csv(DF, file = file.path(tempdir(), 'file.csv'))

## read this file very easily by
profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'))
profile


## imagine a csv table that requires a bit more customization,
## similar to the following data.frame:
(DF &lt;- data.frame(ID = rep(1234, times = 3), layer_top = c(10.5, 15, 55.0), gt1 = c(5, 7, 2),
                  gs = c(5.0, 1.5, 1.0), crust = c(0, 1, 0), hardness = c('F', 'P', '4F+')))
write.csv(DF, file = file.path(tempdir(), 'file.csv'))

profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'), height = 'layer_top', gtype = 'gt1',
                          use.swisscode = TRUE, gsize = 'gs', crust.val = 1)
profile
## Note that the csv column 'crust', which specifies whether a MF layer is actually
#  a MFcr layer, is already named correctly (i.e., 'crust'). If it were named 'freeze-crust',
#  we would need to add to the function call: `crust = 'freeze-crust'`.
# Also note, that we need to provide `crust.val = 1`, since we're not using the standard definition
# of swisscode MFcr encoding (see Details).

## let's assume you want to read the csv file an customize some names, e.g. GrainSIZE:
profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'), height = 'layer_top', gtype = 'gt1',
                          use.swisscode = TRUE, GrainSIZE = 'gs')
profile

## Note that generally in a snowprofile object layer properties can be custom named,
#  meta information, e.g. station_id, can not! I.e. you need to use the prescribed names.


</code></pre>


</div>