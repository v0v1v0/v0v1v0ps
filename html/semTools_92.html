<div class="container">

<table style="width: 100%;"><tr>
<td>permuteMeasEq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Permutation Randomization Tests of Measurement Equivalence and Differential
Item Functioning (DIF)</h2>

<h3>Description</h3>

<p>The function <code>permuteMeasEq</code> provides tests of hypotheses involving
measurement equivalence, in one of two frameworks: multigroup CFA or MIMIC
models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">permuteMeasEq(nPermute, modelType = c("mgcfa", "mimic"), con, uncon = NULL,
  null = NULL, param = NULL, freeParam = NULL, covariates = NULL,
  AFIs = NULL, moreAFIs = NULL, maxSparse = 10, maxNonconv = 10,
  showProgress = TRUE, warn = -1, datafun, extra,
  parallelType = c("none", "multicore", "snow"), ncpus = NULL, cl = NULL,
  iseed = 12345)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nPermute</code></td>
<td>
<p>An integer indicating the number of random permutations used
to form empirical distributions under the null hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelType</code></td>
<td>
<p>A character string indicating type of model employed:
multiple-group CFA (<code>"mgcfa"</code>) or MIMIC (<code>"mimic"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con</code></td>
<td>
<p>The constrained <code>lavaan</code> object, in which the parameters
specified in <code>param</code> are constrained to equality across all groups when
<code>modelType = "mgcfa"</code>, or which regression paths are fixed to zero when
<code>modelType = "mimic"</code>. In the case of testing <em>configural</em>
invariance when <code>modelType = "mgcfa"</code>, <code>con</code> is the configural
model (implicitly, the unconstrained model is the saturated model, so use
the defaults <code>uncon = NULL</code> and <code>param = NULL</code>). When
<code>modelType = "mimic"</code>, <code>con</code> is the MIMIC model in which the
covariate predicts the latent construct(s) but no indicators (unless they
have already been identified as DIF items).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncon</code></td>
<td>
<p>Optional.  The unconstrained <code>lavaan</code> object, in which the
parameters specified in <code>param</code> are freely estimated in all groups.
When <code>modelType = "mgcfa"</code>, only in the case of testing
<em>configural</em> invariance should <code>uncon = NULL</code>. When
<code>modelType = "mimic"</code>, any non-<code>NULL uncon</code> is silently set to
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null</code></td>
<td>
<p>Optional.  A <code>lavaan</code> object, in which an alternative null
model is fit (besides the default independence model specified by
<code>lavaan</code>) for the calculation of incremental fit indices. See Widamin &amp;
Thompson (2003) for details. If <code>NULL</code>, <code>lavaan</code>'s default
independence model is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>An optional character vector or list of character vectors
indicating which parameters the user would test for DIF following a
rejection of the omnibus null hypothesis tested using
(<code>more</code>)<code>AFIs</code>. Note that <code>param</code> does not guarantee certain
parameters <em>are</em> constrained in <code>con</code>; that is for the user to
specify when fitting the model. If users have any "anchor items" that they
would never intend to free across groups (or levels of a covariate), these
should be excluded from <code>param</code>; exceptions to a type of parameter can
be specified in <code>freeParam</code>. When <code>modelType = "mgcfa"</code>,
<code>param</code> indicates which parameters of interest are constrained across
groups in <code>con</code> and are unconstrained in <code>uncon</code>. Parameter names
must match those returned by <code>names(coef(con))</code>, but omitting any
group-specific suffixes (e.g., <code>"f1~1"</code> rather than <code>"f1~1.g2"</code>)
or user-specified labels (that is, the parameter names must follow the rules
of lavaan's <code>model.syntax</code>). Alternatively (or
additionally), to test all constraints of a certain type (or multiple types)
of parameter in <code>con</code>, <code>param</code> may take any combination of the
following values: <code>"loadings"</code>, <code>"intercepts"</code>,
<code>"thresholds"</code>, <code>"residuals"</code>, <code>"residual.covariances"</code>,
<code>"means"</code>, <code>"lv.variances"</code>, and/or <code>"lv.covariances"</code>. When
<code>modelType = "mimic"</code>, <code>param</code> must be a vector of individual
parameters or a list of character strings to be passed one-at-a-time to
<code>lavTestScore</code><code>(object = con, add = param[i])</code>,
indicating which (sets of) regression paths fixed to zero in <code>con</code> that
the user would consider freeing (i.e., exclude anchor items). If
<code>modelType = "mimic"</code> and <code>param</code> is a list of character strings,
the multivariate test statistic will be saved for each list element instead
of 1-<em>df</em> modification indices for each individual parameter, and
<code>names(param)</code> will name the rows of the <code>MI.obs</code> slot (see
permuteMeasEq). Set <code>param = NULL</code> (default) to avoid
collecting modification indices for any follow-up tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freeParam</code></td>
<td>
<p>An optional character vector, silently ignored when
<code>modelType = "mimic"</code>. If <code>param</code> includes a type of parameter
(e.g., <code>"loadings"</code>), <code>freeParam</code> indicates exceptions (i.e.,
anchor items) that the user would <em>not</em> intend to free across groups
and should therefore be ignored when calculating <em>p</em> values adjusted
for the number of follow-up tests. Parameter types that are already
unconstrained across groups in the fitted <code>con</code> model (i.e., a
<em>partial</em> invariance model) will automatically be ignored, so they do
not need to be specified in <code>freeParam</code>. Parameter names must match
those returned by <code>names(coef(con))</code>, but omitting any group-specific
suffixes (e.g., <code>"f1~1"</code> rather than <code>"f1~1.g2"</code>) or
user-specified labels (that is, the parameter names must follow the rules of
lavaan <code>model.syntax</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>An optional character vector, only applicable when
<code>modelType = "mimic"</code>. The observed data are partitioned into columns
indicated by <code>covariates</code>, and the rows are permuted simultaneously for
the entire set before being merged with the remaining data.  Thus, the
covariance structure is preserved among the covariates, which is necessary
when (e.g.) multiple dummy codes are used to represent a discrete covariate
or when covariates interact. If <code>covariates = NULL</code> when
<code>modelType = "mimic"</code>, the value of <code>covariates</code> is inferred by
searching <code>param</code> for predictors (i.e., variables appearing after the
"<code>~</code>" operator).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AFIs</code></td>
<td>
<p>A character vector indicating which alternative fit indices (or
chi-squared itself) are to be used to test the multiparameter omnibus null
hypothesis that the constraints specified in <code>con</code> hold in the
population. Any fit measures returned by <code>fitMeasures</code>
may be specified (including constants like <code>"df"</code>, which would be
nonsensical). If both <code>AFIs</code> and <code>moreAFIs</code> are <code>NULL</code>, only
<code>"chisq"</code> will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moreAFIs</code></td>
<td>
<p>Optional. A character vector indicating which (if any)
alternative fit indices returned by <code>moreFitIndices</code>
are to be used to test the multiparameter omnibus null hypothesis that the
constraints specified in <code>con</code> hold in the population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxSparse</code></td>
<td>
<p>Only applicable when <code>modelType = "mgcfa"</code> and at
least one indicator is <code>ordered</code>. An integer indicating the maximum
number of consecutive times that randomly permuted group assignment can
yield a sample in which at least one category (of an <code>ordered</code>
indicator) is unobserved in at least one group, such that the same set of
parameters cannot be estimated in each group. If such a sample occurs, group
assignment is randomly permuted again, repeatedly until a sample is obtained
with all categories observed in all groups. If <code>maxSparse</code> is exceeded,
<code>NA</code> will be returned for that iteration of the permutation
distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNonconv</code></td>
<td>
<p>An integer indicating the maximum number of consecutive
times that a random permutation can yield a sample for which the model does
not converge on a solution. If such a sample occurs, permutation is
attempted repeatedly until a sample is obtained for which the model does
converge. If <code>maxNonconv</code> is exceeded, <code>NA</code> will be returned for
that iteration of the permutation distribution, and a warning will be
printed when using <code>show</code> or <code>summary</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showProgress</code></td>
<td>
<p>Logical. Indicating whether to display a progress bar
while permuting. Silently set to <code>FALSE</code> when using parallel options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Sets the handling of warning messages when fitting model(s) to
permuted data sets. See <code>options</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datafun</code></td>
<td>
<p>An optional function that can be applied to the data
(extracted from <code>con</code>) after each permutation, but before fitting the
model(s) to each permutation. The <code>datafun</code> function must have an
argument named <code>data</code> that accepts a <code>data.frame</code>, and it must
return a <code>data.frame</code> containing the same column names. The column
order may differ, the values of those columns may differ (so be careful!),
and any additional columns will be ignored when fitting the model, but an
error will result if any column names required by the model syntax do not
appear in the transformed data set. Although available for any
<code>modelType</code>, <code>datafun</code> may be useful when using the MIMIC method
to test for nonuniform DIF (metric/weak invariance) by using product
indicators for a latent factor representing the interaction between a factor
and one of the <code>covariates</code>, in which case the product indicators would
need to be recalculated after each permutation of the <code>covariates</code>. To
access other R objects used within <code>permuteMeasEq</code>, the arguments to
<code>datafun</code> may also contain any subset of the following: <code>"con"</code>,
<code>"uncon"</code>, <code>"null"</code>, <code>"param"</code>, <code>"freeParam"</code>,
<code>"covariates"</code>, <code>"AFIs"</code>, <code>"moreAFIs"</code>, <code>"maxSparse"</code>,
<code>"maxNonconv"</code>, and/or <code>"iseed"</code>. The values for those arguments
will be the same as the values supplied to <code>permuteMeasEq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra</code></td>
<td>
<p>An optional function that can be applied to any (or all) of the
fitted lavaan objects (<code>con</code>, <code>uncon</code>, and/or <code>null</code>). This
function will also be applied after fitting the model(s) to each permuted
data set. To access the R objects used within <code>permuteMeasEq</code>, the
arguments to <code>extra</code> must be any subset of the following: <code>"con"</code>,
<code>"uncon"</code>, <code>"null"</code>, <code>"param"</code>, <code>"freeParam"</code>,
<code>"covariates"</code>, <code>"AFIs"</code>, <code>"moreAFIs"</code>, <code>"maxSparse"</code>,
<code>"maxNonconv"</code>, and/or <code>"iseed"</code>. The values for those arguments
will be the same as the values supplied to <code>permuteMeasEq</code>. The
<code>extra</code> function must return a named <code>numeric</code> vector or a named
<code>list</code> of scalars (i.e., a <code>list</code> of <code>numeric</code> vectors of
<code>length == 1</code>). Any unnamed elements (e.g., <code>""</code> or <code>NULL</code>)
of the returned object will result in an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallelType</code></td>
<td>
<p>The type of parallel operation to be used (if any). The
default is <code>"none"</code>. Forking is not possible on Windows, so if
<code>"multicore"</code> is requested on a Windows machine, the request will be
changed to <code>"snow"</code> with a message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>Integer: number of processes to be used in parallel operation.
If <code>NULL</code> (the default) and <code>parallelType 
c("multicore","snow")</code>, the default is one less than the maximum number of
processors detected by <code>detectCores</code>. This default is
also silently set if the user specifies more than the number of processors
detected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use when
<code>parallelType = "snow"</code>.  If <code>NULL</code>, a <code>"PSOCK"</code> cluster on
the local machine is created for the duration of the <code>permuteMeasEq</code>
call. If a valid <code>makeCluster</code> object is supplied,
<code>parallelType</code> is silently set to <code>"snow"</code>, and <code>ncpus</code> is
silently set to <code>length(cl)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>Integer: Only used to set the states of the RNG when using
parallel options, in which case <code>RNGkind</code> is set to
<code>"L'Ecuyer-CMRG"</code> with a message. See
<code>clusterSetRNGStream</code> and Section 6 of
<code>vignette("parallel", "parallel")</code> for more details. If user supplies
an invalid value, <code>iseed</code> is silently set to the default (12345). To
set the state of the RNG when not using parallel options, call
<code>set.seed</code> before calling <code>permuteMeasEq</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>permuteMeasEq</code> provides tests of hypotheses involving
measurement equivalence, in one of two frameworks:
</p>

<ol>
<li>
<p>1 For multiple-group CFA models, provide a pair of nested lavaan objects,
the less constrained of which (<code>uncon</code>) freely estimates a set of
measurement parameters (e.g., factor loadings, intercepts, or thresholds;
specified in <code>param</code>) in all groups, and the more constrained of which
(<code>con</code>) constrains those measurement parameters to equality across
groups. Group assignment is repeatedly permuted and the models are fit to
each permutation, in order to produce an empirical distribution under the
null hypothesis of no group differences, both for (a) changes in
user-specified fit measures (see <code>AFIs</code> and <code>moreAFIs</code>) and for
(b) the maximum modification index among the user-specified equality
constraints. Configural invariance can also be tested by providing that
fitted lavaan object to <code>con</code> and leaving <code>uncon = NULL</code>, in which
case <code>param</code> must be <code>NULL</code> as well.
</p>
</li>
<li>
<p>2 In MIMIC models, one or a set of continuous and/or discrete
<code>covariates</code> can be permuted, and a constrained model is fit to each
permutation in order to provide a distribution of any fit measures (namely,
the maximum modification index among fixed parameters in <code>param</code>) under
the null hypothesis of measurement equivalence across levels of those
covariates.
</p>
</li>
</ol>
<p>In either framework, modification indices for equality constraints or fixed
parameters specified in <code>param</code> are calculated from the constrained
model (<code>con</code>) using the function <code>lavTestScore</code>.
</p>
<p>For multiple-group CFA models, the multiparameter omnibus null hypothesis of
measurement equivalence/invariance is that there are no group differences in
any measurement parameters (of a particular type). This can be tested using
the <code>anova</code> method on nested <code>lavaan</code> objects, as seen in the
output of <code>measurementInvariance</code>, or by inspecting
the change in alternative fit indices (AFIs) such as the CFI. The
permutation randomization method employed by <code>permuteMeasEq</code> generates
an empirical distribution of any <code>AFIs</code> under the null hypothesis, so
the user is not restricted to using fixed cutoffs proposed by Cheung &amp;
Rensvold (2002), Chen (2007), or Meade, Johnson, &amp; Braddy (2008).
</p>
<p>If the multiparameter omnibus null hypothesis is rejected, partial
invariance can still be established by freeing invalid equality constraints,
as long as equality constraints are valid for at least two indicators per
factor. Modification indices can be calculated from the constrained model
(<code>con</code>), but multiple testing leads to inflation of Type I error rates.
The permutation randomization method employed by <code>permuteMeasEq</code>
creates a distribution of the maximum modification index if the null
hypothesis is true, which allows the user to control the familywise Type I
error rate in a manner similar to Tukey's <em>q</em> (studentized range)
distribution for the Honestly Significant Difference (HSD) post hoc test.
</p>
<p>For MIMIC models, DIF can be tested by comparing modification indices of
regression paths to the permutation distribution of the maximum modification
index, which controls the familywise Type I error rate. The MIMIC approach
could also be applied with multiple-group models, but the grouping variable
would not be permuted; rather, the covariates would be permuted separately
within each group to preserve between-group differences. So whether
parameters are constrained or unconstrained across groups, the MIMIC
approach is only for testing null hypotheses about the effects of
<code>covariates</code> on indicators, controlling for common factors.
</p>
<p>In either framework, <code>lavaan</code>'s <code>group.label</code>
argument is used to preserve the order of groups seen in <code>con</code> when
permuting the data.
</p>


<h3>Value</h3>

<p>The permuteMeasEq object representing the results of
testing measurement equivalence (the multiparameter omnibus test) and DIF
(modification indices), as well as diagnostics and any <code>extra</code> output.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam;
<a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>


<h3>References</h3>

<p><b>Papers about permutation tests of measurement equivalence:</b>
</p>
<p>Jorgensen, T. D., Kite, B. A., Chen, P.-Y., &amp; Short, S. D. (2018).
Permutation randomization methods for testing measurement equivalence and
detecting differential item functioning in multiple-group confirmatory
factor analysis. <em>Psychological Methods, 23</em>(4), 708–728.
<a href="https://doi.org/10.1037/met0000152">doi:10.1037/met0000152</a>
</p>
<p>Kite, B. A., Jorgensen, T. D., &amp; Chen, P.-Y. (2018). Random permutation
testing applied to measurement invariance testing with ordered-categorical
indicators. <em>Structural Equation Modeling 25</em>(4), 573–587.
<a href="https://doi.org/10.1080/10705511.2017.1421467">doi:10.1080/10705511.2017.1421467</a>
</p>
<p>Jorgensen, T. D. (2017). Applying permutation tests and multivariate
modification indices to configurally invariant models that need
respecification. <em>Frontiers in Psychology, 8</em>(1455).
<a href="https://doi.org/10.3389/fpsyg.2017.01455">doi:10.3389/fpsyg.2017.01455</a>
</p>
<p><b>Additional reading:</b>
</p>
<p>Chen, F. F. (2007). Sensitivity of goodness of fit indexes to
lack of measurement invariance.  <em>Structural Equation Modeling, 14</em>(3),
464–504. <a href="https://doi.org/10.1080/10705510701301834">doi:10.1080/10705510701301834</a>
</p>
<p>Cheung, G. W., &amp; Rensvold, R. B. (2002). Evaluating goodness-of-fit indexes
for testing measurement invariance. <em>Structural Equation Modeling,
9</em>(2), 233–255. <a href="https://doi.org/10.1207/S15328007SEM0902_5">doi:10.1207/S15328007SEM0902_5</a>
</p>
<p>Meade, A. W., Johnson, E. C., &amp; Braddy, P. W. (2008). Power and sensitivity
of alternative fit indices in tests of measurement invariance. <em>Journal
of Applied Psychology, 93</em>(3), 568–592. <a href="https://doi.org/10.1037/0021-9010.93.3.568">doi:10.1037/0021-9010.93.3.568</a>
</p>
<p>Widamin, K. F., &amp; Thompson, J. S. (2003). On specifying the null model for
incremental fit indices in structural equation modeling. <em>Psychological
Methods, 8</em>(1), 16–37. <a href="https://doi.org/10.1037/1082-989X.8.1.16">doi:10.1037/1082-989X.8.1.16</a>
</p>


<h3>See Also</h3>

<p><code>TukeyHSD</code>, <code>lavTestScore</code>,
<code>measurementInvariance</code>,
<code>measurementInvarianceCat</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

########################
## Multiple-Group CFA ##
########################

## create 3-group data in lavaan example(cfa) data
HS &lt;- lavaan::HolzingerSwineford1939
HS$ageGroup &lt;- ifelse(HS$ageyr &lt; 13, "preteen",
                      ifelse(HS$ageyr &gt; 13, "teen", "thirteen"))

## specify and fit an appropriate null model for incremental fit indices
mod.null &lt;- c(paste0("x", 1:9, " ~ c(T", 1:9, ", T", 1:9, ", T", 1:9, ")*1"),
              paste0("x", 1:9, " ~~ c(L", 1:9, ", L", 1:9, ", L", 1:9, ")*x", 1:9))
fit.null &lt;- cfa(mod.null, data = HS, group = "ageGroup")

## fit target model with varying levels of measurement equivalence
mod.config &lt;- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
fit.config &lt;- cfa(mod.config, data = HS, std.lv = TRUE, group = "ageGroup")
fit.metric &lt;- cfa(mod.config, data = HS, std.lv = TRUE, group = "ageGroup",
                  group.equal = "loadings")
fit.scalar &lt;- cfa(mod.config, data = HS, std.lv = TRUE, group = "ageGroup",
                  group.equal = c("loadings","intercepts"))


####################### Permutation Method

## fit indices of interest for multiparameter omnibus test
myAFIs &lt;- c("chisq","cfi","rmsea","mfi","aic")
moreAFIs &lt;- c("gammaHat","adjGammaHat")

## Use only 20 permutations for a demo.  In practice,
## use &gt; 1000 to reduce sampling variability of estimated p values

## test configural invariance
set.seed(12345)
out.config &lt;- permuteMeasEq(nPermute = 20, con = fit.config)
out.config

## test metric equivalence
set.seed(12345) # same permutations
out.metric &lt;- permuteMeasEq(nPermute = 20, uncon = fit.config, con = fit.metric,
                            param = "loadings", AFIs = myAFIs,
                            moreAFIs = moreAFIs, null = fit.null)
summary(out.metric, nd = 4)

## test scalar equivalence
set.seed(12345) # same permutations
out.scalar &lt;- permuteMeasEq(nPermute = 20, uncon = fit.metric, con = fit.scalar,
                            param = "intercepts", AFIs = myAFIs,
                            moreAFIs = moreAFIs, null = fit.null)
summary(out.scalar)

## Not much to see without significant DIF.
## Try using an absurdly high alpha level for illustration.
outsum &lt;- summary(out.scalar, alpha = .50)

## notice that the returned object is the table of DIF tests
outsum

## visualize permutation distribution
hist(out.config, AFI = "chisq")
hist(out.metric, AFI = "chisq", nd = 2, alpha = .01,
     legendArgs = list(x = "topright"))
hist(out.scalar, AFI = "cfi", printLegend = FALSE)


####################### Extra Output

## function to calculate expected change of Group-2 and -3 latent means if
## each intercept constraint were released
extra &lt;- function(con) {
  output &lt;- list()
  output["x1.vis2"] &lt;- lavTestScore(con, release = 19:20, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[70]
  output["x1.vis3"] &lt;- lavTestScore(con, release = 19:20, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[106]
  output["x2.vis2"] &lt;- lavTestScore(con, release = 21:22, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[70]
  output["x2.vis3"] &lt;- lavTestScore(con, release = 21:22, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[106]
  output["x3.vis2"] &lt;- lavTestScore(con, release = 23:24, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[70]
  output["x3.vis3"] &lt;- lavTestScore(con, release = 23:24, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[106]
  output["x4.txt2"] &lt;- lavTestScore(con, release = 25:26, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[71]
  output["x4.txt3"] &lt;- lavTestScore(con, release = 25:26, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[107]
  output["x5.txt2"] &lt;- lavTestScore(con, release = 27:28, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[71]
  output["x5.txt3"] &lt;- lavTestScore(con, release = 27:28, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[107]
  output["x6.txt2"] &lt;- lavTestScore(con, release = 29:30, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[71]
  output["x6.txt3"] &lt;- lavTestScore(con, release = 29:30, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[107]
  output["x7.spd2"] &lt;- lavTestScore(con, release = 31:32, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[72]
  output["x7.spd3"] &lt;- lavTestScore(con, release = 31:32, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[108]
  output["x8.spd2"] &lt;- lavTestScore(con, release = 33:34, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[72]
  output["x8.spd3"] &lt;- lavTestScore(con, release = 33:34, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[108]
  output["x9.spd2"] &lt;- lavTestScore(con, release = 35:36, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[72]
  output["x9.spd3"] &lt;- lavTestScore(con, release = 35:36, univariate = FALSE,
                                    epc = TRUE, warn = FALSE)$epc$epc[108]
  output
}

## observed EPC
extra(fit.scalar)

## permutation results, including extra output
set.seed(12345) # same permutations
out.scalar &lt;- permuteMeasEq(nPermute = 20, uncon = fit.metric, con = fit.scalar,
                            param = "intercepts", AFIs = myAFIs,
                            moreAFIs = moreAFIs, null = fit.null, extra = extra)
## summarize extra output
summary(out.scalar, extra = TRUE)


###########
## MIMIC ##
###########

## Specify Restricted Factor Analysis (RFA) model, equivalent to MIMIC, but
## the factor covaries with the covariate instead of being regressed on it.
## The covariate defines a single-indicator construct, and the
## double-mean-centered products of the indicators define a latent
## interaction between the factor and the covariate.
mod.mimic &lt;- '
visual  =~ x1 + x2 + x3
age =~ ageyr
age.by.vis =~ x1.ageyr + x2.ageyr + x3.ageyr

x1 ~~ x1.ageyr
x2 ~~ x2.ageyr
x3 ~~ x3.ageyr
'

HS.orth &lt;- indProd(var1 = paste0("x", 1:3), var2 = "ageyr", match = FALSE,
                   data = HS[ , c("ageyr", paste0("x", 1:3))] )
fit.mimic &lt;- cfa(mod.mimic, data = HS.orth, meanstructure = TRUE)
summary(fit.mimic, stand = TRUE)

## Whereas MIMIC models specify direct effects of the covariate on an indicator,
## DIF can be tested in RFA models by specifying free loadings of an indicator
## on the covariate's construct (uniform DIF, scalar invariance) and the
## interaction construct (nonuniform DIF, metric invariance).
param &lt;- as.list(paste0("age + age.by.vis =~ x", 1:3))
names(param) &lt;- paste0("x", 1:3)
# param &lt;- as.list(paste0("x", 1:3, " ~ age + age.by.vis")) # equivalent

## test both parameters simultaneously for each indicator
do.call(rbind, lapply(param, function(x) lavTestScore(fit.mimic, add = x)$test))
## or test each parameter individually
lavTestScore(fit.mimic, add = as.character(param))


####################### Permutation Method

## function to recalculate interaction terms after permuting the covariate
datafun &lt;- function(data) {
  d &lt;- data[, c(paste0("x", 1:3), "ageyr")]
  indProd(var1 = paste0("x", 1:3), var2 = "ageyr", match = FALSE, data = d)
}

set.seed(12345)
perm.mimic &lt;- permuteMeasEq(nPermute = 20, modelType = "mimic",
                            con = fit.mimic, param = param,
                            covariates = "ageyr", datafun = datafun)
summary(perm.mimic)


## End(Not run)

</code></pre>


</div>