<div class="container">

<table style="width: 100%;"><tr>
<td>capacity_logreg_main</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate channel capacity between discrete input and continuous output</h2>

<h3>Description</h3>

<p>The main wrapping function for basic usage of SLEMI package for estimation of channel capacity. Firstly, data is pre-processed
(all arguments are checked, observation with NAs are removed, variables are scaled and centered (if scale=TRUE)). Then basic estimation is carried out
and (if testing=TRUE) diagnostic tests are computed. If output directory path is given (output_path is not NULL), graphs visualising the data and the analysis
are saved there, together with a compressed output object (as .rds file) with full estimation results.
</p>


<h3>Usage</h3>

<pre><code class="language-R">capacity_logreg_main(
  dataRaw,
  signal = "input",
  response = NULL,
  output_path = NULL,
  side_variables = NULL,
  formula_string = NULL,
  cc_maxit = 100,
  lr_maxit = 1000,
  MaxNWts = 5000,
  testing = FALSE,
  model_out = TRUE,
  scale = TRUE,
  TestingSeed = 1234,
  testing_cores = 1,
  boot_num = 10,
  boot_prob = 0.8,
  sidevar_num = 10,
  traintest_num = 10,
  partition_trainfrac = 0.6,
  plot_width = 6,
  plot_height = 4,
  data_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataRaw</code></td>
<td>
<p>must be a data.frame object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_path</code></td>
<td>
<p>is the directory in which output will be saved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cc_maxit</code></td>
<td>
<p>is the number of iteration of iterative optimisation of the algorithm to estimate channel capacity. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing</code></td>
<td>
<p>is the logical indicating if the testing procedures should be executed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_out</code></td>
<td>
<p>is the logical indicating if the calculated logistic regression model should be included in output list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>is a logical indicating if the response variables should be scaled and centered before fitting logistic regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TestingSeed</code></td>
<td>
<p>is the seed for random number generator used in testing procedures</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing_cores</code></td>
<td>
<p>- number of cores to be used in parallel computing (via doParallel package)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_num</code></td>
<td>
<p>is the number of bootstrap tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_prob</code></td>
<td>
<p>is the proportion of initial size of data to be used in bootstrap</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sidevar_num</code></td>
<td>
<p>is the number of re-shuffling tests of side variables to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traintest_num</code></td>
<td>
<p>is the number of overfitting tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition_trainfrac</code></td>
<td>
<p>is the fraction of data to be used as a training dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_width</code></td>
<td>
<p>-  basic dimensions (width) of plots, in inches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_height</code></td>
<td>
<p>-  basic dimensions (height) of plots, in inches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_out</code></td>
<td>
<p>is the logical indicating if the data should be included in output list</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In a typical experiment aimed to quantify information flow a given signaling system, input values <code class="reqn">x_1\leq x_2 \ldots... \leq x_m</code>, ranging from 0 to saturation are considered.
Then, for each input level, <code class="reqn">x_i</code>, <code class="reqn">n_i</code> observations are collected, which are represented as vectors 
</p>
<p style="text-align: center;"><code class="reqn">y^i_j \sim P(Y|X = x_i)</code>
</p>

<p>Within information theory the degree of information transmission is measured as the mutual information
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(y|X = x_i)}{P(y)}dy,</code>
</p>

<p>where <code class="reqn">P(y)</code> is the marginal distribution of the output. MI is expressed in bits and <code class="reqn">2^{MI}</code> can be interpreted as the number of 
inputs that the system can resolve on average.
</p>
<p>The maximization of mutual information with respect to the input distribution, <code class="reqn">P(X)</code>,
defines the information capacity, C. Formally,
</p>
<p style="text-align: center;"><code class="reqn">C^* = max_{P(X)} MI(X,Y)</code>
</p>

<p>Information capacity is expressed in bits and <code class="reqn">2^{C^*}</code> can be interpreted as the maximal number of inputs that the system can
effectively resolve.
</p>
<p>In contrast to existing approaches, instead of estimating, possibly highly dimensional, conditional output distributions P(Y|X =x_i), we propose to estimate the discrete, conditional input distribution, 
<code class="reqn">P(x_i |Y = y)</code>, which is known to be a simpler problem. Estimation of the MI using estimates of <code class="reqn">P(x_i |Y = y)</code>, denoted here as <code class="reqn">\hat{P}(x_i|Y = y)</code>, is possible as the MI, can be
alternatively written as
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(x_i|Y = y)}{P(x_i)}dy</code>
</p>

<p>The expected value (as in above expression) with respect to distribution <code class="reqn">P(Y|X = x_i)</code> can be approximated by the average with respect to data
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) \approx \sum_{i=1}^{m} P(x_i)\frac{1}{n_i} \sum_{j=1}^{n_i} P(y|X = x_i)log_2\frac{\hat{P}(x_i|Y = y^i_j)}{P(x_i)}dy</code>
</p>

<p>Here, we propose to use logistic regression as <code class="reqn">\hat{P}(x_i|Y = y^i_j)</code>. Specifically,
</p>
<p style="text-align: center;"><code class="reqn">log\frac{P(x_i |Y = y)}{P(x_m|Y = y)} \approx \alpha_i +\beta_iy</code>
</p>

<p>Following this approach, channel capacity can be calculated by optimising MI with respect to the input distribution, <code class="reqn">P(X)</code>.
However, this, potentially difficult problem, can be divided into two simpler maximization problems, for which explicit solutions exist. 
Therefore, channel capacity can be obtained from the two explicit solutions in an iterative procedure known as alternate maximization (similarly as in Blahut-Arimoto algorithm) [1].
</p>
<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). Preliminary scaling of  data (argument scale) should be used similarly as in other 
data-driven approaches, e.g. if response variables are comparable, scaling (scale=FALSE) can be omitted, while if they represent 
different phenomenon (varying by units and/or magnitude) scaling is recommended.
</p>


<h3>Value</h3>

<p>a list with several elements:
</p>

<ul>
<li>
<p> output$regression - confusion matrix of logistic regression predictions
</p>
</li>
<li>
<p> output$cc         - channel capacity in bits
</p>
</li>
<li>
<p> output$p_opt      - optimal probability distribution
</p>
</li>
<li>
<p> output$model      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li>
<li>
<p> output$params     - parameters used in algorithm
</p>
</li>
<li>
<p> output$time       - computation time of calculations
</p>
</li>
<li>
<p> output$testing    - a 2- or 4-element output list of testing procedures (if testing=TRUE)
</p>
</li>
<li>
<p> output$testing_pv - one-sided p-values of testing procedures (if testing=TRUE)
</p>
</li>
<li>
<p> output$data       - raw data used in analysis
</p>
</li>
</ul>
<h3>References</h3>

<p>[1] Csiszar I, Tusnady G, Information geometry and alternating minimization procedures, Statistics &amp; Decisions 1 Supplement 1 (1984), 205â€“237.
</p>
<p>[2] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tempdata=data_example1
outputCLR1=capacity_logreg_main(dataRaw=tempdata,
signal="signal", response="response",cc_maxit = 10,
formula_string = "signal~response")

tempdata=data_example2
outputCLR2=capacity_logreg_main(dataRaw=tempdata,
signal="signal", response=c("X1","X2"),cc_maxit = 10,
formula_string = "signal~X1+X2") 

#For further details see vignette
</code></pre>


</div>