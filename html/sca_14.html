<div class="container">

<table style="width: 100%;"><tr>
<td>sca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simple Component Analysis – Interactively</h2>

<h3>Description</h3>

<p>A system of simple components calculated from a correlation (or
variance-covariance) matrix is built (interactively if <code>interactive =
    TRUE</code>) following the methodology of Rousson and Gasser (2003).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sca(S, b = if(interactive) 5, d = 0, qmin = if(interactive) 0 else 5,
    corblocks = if(interactive) 0 else 0.3,
    criterion = c("csv", "blp"), cluster = c("median","single","complete"),
    withinblock = TRUE, invertsigns = FALSE,
    interactive = dev.interactive())
## S3 method for class 'simpcomp'
print(x, ndec = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>the correlation (or variance-covariance) matrix to be analyzed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>the number of block-components initially proposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>the number of difference-components initially proposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmin</code></td>
<td>
<p>if larger than zero, the number of difference-components
is chosen such that the system contains at least <code>qmin</code>
components (overriding argument <code>d</code>!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corblocks</code></td>
<td>
<p>if larger than zero, the number of block-components
is chosen such that correlations among them are all smaller than
<code>corblocks</code> (overriding argument <code>b</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>character string specifying the optimality criterion
to be used for evaluating a system of simple components.  One of
<code>"csv"</code> (corrected sum of variances) or <code>"blp"</code> (best
linear predictor); can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>character string specifying the clustering method to be
used in the definition of the block-components.  One of
<code>"single"</code> (single linkage), <code>"median"</code> (median linkage)
or <code>"complete"</code> (complete linkage) can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinblock</code></td>
<td>
<p>a logical indicating whether any given
difference-component should only involve variables belonging to the
same block-component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invertsigns</code></td>
<td>
<p>a logical indicating whether the sign of some
variables should be inverted initially in order to avoid negative
correlations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactive</code></td>
<td>
<p>a logical indicating whether the system of simple
components should be built interactively.  If <code>interactive=FALSE</code>, an
optimal system of simple components is automatically calculated
without any intervention of the user (according to <code>b</code> or
<code>corblocks</code>, and to <code>d</code> or <code>qmin</code>).
</p>
<p>By default, <code>interactive = dev.interactive()</code> (which is
true if <code>interactive()</code> and <code>.Device</code> is an
interactive graphics device).</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>sca</code>, typically the result of
<code>sca(..)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndec</code></td>
<td>
<p>number of decimals <em>after</em> the dot, for the
percentages printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments, passed to and from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When confronted with a large number <code class="reqn">p</code> of variables measuring
different aspects of a same theme, the practitionner may like to
summarize the information into a limited number <code class="reqn">q</code> of components.  A
<em>component</em> is a linear combination of the original variables, and
the weights in this linear combination are called the <em>loadings</em>.
Thus, a system of components is defined by a <code class="reqn">p</code> times <code class="reqn">q</code> dimensional
matrix of loadings.
</p>
<p>Among all systems of components, principal components (PCs) are
optimal in many ways.  In particular, the first few PCs extract a
maximum of the variability of the original variables and they are
uncorrelated, such that the extracted information is organized in an
optimal way: we may look at one PC after the other, separately,
without taking into account the rest.
</p>
<p>Unfortunately PCs are often difficult to interpret. The goal of Simple
Component Analysis is to replace (or to supplement) the optimal but
non-interpretable PCs by suboptimal but interpretable <em>simple
components</em>. The proposal of Rousson and Gasser (2003) is to look for
an optimal system of components, but only among the simple ones,
according to some definition of optimality and simplicity. The outcome
of their method is a simple matrix of loadings calculated from the
correlation matrix <code class="reqn">S</code> of the original variables.
</p>
<p>Simplicity is not a guarantee for interpretability (but it helps in
this regard).  Thus, the user may wish to partly modify an optimal
system of simple components in order to enhance
interpretability.  While PCs are by definition 100% optimal, the
optimal system of simple components proposed by the procedure <code>sca</code>
may be, say, 95%, optimal, whereas the simple system altered by the
user may be, say, 93% optimal. It is ultimately to the user to decide
if the gain in interpretability is worth the loss of optimality.
</p>
<p>The interactive procedure <code>sca</code> is intended to assist the user in
his/her choice for an interptetable system of simple components. The
algorithm consists of three distinct stages and proceeds in an
interative way. At each step of the procedure, a simple matrix of
loadings is displayed in a window. The user may alter this matrix by
clicking on its entries, following the instructions given there.  If
all the loadings of a component share the same sign, it is a
“block-component”.  If some loadings are positive and some loadings
are negative, it is a “difference-component”.  Block-components are
arguably easier to interpret than
difference-components. Unfortunately, PCs almost always contain only
one block-component. In the procedure <code>sca</code>, the user may choose the
number of block-components in the system, the rationale being to have
as many block-components such that correlations among them are below
some cut-off value (typically .3 or .4).
</p>
<p>Simple block-components should define a partition of the original
variables. This is done in the first stage of the procedure <code>sca</code>. An
agglomerative hierarchical clustering procedure is used there.
</p>
<p>The second stage of the procedure <code>sca</code> consists in the definition of
simple difference-components.  Those are obtained as simplified
versions of some appropriate “residual components”. The idea is to
retain the large loadings (in absolute value) of these residual
components and to shrink to zero the small ones. For each
difference-component, the interactive procedure <code>sca</code> displays the
loadings of the corresponding residual component (at the right side of
the window), such that the user may know which variables are
especially important for the definition of this component.
</p>
<p>At the third stage of the interactive procedure <code>sca</code>, it is possible
to remove some of the difference-components from the system.
</p>
<p>For many examples, it is possible to find a simple system which is 90%
or 95% optimal, and where correlations between components are below 0.3
or 0.4. When the structure in the correlation matrix is complicated, it
might be advantageous to invert the sign of some of the variables in
order to avoid as much as possible negative correlations. This can be
done using the option ‘invertsigns=TRUE’.
</p>
<p>In principle, simple components can be calculated from a correlation
matrix or from a variance-covariance matrix. However, the definition
of simplicity used is not well adapted to the latter case, such that
it will result in systems which are far from being 100%
optimal. Thus, it is advised to define simple components from a
correlation matrix, not from a variance-covariance matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>simpcomp</code> which is basically as list with
the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>simplemat</code></td>
<td>
<p>an integer matrix defining a system of simple
components.  The rows correspond to variables and the columns correspond to
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>loadings of simple components.  This is a
version of <code>simplemat</code>, normalized by a version of
<code>scale</code>.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>allcrit</code></td>
<td>
<p>a <code>list</code> containing the following components:
</p>

<dl>
<dt>varpc</dt>
<dd>
<p>a vector containing the percentage of total
variability accounted by each of the the first <code>nblock + ndiff</code>
principal components of <code>S</code>.</p>
</dd>
<dt>varsc</dt>
<dd>
<p>a vector containing the percentage of total
variability accounted by each of the simple components defined by
<code>simplemat</code>.</p>
</dd>
<dt>cumpc</dt>
<dd>
<p>the sum of varpc, indicating the percentage of total
variability accounted by the first <code>nblock + ndiff</code> principal
components of <code>S</code>.</p>
</dd>
<dt>cumsc</dt>
<dd>
<p>a score indicating the percentage of total
variability accounted by the system of simple
components. <code>cumsc</code> is calculated according to <code>criterion</code>.</p>
</dd>
<dt>opt</dt>
<dd>
<p>indicates the optimality of the system of simple
components and is computed as <code>cumsc/cumpc</code>.</p>
</dd>
<dt>corsc</dt>
<dd>
<p>correlation matrix of the simple components defined
by <code>simplemat</code>.</p>
</dd>
<dt>maxcor</dt>
<dd>
<p>a list with the following components:
</p>

<dl>
<dt>row</dt>
<dd>
<p>label of the row of the maximum value in <code>corsc</code>.</p>
</dd>
<dt>col</dt>
<dd>
<p>label of the column of the maximum value in <code>corsc</code>.</p>
</dd>
<dt>val</dt>
<dd>
<p>maximum value in <code>corsc</code> (in absolute value).</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>nblock</code></td>
<td>
<p>number of block-components in <code>simplemat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndiff</code></td>
<td>
<p>number of difference-components in <code>simplemat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>as above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>as above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinblock</code></td>
<td>
<p>as above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invertsigns</code></td>
<td>
<p>as above</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vardata</code></td>
<td>
<p>the correlation (or variance-covariance) matrix which
was analyzed. In principle it should be equal to argument <code>S</code> above,
except if it has been transformed in order to avoid negative
correlations.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>PCA already is known to be “non-unique” in the sense that the
principal directions (eigen vectors, <code>eigen</code>) are only
determined up to a factor <code class="reqn">\pm 1</code>, i.e., sign change.
</p>
<p>Consequently results may change depending e.g., only on the Lapack / BLAS
library used.


This is even more the case for SCA, notably in artificial situations
such as the ‘<span class="file">tests/artif3.R</span>’ in the sources of <a href="https://CRAN.R-project.org/package=sca"><span class="pkg">sca</span></a>.
</p>


<h3>Author(s)</h3>

<p>Valentin Rousson <a href="mailto:rousson@ifspm.unizh.ch">rousson@ifspm.unizh.ch</a> and
Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>.</p>


<h3>References</h3>

<p>Rousson, Valentin and Gasser, Theo (2004)
Simple Component Analysis.
<em>JRSS: Series C (Applied Statistics)</em> <b>53</b>(4), 539–555;
<a href="https://doi.org/10.1111/j.1467-9876.2004.05359.x">doi:10.1111/j.1467-9876.2004.05359.x</a>
</p>
<p>Rousson, V. and Gasser, Th. (2003)
<em>Some Case Studies of Simple Component Analysis</em>.
Manuscript, <em>no longer</em> available as
‘<span class="file">https://www.biostat.uzh.ch/research/manuscripts/scacases.pdf</span>’
</p>
<p>Gervini, D. and Rousson, V. (2003)
<em>Some Proposals for Evaluating Systems of Components in Dimension
Reduction Problems</em>.
Submitted.
</p>


<h3>See Also</h3>

<p><code>prcomp</code> (for PCA), etc.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(pitpropC)
sc.pitp &lt;- sca(pitpropC, interactive=FALSE)
sc.pitp
## to see it's low-level components:
str(sc.pitp)

## Let `X' be a matrix containing some data set whose rows correspond to
## subjects and whose columns correspond to variables. For example:


library(MASS)
SigU &lt;- function(p, rho) { r &lt;- diag(p); r[col(r) != row(r)] &lt;- rho; r}
rmvN &lt;- function(n,p, rho)
        mvrnorm(n, mu=rep(0,p), Sigma = SigU(p, rho))
X &lt;- cbind(rmvN(100, 3, 0.7),
           rmvN(100, 2, 0.9),
           rmvN(100, 4, 0.8))


## An optimal simple system with at least 5 components for the data in `X',
## where the number of block-components is such that correlations among
## them are all smaller than 0.4, can be automatically obtained as:

(r &lt;- sca(cor(X), qmin=5, corblocks=0.4, interactive=FALSE))

## On the other hand, an optimal simple system with two block-components
## and two difference-components for the data in `X' can be automatically
## obtained as:

(r &lt;- sca(cor(X), b=2, d=2, qmin=0, corblocks=0, interactive=FALSE))

## The resulting simple matrix is contained in `r$simplemat'.
## A matrix of scores for such simple components can then be obtained as:

(Z &lt;- scale(X) %*% r$loadings)

## On the other hand, scores of simple components calculated from the
## variance-covariance matrix of `X' can be obtained as:

r &lt;- sca(var(X), b=2, d=2, qmin=0, corblocks=0, interactive=FALSE)
Z &lt;- scale(X, scale=FALSE) %*% r$loadings

## One can also use the program interactively as follows:

if(interactive()) {
  r &lt;- sca(cor(X), corblocks=0.4, qmin=5, interactive = TRUE)

  ## Since the interactive part of the program is active here, the proposed
  ## system can then be  modified according to the user's wishes. The
  ## result of the procedure will be contained in `r'.
}

</code></pre>


</div>