<div class="container">

<table style="width: 100%;"><tr>
<td>stable.GR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gelman-Rubin diagnostic using stable variance estimators</h2>

<h3>Description</h3>

<p>This function uses fast and strongly consistent estimators estimators of Monte Carlo variance to calculate the Gelman-Rubin convergence diagnostic for Markov chain Monte Carlo. A univariate ‘potential scale reduction factor’ (PSRF) is calculated for each variable in <code>x</code>. For multivariate chains, a multivariate PSRF is calculated to take into account the interdependence of the chain's components.  The PSRFs decrease to 1 as the chain length increases. When the PSRF becomes sufficiently close to 1, the sample collected by the Markov chain has converged to the target distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stable.GR(
  x,
  multivariate = TRUE,
  mapping = "determinant",
  method = "lug",
  size = NULL,
  autoburnin = FALSE,
  blather = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a list of matrices, where each matrix represents one Markov chain sample. Each row of the matrices represents one step of the chain. Each column of the matrices represents one variable. A list with a single matrix (chain) is allowed. Optionally, this can be an <code>mcmclist</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multivariate</code></td>
<td>
<p>a logical flag indicating whether the multivariate potential scale reduction factor should be calculated for multivariate chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>the function used to map the covariance matrix to a scalar. This is one of “<code>determinant</code>” (determinant of the covariance matrix, the default) or “<code>maxeigen</code>” (the largest eigenvalue of the covariance matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used to compute the standard error of the chains. This is one of “<code>lug</code>” (lugsail, the default), “<code>bm</code>” (batch means), “<code>obm</code>” (overlapping batch means), “<code>tukey</code>” (spectral variance method with a Tukey-Hanning window), or “<code>bartlett</code>” (spectral variance method with a Bartlett window).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>options are <code>NULL</code> (default, which calculates an ideal batch size), character values of <code>sqroot</code> and <code>cuberoot</code>, or any numeric value between 1 and <code class="reqn">n</code>. Size represents the batch size in “<code>bm</code>” (batch means) and the truncation point in “<code>bartlett</code>” and “<code>tukey</code>”. sqroot means size is floor(n^(1/2) and cuberoot means size is floor(n^(1/3)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half of the series should be used in the computation.  If set to TRUE and <code>start(x)</code> is less than <code>end(x)/2</code> then start of series will be adjusted so that only second half of series is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blather</code></td>
<td>
<p>a logical flag indicating whether to include additional output.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>psrf</code></td>
<td>
<p>A vector containing the point estimates of the PSRF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mpsrf</code></td>
<td>
<p>A scalar point estimate of the multivariate PSRF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>A vector containing the sample means based on the chains provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.eff</code></td>
<td>
<p>A scalar point estimate of the effective sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blather</code></td>
<td>
<p>Either <code>FALSE</code> or a list containing intermediate calculations.</p>
</td>
</tr>
</table>
<h3>Theory</h3>

<p>Gelman and Rubin (1992) and Brooks and Gelman (1998) first constructed the univariate and 
multivariate potential scale reduction factors (PSRF), respectively,  to diagnose Markov chain 
convergence. The function <code>stable.GR</code> stabilizes the PSRF and improves the PSRF's efficiency by 
incorporating lugsail estimators for the target variance. The PSRF decreases to 1 as the chain length
increases; when the PSRF becomes sufficiently close to 1, the sample collected by the Markov chain has 
converged to to the target distribution. A PSRF convergence threshold can be calculated using 
<code>choosepsrf</code>.
</p>


<h3>References</h3>

<p>Vats, D. and Knudson, C. Revisiting the Gelman-Rubin Diagnostic.	arXiv:1812.09384. 
</p>
<p>Vats, D. and Flegal, J. Lugsail lag windows and their application to MCMC. arXiv: 1809.04541.
</p>
<p>Flegal, J. M. and Jones, G. L. (2010) Batch means and spectral variance estimators in Markov chain Monte Carlo. <em>The Annals of Statistics</em>, <b>38</b>, 1034–1070. <br></p>
<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511. <br></p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. <em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(stableGR)
set.seed(100)
p &lt;- 2
n &lt;- 100 # n is tiny here purely for demo purposes.
# use n much larger for real problems!

sig.mat = matrix(c(1, .8, .8, 1), ncol = 2, nrow = 2)

# Making 3 chains
chain1 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain2 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)
chain3 &lt;- mvn.gibbs(N = n, p = p, mu = rep(1,p), sigma = sig.mat)

# find GR diagnostic using all three chains
x &lt;- list(chain1, chain2, chain3)
stable.GR(x) 


</code></pre>


</div>