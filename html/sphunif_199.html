<div class="container">

<table style="width: 100%;"><tr>
<td>r_alt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample non-uniformly distributed spherical data</h2>

<h3>Description</h3>

<p>Simple simulation of prespecified non-uniform spherical
distributions: von Mises–Fisher (vMF), Mixture of vMF (MvMF),
Angular Central Gaussian (ACG), Small Circle (SC), Watson (W),
Cauchy-like (C), Mixture of Cauchy-like (MC), or Uniform distribution with
Antipodal-Dependent observations (UAD).
</p>


<h3>Usage</h3>

<pre><code class="language-R">r_alt(n, p, M = 1, alt = "vMF", mu = c(rep(0, p - 1), 1), kappa = 1,
  nu = 0.5, F_inv = NULL, K = 1000, axial_mix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of samples of size <code>n</code>. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt</code></td>
<td>
<p>alternative, must be <code>"vMF"</code>, <code>"MvMF"</code>, <code>"ACG"</code>,
<code>"SC"</code>, <code>"W"</code>, <code>"C"</code>, <code>"MC"</code>, or <code>"UAD"</code>. See
details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>location parameter for <code>"vMF"</code>, <code>"SC"</code>, <code>"W"</code>, and
<code>"C"</code>. Defaults to <code>c(rep(0, p - 1), 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>non-negative parameter measuring the strength of the deviation
with respect to uniformity (obtained with <code class="reqn">\kappa = 0</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>projection along <code class="reqn">{\bf e}_p</code> controlling the modal
strip of the small circle distribution. Must be in (-1, 1). Defaults to
<code>0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F_inv</code></td>
<td>
<p>quantile function returned by <code>F_inv_from_f</code>. Used
for <code>"SC"</code>, <code>"W"</code>, and <code>"C"</code>. Computed by internally if
<code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">F^{-1}</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axial_mix</code></td>
<td>
<p>use a mixture of von Mises–Fisher or Cauchy-like that is
axial (i.e., symmetrically distributed about the origin)? Defaults to
<code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter <code>kappa</code> is used as <code class="reqn">\kappa</code> in the following
distributions:
</p>

<ul>
<li> <p><code>"vMF"</code>: von Mises–Fisher distribution with concentration
<code class="reqn">\kappa</code> and directional mean <code class="reqn">\boldsymbol{\mu}</code>.
</p>
</li>
<li> <p><code>"MvMF"</code>: equally-weighted mixture of <code class="reqn">p</code> von Mises–Fisher
distributions with common concentration <code class="reqn">\kappa</code> and directional means
<code class="reqn">\pm{\bf e}_1, \ldots, \pm{\bf e}_p</code> if
<code>axial_mix = TRUE</code>. If <code>axial_mix = FALSE</code>, then only means
with positive signs are considered.
</p>
</li>
<li> <p><code>"ACG"</code>: Angular Central Gaussian distribution with diagonal
shape matrix with diagonal given by
</p>
<p style="text-align: center;"><code class="reqn">(1, \ldots, 1, 1 + \kappa) / (p + \kappa).</code>
</p>

</li>
<li> <p><code>"SC"</code>: Small Circle distribution with axis mean
<code class="reqn">\boldsymbol{\mu}</code> and concentration <code class="reqn">\kappa</code> about the projection
along the mean, <code class="reqn">\nu</code>.
</p>
</li>
<li> <p><code>"W"</code>: Watson distribution with axis mean <code class="reqn">\boldsymbol{\mu}</code>
and concentration <code class="reqn">\kappa</code>. The Watson distribution is a particular
case of the Bingham distribution.
</p>
</li>
<li> <p><code>"C"</code>: Cauchy-like distribution with directional mode
<code class="reqn">\boldsymbol{\mu}</code> and concentration
<code class="reqn">\kappa = \rho / (1 - \rho^2)</code>. The circular Wrapped Cauchy
distribution is a particular case of this Cauchy-like distribution.
</p>
</li>
<li> <p><code>"MC"</code>: equally-weighted mixture of <code class="reqn">p</code> Cauchy-like
distributions with common concentration <code class="reqn">\kappa</code> and directional means
<code class="reqn">\pm{\bf e}_1, \ldots, \pm{\bf e}_p</code> if
<code>axial_mix = TRUE</code>. If <code>axial_mix = FALSE</code>, then only means
with positive signs are considered.
</p>
</li>
</ul>
<p>The alternative <code>"UAD"</code> generates a sample formed by
<code class="reqn">\lceil n/2\rceil</code> observations drawn uniformly on <code class="reqn">S^{p-1}</code>
and the remaining observations drawn from a uniform spherical cap
distribution of angle <code class="reqn">\pi-\kappa</code> about each of the
<code class="reqn">\lceil n/2\rceil</code> observations (see <code>unif_cap</code>). Hence,
<code>kappa = 0</code> corresponds to a spherical cap covering the whole sphere and
<code>kappa = pi</code> is a one-point degenerate spherical cap.
</p>
<p>Much faster sampling for <code>"SC"</code>, <code>"W"</code>, <code>"C"</code>, and <code>"MC"</code>
is achieved providing <code>F_inv</code>; see examples.
</p>


<h3>Value</h3>

<p>An <b>array</b> of size <code>c(n, p, M)</code> with <code>M</code> random
samples of size <code>n</code> of non-uniformly-generated directions on
<code class="reqn">S^{p-1}</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulation with p = 2

p &lt;- 2
n &lt;- 50
kappa &lt;- 20
nu &lt;- 0.5
angle &lt;- pi / 10
rho &lt;- ((2 * kappa + 1) - sqrt(4 * kappa + 1)) / (2 * kappa)
F_inv_SC_2 &lt;- F_inv_from_f(f = function(z) exp(-kappa * (z - nu)^2), p = 2)
F_inv_W_2 &lt;- F_inv_from_f(f = function(z) exp(kappa * z^2), p = 2)
F_inv_C_2 &lt;- F_inv_from_f(f = function(z) (1 - rho^2) /
                            (1 + rho^2 - 2 * rho * z)^(p / 2), p = 2)
x1 &lt;- r_alt(n = n, p = p, alt = "vMF", kappa = kappa)[, , 1]
x2 &lt;- r_alt(n = n, p = p, alt = "C", F_inv = F_inv_C_2)[, , 1]
x3 &lt;- r_alt(n = n, p = p, alt = "SC", F_inv = F_inv_SC_2)[, , 1]
x4 &lt;- r_alt(n = n, p = p, alt = "ACG", kappa = kappa)[, , 1]
x5 &lt;- r_alt(n = n, p = p, alt = "W", F_inv = F_inv_W_2)[, , 1]
x6 &lt;- r_alt(n = n, p = p, alt = "MvMF", kappa = kappa)[, , 1]
x7 &lt;- r_alt(n = n, p = p, alt = "MC", kappa = kappa)[, , 1]
x8 &lt;- r_alt(n = n, p = p, alt = "UAD", kappa = 1 - angle)[, , 1]
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
plot(r * x1, pch = 16, xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1), col = 1)
points(r * x2, pch = 16, col = 2)
points(r * x3, pch = 16, col = 3)
plot(r * x4, pch = 16, xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1), col = 1)
points(r * x5, pch = 16, col = 2)
points(r * x6, pch = 16, col = 3)
points(r * x7, pch = 16, col = 4)
col &lt;- rep(rainbow(n / 2), 2)
plot(r * x8, pch = 16, xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1), col = col)
for (i in seq(1, n, by = 2)) lines((r * x8)[i + 0:1, ], col = col[i])

## Simulation with p = 3

n &lt;- 50
p &lt;- 3
kappa &lt;- 20
angle &lt;- pi / 10
nu &lt;- 0.5
rho &lt;- ((2 * kappa + 1) - sqrt(4 * kappa + 1)) / (2 * kappa)
F_inv_SC_3 &lt;- F_inv_from_f(f = function(z) exp(-kappa * (z - nu)^2), p = 3)
F_inv_W_3 &lt;- F_inv_from_f(f = function(z) exp(kappa * z^2), p = 3)
F_inv_C_3 &lt;- F_inv_from_f(f = function(z) (1 - rho^2) /
                            (1 + rho^2 - 2 * rho * z)^(p / 2), p = 3)
x1 &lt;- r_alt(n = n, p = p, alt = "vMF", kappa = kappa)[, , 1]
x2 &lt;- r_alt(n = n, p = p, alt = "C", F_inv = F_inv_C_3)[, , 1]
x3 &lt;- r_alt(n = n, p = p, alt = "SC", F_inv = F_inv_SC_3)[, , 1]
x4 &lt;- r_alt(n = n, p = p, alt = "ACG", kappa = kappa)[, , 1]
x5 &lt;- r_alt(n = n, p = p, alt = "W", F_inv = F_inv_W_3)[, , 1]
x6 &lt;- r_alt(n = n, p = p, alt = "MvMF", kappa = kappa)[, , 1]
x7 &lt;- r_alt(n = n, p = p, alt = "MC", kappa = kappa)[, , 1]
x8 &lt;- r_alt(n = n, p = p, alt = "UAD", kappa = 1 - angle)[, , 1]
s3d &lt;- scatterplot3d::scatterplot3d(x1, pch = 16, xlim = c(-1.1, 1.1),
                                    ylim = c(-1.1, 1.1), zlim = c(-1.1, 1.1))
s3d$points3d(x2, pch = 16, col = 2)
s3d$points3d(x3, pch = 16, col = 3)
s3d &lt;- scatterplot3d::scatterplot3d(x4, pch = 16, xlim = c(-1.1, 1.1),
                                    ylim = c(-1.1, 1.1), zlim = c(-1.1, 1.1))
s3d$points3d(x5, pch = 16, col = 2)
s3d$points3d(x6, pch = 16, col = 3)
s3d$points3d(x7, pch = 16, col = 4)
col &lt;- rep(rainbow(n / 2), 2)
s3d &lt;- scatterplot3d::scatterplot3d(x8, pch = 16, xlim = c(-1.1, 1.1),
                                    ylim = c(-1.1, 1.1), zlim = c(-1.1, 1.1),
                                    color = col)
for (i in seq(1, n, by = 2)) s3d$points3d(x8[i + 0:1, ], col = col[i],
                                          type = "l")
</code></pre>


</div>