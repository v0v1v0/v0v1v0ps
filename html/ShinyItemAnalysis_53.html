<div class="container">

<table style="width: 100%;"><tr>
<td>plot_corr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute and plot an item correlation matrix</h2>

<h3>Description</h3>

<p>Computes and visualizes an item correlation matrix (also known as a heatmap),
offering several correlation "types" and optional clustering (with possible
cluster outlining). The function relies on <code>ggplot2()</code> package, providing a
high customisability using "the grammar of graphics" (see the examples
below).
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_corr(
  Data,
  cor = c("polychoric", "tetrachoric", "pearson", "spearman", "none"),
  clust_method = "none",
  n_clust = 0L,
  shape = c("circle", "square"),
  labels = FALSE,
  labels_size = 3,
  line_size = 0.5,
  line_col = "black",
  line_alpha = 1,
  fill = NA,
  fill_alpha = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Data</code></td>
<td>
<p><code>matrix</code>, <code>data.frame</code> or <code>tibble</code>: either a
<code>data.frame</code> with scored items (as columns, one observation per row),
or a correlation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>character: correlation "type" used to correlation matrix
computation; available options are <code>polychoric</code>, <code>tetrachoric</code>,
<code>pearson</code>, <code>spearman</code>, or <code>none</code> (in case you provide
the correlation matrix as <code>Data</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust_method</code></td>
<td>
<p>character: optional clustering method, available options
are: <code>ward.D</code>, <code>ward.D2</code>, <code>single</code>, <code>complete</code>,
<code>average</code> (= UPGMA), <code>mcquitty</code> (= WPGMA), <code>median</code> (=
WPGMC), <code>centroid</code> (= UPGMC) or <code>none</code> (clustering disabled).
See <code>hclust()</code> for a detailed description of available options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_clust</code></td>
<td>
<p>integer: the number of clusters you want to be outlined. When
set to zero (the default), no cluster are outlined, but items still do get
sorted according to <code>clust_method</code> (if not set to <code>none</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>character: tile appearance; either <code>circle</code> (default) to
map the correlation coefficient to circle size and color, or <code>square</code>
to draw square-shaped tiles with only shade denoting the coefficient
magnitude. You can use an unambiguous abbreviation of the two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>logical: when <code>TRUE</code>, the correlation coefficients are
plotted onto tiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_size</code></td>
<td>
<p>numeric: label size in points (pts).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_size</code></td>
<td>
<p>numeric: cluster outline width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_col</code></td>
<td>
<p>character: color of the outline, either a HEX code (e.g.
"#123456"), or one of <code>R</code>'s standard colors (see the
<code>colors()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_alpha</code></td>
<td>
<p>numeric 0-1: the opacity of the outline.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>character: the color used to fill the outlined clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_alpha</code></td>
<td>
<p>numeric 0–1: the opacity of the fill color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>psych::polychoric</code>
</p>

<dl>
<dt><code>correct</code></dt>
<dd>
<p>Correction value to use to correct for continuity in the case of zero entry cell for tetrachoric, polychoric, polybi, and mixed.cor.  See the examples for the effect of correcting versus not correcting for continuity.</p>
</dd>
<dt><code>smooth</code></dt>
<dd>
<p>if TRUE and if the tetrachoric/polychoric matrix is not positive definite, then apply a simple smoothing algorithm using cor.smooth</p>
</dd>
<dt><code>global</code></dt>
<dd>
<p>When finding pairwise correlations, should we use the global values of the tau parameter (which is somewhat faster), or the local values (global=FALSE)?  The local option is equivalent to the polycor solution, or to doing one correlation at a time. global=TRUE borrows information for one item pair from the other pairs using those item's frequencies.   This will make a difference in the presence of lots of missing data. With very small sample sizes with global=FALSE and correct=TRUE, the function will fail (for as yet underdetermined reasons. </p>
</dd>
<dt><code>weight</code></dt>
<dd>
<p>A vector of length of the number of observations that specifies the weights to apply to each case.  The NULL case is equivalent of weights of 1 for all cases.  </p>
</dd>
<dt><code>std.err</code></dt>
<dd>
<p>std.err=FALSE does not report the standard errors (faster)  deprecated</p>
</dd>
<dt><code>progress</code></dt>
<dd>
<p>Show the progress bar (if  not doing multicores)</p>
</dd>
<dt><code>ML</code></dt>
<dd>
<p> ML=FALSE  do a quick two step procedure, ML=TRUE, do longer maximum likelihood — very slow! Deprecated</p>
</dd>
<dt><code>delete</code></dt>
<dd>
<p>Cases with no variance are deleted with a warning before proceeding.</p>
</dd>
<dt><code>max.cat</code></dt>
<dd>
<p>The maximum number of categories to bother with for polychoric.  </p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Correlation heatmap displays selected type of correlations between items. The
color of tiles indicates how much and in which way the items are correlated
– red color means positive correlation and blue color means negative
correlation. Correlation heatmap can be reordered using hierarchical
clustering method specified with <code>clust_method</code> argument. When the desired
number of clusters (argument <code>n_clust</code>) is not zero and some clustering is
demanded, the rectangles outlining the found clusters are drawn.
</p>


<h3>Value</h3>

<p>An object of class <code>ggplot</code> and/or <code>gg</code>.
</p>


<h3>Author(s)</h3>

<p>Jan Netik <br>
Institute of Computer Science of the Czech Academy of Sciences <br><a href="mailto:netik@cs.cas.cz">netik@cs.cas.cz</a>
</p>
<p>Patricia Martinkova <br>
Institute of Computer Science of the Czech Academy of Sciences <br><a href="mailto:martinkova@cs.cas.cz">martinkova@cs.cas.cz</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># use first 20 columns from HCI dataset (the remainder are not items)
HCI &lt;- HCI[, 1:20]

# use Pearson product-moment correlation coefficient for matrix computation
plot_corr(HCI, cor = "pearson")

## Not run: 
# use tetrachoric correlation and reorder the resulting heatmap
# using Ward's method
HCI %&gt;% plot_corr(cor = "tetrachoric", clust_method = "ward.D")

# outline 3 Ward's clusters with bold yellow line and add labels
HCI %&gt;%
  plot_corr(
    n_clust = 3, clust_method = "ward.D2", line_col = "yellow",
    line_size = 1.5, labels = TRUE
  )

# add title and position the legend below the plot
library(ggplot2)
HCI %&gt;%
  plot_corr(n_clust = 3) +
  ggtitle("HCI heatmap") +
  theme(legend.position = "bottom")

# mimic the look of corrplot package
plot_corr(HCI, cor = "polychoric", clust_method = "complete", shape = "square") +
  scale_fill_gradient2(
    limits = c(-.1, 1),
    breaks = seq(-.1, 1, length.out = 12),
    guide = guide_colorbar(
      barheight = .8, barwidth = .0275,
      default.unit = "npc",
      title = NULL, frame.colour = "black", ticks.colour = "black"
    )
  ) +
  theme(axis.text = element_text(colour = "red", size = 12))

## End(Not run)

</code></pre>


</div>