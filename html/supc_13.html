<div class="container">

<table style="width: 100%;"><tr>
<td>supc.random</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Randomized Self-Updating Process Clustering</h2>

<h3>Description</h3>

<p>The Randomized Self-Updating Process Clustering (randomized SUP) is a modification of the original SUP algorithm. 
The randomized SUP randomly generates the partition of the instances during each iterations. 
At each iteration, the self updating process is conducted independently in each partition in order to reduce the computation and the memory.
</p>


<h3>Usage</h3>

<pre><code class="language-R">supc.random(
  x,
  r = NULL,
  rp = NULL,
  t = c("static", "dynamic"),
  k = NULL,
  groups = NULL,
  tolerance = 1e-04,
  cluster.tolerance = 10 * tolerance,
  drop = TRUE,
  implementation = c("cpp", "R"),
  sort = TRUE,
  verbose = (nrow(x) &gt; 10000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data matrix. Each row is an instance of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>numeric vector or <code>NULL</code>. The parameter <code class="reqn">r</code> of the self-updating process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rp</code></td>
<td>
<p>numeric vector or <code>NULL</code>. If <code>r</code> is <code>NULL</code>, then <code>rp</code> will be used. 
The corresponding <code>r</code> is the <code>rp</code>-percentile of the pairwise distances of the data. 
If both <code>r</code> and <code>rp</code> are <code>NULL</code>, then the default value is <code>rp = c(0.0005, 0.001, 0.01, 0.1, 0.3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>either numeric vector, list of function, or one of <code>"static" or "dynamic"</code>. The parameter <code class="reqn">T(t)</code> of the self-updating process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer value. The number of the partitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>list. The first element is the partition of the first iteration, and the second element is the partition
of the second iteration, etc. If the number of the iteration exceeds <code>length(groups)</code>, then new partition will be 
generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>numeric value. The threshold of convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.tolerance</code></td>
<td>
<p>numeric value. After iterations, if the distance of two points are smaller than <code>cluster.tolerance</code>,
then they are identified as in the same cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical value. Whether to delete the list structure if its length is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implementation</code></td>
<td>
<p>eithor <code>"R"</code> or <code>"cpp"</code>. Choose the engine to calculate result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>logical value. Whether to sort the cluster id by size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical value. Whether to show the iteration history.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please check the vignettes via <code>vignette("supc", package = "supc")</code> for details.
</p>


<h3>Value</h3>

<p><code>supc1</code> returns a list of objects of class "supc".
</p>
<p>Each "supc" object contains the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The input matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d0</code></td>
<td>
<p>The pairwise distance matrix of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The value of <code class="reqn">r</code> of the clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>The function <code class="reqn">T(t)</code> of the clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>The cluster id of each instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>The center of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>The size of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>The number of iterations before convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>The partition of each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>The position of data after iterations.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Shiu, Shang-Ying, and Ting-Li Chen. 2016. "On the Strengths of the Self-Updating Process Clustering Algorithm." Journal of Statistical Computation and Simulation 86 (5): 1010â€“1031. doi: <a href="https://doi.org/10.1080/00949655.2015.1049605">10.1080/00949655.2015.1049605</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The shape data has a structure of five clusters and a number of noise data points.

makecircle=function(N, seed){
 n=0
 x=matrix(NA, nrow=N, ncol=2)
 while (n&lt;N){
   tmp=runif(2, min=0, max=1)*2-1
   if (sum(tmp^2)&lt;1) {
      n=n+1
      x[n,]=tmp
   }
 }
 return(x)
}

makedata &lt;- function(ns, seed) {
 size=c(10,3,3,1,1)
 mu=rbind(c(-0.3, -0.3), c(-0.55, 0.8), c(0.55, 0.8), c(0.9, 0), c(0.9, -0.6))
 sd=rbind(c(0.7, 0.7), c(0.45, 0.2), c(0.45, 0.2), c(0.1, 0.1), c(0.1, 0.1))
 x=NULL

 for (i in 1:5){
    tmp=makecircle(ns*size[i], seed+i)
    tmp[,1]=tmp[,1]*sd[i,1]+mu[i,1]
    tmp[,2]=tmp[,2]*sd[i,2]+mu[i,2]
    x=rbind(x, tmp)
 }
 
 tmp=runif(floor(ns/3), min=0, max=1)/5-0.1
 tmp=cbind(tmp, 0.8*rep(1, floor(ns/3)))
 x=rbind(x, tmp)
 x=rbind(x, matrix(1, nrow=2*ns, ncol=2)*2-1)
 return(x)
}

shape1 &lt;- makedata(250, 100)
dim(shape1)
plot(shape1)

X.supc=supc.random(shape1, r=0.5, t="dynamic", k = 500, implementation = "R")
plot(shape1, col=X.supc$cluster)


</code></pre>


</div>