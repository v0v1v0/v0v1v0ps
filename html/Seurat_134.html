<div class="container">

<table style="width: 100%;"><tr>
<td>FindTransferAnchors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find transfer anchors</h2>

<h3>Description</h3>

<p>Find a set of anchors between a reference and query object. These
anchors can later be used to transfer data from the reference to
query object using the <code>TransferData</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FindTransferAnchors(
  reference,
  query,
  normalization.method = "LogNormalize",
  recompute.residuals = TRUE,
  reference.assay = NULL,
  reference.neighbors = NULL,
  query.assay = NULL,
  reduction = "pcaproject",
  reference.reduction = NULL,
  project.query = FALSE,
  features = NULL,
  scale = TRUE,
  npcs = 30,
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = NA,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  approx.pca = TRUE,
  mapping.score.k = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p><code>Seurat</code> object to use as the reference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p><code>Seurat</code> object to use as the query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recompute.residuals</code></td>
<td>
<p>If using SCT as a normalization method, compute
query Pearson residuals using the reference SCT model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.assay</code></td>
<td>
<p>Name of the Assay to use from reference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.neighbors</code></td>
<td>
<p>Name of the Neighbor to use from the reference.
Optionally enables reuse of precomputed neighbors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors.
Options are:
</p>

<ul>
<li>
<p>pcaproject: Project the PCA from the reference onto the query. We
recommend using PCA when reference and query datasets are from scRNA-seq
</p>
</li>
<li>
<p>lsiproject: Project the LSI from the reference onto the query. We
recommend using LSI when reference and query datasets are from scATAC-seq.
This requires that LSI has been computed for the reference dataset, and the
same features (eg, peaks or genome bins) are present in both the reference
and query. See <code>RunTFIDF</code> and
<code>RunSVD</code>
</p>
</li>
<li>
<p>rpca: Project the PCA from the reference onto the query, and the PCA
from the query onto the reference (reciprocal PCA projection).
</p>
</li>
<li>
<p>cca: Run a CCA on the reference and query 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.reduction</code></td>
<td>
<p>Name of dimensional reduction to use from the
reference if running the pcaproject workflow. Optionally enables reuse of
precomputed reference dimensional reduction. If NULL (default), use a PCA
computed on the reference object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>project.query</code></td>
<td>
<p>Project the PCA from the query dataset onto the
reference. Use only in rare cases where the query dataset has a much larger
cell number, but the reference dataset has a unique assay for transfer. In
this case, the default features will be set to the variable features of the
query object that are alos present in the reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>features</code></td>
<td>
<p>Features to use for dimensional reduction. If not specified,
set as variable features of the reference object which are also present in
the query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Scale query data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npcs</code></td>
<td>
<p>Number of PCs to compute on reference if reference.reduction is
not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.norm</code></td>
<td>
<p>Perform L2 normalization on the cell embeddings after
dimensional reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Which dimensions to use from the reduction to specify the
neighbor search space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when finding anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors. Set to
NA to turn off filtering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the
neighborhood search space in the anchor filtering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code>RANN</code> or <code>RcppAnnoy</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx.pca</code></td>
<td>
<p>Use truncated singular value decomposition to approximate
PCA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mapping.score.k</code></td>
<td>
<p>Compute and store nearest k query neighbors in the
AnchorSet object that is returned. You can optionally set this if you plan
on computing the mapping score and want to enable reuse of some downstream
neighbor calculations to make the mapping score function more efficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>

<ul>
<li>
<p>Perform dimensional reduction. Exactly what is done here depends on
the values set for the <code>reduction</code> and <code>project.query</code>
parameters. If <code>reduction = "pcaproject"</code>, a PCA is performed on
either the reference (if <code>project.query = FALSE</code>) or the query (if
<code>project.query = TRUE</code>), using the <code>features</code> specified. The data
from the other dataset is then projected onto this learned PCA structure.
If <code>reduction = "cca"</code>, then CCA is performed on the reference and
query for this dimensional reduction step. If
<code>reduction = "lsiproject"</code>, the stored LSI dimension reduction in the
reference object is used to project the query dataset onto the reference.
If <code>l2.norm</code> is set to <code>TRUE</code>, perform L2 normalization of the
embedding vectors.
</p>
</li>
<li>
<p>Identify anchors between the reference and query - pairs of cells
from each dataset that are contained within each other's neighborhoods
(also known as mutual nearest neighbors).
</p>
</li>
<li>
<p>Filter low confidence anchors to ensure anchors in the low dimension
space are in broad agreement with the high dimensional measurements. This
is done by looking at the neighbors of each query cell in the reference
dataset using <code>max.features</code> to define this space. If the reference
cell isn't found within the first <code>k.filter</code> neighbors, remove the
anchor.
</p>
</li>
<li>
<p>Assign each remaining anchor a score. For each anchor cell, determine
the nearest <code>k.score</code> anchors within its own dataset and within its
pair's dataset. Based on these neighborhoods, construct an overall neighbor
graph and then compute the shared neighbor overlap between anchor and query
cells (analogous to an SNN graph). We use the 0.01 and 0.90 quantiles on
these scores to dampen outlier effects and rescale to range between 0-1.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns an <code>AnchorSet</code> object that can be used as input to
<code>TransferData</code>, <code>IntegrateEmbeddings</code> and
<code>MapQuery</code>. The dimension reduction used for finding anchors is
stored in the <code>AnchorSet</code> object and can be used for computing anchor
weights in downstream functions. Note that only the requested dimensions are
stored in the dimension reduction object in the <code>AnchorSet</code>. This means
that if <code>dims=2:20</code> is used, for example, the dimension of the stored
reduction is <code>1:19</code>.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>;
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("pbmc3k")

# for demonstration, split the object into reference and query
pbmc.reference &lt;- pbmc3k[, 1:1350]
pbmc.query &lt;- pbmc3k[, 1351:2700]

# perform standard preprocessing on each object
pbmc.reference &lt;- NormalizeData(pbmc.reference)
pbmc.reference &lt;- FindVariableFeatures(pbmc.reference)
pbmc.reference &lt;- ScaleData(pbmc.reference)

pbmc.query &lt;- NormalizeData(pbmc.query)
pbmc.query &lt;- FindVariableFeatures(pbmc.query)
pbmc.query &lt;- ScaleData(pbmc.query)

# find anchors
anchors &lt;- FindTransferAnchors(reference = pbmc.reference, query = pbmc.query)

# transfer labels
predictions &lt;- TransferData(
  anchorset = anchors,
  refdata = pbmc.reference$seurat_annotations
)
pbmc.query &lt;- AddMetaData(object = pbmc.query, metadata = predictions)

## End(Not run)

</code></pre>


</div>