<div class="container">

<table style="width: 100%;"><tr>
<td>rasch.mml2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimation of the Generalized Logistic Item Response Model,
Ramsay's Quotient Model, Nonparametric Item Response Model,
Pseudo-Likelihood Estimation and a Missing Data Item Response Model
</h2>

<h3>Description</h3>

<p>This function employs marginal maximum likelihood estimation
of item response models for dichotomous data.
First, the Rasch type model (generalized
item response model) can be estimated. The generalized logistic
link function (Stukel, 1988) can be estimated or fixed for conducting
IRT with different link functions than the logistic one. The Four-Parameter
logistic item response model is a special case of this model
(Loken &amp; Rulison, 2010). Second, Ramsay's quotient model (Ramsay, 1989)
can be estimated by specifying <code>irtmodel="ramsay.qm"</code>.
Third, quite general item response functions can be estimated
in a nonparametric framework (Rossi, Wang &amp; Ramsay, 2002).
Fourth, pseudo-likelihood estimation for fractional item responses can be
conducted for Rasch type models. Fifth, a simple two-dimensional
missing data item response model (<code>irtmodel='missing1'</code>;
Mislevy &amp; Wu, 1996) can be estimated.
</p>
<p>See Details for more explanations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rasch.mml2( dat, theta.k=seq(-6,6,len=21), group=NULL, weights=NULL,
   constraints=NULL, glob.conv=10^(-5), parm.conv=10^(-4), mitermax=4,
   mmliter=1000, progress=TRUE,  fixed.a=rep(1,ncol(dat)),
   fixed.c=rep(0,ncol(dat)), fixed.d=rep(1,ncol(dat)),
   fixed.K=rep(3,ncol(dat)), b.init=NULL, est.a=NULL, est.b=NULL,
   est.c=NULL, est.d=NULL, min.b=-99, max.b=99, min.a=-99, max.a=99,
   min.c=0, max.c=1, min.d=0, max.d=1, prior.b=NULL, prior.a=NULL, prior.c=NULL,
   prior.d=NULL, est.K=NULL, min.K=1, max.K=20, min.delta=-20, max.delta=20,
   beta.init=NULL, min.beta=-8, pid=1:(nrow(dat)), trait.weights=NULL,  center.trait=TRUE,
   center.b=FALSE, alpha1=0, alpha2=0,est.alpha=FALSE, equal.alpha=FALSE,
   designmatrix=NULL, alpha.conv=parm.conv, numdiff.parm=0.00001,
   numdiff.alpha.parm=numdiff.parm, distribution.trait="normal", Qmatrix=NULL,
   variance.fixed=NULL, variance.init=NULL,
   mu.fixed=cbind(seq(1,ncol(Qmatrix)),rep(0,ncol(Qmatrix))),
   irtmodel="raschtype", npformula=NULL, npirt.monotone=TRUE,
   use.freqpatt=is.null(group), delta.miss=0, est.delta=rep(NA,ncol(dat)),
   nimps=0, ... )

## S3 method for class 'rasch.mml'
summary(object, file=NULL, ...)

## S3 method for class 'rasch.mml'
plot(x, items=NULL, xlim=NULL, main=NULL, ...)

## S3 method for class 'rasch.mml'
anova(object,...)

## S3 method for class 'rasch.mml'
logLik(object,...)

## S3 method for class 'rasch.mml'
IRT.irfprob(object,...)

## S3 method for class 'rasch.mml'
IRT.likelihood(object,...)

## S3 method for class 'rasch.mml'
IRT.posterior(object,...)

## S3 method for class 'rasch.mml'
IRT.modelfit(object,...)

## S3 method for class 'rasch.mml'
IRT.expectedCounts(object,...)

## S3 method for class 'IRT.modelfit.rasch.mml'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>An <code class="reqn">N \times I</code> data frame of dichotomous item responses. <br>
For the missing data item response model (<code>irtmodel='missing1'</code>),
code item responses by <code>9</code> which should be treated by the missing
data model. Other missing responses can be coded by <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>

<p>Optional vector of discretized theta values. For multidimensional
IRT models with <code class="reqn">D</code> dimensions, it is a matrix with <code class="reqn">D</code> columns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>

<p>Vector of integers with group identifiers in multiple group estimation.
The multiple group does not work for <code>irtmodel="missing1"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of person weights (sample weights).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>

<p>Constraints on <code>b</code> parameters (item difficulties). It must be
a matrix with two columns: the first column contains item names, the
second column fixed parameter values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.conv</code></td>
<td>

<p>Convergence criterion for deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.conv</code></td>
<td>

<p>Convergence criterion for item parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mitermax</code></td>
<td>

<p>Maximum number of iterations in M step. This argument does only
apply for the estimation of the <code class="reqn">b</code> parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mmliter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>Should progress be displayed at the console?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.a</code></td>
<td>

<p>Fixed or initial <code class="reqn">a</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.c</code></td>
<td>

<p>Fixed or initial <code class="reqn">c</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.d</code></td>
<td>

<p>Fixed or initial <code class="reqn">d</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.K</code></td>
<td>

<p>Fixed or initial <code class="reqn">K</code> parameters in Ramsay's
quotient model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.init</code></td>
<td>

<p>Initial <code class="reqn">b</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.a</code></td>
<td>

<p>Vector of integers which indicate which <code class="reqn">a</code>
parameters should be estimated. Equal integers correspond
to the same estimated parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.b</code></td>
<td>

<p>Vector of integers which indicate which <code class="reqn">b</code>
parameters should be estimated. Equal integers correspond
to the same estimated parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.c</code></td>
<td>

<p>Vector of integers which indicate which <code class="reqn">c</code>
parameters should be estimated. Equal integers correspond
to the same estimated parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.d</code></td>
<td>

<p>Vector of integers which indicate which <code class="reqn">d</code>
parameters should be estimated. Equal integers correspond
to the same estimated parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.b</code></td>
<td>

<p>Minimal <code class="reqn">b</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.b</code></td>
<td>

<p>Maximal <code class="reqn">b</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.a</code></td>
<td>

<p>Minimal <code class="reqn">a</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.a</code></td>
<td>

<p>Maximal <code class="reqn">a</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.c</code></td>
<td>

<p>Minimal <code class="reqn">c</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.c</code></td>
<td>

<p>Maximal <code class="reqn">c</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.d</code></td>
<td>

<p>Minimal <code class="reqn">d</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.d</code></td>
<td>

<p>Maximal <code class="reqn">d</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.b</code></td>
<td>
<p>Optional prior distribution for <code class="reqn">b</code> parameters:
<code class="reqn">N(\mu, \sigma)</code>. Input is a vector of length two with parameters
<code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.a</code></td>
<td>
<p>Optional prior distribution for <code class="reqn">a</code> parameters:
<code class="reqn">N(\mu, \sigma)</code>. Input is a vector of length two with parameters
<code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.c</code></td>
<td>
<p>Optional prior distribution for <code class="reqn">c</code> parameters:
<code class="reqn">Beta(a, b)</code>. Input is a vector of length two with parameters
<code class="reqn">a</code> and <code class="reqn">b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.d</code></td>
<td>
<p>Optional prior distribution for <code class="reqn">d</code> parameters:
<code class="reqn">Beta(a, b)</code>. Input is a vector of length two with parameters
<code class="reqn">a</code> and <code class="reqn">b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.K</code></td>
<td>

<p>Vector of integers which indicate which <code class="reqn">K</code>
parameters should be estimated. Equal integers correspond
to the same estimated parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.K</code></td>
<td>
<p> Minimal <code class="reqn">K</code> parameter to be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.K</code></td>
<td>
<p> Maximal <code class="reqn">K</code> parameter to be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.delta</code></td>
<td>
<p> Minimal <code class="reqn">delta.miss</code> parameter to be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.delta</code></td>
<td>
<p> Maximal <code class="reqn">delta.miss</code> parameter to be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.init</code></td>
<td>
<p>Optional vector of initial <code class="reqn">\beta</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.beta</code></td>
<td>
<p>Minimum <code class="reqn">\beta</code> parameter to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>

<p>Optional vector of person identifiers
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait.weights</code></td>
<td>

<p>Optional vector of trait weights for a fixing
the trait distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.trait</code></td>
<td>

<p>Should the trait distribution be centered
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.b</code></td>
<td>
<p>An optional logical indicating whether <code class="reqn">b</code> parameters
should be centered at each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>

<p>Fixed or initial <code class="reqn">\alpha_1</code> parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha2</code></td>
<td>

<p>Fixed or initial <code class="reqn">\alpha_2</code> parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.alpha</code></td>
<td>

<p>Should <code class="reqn">\alpha</code> parameters be estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal.alpha</code></td>
<td>

<p>Estimate <code class="reqn">\alpha</code> parameters under the
assumption <code class="reqn">\alpha_1=\alpha_2</code>?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designmatrix</code></td>
<td>

<p>Design matrix for item difficulties <code class="reqn">b</code> to estimate
linear logistic test models
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.conv</code></td>
<td>

<p>Convergence criterion for <code class="reqn">\alpha</code> parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.parm</code></td>
<td>

<p>Parameter for numerical differentiation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.alpha.parm</code></td>
<td>

<p>Parameter for numerical differentiation for <code class="reqn">\alpha</code>
parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution.trait</code></td>
<td>

<p>Assumed trait distribution. The default is the normal
distribution (<code>"normal"</code>). Log-linear smoothing of the
trait distribution is also possible (<code>"smooth2"</code>,
<code>"smooth3"</code> or <code>"smooth4"</code> for smoothing up to
2, 3 or 4 moments, respectively).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmatrix</code></td>
<td>

<p>The Q-matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.fixed</code></td>
<td>

<p>Matrix for fixing covariance matrix (See Examples)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.init</code></td>
<td>
<p>Optional initial covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.fixed</code></td>
<td>

<p>Matrix for fixing mean vector (See Examples)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irtmodel</code></td>
<td>

<p>Specify estimable IRT models: <code>raschtype</code> (Rasch type model),
<code>ramsay.qm</code> (Ramsay's quotient model), <code>npirt</code> (Nonparametric
item response model). If <code>npirt</code> is used as the argument
for <code>irtmodel</code>, the argument <code>npformula</code>
specifies different item response functions in the
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> formula framework (like <code>"y~I(theta^2)"</code>; see Examples).
For estimating the missing data item response model, use
<code>irtmodel='missing1'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npformula</code></td>
<td>

<p>A string or a vector which contains <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> formula objects for specifying
the item response function. For example, <code>"y~theta"</code> is the specification
of the 2PL model (see Details). If <code>irtmodel="npirt"</code> and <code>npformula</code>
is not specified, then an unrestricted item response functions on the
grid of <code class="reqn">\theta</code> values is estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npirt.monotone</code></td>
<td>
<p>Should nonparametrically estimated item response functions
be monotone? The default is <code>TRUE</code>. This function applies only
to <code>irtmodel='npirt'</code> and <code>npformula=NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.freqpatt</code></td>
<td>
<p>A logical if frequencies of pattern should be used or not.
The default is <code>is.null(group)</code>. This means that for single
group analyses, frequency patterns are used but not for multiple
groups. If data processing times are large, then <code>use.freqpatt=FALSE</code>
is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.miss</code></td>
<td>
<p>Missingness parameter <code class="reqn">\delta</code> quantifying the meaning
of responding to an item between the two extremes of ignoring
missing responses and setting all missing responses to incorrect</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.delta</code></td>
<td>
<p>Vector with indices indicating the <code class="reqn">\delta</code> parameters
to be estimated if <code>irtmodel="missing1"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nimps</code></td>
<td>
<p>Number of imputed datasets of item responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>rasch.mml</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>rasch.mml</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>items</code></td>
<td>
<p>Vector of integer or item names which should be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>Specification for <code>xlim</code> in plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>Title of the plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name for summary output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The item response function of the generalized item response model
(<code>irtmodel="raschtype"</code>; Stukel, 1988) can be written as
</p>
<p style="text-align: center;"><code class="reqn">P( X_{pi}=1 | \theta_{pd} )=c_i + (d_i - c_i ) g_{\alpha_1, \alpha_2}
[ a_i ( \theta_{pd} - b_i ) ] </code>
</p>

<p>where <code class="reqn">g</code> is the generalized logistic link function depending
on parameters <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code>.
</p>
<p>For the most important link functions the specifications are (Stukel, 1988):
</p>
<p>logistic link function: <code class="reqn">\alpha_1=0</code> and <code class="reqn">\alpha_2=0</code> <br>
probit link function: <code class="reqn">\alpha_1=0.165</code> and <code class="reqn">\alpha_2=0.165</code> <br>
loglog link function: <code class="reqn">\alpha_1=-0.037</code> and <code class="reqn">\alpha_2=0.62</code> <br>
cloglog link function: <code class="reqn">\alpha_1=0.62</code> and <code class="reqn">\alpha_2=-0.037</code>
</p>
<p>See <code>pgenlogis</code> for exact transformation formulas of
the mentioned link functions. <br></p>
<p>A <code class="reqn">D</code>-dimensional model can also be specified
but only allows for between item dimensionality
(one item loads on one and only dimension).
Setting <code class="reqn">c_i=0</code>, <code class="reqn">d_i=1</code> and  <code class="reqn">a_i=1</code> for all items <code class="reqn">i</code>,
an additive item response model
</p>
<p style="text-align: center;"><code class="reqn">P( X_{pi}=1 | \theta_p )=g_{\alpha_1, \alpha_2} ( \theta_p - b_i  ) </code>
</p>

<p>is estimated.
</p>
<p>Ramsay's quotient model (<code>irtmodel="qm.ramsay"</code>) uses
the item response function
</p>
<p style="text-align: center;"><code class="reqn">P( X_{pi}=1 | \theta_p )=\frac{ \exp(\theta_p / b_i)}
    { K_i + \exp (\theta_p / b_i )} </code>
</p>

<p>Quite general unidimensional item response models can be estimated
in a nonparametric framework (<code>irtmodel="npirt"</code>). The response
functions are a linear combination of transformed <code class="reqn">\theta</code>
values
</p>
<p style="text-align: center;"><code class="reqn">logit[ P( X_{pi}=1 | \theta_p ) ]=Y_\theta \beta </code>
</p>

<p>Where <code class="reqn">Y_\theta</code> is a design matrix of <code class="reqn">\theta</code> and
<code class="reqn">\beta</code> are item parameters to be estimated.
The formula <code class="reqn">Y_\theta \beta</code> can be specified in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> formula
framework (see Example 3, Model 3c).
</p>
<p>Pseudo-likelihood estimation can be conducted for fractional item response data
as input (i.e. some item response <code class="reqn">x_{pi}</code> do have values
between 0 and 1). Then the pseudo-likelihood <code class="reqn">L_p</code> for person <code class="reqn">p</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn"> L_p=\prod_i P_i ( \theta_p )^{x_{pi}} [1-P_i ( \theta_p )]^{(1-x_{pi})}</code>
</p>

<p>Note that for dichotomous responses this term corresponds to the ordinary
likelihood. See Example 7.
</p>
<p>A special two-dimensional missing data item response model (<code>irtmodel="missing1"</code>)
is implemented according to Mislevy and Wu (1996).
Besides an unidimensional ability <code class="reqn">\theta_p</code>,
an individual response propensity <code class="reqn">\xi_p</code> is proposed. We define
item responses <code class="reqn">X_{pi}</code> and response indicators <code class="reqn">R_{pi}</code> indicating whether
item responses <code class="reqn">X_{pi}</code> are observed or not. Denoting the logistic function
by <code class="reqn">\Psi</code>, the item response model for ability is defined as
</p>
<p style="text-align: center;"><code class="reqn"> P( X_{pi}=1  | \theta_p, \xi_p )=P( X_{pi}=1 | \theta_p )
=\Psi( a_i (\theta_p - b_i ))</code>
</p>

<p>We also define a measurement model for response indicators <code class="reqn">R_{pi}</code> which depends
on the item response <code class="reqn">X_{pi}</code> itself:
</p>
<p style="text-align: center;"><code class="reqn">P( R_{pi}=1 | X_{pi}=k, \theta_p, \xi_p )=
    P( R_{pi}=1 | X_{pi}=k, \xi_p )=
\Psi \left[  \xi_p -  \beta_i - k \delta _i  \right] \quad \mbox{ for }
\quad k=0,1</code>
</p>

<p>If <code class="reqn">\delta _i=0</code>, then the probability of responding to an item is independent
of the incompletely observed item <code class="reqn">X_{pi}</code> which is an
item response model with nonignorable missings (Holman &amp; Glas, 2005;
see also Pohl, Graefe &amp; Rose, 2014).
If <code class="reqn">\delta _i</code> is a large negative number (e.g. <code class="reqn">\delta=-100</code>), then
it follows <code class="reqn">P( R_{pi}=1 | X_{pi}=1, \theta_p, \xi_p )=1</code>
and as a consequence it holds that <code class="reqn">P(X_{pi}=1 | R_{pi}=0, \theta_p, \xi_p)=0</code>,
which is equivalent to treating
all missing item responses as incorrect. The missingness parameter
<code class="reqn">\delta</code> can be specified
by the user and studied as a sensitivity analysis under different
missing not at random assumptions or can be estimated by choosing
<code>est.delta=TRUE</code>.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>Original data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Estimated item parameters in the generalized
item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item2</code></td>
<td>
<p>Estimated item parameters for Ramsay's quotient model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait.distr</code></td>
<td>
<p>Discretized ability distribution points and probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.trait</code></td>
<td>
<p>Estimated mean vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.trait</code></td>
<td>
<p>Estimated standard deviations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skewness.trait</code></td>
<td>
<p>Estimated skewnesses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pjk</code></td>
<td>
<p>Estimated probabilities of item correct evaluated at <code>theta.k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rprobs</code></td>
<td>
<p>Item response probabilities like in <code>pjk</code>, but slightly
extended to accommodate all categories</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>Person parameter estimates: mode (<code>MAP</code>) and
mean (<code>EAP</code>) of the posterior distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>
<p>Person identifier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ability.est.pattern</code></td>
<td>
<p>Response pattern estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.qk.yi</code></td>
<td>
<p>Individual posterior distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.yi.qk</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.a</code></td>
<td>
<p>Estimated <code class="reqn">a</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.c</code></td>
<td>
<p>Estimated <code class="reqn">c</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Number of groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>
<p>Estimated <code class="reqn">\alpha_1</code> parameter in generalized logistic
item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha2</code></td>
<td>
<p>Estimated <code class="reqn">\alpha_2</code> parameter in generalized logistic
item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.b</code></td>
<td>
<p>Standard error of <code class="reqn">b</code> parameter in generalized logistic model
or Ramsay's quotient model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.a</code></td>
<td>
<p>Standard error of <code class="reqn">a</code> parameter in generalized logistic model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.c</code></td>
<td>
<p>Standard error of <code class="reqn">c</code> parameter in generalized logistic model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.d</code></td>
<td>
<p>Standard error of <code class="reqn">d</code> parameter in generalized logistic model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.alpha</code></td>
<td>
<p>Standard error of <code class="reqn">\alpha</code> parameter in generalized
logistic model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.K</code></td>
<td>
<p>Standard error of <code class="reqn">K</code> parameter in Ramsay's quotient model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reliability</code></td>
<td>
<p>EAP reliability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irtmodel</code></td>
<td>
<p>Type of estimated item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Number of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Mean vector (for multidimensional models)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma.cov</code></td>
<td>
<p>Covariance matrix (for multdimensional models)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>
<p>Grid of discretized ability distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait.weights</code></td>
<td>
<p>Fixed vector of probabilities for the ability distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.k</code></td>
<td>
<p>Trait distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>esttype</code></td>
<td>
<p>Estimation type: <code>ll</code> (Log-Likelihood),
<code>pseudoll</code> (Pseudo-Log-Likelihood)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Multiple group estimation is not possible for
Ramsay's quotient model and multdimensional models.
</p>


<h3>References</h3>

<p>Holman, R., &amp; Glas, C. A. (2005). Modelling non-ignorable missing-data mechanisms
with item response theory models.
<em>British Journal of Mathematical and Statistical Psychology, 58</em>(1), 1-17.
<a href="https://doi.org/10.1348/000711005X47168">doi:10.1348/000711005X47168</a>
</p>
<p>Loken, E., &amp; Rulison, K. L. (2010). Estimation of a four-parameter
item response theory model. <em>British Journal of Mathematical
and Statistical Psychology, 63</em>(3), 509-525.
<a href="https://doi.org/10.1348/000711009X474502">doi:10.1348/000711009X474502</a>
</p>
<p>Mislevy, R. J., &amp; Wu, P. K. (1996). <em>Missing responses and IRT ability
estimation: Omits, choice, time Limits, and adaptive testing</em>.
ETS Research Report ETS RR-96-30. Princeton, ETS.
<a href="https://doi.org/10.1002/j.2333-8504.1996.tb01708.x">doi:10.1002/j.2333-8504.1996.tb01708.x</a>
</p>
<p>Pohl, S., Graefe, L., &amp; Rose, N. (2014). Dealing with omitted and
not-reached items in competence tests evaluating approaches accounting for
missing responses in item response theory models.
<em>Educational and Psychological Measurement, 74</em>(3), 423-452.
<a href="https://doi.org/10.1177/0013164413504926">doi:10.1177/0013164413504926</a>
</p>
<p>Ramsay, J. O. (1989). A comparison of three simple test theory models.
<em>Psychometrika, 54</em>, 487-499.
<a href="https://doi.org/10.1007/BF02294631">doi:10.1007/BF02294631</a>
</p>
<p>Rossi, N., Wang, X., &amp; Ramsay, J. O. (2002). Nonparametric item response
function estimates with the EM algorithm.
<em>Journal of Educational and Behavioral Statistics, 27</em>(3), 291-317.
<a href="https://doi.org/10.3102/10769986027003291">doi:10.3102/10769986027003291</a>
</p>
<p>Stukel, T. A. (1988). Generalized logistic models.
<em>Journal of the American Statistical Association, 83</em>(402), 426-431.
<a href="https://doi.org/10.1080/01621459.1988.10478613">doi:10.1080/01621459.1988.10478613</a>
</p>
<p>van der Maas, H. J. L., Molenaar, D., Maris, G., Kievit, R. A., &amp;
Borsboom, D. (2011).
Cognitive psychology meets psychometric theory: On the relation between
process models for decision making and latent variable models for
individual differences.
<em>Psychological Review, 118</em>(2), 339-356.
doi: 10.1037/a0022749
</p>


<h3>See Also</h3>

<p>Simulate the generalized logistic Rasch model with <code>sim.raschtype</code>.
</p>
<p>Simulate Ramsay's quotient model with <code>sim.qm.ramsay</code>.
</p>
<p>Simulate locally dependent item response data using <code>sim.rasch.dep</code>.
</p>
<p>For an assessment of global model fit see <code>modelfit.sirt</code>.
</p>
<p>See <code>CDM::itemfit.sx2</code> for item fit
statistics.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Reading dataset
#############################################################################

library(CDM)
data(data.read)
dat &lt;- data.read
I &lt;- ncol(dat) # number of items

# Rasch model
mod1 &lt;- sirt::rasch.mml2( dat )
summary(mod1)
plot( mod1 )    # plot all items
# title 'Rasch model', display curves from -3 to 3 only for items 1, 5 and 8
plot(mod1, main="Rasch model Items 1, 5 and 8", xlim=c(-3,3), items=c(1,5,8) )

# Rasch model with constraints on item difficulties
# set item parameters of A1 and C3 equal to -2
constraints &lt;- data.frame( c("A1","C3"), c(-2,-2) )
mod1a &lt;- sirt::rasch.mml2( dat, constraints=constraints)
summary(mod1a)

# estimate equal item parameters for 1st and 11th item
est.b &lt;- 1:I
est.b[11] &lt;- 1
mod1b &lt;- sirt::rasch.mml2( dat, est.b=est.b )
summary(mod1b)

# estimate Rasch model with skew trait distribution
mod1c &lt;- sirt::rasch.mml2( dat, distribution.trait="smooth3")
summary(mod1c)

# 2PL model
mod2 &lt;- sirt::rasch.mml2( dat, est.a=1:I )
summary(mod2)
plot(mod2)    # plot 2PL item response curves

# extract individual likelihood
llmod2 &lt;- IRT.likelihood(mod2)
str(llmod2)

## Not run: 
library(CDM)
# model comparisons
CDM::IRT.compareModels(mod1, mod1c, mod2 )
anova(mod1,mod2)

# assess model fit
smod1 &lt;- IRT.modelfit(mod1)
smod2 &lt;- IRT.modelfit(mod2)
IRT.compareModels(smod1, smod2)

# set some bounds for a and b parameters
mod2a &lt;- sirt::rasch.mml2( dat, est.a=1:I, min.a=.7, max.a=2, min.b=-2 )
summary(mod2a)

# 3PL model
mod3 &lt;- sirt::rasch.mml2( dat, est.a=1:I, est.c=1:I,
              mmliter=400 # maximal 400 iterations
                 )
summary(mod3)

# 3PL model with fixed guessing paramters of .25 and equal slopes
mod4 &lt;- sirt::rasch.mml2( dat, fixed.c=rep( .25, I )   )
summary(mod4)

# 3PL model with equal guessing paramters for all items
mod5 &lt;- sirt::rasch.mml2( dat, est.c=rep(1, I )   )
summary(mod5)

# difficulty + guessing model
mod6 &lt;- sirt::rasch.mml2( dat, est.c=1:I   )
summary(mod6)

# 4PL model
mod7 &lt;- sirt::rasch.mml2( dat, est.a=1:I, est.c=1:I, est.d=1:I,
            min.d=.95, max.c=.25)
        # set minimal d and maximal c parameter to .95 and .25
summary(mod7)

# 4PL model with prior distributions
mod7b &lt;- sirt::rasch.mml2( dat, est.a=1:I, est.c=1:I, est.d=1:I, prior.a=c(1,2),
            prior.c=c(5,17), prior.d=c(20,2) )
summary(mod7b)

# constrained 4PL model
# equal slope, guessing and slipping parameters
mod8 &lt;- sirt::rasch.mml2( dat,est.c=rep(1,I), est.d=rep(1,I) )
summary(mod8)

# estimation of an item response model with an
# uniform theta distribution
theta.k &lt;- seq( 0.01, .99, len=20 )
trait.weights &lt;- rep( 1/length(theta.k), length(theta.k) )
mod9 &lt;- sirt::rasch.mml2( dat, theta.k=theta.k, trait.weights=trait.weights,
              normal.trait=FALSE, est.a=1:12  )
summary(mod9)

#############################################################################
# EXAMPLE 2: Longitudinal data
#############################################################################

data(data.long)
dat &lt;- data.long[,-1]

# define Q loading matrix
Qmatrix &lt;- matrix( 0, 12, 2 )
Qmatrix[1:6,1] &lt;- 1 # T1 items
Qmatrix[7:12,2] &lt;- 1    # T2 items

# define restrictions on item difficulties
est.b &lt;- c(1,2,3,4,5,6,   3,4,5,6,7,8)
mu.fixed &lt;- cbind(1,0)
    # set first mean to 0 for identification reasons

# Model 1: 2-dimensional Rasch model
mod1 &lt;- sirt::rasch.mml2( dat, Qmatrix=Qmatrix, miterstep=4,
            est.b=est.b,  mu.fixed=mu.fixed, mmliter=30 )
summary(mod1)
plot(mod1)
##     Plot function is only applicable for unidimensional models

## End(Not run)

#############################################################################
# EXAMPLE 3: One group, estimation of alpha parameter in the generalized logistic model
#############################################################################

# simulate theta values
set.seed(786)
N &lt;- 1000                  # number of persons
theta &lt;- stats::rnorm( N, sd=1.5 ) # N persons with SD 1.5
b &lt;- seq( -2, 2, len=15)

# simulate data
dat &lt;- sirt::sim.raschtype( theta=theta, b=b, alpha1=0, alpha2=-0.3 )

#  estimating alpha parameters
mod1 &lt;- sirt::rasch.mml2( dat, est.alpha=TRUE, mmliter=30 )
summary(mod1)
plot(mod1)

## Not run: 
# fixed alpha parameters
mod1b &lt;- sirt::rasch.mml2( dat, est.alpha=FALSE, alpha1=0, alpha2=-.3 )
summary(mod1b)

# estimation with equal alpha parameters
mod1c &lt;- sirt::rasch.mml2( dat, est.alpha=TRUE, equal.alpha=TRUE )
summary(mod1c)

# Ramsay QM
mod2a &lt;- sirt::rasch.mml2( dat, irtmodel="ramsay.qm" )
summary(mod2a)

## End(Not run)

# Ramsay QM with estimated K parameters
mod2b &lt;- sirt::rasch.mml2( dat, irtmodel="ramsay.qm", est.K=1:15, mmliter=30)
summary(mod2b)
plot(mod2b)

## Not run: 
# nonparametric estimation of monotone item response curves
mod3a &lt;- sirt::rasch.mml2( dat, irtmodel="npirt", mmliter=100,
            theta.k=seq( -3, 3, len=10) ) # evaluations at 10 theta grid points
# nonparametric ICC of first 4 items
round( t(mod3a$pjk)[1:4,], 3 )
summary(mod3a)
plot(mod3a)

# nonparametric IRT estimation without monotonicity assumption
mod3b &lt;- sirt::rasch.mml2( dat, irtmodel="npirt", mmliter=10,
            theta.k=seq( -3, 3, len=10), npirt.monotone=FALSE)
plot(mod3b)

# B-Spline estimation of ICCs
library(splines)
mod3c &lt;- sirt::rasch.mml2( dat, irtmodel="npirt",
             npformula="y~bs(theta,df=3)", theta.k=seq(-3,3,len=15) )
summary(mod3c)
round( t(mod3c$pjk)[1:6,], 3 )
plot(mod3c)

# estimation of quadratic item response functions: ~ theta + I( theta^2)
mod3d &lt;- sirt::rasch.mml2( dat, irtmodel="npirt",
             npformula="y~theta + I(theta^2)" )
summary(mod3d)
plot(mod3d)

# estimation of a stepwise ICC function
# ICCs are constant on the theta domains: [-Inf,-1], [-1,1], [1,Inf]
mod3e &lt;- sirt::rasch.mml2( dat, irtmodel="npirt",
             npformula="y~I(theta&gt;-1 )+I(theta&gt;1)" )
summary(mod3e)
plot(mod3e, xlim=c(-2.5,2.5) )

# 2PL model
mod4 &lt;- sirt::rasch.mml2( dat,  est.a=1:15)
summary(mod4)

#############################################################################
# EXAMPLE 4: Two groups, estimation of generalized logistic model
#############################################################################

# simulate generalized logistic Rasch model in two groups
set.seed(8765)
N1 &lt;- 1000     # N1=1000 persons in group 1
N2 &lt;- 500      # N2=500 persons in group 2
dat1 &lt;- sirt::sim.raschtype( theta=stats::rnorm( N1, sd=1.5 ), b=b,
            alpha1=-0.3, alpha2=0)
dat2 &lt;- sirt::sim.raschtype( theta=stats::rnorm( N2, mean=-.5, sd=.75),
            b=b, alpha1=-0.3, alpha2=0)
dat1 &lt;- rbind( dat1, dat2 )
group &lt;- c( rep(1,N1), rep(2,N2))

mod1 &lt;-  sirt::rasch.mml2( dat1, parm.conv=.0001, group=group, est.alpha=TRUE )
summary(mod1)

#############################################################################
# EXAMPLE 5: Multidimensional model
#############################################################################

#***
# (1) simulate data
set.seed(785)
library(mvtnorm)
N &lt;- 500
theta &lt;- mvtnorm::rmvnorm( N,mean=c(0,0), sigma=matrix( c(1.45,.5,.5,1.7), 2, 2 ))
I &lt;- 10
# 10 items load on the first dimension
p1 &lt;- stats::plogis( outer( theta[,1], seq( -2, 2, len=I ), "-" ) )
resp1 &lt;- 1 * ( p1 &gt; matrix( stats::runif( N*I ), nrow=N, ncol=I ) )
# 10 items load on the second dimension
p1 &lt;- stats::plogis( outer( theta[,2], seq( -2, 2, len=I ), "-" ) )
resp2 &lt;- 1 * ( p1 &gt; matrix( stats::runif( N*I ), nrow=N, ncol=I ) )
#Combine the two sets of items into one response matrix
resp &lt;- cbind(resp1,resp2)
colnames(resp) &lt;- paste("I", 1:(2*I), sep="")
dat &lt;- resp

# define Q-matrix
Qmatrix &lt;- matrix( 0, 2*I, 2 )
Qmatrix[1:I,1] &lt;- 1
Qmatrix[1:I+I,2] &lt;- 1

#***
# (2) estimation of models
# 2-dimensional Rasch model
mod1 &lt;- sirt::rasch.mml2( dat, Qmatrix=Qmatrix )
summary(mod1)

# 2-dimensional 2PL model
mod2 &lt;- sirt::rasch.mml2( dat, Qmatrix=Qmatrix, est.a=1:(2*I) )
summary(mod2)

# estimation with some fixed variances and covariances
# set variance of 1st dimension to 1 and
#  covariance to zero
variance.fixed &lt;- matrix( cbind(c(1,1), c(1,2), c(1,0)),
             byrow=FALSE, ncol=3 )
mod3 &lt;- sirt::rasch.mml2( dat, Qmatrix=Qmatrix, variance.fixed=variance.fixed )
summary(mod3)

# constraints on item difficulties
#  useful for example in longitudinal linking
est.b &lt;- c( 1:I, 1:I )
    # equal indices correspond to equally estimated item parameters
mu.fixed &lt;- cbind( 1, 0 )
mod4 &lt;- sirt::rasch.mml2( dat, Qmatrix=Qmatrix, est.b=est.b, mu.fixed=mu.fixed )
summary(mod4)

#############################################################################
# EXAMPLE 6: Two booklets with same items but with item context effects.
# Therefore, item slopes and item difficulties are assumed to be shifted in the
# second design group.
#############################################################################

#***
# simulate data
set.seed(987)
I &lt;- 10     # number of items
# define person design groups 1 and 2
n1 &lt;- 700
n2 &lt;- 1500
# item difficulties group 1
b1 &lt;- seq(-1.5,1.5,length=I)
# item slopes group 1
a1 &lt;- rep(1, I)
# simulate data group 1
dat1 &lt;- sirt::sim.raschtype( stats::rnorm(n1), b=b1, fixed.a=a1 )
colnames(dat1) &lt;- paste0("I", 1:I, "des1" )
# group 2
b2 &lt;- b1 - .15
a2 &lt;- 1.1*a1
# Item parameters are slightly transformed in the second group
# compared to the first group. This indicates possible item context effects.

# simulate data group 2
dat2 &lt;- sirt::sim.raschtype( stats::rnorm(n2), b=b2, fixed.a=a2 )
colnames(dat2) &lt;- paste0("I", 1:I, "des2" )
# define joint dataset
dat &lt;- matrix( NA, nrow=n1+n2, ncol=2*I)
colnames(dat) &lt;- c( colnames(dat1), colnames(dat2) )
dat[ 1:n1, 1:I ] &lt;- dat1
dat[ n1 + 1:n2, I + 1:I ] &lt;- dat2
# define group identifier
group &lt;- c( rep(1,n1), rep(2,n2) )

#***
# Model 1: Rasch model two groups
itemindex &lt;- rep( 1:I, 2 )
mod1 &lt;- sirt::rasch.mml2( dat, group=group, est.b=itemindex )
summary(mod1)

#***
# Model 2: two item slope groups and designmatrix for intercepts
designmatrix &lt;- matrix( 0, 2*I, I+1)
designmatrix[ ( 1:I )+ I,1:I] &lt;- designmatrix[1:I,1:I] &lt;- diag(I)
designmatrix[ ( 1:I )+ I,I+1] &lt;- 1
mod2 &lt;- sirt::rasch.mml2( dat, est.a=rep(1:2,each=I), designmatrix=designmatrix )
summary(mod2)

#############################################################################
# EXAMPLE 7: PIRLS dataset with missing responses
#############################################################################

data(data.pirlsmissing)
items &lt;- grep( "R31", colnames(data.pirlsmissing), value=TRUE )
I &lt;- length(items)
dat &lt;- data.pirlsmissing

#****
# Model 1: recode missing responses as missing (missing are ignorable)

# data recoding
dat1 &lt;- dat
dat1[ dat1==9 ] &lt;- NA
# estimate Rasch model
mod1 &lt;- sirt::rasch.mml2( dat1[,items], weights=dat$studwgt, group=dat$country )
summary(mod1)
##   Mean=0 0.341 -0.134 0.219
##   SD=1.142 1.166 1.197 0.959

#****
# Model 2: recode missing responses as wrong

# data recoding
dat2 &lt;- dat
dat2[ dat2==9 ] &lt;- 0
# estimate Rasch model
mod2 &lt;- sirt::rasch.mml2( dat2[,items], weights=dat$studwgt, group=dat$country )
summary(mod2)
  ##   Mean=0 0.413 -0.172 0.446
  ##   SD=1.199 1.263 1.32 0.996

#****
# Model 3: recode missing responses as rho * P_i( theta ) and
#          apply pseudo-log-likelihood estimation
# Missing item responses are predicted by the model implied probability
# P_i( theta ) where theta is the ability estimate when ignoring missings (Model 1)
# and rho is an adjustment parameter. rho=0 is equivalent to Model 2 (treating
# missing as wrong) and rho=1 is equivalent to Model 1 (treating missing as ignorable).

# data recoding
dat3 &lt;- dat
# simulate theta estimate from posterior distribution
theta &lt;- stats::rnorm( nrow(dat3), mean=mod1$person$EAP, sd=mod1$person$SE.EAP )
rho &lt;- .3   # define a rho parameter value of .3
for (ii in items){
    ind &lt;- which( dat[,ii]==9 )
    dat3[ind,ii] &lt;- rho*stats::plogis( theta[ind] - mod1$item$b[ which( items==ii ) ] )
                }

# estimate Rasch model
mod3 &lt;- sirt::rasch.mml2( dat3[,items], weights=dat$studwgt, group=dat$country )
summary(mod3)
  ##   Mean=0 0.392 -0.153 0.38
  ##   SD=1.154 1.209 1.246 0.973

#****
# Model 4: simulate missing responses as rho * P_i( theta )
# The definition is the same as in Model 3. But it is now assumed
# that the missing responses are 'latent responses'.
set.seed(789)

# data recoding
dat4 &lt;- dat
# simulate theta estimate from posterior distribution
theta &lt;- stats::rnorm( nrow(dat4), mean=mod1$person$EAP, sd=mod1$person$SE.EAP )
rho &lt;- .3   # define a rho parameter value of .3
for (ii in items){
    ind &lt;- which( dat[,ii]==9 )
    p3 &lt;- rho*stats::plogis( theta[ind] - mod1$item$b[ which( items==ii ) ] )
    dat4[ ind, ii ] &lt;- 1*( stats::runif( length(ind), 0, 1 ) &lt; p3)
                }

# estimate Rasch model
mod4 &lt;- sirt::rasch.mml2( dat4[,items], weights=dat$studwgt, group=dat$country )
summary(mod4)
  ##   Mean=0 0.396 -0.156 0.382
  ##   SD=1.16 1.216 1.253 0.979

#****
# Model 5: recode missing responses for multiple choice items with four alternatives
#          to 1/4 and apply pseudo-log-likelihood estimation.
#          Missings for constructed response items are treated as incorrect.

# data recoding
dat5 &lt;- dat
items_mc &lt;- items[ substring( items, 7,7)=="M" ]
items_cr &lt;- items[ substring( items, 7,7)=="C" ]
for (ii in items_mc){
    ind &lt;- which( dat[,ii]==9 )
    dat5[ind,ii] &lt;- 1/4
                }
for (ii in items_cr){
    ind &lt;- which( dat[,ii]==9 )
    dat5[ind,ii] &lt;- 0
                }

# estimate Rasch model
mod5 &lt;- sirt::rasch.mml2( dat5[,items], weights=dat$studwgt, group=dat$country )
summary(mod5)
  ##   Mean=0 0.411 -0.165 0.435
  ##   SD=1.19 1.245 1.293 0.995

#*** For the following analyses, we ignore sample weights and the
#    country grouping.
data(data.pirlsmissing)
items &lt;- grep( "R31", colnames(data.pirlsmissing), value=TRUE )
dat &lt;- data.pirlsmissing
dat1 &lt;- dat
dat1[ dat1==9 ] &lt;- 0

#*** Model 6: estimate item difficulties assuming incorrect missing data treatment
mod6 &lt;- sirt::rasch.mml2( dat1[,items], mmliter=50 )
summary(mod6)

#*** Model 7: reestimate model with constrained item difficulties
I &lt;- length(items)
constraints &lt;- cbind( 1:I, mod6$item$b )
mod7 &lt;- sirt::rasch.mml2( dat1[,items], constraints=constraints)
summary(mod7)

#*** Model 8: score all missings responses as missing items
dat2 &lt;- dat[,items]
dat2[ dat2==9 ] &lt;- NA
mod8 &lt;- sirt::rasch.mml2( dat2, constraints=constraints, mu.fixed=NULL )
summary(mod8)

#*** Model 9: estimate missing data model 'missing1' assuming a missingness
#       parameter delta.miss of zero
dat2 &lt;-  dat[,items]    # note that missing item responses must be defined by 9
mod9 &lt;- sirt::rasch.mml2( dat2, constraints=constraints, irtmodel="missing1",
            theta.k=seq(-5,5,len=10), delta.miss=0, mitermax=4, mu.fixed=NULL )
summary(mod9)

#*** Model 10: estimate missing data model with a large negative missing delta parameter
#=&gt; This model is equivalent to treating missing responses as wrong
mod10 &lt;- sirt::rasch.mml2( dat2, constraints=constraints, irtmodel="missing1",
             theta.k=seq(-5, 5, len=10), delta.miss=-10, mitermax=4, mmliter=200,
             mu.fixed=NULL )
summary(mod10)

#*** Model 11: choose a missingness delta parameter of -1
mod11 &lt;- sirt::rasch.mml2( dat2, constraints=constraints, irtmodel="missing1",
             theta.k=seq(-5, 5, len=10), delta.miss=-1, mitermax=4,
             mmliter=200, mu.fixed=NULL )
summary(mod11)

#*** Model 12: estimate joint delta parameter
mod12 &lt;- sirt::rasch.mml2( dat2, irtmodel="missing1", mu.fixed=cbind( c(1,2), 0 ),
             theta.k=seq(-8, 8, len=10), delta.miss=0, mitermax=4,
             mmliter=30, est.delta=rep(1,I)  )
summary(mod12)

#*** Model 13: estimate delta parameter in item groups defined by item format
est.delta &lt;- 1 + 1 * ( substring( colnames(dat2),7,7 )=="M" )
mod13 &lt;- sirt::rasch.mml2( dat2, irtmodel="missing1", mu.fixed=cbind( c(1,2), 0 ),
             theta.k=seq(-8, 8, len=10), delta.miss=0, mitermax=4,
             mmliter=30, est.delta=est.delta  )
summary(mod13)

#*** Model 14: estimate item specific delta parameter
mod14 &lt;- sirt::rasch.mml2( dat2, irtmodel="missing1", mu.fixed=cbind( c(1,2), 0 ),
             theta.k=seq(-8, 8, len=10), delta.miss=0, mitermax=4,
             mmliter=30, est.delta=1:I  )
summary(mod14)

#############################################################################
# EXAMPLE 8: Comparison of different models for polytomous data
#############################################################################

data(data.Students, package="CDM")
head(data.Students)
dat &lt;- data.Students[, paste0("act",1:5) ]
I &lt;- ncol(dat)

#**************************************************
#*** Model 1: Partial Credit Model (PCM)

#*** Model 1a: PCM in TAM
mod1a &lt;- TAM::tam.mml( dat )
summary(mod1a)

#*** Model 1b: PCM in sirt
mod1b &lt;- sirt::rm.facets( dat )
summary(mod1b)

#*** Model 1c: PCM in mirt
mod1c &lt;- mirt::mirt( dat, 1, itemtype=rep("Rasch",I), verbose=TRUE )
print(mod1c)

#**************************************************
#*** Model 2: Sequential Model (SM): Equal Loadings

#*** Model 2a: SM in sirt
dat1 &lt;- CDM::sequential.items(dat)
resp &lt;- dat1$dat.expand
iteminfo &lt;- dat1$iteminfo
# fit model
mod2a &lt;- sirt::rasch.mml2( resp )
summary(mod2a)

#**************************************************
#*** Model 3: Sequential Model (SM): Different Loadings

#*** Model 3a: SM in sirt
mod3a &lt;- sirt::rasch.mml2( resp, est.a=iteminfo$itemindex )
summary(mod3a)

#**************************************************
#*** Model 4: Generalized partial credit model (GPCM)

#*** Model 4a: GPCM in TAM
mod4a &lt;- TAM::tam.mml.2pl( dat, irtmodel="GPCM")
summary(mod4a)

#**************************************************
#*** Model 5: Graded response model (GRM)

#*** Model 5a: GRM in mirt
mod5a &lt;- mirt::mirt( dat, 1, itemtype=rep("graded",I), verbose=TRUE)
print(mod5a)

# model comparison
logLik(mod1a);logLik(mod1b);mod1c@logLik  # PCM
logLik(mod2a)   # SM (Rasch)
logLik(mod3a)   # SM (GPCM)
logLik(mod4a)   # GPCM
mod5a@logLik    # GRM

## End(Not run)
</code></pre>


</div>