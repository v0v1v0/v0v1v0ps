<div class="container">

<table style="width: 100%;"><tr>
<td>predict.Sarlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction for spatial simultaneous autoregressive linear
model objects</h2>

<h3>Description</h3>

<p><code>predict.Sarlm()</code> calculates predictions as far as is at present possible for for spatial simultaneous autoregressive linear
model objects, using Haining's terminology for decomposition into
trend, signal, and noise, or other types of predictors — see references.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'Sarlm'
predict(object, newdata = NULL, listw = NULL, pred.type = "TS", all.data = FALSE,
 zero.policy = NULL, legacy = TRUE, legacy.mixed = FALSE, power = NULL, order = 250,
 tol = .Machine$double.eps^(3/5), spChk = NULL, ...)
#\method{predict}{SLX}(object, newdata, listw, zero.policy=NULL, ...)
## S3 method for class 'Sarlm.pred'
print(x, ...)
## S3 method for class 'Sarlm.pred'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>Sarlm</code> object returned by <code>lagsarlm</code>, 
<code>errorsarlm</code> or <code>sacsarlm</code>, the method for SLX objects takes the output of <code>lmSLX</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>data frame in which to predict — if NULL, predictions are
for the data on which the model was fitted. Should have row names corresponding to region.id. If row names are exactly the same than the ones used for training, it uses in-sample predictors for forecast.  See ‘Details’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>. In the out-of-sample prediction case (ie. if newdata is not NULL), if <code>legacy.mixed=FALSE</code> or if <code>pred.type!="TS"</code>, it should include both in-sample and out-of-sample spatial units. In this case, if regions of the listw are not in the correct order, they are reordered.  See ‘Details’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.type</code></td>
<td>
<p>predictor type — default “TS”, use decomposition into  
trend, signal, and noise ; other types available depending on <code>newdata</code>. If <code>newdata=NULL</code> (in-sample prediction), “TS”, “trend”, “TC” and “BP” are available. If <code>newdata</code> is not NULL and its row names are the same than the <code>data</code> used to fit the model (forecast case), “TS”, “trend” and “TC” are available. In other cases (out-of-sample prediction), “TS”, “trend”, “KP1”, “KP2”, “KP3”, “KP4”, “KP5”, “TC”, “BP”, “BPW”, “BPN”, “TS1”, “TC1”, “BP1”, “BPW1” and “BPN1” are available.  See ‘Details’ and references</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.data</code></td>
<td>
<p>(only applies to <code>pred.type="TC"</code> and newdata is not NULL) default FALSE: return predictions only for newdata units, if TRUE return predictions for all data units.  See ‘Details’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE (default) assign NA - causing the function to 
terminate with an error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legacy</code></td>
<td>
<p>(only applies to lag and Durbin (mixed) models for <code>pred.type="TS"</code>) default TRUE: use ad-hoc predictor, if FALSE use DGP-based predictor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legacy.mixed</code></td>
<td>
<p>(only applies to mixed models if newdata is not NULL) default FALSE: compute lagged variables from both in-sample and out-of-sample units with <code class="reqn">[W X]_O</code> and <code class="reqn">[W X]_S</code> where <code>X=cbind(Xs, Xo)</code>, if TRUE compute lagged variables independantly between in-sample and out-of-sample units with <code class="reqn">W_{OO} X_O</code> and <code class="reqn">W_{SS} X_S</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>(only applies to lag and Durbin (mixed) models for “TS”, “KP1”, “KP2”, “KP3”, “TC”, “TC1”, “BP”, “BP1”, “BPN”, “BPN1”, “BPW” and “BPW1” types) use <code>powerWeights</code>, if default NULL, set FALSE if <code>object$method</code> is “eigen”, otherwise TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>power series maximum limit if <code>power</code> is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for convergence of power series if <code>power</code> is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spChk</code></td>
<td>
<p>should the row names of data frames be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the object to be printed</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed through</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The function supports three types of prediction.  In-sample prediction is the computation of predictors on the data used to fit the model (<code>newdata=NULL</code>).  Prevision, also called forecast, is the computation of some predictors (“trend”, in-sample “TC” and out-of-sample “TS”) on the same spatial units than the ones used to fit the model, but with different observations of the variables in the model (row names of <code>newdata</code> should have the same row names than the data frame used to fit the model).  And out-of-sample prediction is the computation of predictors on other spatial units than the ones used to fit the model (<code>newdata</code> has different row names).  For extensive definitions, see Goulard et al. (2017). 
</p>
<p><code>pred.type</code> of predictors are available according to the model of <code>object</code> an to the type of prediction.  In the two following tables, “yes” means that the predictor can be used with the model, “no” means that <code>predict.Sarlm()</code> will stop with an error, and “yes*” means that the predictor is not designed for the specified model, but it can be used with <code>predict.Sarlm()</code>.  In the last case, be careful with the computation of a inappropriate predictor.
</p>
<p><em>In-sample predictors by models</em>
</p>

<table>
<tr>
<td style="text-align: left;">
  pred.type </td>
<td style="text-align: center;"> sem (mixed) </td>
<td style="text-align: center;"> lag (mixed) </td>
<td style="text-align: center;"> sac (mixed) </td>
</tr>
<tr>
<td style="text-align: left;">
        </td>
<td style="text-align: center;">     </td>
<td style="text-align: center;">  </td>
<td style="text-align: center;">  </td>
</tr>
<tr>
<td style="text-align: left;">
  “trend” </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “TS”   </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  no </td>
</tr>
<tr>
<td style="text-align: left;">
  “TC”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BP”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Note that only “trend” and “TC” are available for prevision.
</p>
<p><em>Out-of-sample predictors by models</em>
</p>

<table>
<tr>
<td style="text-align: left;">
  pred.type </td>
<td style="text-align: center;"> sem (mixed) </td>
<td style="text-align: center;"> lag (mixed) </td>
<td style="text-align: center;"> sac (mixed) </td>
</tr>
<tr>
<td style="text-align: left;">
        </td>
<td style="text-align: center;">     </td>
<td style="text-align: center;">  </td>
<td style="text-align: center;">  </td>
</tr>
<tr>
<td style="text-align: left;">
  “trend” </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “TS”   </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  no </td>
</tr>
<tr>
<td style="text-align: left;">
  “TS1” or “KP4”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “TC”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “TC1” or “KP1”  </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “BP”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BP1”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BPW”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BPW1”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BN”     </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “BPN1”   </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
  “KP2”   </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “KP3”   </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  yes </td>
</tr>
<tr>
<td style="text-align: left;">
  “KP5”   </td>
<td style="text-align: center;">  yes </td>
<td style="text-align: center;">  no </td>
<td style="text-align: center;">  yes* </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Values for <code>pred.type=</code> include “TS1”, “TC”, “TC1”, “BP”, “BP1”, “BPW”, “BPW1”, “BPN”, “BPN1”, following the notation in Goulard et al. (2017), and for <code>pred.type=</code> “KP1”, “KP2”, “KP3”, “KP4”, “KP5”, following the notation in Kelejian et al. (2007).  <code>pred.type="TS"</code> is described bellow and in Bivand (2002).  
</p>
<p>In the following, the trend is the non-spatial smooth, the signal is the
spatial smooth, and the noise is the residual.  The fit returned by <code>pred.type="TS"</code> is the
sum of the trend and the signal.  
</p>
<p>When <code>pred.type="TS"</code>, the function approaches prediction first by dividing invocations between 
those with or without newdata.  When no newdata is present, the response 
variable may be reconstructed as the sum of the trend, the signal, and the
noise (residuals).  Since the values of the response variable are known,
their spatial lags are used to calculate signal components (Cressie 1993, p. 564).  For the error
model, trend = <code class="reqn">X \beta</code>, and signal = <code class="reqn">\lambda W y - 
\lambda W X \beta</code>. For the lag and mixed
models, trend = <code class="reqn">X \beta</code>, and signal = <code class="reqn">\rho W y</code>.
</p>
<p>This approach differs from the design choices made in other software, for
example GeoDa, which does not use observations of the response variable,
and corresponds to the newdata situation described below.  
</p>
<p>When however newdata is used for prediction, no observations of the response 
variable being predicted are available.  Consequently, while the trend
components are the same, the signal cannot take full account of the spatial
smooth.  In the error model and Durbin error model, the signal is set to zero, since the spatial smooth is expressed in terms of the error: 
<code class="reqn">(I - \lambda W)^{-1} \varepsilon</code>.
</p>
<p>In the lag model, the signal can be expressed in the following way (for legacy=TRUE):
</p>
<p style="text-align: center;"><code class="reqn">(I - \rho W) y = X \beta + \varepsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">y = (I - \rho W)^{-1} X \beta + (I - \rho W)^{-1} \varepsilon</code>
</p>

<p>giving a feasible signal component of:
</p>
<p style="text-align: center;"><code class="reqn">\rho W y = \rho W (I - \rho W)^{-1} X \beta</code>
</p>

<p>For legacy=FALSE, the trend is computed first as:
</p>
<p style="text-align: center;"><code class="reqn">X \beta</code>
</p>

<p>next the prediction using the DGP:
</p>
<p style="text-align: center;"><code class="reqn">(I - \rho W)^{-1} X \beta</code>
</p>

<p>and the signal is found as the difference between prediction and trend. The numerical results for the legacy and DGP methods are identical.  
</p>

<p>setting the error term to zero.  This also means that predictions of the
signal component for lag and mixed models require the inversion of an 
n-by-n matrix.  
</p>
<p>Because the outcomes of the spatial smooth on the error term are
unobservable, this means that the signal values for newdata are
incomplete.  In the mixed model, the spatially lagged RHS variables
influence both the trend and the signal, so that the root mean square
prediction error in the examples below for this case with newdata is
smallest, although the model was not the best fit.  
</p>
<p>If <code>newdata</code> has more than one row, leave-one-out predictors (<code>pred.type=</code> include “TS1”, “TC1”, “BP1”, “BPW1”, “BPN1”, “KP1”, “KP2”, “KP3”, “KP4”, “KP5”) are computed separatly on each out-of-sample unit.  
</p>
<p><code>listw</code> should be provided except if <code>newdata=NULL</code> and <code>pred.type=</code> include “TS”, “trend”, or if <code>newdata</code> is not <code>NULL</code>, <code>pred.type="trend"</code> and <code>object</code> is not a mixed model.  
</p>
<p><code>all.data</code> is useful when some out-of-sample predictors return different predictions for in-sample units, than the same predictor type computed only on in-sample data.  
</p>


<h3>Value</h3>

<p><code>predict.Sarlm()</code> returns a vector of predictions with three attribute 
vectors of trend, signal (only for <code>pred.type="TS"</code>) and region.id values and two other attributes
of pred.type and call with class <code>Sarlm.pred</code>. 
</p>
<p><code>print.Sarlm.pred()</code> is a print function for this class, printing and
returning a data frame with columns: "fit", "trend" and "signal" (when available) and with region.id as row names.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Martin Gubri</p>


<h3>References</h3>

<p>Haining, R. 1990 <em>Spatial data analysis in the social and environmental sciences</em>, Cambridge: Cambridge University Press, p. 258; Cressie, N. A. C. 1993 <em>Statistics for spatial data</em>, Wiley, New York; Michel Goulard, Thibault Laurent &amp; Christine Thomas-Agnan, 2017 <em>About predictions in spatial autoregressive models: optimal and almost optimal strategies</em>,  Spatial Economic Analysis Volume 12, Issue 2–3, 304–325 <a href="https://doi.org/10.1080/17421772.2017.1300679">doi:10.1080/17421772.2017.1300679</a>, ; Kelejian, H. H. and Prucha, I. R. 2007 <em>The relative efficiencies of various predictors in spatial econometric models containing spatial lags</em>, Regional Science and Urban Economics, Volume 37, Issue 3, 363–374; Bivand, R. 2002 <em>Spatial econometrics functions in R: Classes and methods</em>, Journal of Geographical Systems, Volume 4, No. 4, 405–421</p>


<h3>See Also</h3>

<p><code>errorsarlm</code>, <code>lagsarlm</code>, <code>sacsarlm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(oldcol, package="spdep")
lw &lt;- spdep::nb2listw(COL.nb)
COL.lag.eig &lt;- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw)

COL.mix.eig &lt;- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,
  type="mixed")
print(p1 &lt;- predict(COL.mix.eig))
print(p2 &lt;- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = "TS",
 legacy.mixed = TRUE))
AIC(COL.mix.eig)
sqrt(deviance(COL.mix.eig)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(p1))^2)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(p2))^2)/length(COL.nb))

COL.err.eig &lt;- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw)
AIC(COL.err.eig)
sqrt(deviance(COL.err.eig)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig)))^2)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig, newdata=COL.OLD,
  listw=lw, pred.type = "TS")))^2)/length(COL.nb))

COL.SDerr.eig &lt;- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,
 etype="emixed")
AIC(COL.SDerr.eig)
sqrt(deviance(COL.SDerr.eig)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig)))^2)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig, newdata=COL.OLD,
  listw=lw, pred.type = "TS")))^2)/length(COL.nb))

AIC(COL.lag.eig)
sqrt(deviance(COL.lag.eig)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig)))^2)/length(COL.nb))
sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig, newdata=COL.OLD,
  listw=lw, pred.type = "TS")))^2)/length(COL.nb))

p3 &lt;- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = "TS",
 legacy=FALSE, legacy.mixed = TRUE)
all.equal(p2, p3, check.attributes=FALSE)
p4 &lt;- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = "TS",
 legacy=FALSE, power=TRUE, legacy.mixed = TRUE)
all.equal(p2, p4, check.attributes=FALSE)
p5 &lt;- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = "TS",
 legacy=TRUE, power=TRUE, legacy.mixed = TRUE)
all.equal(p2, p5, check.attributes=FALSE)
</code></pre>


</div>