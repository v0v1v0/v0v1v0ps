<div class="container">

<table style="width: 100%;"><tr>
<td>corrFamily</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Using corrFamily constructors and descriptors.
</h2>

<h3>Description</h3>

<p>One can declare and fit correlated random effects belonging to a user-defined correlation (or covariance) model (i.e., a parametric family of correlation matrices, although degenerate case with no parameter are also possible). This documentation is a first introduction to this feature. It is experimental in the sense that its design has been formalized only from a limited number of corrFamily examples, and that the documentation is not mature. Implementing prediction for random-effects defined in this way may be tricky. A distinct documentation <code>corrFamily-design</code> provides more information for the efficient design of new correlation models to be fitted in this way.  
</p>
<p>A simple example of random-effect model implemented in this way is the autoregressive model of order <code class="reqn">p</code> (AR(p) in the literature; specifically documented elsewhere, see <code>ARp</code>). It can be used as a formula term like other autocorrelated random-effects predefined in <span class="pkg">spaMM</span>, to be fitted by <code>fitme</code>
or <code>fitmv</code>:
</p>
<pre>
fitme(lh ~ 1 + ARp(1|time, p=3),  # &lt;= declaration of random effect
  &lt; data and other possible arguments &gt;)
</pre>
<p>User-defined correlation models should be registered for this simple syntax to work (see Details for an alternative syntax):  
</p>
<pre>
myARp &lt;- ARp                   # 'myARP' is thus a user-defined model
register_cF("myARp")        # Register it so that the next call works
fitme(lh ~ 1 + myARp(1|time, p=3),  
  &lt; data and other possible arguments &gt;)
</pre>
<p>The <code>ARp</code> object here copied in <code>myARp</code> is a function (the <em>corrFamily constructor</em>) which returns a <code>list</code> (the <em>corrFamily descriptor</em>) which contains the necessary information to fit a random effect with an AR(p) correlation. The <code>p</code> argument in the <code>myARp(1|time, p=3)</code> term enforces evaluation of <code>myARp(p=3)</code>, producing the descriptor for the AR(3) model. The structure of this descriptor is 
</p>
<pre>
List of 5
 $ Cf            :function (parvec)  
  ..- &lt; with some attribute &gt;
 $ tpar         : num [1:3] 0.5 0.333 0.25
 $ type         : chr "precision"
 $ initialize   :function (Zmatrix, ...) 
  ..- &lt; with some attribute &gt;
 $ fixed        : NULL
 $ calc_moreargs:function (corrfamily, ...)  
  ..- &lt; with some attribute &gt;
 $ levels_type        : chr "time_series"
 $ calc_corr_from_dist:function (ranFix, char_rd, distmat, ...)  
  ..- &lt; with some attribute &gt;
 &lt; and possibly other elements &gt; 
</pre>
<p>The meaning of these elements and some additional ones is explained below. 
</p>
<p>Only <code>Cf</code> and <code>tpar</code> are necessary elements of a corrFamily object. If one designs a new descriptor where some other elements are absent, <span class="pkg">spaMM</span> will try to provide plausible defaults for these elements. Further, if the descriptor does not provide parameter names (as the names of <code>tpar</code>, or in some more cryptic way), default names <code>"p1"</code>, <code>"p2"</code>... will be provided.    
</p>


<h3>Usage</h3>

<pre><code class="language-R">## corrFamily descriptor provided as a list of the form
#
# list(Cf=&lt;.&gt;, tpar=&lt;.&gt;, ...)

## corrFamily constructor: any function that returns 
#    a valid corrFamily descriptor
#
# function(tpar=&lt;.&gt;, fixed=&lt;.&gt;, ...) # typical but not mandatory arguments

## There is a distinct documentation page for 'register_cF'.
</code></pre>


<h3>Arguments</h3>

<p><b><em>Elements</em> of the corrFamily <em>descriptor</em></b>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Cf</code></td>
<td>
<p>(required): function returning the correlation matrix (or covariance matrix, or their inverse), given its first argument, a parameter vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tpar</code></td>
<td>
<p>(required): a feasible argument of <code>Cf</code>. <code>tpar</code> is <b>not</b> an initial <b>nor</b> a fixed value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>optional, but required if the return value of <code>Cf</code> is an inverse correlation matrix rather than a correlation matrix, in which case one should specify <code>type="precision"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>optional: fixed values for some correlation parameters, provided as a named vector with names consistent with those to be used for <code>tpar</code>. This is conceived to achieve the same statistical fit as by using the <code>fixed</code> argument of <code>fitme</code>, although the structure of the result of the fit differs in some subtle ways whether parameters are fixed through the descriptor or through the fitting function (see Examples in <code>ARp</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_moreargs</code></td>
<td>
<p>optional: a function returning a list with possible elements <code>init</code>, <code>lower</code> and <code>upper</code> for control of estimation (and possibly other elements for other purposes). If the descriptor does not provide this function, a default <code>calc_moreargs</code> will be provided, implementing unbounded optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialize</code></td>
<td>
<p>optional: a function evaluating variables that may be needed repeatedly by <code>Cf</code> or <code>Af</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Af</code></td>
<td>
<p>This function should be defined if the correlation model requires an <b>A</b> matrix (the middle term in the case the design matrix of a random effect term is described by a triple matrix product <b>ZAL</b> as described in <code>random-effects</code>). Examples can be found in the descriptors returned by the <code>ranGCA</code> and <code>MaternIMRFa</code> constructors. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels_type</code></td>
<td>
<p>In the above example its value <code>"time_series"</code> informs <span class="pkg">spaMM</span> that levels of the random effect should be considered for all integer values within the range of the <code>time</code> variable, not only for levels present in the data. If this element is not provided by the constructor, <span class="pkg">spaMM</span> will internally assume a <code>levels_type</code> suitable for geostatistical models. Further level types may be defined in the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_corr_from_dist, make_new_corr_lists</code></td>
<td>
<p>Functions possibly needed for prediction (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>need_Cnn</code></td>
<td>
<p>optional: a boolean; default is TRUE. Controls prediction computations (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>public</code></td>
<td>
<p>An environment where some variables can be saved, typically by the <code>initialize</code> expression, for inspection at user level and for re-use. See <code>diallel</code> for an example.</p>
</td>
</tr>
</table>
<p><b><em>fitting-function</em> arguments</b>:
</p>
<p><code>lower, upper, init</code> and <code>fixed</code> optimization controls can be used to control optimization of continuous parameters as for other random-effect parameters. They are specified as numeric vectors, themselves being element of the <code>corrPars</code> list (see Examples in <code>corrFamily-design</code>). Parameter names (consistent with those to be used for the <code>tpar</code> argument) may be required to disambiguate incomplete vectors (e.g., to specify only its second element). Apart from <code>fixed</code> ones, any of the values not specified through the fitting-function arguments will be sought in the return value of the <code>calc_moreargs</code> function, if provided in the descriptor. If the <code>lower</code> or <code>upper</code> information is missing there, it must be provided throught the fitting-function call. If the <code>init</code> information is missing, a default value will be deduced from the bounds. The <code>init</code> specification is thus always optional while the bounds specification is optional only if the descriptor provides default values.  

</p>
<p><b><em>Arguments</em> of the corrFamily <em>constructor</em></b>
</p>
<p>These may be ad libitum, as design rules are defined only for the returned descriptor. However, arguments <code>tpar</code>, <code>fixed</code>, and <code>public</code> of predefined constructors, such as <code>ARp</code>, are designed to match the above respective elements of the descriptor. 
</p>


<h3>Details</h3>

<p><b>* Constructor elements for prediction:</b>
</p>
<p>For prediction of autocorrelated random effects, one must first assess whether levels of the random effect not represented in the fit are possible in new data (corresponding to new spatial locations in geostatistical models, or new time steps in time series). In that case <code>need_Cnn</code> must be TRUE (Interpolated MRFs do not require this as all required random-effect levels are determined by the IMRF <code>mesh</code> argument rather than by the fitted data or new data).
</p>
<p>Next, for autocorrelated random effects where <code>need_Cnn</code> is TRUE, a <code>make_new_corr_lists</code> function must be provided, except when a <code>calc_corr_from_dist</code> function is instead provided (which may be sufficient for models that construct the correlation from a spatial distance matrix). When <code>need_Cnn</code> is FALSE, a <code>make_new_corr_lists</code> function may still be needed. 
</p>
<p>The Examples section provides a simple example of such design, and the source code of the <code>ARp</code> or <code>ARMA</code> constructors provide further examples. They show that the <code>make_new_corr_lists</code> function may assign matrices or vectors as elements of several lists contained in a <code>newLv_env</code> environment. A matrix is assigned in the <code>cov_newLv_oldv_list</code>, specifying correlations between “new” levels of the random effect (implied by the new data) and “old” levels (those already included in the design matrix of the random effect for the fit). If <code>need_Cnn</code> is TRUE, a second matrix may be assigned in the <code>cov_newLv_newLv_list</code>, specifying correlation between “new” levels, and the diagonal of this matrix is assigned in the <code>diag_cov_newLv_newLv_list</code>. The overall structure of the code (the conditions where these assignments are performed, and the list indices), should be conserved. 
</p>
<p>When calling <code>simulate(., newdata=&lt;non-NULL&gt;, type="marginal"</code>, a fourth matrix may be useful, assigned into a <code>L_newLv_newLv_list</code>, specifying the matrix root (as a <code>tcrossprod</code> factor) of the correlation matrix stored in <code>cov_newLv_newLv_list</code>. The relevant <span class="pkg">spaMM</span> procedure will however try to compute it on the fly when it has not been provided by the <code>make_new_corr_lists</code> function.  
</p>
<p><b>* Fitting a <code>corrFamily</code> without a constructor:</b>
</p>
<p>It is possible to use an unregistered corrFamily, as follows: 
</p>
<pre>
AR3 &lt;- ARp(p=3)          # Generate descriptor of AR model of order 3

fitme(lh ~ 1 + corrFamily(1|time),  # &lt;= declaration of random effect
  covStruct=list( 
    corrFamily= AR3     # &lt;= declaration of its correlation structure
  ), 
  &lt; data and other possible arguments &gt;)
</pre>
<p>Here the fit only uses a descriptor list, not a constructor function. This descriptor is here provided to the fitting function as an element of the <code>covStruct</code> argument (using the general syntax of this argument), and in the model formula the corresponding random effect is declared as a term of the form<br><code>corrFamily(1|&lt;grouping factor&gt;)</code>. 
</p>
<p>This syntax is more complex than the one using a registered constructor, but it might be useful for development purposes (one only has to code the descriptor, not the constructor function). However, it is not general; in particular, using registered constructors may be required to obtain correct results when fitting multivariate-response models by <code>fitmv</code>.

</p>


<h3>See Also</h3>

<p>See <code>ARp</code>, <code>diallel</code>, and <code>MaternIMRFa</code> for basic examples of using a predefined corrFamily descriptor, and <code>corrFamily-design</code> for more geeky stuff including examples of implementing simple new correlation families. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
### Minimal (with many features missing) reimplementation 
#     of corrMatrix() terms as a corrFamily 


corrMatrix_cF &lt;- function(corrMatrix) {
  
  force(corrMatrix) # Makes it available in the environment of the functions next defined.
  oldZlevels &lt;- NULL
  
  initialize &lt;- function(Zmatrix, ...) {
    oldZlevels &lt;&lt;- colnames(Zmatrix) # Pass info about levels of the random effect in the data.
  }
  
  Cf &lt;- function(newlevels=oldZlevels ) {
    if (length(newlevels)) {
      corrMatrix[newlevels,newlevels]
    } else corrMatrix[oldZlevels,oldZlevels] # for Cf(tpar=numeric(0L))
  }
  
  calc_moreargs &lt;- function(corrfamily, ...) {
    list(init=c(),lower=c(),upper=c())
  }
  
  make_new_corr_lists &lt;- function(newLv_env, which_mats, newZAlist, new_rd, ...) {
    newlevels &lt;- colnames(newZAlist[[new_rd]])
    newLv_env$cov_newLv_oldv_list[[new_rd]] &lt;- corrMatrix[newlevels,oldZlevels, drop=FALSE]
    if (which_mats$nn[new_rd]) {
      newLv_env$cov_newLv_newLv_list[[new_rd]] &lt;- corrMatrix[newlevels,newlevels, drop=FALSE]
    } else { 
      newLv_env$diag_cov_newLv_newLv_list[[new_rd]] &lt;- rep(1,length(newlevels)) 
    }
  }
  
  list(Cf=Cf, tpar=numeric(0L), initialize=initialize, calc_moreargs=calc_moreargs, 
       make_new_corr_lists=make_new_corr_lists,
       tag="corrMatrix_cF") 
}

register_cF("corrMatrix_cF")

# usage:

data("blackcap") 
MLcorMat &lt;- MaternCorr(proxy::dist(blackcap[,c("latitude","longitude")]),
                       nu=0.6285603,rho=0.0544659)
corrmat &lt;- proxy::as.matrix(MLcorMat, diag=1)

fitme(migStatus ~ means+ corrMatrix_cF(1|name, corrMatrix=corrmat),data=blackcap,
      corrMatrix=MLcorMat,method="ML")
      
unregister_cF("corrMatrix_cF") # Tidy things before leaving.         


## End(Not run)
</code></pre>


</div>