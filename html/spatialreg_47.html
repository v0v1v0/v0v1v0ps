<div class="container">

<table style="width: 100%;"><tr>
<td>gstsls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial simultaneous autoregressive SAC model estimation by GMM</h2>

<h3>Description</h3>

<p>An implementation of Kelejian and Prucha's generalised moments estimator for the autoregressive parameter in a spatial model
with a spatially lagged dependent variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gstsls(formula, data = list(), listw, listw2 = NULL, na.action = na.fail, 
    zero.policy = attr(listw, "zero.policy"), pars=NULL, scaleU=FALSE, control = list(), 
    verbose=NULL, method="nlminb", robust=FALSE, legacy=FALSE, W2X=TRUE) 
## S3 method for class 'Gmsar'
impacts(obj, ..., n = NULL, tr = NULL, R = NULL,
 listw = NULL, evalues=NULL, tol = 1e-06, empirical = FALSE, Q=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit. The details 
of model specification are given for <code>lm()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment which the function 
is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw2</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code>, if not given, set to the same spatial weights as the listw argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> with consequences for residuals and fitted values - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE (default) assign NA - causing <code>GMerrorsar()</code> to terminate with an error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>starting values for <code class="reqn">\lambda</code> and <code class="reqn">\sigma^2</code> for GMM optimisation, 
if missing (default), approximated from initial 2sls model as the autocorrelation coefficient corrected for weights style 
and model sigma squared</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleU</code></td>
<td>
<p>Default FALSE: scale the OLS residuals before computing the moment matrices; only used if the <code>pars</code> argument is missing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters. See details in optim or nlminb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>default NULL, use global option value; if TRUE, reports function values during optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>default nlminb, or optionally a method passed to optim to use an alternative optimizer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>see <code>stsls</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legacy</code></td>
<td>
<p>see <code>stsls</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W2X</code></td>
<td>
<p>see <code>stsls</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A spatial regression object created by <code>lagsarlm</code>, <code>lagmess</code> or by <code>lmSLX</code>; in <code>HPDinterval.LagImpact</code>, a LagImpact object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed through to methods in the <span class="pkg">coda</span> package</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr</code></td>
<td>
<p>A vector of traces of powers of the spatial weights matrix created using <code>trW</code>, for approximate impact measures; if not given, <code>listw</code> must be given for exact measures (for small to moderate spatial weights matrices); the traces must be for the same spatial weights as were used in fitting the spatial regression, and must be row-standardised</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalues</code></td>
<td>
<p>vector of eigenvalues of spatial weights matrix for impacts calculations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>If given, simulations are used to compute distributions for the impact measures, returned as <code>mcmc</code> objects; the objects are used for convenience but are not output by an MCMC process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Argument passed to <code>mvrnorm</code>: tolerance (relative to largest variance) for numerical lack of positive-definiteness in the coefficient covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empirical</code></td>
<td>
<p>Argument passed to <code>mvrnorm</code> (default FALSE): if true, the coefficients and their covariance matrix specify the empirical not population mean and covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>default NULL, else an integer number of cumulative power series impacts to calculate if <code>tr</code> is given</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>defaults to <code>length(obj$residuals)</code>; in the method for <code>Gmsar</code> objects it may be used in panel settings to compute the impacts for cross-sectional weights only, suggested by Angela Parenti</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When the control list is set with care, the function will converge to values close to the ML estimator 
without requiring computation of the Jacobian, the most resource-intensive part of ML estimation. 
</p>


<h3>Value</h3>

<p>A list object of class <code>Gmsar</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>simultaneous autoregressive error coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>GMM coefficient estimates (including the spatial autocorrelation coefficient)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rest.se</code></td>
<td>
<p>GMM coefficient standard errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2</code></td>
<td>
<p>GMM residual variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE</code></td>
<td>
<p>sum of squared GMM errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>number of parameters estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lm.model</code></td>
<td>
<p>NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call used to create this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>GMM residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lm.target</code></td>
<td>
<p>NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Difference between residuals and response variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>model formula</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aliased</code></td>
<td>
<p>NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>zero.policy for this model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LL</code></td>
<td>
<p>NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vv</code></td>
<td>
<p>list of internal bigG and litg components for testing optimisation surface</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optres</code></td>
<td>
<p>object returned by optimizer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>start parameter values for optimisation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hcov</code></td>
<td>
<p>NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>(possibly) named vector of excluded or omitted observations if non-default na.action argument used</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Gianfranco Piras and Roger Bivand</p>


<h3>References</h3>

<p>Kelejian, H. H., and Prucha, I. R., 1999. A Generalized Moments Estimator for the Autoregressive Parameter in a Spatial Model. International Economic Review, 40, pp. 509â€“533; Cressie, N. A. C. 1993 <em>Statistics for spatial data</em>, Wiley, New York.
</p>
<p>Roger Bivand, Gianfranco Piras (2015). Comparing Implementations of Estimation Methods for Spatial Econometrics. <em>Journal of Statistical Software</em>, 63(18), 1-36. <a href="https://doi.org/10.18637/jss.v063.i18">doi:10.18637/jss.v063.i18</a>.
</p>


<h3>See Also</h3>

<p><code>optim</code>, <code>nlminb</code>, <code>GMerrorsar</code>, <code>GMargminImage</code></p>


<h3>Examples</h3>

<pre><code class="language-R">#require("spdep", quietly=TRUE) 
data(oldcol, package="spdep")
COL.errW.GM &lt;- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD, spdep::nb2listw(COL.nb, style="W"))
summary(COL.errW.GM)
aa &lt;- GMargminImage(COL.errW.GM)
levs &lt;- quantile(aa$z, seq(0, 1, 1/12))
image(aa, breaks=levs, xlab="lambda", ylab="s2")
points(COL.errW.GM$lambda, COL.errW.GM$s2, pch=3, lwd=2)
contour(aa, levels=signif(levs, 4), add=TRUE)
COL.errW.GM &lt;- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD,
 spdep::nb2listw(COL.nb, style="W"), scaleU=TRUE)
summary(COL.errW.GM)
listw &lt;- spdep::nb2listw(COL.nb)
W &lt;- as(listw, "CsparseMatrix")
trMat &lt;- trW(W, type="mult")
impacts(COL.errW.GM, tr=trMat)
</code></pre>


</div>