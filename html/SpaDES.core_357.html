<div class="container">

<table style="width: 100%;"><tr>
<td>outputs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation outputs</h2>

<h3>Description</h3>

<p>Accessor functions for the <code>outputs</code> slots in a <code>simList</code> object.
</p>
<p>If a module saves a file to disk during events, it can be useful to keep track
of the files that are saved e.g., for <code>saveSimList()</code> so that all files can
be added to the archive. In addition to setting <code>outputs</code> at the <code>simInit</code>
stage, a module developer can also put this in a using any saving mechanism that
is relevant (e.g., <code>qs::qsave</code>, <code>saveRDS</code> etc.). When a module event does this
it can be useful to register that saved file. <code>registerOutputs</code> offers an additional
mechanism to do this. See examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">outputs(sim)

## S4 method for signature 'simList'
outputs(sim)

outputs(sim) &lt;- value

## S4 replacement method for signature 'simList'
outputs(sim) &lt;- value

registerOutputs(filename, sim, ...)

outputArgs(sim)

## S4 method for signature 'simList'
outputArgs(sim)

outputArgs(sim) &lt;- value

## S4 replacement method for signature 'simList'
outputArgs(sim) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>A <code>simList</code>. If missing, then the function will search in the call
stack, so it will find it if it is in a <code>SpaDES</code> module.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The object to be stored at the slot. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>The filename to register in the <code>outputs(sim)</code> data.frame. If
missing, an attempt will be made to search for either a <code>file</code> or <code>filename</code>
argument in the call itself. This means that this function can be used with
the pipe, as long as the returned return from the upstream pipe function is
a filename or if it is <code>NULL</code> (e.g., <code>saveRDS</code>), then it will find the <code>file</code>
argument and use that.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are one of three mechanisms to add information about which output files to save.
</p>

<ol>
<li>
<p> As arguments to a <code>simInit</code> call. Specifically, <code>inputs</code> or <code>outputs</code>.
See <code>?simInit</code>.
</p>
</li>
<li>
<p> With the <code>outputs(simList)</code> function call.
</p>
</li>
<li>
<p> By adding a function called <code>.inputObjects</code> inside a module, which will be executed
during the <code>simInit</code> call. This last way is the most "modular" way to create
default data sets for your model.
</p>
</li>
</ol>
<p>See below for more details.
</p>
<p>Note using <code>registerOutputs</code>: a user can pass any other
arguments to <code>registerOutputs</code> that are in the
<code>outputs(sim)</code> data.frame, such as <code>objectName</code>, <code>fun</code>, <code>package</code>, though these
will not be used to save the files as this function is only about
registering an output that has already been saved.
</p>


<h3>Value</h3>

<p>A <code>simList</code> which will be the <code>sim</code> passed in with a new object registered
in the <code>outputs(sim)</code>
</p>


<h3>outputs function or argument in <code>simInit</code>
</h3>

<p><code>outputs</code> accepts a data.frame similar to the <code>inputs</code> data.frame, but
with up to 6 columns.
</p>

<table>
<tr>
<td style="text-align: left;">
<code>objectName</code> </td>
<td style="text-align: left;"> required, character string indicating the name of the object
in the <code>simList</code> that will be saved to disk (without the <code style="white-space: pre;">⁠sim$⁠</code> prefix).</td>
</tr>
<tr>
<td style="text-align: left;">

<code>file</code> </td>
<td style="text-align: left;"> optional, a character string indicating the file path to save to.
The default is to concatenate <code>objectName</code> with the model timeunit and
<code>saveTime</code>, separated by underscore, '<code style="white-space: pre;">⁠_⁠</code>'. So a default filename would be
<code>"Fires_year1.rds"</code>.</td>
</tr>
<tr>
<td style="text-align: left;">

<code>fun</code> </td>
<td style="text-align: left;"> optional, a character string indicating the function to use to
save that file. The default is <code>saveRDS()</code> </td>
</tr>
<tr>
<td style="text-align: left;">

<code>package</code> </td>
<td style="text-align: left;"> optional character string indicating the package in
which to find the <code>fun</code>);</td>
</tr>
<tr>
<td style="text-align: left;">

<code>saveTime</code> </td>
<td style="text-align: left;"> optional numeric, indicating when in simulation time the file
should be saved. The default is the lowest priority at <code>end(sim)</code>,
i.e., at the very end. </td>
</tr>
<tr>
<td style="text-align: left;">

<code>arguments</code> </td>
<td style="text-align: left;"> is a list of lists of named arguments, one list for each
<code>fun</code>. For example, if <code>fun = "write.csv"</code>,
<code>arguments = list(row.names = TRUE)</code> will pass the argument
<code>row.names = TRUE</code> to <code>write.csv</code>  If there is only one list,
then it is assumed to apply to all files and will be recycled as per normal R
rules of recycling for each <code>fun</code>.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>See the modules vignette for more details (<code>browseVignettes("SpaDES.core")</code>).
</p>


<h3>Note</h3>

<p>The automatic file type handling only adds the correct extension from a given
<code>fun</code> and <code>package</code>. It does not do the inverse, from a given extension find the
correct <code>fun</code> and <code>package</code>.
</p>


<h3>See Also</h3>

<p><code>registerOutputs()</code> which enables files that are saved to be added to
the <code>simList</code> using the <code>outputs(sim)</code> mechanism, so the files that are saved
during a module event can be tracked at the <code>simList</code> level. <code>saveSimList()</code>
which will optionally add all the outputs that are tracked into an archive.
</p>
<p><code>Plots()</code>, <code>outputs()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#######################
# outputs
#######################

tmpdir &lt;- file.path(tempdir(), "outputs") |&gt; checkPath(create = TRUE)
tmpFile &lt;- file.path(tmpdir, "temp.rds")
tempObj &lt;- 1:10

# Can add data.frame of outputs directly into simInit call
sim &lt;- simInit(objects = c("tempObj"),
               outputs = data.frame(objectName = "tempObj"),
               paths = list(outputPath = tmpdir))
outputs(sim) # To see what will be saved, when, what filename
sim &lt;- spades(sim)
outputs(sim) # To see that it was saved, when, what filename

# Also can add using assignment after a simList object has been made
sim &lt;- simInit(objects = c("tempObj"), paths = list(outputPath = tmpdir))
outputs(sim) &lt;- data.frame(objectName = "tempObj", saveTime = 1:10)
sim &lt;- spades(sim)
outputs(sim) # To see that it was saved, when, what filename.

# can do highly variable saving
tempObj2 &lt;- paste("val", 1:10)
df1 &lt;- data.frame(col1 = tempObj, col2 = tempObj2)
sim &lt;- simInit(objects = c("tempObj", "tempObj2", "df1"),
  paths = list(outputPath = tmpdir))
outputs(sim) &lt;- data.frame(
     objectName = c(rep("tempObj", 2), rep("tempObj2", 3), "df1"),
     saveTime = c(c(1, 4), c(2, 6, 7), end(sim)),
     fun = c(rep("saveRDS", 5), "write.csv"),
     package = c(rep("base", 5), "utils"),
     stringsAsFactors = FALSE)
# since write.csv has a default of adding a column, x, with rownames, must add additional
#   argument for 6th row in data.frame (corresponding to the write.csv function)
outputArgs(sim)[[6]] &lt;- list(row.names = FALSE)
sim &lt;- spades(sim)
outputs(sim)

# read one back in just to test it all worked as planned
newObj &lt;- read.csv(dir(tmpdir, pattern = "year10.csv", full.name = TRUE))
newObj

# using saving with SpaDES-aware methods
# To see current ones SpaDES can do
.saveFileExtensions()

library(terra)
ras &lt;- rast(ncol = 4, nrow = 5)
ras[] &lt;- 1:20

sim &lt;- simInit(objects = c("ras"), paths = list(outputPath = tmpdir))
outputs(sim) &lt;- data.frame(
  file = "test",
  fun = "writeRaster",
  package = "terra",
  objectName = "ras",
  stringsAsFactors = FALSE)

simOut &lt;- spades(sim)
outputs(simOut)
newRas &lt;- rast(dir(tmpdir, full.name = TRUE, pattern = ".tif")[1])
all.equal(newRas, ras) # Should be TRUE
# Clean up after
unlink(tmpdir, recursive = TRUE)
# For `registerOutputs`
sim &lt;- simInit()
# This would normally be a save call, e.g., `writeRaster`
tf &lt;- reproducible::tempfile2(fileext = ".tif")
sim &lt;- registerOutputs(sim, filename = tf)

# Using a pipe
tf &lt;- reproducible::tempfile2(fileext = ".rds")
sim$a &lt;- 1
sim &lt;- saveRDS(sim$a, tf) |&gt; registerOutputs()
# confirm:
outputs(sim) # has object --&gt; saved = TRUE

</code></pre>


</div>