<div class="container">

<table style="width: 100%;"><tr>
<td>doCallWE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Innermost Computation: Error Catching Version of do.call()</h2>

<h3>Description</h3>

<p><code>doCallWE()</code> performs the innermost computation of the simulation
study at hand.  It is a version of <code>do.call(f, argl, *)</code>,
with care of catching and storing <em>both</em> error and warnings (via
<code>tryCatch.W.E()</code>) and measures user time.  This is useful
in large(r) simulation studies.
</p>
<p><code>mkTimer()</code> returns a <em>function</em> to be passed as
<code>timer</code> to <code>doCallWE()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">doCallWE(f, argl, 
         timer = mkTimer(gcFirst=FALSE))

mkTimer(gcFirst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a <code>function</code> which given data and parameters,
computes the statistic we are simulating.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argl</code></td>
<td>
<p>list of arguments for <code>f()</code>.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>timer</code></td>
<td>
<p>a <code>function</code> similar to
<code>system.time()</code>; by default, measure user time in
milliseconds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcFirst</code></td>
<td>
<p>logical, passed to <code>system.time()</code>, as it
is called from the resulting function <code>mkTimer()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that <code>gcFirst=FALSE</code> is default for a good reason: if a call
to <code>doOne()</code> is relatively fast, calling <code>gc()</code> every
time is unnecessarily expensive and may completely dominate the
overall simulation run time. For serious run time measurement,
<code>gcFirst=TRUE</code> is preferable, as it ensures less
variable timings, see <code>system.time</code>.
</p>


<h3>Value</h3>

<p><code>doCallWE()</code> returns a <code>list</code> with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p><code>f</code><code class="reqn">(\langle \mathtt{argl} \rangle)</code>,
if there was no error, <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>error message (see <code>simpleError</code> or
<code>stop()</code>), <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warning</code></td>
<td>
<p>warning message (see <code>simpleWarning</code> or
<code>warning()</code>), <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>time, as measured by <code>timer()</code>; defaults to
milliseconds without garbage collection.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marius Hofert and Martin Maechler.</p>


<h3>See Also</h3>

<p><code>do.call</code>, <code>tryCatch.W.E</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(61)
L &lt;- log(abs(rt(n=100, df = 1.5)))
r &lt;- doCallWE(quantile, list(L, probs= 0.95))
## set timer for  "no timing" :
u &lt;- doCallWE(quantile, list(L, probs= 0.95), timer = function(E) { E; NULL })
stopifnot(is.null(r$error),
	  all.equal(r$value, quantile(L, 0.95)),
	  identical(r[1:3], u[1:3]), is.null(u[["time"]]))
</code></pre>


</div>