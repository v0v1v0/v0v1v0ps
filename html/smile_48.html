<div class="container">

<table style="width: 100%;"><tr>
<td>predict_spm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction over the same or a different set of regions (or points).</h2>

<h3>Description</h3>

<p>Realizes predictions that can be useful when researchers are
interested in predict a variable observed in one political division of a
city (or state) on another division of the same region.
</p>


<h3>Usage</h3>

<pre><code class="language-R">predict_spm(x, ...)

## S3 method for class 'spm_fit'
predict_spm(x, .aggregate = TRUE, ...)

## S3 method for class 'sf'
predict_spm(x, spm_obj, n_pts, type, outer_poly = NULL, id_var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>sf</code> object such that its geometries are either points or
polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.aggregate</code></td>
<td>
<p><code>logical</code>. Should the predictions be aggregated? In
case the input is only a "fit" object, the aggregation is made over the
polygons on which the original data was observed. In case the input
<code>x</code> is composed by <code>sf POLYGONS</code>, the aggregation is made over
this new partition of the study region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spm_obj</code></td>
<td>
<p>an object of either class <code>spm_fit</code> or <code>mspm_fit</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_pts</code></td>
<td>
<p>a <code>numeric</code> scalar standing for number of points to form a
grid over the whole region to make the predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>character</code> type of grid to be generated. See
<code>st_sample</code> in the package <code>sf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outer_poly</code></td>
<td>
<p>(object) <code>sf geometry</code> storing the "outer map" we
want to compute the predictions in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_var</code></td>
<td>
<p>if <code>x</code> is a set of <code>POLYGONS</code> (areal data) instead
of a set of points, the <code>id_var</code> is the name (or index) of the
unique identifier associated to each polygon.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>list</code> of size 4 belonging to the class <code>spm_pred</code>. This
list contains the predicted values and the mean and covariance matrix
associated with the conditional distribution used to compute the
predictions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(liv_lsoa) ## loading the LSOA data
data(liv_msoa) ## loading the MSOA data

msoa_spm &lt;- sf_to_spm(sf_obj = liv_msoa, n_pts = 500,
                      type = "regular", by_polygon = FALSE,
                      poly_ids = "msoa11cd",
                      var_ids = "leb_est")
## fitting model
theta_st_msoa &lt;- c("phi" = 1) # initial value for the range parameter

fit_msoa &lt;-
   fit_spm(x = msoa_spm,
           theta_st = theta_st_msoa,
           model = "matern",
           nu = .5,
           apply_exp  = TRUE,
           opt_method = "L-BFGS-B",
           control    = list(maxit = 500))

pred_lsoa &lt;- predict_spm(x = liv_lsoa, spm_obj = fit_msoa, id_var = "lsoa11cd")

</code></pre>


</div>