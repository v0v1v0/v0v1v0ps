<div class="container">

<table style="width: 100%;"><tr>
<td>string_magic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>String interpolation with operation chaining</h2>

<h3>Description</h3>

<p>This is firstly a string interpolation tool. On top of this it can apply, and chain, over 50
basic string operations to the interpolated variables. Advanced support for pluralization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_magic(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .post = NULL,
  .nest = FALSE,
  .collapse = NULL,
  .invisible = FALSE,
  .default = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .class = NULL,
  .help = NULL,
  .namespace = NULL
)

.string_magic(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .collapse = NULL,
  .last = NULL,
  .nest = FALSE,
  .trigger = TRUE,
  .namespace = NULL
)

sma(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .post = NULL,
  .nest = FALSE,
  .collapse = NULL,
  .invisible = FALSE,
  .default = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .class = NULL,
  .help = NULL,
  .namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Character scalars that will be collapsed with the argument <code>sep</code>. Note that
named arguments are used for substitution.
</p>
<p>To interpolate, you can
use <code>"{x}"</code> within each character string to insert the value of <code>x</code> in the string.
You can add string operations in each <code>"{}"</code> instance with the syntax <code>"'arg'op ? x"</code>
(resp. <code>"'arg'op ! x"</code>) to apply the operation <code>'op'</code> with the argument <code>'arg'</code> to <code>x</code>
(resp. the verbatim of <code>x</code>). Otherwise, what to say? Ah, nesting is enabled, and since
there's over 50 operators, it's a bit complicated to sort you out in this small space.
</p>
<p>Use the argument <code>.help = "keyword"</code> (or <code>.help = TRUE</code>) to obtain a selective help
from the main documentation.
</p>
<p>Note that in interpolations you have access to the special variables: <code>.now</code> and <code>.date</code>
to get the current time; and the special function <code>.now("format")</code> to
format the time. Ex: <code>.now('%Y-%m %H:%m')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.envir</code></td>
<td>
<p>An environment used to evaluate the variables in <code>"{}"</code>. By default the variables are
evaluated using the environment from where the function is called or using the named
arguments passed to the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.sep</code></td>
<td>
<p>Character scalar, default is the empty string <code>""</code>. It is used to collapse all
the elements in <code>...</code> before applying any operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.vectorize</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, Further, elements in <code>...</code> are
NOT collapsed together, but instead vectorised.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.delim</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("{", "}")</code>. Defines
the opening and the closing delimiters for interpolation.
</p>
<p>If of length 1, it must be of the form: 1) the opening delimiter,
2) a single space, 3) the closing delimiter. Ex: <code>".[ ]"</code> is equivalent to <code>c(".[", "]")</code>.
The default value is equivalent to <code>"{ }"</code>.
</p>
<p>[ ]: R:%20
[", "]: R:%22,%20%22</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.last</code></td>
<td>
<p>Character scalar, a function, or <code>NULL</code> (default). If provided and character:
it must be an <code>string_magic</code> chain of operations of the form <code>"'arg1'op1, op2, etc"</code>. All these operations
are applied just before returning the vector. If a function,
it will be applied to the resulting vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.post</code></td>
<td>
<p>Function or <code>NULL</code> (default). If not <code>NULL</code>, this function will be applied
after all the processing, just before returning the object. This function can have
extra arguments which will be caught directly in the <code>...</code> argument of <code>string_magic</code>.
For example if <code>.post = head</code>, you can directly pass the argument <code>n = 3</code> to <code>string_magic</code>'s arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.nest</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, it will nest the original string within
interpolation delimiters, so that you can apply operations directly on the string. Example:
<code>string_magic("upper ! hello")</code> returns "upper ! hello", while <code>string_magic("upper ! hello", .nest = TRUE)</code>
returns <code>"HELLO"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.collapse</code></td>
<td>
<p>Character scalar, default is <code>NULL</code>. If provided, the character vector
that should be returned is collapsed with the value of this argument. This leads
to return a string of length 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.invisible</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether the object returned should be
invisible (i.e. not printed on the console).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.default</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If provided, it must be
a sequence of <code>string_magic</code> operations. It will be applied as a default to any interpolation.
Ex: if <code>x = 1:2</code>, then <code>string_magic("x = {x}", .default = "enum")</code> leads to "x = 1 and 2",
and is equivalent to <code>string_magic("x = {enum?x}")</code>. Note that this default operations does
not apply to nested expressions. That is <code>string_magic("{!x{1:2}}", .default = "enum")</code> leads
to <code>c("x1", "x2")</code> and NOT <code>"x1 and 2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.trigger</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code>, this function is not run. Can be
useful in debugging situations where we want conditional evaluations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.check</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to enable error-handling (i.e.
human readable error messages).
Without error-handling you can save something of the order of 40us. Useful only
in long loops.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.class</code></td>
<td>
<p>Character vector representing the class to give to the object returned.
By default it is <code>NULL</code>. Note that the class <code>string_magic</code> has a specific <code>print</code> method, usually
nicer for small vectors (it <code>base::cat()</code>s the elements).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.help</code></td>
<td>
<p>Character scalar or <code>TRUE</code>, default is <code>NULL</code>. This argument
is used to generate a dynamic help on the console. If <code>TRUE</code>, the user can select which
topic to read from the main documentation, with the possibility to search for keywords and
navigate the help pages. If a character scalar, then a regex search is perfomed on the main
documentation and any section containining a match is displayed. The user can easily
navigate across matches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code>string_magic_register_fun()</code> or <code>string_magic_register_ops()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are over 50 basic string operations, it supports pluralization, string operations can be
nested, operations can be applied group-wise or conditionally and
operators have sensible defaults.
You can also declare your own operations with <code>string_magic_register_fun()</code> or <code>string_magic_register_ops()</code>.
They will be seamlessly integrated to <code>string_magic</code>.
</p>
<p>The function <code>.string_magic</code> (prefixed with a dot) is a leaner version of the function <code>string_magic</code>.
It does the same operations but with the following differences:
</p>

<ul>
<li>
<p> there is no error handling: meaning that the error messages, if any, will be poor and
hard to understand
</p>
</li>
<li>
<p> default options are not applied: hence the user must always explicitly provide the arguments
</p>
</li>
</ul>
<p>This leads to a faster processing time (of about 50 microseconds) at the cost of user experience.
</p>
<p>If you want to change the default values of <code>string_magic</code> (like changing the delimiter), use
the function <code>string_magic_alias()</code>.
</p>
<p>Use the argument <code>.help</code> to which
you can pass keywords or regular expressions and fecth select pieces from the main documentation.
</p>


<h3>Value</h3>

<p>It returns a character vector whose length depends on the elements and operations in the interpolations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_magic()</code>: String interpolation with operation chaining
</p>
</li>
<li> <p><code>.string_magic()</code>: A simpler version of <code>string_magic</code> without any error handling to save a few micro seconds
</p>
</li>
<li> <p><code>sma()</code>: Alias to <code>string_magic</code>
</p>
</li>
</ul>
<h3>Interpolation and string operations</h3>

<p>Principle:
</p>
<p>To interpolate a variable, say <code>x</code>, simply use <code>{x}</code>. For example <code style="white-space: pre;">⁠x = "world"; string_magic("hello {x}")⁠</code> leads
to "hello world".
</p>
<p>To any interpolation you can add operations. Taking the previous example, say we want to display
"hello W O R L D". This means upper casing all letters of the interpolated variable and adding a space between
each of them. Do you think we can do that? Of course yes:
<code>string_magic("hello {upper, ''s, c ? x}")</code>. And that's it.
</p>
<p>Now let's explain what happened. Within the <code>{}</code> <em>box</em>, we first write a set of
operations, here "upper, ”s, c", then add "?" and finally write
the variable to interpolate, "x".  The operations (explained in more details
below) are <code>upper</code>, upper-casing all letters, ”s: splitting
with the empty string, 'c': concatenating with spaces the vector of string that was just split.
The question mark means that the expression coming after it is to be evaluated
(this is opposed to the exclamation mark presented next).
</p>
<p>The syntax is always the same: <code>{operations ? expression}</code>, where the operations section
is a <em>comma separated</em> list of operations.
These operations are of the form <code style="white-space: pre;">⁠'arg'op⁠</code>, with <code>arg</code> the argument to the operator
code <code>op</code>. These operations are performed sequantially from left to right.
</p>
<p>Some operations, like <code>upper</code>, accept options. You attach options to an operation
with a dot followed by the option name. Formally: <code>op.option1.option2</code>, etc.
Example: <code style="white-space: pre;">⁠x = "hi there. what's up? fine." ; string_magic("He said: {upper.sentence, Q ? x}")⁠</code>.
Leads to: <code style="white-space: pre;">⁠He said: "Hi there. What's up? Fine."⁠</code>.
</p>
<p>Both operators and options are partially matched. So <code>string_magic("He said: {up.s, Q ? x}")</code> would
also work.
</p>


<h3>Verbatim interpolation and nesting</h3>

<p>Principle:
</p>
<p>Instead of interpolating a variable, say <code>x</code>, with <code>{x}</code>, you can use an exclamation
mark to trigger varbatim evaluation.
For example <code>string_magic("hello {!x}")</code> would lead to "hello x". It's a
bit disappointing, right? What's the point of doing that? Wait until the next two paragraphs.
</p>
<p>Verbatim evaluation is a powerful way to apply operations to plain text. For example:
<code>string_magic("hello {upper, ''s, c ! world}")</code> leads to "hello W O R L D".
</p>
<p>(A note in passing. The spaces surrounding the exclamation mark are non necessary,
but when one space is present on both sides of the <code>!</code>, then the verbatim
expression only begins after it. Ex: <code>"{upper! hi}"</code> leads to " HI" while <code>"{upper ! hi}"</code>
leads to "HI" and <code>"{upper !  hi}"</code> leads to " HI".)
</p>
<p>The second advantage of verbatim evaluations is <em>nesting</em>. Anything in a verbatim
expression is evaluated with the function <code>string_magic</code>.
This means that any <em>box</em> will be evaluated as previously described. Let's
give an example. You want to write the expression of a polynomial of order n: a + bx + cx^2 + etc.
You can do that with nesting. Assume we have <code>n = 2</code>.
</p>
<p>Then <code>string_magic("poly({n}): {' + 'c ! {letters[1 + 0:n]}x^{0:n}}")</code> leads to
"poly(2): ax^0 + bx^1 + cx^2".
</p>
<p>How does it work? The verbatim expression (the one following the exclamation mark),
here <code>"{letters[1 + 0:n]}x^{0:n}"</code>, is evaluated with <code>string_magic</code>.
<code>string_magic("{letters[1 + 0:n]}x^{0:n}")</code> leads to the vector c("ax^0", "bx^1", "cx^2").
</p>
<p>The operation <code style="white-space: pre;">⁠' + 'c⁠</code> then concatenates (or collapses) that vector with ' + '.
This value is then appended to the previous string.
</p>
<p>We could refine by adding a cleaning operation in which we replace "x^0" and "^1"
by the empty string. Let's do it:
</p>
<p><code>string_magic("poly({n}): {' + 'c, 'x\\^0|\\^1'r ! {letters[1 + 0:n]}x^{0:n}}")</code> leads to
"poly(2): a + bx + cx^2", what we wanted.
</p>
<p>You can try to write a function to express the polynomial as before: although it is
a simple task, my guess is that it will require more typing.
</p>


<h3>Operations</h3>

<p>General syntax:
</p>
<p>As seen in the previous sections, within a <em>box</em> (i.e. <code>"{}"</code>), multiple operations
can be performed.
We can do so by stacking the operations codes and in a comma separated enumeration.
Operations can have arguments, and operations can also have options. The general
syntax, with argument and options, is:
</p>
<p><code style="white-space: pre;">⁠{'arg1'op1.optionA.optionB, arg2 op2.optionC, ⁠</code>arg3<code style="white-space: pre;">⁠op3, 51op4 ? x}⁠</code>
</p>
<p>The argument can appear in four forms: a) inside single or double quotes just
before the operation name (<code>arg1</code> above),
b) verbatim, separated with a space, just before the operation name (<code>arg2</code> above),
c) inside bactick quotes the argument is evaluated from the environment (<code>arg3</code> above),
or d) when the argument is an integer it can be juxtaposed to the opeation name (like in <code>op4</code> above).
</p>
<p>The options are always dot separated and attached to the operation name, they are
specific to each operation.
</p>
<p>Both the operation name and the option names are partially matched.
</p>


<h3>Basic string operations</h3>

<p>This section describes some of the most common string operations: extracting, replacing, collapsing, splitting, etc.
These functions accept generic flags ("ignore", "fixed", "word") in their patterns (syntax: "flags/pattern").
Please see the dedicated section for more information on flags.
</p>

<ul>
<li>
<p> s, split, S, Split: splits the string according to a pattern.
The operations have different defaults: <code>' '</code>
for <code>s</code> and 'split', and <code>',[ \t\n]*'</code> for <code>S</code> and 'Split' (i.e. comma separation).
Ex.1: <code>string_magic("{S ! romeo, juliet}")</code> leads to the vector c("romeo", "juliet").
Ex.2: <code>string_magic("{'f/+'s, '-'c ! 5 + 2} = 3")</code> leads to "5 - 2 = 3" (note the flag "fixed" in <code>s</code>'s pattern).
</p>
</li>
<li>
<p> c, C: to concatenate multiple strings into a single one. The two operations are
identical, only their default change. c: default is <code>' '</code>, C: default is <code>', | and '</code>.
The syntax of the argument is 's1' or 's1|s2'. s1 is the string used to concatenate
(think <code>paste(x, collapse = s1)</code>). In arguments of the form <code>'s1|s2'</code>, <code>s2</code> will be used to concatenate the last two elements.
Ex.1: <code style="white-space: pre;">⁠x = 1:4; string_magic("Et {' et 'c ? x}!")⁠</code> leads to "Et 1 et 2 et 3 et 4!".
Ex.2: <code>string_magic("Choose: {', | or 'c ? 2:4}?")</code> leads to "Choose: 2, 3 or 4?".
</p>
</li>
<li>
<p> x, X: extracts patterns from a string. Both have the same default: <code>'[[:alnum:]]+'</code>.
<code>x</code> extracts the first match while <code>X</code> extracts <strong>all</strong> the matches.
Ex.1: <code style="white-space: pre;">⁠x = c("6 feet under", "mahogany") ; string_magic("{'\\w{3}'x ? x}")⁠</code> leads to the vector c("fee", "mah").
Ex2.: <code style="white-space: pre;">⁠x = c("6 feet under", "mahogany") ; string_magic("{'\\w{3}'X ? x}")⁠</code> leads to the
vector c("fee", "und", "mah", "oga").
</p>
</li>
<li>
<p> extract: extracts multiple patterns from a string, this is an alias to the operation <code>X</code> described above.
Use the option "first" to extract only the first match for each string (behavior becomes like <code>x</code>).
Ex: <code style="white-space: pre;">⁠x = c("margo: 32, 1m75", "luke doe: 27, 1m71") ; string_magic("{'^\\w+'extract ? x} is {'\\d+'extract.first ? x}")⁠</code>
leads to c("margo is 32", "luke is 27").
</p>
</li>
<li>
<p> r, R: replacement within a string. The two operations are identical and have no default.
The syntax is <code>'old'</code> or <code>'old =&gt; new'</code> with <code>'old'</code> the pattern to find and <code>new</code> the replacement. If <code>new</code> is missing, it is
considered the empty string. This operation also accepts the flag "total" which instruct to
replace the fulll string in case the pattern is found.
Ex.1: <code>string_magic("{'e'r ! Where is the letter e?}")</code> leads to "Whr is th lttr ?".
Ex.2: <code>string_magic("{'(?&lt;!\\b)e =&gt; a'R ! Where is the letter e?}")</code> leads to "Whara is tha lattar e?".
Ex.3: <code>string_magic("{'t/e =&gt; here'r ! Where is the letter e?}")</code> leads to "here".
</p>
</li>
<li>
<p> clean: replacement with a string. Similar to the operation <code>r</code>, except that here the comma is
a pattern separator, see detailed explanations in <code>string_clean()</code>. Ex: <code>string_magic("{'f/[, ]'clean ! x[a]}")</code>
leads to "xa".
</p>
</li>
<li>
<p> get: restricts the string only to values respecting a pattern. This operation has no default.
Accepts the options "equal" and "in".
By default it uses the same syntax as <code>string_get()</code> so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested.
Example: <code style="white-space: pre;">⁠x = row.names(mtcars) ; string_magic("Mercedes models: {'Merc &amp; [[:alpha:]]$'get, '^.+ 'r, C ? x}")⁠</code>
leads to "Mercedes models: 240D, 280C, 450SE, 450SL and 450SLC".
</p>
</li>
<li>
<p> is: detects if a pattern is present in a string, returns a logical vector. This operation has no default.
Accepts the options "equal" and "in".
By default it uses the same syntax as <code>string_is()</code> so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested.
Mostly useful as the final operation in a <code>string_ops()</code> call.
Example: <code style="white-space: pre;">⁠x = c("Mark", "Lucas") ; string_magic("Mark? {'i/mark'is, C ? x}")⁠</code> leads to "Mark? TRUE and FALSE".
</p>
</li>
<li>
<p> which: returns the index of string containing a specified pattern. With no default, can be applied
to a logical vector directly.
By default it uses the same syntax as string_which() so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option "equal" is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option "in" is used, the argument is first split with respect to commas
and then set inclusion is tested.
Mostly useful as the final operation in a <code>string_ops()</code> call.
Ex.1: <code style="white-space: pre;">⁠x = c("Mark", "Lucas") ; string_magic("Mark is number {'i/mark'which ? x}.")⁠</code> leads to
"Mark is number 1.".
</p>
</li>
</ul>
<h3>Operations changing the length or the order</h3>


<ul>
<li>
<p> first: keeps only the first <code>n</code> elements. Example: <code>string_magic("First 3 numbers: {3 first, C ? mtcars$mpg}.")</code>
leads to "First 3 numbers: 21, 21 and 22.8.". Negative numbers as argument remove the
first <code>n</code> values. You can add a second argument in the form <code style="white-space: pre;">⁠'n1|n2'first⁠</code> in which case the first <code>n1</code> and last
<code>n2</code> values are kept; <code>n1</code> and <code>n2</code> must be positive numbers.
</p>
</li>
<li>
<p> K, Ko, KO: keeps only the first <code>n</code> elements; has more options than <code>first</code>. The syntax is <code style="white-space: pre;">⁠'n'K⁠</code>,
<code style="white-space: pre;">⁠'n|s'K⁠</code>, <code style="white-space: pre;">⁠'n||s'K⁠</code>. The values Ko and KO only accept the two first syntax (with <code>n</code> only).
<code>n</code> provides the number of elements to keep. If <code>s</code> is provided and the number of
elements are greater than <code>n</code>, then in 'n|s' the string <code>s</code> is added at the end, and
if 'n||s' the string s replaces the nth element.
The string <code>s</code> accepts specials values:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠:n:⁠</code> or <code style="white-space: pre;">⁠:N:⁠</code> which gives the total number of items in digits or letters (N)
</p>
</li>
<li> <p><code style="white-space: pre;">⁠:rest:⁠</code> or <code style="white-space: pre;">⁠:REST:⁠</code> which gives the number of elements that have been truncated in digits or letters (REST)
Ex: <code>string_magic("{'3|:rest: others'K ? 1:200}")</code> leads to the vector <code>c("1", "2", "3", "197 others")</code>.
</p>
</li>
<li>
<p> The operator 'n'Ko is like <code style="white-space: pre;">⁠'n||:rest: others'K⁠</code> and 'n'KO is like <code style="white-space: pre;">⁠'n||:REST: others'K⁠</code>.
</p>
</li>
</ul>
</li>
<li>
<p> last: keeps only the last <code>n</code> elements. Example: <code>string_magic("Last 3 numbers: {3 last, C ? mtcars$mpg}.")</code>
leads to "Last 3 numbers: 19.7, 15 and 21.4.". Negative numbers as argument remove the
last <code>n</code> values.
</p>
</li>
<li>
<p> sort: sorts the vector in increasing order. Accepts optional arguments and the option "num".
Example: <code style="white-space: pre;">⁠x = c("sort", "me") ; string_magic("{sort, c ? x}")⁠</code> leads to "me sort".
If an argument is provided, it must be a regex pattern that will be applied to
the vector using <code>string_clean()</code>. The sorting will be applied to the modified version of the vector
and the original vector will be ordered according to this sorting.
Ex: <code>x = c("Jon Snow", "Khal Drogo")</code>; <code>string_magic("{'.+ 'sort, C?x}")</code> leads to
"Khal Drogo and Jon Snow". The option "num" sorts over a numeric version
(with silent conversion) of the vector and reorders the original vector accordingly.
Values which could not be converted are last.
<strong>Important note</strong>: the sorting operation is applied before any character conversion.
If previous operations were applied, it is likely that numeric data were transformed to character.
Note the difference: <code style="white-space: pre;">⁠x = c(20, 100, 10); string_magic("{sort, ' + 'c ? x}")⁠</code> leads to "10 + 20 + 100"
while <code>string_magic("{n, sort, ' + 'c ? x}")</code> leads to "10 + 100 + 20" because the operation "n"
first transformed the numeric vector into character.
</p>
</li>
<li>
<p> dsort: sorts the vector in decreasing order. It accepts an optional argument and
the option "num". Example: <code>string_magic("5 = {dsort, ' + 'c ? 2:3}")</code>
leads to "5 = 3 + 2". See the operation "sort" for a description of the argument and the option.
</p>
</li>
<li>
<p> rev: reverses the vector. Example: <code>string_magic("{rev, ''c ? 1:3}")</code> leads to "321".
</p>
</li>
<li>
<p> unik: makes the string vector unique. Example: <code>string_magic("Iris species: {unik, C ? iris$Species}.")</code>
leads to "Iris species: setosa, versicolor and virginica.".
</p>
</li>
<li>
<p> each: repeats each element of the vector <code>n</code> times. Option "c" then collapses the full vector
with the empty string as a separator. Ex.1: <code>string_magic("{/x, y}{2 each ? 1:2}")</code> leads to the
vector <code>c("x1", "y1", "x2", "y2")</code>. Ex.2: <code>string_magic("Large number: 1{5 each.c ! 0}")</code> leads to
"Large number: 100000".
</p>
</li>
<li>
<p> times: repeats the vector sequence <code>n</code> times. Option "c" then collapses the full vector
with the empty string as a separator. Example: <code>string_magic("What{6 times.c ! ?}")</code> leads to "What??????".
</p>
</li>
<li>
<p> rm: removes elements from the vector. Options: "empty", "blank", "noalpha", "noalnum", "all".
The <em>optional</em> argument represents the pattern used to detect strings to be deleted.
Ex.1: <code>x = c("Luke", "Charles")</code>; <code>string_magic("{'i/lu'rm ? x}")</code> leads to "charles". By default it removes
empty strings. Option "blank" removes strings containing only blank characters (spaces, tab, newline).
Option "noalpha" removes strings not containing letters. Option "noalnum" removes strings not
containing alpha numeric characters. Option "all" removes all strings (useful in conditions, see
the dedicated section). If an argument is provided, only the options "empty" and "blank" are available.
Ex.2: <code>x = c("I want to enter.", "Age?", "21")</code>; <code>string_magic("Nightclub conversation: {rm.noalpha, c ! - {x}}")</code>
leads to "Nightclub conversation: - I want to enter. - Age?"
</p>
</li>
<li>
<p> nuke: removes all elements, equivalent to <code>rm.all</code> but possibly more explicit (not sure).
Useful in conditions, see the dedicated section.
Example: <code style="white-space: pre;">⁠x = c(5, 7, 453, 647); string_magic("Small numbers only: {if(.&gt;20 ; nuke), C ? x}")⁠</code> leads
to "Small numbers only: 5 and 7";
</p>
</li>
<li>
<p> insert: inserts a new element to the vector. Options: "right" and "both". Option "right" adds
the new element to the right. Option "both" inserts the new element on the two sides of the vector.
Example: <code>string_magic("{'3'insert.right, ' + 'c ? 1:2}")</code> leads to "1 + 2 + 3".
</p>
</li>
<li> <p><code>dp</code> or <code>deparse</code>: Deparses an object and keeps only the first characters of
the deparsed string. Accepts a number as argument. In that case only the first <code>n</code>
characters are kept. Accepts option <code>long</code>: in that case all the
lines of the deparsed object are first collapsed.
Example: <code style="white-space: pre;">⁠fml = y ~ x1 + x2; string_magic("The estimated model is {dp ? fml}.")⁠</code>
</p>
</li>
</ul>
<h3>Formatting operations</h3>


<ul>
<li>
<p> lower: lower cases the full string.
</p>
</li>
<li>
<p> upper: upper cases the full string. Options: "first" and "sentence".
Option "first" upper cases only the first character. Option "sentence"
upper cases the first letter after punctuation.
Ex: <code style="white-space: pre;">⁠x = "hi. how are you? fine." ; string_magic("{upper.sentence ? x}")⁠</code> leads
to "Hi. How are you? Fine.".
</p>
</li>
<li>
<p> title: applies a title case to the string. Options: "force" and "ignore".
Option "force" first puts everything to lowercase before applying the title case.
Option "ignore" ignores a few small prepositions ("a", "the", "of", etc).
Ex: <code style="white-space: pre;">⁠x = "bryan is in the KITCHEN" ; string_magic("{title.force.ignore ? x}")⁠</code> leads to "Bryan Is in the Kitchen".
</p>
</li>
<li>
<p> ws: normalizes whitespaces (WS). It trims the whitespaces on the edges and transforms any succession
of whitespaces into a single one. Can also be used to further clean the string with its options.
Options: "punct", "digit", "isolated". Option "punct" cleans the punctuation. Option "digit" cleans digits.
Option "isolated" cleans isolated letters. WS normalization always come after any of these options.
<strong>Important note:</strong> punctuation (or digits) are replaced with WS and <strong>not</strong>
the empty string. This means that <code>string_magic("ws.punct ! Meg's car")</code> will become "Meg s car".
</p>
</li>
<li>
<p> trimws: trims the white spaces on both ends of the strings.
</p>
</li>
<li>
<p> q, Q, bq: to add quotes to the strings. q: single quotes, Q: double quotes, bq:
back quotes. <code style="white-space: pre;">⁠x = c("Mark", "Pam"); string_magic("Hello {q, C ? x}!")⁠</code> leads to "Hello 'Mark' and 'Pam'!".
</p>
</li>
<li>
<p> format, Format: applies the base R's function <code>base::format()</code> to the string.
By default, the values are left aligned, <em>even numbers</em> (differently from <code>base::format()</code>'s behavior).
The upper case command (<code>Format</code>) applies right alignment. Options: "0", "zero", "right", "center".
Options "0" or "zero" fills the blanks with 0s: useful to format numbers. Option "right" right aligns,
and "center" centers the strings.
Ex: <code style="white-space: pre;">⁠x = c(1, 12345); string_magic("left: {format.0, q, C ? x}, right: {Format, q, C ? x}")⁠</code>
leads to "left: '000001' and '12,345', right: '     1' and '12,345'".
</p>
</li>
<li>
<p> %: applies <code>base::sprintf()</code> formatting. The syntax is 'arg'% with arg an sprintf formatting,
or directly the sprint formatting, e.g. <code style="white-space: pre;">⁠% 5s⁠</code>. Example: <code>string_magic("pi = {%.3f ? pi}")</code> leads
to "pi = 3.142".
</p>
</li>
<li>
<p> stopwords: removes basic English stopwords (the snowball list is used).
The stopwords are replaced with an empty space but the left and right WS are
untouched. So WS normalization may be needed (see operation <code>ws</code>).
<code style="white-space: pre;">⁠x = c("He is tall", "He isn't young"); string_magic("Is he {stop, ws, C ? x}?")⁠</code> leads to "Is he tall and young?".
</p>
</li>
<li>
<p> ascii: turns all letters into ASCII with transliteration. Failed translations
are transformed into question marks. Options: "silent", "utf8". By default, if some conversion fails
a warning is prompted. Option "silent" disables the warning in case of failed conversion. The conversion
is done with <code>base::iconv()</code>, option "utf8" indicates that the source endocing is UTF-8, can be useful
in some cases.
</p>
</li>
<li>
<p> n: formats integers by adding a comma to separate thousands. Options: "letter", "upper", "0", "zero".
The option "letter" writes the number in letters (large numbers keep their numeric format). The option
"upper" is like the option "letter" but uppercases the first letter. Options "0" or "zero" left pads
numeric vectors with 0s. Ex.1: <code style="white-space: pre;">⁠x = 5; string_magic("He's {N ? x} years old.")⁠</code> leads to "He's five years old.".
Ex.2: <code style="white-space: pre;">⁠x = c(5, 12, 52123); string_magic("She owes {n.0, '$'paste, C ? x}.")⁠</code> leads to
"She owes $5, $12 and $52,123.".
</p>
</li>
<li>
<p> N: same as <code>n</code> but automatically adds the option "letter".
</p>
</li>
<li>
<p> nth: when applied to a number, these operators write them as a rank. Options: "letter",
"upper", "compact".
Ex.1: <code style="white-space: pre;">⁠n = c(3, 7); string_magic("They finished {nth, enum ? n}!")⁠</code> leads to "They finished 3rd and 7th!".
Option "letter" tries to write the numbers in letters, but note that it stops at 20. Option "upper"
is the same as "letter" but uppercases the first letter. Option "compact" aggregates
consecutive sequences in the form "start_n_th to end_n_th".
Ex.2: <code>string_magic("They arrived {nth.compact ? 5:20}.")</code> leads to "They arrived 5th to 20th.".
Nth: same as <code>nth</code>, but automatically adds the option "letter". Example:
<code style="white-space: pre;">⁠n = c(3, 7); string_magic("They finished {Nth, enum ? n}!")⁠</code> leads to "They finished third and seventh!".
</p>
</li>
<li>
<p> ntimes: write numbers in the form <code>n</code> times. Options: "letter", "upper". Option
"letter" writes the number in letters (up to 100). Option "upper" does the same as "letter"
and uppercases the first letter. Example: <code>string_magic("They lost {C ! {ntimes ? c(1, 12)} against {S!Real, Barcelona}}.")</code>
leads to "They lost once against Real and 12 times against Barcelona.".
</p>
</li>
<li>
<p> Ntimes: same as <code>ntimes</code> but automatically adds the option "letter".
Example: <code style="white-space: pre;">⁠x = 5; string_magic("This paper was rejected {Ntimes ? x}...")⁠</code> leads to
"This paper was rejected five times...".
</p>
</li>
<li>
<p> firstchar, lastchar: to select the first/last characters of each element.
Ex: <code>string_magic("{19 firstchar, 9 lastchar ! This is a very long sentence}")</code> leads to "very long".
Negative numbers remove the first/last characters.
</p>
</li>
<li>
<p> k: to keep only the first n characters (like <code>firstchar</code> but with more options). The
argument can be of the form <code style="white-space: pre;">⁠'n'k⁠</code>, <code style="white-space: pre;">⁠'n|s'k⁠</code> or <code style="white-space: pre;">⁠'n||s'k⁠</code> with <code>n</code> a number and <code>s</code> a string.
<code>n</code> provides the number of characters to keep. Optionnaly, only for strings whose
length is greater than <code>n</code>, after truncation, the string <code>s</code> can be appended at the end.
The difference between 'n|s' and 'n||s' is that in the second case the strings
will always be of maximum size <code>n</code>, while in the first case they can be of length <code>n + nchar(s)</code>.
Ex: <code>string_magic("{4k ! long sentence}")</code> leads to "long",  <code>string_magic("{'4|..'k ! long sentence}") </code>
leads to "long..", <code>string_magic("{'4||..'k ! long sentence}")</code> leads to "lo..".
</p>
</li>
<li>
<p> fill: fills the character strings up to a size. Options: "right", "center".
Accepts arguments of the form <code>'n'</code> or <code>'n|s'</code>, with <code>n</code> a number and <code>s</code> a symbol.
Default is left-alignment of the strings.
Option "right" right aligns and "center" centers the strings. When using <code>'n|s'</code>, the symbol <code>s</code>
is used for the filling. By default if no argument is provided, the
maximum size of the character string is used. See help for <code>string_fill()</code> for more information.
Ex.1: <code>string_magic("Numbers: {'5|0'fill.right, C ? c(1, 55)}")</code> leads to "Numbers: 00001 and 00055".
</p>
</li>
<li>
<p> paste, append: pastes some character to all elements of the string. This operation has no default.
Options: "both", "right", "front", "back", "delete". By default, a string is pasted on the left.
Option "right" pastes on the right and "both" pastes on both sides. Option "front" only
pastes on the first element while option "back" only pastes on the last element. Option "delete"
first replaces all elements with the empty string.
Example: <code>string_magic("6 = {'|'paste.both, ' + 'c ? -3:-1}")</code> leads to "6 = |-3| + |-2| + |-1|".
The argument can be of the form <code>s</code> or <code>s1|s2</code>. If of the second form, this is equivalent
to chaining two <code>paste</code> operations, once on the left and once on the right: <code style="white-space: pre;">⁠'s1'paste, 's2'paste.right⁠</code>.
</p>
</li>
<li>
<p> join: joins lines ending with a double backslash. Ex: <code>x = "the sun \\\n is shining"</code>;
<code>string_magic("{join ? x}")</code> leads to "the sun is shining".
</p>
</li>
<li>
<p> escape: adds backslashes in front of specific characters. Options <code>"nl"</code>, <code>"tab"</code>.
Option <code>"nl"</code> escapes the newlines (<code style="white-space: pre;">⁠\n⁠</code>), leading them to be displayed as <code>"\\\\n"</code>.
Option <code>"tab"</code> does the same for tabs (<code>"\t"</code>). This is useful to make the value free
of space formatters.
The default behavior is to escape both newlines and tabs.
</p>
</li>
</ul>
<h3>Other operations</h3>


<ul>
<li>
<p> num: converts to numeric. Options: "warn", "soft", "rm", "clear". By default, the conversion
is performed silently and elements that failed to convert are turned into NA.
Option "warns" displays a warning if the conversion to numeric fails.
Option "soft" does not convert if the conversion of at least one element fails.
Option "rm" converts and removes the elements that could not be converted.
Option "clear" turns failed conversions into the empty string, and hence lead to a character vector.
Example: <code style="white-space: pre;">⁠x = c(5, "six"); string_magic("Compare {num, C, q ? x} with {num.rm, C, q ? x}.")⁠</code> leads to
"Compare '5 and NA' with '5'.", and <code>string_magic("Compare {num.soft, C, q ? x} with {clear, C, q ? x}.")</code>
leads to "Compare '5 and six' with '5 and '.".
</p>
</li>
<li>
<p> enum: enumerates the elements. It creates a single string containing the comma
separated list of elements.
If there are more than 7 elements, only the first 6 are shown and the number of
items left is written.
For example <code>string_magic("enum ? 1:5")</code> leads to "1, 2, 3, 4, and 5".
You can add the following options by appending the letter to enum after a dot:
</p>

<ul>
<li>
<p> q, Q, or bq: to quote the elements
</p>
</li>
<li>
<p> or, nor: to finish with an 'or' (or 'nor') instead of an 'and'
</p>
</li>
<li>
<p> comma: to finish the enumeration with ", " instead of ", and".
</p>
</li>
<li>
<p> i, I, a, A, 1: to enumerate with this prefix, like in: i) one, and ii) two
</p>
</li>
<li>
<p> a number: to tell the number of items to display
Ex.1: <code style="white-space: pre;">⁠x = c("Marv", "Nancy"); string_magic("The main characters are {enum ? x}.")⁠</code> leads to
"The main characters are Marv and Nancy.".
Ex.2: <code style="white-space: pre;">⁠x = c("orange", "milk", "rice"); string_magic("Shopping list: {enum.i.q ? x}.")⁠</code> leads to
"Shopping list: i) 'orange', ii) 'milk', and iii) 'rice'."
</p>
</li>
</ul>
</li>
<li>
<p> len: gives the length of the vector. Options "letter", "upper", "num".
Option "letter" writes the length in words (up to 100). Option "upper" is the same
as letter but uppercases the first letter.
By default, commas are added to separate thousands. Use uption "num" to preserve
a regular numeric format.
Example: <code>string_magic("Size = {len ? 1:5000}")</code> leads to "Size = 5,000".
</p>
</li>
<li>
<p> width: formats the string to fit a given width by cutting at word boundaries.
Accepts arguments of the form <code>'n'</code> or <code>'n|s'</code>, with <code>n</code> a number and <code>s</code> a string.
An argument of the form <code>'n|s'</code> will add <code>s</code> at the beginning of each line. Further,
by default a trailing white space is added to <code>s</code>; to remove this
behavior, add an underscore at the end of it.
The argument <code>n</code> is either
an integer giving the target character width (minimum is 15), or it can be a fraction expressing the
target size as a fraction of the current screen. Finally it can be an expression that
uses the variable <code>.sw</code> which will capture the value of the current screen width.
Ex.1: <code>string_magic("{15 width ! this is a long sentence}")</code> leads to "this is a long\nsentence".
Ex.2: <code>string_magic("{15 width.#&gt; ! this is a long sentence}")</code> leads to "#&gt; this is a long\n#&gt; sentence".
</p>
</li>
<li>
<p> difftime: displays a formatted time difference. Option "silent" does not report a warning if the
operation fails. It accepts either objects of class <code>POSIXt</code> or <code>difftime</code>.
Example: <code style="white-space: pre;">⁠x = Sys.time() ; Sys.sleep(0.5) ; string_magic("Time: {difftime ? x}")⁠</code> leads to something
like "Time: 514ms".
</p>
</li>
</ul>
<h3>Group-wise operations</h3>

<p>In <code>string_magic</code>, the splitting operation <code>s</code> (or <code>S</code>) keeps a memory of the strings
that were split. Use the tilde operator, of the form <code style="white-space: pre;">⁠~(op1, op2)⁠</code>, to apply operations
group-wise, to each of the split strings.
</p>
<p>Better with an example. <code>x = c("Oreste, Hermione", "Hermione, Pyrrhus", "Pyrrhus, Andromaque") ;</code>
<code>string_magic("Troubles ahead: {S, ~(' loves 'c), C ? x}.")</code> leads to
"Troubles ahead: Oreste loves Hermione, Hermione loves Pyrrhus and Pyrrhus loves Andromaque.".
</p>
<p>Almost all operations can be applied group-wise (although only operations changing the order or
the length of the strings really matter).
</p>


<h3>Conditional operations</h3>

<p>There are two operators to apply operations conditionally: <code>if</code> and <code>vif</code>, the latter
standing for <em>verbatim if</em>.
</p>
<p>The syntax of <code>if</code> is <code style="white-space: pre;">⁠if(cond ; ops_true ; ops_false)⁠</code> with <code>cond</code> a
condition (i.e. logical operation) on the value being interpolated, <code>ops_true</code> a comma-separated
sequence of operations if the condition is <code>TRUE</code> and <code>ops_false</code> an <em>optional</em> a sequence of
operations if the condition is <code>FALSE</code>.
</p>
<p>Ex.1: Let's take a sentence, delete words of less than 4 characters, and trim
words of 7+ characters.
x = "Songe Cephise a cette nuit cruelle qui fut pour tout un peuple une nuit eternelle"
<code>string_magic("{' 's, if(.nchar&lt;=4 ; nuke ; '7|..'k), c ? x}")</code>.
Let's break it down. First the sentence is split w.r.t. spaces, leading to a vector
of words. Then we use the special variable <code>.nchar</code> in <code>if</code>'s condition to refer
to the number of characters of the current vector (the words). The words with
less than 4 characters are nuked (i.e. removed), and the other words are
trimmed at 7 characters. Finally the modified vector of words is collapsed with
the function <code>c</code>, leading to the result.
</p>
<p>The condition <code>cond</code> accepts the following special values: <code>.</code> (the dot), <code>.nchar</code>, <code>.C</code>, <code>.len</code>, <code>.N</code>.
The dot, <code>.</code>, refers to the current vector. <code>.nchar</code> represent the number of characters
of the current vector (equivalent to <code>nchar(.)</code>). <code>.C</code> is an alias to <code>.nchar</code>.
<code>.len</code> represent the length of the current vector (equivalent to <code>length(.)</code>).
<code>.N</code> is an alias to <code>.len</code>.
</p>
<p>If a condition leads to a result of length 1, then the operations are applied to
the full string vector and not element-wise (as was the case in Ex.1). Contrary to element-wise conditions
for which operations modifying the length of the vectors are forbidden (apart from nuking),
such operations are fine in full-string conditions.
</p>
<p>Ex.2: <code>x = string_magic("x{1:10}")</code>; <code>string_magic("y = {if(.N&gt;4 ; 3 first, '...'insert.right), ' + 'c ? x}")</code>
leads to "y = x1 + x2 + x3 + ...". the same opration applied to <code>x = string_magic("x{1:4}")</code>
leads to "y = x1 + x2 + x3 + x4".
</p>
<p>For <code>vif</code>, the syntax is <code style="white-space: pre;">⁠vif(cond ; verb_true ; verb_false)⁠</code> with <code>verb_true</code>
a verbatim value with which the vector will be replaced if the condition is <code>TRUE</code>.
This is similar for <code>verb_false</code>. The condition works as in <code>if</code>.
</p>
<p>Ex.3: <code style="white-space: pre;">⁠x = c(1, 25, 12, 6) ; string_magic("Values: {vif(.&lt;10 ; &lt;10), C ? x}")⁠</code> leads to
"Values: &lt;10, 25, 12 and &lt;10". As we can see values lower than 10 are replaced
with "&lt;10" while other values are not modified.
</p>
<p>Ex.4: <code>x = string_magic("x{1:10}")</code>; <code>string_magic("y = {vif(.N&gt;4 ; {S!{x[1]}, ..., {last?x}}), ' + 'c ? x}")</code>
leads to "y = x1 + ... + x10".
Let's break it down. If the length of the vector is greater than 4 (here it's 10), then
the full string is replaced with <code>"{S!{x[1]}, ..., {last?x}}"</code>. Interpolation applies to
such string. Hence the split operation <code>S</code> breaks the string w.r.t.
the commas (default behavior), leading to the vector <code>c("{x[1]}", "...", "{last?x}")</code>. Since the
string contains curly brackets, interpolation is applied again. This leads to
the vector <code>c("x1", "...", "x10")</code>. Finally, this vector is collapsed with ' + ' leading
to the final string.
Note that there are many ways to get to the same result. Here is another example:
<code>string_magic("y = {vif(.N&gt;4 ; {x[1]} + ... + {last?x} ; {' + 'c ? x}) ? x}")</code>.
</p>
<p>The <code>vif</code> condition allows the use of '.' to refer to the current value in
<code>verb_true</code> and <code>verb_false</code>, as illustrated by the last example:
</p>
<p>Ex.5: <code>string_magic("{4 last, vif(. %% 2 ; x{.} ; y{rev?.}), C ? 1:11}")</code>
leads to "y10, x9, y8 and x11".
</p>


<h3>Special interpolation</h3>

<p>if-else:
</p>
<p>Using an ampersand ("&amp;") as the first character of an interpolation leads to an <em>if-else</em> operation.
Using two ampersands ("&amp;&amp;") leads to a slightly different operation described at the end of this section.
</p>
<p>The syntax is as follows: <code style="white-space: pre;">⁠{&amp;cond ; verb_true ; verb_false}⁠</code> with <code>cond</code> a
condition (i.e. logical operation) on the value being interpolated, <code>verb_true</code>
a verbatim value with which the vector will be replaced if the condition is <code>TRUE</code> and
<code>verb_false</code> an <em>optional</em> verbatim value with which the vector will be replaced if the condition is <code>FALSE</code>.
If not provided, <code>verb_false</code> is considered to be the empty string unless the operator is
the double ampersand described at the end of this section.
</p>
<p>Note that in <code>cond</code>, you can use the function <code>len</code>, an alias to <code>length</code>.
</p>
<p>Ex.1: <code>x = 1:5</code>; <code>string_magic("x is {&amp;len(x)&lt;10 ; short ; {`log10(.N)-1`times, ''c ! very }long}")</code>
leads to "x is short". With <code>x = 1:50</code>, it leads to "x is long", and to "x is very very long"
if <code>x = 1:5000</code>.
</p>
<p>If a condition leads to a result of length 1, the full string is replaced by the verbatim
expression. Further, this expression will be interpolated if requested. This was the case
in Ex.1 where <code>verb_false</code> was interpolated.
</p>
<p>If the condition's length is greater than 1, then each logical values equal to <code>TRUE</code> is replaced
by <code>verb_true</code>, and <code>FALSE</code> or <code>NA</code> values are replaced with <code>verb_false</code>. Note,
importantly, that <strong>no interpolation is perfomed in that case</strong>.
</p>
<p>Ex.2: <code style="white-space: pre;">⁠x = 1:3 ; string_magic("x is {&amp;x == 2 ; two ; not two}")⁠</code> leads to the vector
<code>c("x is not two", "x is two", "x is not two")</code>.
</p>
<p>In that example, when x is odd, it is replaced with "odd", and when even it is
replaced with the elements of y.
</p>
<p>Using the two ampersand operator ("&amp;&amp;") is like the simple ampersand version but the
default for <code>verb_false</code> is the variable used in the condition itself. So the syntax is
<code style="white-space: pre;">⁠{&amp;&amp;cond ; verb_true}⁠</code> and <em>it does not accept</em> <code>verb_false</code>.
</p>
<p>Ex.3: <code style="white-space: pre;">⁠i = 3 ; string_magic("i = {&amp;&amp;i == 3 ; three}")⁠</code> leads to "i = three", and to "i = 5" if <code>i = 5</code>.
</p>
<p>Pluralization:
</p>
<p>There is advanced support for pluralization which greatly facilitates the writing of messages
in natural language.
</p>
<p>There are two ways to pluralize: over length or over value. To trigger a "pluralization" interpolation
use as first character:
</p>

<ul>
<li> <p><code>$</code> to pluralize over the length of a variable (see Ex.2)
</p>
</li>
<li> <p><code style="white-space: pre;">⁠#⁠</code> to pluralize over the value of a variable (see Ex.1)
</p>
</li>
</ul>
<p>Ex.1: <code style="white-space: pre;">⁠x = 5; string_magic("I bought {N?x} book{#s}.")⁠</code> leads to "I bought five books.".
If <code>x = 1</code>, this leads to "I bought one book.".
</p>
<p>The syntax is <code style="white-space: pre;">⁠{#plural_ops ? variable}⁠</code> or <code style="white-space: pre;">⁠{#plural_ops}⁠</code> where <code>plural_ops</code> are
specific pluralization operations which will be described below.
The pluralization is perfomed <em>always</em> with respect to the value of a variable.
You can either add the variable explicitly (<code style="white-space: pre;">⁠{#plural_ops ? variable}⁠</code>) or refer
to it implicitly (<code style="white-space: pre;">⁠{#plural_ops}⁠</code>). If implicit, then the algorithm will look at the
previous variable that was interpolated and pluralize over it. This is exaclty what happens in
Ex.1 where <code>x</code> was interpolated in <code>{N?x}</code> and plural operation <code>s</code> in <code style="white-space: pre;">⁠{#s}⁠</code> then applied to
<code>x</code>. It was equivalent to have <code style="white-space: pre;">⁠{#s ? x}⁠</code>. If a variable wasn't interpolated before, then
the next interpolated variable will be used (see Ex.2). If no variable is interpolated
at all, an error is thrown.
</p>
<p>Ex.2: <code style="white-space: pre;">⁠x = c("J.", "M."); string_magic("My BFF{$s, are} {C?x}!")⁠</code> leads to "My BFFs are J. and M.!".
If "x = "S.", this leads to "My BFF is S.!".
</p>
<p>Pluralizing accepts the following operations:
</p>

<ul>
<li>
<p> s, es: adds an "s" (or "es") if it is plural (&gt; 1), nothing otherwise. Accepts the option <code>0</code> or <code>zero</code> which
treats a 0-length or a 0-value as plural.
</p>
</li>
<li>
<p> y or ies: adds an 'y' if singular and 'ies' if plural (&gt;1). Accepts the option <code>0</code> or <code>zero</code> which
treats a 0-length or a 0-value as plural.
</p>
</li>
<li>
<p> enum: enumerates the elements (see help for the regular operation <code>enum</code>)
</p>
</li>
<li>
<p> n, N, len, Len: add the number of elements ("len") or the value ("n") of the variable as a formatted number or
in letters (upper case versions). Accepts the options <code>letter</code> (to write in letter)
and <code>upper</code> (to uppercase the first letter).
</p>
</li>
<li>
<p> nth, ntimes: writes the value of the variable as an order (nth) or a frequence (ntimes). Accepts the option <code>letter</code>
to write the numbers in letters (uppercase version of the operator does the same).
</p>
</li>
<li>
<p> is, or any verb: conjugates the verb appropriately
</p>
</li>
</ul>
<p>You can chain operations, in that case a whitespace is automatically added between them.
</p>
<p>Ex.3: <code style="white-space: pre;">⁠x = c(7, 3, 18); string_magic("The winning number{$s, is, enum ? sort(x)}.")⁠</code>
leads to "The winning numbers are 3, 7 and 18.". With <code>x = 7</code> this leads to
"The winning number is 7.".
</p>
<p>On top of the previous operations, there is a special operation allowing to add verbatim text depending on
the situation. The syntax is as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠(s1;s2)⁠</code>: adds verbatim 's1' if singular and 's2' if plural (&gt;1)
</p>
</li>
<li> <p><code style="white-space: pre;">⁠(s1;s2;s3)⁠</code>: adds verbatim 's1' if zero, 's2' if singular (=1) and 's3' if plural
</p>
</li>
<li> <p><code style="white-space: pre;">⁠(s1;;s3)⁠</code>: adds verbatim 's1' if zero, 's3' if singular or plural (i.e. &gt;=1)
</p>
</li>
</ul>
<p>These case-dependent verbatim values <strong>are interpolated</strong> (if appropriate). In these interpolations
you need not refer explicitly to the variable for pluralization interpolations.
</p>
<p>Ex.4: <code style="white-space: pre;">⁠x = 3; string_magic("{#(Sorry, nothing found.;;{#N.upper} match{#es, were} found.)?x}")⁠</code> leads to
"Three matches were found.". If "x = 1", this leads to "One match was found." and if "x = 0" this leads
to "Sorry, nothing found.".
</p>


<h3>Escaping and special cases</h3>

<p>The opening and closing brakets, <code>{}</code>, are special characters and cannot be used as regular text.
To bypass their special meaning, you need to escape them with a double backslash.
</p>
<p>Ex.1: <code>string_magic("open = \\\\{, close = }")</code> leads to <code>"open = {, close = }"</code>.
Ex.2: <code>string_magic("many {5 times.c ! \\\\}}")</code> leads to <code style="white-space: pre;">⁠many }}}}}⁠</code>.
</p>
<p>You only need to escape the special delimiters which the algorithm is currently looking for.
As you can see, you don't need to escape the closing bracket in Ex.1 since no box
was open. On the other hand, you need to escape it in Ex.2.
</p>
<p>Alternatively, use the argument <code>.delim</code> to set custom delimiters.
</p>
<p>Ex.3: <code>string_magic("I {'can {write} {{what}} I want'}")</code> leads to <code>"I can {write} {{what}} I want"</code>.
</p>
<p>Since <code>{expr}</code> evaluates <code>expr</code>, the stuff inside the <em>box</em>, you can pass a
character string and it will stay untouched.
</p>
<p>In the few operations expecting a semi-colon (if-else and pluralization), it can also be
escaped with a double backslash.
</p>
<p>In interpolations, the exclamation mark (<code>!</code>) signals a verbatim expression. But what
if you use it to mean the logical operation <em>not</em> in an operation-free interpolation?
In that case, you need a hack: use a question mark (<code style="white-space: pre;">⁠?⁠</code>) first to indicate to the
algorithm that you want to evaluate the expression.
</p>
<p>Ex.4: <code>string_magic("{!TRUE} is {?!TRUE}")</code> leads to "TRUE is FALSE". The first expression is
taken verbatim while the second is evaluated.
</p>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant <em>"any character"</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".
</p>
<p>The four flags always available are: "ignore", "fixed", "word" and "magic".
</p>

<ul>
<li>
<p> "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)"
at the beginning of the pattern.
</p>
</li>
<li>
<p> "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li>
<p> "word" adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, "word/one, two" is treated as "\b(one|two)\b". Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to " I ambushed?" thanks to the flags "ignore" and "word".
</p>
</li>
<li>
<p> "magic" allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other tools with aliases: 
<code>cat_magic_alias()</code>,
<code>string_clean_alias()</code>,
<code>string_magic_alias()</code>,
<code>string_ops_alias()</code>,
<code>string_vec_alias()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#
# BASIC USAGE ####
#

x = c("Romeo", "Juliet")

# {x} inserts x
string_magic("Hello {x}!")

# elements in ... are collapsed with "" (default)
string_magic("Hello {x[1]}, ",
    "how is {x[2]} doing?")

# Splitting a comma separated string
# The mechanism is explained later
string_vec("J. Mills, David, Agnes, Dr Strong")

# Nota: this is equivalent to (explained later)
string_magic("{', *'S ! J. Mills, David, Agnes, Dr Strong}")

#
# Applying low level operations to strings
#

# Two main syntax:

# A) expression evaluation
# {operation ? x}
#            | |
#            |  \-&gt; the expression to be evaluated
#             \-&gt; ? means that the expression will be evaluated

# B) verbatim
# {operation ! x}
#            | |
#            |  \-&gt; the expression taken as verbatim (here 'x')
#             \-&gt; ! means that the expression is taken as verbatim

# operation: usually 'arg'op with op an operation code.

# Example: splitting
x = "hello dear"
string_magic("{' 's ? x}")
# x is split by ' '

string_magic("{' 's ! hello dear}")
# 'hello dear' is split by ' '
# had we used ?, there would have been an error


# There are 50+ string operators
# Operators usually have a default value
# Operations can have options
# Operations can be chained by separating them with a comma

# Example: default of 's' is ' ' + chaining with collapse
string_magic("{s, ' my 'c ! hello dear}")

#
# Nesting
#

# {operations ! s1{expr}s2}
#             |   |
#             |    \-&gt; expr will be interpolated then added to the string
#              \-&gt; nesting requires verbatim evaluation: '!'

string_magic("The variables are: {C ! x{1:4}}.")

# This one is ugly but it shows triple nesting
string_magic("The variables are: {ws, C ! {2 times ! x{1:4}}{','s, 4 each !  ,_sq}}.")

#
# Splitting
#

# s: split with fixed pattern, default is ' '
string_magic("{s ! a b c}")
string_magic("{' b 's !a b c}")

# S: same as 's' but default is ',[ \t\n]*'
string_magic("{S !a, b, c}")
string_magic("{'[[:punct:] ]+'S ! a! b; c}")

# add regex flags: e.g. fixed search
string_magic("{'f/.'s ! hi.there}")


#
# Collapsing
#

# c and C do the same, their default is different
# syntax: 's1|s2' with
# - s1 the string used for collapsing
# - s2 (optional) the string used for the last collapse

# c: default is ' '
string_magic("{c ? 1:3}")

# C: default is ', | and '
string_magic("{C ? 1:3}")

string_magic("{', | or 'c ? 1:4}")

#
# Extraction
#

# extract: to extract patterns (option first)
# x: alias to extract.first
# X: alias to extract
# syntax: 'pattern'x
# Default is '[[:alnum:]]+'

x = "This years is... 2020"
string_magic("{x ? x}") # similar to string_magic("{extract.first ? x}")
string_magic("{X ? x}") # similar to string_magic("{extract ? x}")

string_magic("{'\\d+'x ? x}")

#
# STRING FORMATTING ####
#

#
# upper, lower, title

# upper case the first letter
string_magic("{upper.first ! julia mills}")

# title case
string_magic("{title ! julia mills}")

# upper all letters
string_magic("{upper ! julia mills}")

# lower case
string_magic("{lower ! JULIA MILLS}")

#
# q, Q, bq: single, double, back quote

string_magic("{S, q, C ! Julia, David, Wilkins}")
string_magic("{S, Q, C ! Julia, David, Wilkins}")
string_magic("{S, bq, C ! Julia, David, Wilkins}")

#
# format, Format: formats the string to fit the same length

# format: the right side is filled with blanks
# Format: the left side is filled with blanks, the string is right aligned

score = c(-10, 2050)
nm = c("Wilkins", "David")
string_magic("Monopoly scores:\n{'\n'c ! - {format ? nm}: {Format ? score} US$}")

# OK that example may have been a bit too complex,
# let's make it simple:

string_magic("Scores: {format ? score}")
string_magic("Names: {Format ? nm}")

#
# ws: white space normalization

# ws: suppresses trimming white spaces + normalizes successive white spaces
# Add the following options in any order to:
# - punct: remove punctuation
# - digit: remove digits
# - isolated: remove isolated characters

string_magic("{ws ! The   white  spaces are now clean.  }")

string_magic("{ws.punct ! I, really -- truly; love punctuation!!!}")

string_magic("{ws.digit ! 1, 2, 12, a microphone check!}")

string_magic("{ws.i ! 1, 2, 12, a microphone check!}")

string_magic("{ws.d.i ! 1, 2, 12, a microphone check!}")

string_magic("{ws.p.d.i ! 1, 2, 12, a microphone check!}")

#
# %: applies sprintf formatting

 # add the formatting as a regular argument
string_magic("pi = {'.2f'% ? pi}")
# or right after the %
string_magic("pi = {%.2f ? pi}")

#
# paste: appends text on each element
# Accepts the options: right, both, front and back
# It accepts the special values :1:, :i:, :I:, :a:, :A: to create enumerations

# adding '|' on both sides
string_magic("{'|'paste.both, ' + 'c ! x{1:4}}")


# Enumerations
acad = string_vec("you like admin, you enjoy working on weekends, you really love emails")
string_magic("Main reasons to pursue an academic career:\n {':i:) 'paste, C ? acad}.")

# You can also use the enum command
string_magic("Main reasons to pursue an academic career:\n {enum.i ? acad}.")

#
# stopwords: removes basic English stopwords
# the list is from the Snowball project:
#  http://snowball.tartarus.org/algorithms/english/stop.txt

string_magic("{stop, ws ! It is a tale told by an idiot, ",
                         "full of sound and fury, signifying nothing.}")

#
# k: keeps the first n characters
# syntax: nk: keeps the first n characters
#         'n|s'k: same + adds 's' at the end of shortened strings
#         'n||s'k: same but 's' counts in the n characters kept

words = string_vec("short, constitutional")
string_magic("{5k ? words}")

string_magic("{'5|..'k ? words}")

string_magic("{'5||..'k ? words}")

#
# K: keeps the first n elements
# syntax: nK: keeps the first n elements
#         'n|s'K: same + adds the element 's' at the end
#         'n||s'K: same but 's' counts in the n elements kept
#
# Special values :rest: and :REST:, give the number of items dropped

bx = string_vec("Pessac Leognan, Saint Emilion, Marguaux, Saint Julien, Pauillac")
string_magic("Bordeaux wines I like: {3K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3|etc..'K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3||etc..'K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3|and at least :REST: others'K, ', 'C ? bx}.")

#
# Ko, KO: special operator which keeps the first n elements and adds "others"
# syntax: nKo
# KO gives the rest in letters

string_magic("Bordeaux wines I like: {4KO, C ? bx}.")

#
# r, R: string replacement 
# syntax: 's'R: deletes the content in 's' (replaces with the empty string)
#         's1 =&gt; s2'R replaces s1 into s2

string_magic("{'e'r, ws ! The letter e is deleted}")

# adding a perl look-behind
string_magic("{'(?&lt;! )e'r !The letter e is deleted}")

string_magic("{'e =&gt; a'r !The letter e becomes a}")

string_magic("{'([[:alpha:]]{3})[[:alpha:]]+ =&gt; \\1.'r ! Trimming the words}")

# Alternative way with simple operations: split, shorten, collapse
string_magic("{s, '3|.'k, c ! Trimming the words}")

#
# times, each
# They accept the option c to collapse with the empty string

string_magic("N{10 times.c ! o}!")

string_magic("{3 times.c ? 1:3}")
string_magic("{3 each.c ? 1:3}")

#
# erase: replaces the items by the empty string
# -&gt; useful in conditions

string_magic("{erase ! I am going to be annihilated}")

#
# ELEMENT MANIPULATION ####
#

#
# rm: removes the elements
# Its (optional) argument is a regular expression giving which element to remove
# Many options: "empty", "blank", "noalpha", "noalnum", "all" 

x = c("Destroy", "All")
string_magic("{'A'rm ? x}")

string_magic("{rm.all ? x}")

x = string_vec("1, 12, 123, 1234, 123456, 1234567")
# we delete elements whose number of characters is lower or equal to 3
# =&gt; see later section CONDITIONS
string_magic("{if(.nchar &gt; 3 ; nuke) ? x}")

#
# PLURALIZATION ####
#

# Two ways to enable pluralization:
# {$ command}: means the plural is decuced from the length of the variable
# {# command}: means the plural is decuced from the value of the variable

# Explanatory example
x = c("Eschyle", "Sophocle", "Euripide")
n = 37
string_magic("The author{$s, enum, have ? x} written {#N ? n} play{#s}.")

x = "Laurent Berge"
n = 0
string_magic("The author{$s, enum, have ? x} written {#N ? n} play{#s}.")

# How does it work?
# First is {$s, enum, have ? x}.
# The commands `s`, `enum` and `have` are applied to `x` which must come after a `?`
#    =&gt; there the plural (whether an s is added and how to conjugate the verb have) depends
#       on the **length** of the vector `x`
#
# Second comes {#N ? n}.
# The double dollar sign means that the command `N` will be applied to the **value** n.
# The value must come after the `?`
#
# Third is {#s}.
# The object to which `s` should be applied is missing (there is no `? n`).
# The default is to apply the command to the previous object. In this case,
#  this is `n`.

# Another similar example illustrating that we need not express the object several times:
x = c("Eschyle", "Sophocle", "Euripide")
string_magic("The {Len ? x} classic author{$s, are, enum}.")



#
# ARGUMENTS FROM THE ENVIRONMENT ####
#

# Arguments can be evaluated from the calling environment.
# Simply use backticks instead of quotes.

dollar = 6
reason = "glory"
string_magic("Why do you develop packages? For {`dollar`times.c ! $}?",
    "For money? No... for {upper,''s, c ? reason}!", .sep = "\n")

#
# Alias generation
#

# Let's create a formula filler
# - we use .local_ops to create the ad hoc operation "add" which adds variables
# - we transform into a formula ex post

fml = string_magic_alias(.post = as.formula, .local_ops = list(add = "' + 'collapse"))

# example with mtcars
lhs = "mpg"
rhs = c("hp", "drat")
fml("{lhs} ~ {add?rhs} + am")
   

</code></pre>


</div>