<div class="container">

<table style="width: 100%;"><tr>
<td>make_spatial_folds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Makes training and testing spatial folds</h2>

<h3>Description</h3>

<p>Applies <code>make_spatial_fold()</code> to every record in a data frame <code>xy.selected</code> to generate as many spatially independent folds over the dataset <code>xy</code> as rows are in <code>xy.selected</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_spatial_folds(
  data = NULL,
  dependent.variable.name = NULL,
  xy.selected = NULL,
  xy = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  training.fraction = 0.75,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy.selected</code></td>
<td>
<p>Data frame with at least three columns: "x" (longitude), "y" (latitude), and "id" (integer, id of the record). Usually a subset of <code>xy</code>. Usually the result of applying <code>thinning()</code> or <code>thinning_til_n()</code> to 'xy' Default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>data frame with at least three columns: "x" (longitude), "y" (latitude), and "id" (integer, index of the record). Default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.step.x</code></td>
<td>
<p>Numeric, distance step used during the growth in the x axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the x coordinates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.step.y</code></td>
<td>
<p>Numeric, distance step used during the growth in the y axis of the buffers defining the training folds. Default: <code>NULL</code> (1/1000th the range of the y coordinates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>training.fraction</code></td>
<td>
<p>numeric, fraction of the data to be included in the growing buffer as training data, Default: <code>0.75</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">⁠%dopar%⁠</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name "cluster" so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">⁠%&gt;%⁠</code> pipe. Default: <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with as many slots as rows are in <code>xy.selected</code>. Each slot has two slots named <code>training</code> and <code>testing</code>, with the former having the indices of the training records selected from xy, and the latter having the indices of the testing records.
</p>


<h3>See Also</h3>

<p><code>make_spatial_fold()</code>, <code>rf_evaluate()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){

 #loading example data
 data(plant_richness_df)

 #getting case coordinates
 xy &lt;- plant_richness_df[, 1:3]
 colnames(xy) &lt;- c("id", "x", "y")

 #thining til 20 cases
 xy.selected &lt;- thinning_til_n(
   xy = xy,
   n = 20
   )

 #making spatial folds centered on these 20 cases
 out &lt;- make_spatial_folds(
   xy.selected = xy.selected,
   xy = xy,
   distance.step = 0.05, #degrees
   training.fraction = 0.6,
   n.cores = 1
 )

 #plotting training and testing folds
 plot(xy[ c("x", "y")], type = "n", xlab = "", ylab = "")
 #plots training points
 points(xy[out[[10]]$training, c("x", "y")], col = "red4", pch = 15)
 #plots testing points
 points(xy[out[[10]]$testing, c("x", "y")], col = "blue4", pch = 15)
 #plots xy.i
 points(xy[10, c("x", "y")], col = "black", pch = 15, cex = 2)

}
</code></pre>


</div>