<div class="container">

<table style="width: 100%;"><tr>
<td>get_split_indexes_from_stratum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate indexes that can be used to split a stratum into two parts</h2>

<h3>Description</h3>

<p><code>get_split_indexes_from_stratum</code> returns a list with indexes for
splitting its <code>stratum</code> argument in two parts. The splits differ at most
by one in size. With default arguments, a random split-half is returned,
which samples elements for each part from <code>stratum</code> without replacement.
Via additional arguments to <code>get_split_indexes_from_stratum</code> a range of
other splitting methods can be applied.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_split_indexes_from_stratum(
  stratum,
  method = c("random", "odd_even", "first_second"),
  replace = FALSE,
  split_p = 0.5,
  subsample_p = 1,
  careful = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>stratum</code></td>
<td>
<p>(data frame, tibble, list, or vector) Object to split;
dataframes and tibbles are counted and split by row. All other data types
are counted and split by element</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(character) Splitting method. Note that <code>first_second</code> and
<code>odd_even</code> splitting method will only deliver a valid split with
default settings for other arguments (<code>subsample_p = 1, split_p = 1,
replace = TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>(logical) If FALSE, splits are constructed by sampling from
stratum without replacement. If TRUE, stratum is sampled with replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_p</code></td>
<td>
<p>(numeric) Desired joint size of both parts, expressed as a
proportion of the size of the subsampled <code>stratum</code>. If <code>split_p</code>
is larger than 1, and <code>careful</code> is FALSE, then parts are automatically
sampled with replacement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subsample_p</code></td>
<td>
<p>(numeric) Subsample a proportion of <code>stratum</code> to be
used in the split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>careful</code></td>
<td>
<p>(boolean) If TRUE, stop with an error when called with
arguments that may yield unexpected splits</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following rounding rules apply to subsample size and split size:
</p>
 <ul>
<li>
<p> If the size of the subsample, calculated as
<code>subsample_p</code> times size of <code>stratum</code>, is a fraction, then
subsample size is rounded up. </p>
</li>
<li>
<p> If the joint size of the two parts,
calculated as 2 * <code>split_p</code> times size of the subsampled <code>stratum</code>,
is a fraction, the part size is rounded up. </p>
</li>
<li>
<p> If the joint size of the
two parts is odd and <code>replace</code> is FALSE, then one of the parts randomly
gets one more element than the other part. </p>
</li>
<li>
<p> If the joint size of the two
parts is odd and <code>replace</code> is TRUE, part size is rounded up to the next
whole number, so each of the splits has the same size. </p>
</li>
</ul>
<h3>Value</h3>

<p>(list) List with two elements that contain indexes that can be used
to split the stratum in two parts two splits of stratum.
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code>apply_split_indexes_to_strata()</code>,
<code>apply_split_indexes_to_stratum()</code>,
<code>check_strata()</code>,
<code>get_split_indexes_from_strata()</code>,
<code>split_df()</code>,
<code>split_strata()</code>,
<code>split_stratum()</code>,
<code>stratify()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Split-half. One of the splits gets 4 elements and the other 5
stratum = letters[1:9]
indexes = get_split_indexes_from_stratum(stratum)
apply_split_indexes_to_stratum(stratum, indexes[[1]], indexes[[2]])
</code></pre>


</div>