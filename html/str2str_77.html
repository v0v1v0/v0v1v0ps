<div class="container">

<table style="width: 100%;"><tr>
<td>v2lv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Atomic) Vector to List of (Atomic) Vectors</h2>

<h3>Description</h3>

<p><code>v2lv</code> converts a (atomic) vector to a list of atomic vectors. The default is
conversion to a list vector where each element of the list has only one element.
The <code>n.break</code> argument allows for the input vector to be broken up into
larger sections with each section being a list element in the return object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">v2lv(v, use.names = TRUE, n.break = 1L, warn.break = TRUE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>(atomic) vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>logical vector of length 1 specifying whether the names from
<code>v</code> should be retained in the return object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.break</code></td>
<td>
<p>integer vector of length 1 specifying how <code>v</code> should be broken
up. Every <code>n.break</code> elements while seq_along <code>v</code>, a new element of the list
is created and subsequent elements of <code>v</code> are stored there. If <code>n.break</code>
is not a multiple of <code>length(v)</code>, then NAs are appended to the end of <code>v</code>
to ensure that each list element has (atomic) vectors of the same length. Note, the
default is 1L resulting in a list vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.break</code></td>
<td>
<p>logical vector of length one specifying whether a warning
should be printed if <code>length(v) / n.break</code> is not a whole number, which
would then result in NAs being appended to the end of the vector before converting
to a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>v</code> is an atomic vector.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Future versions of this function plan to allow for use similar to the <code>utils::relist</code>
function to allow reconstruction after flattening a matrix-like object to a single vector.
</p>


<h3>Value</h3>

<p>list of (atomic) vectors that are the elements of <code>v</code> broken up
according to <code>n.break</code>. The list only has names if <code>v</code> has names and
<code>n.break</code> = 1L.
</p>


<h3>Examples</h3>

<pre><code class="language-R">vec &lt;- setNames(object = mtcars[[1]], nm = row.names(mtcars))
v2lv(vec)
v2lv(vec, use.names = FALSE)
vec &lt;- unlist(mtcars)
v2lv(vec, n.break = 32) # n.break &gt; 1L and multiple of length(v)
v2lv(vec, n.break = 30) # n.break &gt; 1L and NOT multiple of length(v)
</code></pre>


</div>