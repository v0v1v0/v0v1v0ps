<div class="container">

<table style="width: 100%;"><tr>
<td>add_resource</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add a Resource</h2>

<h3>Description</h3>

<p>Define a new resource in a simulation environment. Resources are conceived
with queuing systems in mind, and therefore they comprise two internal
self-managed parts: a <em>server</em>, which is the active part, with a
specified capacity that can be seized and released (see <code>seize</code>);
and a priority <em>queue</em> of a certain size, in which arrivals may wait for
the server to be available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_resource(.env, name, capacity = 1, queue_size = Inf, mon = TRUE,
  preemptive = FALSE, preempt_order = c("fifo", "lifo"),
  queue_size_strict = FALSE, queue_priority = c(0, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.env</code></td>
<td>
<p>the simulation environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>the name of the resource. If several names are provided, several
resources will be defined with the same parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capacity</code></td>
<td>
<p>the capacity of the server, either an integer or a
<code>schedule</code>, so that the value may change during the simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queue_size</code></td>
<td>
<p>the size of the queue, either an integer or a
<code>schedule</code>, so that the value may change during the simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mon</code></td>
<td>
<p>whether the simulator must monitor this resource or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preemptive</code></td>
<td>
<p>whether arrivals in the server can be preempted or not based
on seize priorities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preempt_order</code></td>
<td>
<p>if <code>preemptive=TRUE</code> and several arrivals are
preempted, this parameter defines which arrival should be preempted first.
Either <code>fifo</code> (First In First Out: older preemptible tasks are preempted
first) or <code>lifo</code> (Last In First Out: newer preemptible tasks are
preempted first).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queue_size_strict</code></td>
<td>
<p>whether the <code>queue_size</code> is a hard limit (see
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queue_priority</code></td>
<td>
<p>the priority range required to be able to access the
queue if there is no room in the server (if a single value is provided, it is
treated as the minimum priority). By default, all arrivals can be enqueued.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An entity trying to seize a resource (see <code>seize</code>) may
1) access the server straightaway if there is enough capacity, 2) wait in the
queue if there is no room in the server but there is room in the queue, or 3)
rejected if there is no room in the queue either.
</p>
<p>There are two special situations regarding queue management: 1) the
<code>queue_size</code> is shrinked below the actual number of items waiting, and
2) preemption occurs, and an item previously in the server goes to the queue.
By default in both cases, the excess of items in the queue is allowed.
However, with <code>queue_size_strict=TRUE</code>, the maximum <code>queue_size</code> is
guaranteed, and thus some entities will be rejected (dropped) by the resource.
</p>
<p>Whenever an arrival is rejected (due to a server drop or a queue drop), it
will set the <code>finished</code> flag to <code>FALSE</code> in the output of
<code>get_mon_arrivals</code>. Unfinished arrivals can be handled with a
drop-out trajectory that can be set using the <code>handle_unfinished</code>
activity.
</p>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p>Convenience functions: <code>schedule</code>.
</p>


</div>