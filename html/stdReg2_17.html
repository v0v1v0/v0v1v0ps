<div class="container">

<table style="width: 100%;"><tr>
<td>standardize_parfrailty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regression standardization in shared frailty gamma-Weibull models</h2>

<h3>Description</h3>

<p><code>standardize_parfrailty</code> performs regression standardization in shared frailty
gamma-Weibull models, at specified values of the exposure, over the sample
covariate distribution. Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival
outcome, the exposure, and a vector of covariates, respectively.
<code>standardize_parfrailty</code> fits a parametric frailty model to
estimate the standardized survival function
<code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code>, where <code class="reqn">t</code> is a specific value of
<code class="reqn">T</code>, <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, and the expectation is over
the marginal distribution of <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">standardize_parfrailty(
  formula,
  data,
  values,
  times,
  clusterid,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family = "gaussian",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula which is used to fit the model for the outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>A vector containing the specific values of <code class="reqn">T</code> at
which to estimate the standardized survival function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterid</code></td>
<td>
<p>An optional string containing the name of a cluster identification variable
when data are clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either "plain", which gives untransformed intervals, or "log", which gives
log-transformed intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>standardize_parfrailty</code> fits a shared frailty gamma-Weibull model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|X_{ij},Z_{ij})=\lambda(t_{ij};\alpha,\eta)U_iexp\{h(X_{ij},Z_{ij};\beta)\}</code>
</p>

<p>, with parameterization as described in the help section for
parfrailty. Integrating out the gamma frailty gives the survival
function
</p>
<p style="text-align: center;"><code class="reqn">S(t|X,Z)=[1+\phi\Lambda_0(t;\alpha,\eta)\exp\{h(X,Z;\beta)\}]^{-1/\phi},</code>
</p>

<p>where <code class="reqn">\Lambda_0(t;\alpha,\eta)</code> is the cumulative baseline hazard
</p>
<p style="text-align: center;"><code class="reqn">(t/\alpha)^{\eta}.</code>
</p>
<p> The ML estimates of <code class="reqn">(\alpha,\eta,\phi,\beta)</code>
are used to obtain estimates of the survival function <code class="reqn">S(t|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=[1+\hat{\phi}\Lambda_0(t;\hat{\alpha},\hat{\eta})\exp\{h(X,Z;\hat{\beta})\}]^{-1/\hat{\phi}}.</code>
</p>

<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the
<code>x</code> argument, these estimates are averaged across all subjects (i.e.
all observed values of <code class="reqn">Z</code>) to produce estimates
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n.</code>
</p>
<p> The variance for
<code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula.
</p>


<h3>Value</h3>

<p>An object of class <code>std_surv</code>.
This is basically a list with components estimates and covariance estimates in <code>res</code>
Results for transformations, contrasts, references are stored in <code>res_contrasts</code>.
The output contains estimates for contrasts and confidence intervals for all
combinations of transforms and reference levels.
Obtain numeric results in a data frame with the tidy function.
</p>


<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct)
adjusted survival functions in the literature.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> does not currently handle time-varying exposures or
covariates.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> internally loops over all values in the <code>t</code> argument.
Therefore, the function will usually be considerably faster if
<code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>standardize_coxph</code> does not condition on
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this
matters, note that
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>

<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not
depend on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is independent
of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that
the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance
decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However,
<code class="reqn">\theta(t,x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the
sample distribution for <code class="reqn">Z</code>, and thus the term
<code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> is not 0, unless one conditions on
<code class="reqn">\bar{Z}</code>. The variance calculation by Gail and Byar (1986) ignores this
term, and thus effectively conditions on <code class="reqn">\bar{Z}</code>.
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>,
669-674.
</p>
<p>Dahlqwist E., Pawitan Y., Sjölander A. (2019). Regression standardization
and attributable fraction estimation with between-within frailty models for
clustered survival data. <em>Statistical Methods in Medical Research</em>
<b>28</b>(2), 462-485.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted
survival curves, with applications to testing for no treatment effect.
<em>Biometrical Journal</em> <b>28</b>(5), 587-599.
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>


<h3>Examples</h3>

<pre><code class="language-R">


require(survival)

# simulate data
set.seed(6)
n &lt;- 300
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each = m)
U &lt;- rep(rgamma(n, shape = 1 / phi, scale = phi), each = m)
X &lt;- rnorm(n * m)
# reparameterize scale as in rweibull function
weibull.scale &lt;- alpha / (U * exp(beta * X))^(1 / eta)
T &lt;- rweibull(n * m, shape = eta, scale = weibull.scale)

# right censoring
C &lt;- runif(n * m, 0, 10)
D &lt;- as.numeric(T &lt; C)
T &lt;- pmin(T, C)

# strong left-truncation
L &lt;- runif(n * m, 0, 2)
incl &lt;- T &gt; L
incl &lt;- ave(x = incl, id, FUN = sum) == m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]

fit.std &lt;- standardize_parfrailty(
  formula = Surv(L, T, D) ~ X,
  data = dd,
  values = list(X = seq(-1, 1, 0.5)),
  times = 1:5,
  clusterid = "id"
)
print(fit.std)
plot(fit.std)

</code></pre>


</div>