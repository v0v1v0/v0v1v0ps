<div class="container">

<table style="width: 100%;"><tr>
<td>SparseM.solve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Linear Equation Solving via Cholesky Decomposition for Sparse Matrices</h2>

<h3>Description</h3>

 
<dl>
<dt><code>chol()</code></dt>
<dd>
<p>performs a Cholesky decomposition of a symmetric
positive definite sparse matrix <code>x</code> of class <code>matrix.csr</code>.</p>
</dd>
<dt><code>backsolve()</code></dt>
<dd>
<p>performs a triangular back-fitting to compute
the solutions of a system of linear equations in one step.</p>
</dd>
<dt>
<code>backsolve()</code> and <code>forwardsolve()</code>
</dt>
<dd>
<p>can also split the functionality of
<code>backsolve</code> into two steps.</p>
</dd>
<dt><code>solve()</code></dt>
<dd>
<p>combines <code>chol()</code> and <code>backsolve()</code> to
compute the inverse of a matrix if the right-hand-side is missing.</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">chol(x, ...)
## S4 method for signature 'matrix.csr'
chol(x, pivot = FALSE,
    nsubmax, nnzlmax, tmpmax,
    eps = .Machine$double.eps, tiny = 1e-30, Large = 1e128, warnOnly = FALSE,
    cacheKb = 1024L, level = 8L, ...)

## S4 method for signature 'matrix.csr.chol'
backsolve(r, x, k, upper.tri, transpose,
          twice = TRUE, drop = TRUE, ...)
## S4 method for signature 'matrix.csr.chol'
forwardsolve(l, x, k, upper.tri, transpose)
## S4 method for signature 'matrix.csr'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>symmetric positive definite matrix of class <code>"matrix.csr"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, l</code></td>
<td>
<p>object of class <code>"matrix.csr.chol"</code> as returned by the
<code>chol()</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<dl>
<dt>For <code>chol()</code>:</dt>
<dd>
<p>One of the sparse matrix classes,
<code>"matrix.csr"</code> or <code>"matrix.csc"</code>;</p>
</dd>
<dt>For <code>{back,forward,}solve()</code>:</dt>
<dd>
<p>vector or regular matrix of
right-hand-side(s) of a system of linear equations.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>vector or matrix right-hand-side(s) to solve for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pivot</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsubmax, nnzlmax, tmpmax</code></td>
<td>
<p>positive integer numbers with smart
defaults; do <em>not</em> set unless you know what you are doing!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>positive tolerance for checking symmetry; change with caution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiny</code></td>
<td>
<p>positive tolerance for checking diagonal entries to be
“essentially zero” and hence to be replaced by <code>Large</code>, during
Cholesky decomposition.  Chaning this value may help in close to
singular cases, see ‘Examples’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Large</code></td>
<td>
<p>large positive number, “essentially infinite”, to
replace tiny diagonal entries during Cholesky.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warnOnly</code></td>
<td>
<p><code>logical</code>; when set to true, a result is
returned with a <code>warning</code> instead of an error (via
<code>stop()</code>); notably in close to singular cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cacheKb</code></td>
<td>
<p>a positive integer, specifying an approximate size of the machine's
cache memory in kilo (1024) bytes (‘Kb’); used to be hard wired to 64.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>level of loop unrolling while performing numerical
factorization; an integer in <code>c(1, 2, 4, 8)</code>; used to be hard wired to 8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.tri, transpose</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twice</code></td>
<td>
<p><code>logical</code> flag:  If true, <code>backsolve()</code>
solves twice, see below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p><code>logical</code> flag:  If true, <code>backsolve()</code>
returns <code>drop(.)</code>, i.e., a vector instead of a column-1 matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>chol</code> performs a Cholesky decomposition of
a symmetric positive definite sparse matrix <code>a</code> of class
<code>matrix.csr</code> using the block sparse Cholesky algorithm of Ng and
Peyton (1993).  The structure of the resulting <code>matrix.csr.chol</code>
object is relatively complicated.  If necessary it can be coerced back
to a <code>matrix.csr</code> object as usual with <code>as.matrix.csr</code>.
<code>backsolve</code> does triangular back-fitting to compute
the solutions of a system of linear equations.  For systems of linear equations
that only vary on the right-hand-side, the result from <code>chol</code>
can be reused.  Contrary to the behavior of <code>backsolve</code> in base R,
the default behavior of  <code>backsolve(C,b)</code> when C is a <code>matrix.csr.chol</code> object
is to produce a solution to the system <code class="reqn">Ax = b</code> where <code>C &lt;- chol(A)</code>, see
the example section.  When the flag <code>twice</code> is <code>FALSE</code> then backsolve
solves the system <code class="reqn">Cx = b</code>, up to a permutation  – see the comments below.
The command <code>solve</code> combines <code>chol</code> and <code>backsolve</code>, and will
compute the inverse of a matrix if the right-hand-side is missing.
The determinant of the Cholesky factor is returned providing a
means to efficiently compute the determinant of sparse positive
definite symmetric matrices.
</p>
<p>There are several integer storage parameters that are set by default in the call
to the Cholesky factorization, these can be overridden in any of the above
functions and will be passed by the usual "dots" mechanism.  The necessity
to do this is usually apparent from error messages like:  Error
in local(X...) increase tmpmax.   For example, one can use,
<code>solve(A,b, tmpmax = 100*nrow(A))</code>.  The current default for tmpmax
is <code>50*nrow(A)</code>. Some experimentation may be needed to
select appropriate values, since they are highly problem dependent.  See
the code of chol() for further details on the current defaults.
</p>


<h3>Note</h3>

<p>There is no explicit checking for positive definiteness of the matrix
so users are advised to ensure that this condition is satisfied.
Messages such as "insufficient space" may indicate that one is trying
to factor a singular matrix.
Because the sparse Cholesky algorithm re-orders the positive
definite sparse matrix <code>A</code>, the value of
<code>x &lt;- backsolve(C, b)</code> does <em>not</em> equal the solution to the
triangular system <code class="reqn">Cx = b</code>, but is instead the solution to the
system <code class="reqn">CPx = Pb</code> for some permutation matrix <code class="reqn">P</code>
(and analogously for <code>x &lt;- forwardsolve(C, b)</code>).  However, a
little algebra easily shows that
<code>backsolve(C, forwardsolve(C, b), twice = FALSE)</code> <em>is</em> the solution
to the equation <code class="reqn">Ax=b</code>.  Finally, if <code>C &lt;- chol(A)</code>  for some
sparse covariance matrix <code>A</code>, and z is a conformable standard normal vector,
then the product  <code>y &lt;- as.matrix.csr(C) %*% z</code> is normal with covariance
matrix <code>A</code> irrespective of the permutation of the Cholesky factor.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002)
SparseM: A Sparse Matrix Package for <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>. <a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>
<p>Ng, E. G. and B. W. Peyton (1993)
Block sparse Cholesky algorithms on advanced uniprocessor computers.
<em>SIAM J. Scientific Computing</em> <b>14</b>, 1034–1056.
</p>


<h3>See Also</h3>

<p><code>slm()</code> for a sparse version of <span class="pkg">stats</span> package's <code>lm()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(lsq)
class(lsq) # -&gt; [1] "matrix.csc.hb"
model.matrix(lsq)-&gt;design.o
class(design.o) # -&gt; "matrix.csr"
dim(design.o) # -&gt; [1] 1850  712
y &lt;- model.response(lsq) # extract the rhs
length(y) # [1] 1850

X &lt;- as.matrix(design.o)
c(object.size(X) / object.size(design.o)) ## X is 92.7 times larger

t(design.o) %*% design.o -&gt; XpX
t(design.o) %*% y -&gt; Xpy
chol(XpX) -&gt; chol.o

determinant(chol.o)

b1 &lt;- backsolve(chol.o,Xpy) # least squares solutions in two steps
b2 &lt;- solve(XpX,Xpy)        # least squares estimates in one step
b3 &lt;- backsolve(chol.o, forwardsolve(chol.o, Xpy),
                twice = FALSE) # in three steps
## checking that these three are indeed equal :
stopifnot(all.equal(b1, b2), all.equal(b2, b3))
</code></pre>


</div>