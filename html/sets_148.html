<div class="container">

<table style="width: 100%;"><tr>
<td>outer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Outer Product of Sets (Tuples)</h2>

<h3>Description</h3>

<p>Outer “product” of (g)sets (tuples).</p>


<h3>Usage</h3>

<pre><code class="language-R">set_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
gset_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
cset_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
tuple_outer(X, Y, FUN = "*", ..., SIMPLIFY = TRUE, quote = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X, Y</code></td>
<td>
<p>Set (tuple) objects or vectors. If <code>Y</code> is omitted, <code>X</code>
will be used instead. In this case, <code>FUN</code> can also be specified
as <code>Y</code> for convenience.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function or function name (character string).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SIMPLIFY</code></td>
<td>
<p>Logical. If <code>TRUE</code> and all return values of
<code>FUN</code> are atomic and of length 1, the result will be an atomic
matrix; otherwise, a recursive one (a list with <code>dim</code>
attribute).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quote</code></td>
<td>
<p>logical indicating whether the character strings used for
the row and column names of the returned matrix should
be quoted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the <code>FUN</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function applies <code>FUN</code> to all pairs of elements specified in
<code>X</code> and <code>Y</code>.  Basically intended as a replacement for
<code>outer</code> for sets (tuples), it will also accept any vector for
<code>X</code> and <code>Y</code>.  The return value will be a matrix of dimension
<code>length(X)</code> times <code>length(Y)</code>, atomic or recursive
depending on the complexity of <code>FUN</code>'s return type and the
<code>SIMPLIFY</code> argument.
</p>


<h3>See Also</h3>

<p><code>set</code>, <code>tuple</code>, <code>outer</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set_outer(set(1,2), set(1,2,3), "/")
X &lt;- set_outer(set(1,2), set(1,2,3), pair)
X[[1,1]]
Y &lt;- set_outer(set(1,2), set(1,2,3), set)
Y[[1,1]]
set_outer(2 ^ set(1,2,3), set_is_subset)

tuple_outer(pair(1,2), triple(1,2,3))
tuple_outer(1:5, 1:4, "^")
</code></pre>


</div>