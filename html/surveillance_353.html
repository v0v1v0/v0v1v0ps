<div class="container">

<table style="width: 100%;"><tr>
<td>hhh4_simulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate <code>"hhh4"</code> Count Time Series</h2>

<h3>Description</h3>

<p>Simulates a multivariate time series of counts based on the
Poisson/Negative Binomial model as described in Paul and Held (2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'hhh4'
simulate(object, nsim = 1, seed = NULL, y.start = NULL,
         subset = 1:nrow(object$stsObj), coefs = coef(object),
         components = c("ar","ne","end"), simplify = nsim&gt;1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object of class <code>"hhh4"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>number of time series to simulate. Defaults to <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>an object specifying how the random number generator should be
initialized for simulation (via <code>set.seed</code>). The
initial state will also be stored as an attribute <code>"seed"</code> of
the result. The original state of the <code>.Random.seed</code>
will be restored at the end of the simulation.
By default (<code>NULL</code>), neither initialization nor recovery will
be done.
This behaviour is copied from the <code>simulate.lm</code> method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.start</code></td>
<td>

<p>vector or matrix (with <code>ncol(object$stsObj)</code> columns) with
starting counts for the epidemic components. 
If <code>NULL</code>, the observed means in the respective units of the
data in <code>object</code> during <code>subset</code> are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>time period in which to simulate data. Defaults to (and cannot
exceed) the whole period defined by the underlying <code>"sts"</code>
object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>

<p>coefficients used for simulation from the model in <code>object</code>.
Default is to use the fitted parameters.
Note that the <code>coefs</code>-vector must be in the same order and
scaling as <code>coef(object)</code>, which especially means
<code>reparamPsi = TRUE</code> (as per default when using the
<code>coef</code>-method to extract the parameters).
The overdispersion parameter in <code>coefs</code> is the inverse of the
dispersion parameter <code>size</code> in <code>rnbinom</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>components</code></td>
<td>

<p>character vector indicating which components of the fitted model
<code>object</code> should be active during simulation. For instance,
a simulation with <code>components="end"</code> is solely based on the
fitted endemic mean.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>

<p>logical indicating if only the simulated counts (<code>TRUE</code>) or the
full <code>"sts"</code> object (<code>FALSE</code>) should be
returned for every replicate.
By default a full <code>"sts"</code> object is returned iff <code>nsim=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>unused (argument of the generic).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Simulates data from a Poisson or a Negative Binomial model
with mean
</p>
<p style="text-align: center;"><code class="reqn">\mu_{it} = \lambda_{it} y_{i,t-1} + 
                   \phi_{it} \sum_{j \neq i} w_{ji} y_{j,t-1} + 
                   \nu_{it}</code>
</p>

<p>where
<code class="reqn">\lambda_{it}&gt;0</code>, <code class="reqn">\phi_{it}&gt;0</code>, and <code class="reqn">\nu_{it}&gt;0</code> are 
parameters which are modelled parametrically.
The function uses the model and parameter estimates of the fitted
<code>object</code> to simulate the time series.
</p>
<p>With the argument <code>coefs</code> it is possible to simulate from  
the model as specified in <code>object</code>, but with different 
parameter values.
</p>


<h3>Value</h3>

<p>If <code>simplify=FALSE</code>: an object of class
<code>"sts"</code> (<code>nsim = 1</code>) or a list of those
(<code>nsim &gt; 1</code>).
</p>
<p>If <code>simplify=TRUE</code>: an object of class
<code>"hhh4sims"</code>, which is an array of dimension
<code>c(length(subset), ncol(object$stsObj), nsim)</code>.
The originally observed counts during the simulation period,
<code>object$stsObj[subset,]</code>, are attached for reference
(used by the <code>plot</code>-methods) as an attribute <code>"stsObserved"</code>,
and the initial condition <code>y.start</code> as attribute <code>"initial"</code>.
The <code>[</code>-method for <code>"hhh4sims"</code> takes care of subsetting
these attributes appropriately.
</p>


<h3>Author(s)</h3>

<p>Michaela Paul and Sebastian Meyer
</p>


<h3>References</h3>

<p>Paul, M. and Held, L. (2011) Predictive assessment of a non-linear
random  effects model for multivariate time series of infectious
disease counts. Statistics in Medicine, <b>30</b>, 1118â€“1136
</p>


<h3>See Also</h3>

<p><code>plot.hhh4sims</code> and <code>scores.hhh4sims</code>
and the examples therein for <code>nsim &gt; 1</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(influMen)
# convert to sts class and extract meningococcal disease time series
meningo &lt;- disProg2sts(influMen)[,2]

# fit model
fit &lt;- hhh4(meningo, control = list(
              ar = list(f = ~ 1),
              end = list(f = addSeason2formula(~1, period = 52)),
              family = "NegBin1"))
plot(fit)

# simulate from model (generates an "sts" object)
simData &lt;- simulate(fit, seed=1234)

# plot simulated data
plot(simData, main = "simulated data", xaxis.labelFormat=NULL)

# use simplify=TRUE to return an array of simulated counts
simCounts &lt;- simulate(fit, seed=1234, simplify=TRUE)
dim(simCounts)  # nTime x nUnit x nsim

# plot the first year of simulated counts (+ initial + observed)
plot(simCounts[1:52,,], type = "time", xaxis.labelFormat = NULL)
# see help(plot.hhh4sims) for other plots, mainly useful for nsim &gt; 1

# simulate from a Poisson instead of a NegBin model
# keeping all other parameters fixed at their original estimates
coefs &lt;- replace(coef(fit), "overdisp", 0)
simData2 &lt;- simulate(fit, seed=123, coefs = coefs)
plot(simData2, main = "simulated data: Poisson model", xaxis.labelFormat = NULL)

# simulate from a model with higher autoregressive parameter
coefs &lt;- replace(coef(fit), "ar.1", log(0.9))
simData3 &lt;- simulate(fit, seed=321, coefs = coefs)
plot(simData3, main = "simulated data: lambda = 0.5", xaxis.labelFormat = NULL)


## more sophisticated: simulate beyond initially observed time range

# extend data range by one year (non-observed domain), filling with NA values
nextend &lt;- 52
timeslots &lt;- c("observed", "state", "alarm", "upperbound", "populationFrac")
addrows &lt;- function (mat, n) mat[c(seq_len(nrow(mat)), rep(NA, n)),,drop=FALSE]
extended &lt;- Map(function (x) addrows(slot(meningo, x), n = nextend), x = timeslots)
# create new sts object with extended matrices
meningo2 &lt;- do.call("sts", c(list(start = meningo@start, frequency = meningo@freq,
                                  map = meningo@map), extended))

# fit to the observed time range only, via the 'subset' argument
fit2 &lt;- hhh4(meningo2, control = list(
              ar = list(f = ~ 1),
              end = list(f = addSeason2formula(~1, period = 52)),
              family = "NegBin1",
              subset = 2:(nrow(meningo2) - nextend)))
# the result is the same as before
stopifnot(all.equal(fit, fit2, ignore = c("stsObj", "control")))

# long-term probabilistic forecast via simulation for non-observed time points
meningoSim &lt;- simulate(fit2, nsim = 100, seed = 1,
                       subset = seq(nrow(meningo)+1, nrow(meningo2)),
                       y.start = tail(observed(meningo), 1))
apply(meningoSim, 1:2, function (ysim) quantile(ysim, c(0.1, 0.5, 0.9)))
# three plot types are available for "hhh4sims", see also ?plot.hhh4sims
plot(meningoSim, type = "time", average = median)
plot(meningoSim, type = "size", observed = FALSE)
if (requireNamespace("fanplot"))
    plot(meningoSim, type = "fan", means.args = list(),
         fan.args = list(ln = c(.1,.9), ln.col = 8))
</code></pre>


</div>