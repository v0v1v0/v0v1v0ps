<div class="container">

<table style="width: 100%;"><tr>
<td>simex</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Measurement error in models using SIMEX</h2>

<h3>Description</h3>

<p>Implementation of the SIMEX algorithm for measurement error models according to Cook and Stefanski
</p>


<h3>Usage</h3>

<pre><code class="language-R">simex(model, SIMEXvariable, measurement.error, lambda = c(0.5, 1, 1.5,
  2), B = 100, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE)

## S3 method for class 'simex'
plot(x, xlab = expression((1 + lambda)),
  ylab = colnames(b)[-1], ask = FALSE, show = rep(TRUE, NCOL(b) - 1),
  ...)

## S3 method for class 'simex'
predict(object, newdata, ...)

## S3 method for class 'simex'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'summary.simex'
print(x, digits = max(3, getOption("digits") -
  3), ...)

## S3 method for class 'simex'
refit(object, fitting.method = "quadratic",
  jackknife.estimation = "quadratic", asymptotic = TRUE, ...)

## S3 method for class 'simex'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the naive model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SIMEXvariable</code></td>
<td>
<p>character or vector of characters containing the names of the variables with measurement error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurement.error</code></td>
<td>
<p>given standard deviations of measurement errors. In
case of homoskedastic measurement error it is a matrix with dimension
1x<code>length(SIMEXvariable)</code>. In case of heteroskedastic error for at least one
SIMEXvariable it is a matrix of dimension nx</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>vector of lambdas for which the simulation step should be done (without 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>number of iterations for each lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitting.method</code></td>
<td>
<p>fitting method for the extrapolation. <code>linear</code>, <code>quadratic</code>,
<code>nonlinear</code> are implemented. (first 4 letters are enough)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jackknife.estimation</code></td>
<td>
<p>specifying the extrapolation method for jackknife
variance estimation. Can be set to <code>FALSE</code> if it should not be performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asymptotic</code></td>
<td>
<p>logical, indicating if asymptotic variance estimation should
be done, in the naive model the option <code>x = TRUE</code> has to be set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class 'simex'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>optional name for the X-Axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>vector containing the names for the Y-Axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>logical. If <code>TRUE</code>, the user is asked for input, before a new figure is drawn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show</code></td>
<td>
<p>vector of logicals indicating for wich variables a plot should be produced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to other functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>of class 'simex'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>optionally, a data frame in which to look for
variables with which to predict. If omitted, the fitted linear predictors are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of digits to be printed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Nonlinear is implemented as described in Cook and Stefanski, but is numerically
instable. It is not advisable to use this feature. If a nonlinear extrapolation
is desired please use the <code>refit()</code> method.
</p>
<p>Asymptotic is only implemented for naive models of class <code>lm</code> or <code>glm</code> with homoscedastic measurement error.
</p>
<p><code>refit()</code> refits the object with a different extrapolation function.
</p>


<h3>Value</h3>

<p>An object of class 'simex' which contains:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the corrected coefficients of the SIMEX model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SIMEX.estimates</code></td>
<td>
<p>the estimates for every lambda,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the naive model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurement.error</code></td>
<td>
<p>the known error standard deviations,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>the number of iterations,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrapolation</code></td>
<td>
<p>the model object of the extrapolation step,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitting.method</code></td>
<td>
<p>the fitting method used in the extrapolation step,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the residuals of the main model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted values of the main model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.jackknife</code></td>
<td>
<p>the jackknife variance estimate,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrapolation.variance</code></td>
<td>
<p>the model object of the variance extrapolation,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.jackknife.lambda</code></td>
<td>
<p>the data set for the extrapolation,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.asymptotic</code></td>
<td>
<p>the asymptotic variance estimates,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the estimates for every B and lambda,</p>
</td>
</tr>
</table>
<p>...
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot</code>: Plot the simulation and extrapolation step
</p>
</li>
<li> <p><code>predict</code>: Predict using simex correction
</p>
</li>
<li> <p><code>print</code>: Print simex nicely
</p>
</li>
<li> <p><code>print</code>: Print summary nicely
</p>
</li>
<li> <p><code>refit</code>: Refits the model with a different extrapolation function
</p>
</li>
<li> <p><code>summary</code>: Summary of simulation and extrapolation
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Wolfgang Lederer,<a href="mailto:wolfgang.lederer@gmail.com">wolfgang.lederer@gmail.com</a>
</p>
<p>Heidi Seibold,<a href="mailto:heidi.bold@gmail.com">heidi.bold@gmail.com</a>
</p>


<h3>References</h3>

<p>Cook, J.R. and Stefanski, L.A. (1994) Simulation-extrapolation estimation in
parametric measurement error models. <em>Journal of the American Statistical
Association</em>, <b>89</b>, 1314 – 1328
</p>
<p>Carroll, R.J., Küchenhoff, H., Lombard, F. and Stefanski L.A. (1996) Asymptotics
for the SIMEX estimator in nonlinear measurement error models. <em>Journal
of the American Statistical Association</em>, <b>91</b>, 242 – 250
</p>
<p>Carrol, R.J., Ruppert, D., Stefanski, L.A. and Crainiceanu, C. (2006).
<em>Measurement error in nonlinear models: A modern perspective.</em>, Second
Edition. London: Chapman and Hall.
</p>
<p>Lederer, W. and Küchenhoff, H. (2006) A short introduction to the SIMEX and MCSIMEX. <em>R News</em>, <b>6(4)</b>, 26–31
</p>


<h3>See Also</h3>

<p><code>mcsimex</code> for discrete data with misclassification,
<code>lm</code>, <code>glm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Seed
set.seed(49494)

## simulating the measurement error standard deviations
sd_me &lt;- 0.3
sd_me2 &lt;- 0.4
temp &lt;- runif(100, min = 0, max = 0.6)
sd_me_het1 &lt;- sort(temp)
temp2 &lt;- rnorm(100, sd = 0.1)
sd_me_het2 &lt;- abs(sd_me_het1 + temp2)

## simulating the independent variables x (real and with measurement error):

x_real &lt;- rnorm(100)
x_real2 &lt;- rpois(100, lambda = 2)
x_real3 &lt;- -4*x_real + runif(100, min = -10, max = 10)  # correlated to x_real

x_measured &lt;- x_real + sd_me * rnorm(100)
x_measured2 &lt;- x_real2 + sd_me2 * rnorm(100)
x_het1 &lt;- x_real + sd_me_het1 * rnorm(100)
x_het2 &lt;- x_real3 + sd_me_het2 * rnorm(100)

## calculating dependent variable y:
y &lt;- x_real + rnorm(100, sd = 0.05)
y2 &lt;- x_real + 2*x_real2 + rnorm(100, sd = 0.08)
y3 &lt;- x_real + 2*x_real3 + rnorm(100, sd = 0.08)

### one variable with homoscedastic measurement error
(model_real &lt;- lm(y ~ x_real))

(model_naiv &lt;- lm(y ~ x_measured, x = TRUE))

(model_simex &lt;- simex(model_naiv, SIMEXvariable = "x_measured", measurement.error = sd_me))
plot(model_simex)

### two variables with homoscedastic measurement errors
(model_real2 &lt;- lm(y2 ~ x_real + x_real2))
(model_naiv2 &lt;- lm(y2 ~ x_measured + x_measured2, x = TRUE))
(model_simex2 &lt;- simex(model_naiv2, SIMEXvariable = c("x_measured", "x_measured2"),
         measurement.error = cbind(sd_me, sd_me2)))

plot(model_simex2)

## Not run: 
### one variable with increasing heteroscedastic measurement error
model_real

(mod_naiv1 &lt;- lm(y ~ x_het1, x = TRUE))
(mod_simex1 &lt;- simex(mod_naiv1, SIMEXvariable = "x_het1",
                measurement.error = sd_me_het1, asymptotic = FALSE))

plot(mod_simex1)

### two correlated variables with heteroscedastic measurement errors
(model_real3 &lt;- lm(y3 ~ x_real + x_real3))
(mod_naiv2 &lt;- lm(y3 ~ x_het1 + x_het2, x = TRUE))
(mod_simex2 &lt;- simex(mod_naiv2, SIMEXvariable = c("x_het1", "x_het2"),
              measurement.error = cbind(sd_me_het1, sd_me_het2), asymptotic = FALSE))

plot(mod_simex2)

### two variables, one with homoscedastic, one with heteroscedastic measurement error
model_real2
(mod_naiv3 &lt;- lm(y2 ~ x_measured + x_het2, x = TRUE))
(mod_simex3 &lt;- simex(mod_naiv3, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

### glm: two variables, one with homoscedastic, one with heteroscedastic measurement error
t &lt;- x_real + 2*x_real2 + rnorm(100, sd = 0.01)
g &lt;- 1 / (1 + exp(t))
u &lt;- runif(100)
ybin &lt;- as.numeric(u &lt; g)

(logit_real &lt;- glm(ybin ~ x_real + x_real2, family = binomial))
(logit_naiv &lt;- glm(ybin ~ x_measured + x_het2, x = TRUE, family = binomial))
(logit_simex &lt;- simex(logit_naiv, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

summary(logit_simex)
print(logit_simex)
plot(logit_simex)

### polr: two variables, one with homoscedastic, one with heteroscedastic measurement error

if(require("MASS")) {# Requires MASS
yerr &lt;- jitter(y, amount=1)
yfactor &lt;- cut(yerr, 3, ordered_result=TRUE)

(polr_real &lt;- polr(yfactor ~ x_real + x_real2))
(polr_naiv &lt;- polr(yfactor ~ x_measured + x_het2, Hess = TRUE))
(polr_simex &lt;- simex(polr_naiv, SIMEXvariable = c("x_measured", "x_het2"),
                    measurement.error = cbind(sd_me, sd_me_het2), asymptotic = FALSE))

summary(polr_simex)
print(polr_simex)
plot(polr_simex)
}

## End(Not run)

</code></pre>


</div>