<div class="container">

<table style="width: 100%;"><tr>
<td>sk_var_mult</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiply a vector by a power of the covariance matrix</h2>

<h3>Description</h3>

<p>Computes <code>W %*% z</code>, where <code>z</code> is the vector of non-NA data in <code>g</code>,
and <code>W</code> is the <code>p</code>th power of <code>V</code>, the covariance matrix for <code>z</code>. By default,
<code>p=-1</code>, so the function computes products with the inverse covariance matrix.
Alternatively, <code>out='quad'</code> computes the quadratic form <code>t(z) %*% W %*% z</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_var_mult(g, pars, fac_method = "eigen", fac = NULL, quad = FALSE, p = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a sk grid object or (if fac supplied) numeric vector or matrix of non-NA data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>list of form returned by <code>sk_pars</code> (with entries 'y', 'x', 'eps', 'psill')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac_method</code></td>
<td>
<p>either 'eigen' (the default) or 'chol'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>factorization of scaled covariance matrix of z (V divided by psill)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad</code></td>
<td>
<p>logical, if TRUE the function returns the quadratic form <code>t(z) %*% V_inv %*% z</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>numeric, the matrix power of V^p to multiply (ignored when <code>method=='chol'</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>fac_method</code> specifies the covariance matrix factorization to use: either 'chol'
(Cholesky factorization), which only supports <code>p=-1</code>; or 'eigen' (eigen-decomposition),
which supports any integer or numeric power for <code>p</code>. By default, the 'eigen' method
is used, unless a Cholesky decomposition (matrix) is passed in <code>fac</code>.
</p>
<p>The 'eigen' method is required when <code>g</code> has complete data (ie no NA values). Note
that the structure of any supplied <code>fac</code> overrules the <code>fac_method</code> argument, so if your
<code>g</code> is complete and you supply the Cholesky decomposition, the function will halt with
an error even if you have set <code>fac_method='eigen'</code>.
</p>
<p>factorization is often the slow part of the computations, so we allow it to be pre-computed
using <code>sk_var(..., scaled=TRUE)</code> and passed in argument <code>fac</code>.
This must be the factorization of the covariance matrix after dividing by the partial sill
(see <code>?sk_var</code>); either the lower Cholesky factor (eg the transposed output of
<code>base::chol</code>), or a list of eigen-vectors and eigen-values (eg. the output of <code>base::eigen</code>).
In the separable case, the eigen-decomposition is done on each of the x and y components
separately, and <code>fac</code> should be a list with elements 'x' and 'y', each one a list of
eigen-vectors and eigen-values.
</p>
<p>When a factorization is supplied, all entries in <code>pars</code>, except for <code>psill</code>, are ignored,
as they are baked into the factorization already. <code>g</code> can in this case be a numeric vector
or matrix, containing one or more layers of observed data, with <code>NA</code>s omitted.
</p>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>sk base::eigen base::chol
</p>
<p>Other internal variance-related functions: 
<code>sk_corr_mat()</code>,
<code>sk_corr()</code>,
<code>sk_toep_mult()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># relative error comparing output x to reference y
rel_err = \(x, y) ifelse(y == 0, 0, abs( (x - y) / y ) )

# define example grid and data
gdim = c(10, 15)
g = sk(gdim)
n = length(g)
g[] = stats::rnorm(n)

# define covariance parameters
pars = utils::modifyList(sk_pars(g, 'gau'), list(psill=2, eps=0.5))

# COMPLETE CASE

# compute the full covariance matrix
V = sk_var(g, pars, sep=FALSE)
V_inv = chol2inv(chol(V))
out_reference = V_inv %*% g[]
out_reference_quad = t(g[]) %*% out_reference
max( rel_err(sk_var_mult(g, pars), out_reference) )
rel_err(sk_var_mult(g, pars, quad=TRUE), out_reference_quad)

# pre-computed factorization on separable components of correlation matrix
fac_corr = sk_var(utils::modifyList(g, list(gval=NULL)), pars, fac_method='eigen', sep=TRUE)
max( rel_err(sk_var_mult(g, pars, fac=fac_corr), out_reference) )
rel_err(sk_var_mult(g, pars, fac=fac_corr, quad=TRUE), out_reference_quad)

# matrix powers
out_reference = V %*% g[]
max( rel_err(sk_var_mult(g, pars, fac_method='eigen', p=1), out_reference) )
rel_err(sk_var_mult(g, pars, fac_method='eigen', p=1, quad=TRUE), t(g[]) %*% out_reference)

# INCOMPLETE CASE

n_sample = floor(n/10)
idx_sampled = sort(sample.int(n, n_sample))
g_miss = sk(gdim)
g_miss[idx_sampled] = g[idx_sampled]
V = sk_var(g_miss, pars)
sk_plot(V)

# correctness check (eigen used by default)
z = matrix(g[idx_sampled], ncol=1)
V_inv = chol2inv(chol(V))
out_reference = (V_inv %*% z)
out_reference_quad = t(z) %*% out_reference
max(rel_err(sk_var_mult(g_miss, pars), out_reference))
rel_err(sk_var_mult(g_miss, pars, quad=TRUE), out_reference_quad)

# check non-default Cholesky method
max( rel_err(sk_var_mult(g_miss, pars, fac_method='chol'), out_reference) )
rel_err(sk_var_mult(g_miss, pars, quad=TRUE, fac_method='chol'), out_reference_quad)

# supply data as a vector instead of list by pre-computing factorization
fac_chol = sk_var(g_miss, pars, scaled=TRUE, fac_method='chol')
fac_eigen = sk_var(g_miss, pars, scaled=TRUE, fac_method='eigen')
max(rel_err(sk_var_mult(z, pars, fac=fac_chol), out_reference))
max(rel_err(sk_var_mult(g_miss, pars, fac=fac_eigen), out_reference))
rel_err(sk_var_mult(z, pars, fac=fac_chol, quad=TRUE), out_reference_quad)
rel_err(sk_var_mult(g_miss, pars, fac=fac_eigen, quad=TRUE), out_reference_quad)

# matrix powers in eigen mode
out_reference = V %*% z
max(rel_err(sk_var_mult(g_miss, pars, p=1), out_reference))
rel_err(sk_var_mult(g_miss, pars, p=1, quad=TRUE), t(z) %*% out_reference)
max(rel_err(sk_var_mult(g_miss, pars, p=2), V %*% out_reference))

# verify that multiplying g_miss twice by a square root of V is same as multiplying by V
g_miss_sqrt = g_miss
g_miss_sqrt[!is.na(g_miss)] = sk_var_mult(g_miss, pars, p=1/2)
max( rel_err(sk_var_mult(g_miss_sqrt, pars, p=1/2), out_reference) )

</code></pre>


</div>