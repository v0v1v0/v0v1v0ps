<div class="container">

<table style="width: 100%;"><tr>
<td>A_theta_x</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surface area of the intersection of two hyperspherical caps</h2>

<h3>Description</h3>

<p>Computation of
</p>
<p style="text-align: center;"><code class="reqn">A_x(\theta_{ij}) := \frac{1}{\omega_p}
\int_{S^{p - 1}} 1_{\{{\bf X}_i'\boldsymbol\gamma \le x,
{\bf X}_j'\boldsymbol\gamma \le x\}}\,\mathrm{d}\boldsymbol\gamma,</code>
</p>

<p>where <code class="reqn">\theta_{ij} := \cos^{-1}({\bf X}_i'{\bf X}_j)
\in [0, \pi]</code>,
<code class="reqn">x \in [-1, 1]</code>, and <code class="reqn">\omega_{p}</code> is the surface area of
<code class="reqn">S^{p - 1}</code>. <code class="reqn">A_x(\theta_{ij})</code> is the proportion of surface area
of <code class="reqn">S^{p - 1}</code> covered by the intersection of two hyperspherical caps
centered at <code class="reqn">{\bf X}_i</code> and <code class="reqn">{\bf X}_j</code> and with
common solid angle <code class="reqn">\pi - \cos^{-1}(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">A_theta_x(theta, x, p, N = 160L, as_matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector with values in <code class="reqn">[0, \pi]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector with values in <code class="reqn">[-1, 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of points used in the
Gauss-Legendre quadrature. Defaults to
<code>160</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_matrix</code></td>
<td>
<p>return a matrix with the values of <code class="reqn">A_x(\theta)</code> on
the grid formed by <code>theta</code> and <code>x</code>? If <code>FALSE</code>,
<code class="reqn">A_x(\theta)</code> is evaluated on <code>theta</code> and <code>x</code> if they equal
in size. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See García-Portugués et al. (2023) for more details about the
<code class="reqn">A_x(\theta)</code> function.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(length(theta), length(x))</code> containing the
evaluation of <code class="reqn">A_x(\theta)</code> if <code>as_matrix = TRUE</code>. Otherwise,
a vector of size <code>c(length(theta)</code> if <code>theta</code> and <code>x</code> equal
in size.
</p>


<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181–204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Plot A_x(theta) for several dimensions and x's
A_lines &lt;- function(x, th = seq(0, pi, l = 200)) {

  plot(th, A_theta_x(theta = th, x = x, p = 2), type = "l",
       col = 1, ylim = c(0, 1.25), main = paste("x =", x),
       ylab = expression(A[x](theta)),
       xlab = expression(theta), axes = FALSE)
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  abline(h = c(0, 1), lty = 2)
  lines(th, A_theta_x(theta = th, x = x, p = 3), col = 2)
  lines(th, A_theta_x(theta = th, x = x, p = 4), col = 3)
  lines(th, A_theta_x(theta = th, x = x, p = 5), col = 4)
  legend("top", lwd = 2, legend = paste("p =", 2:5),
         col = 1:4, cex = 0.75, horiz = TRUE)

}
old_par &lt;- par(mfrow = c(2, 3))
A_lines(x = -0.75)
A_lines(x = -0.25)
A_lines(x = 0)
A_lines(x = 0.25)
A_lines(x = 0.5)
A_lines(x = 0.75)
par(old_par)

# As surface of (theta, x) for several dimensions
A_surf &lt;- function(p, x = seq(-1, 1, l = 201), th = seq(0, pi, l = 201)) {

  col &lt;- c("white", viridisLite::viridis(20))
  breaks &lt;- c(-1, seq(1e-15, 1, l = 21))
  A &lt;- A_theta_x(theta = th, x = x, p = p)
  image(th, x, A, main = paste("p =", p), col = col, breaks = breaks,
        xlab = expression(theta), axes = FALSE)
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  contour(th, x, A, levels = breaks, add = TRUE)

}
old_par &lt;- par(mfrow = c(2, 2))
A_surf(p = 2)
A_surf(p = 3)
A_surf(p = 4)
A_surf(p = 5)
par(old_par)

# No matrix return
th &lt;- seq(0, pi, l = 5)
x &lt;- seq(-1, 1, l = 5)
diag(A_theta_x(theta = th, x = x, p = 2))
A_theta_x(theta = th, x = x, p = 2, as_matrix = FALSE)
</code></pre>


</div>