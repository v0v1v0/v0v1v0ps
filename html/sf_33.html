<div class="container">

<table style="width: 100%;"><tr>
<td>tidyverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tidyverse methods for sf objects</h2>

<h3>Description</h3>

<p>Tidyverse methods for sf objects. Geometries are sticky, use as.data.frame to let <code>dplyr</code>'s own methods drop them.
Use these methods after loading the tidyverse package with the generic (or after loading package tidyverse).
</p>


<h3>Usage</h3>

<pre><code class="language-R">filter.sf(.data, ..., .dots)

arrange.sf(.data, ..., .dots)

group_by.sf(.data, ..., add = FALSE)

ungroup.sf(x, ...)

rowwise.sf(x, ...)

mutate.sf(.data, ..., .dots)

transmute.sf(.data, ..., .dots)

select.sf(.data, ...)

rename.sf(.data, ...)

rename_with.sf(.data, .fn, .cols, ...)

slice.sf(.data, ..., .dots)

summarise.sf(.data, ..., .dots, do_union = TRUE, is_coverage = FALSE)

distinct.sf(.data, ..., .keep_all = FALSE)

gather.sf(
  data,
  key,
  value,
  ...,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)

pivot_longer.sf(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  ...
)

pivot_wider.sf(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL
)

spread.sf(
  data,
  key,
  value,
  fill = NA,
  convert = FALSE,
  drop = TRUE,
  sep = NULL
)

sample_n.sf(tbl, size, replace = FALSE, weight = NULL, .env = parent.frame())

sample_frac.sf(
  tbl,
  size = 1,
  replace = FALSE,
  weight = NULL,
  .env = parent.frame()
)

group_split.sf(.tbl, ..., .keep = TRUE)

nest.sf(.data, ...)

separate.sf(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)

separate_rows.sf(data, ..., sep = "[^[:alnum:]]+", convert = FALSE)

unite.sf(data, col, ..., sep = "_", remove = TRUE)

unnest.sf(data, ..., .preserve = NULL)

drop_na.sf(x, ...)

inner_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

left_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

right_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

full_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

semi_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

anti_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>data object of class sf</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.dots</code></td>
<td>
<p>see corresponding function in package <code>dplyr</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fn, .cols</code></td>
<td>
<p>see original docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_union</code></td>
<td>
<p>logical; in case <code>summary</code> does not create a geometry column, should geometries be created by unioning using st_union, or simply by combining using st_combine? Using st_union resolves internal boundaries, but in case of unioning points, this will likely change the order of the points; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_coverage</code></td>
<td>
<p>logical; if <code>do_union</code> is <code>TRUE</code>, use an optimized algorithm for features that form a polygonal coverage (have no overlaps)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.keep_all</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convert</code></td>
<td>
<p>see separate_rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor_key</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names_to, names_pattern, names_ptypes, names_transform</code></td>
<td>
<p>see <code>tidyr::pivot_longer()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names_prefix, names_sep, names_repair</code></td>
<td>
<p>see original function docs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values_to, values_drop_na, values_ptypes, values_transform</code></td>
<td>
<p>See <code>tidyr::pivot_longer()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_cols, id_expand, names_from, names_sort, names_glue, names_vary, names_expand</code></td>
<td>
<p>see <code>tidyr::pivot_wider()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values_from, values_fill, values_fn, unused_fn</code></td>
<td>
<p>see <code>tidyr::pivot_wider()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>see separate_rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tbl</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.env</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.tbl</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.keep</code></td>
<td>
<p>see original function docs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>see separate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>into</code></td>
<td>
<p>see separate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove</code></td>
<td>
<p>see separate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra</code></td>
<td>
<p>see separate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.preserve</code></td>
<td>
<p>see unnest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>A join specification created with <code>join_by()</code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">⁠*_join()⁠</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code>join_by()</code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code>join_by()</code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code>join_by()</code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at ?join_by for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code>cross_join()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>select</code> keeps the geometry regardless whether it is selected or not; to deselect it, first pipe through <code>as.data.frame</code> to let dplyr's own <code>select</code> drop it.
</p>
<p>In case one or more of the arguments (expressions) in the <code>summarise</code> call creates a geometry list-column, the first of these will be the (active) geometry of the returned object. If this is not the case, a geometry column is created, depending on the value of <code>do_union</code>.
</p>
<p>In case <code>do_union</code> is <code>FALSE</code>, <code>summarise</code> will simply combine geometries using c.sfg. When polygons sharing a boundary are combined, this leads to geometries that are invalid; see for instance <a href="https://github.com/r-spatial/sf/issues/681">https://github.com/r-spatial/sf/issues/681</a>.
</p>
<p><code>distinct</code> gives distinct records for which all attributes and geometries are distinct; st_equals is used to find out which geometries are distinct.
</p>
<p><code>nest</code> assumes that a simple feature geometry list-column was among the columns that were nested.
</p>


<h3>Value</h3>

<p>an object of class sf
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require(dplyr, quietly = TRUE)) {
 nc = read_sf(system.file("shape/nc.shp", package="sf"))
 nc %&gt;% filter(AREA &gt; .1) %&gt;% plot()
 # plot 10 smallest counties in grey:
 st_geometry(nc) %&gt;% plot()
 nc %&gt;% select(AREA) %&gt;% arrange(AREA) %&gt;% slice(1:10) %&gt;% plot(add = TRUE, col = 'grey')
 title("the ten counties with smallest area")
 nc2 &lt;- nc %&gt;% mutate(area10 = AREA/10)
 nc %&gt;% slice(1:2)
}
# plot 10 smallest counties in grey:
if (require(dplyr, quietly = TRUE)) {
 st_geometry(nc) %&gt;% plot()
 nc %&gt;% select(AREA) %&gt;% arrange(AREA) %&gt;% slice(1:10) %&gt;% plot(add = TRUE, col = 'grey')
 title("the ten counties with smallest area")
}
if (require(dplyr, quietly = TRUE)) {
 nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
 nc %&gt;% group_by(area_cl) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc2 &lt;- nc %&gt;% mutate(area10 = AREA/10)
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% transmute(AREA = AREA/10) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% select(SID74, SID79) %&gt;% names()
 nc %&gt;% select(SID74, SID79) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc2 &lt;- nc %&gt;% rename(area = AREA)
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% slice(1:2)
}
if (require(dplyr, quietly = TRUE)) {
 nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
 nc.g &lt;- nc %&gt;% group_by(area_cl)
 nc.g %&gt;% summarise(mean(AREA))
 nc.g %&gt;% summarise(mean(AREA)) %&gt;% plot(col = grey(3:6 / 7))
 nc %&gt;% as.data.frame %&gt;% summarise(mean(AREA))
}
if (require(dplyr, quietly = TRUE)) {
 nc[c(1:100, 1:10), ] %&gt;% distinct() %&gt;% nrow()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE) &amp;&amp; "geometry" %in% names(nc)) {
 nc %&gt;% select(SID74, SID79) %&gt;% gather("VAR", "SID", -geometry) %&gt;% summary()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE) &amp;&amp; "geometry" %in% names(nc)) {
 nc$row = 1:100 # needed for spread to work
 nc %&gt;% select(SID74, SID79, geometry, row) %&gt;%
	gather("VAR", "SID", -geometry, -row) %&gt;%
	spread(VAR, SID) %&gt;% head()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE)) {
 storms.sf = st_as_sf(storms, coords = c("long", "lat"), crs = 4326)
 x &lt;- storms.sf %&gt;% group_by(name, year) %&gt;% nest
 trs = lapply(x$data, function(tr) st_cast(st_combine(tr), "LINESTRING")[[1]]) %&gt;%
    st_sfc(crs = 4326)
 trs.sf = st_sf(x[,1:2], trs)
 plot(trs.sf["year"], axes = TRUE)
}
</code></pre>


</div>