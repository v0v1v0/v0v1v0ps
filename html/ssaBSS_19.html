<div class="container">

<table style="width: 100%;"><tr>
<td>SSAcor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Identification of Non-stationarity in the Covariance Structure
</h2>

<h3>Description</h3>

<p>SSAcor method for identifying non-stationarity in the covariance structure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SSAcor(X, ...)

## Default S3 method:
SSAcor(X, K, n.cuts = NULL, tau = 1, eps = 1e-6, maxiter = 2000, ...)
## S3 method for class 'ts'
SSAcor(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The lag as a scalar or a vector. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>. 
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. For all lags <code class="reqn">j=1, ..., ntau</code>, algorithm first calculates matrices
</p>
<p style="text-align: center;"><code class="reqn">{\bf M_j} = \sum_{i = 1}^K \frac{T_i}{T}({\bf S}_{j,T} - {\bf S}_{j,T_i})({\bf S}_{j,T} - {\bf S}_{j,T_i})^T,</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, <code class="reqn">{\bf S}_{J,T}</code> is the global sample covariance for lag <code class="reqn">j</code>, and <code class="reqn">{\bf S}_{\tau,T_i}</code> is the sample covariance of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j = 1}^{ntau} ||\textrm{diag}({\bf}{\bf U}{\bf M}_j {\bf U}')||^2.</code>
</p>

<p>where <code class="reqn">j = 1, \ldots, ntau</code>.
</p>
<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. 
Then the pseudo eigenvalues <code class="reqn">{\bf D}_i = \textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}') = \textrm{diag}(d_{i,1}, \ldots, d_{i,p})</code> are obtained and the value of <code class="reqn">d_{i,j}</code> tells if the <code class="reqn">j</code>th component is nonstationary with respect to <code class="reqn">{\bf M}_i</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of components with non-stationary covariance, and the last <code class="reqn">p-k</code> rows to the subspace of components with stationary covariance. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>W </code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M </code></td>
<td>
<p>Used separation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K </code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p>The sums of pseudo eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DTable </code></td>
<td>
<p>The peudo eigenvalues of size <em>ntau*p</em> to see which type of nonstationarity there exists in each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU </code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cut </code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k </code></td>
<td>
<p>The used lag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method </code></td>
<td>
<p>Name of the method ("SSAcor"), to be used in e.g. screeplot.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code>JADE</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 5000
A &lt;- rorth(4)

z1 &lt;- rtvAR1(n)
z2a &lt;- arima.sim(floor(n/3), model = list(ar = c(0.5),
        innov = c(rnorm(floor(n/3), 0, 1))))
z2b &lt;- arima.sim(floor(n/3), model = list(ar = c(0.2),
        innov = c(rnorm(floor(n/3), 0, 1.28))))
z2c &lt;- arima.sim(n - 2*floor(n/3), model = list(ar = c(0.8),
        innov = c(rnorm(n - 2*floor(n/3), 0, 0.48))))
z2 &lt;- c(z2a, z2b, z2c)
z3 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24), ar = c(0.14, 0.45)))
z4 &lt;- arima.sim(n, model = list(ar = c(0.34, 0.27, 0.18))) 

Z &lt;- cbind(z1, z2, z3, z4)
library(zoo)
X &lt;- as.zoo(tcrossprod(Z, A)) # A zoo object

res &lt;- SSAcor(X, K = 6, tau = 1)
ggscreeplot(res, type = "barplot", color = "gray") # Two non-zero eigenvalues

# Plotting the components as a zoo object
plot(res) # The first two are nonstationary in autocovariance

</code></pre>


</div>