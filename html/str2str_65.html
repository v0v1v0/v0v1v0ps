<div class="container">

<table style="width: 100%;"><tr>
<td>stack2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stack one Set of Variables from Wide to Long</h2>

<h3>Description</h3>

<p><code>stack2</code> converts one set of variables in a data.frame from wide to long format.
(If you want to convert *multiple* sets of variables from wide to long, see
<code>reshape</code>.) It is a modified version of <code>stack</code> that 1) adds a column for
the rownames, 2) returns character vectors rather than factors, 3) can return
additional (repeated) columns, and 4) can order by rownames original
positions rather than the variable names being stacked call order.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stack2(
  data,
  select.nm,
  keep.nm = pick(x = names(data), val = select.nm, not = TRUE),
  rtn.el.nm = "el",
  rtn.vrbnames.nm = "vrb_names",
  rtn.rownames.nm = "row_names",
  order.by.rownames = TRUE,
  stringsAsFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.frame of data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select.nm</code></td>
<td>
<p>character vector of colnames from <code>data</code> specifying the
variables to be stacked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.nm</code></td>
<td>
<p>optional argument containing a character vector of colnames from
<code>data</code> specifying the additional columns to be included in the return object.
These columns are repeated down the data.frame as they are not stacked together.
The default is the inclusion of all other columns in <code>data</code> other than
<code>select.nm</code>. If NULL, then no other columns will be included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtn.el.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the elements of the stacked variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtn.vrbnames.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the names of the stacked variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtn.rownames.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the rownames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.by.rownames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
data.frame should be ordered by the positions of the rownames (TRUE) or by the
positions of the names of the stacked variables (i.e., <code>select.nm</code>). Note,
the ordering is by the *positions*, not by alphabetical order. If that is desired,
convert the rownames to a (id) column and use <code>reshape::melt.data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether the
<code>rtn.vrbnames.nm</code> and <code>rtn.rownames.nm</code> columns should be converted
to factors. Note, the factor levels are ordered by positions and not alphabetically
(see <code>v2fct</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stack2</code> is also very similar to <code>reshape::melt.data.frame</code>. The
differences are that it 1) adds a column for the rownames, 2) returns character
vectors rather than factors, and 3) can order by rownames original positions
rather than the variable names being stacked call order.
</p>


<h3>Value</h3>

<p>data.frame with nrow = <code>nrow(data) * length(`select.nm`)</code> from stacking the
elements of <code>data[select.nm]</code> on top of one another. The first column is
the rownames with name <code>rtn.rownames.nm</code>, the second column is the names
of the stacked variables with name <code>rtn.vrbnames.nm</code>, the third column is
the stacked elements with name <code>rtn.el.nm</code>, and the additional columns
are those specified by <code>keep.nm</code>.
</p>


<h3>See Also</h3>

<p><code>unstack2</code>
<code>stack</code>
<code>melt.data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# general
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"))
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), rtn.el.nm = "rating", rtn.vrbnames.nm = "item",
   rtn.rownames.nm = "row_names") # change the return object colnames
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = pick(x = names(mtcars), val = c("disp","hp","drat","wt","qsec"),
   not = TRUE)) # include all columns from `data` in the return object

# keep options
stack2(data = mtcars, select.nm = c("mpg","cyl","disp")
   ) # default = keep all other variables in `data`
stack2(data = mtcars, select.nm = c("mpg","cyl","disp"), keep = c("gear","carb")
   ) # character vector = keep only specified variables in `data`
stack2(data = mtcars, select.nm = c("mpg","cyl","disp"), keep = NULL,
   ) # NULL = keep no other variables in `data`

# compare to utils:::stack.data.frame and reshape::melt.data.frame
ChickWeight2 &lt;- as.data.frame(datasets::ChickWeight)
ChickWeight2$"Diet" &lt;- as.integer(ChickWeight2$"Diet")
x &lt;- stack(x = ChickWeight2, select = c("weight","Diet")) # does not allow
   # keeping additional columns
y &lt;- reshape::melt(data = ChickWeight2, measure.vars = c("weight","Diet"),
   id.nm = c("Chick","Time"), variable_name = "vrb_names") # does not include
   # rownames and not ordered by rownames
z &lt;- stack2(data = ChickWeight2, select.nm = c("weight","Diet"),
   keep.nm = c("Chick","Time"))
head(x); head(y); head(z)
</code></pre>


</div>