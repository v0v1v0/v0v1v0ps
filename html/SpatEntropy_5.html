<div class="container">

<table style="width: 100%;"><tr>
<td>karlstrom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Karlstrom and Ceccato's entropy.</h2>

<h3>Description</h3>

<p>This function computes Karlstrom and Ceccato's spatial entropy for a
chosen neighbourhood distance,
following Karlstrom and Ceccato (2002), see also Altieri et al (2017) and following works
(references are under the topic <code>SpatEntropy</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">karlstrom(
  data,
  category = 1,
  cell.size = 1,
  partition = 10,
  win = NULL,
  neigh = 4,
  method = "number",
  plotout = T
)

battyLISA(
  data,
  category = 1,
  cell.size = 1,
  partition = 10,
  win = NULL,
  neigh = 4,
  method = "number",
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>category</code></td>
<td>
<p>A single value matching the data category of interest for computing Batty's entropy.
Default to 1. If the dataset is an unmarked point pattern, this argument must not be changed from the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.size</code></td>
<td>
<p>A single number or a vector of length two, only needed if data are lattice. It gives the length of the side of each pixel;
if the pixel is rectangular, the first number gives the horizontal side and the second number gives the vertical side. Default to 1. Ignored if data are points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition</code></td>
<td>
<p>Input defining the partition into subareas. If an integer, it defines the
number of sub-areas that are randomly generated by areapart; if a two column matrix
with coordinates, they are the centroids of the subareas built by areapart. Alternatively,
it can be the output of areapart, a <code>tess</code> object built by the user, a <code>list</code> object
with arguments <code>tiles</code>, i.e. a list of <code>owin</code> objects defining the partition, and <code>n</code>, the number of subareas.
Lastly, it can be an <code>im</code> object, i.e. a factor- or character-valued pixel image on the
same observation window as the data, so that the partition is defined according to the values
of the image.
The default option is <code>partition=areapart(data, G=10)</code>, which generates 10 random sub-areas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>win</code></td>
<td>
<p>Optional, the observation area given as a <code>owin</code> object. If
data are a point pattern <code>ppp</code> object, this argument is ignored
and the observation area is extracted from the object. If data are
given as a matrix and the area is not specified, the default is a
rectangle with x range from 0 to the number of columns of the data, and
y range from 0 to the number of rows of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>A single number. It can be either the number of neighbours for each sub-area
(including the area itself). or the Euclidean distance to define which sub-areas are neighbours,
based on their centroids. Default to 4 neighbours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character, it guides the interpretation of <code>neigh</code>. Either "number" (the default)
or "distance".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Karlstrom and Ceccato's spatial entropy measures the heterogeneity in the spatial distribution
of a phenomenon of interest, with regard to an area partition and accounting for the neighbourhood.
It is similar to Batty's entropy (see batty) discarding the sub-area size,
with the difference that the probability of occurrence of the phenomenon over area <code class="reqn">g</code>
is actually a weighted sum of the neighbouring probabilities.
</p>
<p style="text-align: center;"><code class="reqn">H_{KC}=\sum p_g \log(1/ \tilde{p}_g)</code>
</p>

<p>where <code class="reqn">p_g</code> is the probability of occurrence of the phenomenon over sub-area <code class="reqn">g</code>,
and <code class="reqn">\tilde{p}_g</code> is the averaged probability over the neighbouring areas (including the g-th area itself).
When data are categorical, the phenomenon of interest corresponds to
one category, which must be specified. If data are an unmarked
point pattern, a fake mark vector is be created with the same category for all points.
For comparison purposes, the relative version of Karlstrom and Ceccato's entropy is also returned, i.e.
Karlstrom and Ceccato's entropy divided by its maximum log(number of sub-areas).
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation.
</p>


<h3>Value</h3>

<p>A list of five elements:
</p>

<ul>
<li> <p><code>karlstrom</code> Karlstrom and Ceccato's entropy
</p>
</li>
<li> <p><code>range</code> The theoretical range of Karlstrom and Ceccato's entropy
</p>
</li>
<li> <p><code>rel.karl</code> Karlstrom and Ceccato's entropy divided by <code class="reqn">\log(G)</code> (number og sub-areas) for comparison across observation areas.
</p>
</li>
<li> <p><code>areas</code> a dataframe giving, for each sub-area, the absolute and relative frequency of
the points/pixels of interest, the weighted probabilities of the neighbours and the sub-area size
</p>
</li>
<li> <p><code>area.tess</code> a <code>tess</code> object with the area partition
</p>
</li>
</ul>
<p>Moreover, a plot is produced showing the data and the area partition.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#LATTICE DATA

data=matrix((sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
KC.entropy=karlstrom(data, category="a")
KC.entropy=karlstrom(data, category="a", neigh=3.5, method="distance")
##to plot
data.binary=matrix(as.numeric(data=="a"), nrow(data))
plot(as.im(data.binary, W=KC.entropy$area.tess$window), main="",
     col=grDevices::gray(seq(1,0,l=length(unique(c(data.binary))))), ribbon=FALSE)
plot(KC.entropy$area.tess, add=TRUE, border=2)

#POINT DATA

#unmarked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10))
KC.entropy=karlstrom(data)
##to plot
plot(data)
plot(KC.entropy$area.tess, add=TRUE, border=2)

#marked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10),
         marks=(sample(1:5, 100, replace=TRUE)))
#if you want to compute the entropy on all points
KC.entropy=karlstrom(unmark(data))
#if you want to compute the entropy on a category, say 3
KC.entropy=karlstrom(data, category=3)
##to plot using the selected category
ind=which(spatstat.geom::marks(data)==3)
data.binary=unmark(data[ind])
plot(data.binary)
plot(KC.entropy$area.tess, add=TRUE, border=2)

</code></pre>


</div>