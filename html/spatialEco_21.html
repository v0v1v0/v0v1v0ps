<div class="container">

<table style="width: 100%;"><tr>
<td>crossCorrelation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial cross correlation</h2>

<h3>Description</h3>

<p>Calculates univariate or bivariate spatial cross-correlation using
local Moran's-I (LISA), following Chen (2015)
</p>


<h3>Usage</h3>

<pre><code class="language-R">crossCorrelation(
  x,
  y = NULL,
  coords = NULL,
  w = NULL,
  type = c("LSCI", "GSCI"),
  k = 999,
  dist.function = c("inv.power", "neg.exponent", "none"),
  scale.xy = TRUE,
  scale.partial = FALSE,
  scale.matrix = FALSE,
  alpha = 0.05,
  clust = TRUE,
  return.sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of x response variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of y response variables, if not specified the
univariate  statistic is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>A matrix of coordinates corresponding to (x,y), only
used if w = NULL. Can also be an sp object with relevant
x,y coordinate slot (ie., points or polygons)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Spatial neighbors/weights in matrix format. Dimensions
must match (n(x),n(y)) and be symmetrical. If w is not defined
then a default method is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>c("LSCI","GSCI") Return Local Spatial Cross-correlation Index (LSCI)
or Global Spatial cross-correlation Index (GSCI)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of simulations for calculating permutation distribution
under the null hypothesis of no spatial autocorrelation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.function</code></td>
<td>
<p>("inv.power", "neg.exponent", "none") If w = NULL, the default method
for deriving spatial weights matrix, options are: inverse power
or negative exponent, none is for use with a provided matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.xy</code></td>
<td>
<p>(TRUE/FALSE) scale the x,y vectors, if FALSE it is assumed that
they are already scaled following Chen (2015)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.partial</code></td>
<td>
<p>(FALSE/TRUE) rescale partial spatial autocorrelation statistics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.matrix</code></td>
<td>
<p>(FALSE/TRUE) If a neighbor/distance matrix is passed, should it
be scaled using (w/sum(w))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>= 0.05     confidence interval (default is 95 pct)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clust</code></td>
<td>
<p>(FALSE/TRUE) Return approximated lisa clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.sims</code></td>
<td>
<p>(FALSE/TRUE) Return randomizations vector n = k</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In specifying a distance matrix, you can pass a coordinates matrix or spatial
object to coords or alternately, pass a distance or spatial weights matrix to
the w argument. If the w matrix represents spatial weights dist.function="none"
should be specified. Otherwise, w is assumed to represent distance and will be
converted to spatial weights using inv.power or neg.exponent. The w distances
can represent an alternate distance hypothesis (eg., road, stream, network distance)
Here are example argument usages for defining a matrix.
</p>

<ul>
<li>
<p> IF coords=x, w=NULL, dist.function= c("inv.power", "neg.exponent")
A distance matrix is derived using the data passed to coords then
spatial weights derived using one of the dist.function options
</p>
</li>
<li>
<p> IF cords=NULL, w=x, dist.function= c("inv.power", "neg.exponent")
It is expected that the distance matrix specified with w represent
some form of distance then the spatial weights are derived using
one of the dist.function options
</p>
</li>
<li>
<p> IF cords=NULL, w=x, dist.function="none"
It is assumed that the matrix passed to w already represents
the spatial weights
</p>
</li>
</ul>
<h3>Value</h3>

<p>When not simulated k=0, a list containing:
</p>

<ul>
<li>
<p> I - Global autocorrelation statistic
</p>
</li>
<li>
<p> SCI - - A data.frame with two columns representing the xy and yx autocorrelation
</p>
</li>
<li>
<p> nsim - value of NULL to represent p values were derived from observed data (k=0)
</p>
</li>
<li>
<p> p - Probability based observations above/below confidence interval
</p>
</li>
<li>
<p> t.test - Probability based on t-test
</p>
</li>
<li>
<p> clusters - If "clust" argument TRUE, vector representing LISA clusters
</p>
</li>
</ul>
<p>When simulated (k&gt;0), a list containing:
</p>

<ul>
<li>
<p> I - Global autocorrelation statistic
</p>
</li>
<li>
<p> SCI - A data.frame with two columns representing the xy and yx autocorrelation
</p>
</li>
<li>
<p> nsim - value representing number of simulations
</p>
</li>
<li>
<p> global.p - p-value of global autocorrelation statistic
</p>
</li>
<li>
<p> local.p - Probability based simulated data using successful rejection of t-test
</p>
</li>
<li>
<p> range.p - Probability based on range of probabilities resulting from paired t-test
</p>
</li>
<li>
<p> clusters - If "clust" argument TRUE, vector representing lisa clusters
</p>
</li>
</ul>
<h3>References</h3>

<p>Chen, Y.G. (2012) On the four types of weight functions for spatial contiguity
matrix. Letters in Spatial and Resource Sciences 5(2):65-72
</p>
<p>Chen, Y.G. (2013) New approaches for calculating Moranâ€™s index of spatial
autocorrelation. PLoS ONE 8(7):e68336
</p>
<p>Chen, Y.G. (2015) A New Methodology of Spatial Cross-Correlation Analysis.
PLoS One 10(5):e0126158. doi:10.1371/journal.pone.0126158
</p>


<h3>Examples</h3>

<pre><code class="language-R"># replicate Chen (2015)
 data(chen)
( r &lt;- crossCorrelation(x=chen[["X"]], y=chen[["Y"]], w = chen[["M"]],  
                        clust=TRUE, type = "LSCI", k=0, 
                        dist.function = "inv.power") ) 


library(sf)
library(spdep)
 
  if (require(sp, quietly = TRUE)) {
   data(meuse, package = "sp")
   meuse &lt;- st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
  } 

#### Using a default spatial weights matrix method (inverse power function)
( I &lt;- crossCorrelation(meuse$zinc, meuse$copper, 
             coords = st_coordinates(meuse)[,1:2], k=99) )
  meuse$lisa &lt;- I$SCI[,"lsci.xy"]
    plot(meuse["lisa"], pch=20)

#### Providing a distance matrix
if (require(units, quietly = TRUE)) {
  Wij &lt;- units::drop_units(st_distance(meuse))
 ( I &lt;- crossCorrelation(meuse$zinc, meuse$copper, w = Wij, k=99) )

#### Providing an inverse power function weights matrix
  Wij &lt;- 1 / Wij
    diag(Wij) &lt;- 0 
      Wij &lt;- Wij / sum(Wij) 
        diag(Wij) &lt;- 0
 ( I &lt;- crossCorrelation(meuse$zinc, meuse$copper, w = Wij, 
                         dist.function = "none", k=99) )
}
 

</code></pre>


</div>