<div class="container">

<table style="width: 100%;"><tr>
<td>DNFOptim.dynamicsSVM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Discrete Nonlinear Filter Maximum Likelihood Estimation Function
</h2>

<h3>Description</h3>

<p>The <code>DNFOptim</code> function finds maximum likelihood estimates for stochastic volatility models parameters using the <code>DNF</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'dynamicsSVM'
DNFOptim(dynamics, data, par, factors, tol, N = 50, K = 20, R = 1,
  grids = 'Default', 
  rho = 0, delta = 0, alpha = 0, rho_z = 0, nu = 0, jump_params_list = "dummy",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dynamics</code></td>
<td>
<p>A dynamicsSVM object representing the model dynamics to be used by the optimizer to find maximum likelihood parameter estimates.This should be a vector or an <code>xts</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A series of asset returns for which we want to find maximum likelihood estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Initial values for the parameters to be optimized over. Information about how to pass the initial parameters is given in the 'Note' section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>Series of values taken by <code>d</code> explanatory variables. This should be a matrix or an <code>xts</code> object with <code>d</code> rows and <code>T</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance hyperparameter for the optimization. The <code>optim</code> function will be rerun until the difference between the maximum values for the likelihood function is less than <code>tol</code>. After the first <code>optim</code> call, which uses the initial parameters, the next optimizers are run using the previous optimizer's maximum likelihood parameter estimates as initial values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of nodes in the variance grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of nodes in the jump size grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grids</code></td>
<td>
<p>Grids to be used for numerical integration by the <code>DNF</code> function. The <code>DNF</code> function creates grids for built-in models. However, this arguments must be provided for custom models. It should contain a list of three sequences: <code>var_mid_points</code> (variance mid-point sequence), <code>j_nums</code> (sequence for the number of jumps), and <code>jump_mid_points</code> (jump mid-point sequence). If there are no variance jumps in the model, set <code>jump_mid_points</code> equal to zero. If there are no jumps in the model, both <code>j_nums</code> and <code>jump_mid_points</code> should be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Maximum number of jumps used in the numerical integration at each timestep.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho, delta, alpha, rho_z, nu</code></td>
<td>
<p>See <code>help(dynamicsSVM)</code> for a description of each of these arguments individually. These arguments should be used only for custom models and can be fixed to a certain
value (e.g., <code>rho = -0.75</code>). If they are estimated, they should be set to <code>'var'</code> (e.g., to estimate <code>rho</code> set <code>rho = 'var'</code>) and include it in the vector par to be passed to the <code>optim</code> function.
See Note for more details on the order in which custom models should receive parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jump_params_list</code></td>
<td>
<p>List of the names of the arguments in the jump parameter distribution in the order that they are used by the <code>jump_dist</code> function. This is used by <code>DNFOptim</code> to check for parameters that occur both in the <code>jump_dist</code> function and as arguments in drift or diffusion functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to the <code>optim</code> function. See Note.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>Returns a list obtained from R's <code>optim</code> function. See <code>help(optim)</code> for details about the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SVDNF</code></td>
<td>
<p>Returns a SVDNF object obtained from running the <code>DNF</code> function at the MLE parameter values. See <code>help(DNF)</code> for details about the output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho, delta, alpha, rho_z, nu</code></td>
<td>
<p>See <code>help(dynamicsSVM)</code> for a description of each of these arguments individually. If they are estimated, they are set to <code>'var'</code>. If the parameters were fixed during the estimation, this will return the value at which they were fixed.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>When passing the initial parameter vector <code>par</code> to the <code>optim</code> function (via <code>...</code>), the parameters should follow a specific order.
</p>
<p>For the <code>PittMalikDoucet</code> model, the parameters should be in the following order: <code>phi</code>, <code>theta</code>, <code>sigma</code>, <code>rho</code>, <code>delta</code>, <code>alpha</code>, and <code>p</code>.
</p>
<p>For the <code>DuffiePanSingleton</code> model, the parameters should be in the following order: <code>mu</code>, <code>alpha</code>, <code>delta</code>, <code>rho_z</code>, <code>nu</code>, <code>omega</code>, <code>kappa</code>, <code>theta</code>, <code>sigma</code>, and <code>rho</code>.
</p>
<p>For the <code>CAPM_SV</code> model, the parameters should be in the following order: <code>c_0</code>, <code>c_1</code>, <code>phi</code>, <code>theta</code>, and <code>sigma</code>.
</p>
<p>All other built-in models can be seen as being nested within these models (i.e., <code>Heston</code> and <code>Bates</code> models are nested in the <code>DuffiePanSingleton</code> model, while <code>Taylor</code> and <br><code>TaylorWithLeverage</code> are nested in the <code>PittMalikDoucet</code> model). Their parameters should be passed in the same order as those in the more general models, minus the parameters not found in these nested models.
</p>
<p>For example, the <code>Taylor</code> model contains neither jumps nor correlation between volatility and returns innovations. Thus, its three parameters are passed in the order: <code>phi</code>, <code>theta</code>, and <code>sigma</code>.
</p>
<p>When <code>models = "Custom"</code>, parameters should be passed in the following order: <code>mu_y_params</code>, <code>sigma_y_params</code>, <code>mu_x_params</code>, <code>sigma_x_params</code>, <code>rho</code>, <code>delta</code>, <code>alpha</code>, <code>rho_z</code>, <code>nu</code>, and <code>jump_params</code>. If an argument is repeated (e.g., both <code>mu_y_params</code> and  <code>sigma_y_params</code> use the same parameter), write it only when it first appears in the custom model order.
</p>


<h3>References</h3>

<p>R Core Team (2019). R: A language and environment for statistical computing. R Foundation
for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)

# Generating return data
Taylor_mod &lt;- dynamicsSVM(model = "Taylor", phi = 0.9,
  theta = -7.36, sigma = 0.363)
Taylor_sim &lt;- modelSim(t = 30, dynamics = Taylor_mod, init_vol = -7.36)
plot(Taylor_sim$volatility_factor, type = 'l')
plot(Taylor_sim$returns, type = 'l')

# Initial values and optimization bounds
init_par &lt;- c(0.7, -5, 0.3)
lower &lt;- c(0.01, -20, 0.1); upper &lt;- c(0.99, 0, 1)

# Running DNFOptim to get MLEs
optim_test &lt;- DNFOptim(data = Taylor_sim$returns,
  dynamics = Taylor_mod,
  par = init_par, lower = lower, upper = upper, method = "L-BFGS-B")
                
# Parameter estimates
summary(optim_test)

# Plot prediction and filtering distributions
plot(optim_test)

</code></pre>


</div>