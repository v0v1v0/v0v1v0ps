<div class="container">

<table style="width: 100%;"><tr>
<td>mergeNodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graph nodes merging by a membership attribute</h2>

<h3>Description</h3>

<p>Merge groups of graph nodes using hierarchical clustering
with prototypes derived from <code>protoclust</code> or 
custom membership attribute (e.g., cluster membership derived from
<code>clusterGraph</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mergeNodes(
  graph,
  data,
  h = 0.5,
  membership = NULL,
  HM = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>network as an igraph object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes. If <code>membership</code> is not NULL, is currently
ignored, <code>data = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Cutting the minimax clustering at height, h = 1 - abs(cor(j,k)),
yielding a merged node (and a reduced data set) in which every node in the
cluster has correlation of at least cor(j,k) with the prototype node.
By default, <code>h = 0.5</code>, i.e. cor(j,k) = 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>Cluster membership. A vector of cluster membership
identifiers as numeric values, where vector names correspond to graph
node names. By default, <code>membership = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HM</code></td>
<td>
<p>Hidden cluster label. If membership is derived from clusterGraph:
HM = "LV", a latent variable (LV) will be defined as common unknown cause
acting on cluster nodes. If HM = "CV", cluster nodes will be considered as
regressors of a latent composite variable (CV). Finally, if HM = "UV", an
unmeasured variable (UV) is defined, where source nodes of the module (i.e.,
in-degree = 0) act as common regressors influencing the other nodes
via an unmeasured variable. By default, <code>HM = NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the merged graphs will
not be plotted to screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Hierarchical clustering with prototypes (or Minmax linkage) is
unique in naturally associating a node (the prototypes) with every
interior node of the dendogram. Thus, for each merge we have a single
representative data point for the resulting cluster (Bien, Tibshirani, 2011).
These prototypes can be used to greatly enhance the interpretability of
merging nodes and data reduction for SEM fitting.
</p>


<h3>Value</h3>

<p>A list of 2 objects is returned:
</p>

<ol>
<li>
<p> "gLM", A graph with merged nodes as an igraph object;
</p>
</li>
<li>
<p> "membership", cluster membership vector for each node.
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Bien J, Tibshirani R (2011). Hierarchical Clustering With Prototypes via
Minimax Linkage. Journal of the American Statistical Association
106(495): 1075-1084. &lt;doi:10.1198/jasa.2011.tm10183&gt;
</p>


<h3>See Also</h3>

<p><code>clusterGraph</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Gene memberships with prototypes with h=0.5
G &lt;- properties(alsData$graph)[[1]]
M &lt;- mergeNodes(G, data = alsData$exprs, h = 0.5, verbose=TRUE)

# Gene memberships with EBC method and size=10
m &lt;- clusterGraph(G, type = "ebc", size = 10)
M &lt;- mergeNodes(G, membership = m, HM = "LV", verbose=TRUE)

# Gene memberships defined by user
c1 &lt;- c("5894", "5576", "5567", "572", "598")
c2 &lt;- c("6788", "84152", "2915", "836", "5530")
c3 &lt;- c("5603", "6300", "1432", "5600")
m &lt;- c(rep(1,5), rep(2,5), rep(3,4))
names(m) &lt;- c(c1, c2, c3)
M &lt;- mergeNodes(G, membership = m, HM = "CV", verbose=TRUE)

</code></pre>


</div>