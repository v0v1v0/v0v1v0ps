<div class="container">

<table style="width: 100%;"><tr>
<td>next_terminal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tell me what the next terminal is</h2>

<h3>Description</h3>

<p>If the first is a terminal, return it. If not, go inside it and search the
next terminal
</p>


<h3>Usage</h3>

<pre><code class="language-R">next_terminal(
  pd,
  stack = FALSE,
  vars = c("pos_id", "token", "text"),
  tokens_exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pd</code></td>
<td>
<p>A nest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stack</code></td>
<td>
<p>Whether or not to also return information on the tokens that
are between <code>pd</code> and the first terminal, so the returned data frame can be
understood as a transition path from <code>pd</code> to the next terminal, instead of
the information at the terminal only. The order is inside-out,
i.e. the first non-terminal on top, the terminal last.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>The variables to return.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tokens_exclude</code></td>
<td>
<p>A vector with tokens to exclude. This can be helpful if
one wants to find the next token that is not a comment for example.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a data frame (which is <strong>not</strong> a valid parse table for
<code>stack = TRUE</code>), with <code>vars</code> and another variable <code>position</code> that denotes
the index each element in the transition. This can be helpful in conjunction
with <code>purrr::pluck()</code> or <code>purrr::modify_in()</code> to reach the terminal in the
nested structure.
</p>


<h3>Examples</h3>

<pre><code class="language-R">withr::with_options(
  list(styler.cache_name = NULL), # temporarily deactivate cache
  {
    pd &lt;- compute_parse_data_nested("if (TRUE) f()")
    styler:::next_terminal(pd)
  }
)
</code></pre>


</div>