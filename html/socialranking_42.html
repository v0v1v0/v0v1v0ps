<div class="container">

<table style="width: 100%;"><tr>
<td>doRanking</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a <code>SocialRanking</code> object</h2>

<h3>Description</h3>

<p>Rank elements based on their scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">doRanking(scores, compare = NULL, decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>A vector or list representing each element's score. If <code>names(scores)</code> is not <code>NULL</code>, those will be used as element names.
Else a number sequence corresponding to the elements is generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compare</code></td>
<td>
<p>Optional comparison function taking in two elements and returning a numerical value based on the relation between
these two elements. If set to <code>NULL</code>, the default <code>order()</code> function is called. See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>If <code>TRUE</code> (default), elements with higher scores are ranked higher.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All ranking solutions in the package are tied to the scores or score vectors of the elements.
For these kinds of solutions, <code>doRanking()</code> offers a simple way that turns a (named) vector or list of scores for each element into a <code>SocialRanking</code> object.
For example, <code>doRanking(c(a=1,b=2))</code> produces <code>b &gt; a</code> (<code class="reqn">b P^\succsim a</code>), because <code>b</code> with a score of <code>2</code> should be placed higher than <code>a</code> with a score of <code>1</code>.
</p>
<p>Ranking solutions in the package include <code>lexcelRanking()</code>, <code>ordinalBanzhafRanking()</code> and <code>L1Ranking()</code>, among others.
These functions take a power relation, calculate the scores of each element and returns a <code>SocialRanking</code> object.
</p>
<p>R natively supports sorting for vectors, but not for lists.
If the use of lists is necessary, or if the native sort method in vectors does not produce the desired results, there are two possible ways to solve this:
</p>

<ol>
<li>
<p> by the introduction of custom S3 classes, or
</p>
</li>
<li>
<p> by setting the <code>compare</code> parameter in <code>doRanking()</code>.
</p>
</li>
</ol>
<p>For S3 classes, the class for the score object has to be set and the <code>==</code> and <code>&gt;</code> (and <code>[</code> for lists) operators overloaded.
I.e., <code>lexcelScores()</code> returns a list with the custom class <code>LexcelScores</code> that implements <code style="white-space: pre;">⁠==.LexcelScores⁠</code>, <code style="white-space: pre;">⁠&gt;.LexcelScores⁠</code>, <code style="white-space: pre;">⁠[.LexcelScores⁠</code> and <code>is.na.LexcelScores</code>.
</p>
<p>In cases where we only want to experiment, introducing new S3 classes can be cumbersome.
As an alternative, the <code>compare</code> parameter can be assigned a function.
This function must take two parameters, i.e., <code style="white-space: pre;">⁠function(a, b)⁠</code>, where <code>a</code> and <code>b</code> are the scores of two arbitrary elements.
The function then must return one of the following:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠&gt; 0⁠</code> (positive value) if score <code>a</code> is ranked higher than score <code>b</code>,
</p>
</li>
<li> <p><code style="white-space: pre;">⁠&lt; 0⁠</code> (negative value) if score <code>a</code> is ranked lower than score <code>b</code>, or
</p>
</li>
<li> <p><code style="white-space: pre;">⁠= 0⁠</code> if both scores <code>a</code> and <code>b</code> are considered equal.
</p>
</li>
</ul>
<p>In <code>doRanking(c(a=3,b=2,c=2), compare = function(a,b) a - b)</code>, the compare function returns a positive value of the first parameter is larger than the second.
<code>a</code> has the highest value and will there for be ranked highest, <code>a &gt; b ~ c</code>.
</p>
<p>Conversely, <code>doRanking(c(a=3,b=2,c=2), compare = function(a,b) b - a)</code> favors elements with lower scores, resulting in the element ranking <code>b ~ c &gt; a</code>.
</p>


<h3>Value</h3>

<p>A list of type <code>SocialRanking</code>.
Each element of the list contains a vector of elements in <code>powerRelation$elements</code> that are indifferent to one another.
</p>


<h3>See Also</h3>

<p><code>SocialRanking()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">doRanking(c(a=1,b=2))
# b &gt; a

doRanking(c(a=2,b=2))
# a ~ b

# a custom ranking function. Here, we implement the following ranking solution:
# disregard any big coalitions and only rank elements based on their individual performances
# iRj if and only if {i} &gt;= {j}
singletonRanking &lt;- function(pr) {
  scores &lt;- sapply(pr$elements, equivalenceClassIndex, powerRelation = pr)
  # note that coalitions in higher indexed equivalence classes are less preferable
  # hence, scores should be sorted in an increasing order
  doRanking(scores, decreasing = FALSE)
}

pr &lt;- as.PowerRelation("abc &gt; ab &gt; ac &gt; b ~ c ~ bc &gt; a")
singletonRanking(pr)
# b ~ c &gt; a

# a reverse lexcel ranking, where vectors are compared right to left
# here, we introduce a compare function. It returns:
# * 0, if a and b are identical
# * a positive value, if a[i] &gt; b[i] and every value after that is equal
# * a negative value, if a[i] &lt; b[i] and every value after that is equal
reverseLexcelCompare &lt;- function(a, b) {
  i &lt;- which(a != b) |&gt; rev()
  if(length(i) == 0) 0
  else a[i[1]] - b[i[1]]
}

scores &lt;- unclass(cumulativeScores(pr))

# R cannot natively sort a class. Instead:
# Method 1 - utilize the compare parameter
doRanking(scores, compare = reverseLexcelCompare)


# Method 2 - introduce S3 class
`[.RevLex` &lt;- function(x, i, ...) structure(unclass(x)[i], class = "RevLex")
`==.RevLex` &lt;- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) == 0
`&gt;.RevLex` &lt;- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) &gt; 0
is.na.RevLex &lt;- function(x) FALSE
doRanking(structure(scores, class = "RevLex"))

stopifnot(
  doRanking(scores, compare = reverseLexcelCompare) ==
  doRanking(structure(scores, class = "RevLex"))
)

</code></pre>


</div>