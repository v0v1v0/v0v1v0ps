<div class="container">

<table style="width: 100%;"><tr>
<td>spSVC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for fitting univariate Bayesian spatially-varying
coefficient regression models</h2>

<h3>Description</h3>

<p>The function <code>spSVC</code> fits Gaussian univariate Bayesian spatially-varying
coefficient regression models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spSVC(formula, data = parent.frame(), svc.cols=1, coords, 
      priors, starting, tuning, cov.model, center.scale=FALSE,
      amcmc, n.samples, n.omp.threads = 1,
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spSVC</code> is called. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>svc.cols</code></td>
<td>
<p>a vector indicating which columns of the regression
design matrix <code class="reqn">X</code> should be space-varying. <code>svc.cols</code> can
be an integer vector with values indicating <code class="reqn">X</code> columns or a
character vector with values corresponding to <code class="reqn">X</code> column
names. <code>svc.cols</code> default argument
of 1 results in a space-varying intercept model (assuming an intercept
is specified in the first column of the design matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times m</code> matrix of the observation coordinates
in <code class="reqn">R^m</code> (e.g., <code class="reqn">R^2</code> might be easting and northing). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>, <code>k.iw</code>,
<code>tau.sq.ig</code>, <code>phi.unif</code>, <code>nu.unif</code>,
<code>beta.norm</code>, and <code>beta.flat</code>. Scalar variance parameters <code>simga.sq</code> and
<code>tau.sq</code> are assumed to follow an
inverse-Gamma distribution. Cross-covariance matrix parameter <code>K</code> is
assumed to follow an inverse-Wishart. The spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform
distributions. The regression coefficient priors can be either flat
or multivariate Normal. 
</p>
<p>There are two specification for the Gaussian Process (GP) on the <code>svc.cols</code> columns: 1)
univariate GPs on each column; 2) multivariate GP on the <code class="reqn">r</code>
columns (i.e., where <code class="reqn">r</code> equals <code>length(svc.cols)</code>). If
univariate GPs are desired, specify <code>sigma.sq.ig</code> as a
list of length two with the first and second elements corresponding
to the length <code class="reqn">r</code> <em>shape</em> and <em>scale</em>
hyperparameter vectors,
respectively. If a multivariate GP is desired, specify <code>k.iw</code>
as a list of length two with the first and second elements corresponding
to the degrees-of-freedom <code class="reqn">df</code> and <code class="reqn">r\times r</code> <em>scale</em> matrix,
respectively. This inverse-Wishart prior is on the <code class="reqn">r\times r</code> multivariate GP
cross-covariance matrix defined as <code class="reqn">K=AA'</code> where <code class="reqn">A</code> is the
lower-triangle Cholesky square root of <code class="reqn">K</code>.
</p>
<p>If the regression coefficients, i.e., <code>beta</code>
vector, are assumed to follow a multivariate Normal distribution then pass the
hyperparameters as a list of length two with the first
and second elements corresponding to the mean vector and positive
definite covariance matrix, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. Similarly, <code>phi</code>
and <code>nu</code> are specified as lists of length two with
the first and second elements holding vectors of length <code class="reqn">r</code> lower
and upper bounds of the Uniforms' support, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>, <code>A</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>.  The value portion of each
tag is the parameter's starting value(s). Starting values must be
set for the <code class="reqn">r</code> univariate or multivariate GP <code>phi</code> and
<code>nu</code>. For univariate GPs <code>sigma.sq.ig</code> is
specified as a vector of length <code class="reqn">r</code> and for a multivariate GP <code>A</code> is specified as a vector of 
<code class="reqn">r\times(r+1)/2</code> that gives the lower-triangle elements in column major ordering of the Cholesky square root
of the cross-covaraince matrix <code class="reqn">K=AA'</code>. <code>tau.sq</code> is
a single value. See Finley and Banerjee (2019) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq</code>, <code>A</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>. The value portion of each
tag defines the variance of the Metropolis sampler Normal proposal
distribution. For <code>sigma.sq</code>, <code>phi</code>, and <code>nu</code> the
tuning value vectors are of length <code class="reqn">r</code> and <code>A</code> is of
length <code class="reqn">r\times(r+1)/2</code>. <code>tuning</code> vector elements correspond to <code>starting</code> vector elements. <code>tau.sq</code> is
a single value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.scale</code></td>
<td>
<p>if <code>TRUE</code>, non-constant columns of <code class="reqn">X</code>
are centered on zero and scaled to have variance one. If
<code>spPredict</code> is subsequently called this centering and scaling
is applied to <code>pred.covars</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler, see Roberts and Rosenthal (2007) for an explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance
and MCMC progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>
<p>The <em>no nugget</em> model is specified by removing <code>tau.sq</code> from the <code>starting</code> list.
</p>


<h3>Value</h3>

<p>An object of class <code>spSVC</code>, which is a list comprising:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times m</code> matrix specified by
<code>coords</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for subsequent
parameter recovery, prediction, and model fit evaluation using
<code>spRecover</code>, <code>spPredict</code>,
<code>spDiag</code>, respectively. 
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1â€“28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006). Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a>.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Bayesian spatially varying
coefficient models in the spBayes R package. <a href="https://arxiv.org/abs/1903.03028">https://arxiv.org/abs/1903.03028</a>.
</p>


<h3>See Also</h3>

<p><code>spRecover, spDiag, spPredict</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

library(Matrix)

rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}


##Assume both columns of X are space-varying and the two GPs don't covary
set.seed(1)
n &lt;- 200
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

X &lt;- as.matrix(cbind(1, rnorm(n)))
colnames(X) &lt;- c("x.1", "x.2")

Z &lt;- t(bdiag(as.list(as.data.frame(t(X)))))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)

sigma.sq &lt;- c(1,5)
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))

C &lt;- exp(-phi*D)%x%diag(sigma.sq)

w &lt;- rmvn(1, rep(0,p*n), C)

mu &lt;- as.vector(X%*%B + Z%*%w)

y &lt;- rnorm(n, mu, sqrt(tau.sq))

##fit a model to the simulated dat
starting &lt;- list("phi"=rep(3/0.5, p), "sigma.sq"=rep(1, p), "tau.sq"=1)

tuning &lt;- list("phi"=rep(0.1, p), "sigma.sq"=rep(0.1, p), "tau.sq"=0.1)

cov.model &lt;- "exponential"

priors &lt;- list("phi.Unif"=list(rep(3/2, p), rep(3/0.0001, p)),
               "sigma.sq.IG"=list(rep(2, p), rep(2, p)),
               "tau.sq.IG"=c(2, 1))

##fit model
n.samples &lt;- 2000

m.1 &lt;- spSVC(y~X-1, coords=coords, starting=starting, svc.cols=c(1,2),
             tuning=tuning, priors=priors, cov.model=cov.model,
             n.samples=n.samples, n.omp.threads=4)

plot(m.1$p.theta.samples, density=FALSE)

##recover posterior samples
m.1 &lt;- spRecover(m.1, start=floor(0.75*n.samples), thin=2, n.omp.threads=4)

summary(m.1$p.beta.recover.samples)
summary(m.1$p.theta.recover.samples)

##check fitted values
quant &lt;- function(x){quantile(x, prob=c(0.025, 0.5, 0.975))}

##fitted y
y.hat &lt;- apply(m.1$p.y.samples, 1, quant)

rng &lt;- c(-15, 20)
plot(y, y.hat[2,], pch=19, cex=0.5, xlab="Fitted y", ylab="Observed y",
     xlim=rng, ylim=rng)
arrows(y, y.hat[2,], y, y.hat[1,], angle=90, length=0.05)
arrows(y, y.hat[2,], y, y.hat[3,], angle=90, length=0.05)
lines(rng, rng, col="blue")

##recovered w
w.hat &lt;- apply(m.1$p.w.recover.samples, 1, quant)

w.1.indx &lt;- seq(1, p*n, p)
w.2.indx &lt;- seq(2, p*n, p)

par(mfrow=c(1,2))

rng &lt;- c(-5,5)
plot(w[w.1.indx], w.hat[2,w.1.indx], pch=19, cex=0.5, xlab="Fitted w.1", ylab="Observed w.1",
     xlim=rng, ylim=rng)
arrows(w[w.1.indx], w.hat[2,w.1.indx], w[w.1.indx], w.hat[1,w.1.indx], angle=90, length=0.05)
arrows(w[w.1.indx], w.hat[2,w.1.indx], w[w.1.indx], w.hat[3,w.1.indx], angle=90, length=0.05)
lines(rng, rng, col="blue")

rng &lt;- c(-10,10)
plot(w[w.2.indx], w.hat[2,w.2.indx], pch=19, cex=0.5, xlab="Fitted w.2", ylab="Observed w.2",
     xlim=rng, ylim=rng)
arrows(w[w.2.indx], w.hat[2,w.2.indx], w[w.2.indx], w.hat[1,w.2.indx], angle=90, length=0.05)
arrows(w[w.2.indx], w.hat[2,w.2.indx], w[w.2.indx], w.hat[3,w.2.indx], angle=90, length=0.05)
lines(rng, rng, col="blue")

## End(Not run)
</code></pre>


</div>