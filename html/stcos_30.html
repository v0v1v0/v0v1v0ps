<div class="container">

<table style="width: 100%;"><tr>
<td>spatial_bisquare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial Bisquare Basis</h2>

<h3>Description</h3>

<p>Spatial bisquare basis on point data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatial_bisquare(dom, knots, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dom</code></td>
<td>
<p>Points <code class="reqn">\bm{u}_1, \ldots, \bm{u}_n</code> to evaluate. See
"Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>Knots <code class="reqn">\bm{c}_1, \ldots, \bm{c}_r</code> for the basis.
See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Radius for the basis.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li>
<p> Both <code>dom</code> and <code>knots</code> may be provided as either <code>sf</code> or
<code>sfc</code> objects, or as matrices of points.
</p>
</li>
<li>
<p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>dom</code>, <code class="reqn">n</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(dom)</code>.
Otherwise, <code>dom</code> will be interpreted as an <code class="reqn">n \times 2</code> numeric matrix.
</p>
</li>
<li>
<p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 2</code> numeric matrix.
</p>
</li>
<li>
<p> If both <code>dom</code> and <code>knots</code> are given as <code>sf</code> or <code>sfc</code> objects,
they will be checked to ensure a common coordinate system.
</p>
</li>
</ul>
<p>For each <code class="reqn">\bm{u}_i</code>, compute the basis functions
</p>
<p style="text-align: center;"><code class="reqn">
\varphi_j(\bm{u}) =
\left[ 1 - \frac{\Vert\bm{u} - \bm{c}_j \Vert^2}{w^2} \right]^2  \cdot
I(\Vert \bm{u} - \bm{c}_j \Vert \leq w)
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>.
</p>
<p>Due to the treatment of <code class="reqn">\bm{u}_i</code> and <code class="reqn">\bm{c}_j</code> as points in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>


<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\varphi_1(\bm{u}_i), \ldots, \varphi_r(\bm{u}_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code>areal_spacetime_bisquare()</code>,
<code>areal_spatial_bisquare()</code>,
<code>spacetime_bisquare()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y)
knots_sf = st_as_sf(knots, coords = c("x","y"), crs = NA, agr = "constant")

# Points to evaluate
x = runif(50)
y = runif(50)
pts = data.frame(x = x, y = y)
dom = st_as_sf(pts, coords = c("x","y"), crs = NA, agr = "constant")

rad = 0.5
spatial_bisquare(cbind(x,y), knots, rad)
spatial_bisquare(dom, knots, rad)

# Plot the knots and the points at which we evaluated the basis
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
points(x, y, cex = 0.5)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>


</div>