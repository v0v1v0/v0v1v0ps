<div class="container">

<table style="width: 100%;"><tr>
<td>cSpline</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>C-Spline Basis for Polynomial Splines</h2>

<h3>Description</h3>

<p>Generates the convex regression spline (called C-spline) basis matrix by
integrating I-spline basis for a polynomial spline or the corresponding
derivatives.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  scale = TRUE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

csp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  scale = TRUE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.
Duplicated internal knots are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>The degree of C-spline defined to be the degree of the
associated M-spline instead of actual polynomial degree. For example,
C-spline basis of degree 2 is defined as the scaled double integral of
associated M-spline basis of degree 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>If <code>TRUE</code> by default, all of the spline basis
functions are returned.  Notice that when using C-Spline for
shape-restricted regression, <code>intercept = TRUE</code> should be set even
when an intercept term is considered additional to the spline basis in
the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
C-splines. The default value is <code>0L</code> for C-spline basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A logical value indicating if scaling C-splines is required. If
<code>TRUE</code> by default, each C-spline basis is scaled to have unit
height at right boundary knot. The corresponding I-spline and M-spline
produced by <code>deriv</code> methods will be scaled to the same extent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is an implementation of the closed-form C-spline basis derived from the
recursion formula of I-splines and M-splines.  The function <code>csp()</code> is
an alias of to encourage the use in a model formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns.  Attributes that correspond to the
arguments specified are returned for usage of other functions in this
package.
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008). Inference using shape-restricted regression splines.
<em>The Annals of Applied Statistics</em>, 2(3), 1013â€“1033.
</p>


<h3>See Also</h3>

<p><code>iSpline</code> for I-splines;
<code>mSpline</code> for M-splines.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(splines2)

x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

### when 'scale = TRUE' (by default)
csMat &lt;- cSpline(x, knots = knots, degree = 2)

plot(csMat, ylab = "C-spline basis", mark_knots = "internal")
isMat &lt;- deriv(csMat)
msMat &lt;- deriv(csMat, derivs = 2)
plot(isMat, ylab = "scaled I-spline basis")
plot(msMat, ylab = "scaled M-spline basis")

### when 'scale = FALSE'
csMat &lt;- cSpline(x, knots = knots, degree = 2, scale = FALSE)

## the corresponding I-splines and M-splines (with same arguments)
isMat &lt;- iSpline(x, knots = knots, degree = 2)
msMat &lt;- mSpline(x, knots = knots, degree = 2, intercept = TRUE)

## or using deriv methods (more efficient)
isMat1 &lt;- deriv(csMat)
msMat1 &lt;- deriv(csMat, derivs = 2)

## equivalent
stopifnot(all.equal(isMat, isMat1, check.attributes = FALSE))
stopifnot(all.equal(msMat, msMat1, check.attributes = FALSE))
</code></pre>


</div>