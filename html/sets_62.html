<div class="container">

<table style="width: 100%;"><tr>
<td>cset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Customizable sets</h2>

<h3>Description</h3>

<p>Creation and manipulation of customizable sets.</p>


<h3>Usage</h3>

<pre><code class="language-R">cset(gset,
     orderfun = sets_options("orderfun"),
     matchfun = sets_options("matchfun"))
cset_support(x)
cset_core(x, na.rm = FALSE)
cset_peak(x, na.rm = FALSE)
cset_height(x, na.rm = FALSE)
cset_memberships(x, filter = NULL)
cset_universe(x)
cset_bound(x)

cset_transform_memberships(x, FUN, ...)
cset_concentrate(x)
cset_dilate(x)
cset_normalize(x, height = 1)
cset_defuzzify(x,
               method = c("meanofmax", "smallestofmax",
                          "largestofmax", "centroid"))

matchfun(FUN)

cset_orderfun(x)
cset_matchfun(x)
cset_orderfun(x) &lt;- value
cset_matchfun(x) &lt;- value

as.cset(x)
is.cset(x)

cset_is_empty(x, na.rm = FALSE)
cset_is_subset(x, y, na.rm = FALSE)
cset_is_proper_subset(x, y, na.rm = FALSE)
cset_is_equal(x, y, na.rm = FALSE)
cset_contains_element(x, e)

cset_is_set(x, na.rm = FALSE)
cset_is_multiset(x, na.rm = FALSE)
cset_is_fuzzy_set(x, na.rm = FALSE)
cset_is_set_or_multiset(x, na.rm = FALSE)
cset_is_set_or_fuzzy_set(x, na.rm = FALSE)
cset_is_fuzzy_multiset(x)
cset_is_crisp(x, na.rm = FALSE)
cset_has_missings(x)

cset_cardinality(x, type = c("absolute", "relative"), na.rm = FALSE)
cset_union(...)
cset_mean(x, y, type = c("arithmetic", "geometric", "harmonic"))
cset_product(...)
cset_difference(...)
cset_intersection(...)
cset_symdiff(...)
cset_complement(x, y)
cset_power(x)
cset_cartesian(...)
cset_combn(x, m)

## S3 method for class 'cset'
cut(x, level = 1, type = c("alpha", "nu"), strict = FALSE, ...)
## S3 method for class 'cset'
mean(x, ..., na.rm = FALSE)

## S3 method for class 'cset'
## median(x, na.rm = FALSE, ...)     [R &gt;= 3.4.0]
## median(x, na.rm)                  [R &lt; 3.4.0]
## S3 method for class 'cset'
length(x)
## S3 method for class 'cset'
lengths(x, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For <code>as.cset()</code> and <code>is.cset()</code>:
an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object. A (c)set object otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A (c)set object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gset</code></td>
<td>
<p>A generalized set (or some other <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object coercible to it).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matchfun</code></td>
<td>
<p>A function for matching similar elements, comparable 
to <code>match</code>, taking two arguments: <code>x</code> (vector of
elements to be matched) and <code>table</code> (vector of elements to be
matched against). The return value is an integer vector of the
matching positions (or <code>NA</code> if there is no match).
Note that the default behavior is to test for <em>identity</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A predicate testing for equality of two objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orderfun</code></td>
<td>
<p>A function taking a list and returning an integer vector,
specifying the order in which an iterator processes the set
elements. Alternatively, the index vector can be specified directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>A new match function (order function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>For <code>gset_cardinality()</code>:
cardinality type (either <code>"absolute"</code> or
<code>"relative"</code>). For <code>gset_mean()</code>: mean type
(<code>"arithmetic"</code>, <code>"geometric"</code>, or <code>"harmonic"</code>).
For <code>"cut"</code>: either <code>"alpha"</code> or <code>"nu"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Logical indicating whether the cut level must be 
exceeded strictly (“greater than”) or not (“greater
than or equal”).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>Double from the unit interval for scaling memberships.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>An object of class <code>element</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>Optional vector of elements to be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Currently, only <code>"Jaccard"</code> is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The minimum membership level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be
removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>cset_<var>foo</var>()</code>: (c)set objects. For
the mean and sort methods: additional parameters internally passed to
<code>mean</code> and <code>order</code>, respectively. For
<code>gset_transform_memberships</code>: further arguments passed to
<code>FUN</code>. For <code>cut</code>: currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Customizable sets extend generalized sets in two ways: First, users
can control the way elements are matched, i.e., define equivalence
classes of elements. Second, an order function (or permutation index)
can be specified for each set for changing the order in which
iterators such as <code>as.list</code> process the elements. The latter in
particular influences the labeling and print methods for
customizable sets.
</p>
<p>The match function needs to be vectorized in a similar way than
<code>match</code>. <code>matchfun</code> can be used to create such a
function from a “simple” predicate testing for equality
(such as, e.g., <code>identical</code>). Make sure, however, to
create the same function only once.
</p>
<p>Note that operations on customizable sets require the same match
function for all sets involved. The order function can differ, but
will then be stripped from the result.
</p>
<p><code>sets_options</code> can be used to
conveniently switch the default match and/or
order function if a number of <code>cset</code> objects need to be created.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1–27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code>set</code> for (“ordinary”) sets, 
<code>gset</code> for generalized sets, 
<code>cset_outer</code>, and
<code>tuple</code> for tuples (“vectors”).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## default behavior of sets: matching of elements is very strict
## Note that on most systems, 3.3 - 2.2 != 1.1
x &lt;- set("1", 1L, 1, 3.3 - 2.2, 1.1)
print(x)

y &lt;- set(1, 1.1, 2L, "2")
print(y)
1L %e% y

set_union(x, y)
set_intersection(x, y)
set_complement(x, y)

## Now use the more sloppy match()-function. 
## Note that 1 == "1" == 1L ...
X &lt;- cset(x, matchfun = match)
print(X)
Y &lt;- cset(y, matchfun = match)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)

## Same using all.equal().
## This is a non-vectorized predicate, so use matchfun
## to generate a vectorized version:
FUN &lt;- matchfun(function(x, y) isTRUE(all.equal(x, y)))
X &lt;- cset(x, matchfun = FUN)
print(X)
Y &lt;- cset(y, matchfun = FUN)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)

### change default functions via set_option
sets_options("matchfun", match)
cset(x)
cset(y)

cset(1:3) &lt;= cset(c(1,2,3))

### restore package defaults
sets_options("matchfun", NULL)

### customized order function
FUN &lt;- function(x) order(as.character(x), decreasing = TRUE)
Z &lt;- cset(letters[1:5], orderfun = FUN)
print(Z)
as.character(Z)

## converter for ordered factors keeps order
o &lt;- ordered(c("a", "b", "a"), levels = c("b", "a"))
as.set(o)
as.cset(o)

## converter for other data types keep order if the elements are unique:
as.cset(c("A", "quick", "brown", "fox"))
as.cset(c("A", "quick", "brown", "fox", "quick"))
</code></pre>


</div>