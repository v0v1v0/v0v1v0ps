<div class="container">

<table style="width: 100%;"><tr>
<td>rings</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identifies all cells within a ring around the focal cells</h2>

<h3>Description</h3>

<p>Identifies the cell numbers of all cells within a ring defined by  minimum
and maximum distances from focal cells.
Uses <code>spread()</code> under the hood, with specific values set.
Under many situations, this may be faster than using <code>sf::st_buffer</code> twice
(once for smaller ring and once for larger ring, then removing the smaller ring cells).
</p>


<h3>Usage</h3>

<pre><code class="language-R">rings(
  landscape,
  loci = NA_real_,
  id = FALSE,
  minRadius = 2,
  maxRadius = 5,
  allowOverlap = FALSE,
  returnIndices = FALSE,
  returnDistances = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>landscape</code></td>
<td>
<p>A <code>RasterLayer</code> or <code>SpatRaster</code> object. This defines the possible
locations for spreading events to start and spread into.
This can also be used as part of <code>stopRule</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci</code></td>
<td>
<p>A vector of locations in <code>landscape</code>.
These should be cell indices.
If user has x and y coordinates, these can be converted
with <code>cellFromXY()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a raster of events ids.
If <code>FALSE</code>, returns a raster of iteration numbers,
i.e., the spread history of one or more events.
NOTE: this is overridden if <code>returnIndices</code> is <code>TRUE</code>
or <code>1</code> or <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minRadius</code></td>
<td>
<p>Numeric. Minimum radius to be included in the ring.
Note: this is inclusive, i.e., <code>&gt;=</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxRadius</code></td>
<td>
<p>Numeric. Maximum radius to be included in the ring.
Note: this is inclusive, i.e., <code>&lt;=</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowOverlap</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then individual events can overlap
with one another, i.e., they do not interact (this is slower
than if <code>allowOverlap = FALSE</code>).
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDistances</code></td>
<td>
<p>Logical. Should the function include a column with the
individual cell distances from the locus where that event
started. Default is <code>FALSE</code>.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other argument passed to <code>spread</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This will return  a <code>data.table</code> with columns as described in
<code>spread</code> when <code>returnIndices = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code>cir()</code> which uses a different algorithm.
<code>cir</code> tends to be faster when there are few starting points, <code>rings</code>
tends to be faster when there are many starting points. Another difference
between the two functions is that <code>rings</code> takes the centre of the pixel
as the centre of a circle, whereas <code>cir</code> takes the exact coordinates.
See example.
</p>
<p><code>sf::st_buffer</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1462)

# Make random forest cover map
emptyRas &lt;- terra::rast(terra::ext(0, 1e2, 0, 1e2), res = 1)

# start from two cells near middle
loci &lt;- (ncell(emptyRas) / 2 - ncol(emptyRas)) / 2 + c(-3, 3)

# No overlap is default, occurs randomly
emptyRas[] &lt;- 0
rngs &lt;- rings(emptyRas, loci = loci, minRadius = 7, maxRadius = 9, returnIndices = TRUE)
emptyRas[rngs$indices] &lt;- rngs$id
if (interactive()) {
  terra::plot(emptyRas)
}

# Variable ring widths, including centre cell for smaller one
emptyRas[] &lt;- 0
rngs &lt;- rings(emptyRas, loci = loci, minRadius = c(0, 7), maxRadius = c(8, 18),
              returnIndices = TRUE)
emptyRas[rngs$indices] &lt;- rngs$id
if (interactive()) {
  terra::plot(emptyRas)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>


</div>