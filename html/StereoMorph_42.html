<div class="container">

<table style="width: 100%;"><tr>
<td>findCheckerboardCorners</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finds internal corners of a checkerboard pattern</h2>

<h3>Description</h3>

<p>This function finds the internal corners of a checkerboard pattern in an image.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findCheckerboardCorners(image.file, nx, ny, corner.file=NULL, verify.file=NULL, 
                        perim.min = 'auto', perim.max = 'auto', dilations.min = 0,
                        dilations.max = 7, sub.pix.win = NULL, sub.pix.win.min = NULL, 
                        quad.fit.max=4, poly.cont.min=-0.3, poly.cont.max=0.3, 
                        quad.approx.thresh = 'auto', flip = FALSE, 
                        print.progress=TRUE, verbose=FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>image.file</code></td>
<td>
<p>File path(s) to image(s) or to folder(s) containing image(s) (and only images). The image(s) should be a JPEG and include a checkerboard pattern. Can be a vector or matrix. Many different inputs accepted, see "Examples".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>The number of internal corners in the checkerboard along one dimension. Note that this is not the number of squares (see "Details").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny</code></td>
<td>
<p>The number of internal corners in the checkerboard along a second dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corner.file</code></td>
<td>
<p>File path(s) to text file(s) or to folder(s) where the corners should be saved. Can be a vector or matrix. If <code>NULL</code>, corners are not saved to a text file. Many different inputs accepted, see "Examples".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verify.file</code></td>
<td>
<p>File path(s) to JPEG image(s) or to folder(s) where verification images should be saved. Can be a vector or matrix. If <code>NULL</code>, verification images are not created. Many different inputs accepted, see "Examples".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perim.min</code></td>
<td>
<p>The minimum expected perimeter of a black square in the checkerboard pattern (in pixels).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perim.max</code></td>
<td>
<p>The maximum expected perimeter of a black square in the checkerboard pattern (in pixels).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dilations.min</code></td>
<td>
<p>The initial number of dilations to perform on the image. See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dilations.max</code></td>
<td>
<p>The maximum number of dilations to perform on the image. If equal to <code>dilations.min</code>, the function will only perform one dilation. See "details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.pix.win</code></td>
<td>
<p>The window size to use in determining the corner positions to subpixel resolution. If <code>NULL</code>, this is determined automatically based on the size of the found corners.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.pix.win.min</code></td>
<td>
<p>Only relevant if sub.pix.win is <code>NULL</code>. This sets the minimum window size that can be set by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad.fit.max</code></td>
<td>
<p>Fit threshold used to identify quadrangles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly.cont.min</code></td>
<td>
<p>The minimum allowed aspect ratio of the polygon contours, used as a threshold in identifying quadrangles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly.cont.max</code></td>
<td>
<p>The maximum allowed aspect ratio of the polygon contours, used as a threshold in identifying quadrangles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad.approx.thresh</code></td>
<td>
<p>A threshold for the perimeter of black squares in which method to use to approximate the shape as a quadrangle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>Logical whether the order of the corners should be flipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.progress</code></td>
<td>
<p>Logical indicating whether the function progress should be printed to the console. See <code>verbose</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicating whether more detailed progress reports to the console. If <code>verbose</code> is <code>FALSE</code>, only the image name and whether the corners were found successfully are printed. If <code>verbose</code> is <code>TRUE</code>, the outcome of the corner search at the conclusion of each dilation is also printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>Logical indicating whether images should be created at each of several steps in the corner search. These will be written to the same location as the images written to <code>verify.file</code>. If <code>debug</code> is <code>TRUE</code>, <code>verify.file</code> must be defined. Additionally, <code>dilations.min</code> and <code>dilations.max</code> should be identical since debugging images are created at each dilation and will be overwritten if a range of dilations is input.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function automatically detects checkerboard corners in an image and returns the pixel coordinates of the internal corners (where the corners of the black squares contact other black squares) to subpixel resolution. The function uses several C++ functions for image processing written by the author and compiled with the StereoMorph package but hidden until documentation can be written for more general use. Currently the function only works with JPEG images (.jpg or .jpeg); this is the most common digital camera image format output. For large images (10-20 MB), the function can take from 5-15 seconds per image.
</p>
<p><code>image.file</code> input to the function can be of several different forms. First, it can be file paths to particular images or file paths to a folder or folders containing images. Secondly, it can be in a vector or matrix format. The format of <code>image.file</code> will dictate the structure of the value returned by the function. If a single image file is input, a two-colum matrix of corners (where the two columns correspond to the x, y pixel coordinates) is returned. If the input is a vector of file paths or folders containing images, a three-dimensional array is returned; the first two dimensions are the rows and columns of each corner matrix and the third dimension is the order of the corresponding image files in <code>image.file</code>. If the input is a matrix of file paths or folders containing images, a four-dimensional array is returned; the first two dimensions are the rows and columns of each corner matrix and the third and fourth dimensions are the positions of the corresponding image files in the <code>image.file</code> matrix. If <code>image.file</code> is a folder or folders containing images, the folders cannot contain any other files.
</p>
<p>The inputs <code>corner.file</code> and <code>verify.file</code> are optional but if they are non-<code>NULL</code>, they should be of the same format as <code>image.file</code>. If <code>image.file</code> is a folder or folders containing images, folders can also be input for <code>corner.file</code> and <code>verify.file</code>. In this case, the function will automatically name the corner files and verify image files with the same names as the images and as text files and JPEG files, respectively. The corners are saved to a text file as a two column matrix without a header or row names.
</p>
<p>For every input image, the function begins by reading in the image (using <code>readJPEG()</code> of the 'jpeg' package). For large images this is one of the most time-consuming steps. The image is converted to grayscale using the internal function <code>rgbToGray()</code>. The image is thresholded to create a binary image (black and white) based on an adaptive threshold. The threshold is created using the internal function <code>meanBlurImage()</code> and the image thresholded with the internal function <code>thresholdImageMatrix()</code>. Morphological closing is performed to reduce noise using the internal functions <code>dilateImage()</code> and <code>erodeImage()</code>.
</p>
<p>The function then proceeds to dilate the image (expand white areas and consolidate black areas) using a 3x3 square kernel for the range specified by <code>dilations.min</code> and <code>dilations.max</code>. This separates the black squares from each other so that their perimeters can be detected as separate contours. For each dilation, all edge points are identified (black pixels with a neighboring white pixel and vice versa) using the internal function <code>findBoundaryPoints()</code>. Contours (connected edge points) are identified by the internal function <code>generateQuads()</code>, retaining only contours that are quadrangles. The midpoints between adjoining corners of all the quads are found using the internal function <code>intCornersFromQuads()</code>; among these will be the full set of internal corners.
</p>
<p>If the initial set of internal corners exceeds the expectation, the internal corners are filtered, fitting a line to the internal corner set and removing the points at the furthest difference from the line of best fit until the number of corners matches the expectation. The filtered internal corner set is then ordered using the internal function <code>orderCorners()</code> so that first corner is the top left most corner in the pattern and the sequence of internal corners proceeds along <code>nx</code> first and <code>ny</code> second. Lastly, the function finds the internal corner positions to subpixel resolution (using the internal function <code>findCornerSubPix()</code>) by sampling a window around the approximate location of the internal corners (of dimensions determined by <code>sub.pix.win</code>) to find a point optimally positioned at the intersection of diagonally opposing white and black squares. If determined automatically, this sampling window will usually be 23x23 pixels. It is the sampling of this large image region that allows the function to return the corner position to subpixel resolution.
</p>
<p>If <code>verify.file</code> is non-<code>NULL</code>, the internal corners are overlayed on the input image to verify that the correct corners have been found and in the correct order. The first corner is circled in red, a green line interconnects all the intermediate corners in sequence and the last corner is circled in blue (the order of colors then being RGB).
</p>


<h3>Value</h3>

<p>An array of the pixel coordinates of internal corners to subpixel resolution in an array of two (one checkerboard input), three (if <code>image.file</code> is a vector) or four dimensions (if <code>image.file</code> is a matrix). For images in which the expected number of internal corners were not found, an <code>NA</code> matrix is returned for those particular images. The corners are returned along the <code>nx</code> dimension first and the <code>ny</code> dimension second.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>This function was written based on the methodology described in 'Learning OpenCV' for the automated detection of internal checkerboard corners (Bradski and Kaehler 2008).
</p>


<h3>See Also</h3>

<p><code>readCheckerboardsToArray</code>, <code>measureCheckerboardSize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## FIND 5 X 3 INTERNAL CORNERS IN A SINGLE IMAGE
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards/RUlna.JPG"), perim.min=180, nx=5, ny=3)

## FIND 5 X 3 INTERNAL CORNERS IN ALL IMAGES IN A FOLDER (HERE 3)
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards"), perim.min=180, nx=5, ny=3)

## WHICH DIMENSIONS ARE ASSIGNED TO NX AND NY IS ARBITRARY BUT REVERSING
## THESE WILL CHANGE THE SEQUENCE IN WHICH THE CORNERS ARE RETURNED
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards/RUlna.JPG"), perim.min=180, nx=3, ny=5)
</code></pre>


</div>