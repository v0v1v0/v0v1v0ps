<div class="container">

<table style="width: 100%;"><tr>
<td>FocusArea-function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute the KWD tranport distance within a given focus area
</h2>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein distance within a given focus area embedded into a large region described as a grid map.
Both the focus and the embedding areas are are described by spatial histograms, similarly to the input data of the other functions of this package.
</p>
<p>The grid map is described by the two lists <code>Xs</code> and <code>Ys</code> of <code>N</code> coordinates, which specify the coordinates of the centroid of every single tile.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have an entry in the two lists of weights <code>W1</code> and <code>W2</code>, one for the first histograms, and the other for the second histogram.
</p>
<p>The two lists of coordinates <code>Xs</code> and <code>Ys</code> are passed to the <code>focusArea</code> function as a matrix with <code>N</code> rows and two columns.
The two lists of weights <code>W1</code> and <code>W2</code> are passed as a matrix with <code>N</code> rows and two columns, a column for each histogram.
</p>
<p>The focus area is specified by three parameters: the coordinates <code>x</code> and <code>y</code> of the center of the focus area, and the (circular) <code>radius</code> of the focus area.
The pair of coordinates (<code>x,y</code>) must correspond to a pair of coordinates contained in the vectors <code>Xs,Ys</code>.
Every tile whose distance is less or equal to the <code>radius</code> will be included in the focus area.
</p>
<p>The focus area by default is circular, that is, the area is based on a <em>L_2</em> norm. By setting the parameter <code>area</code> to the value <code>linf</code> it is possible to obtain
a squared focus area, induced by the norm <em>L_infinity</em>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">focusArea(Coordinates, Weights, x, y, radius,
           L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           area = "l2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li>
<p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li>
<p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li>
<p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the embedding spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li>
<p><code>Weights[,2]</code>: <em>(Second Column)</em> Weights of the spatial histogram of the focus area, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. All the weights outside the focus area should be equal to zero. Data type: vector of positive doubles.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Horizontal coordinate of the centroid of the focus area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vertical coordinate of the centroid of the focus area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>The radius of the focus area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area</code></td>
<td>
<p>Type of norm for delimiting the focus area: <code>l2</code> denotes a circular area of radius, <code>linf</code> denotes a squared area.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>focusArea(Coordinates, Weights, x, y, radius, ...)</code> computes the KW distance within a focus area by implicitly considering the surrounding larger area.
The mass contained within the focus area is transported to a destination either within or outside the focus area.
All the mass contained outside the focus area could be used to balance the mass within the focus area.
</p>


<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li>
<p><code>distance</code>: The value of the KW-distance between the two input areas.
</p>
</li>
<li>
<p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li>
<p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li>
<p><code>iterations</code>: Overall number of iterations of the Capacitated Network Simplex algorithm.
</p>
</li>
<li>
<p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li>
<p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>See also <code>compareOneToOne</code>, <code>compareOneToMany</code>, <code>compareAll</code>, <code>Histogram2D</code>, and <code>Solver</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
test1 &lt;- matrix(runif(2*N, 0, 1), ncol=2, nrow=N)

# Compute distance
print("Compare one-to-one with exact algorithm:")
d &lt;- focusArea(coordinates, Weights=test1,
                x=15, y=15, radius=5,
                method="exact", recode=TRUE, verbosity = "info")
cat("runtime:", d$runtime, " distance:", d$distance,
    " nodes:", d$nodes, " arcs:", d$arcs, "\n")
</code></pre>


</div>