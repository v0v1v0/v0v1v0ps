<div class="container">

<table style="width: 100%;"><tr>
<td>scaled_contr_poly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create scaled orthogonal polynomial contrasts for an ordered factor.</h2>

<h3>Description</h3>

<p>The function <code>contr.poly</code> creates orthogonal polynomial
contrasts for an ordered factor, with the standard deviations of the
columns in the contrast matrix determined by the number of columns.  The
<code>scaled_contr_poly</code> function takes this contrast matrix and alters
the scale so that the standard deviations of the columns all equal
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scaled_contr_poly(x, scale = 1, return_contr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A factor, a numeric or character vector of levels ordered least to
greatest, or a single integer greater than or equal to <code>3</code>.
See 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A single positive number indicating the standard deviation
for the columns of the contrast matrix. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_contr</code></td>
<td>
<p>A logical indicating whether the contrast matrix should
be returned, or <code>x</code> as an ordered factor with the contrasts applied.
See 'Details'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>x</code> is a factor, then the non-<code>NA</code> levels of <code>x</code> are used
as the levels for the contrast matrix.  If <code>x</code> is a vector,
then the unique non-<code>NA</code> values in <code>x</code> in the order in which
they appear in <code>x</code> are used as the levels for the contrast matrix.
If <code>x</code> is a single integer greater than or equal to <code>3</code>, then
the numbers <code>1:x</code> are used as the levels for the contrast matrix.  Any
other value for <code>x</code> results in an error (if <code>x = 2</code>, then
polynomial contrasts are technically possible, but all binary predictors
should be treated as unordered factors and coded with sum contrasts).
<code>contr.poly</code> is then called to obtain an orthogonal
polynomial contrast matrix of the appropriate degree. The contrast matrix is
is put on unit scale and then multiplied by the <code>scale</code> argument,
resulting in an orthogonal polynomial contrast matrix where
each column has standard deviation <code>scale</code>.  If
<code>return_contr = TRUE</code>, the contrast matrix is returned.  If
<code>return_contr = FALSE</code>, then <code>x</code> is coerced to
an ordered factor with the contrast matrix applied, and <code>x</code> is returned.
<code>NA</code> is never
assigned as a level in the contrast matrix or in the factor returned by the
function, but <code>NA</code> values in <code>x</code> are not removed in the factor
returned when <code>return_contr = FALSE</code>.
</p>


<h3>Value</h3>

<p>If <code>return_contr = TRUE</code> a scaled orthogonal polynomial contrast
matrix is returned.  If <code>return_contr = FALSE</code>, then a factor with the
scaled orthogonal polynomial contrasts is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>named_contr_sum</code> for unordered factors.
</p>


<h3>Examples</h3>

<pre><code class="language-R">f &lt;- factor(rep(c("a", "b", "c"), 5), ordered = TRUE)
contrasts(f) &lt;- contr.poly(3)

# difference in contrasts
contrasts(f)
scaled_contr_poly(f)
scaled_contr_poly(f, scale = 0.5)

# different options for 'x'
scaled_contr_poly(levels(f))
scaled_contr_poly(3)
scaled_contr_poly(c(2, 5, 6))

# return factor
f2 &lt;- scaled_contr_poly(f, return_contr = FALSE)
f2
</code></pre>


</div>