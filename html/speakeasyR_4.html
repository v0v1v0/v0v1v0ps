<div class="container">

<table style="width: 100%;"><tr>
<td>order_nodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group nodes by community</h2>

<h3>Description</h3>

<p>Reorders the graph to group nodes in the same community together.
Useful for viewing community structure of a graph using a <code>heatmap()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">order_nodes(graph, membership, is_directed = "detect")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>The graph or adjacency matrix the membership vector was created
for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>A vector or matrix listing node communities. The output
from <code>cluster()</code> (should also work for other clustering
algorithms that return membership in the same format).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_directed</code></td>
<td>
<p>Whether the graph should be treated as directed or not.
By default, if the graph is symmetric it is treated as undirected.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Communities are ordered by size, so nodes in the largest community are
first. Within a community, nodes are order by highest-to-lowest degree.
</p>
<p>If membership is in matrix form (the output from <code>cluster()</code>
with <code>subcluster</code> &gt; 1) a matrix is returned with the indices for level one
in row 1 and level n in row n. Each row reorders the communities of the
previous row such that, at the second level, nodes are still grouped by
the first level communities. This allows the hierarchical structure to be
viewed.
</p>
<p>See vignette for a multilevel example.
</p>


<h3>Value</h3>

<p>An index vector or matrix. The number of rows are equal to the value
of <code>subcluster</code> passed to <code>cluster()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require("igraph")) {
  n_nodes &lt;- 100
  n_types &lt;- 3
  # Mixing parameter (likelihood an edge is between communities).
  mu &lt;- 0.3
  pref &lt;- matrix(mu, n_types, n_types)
  diag(pref) &lt;- 1 - mu
  g &lt;- igraph::sample_pref(n_nodes, types = n_types, pref.matrix = pref)
  # Use a dense matrix representation to easily apply index.
  adj &lt;- as(g[], "matrix")
  memb &lt;- speakeasyR::cluster(adj, seed = 222, max_threads = 2)
  ordering &lt;- speakeasyR::order_nodes(adj, memb)
  
  heatmap(adj[ordering, ordering], scale = "none", Rowv = NA, Colv = NA)
  
}
</code></pre>


</div>