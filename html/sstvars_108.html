<div class="container">

<table style="width: 100%;"><tr>
<td>smart_ind</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create random parameter vector that is fairly close to a given parameter vector</h2>

<h3>Description</h3>

<p><code>smart_ind</code> creates random mean parametrized parameter vector that is
model fairly close to a given parameter vector. The result may not be satisfy the stability
condition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smart_ind(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  accuracy = 1,
  which_random = numeric(0),
  mu_scale,
  mu_scale2,
  omega_scale,
  B_scale,
  ar_scale = 1,
  ar_scale2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li>
<p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li>
<p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>
</li>
<li>
<p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt>
<dd>
<p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu = (\nu_1,...,\nu_M)</code> <code class="reqn">(M \times 1)</code>, <code class="reqn">nu_m &gt; 2</code>.</p>
</dd>
</dl>
</li>
</ul>
<p>For models with...
</p>

<dl>
<dt>
<code>weight_function="relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt>
<code>weight_function="logistic"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>
<code>weight_function="exponential"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt>
<code>weight_function="exogenous"</code>:</dt>
<dd>
<p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt>
<dd>
<p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt>
<code>identification="heteroskedasticity"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints (only for structural models identified by heteroskedasticity):</dt>
<dd>
<p>Replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector
so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt>
<code>"relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt>
<code>"logistic"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt>
<code>"exponential"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt>
<code>"exogenous"</code>:</dt>
<dd>
<p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>
<p>See the vignette for more details about the weight functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt>
<dd>
<p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt>
<dd>
<p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt>
<dd>
<p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt>
<dd>
<p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt>
<dd>
<p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, or <code>"ind_Student"</code>,
where the latest is the Student's <code class="reqn">t</code> distribution with independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 x 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> in order to constrain the
the weight parameter to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given parameter vector the returned individual should be.
Larger number means larger accuracy. Read the source code for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_random</code></td>
<td>
<p>a vector with length between 1 and M specifying the mixture components that should be random instead of
close to the given parameter vector. This does not consider constrained AR or lambda parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>vapply(1:d, function(i1) sd(data[,i1]), numeric(1))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale</code></td>
<td>
<p>a positive real number between zero and one adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong>
coefficients (in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to
be very small. If set smaller than 1, be careful as it might lead to failure in the creation of parameter candidates
that satisfy the stability condition.</strong></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Structural models are not supported!
</p>


<h3>Value</h3>

<p>Returns random mean parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>References</h3>


<ul><li>
<p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li></ul>
</div>