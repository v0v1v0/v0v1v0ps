<div class="container">

<table style="width: 100%;"><tr>
<td>bw.scott</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Scott's Rule for Bandwidth Selection for Kernel Density
</h2>

<h3>Description</h3>

<p>Use Scott's rule of thumb to determine the smoothing bandwidth
for the kernel estimation of point process intensity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">   bw.scott(X, isotropic=FALSE, d=NULL)

   bw.scott.iso(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>,
<code>"lpp"</code>, <code>"pp3"</code> or <code>"ppx"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isotropic</code></td>
<td>

<p>Logical value indicating whether to compute a single
bandwidth for an isotropic Gaussian kernel (<code>isotropic=TRUE</code>)
or separate bandwidths for each coordinate axis
(<code>isotropic=FALSE</code>, the default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>Advanced use only.
An integer value that should be used in Scott's formula
instead of the true number of spatial dimensions.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions select a bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code>density.ppp</code>
or other appropriate functions.
They can be applied to a point pattern
belonging to any class <code>"ppp"</code>, <code>"lpp"</code>, <code>"pp3"</code>
or <code>"ppx"</code>.
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is computed by the rule of thumb
of Scott (1992, page 152, equation 6.42). 
The bandwidth is proportional to <code class="reqn">n^{-1/(d+4)}</code>
where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the number of
spatial dimensions.
</p>
<p>This rule is very fast to compute. It typically produces a larger bandwidth
than <code>bw.diggle</code>. It is useful for estimating
gradual trend.
</p>
<p>If <code>isotropic=FALSE</code> (the default), <code>bw.scott</code> provides a
separate bandwidth for each coordinate axis, and the result of the
function is a vector, of length equal to the number of coordinates.
If <code>isotropic=TRUE</code>, a single bandwidth value is computed
and the result is a single numeric value.
</p>
<p><code>bw.scott.iso(X)</code> is equivalent to
<code>bw.scott(X, isotropic=TRUE)</code>.
</p>
<p>The default value of <code class="reqn">d</code> is as follows:
</p>

<table>
<tr>
<td style="text-align: left;">
    <b>class</b> </td>
<td style="text-align: left;"> <b>dimension</b> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>"ppp"</code> </td>
<td style="text-align: left;"> 2 </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>"lpp"</code> </td>
<td style="text-align: left;"> 1 </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>"pp3"</code> </td>
<td style="text-align: left;"> 3 </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>"ppx"</code> </td>
<td style="text-align: left;"> number of spatial coordinates
  </td>
</tr>
</table>
<p>The use of <code>d=1</code> for point patterns on a linear network
(class <code>"lpp"</code>) was proposed by McSwiggan et al (2016)
and Rakshit et al (2019).
</p>


<h3>Value</h3>

<p>A numerical value giving the selected
bandwidth, or a numerical vector giving the
selected bandwidths for each coordinate.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Scott, D.W. (1992)
<em>Multivariate Density Estimation. Theory, Practice and
Visualization</em>. 
New York: Wiley.
</p>


<h3>See Also</h3>

<p><code>density.ppp</code>,
<code>bw.diggle</code>,
<code>bw.ppl</code>,
<code>bw.CvL</code>,
<code>bw.frac</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  hickory &lt;- split(lansing)[["hickory"]]
  b &lt;- bw.scott(hickory)
  b
  if(interactive()) {
   plot(density(hickory, b))
  }
  bw.scott.iso(hickory)
  bw.scott(osteo$pts[[1]])
</code></pre>


</div>