<div class="container">

<table style="width: 100%;"><tr>
<td>simsl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Single-index models with a surface-link (main function)</h2>

<h3>Description</h3>

<p><code>simsl</code> is the wrapper function for fitting a single-index model with a surface-link (SIMSL).
The function estimates a linear combination (a single-index) of baseline covariates X, and models a nonlinear interactive structure between the single-index and a treatment variable defined on a continuum, by estimating a smooth link function on the index-treatment domain. The resulting <code>simsl</code> object can be used to estimate an optimal dose rule for a new patient with baseline clinical information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simsl(y, A, X, Xm = NULL, family = "gaussian", R = NULL,
  bs = c("ps", "ps"), k = c(8, 8), m = list(NA, NA), sp = NULL,
  knots = NULL, sep.A.effect = FALSE, mc = c(TRUE, FALSE),
  method = "GCV.Cp", beta.ini = NULL, ind.to.be.positive = NULL,
  random.effect = FALSE, z = NULL, gamma = 1, pen.order = 0,
  lambda = 0, max.iter = 10, eps.iter = 0.01, trace.iter = TRUE,
  center.X = TRUE, scale.X = TRUE, uncons.final.fit = TRUE,
  bootstrap = FALSE, nboot = 200, boot.conf = 0.95, seed = 1357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a n-by-1 vector of treatment outcomes; y is a member of the exponential family; any distribution supported by <code>mgcv::gam</code>; y can also be an ordinal categorial response with <code>R</code> categories taking a value from 1 to <code>R</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a n-by-1 vector of treatment variable; each element is assumed to take a value on a continuum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a n-by-p matrix of baseline covarates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xm</code></td>
<td>
<p>a n-by-q design matrix associated with an X main effect model; the defult is <code>NULL</code> and it is taken as a vector of zeros</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>specifies the distribution of y; e.g., "gaussian", "binomial", "poisson"; can be any family supported by <code>mgcv::gam</code>; can also be "ordinal", for an ordinal categorical response y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>the number of response categories for the case of family = "ordinal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs</code></td>
<td>
<p>basis type for the treatment (A) and single-index domains, respectively; the defult is "ps" (p-splines); any basis supported by <code>mgcv::gam</code> can be used, e.g., "cr" (cubic regression splines); see <code>mgcv::s</code> for detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>basis dimension for the treatment (A) and single-index domains, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a length 2 list (e.g., m=list(c(2,3), c(2,2))), for the treatment (A) and single-index domains, respectively, where each element specifies the order of basis and penalty (note, for bs="ps", c(2,3) means a 2nd order P-spline basis (cubic spline) and a 3rd order difference penalty; the default "NA" sets c(2,2) for each domain); see <code>mgcv::s</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p>a vector of smoothing parameters;  Smoothing parameters must be supplied in the order that the smooth terms appear in the model formula (i.e., A, and then the single-index); negative elements indicate that the parameter should be estimated, and hence a mixture of fixed and estimated parameters is possible; see <code>mgcv::gam</code> for detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>a list containing user-specified knot values to be used for basis construction, for the treatment (A) and single-index domains, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep.A.effect</code></td>
<td>
<p>If <code>TRUE</code>, the g term of SIMSL is further decomposed into: the A main effect + the A-by-X interaction effect; the default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc</code></td>
<td>
<p>a length 2 vector indicating which marginals (i.e., A and the single-index, respectively) should have centering (i.e., the sum-to-zero) constraints applied; the default is <code>mc = c(TRUE, FALSE)</code> (see <code>mgcv::te</code> for detail of the constraint), which is sufficient for the so-called "orthogonality" constraint of the SIMSL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the smoothing parameter estimation method; "GCV.Cp" to use GCV for unknown scale parameter and Mallows' Cp/UBRE/AIC for known scale; any method supported by <code>mgcv::gam</code> can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.ini</code></td>
<td>
<p>an initial value for <code>beta.coef</code>; a p-by-1 vector; the defult is <code>NULL</code>, in which case a linear model estimate is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.to.be.positive</code></td>
<td>
<p>for identifiability of the solution <code>beta.coef</code>, the user can restrict the jth (e.g., j=1) component of <code>beta.coef</code> to be positive; by default, we match the "overall" sign of <code>beta.coef</code> with that of the linear estimate (i.e., the initial estimate), by restricting the inner product between the two to be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.effect</code></td>
<td>
<p>if <code>TRUE</code>, as part of the main effects, the user can incorporate z-specific random intercepts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a factor that specifies the random intercepts when <code>random.effect = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>increase this beyond 1 to produce smoother models. <code>gamma</code> multiplies the effective degrees of freedom in the GCV or UBRE/AIC (see <code>mgcv::gam</code> for detail); the default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.order</code></td>
<td>
<p>0 indicates the ridge penalty; 1 indicates the 1st difference penalty; 2 indicates the 2nd difference penalty, used in a penalized least squares (LS) estimation of <code>beta.coef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a regularization parameter associated with the penalized LS for <code>beta.coef</code> update.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>an integer specifying the maximum number of iterations for <code>beta.coef</code> update.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.iter</code></td>
<td>
<p>a value specifying the convergence criterion of algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.iter</code></td>
<td>
<p>if <code>TRUE</code>, trace the estimation process and print the differences in <code>beta.coef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.X</code></td>
<td>
<p>if <code>TRUE</code>, center X to have zero mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.X</code></td>
<td>
<p>if <code>TRUE</code>, scale X to have unit variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncons.final.fit</code></td>
<td>
<p>if <code>TRUE</code>, once the convergence in the estimates of <code>beta.coef</code> is reached, include the main effect associated with the fitted single-index (beta.coef'X) to the final surface-link estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap</code></td>
<td>
<p>if <code>TRUE</code>, compute bootstrap confidence intervals for the single-index coefficients, <code>beta.coef</code>; the default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>when <code>bootstrap=TRUE</code>, a value specifying the number of bootstrap replications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot.conf</code></td>
<td>
<p>a value specifying the confidence level of the bootstrap confidence intervals; the defult is <code>boot.conf = 0.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>when  <code>bootstrap=TRUE</code>, randomization seed used in bootstrap resampling.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>SIMSL captures the effect of covariates via a single-index and their interaction with the treatment via a 2-dimensional smooth link function.
Interaction effects are determined by shapes of the link surface.
The SIMSL allows comparing different individual treatment levels and constructing individual treatment rules,
as functions of a biomarker signature (single-index), efficiently utilizing information on patientâ€™s characteristics.
The resulting <code>simsl</code> object can be used to estimate an optimal dose rule for a new patient with baseline clinical information.
</p>


<h3>Value</h3>

<p>a list of information of the fitted SIMSL including
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta.coef</code></td>
<td>
<p> the estimated single-index coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.fit</code></td>
<td>
<p>a <code>mgcv:gam</code> object containing information about the estimated 2-dimensional link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.ini</code></td>
<td>
<p>the initial value used in the estimation of <code>beta.coef</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.path</code></td>
<td>
<p>solution path of <code>beta.coef</code> over the iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.beta</code></td>
<td>
<p>records the change in <code>beta.coef</code> over the solution path, <code>beta.path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.scale</code></td>
<td>
<p>sd of pretreatment covariates X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.center</code></td>
<td>
<p>mean of pretreatment covariates X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.range</code></td>
<td>
<p>range of the observed treatment variable A</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>number of baseline covariates X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of subjects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot.ci</code></td>
<td>
<p><code>boot.conf</code>-level bootstrap CIs (LB, UB) associated with <code>beta.coef</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot.mat</code></td>
<td>
<p>a (nboot x p) matrix of bootstrap estimates of  <code>beta.coef</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Park, Petkova, Tarpey, Ogden
</p>


<h3>See Also</h3>

<p><code>pred.simsl</code>,  <code>fit.simsl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(1234)
n.test &lt;- 500


## simulation 1
# generate training data
p &lt;- 30
n &lt;- 200
X &lt;- matrix(runif(n*p,-1,1),ncol=p)
A &lt;- runif(n,0,2)
D_opt &lt;- 1 + 0.5*X[,2] + 0.5*X[,1]
mean.fn &lt;- function(X, D_opt, A){ 8 + 4*X[,1] - 2*X[,2] - 2*X[,3] - 25*((D_opt-A)^2) }
mu &lt;-   mean.fn(X, D_opt, A)
y &lt;- rnorm(length(mu),mu,1)
# fit SIMSL
simsl.obj &lt;- simsl(y=y, A=A, X=X)

# generate testing data
X.test &lt;- matrix(runif(n.test*p,-1,1),ncol=p)
A.test &lt;- runif(n.test,0,2)
f_opt.test &lt;- 1 + 0.5*X.test[,2] + 0.5*X.test[,1]
pred &lt;- pred.simsl(simsl.obj, newX= X.test)  # make prediction based on the estimated SIMSL
value &lt;- mean(8 + 4*X.test[,1] - 2*X.test[,2] - 2*X.test[,3] - 25*((f_opt.test- pred$trt.rule)^2))
value  # "value" of the estimated treatment rule; the "oracle" value is 8.


## simulation 2
p &lt;- 10
n &lt;- 400
# generate training data
X &lt;- matrix(runif(n*p,-1,1),ncol=p)
A &lt;- runif(n,0,2)
f_opt &lt;- I(X[,1] &gt; -0.5)*I(X[,1] &lt; 0.5)*0.6 + 1.2*I(X[,1] &gt; 0.5) +
 1.2*I(X[,1] &lt; -0.5) + X[,4]^2 + 0.5*log(abs(X[,7])+1) - 0.6
mu &lt;-   8 + 4*cos(2*pi*X[,2]) - 2*X[,4] - 8*X[,5]^3 - 15*abs(f_opt-A)
y  &lt;- rnorm(length(mu),mu,1)
Xq &lt;- cbind(X, X^2)  # include a quadratic term
# fit SIMSL
simsl.obj &lt;- simsl(y=y, A=A, X=Xq)

# generate testing data
X.test &lt;- matrix(runif(n.test*p,-1,1),ncol=p)
A.test &lt;- runif(n.test,0,2)
f_opt.test &lt;- I(X.test[,1] &gt; -0.5)*I(X.test[,1] &lt; 0.5)*0.6 + 1.2*I(X.test[,1] &gt; 0.5) +
 1.2*I(X.test[,1] &lt; -0.5) + X.test[,4]^2 + 0.5*log(abs(X.test[,7])+1) - 0.6
Xq.test &lt;- cbind(X.test, X.test^2)
pred &lt;- pred.simsl(simsl.obj, newX= Xq.test)  # make prediction based on the estimated SIMSL
value &lt;- mean(8 + 4*cos(2*pi*X.test[,2]) - 2*X.test[,4] - 8*X.test[,5]^3 -
              15*abs(f_opt.test-pred$trt.rule))
value  # "value" of the estimated treatment rule; the "oracle" value is 8.



 ### air pollution data application
 data(chicago); head(chicago)
 chicago &lt;- chicago[,-3][complete.cases(chicago[,-3]), ]
 chicago &lt;- chicago[-c(2856:2859), ]  # get rid of the gross outliers in y
 chicago &lt;- chicago[-which.max(chicago$pm10median), ]  # get rid of the gross outliers in x

 # create lagged variables
 lagard &lt;- function(x,n.lag=5) {
   n &lt;- length(x); X &lt;- matrix(NA,n,n.lag)
   for (i in 1:n.lag) X[i:n,i] &lt;- x[i:n-i+1]
   X
 }
 chicago$pm10 &lt;- lagard(chicago$pm10median)
 chicago &lt;- chicago[complete.cases(chicago), ]
 # create season varaible
 chicago$time.day &lt;- round(chicago$time %%  365)

 # fit SIMSL for modeling the season-by-pm10 interactions on their effects on outcomes
 simsl.obj &lt;- simsl(y=chicago$death, A=chicago$time.day, X=chicago[,7], bs=c("cc","ps"),
                    ind.to.be.positive = 1, family="poisson", method = "REML",
                    bootstrap =FALSE) # bootstrap = TRUE
 simsl.obj$beta.coef  # the estimated single-index coefficients
 summary(simsl.obj$g.fit)
 #round(simsl.obj$boot.ci,3)
 mgcv::vis.gam(simsl.obj$g.fit, view=c("A","single.index"), theta=-135, phi = 30,
               color="heat", se=2,ylab = "single-index", zlab = " ",
               main=expression(paste("Interaction surface g")))



 ### Warfarin data application
 data(warfarin)
 X &lt;- warfarin$X
 A &lt;- warfarin$A
 y &lt;- -abs(warfarin$INR - 2.5)  # the target INR is 2.5
 X[,1:3] &lt;- scale(X[,1:3]) # standardize continuous variables

 # Estimate the main effect, using an additive model
 mu.fit &lt;- mgcv::gam(y-mean(y)  ~ X[, 4:13] +
                       s(X[,1], k=5, bs="ps")+
                       s(X[,2], k=5, bs="ps") +
                       s(X[,3], k=5, bs="ps"), method="REML")
 summary(mu.fit)
 mu.hat &lt;- predict(mu.fit)
 # fit SIMSL
 simsl.obj &lt;- simsl(y, A, X, Xm= mu.hat, scale.X = FALSE, center.X=FALSE, method="REML",
                    bootstrap = FALSE) # bootstrap = TRUE
 simsl.obj$beta.coef
 #round(simsl.obj$boot.ci,3)
 mgcv::vis.gam(simsl.obj$g.fit, view=c("A","single.index"), theta=52, phi = 18,
               color="heat", se=2, ylab = "single-index", zlab = "Y",
               main=expression(paste("Interaction surface g")))


</code></pre>


</div>