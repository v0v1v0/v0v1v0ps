<div class="container">

<table style="width: 100%;"><tr>
<td>dodPwr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Power of the Degree-of-Difference (DOD) method</h2>

<h3>Description</h3>

<p>Computes the power of the Degree-of-Difference (DOD) method by
simulation
</p>


<h3>Usage</h3>

<pre><code class="language-R">
dodPwr(d.primeA, d.prime0=0, ncat = 4, sample.size, nsim = 1e3,
       alpha = 0.05,
       method.tau=c("LR.max", "equi.prob", "se.min", "user.defined"),
       statistic=c("likelihood", "Wilcoxon", "Pearson", "Wald"),
       alternative = c("difference", "similarity", "two.sided",
       "less", "greater"),
       tau=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d.primeA</code></td>
<td>
<p>the value of d-prime under the alternative hypothesis;
non-negative numerical scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.prime0</code></td>
<td>
<p>the value of d-prime under the null hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncat</code></td>
<td>
<p>the number of response categories in the DOD model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.size</code></td>
<td>
<p>the sample size in each simulation for each of the
same-pairs and different pairs. Can be a single scalar value or a
2-vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>the number of simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the significance level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.tau</code></td>
<td>
<p>the method with which to choose the boundary
parameters - see <code>dodSim</code> for details on the methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>the statistic to be used for hypothesis testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>the nature of the alternative hypothesis in the
hypothesis/significance test for d-prime. Note that
<code>"greater"</code> is an alias for <code>"difference"</code> and
<code>"less"</code> is an alias for <code>"similarity"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>if <code>method.tau = "user.defined"</code> a vector of boundary
parameters in the DOD model, otherwise not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parsed on to <code>wilcox.test</code> when appropriate.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The simulation based estimate of the power with the following
attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>se(power)</code></td>
<td>
<p>the estimated standard error of the estimated
power. This is based on the formula
<code>sqrt(pow * (1 - pow) / n)</code>, where <code>pow</code> is the estimated
power and <code>n</code> is the number of simulations used to estimate the
power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.used</code></td>
<td>
<p>the number of simulations used to estimate the
power. This is usually equal to nsim, but can sometimes be smaller
than nsim due to non-convergences to which the Wald test is
especially prone.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Rune Haubo B Christensen</p>


<h3>References</h3>

<p>Ennis, J.M. and R.H.B. Christensen (2015) A Thurstonian comparison
of the tetrad and degree of difference tests.
<em>Food Quality and Preference</em>, 40, pp.263-269.
</p>


<h3>See Also</h3>

 <p><code>dod</code>, <code>dod_fit</code>,
<code>dodSim</code>, <code>optimal_tau</code>,
<code>dodControl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## NOTE: The number of simulations (nsim) is set unrealistically low in
## the examples below to reduce the computation time for automatic
## package checks. nsim between 1e3 and 1e4 is usually sufficient and
## the latter often on the safe side. The standard error of the
## estimated power ('se(power)') reported by dodPwr() measures the
## accuracy of the estimated power and indicates if nsim needs to be
## increased.

## Estimate power of the conventional difference test (no-difference
## under the null hypothesis):
set.seed(125)
dodPwr(d.primeA=1, d.prime0=0, ncat=4, sample.size=100, nsim=50,
       alpha=.05, method.tau="LR.max", statistic="likelihood")
##  [1] 0.62
##  attr(,"se(power)")
##  [1] 0.1825346
##  attr(,"n.used")
##  [1] 50
## Here the boundary parameters are chosen automatically so as to
## maximize the likelihood ratio test statistic, and so this setting
## amounts to a highest achievable power scenario given d-prime = 1.

## Using another (and faster) statistic:
dodPwr(d.primeA=1, d.prime0=0, ncat=4, sample.size=100, nsim=1e3,
       alpha=.05, method.tau="LR.max", statistic="Wilcox")


## Not automatically run to reduce computation time.

## Power of a similarity test:
set.seed(127)
dodPwr(d.primeA=0, d.prime0=1, ncat=4, sample.size=100, nsim=1e2,
       alpha=.05, method.tau="LR.max", statistic="Pearson",
       alternative="similarity")
##  [1] 0.71
##  attr(,"se(power)")
##  [1] 0.1434922
##  attr(,"n.used")
##  [1] 100

## Same as above, but with a given set of boundary parameters:
dodPwr(d.primeA=0, d.prime0=1, sample.size=100, nsim=1e2,
       alpha=.05, method.tau="user.defined", statistic="Pearson",
       alternative="similarity", tau=1:3)

## Using parallel computing to speed up computations:
if(require(parallel)) {
    ## Use detectCores() to get an appropriate number of cores for
    ## practical use - for the example here we fix it at 2:
    ## cl &lt;- makeCluster(detectCores())
    cl &lt;- makeCluster(getOption("cl.cores", 2))
    dvec &lt;- c(0, .2, .5, .7, 1, 1.2, 1.5, 1.75)
    system.time(
        res &lt;- parLapply(cl, dvec, fun=function(dp) {
            library(sensR)
            x &lt;- dodPwr(dp, 0, sample.size=100, nsim=1e4, stat="Wil")
            c("power"=x, "se"=attr(x, "se(power)"))
        })
        )
    stopCluster(cl)
    names(res) &lt;- dvec
    mat &lt;- do.call(cbind, res)
    round(mat[1:2, ], 3)
    ## Example output:
    ##            0   0.2   0.5   0.7     1   1.5  1.75     2
    ##  power 0.051 0.058 0.123 0.238 0.578 0.983 1.000 1.000
    ##  se    0.022 0.023 0.033 0.043 0.049 0.013 0.002 0.001
}

## Realistically one should use more simulations, e.g. nsim=1e4.


</code></pre>


</div>