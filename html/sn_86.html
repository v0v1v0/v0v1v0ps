<div class="container">

<table style="width: 100%;"><tr>
<td>symm-modulated-distr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Symmetry-modulated distributions</h2>

<h3>Description</h3>

<p>Symmetry-modulated distributions, univariate and multivariate,
AKA skew-symmetric distributions</p>


<h3>Usage</h3>

<pre><code class="language-R">dSymmModulated(x, xi=0, omega=1, f0, G0, w, par.f0, par.G0, odd="check", 
  log=FALSE, ...)
rSymmModulated(n=1, xi=0, omega=1, f0, G0, w, par.f0, par.G0, odd="check", ...) 
dmSymmModulated(x, xi, Omega, f0, G0, w, par.f0, par.G0, odd="check", 
  log=FALSE, ...) 
rmSymmModulated(n=1, xi, Omega, f0, G0, w, par.f0, par.G0, odd="check", ...)
plot2D.SymmModulated(range, npt=rep(101,2), xi=c(0,0), Omega, f0, G0, w, 
  par.f0, par.G0, odd="check", ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of coordinates where the density must be evaluated; 
for multivariate densities, evaluated by <code>dmSymmModulated</code>, 
a matrix is also allowed, each row representing a point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>a numeric vector representing the location parameter; 
if must have length 1 for <code>dSymmModulated</code> and <code>rSymmModulated</code>,
length 2 for <code>plot2D.SymmModulated</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>a positive value representing the scale parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f0</code></td>
<td>
<p>a character string denoting the symmetric density to be modulated;
admissible values for <code>dSymmModulated</code> and <code>dSymmModulated</code> 
are <code>"beta"</code>, <code>"cauchy"</code>, <code>"logistic"</code> (or <code>"logis"</code>), 
<code>"normal"</code> (or <code>"norm"</code>), <code>"t"</code>, <code>"uniform"</code>;   
for the other functions the possible 
values are <code>"cauchy"</code>, <code>"normal"</code> (or <code>"norm"</code>), <code>"t"</code>; 
the meaning of the names is described in the ‘Details’  section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G0</code></td>
<td>
<p>a character string denoting the symmetric distribution used in the
modulating factor; admissible values are <code>"beta"</code>, <code>"cauchy"</code>, 
<code>"logistic"</code> (or <code>"logis"</code>), <code>"normal"</code> (or <code>"norm"</code>), 
<code>"t"</code>, <code>"uniform"</code>,  with meaning  described in the
‘Details’ section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>the name (<em>not</em> as a character string) of a user-defined 
function which satisfies the condition <code class="reqn">w(-z)=-w(z)</code> for all <code class="reqn">z</code>;
see the ‘Details’ section for additional specifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.f0, par.G0</code></td>
<td>
<p>parameters required by <code>f0</code> and <code>G0</code>, 
when they are of type <code>"beta"</code> or <code>"t"</code>, otherwise ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odd</code></td>
<td>
<p>a character string, with possible values <code>"check"</code> (default),
"assume", "force",  for regulation of the behaviour about the condition
that <code>w</code> is an odd function, as explained in the ‘Details’
section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical (default: <code>FALSE</code>); 
if <code>TRUE</code>, densities are given as log(densities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>an integer value (default: <code>n=1</code>) indicating the number of 
random numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>a symmetric positive-definite matrix which regulates the 
dependence structure of <code>f0</code> and so of the final density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>a two-column matrix whose column-wise range is taken as the
plotting intervals  on the coordinated axes forming a bivariate grid of
points over which the density is plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npt</code></td>
<td>
<p>a numeric vector with two elements representing the number of  
equally-spaced points on each axis spanning the <code>range</code> described 
above;  default value is <code>rep(101,2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional parameters regulating the function <code>w</code> and, for 
<code>plot2D.SymmModulated</code> only, graphical parameters to be supplied to
function <code>contour</code>. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>dSymmModulated</code>, <code>rSymmModulated</code> and  <code>dmSymmModulated</code>, 
a numeric vector; for <code>dmSymmModulated</code> a matrix, unless <code>n=1</code>.
</p>
<p>For <code>plot2D.SymmModulated</code> an invisible list containing the <code>x</code>
and <code>y</code> coordinates forming the grid over which the density <code>pdf</code>
has been evaluated for plotting.
</p>


<h3>Background</h3>

<p>In the univariate case, start from symmetric density function <code class="reqn">f_0</code>, 
such that  <code class="reqn">f_0(z)=f_0(-z)</code> for all <code class="reqn">z</code>, and 
‘modulate’  it in the form 
</p>
<p style="text-align: center;"><code class="reqn">f(z) = 2\, f_0(z)\, G_0\{w(z)\}</code>
</p>

<p>where <code class="reqn">G_0</code> is a univariate symmetric (about 0) distribution function 
and <code class="reqn">w(z)</code>is a real-valued odd function, hence satisfying the condition 
<code class="reqn">w(-z)=-w(z)</code>;
then $f(z)$ is a proper density function wich integrates to 1. 
A subsequent location and scale transformation applied to <code class="reqn">f(z)</code> 
delivers the final density. 
Specifically, if <code class="reqn">Z</code> denotes a univariate random variable with density 
<code class="reqn">f(z)</code>, then the computed density pertains to the transformed variable
</p>
<p style="text-align: center;"><code class="reqn">\xi + \omega Z.</code>
</p>

<p>In the multivariate case, the scheme is similar, with natural adaptation.
Density <code class="reqn">f_0</code> is  now <code class="reqn">d</code>-dimensional, while <code class="reqn">G_0</code> 
is still univariate. The conditions <code class="reqn">f_0(z)=f_0(-z)</code> 
and <code class="reqn">w(-z)=-w(z)</code> refer to a <code class="reqn">d</code>-dimensional vector <code class="reqn">z</code>.  
Given a <code class="reqn">d \times d</code> symmetric positive-definite matrix 
<code class="reqn">\Omega</code>, we extract the the square roots <code class="reqn">\omega</code> of the diagonal 
element of  <code class="reqn">\Omega</code> and correspondingly obtain the scale-free matrix
</p>
<p style="text-align: center;"><code class="reqn">\bar\Omega = \mathrm{diag}(\omega)^{-1}\, \Omega\,
                             \mathrm{diag}(\omega)^{-1}
     </code>
</p>

<p>which is used to regulate the dependence structure of <code class="reqn">f_0(z)</code> 
and so of <code class="reqn">f(z)</code>. 
If <code class="reqn">Z</code> is multivariate random variable with density <code class="reqn">f(z)</code>, 
then the final distribution refers to 
</p>
<p style="text-align: center;"><code class="reqn">\xi + \mathrm{diag}(\omega)\,Z </code>
</p>

<p>where <code class="reqn">\xi</code> is a <code class="reqn">d</code>-dimensional vector of location parametes.
</p>
<p>This construction was put forward by Azzalini and Capitanio (2003). 
An essentially equivalent formulation has been presented by Wang et al. (2004).
A summary account is available in Section 1.2 of Azzalini and Capitanio
(2014); this includes, inter alia, an explanation  of why the term
‘symmetry-modulated’ distributions is preferred to 
‘skew-symmetric’ distributions. 
</p>
<p>Random number generation is based on expression (1.11a) of
Azzalini and Capitanio (2014).
</p>


<h3>Details</h3>

<p>Functions <code>dSymmModulated</code> and <code>rSymmModulated</code> deal with univariate 
distributions, for computing densities and generating random rumbers, 
respectively; 
<code>dmSymmModulated</code> and <code>rmSymmModulated</code> act similarly 
for multivariate distributions. For the bivariate case only,
<code>plot2D.SymmModulated</code> computes a density over a grid of
coordinates and produces a <code>contour</code> plot. 
</p>
<p>The distribution names used in <code>f0</code> and <code>G0</code> have, in the univariate
case, the same meaning as described in the <code>Distributions</code>
page, with the following exceptions, to achive symmetry about 0: 
<code>"uniform"</code> denotes a  uniform distribution over the interval 
<code class="reqn">(-1, 1)</code>; <code>"beta"</code> denotes the a symmetric Beta distribution with
support  over the interval <code class="reqn">(-1, 1)</code> and a common value of the shape 
parameters.
</p>
<p>In the multivariate case, the available options <code>"normal"</code> and <code>"t"</code>
for <code>f0</code> refer to densities computed by  <code>dmnorm</code> 
and <code>dmt</code> with 0 location and correlation matrix   
<code class="reqn">\bar\Omega</code>, implied by <code class="reqn">\Omega</code>. 
Argument <code>G0</code> has the same meaning as in the univariate case.
</p>
<p>Options <code>"beta"</code> and <code>"t"</code> for <code>f0</code> and <code>G0</code> require the
specification of a shape parameter, via the arguments <code>par.f0</code> and
<code>par.G0</code>, respectively. For <code>"beta"</code> the parameter represents
the common value of the shape parameters of <code>Beta</code>;
for <code>"t"</code>, it represents <code>df</code> of <code>TDist</code> and
<code>dmt</code>. 
</p>
<p>Function <code>w</code> most be  of the form <code>w &lt;- function(z, ...)</code> where
<code>...</code> are optional additional parameters and <code>z</code> represents valued
of the standardized form of the density; in the univariate case, <code>x</code> and
<code>z</code> are related by <code>z=(x-xi)/omega</code> and an analogous fact holds in
the multivariate setting. The function must satisfy the condition
<code class="reqn">w(-z)=-w(z)</code>. It is assumed that the function is vectorized and, in the
multivariate case, it will be called with <code>z</code> representing a matrix with
<code>d</code> columns, if <code>d</code> denotes the dimensionality of the random
variable.
</p>
<p>Argument <code>odd</code> regulates the behaviour with respect to the condition 
<code class="reqn">w(-z)=-w(z)</code>. If its value is <code>"assume"</code>, the condition is just
assumed to hold, and no action is taken. If the value is <code>"check"</code>
(deafult), a <em>limited</em> check is performed; namely, in case of densities,
the check is at 0 and the supplied <code>x</code> points, while for random numbers  
the check is at 0 and the generated points.
The value <code>"force"</code> ensures that the condition is satisfied by 
actually constructing a modified version of the user-supplied function 
<code>w</code>, such that the required condition is enforced. 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B., Gómez, H. W. and Quintana, F. A. (2004).
A new class of skew-normal distributions. <em>Comm. Stat., Theory &amp;
Methods</em>, <b>58</b>, 111-121. 
</p>
<p>Azzalini, A. and Capitanio, A. (2003).
Distributions generated by perturbation of symmetry 
with emphasis on a multivariate skew-<em>t</em> distribution.
<em>J.Roy. Statist. Soc. B</em> <b>65</b>, 367–389.
Full version of the paper at <a href="https://arXiv.org/abs/0911.2342">https://arXiv.org/abs/0911.2342</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.    
</p>
<p>Wang, J., Boyer, J. and Genton, M. G. (2004).
A skew-symmetric representation of multivariate distributions.
<em>Statistica Sinica</em>, <b>14</b>, 1259-1270.
</p>


<h3>See Also</h3>

<p><code>Distributions</code>, 
<code>Beta</code>, <code>TDist</code>,
<code>dmnorm</code>, <code>dmt</code>, 
<code>contour</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- seq(2, 13, length=45)
wLinear &lt;- function(z, lambda) lambda*z
y &lt;- dSymmModulated(x, 5, 2, f0="normal", G0="normal", w=wLinear, lambda=3)
# the same of dsn(x, 5, 2, 3), up to negligible numerical differences
#
wSGN &lt;- function(z, lambda) z*lambda[1]/sqrt(1 + lambda[2]*z^2) 
y &lt;- dSymmModulated(x, 5, 2, f0="normal", G0="normal", w=wSGN, lambda=c(3,5))
# SGN distribution of Arellano-Valle et al. (2004)
#
wST &lt;- function(z, lambda, nu) lambda*z*sqrt((nu+1)/(nu+z^2))
y &lt;- rSymmModulated(n=100, 5, 2, f0="t", G0="t", w=wST, par.f0=8, par.G0=9, 
        lambda=3, nu=8)
# equivalent to rst(n=100, 5, 2, 3, 8) 
#
wTrigs &lt;- function(z, p, q) sin(z * p)/(1 + cos(z * q))
x &lt;- seq(-1, 1, length=51)
y &lt;- dSymmModulated(x, 0, 1, f0="beta", G0="logistic", w=wTrigs, par.f0=2,
        par.G0=NULL, p=5, q=0.5)   
plot(x, y, type="l")        
# univariate analogue of the bivariate distribution on pp.372-3 of
# Azzalini &amp; Capitanio (2003)           
#
range &lt;- cbind(c(-3,3), c(-3,3))
wMvTrigs &lt;- function(z, p, q) sin(z %*% p)/(1 + cos(z %*% q))
plot2D.SymmModulated(range, xi=c(0,0), Omega=diag(2), f0="normal", G0="normal",
    w=wMvTrigs, par.f0=NULL, par.G0=NULL, p=c(2,3), q=c(1,1), col=4)
# w(.) as in (1.6) of Azzalini &amp; Capitanio (2014, p.4) and plot as in 
# bottom-right panel of their Figure 1.1.      
</code></pre>


</div>