<div class="container">

<table style="width: 100%;"><tr>
<td>efficiencies</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute conditional (in-)efficiency estimates of stochastic frontier models</h2>

<h3>Description</h3>

<p><code>efficiencies</code> returns (in-)efficiency estimates of models
estimated with <code>sfacross</code>, <code>sfalcmcross</code>, or
<code>sfaselectioncross</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sfacross'
efficiencies(object, level = 0.95, newData = NULL, ...)

## S3 method for class 'sfalcmcross'
efficiencies(object, level = 0.95, newData = NULL, ...)

## S3 method for class 'sfaselectioncross'
efficiencies(object, level = 0.95, newData = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A stochastic frontier model returned
by <code>sfacross</code>, <code>sfalcmcross</code>, or
<code>sfaselectioncross</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>A number between between 0 and 0.9999 used for the computation
of (in-)efficiency confidence intervals (defaut = <code>0.95</code>). Only used
when <code>udist</code> = <code>'hnormal'</code>, <code>'exponential'</code>, <code>'tnormal'</code>
or <code>'uniform'</code> in <code>sfacross</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newData</code></td>
<td>
<p>Optional data frame that is used to calculate the efficiency
estimates. If NULL (the default), the efficiency estimates are calculated
for the observations that were used in the estimation. In the case of object of
class <code>sfaselectioncross</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In general, the conditional inefficiency is obtained following
Jondrow <em>et al.</em> (1982) and the conditional efficiency is computed
following Battese and Coelli (1988). In some cases the conditional mode is
also returned (Jondrow <em>et al.</em> 1982). The confidence interval is
computed following Horrace and Schmidt (1996), Hjalmarsson <em>et al.</em>
(1996), or Berra and Sharma (1999) (see ‘Value’ section).
</p>
<p>In the case of the half normal distribution for the one-sided error term,
the formulae are as follows (for notations, see the ‘Details’ section
of <code>sfacross</code> or <code>sfalcmcross</code>):
</p>
 <ul><li>
<p> The conditional inefficiency is: </p>
</li></ul>
<p style="text-align: center;"><code class="reqn">E\left\lbrack u_i|\epsilon_i\right
\rbrack=\mu_{i\ast} + \sigma_\ast\frac{\phi
\left(\frac{\mu_{i\ast}}{\sigma_\ast}\right)}{
\Phi\left(\frac{\mu_{i\ast}}{\sigma_\ast}\right)}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\mu_{i\ast}=\frac{-S\epsilon_i\sigma_u^2}{ \sigma_u^2 + \sigma_v^2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\sigma_\ast^2 = \frac{\sigma_u^2 \sigma_v^2}{\sigma_u^2 + \sigma_v^2}</code>
</p>

 <ul><li>
<p> The Battese and Coelli (1988) conditional efficiency is
obtained with: </p>
</li></ul>
<p style="text-align: center;"><code class="reqn">E\left\lbrack\exp{\left(-u_i\right)}
|\epsilon_i\right\rbrack = \exp{\left(-\mu_{i\ast}+
\frac{1}{2}\sigma_\ast^2\right)}\frac{\Phi\left(
\frac{\mu_{i\ast}}{\sigma_\ast}-\sigma_\ast\right)}{
\Phi\left(\frac{\mu_{i\ast}}{\sigma_\ast}\right)}</code>
</p>

 <ul><li>
<p> The reciprocal of the Battese and Coelli (1988) conditional
efficiency is obtained with: </p>
</li></ul>
<p style="text-align: center;"><code class="reqn">E\left\lbrack\exp{\left(u_i\right)}
|\epsilon_i\right\rbrack = \exp{\left(\mu_{i\ast}+
\frac{1}{2}\sigma_\ast^2\right)} \frac{\Phi\left(
\frac{\mu_{i\ast}}{\sigma_\ast}+\sigma_\ast\right)}{
\Phi\left(\frac{\mu_{i\ast}}{\sigma_\ast}\right)}</code>
</p>

 <ul><li>
<p> The conditional mode is computed using: </p>
</li></ul>
<p style="text-align: center;"><code class="reqn">M\left\lbrack u_i|\epsilon_i\right
\rbrack= \mu_{i\ast} \quad \hbox{For} \quad 
\mu_{i\ast} &gt; 0</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">M\left\lbrack u_i|\epsilon_i\right
\rbrack= 0 \quad \hbox{For} \quad \mu_{i\ast} \leq 0</code>
</p>

 <ul><li>
<p> The confidence intervals are obtained with: </p>
</li></ul>
<p style="text-align: center;"><code class="reqn">\mu_{i\ast} + I_L\sigma_\ast \leq 
E\left\lbrack u_i|\epsilon_i\right\rbrack \leq 
\mu_{i\ast} + I_U\sigma_\ast </code>
</p>

<p>with <code class="reqn">LB_i = \mu_{i*} + I_L\sigma_*</code> and
<code class="reqn">UB_i = \mu_{i*} + I_U\sigma_*</code>
</p>
<p>and
</p>
<p style="text-align: center;"><code class="reqn">I_L = \Phi^{-1}\left\lbrace 1 -
\left(1-\frac{\alpha}{2}\right)\left\lbrack 1-
\Phi\left(-\frac{\mu_{i\ast}}{\sigma_\ast}\right)
\right\rbrack\right\rbrace </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">I_U = \Phi^{-1}\left\lbrace 1-
\frac{\alpha}{2}\left\lbrack 1-\Phi
\left(-\frac{\mu_{i\ast}}{\sigma_\ast}\right)
\right\rbrack\right\rbrace</code>
</p>

<p>Thus
</p>
<p style="text-align: center;"><code class="reqn">\exp{\left(-UB_i\right)} \leq E\left
\lbrack\exp{\left(-u_i\right)}|\epsilon_i\right\rbrack 
\leq\exp{\left(-LB_i\right)}</code>
</p>

<p>In the case of the sample selection, as underlined in Greene (2010), the
conditional inefficiency could be computed using Jondrow <em>et al.</em> (1982).
However, here the conditionanl (in)efficiency is obtained using the properties
of the closed skew-normal (CSN) distribution (Lai, 2015). The conditional
efficiency can be obtained using the moment generating functions of a CSN
distribution (see Gonzalez-Farias <em>et al.</em> (2004)). We have:
</p>
<p style="text-align: center;"><code class="reqn">E\left\lbrack\exp{\left(tu_i\right)}
|\epsilon_i\right\rbrack = M_{u|\epsilon}(t)=\frac{\Phi_2\left(\tilde{\mathbf{D}}
\tilde{\bm{\Sigma}}t; \tilde{\bm{\kappa}}, \tilde{\bm{\Delta}} + 
\tilde{\mathbf{D}}\tilde{\bm{\Sigma}}\tilde{\mathbf{D}}' \right)}{
\Phi_2\left(\mathbf{0}; \tilde{\bm{\kappa}}, \tilde{\bm{\Delta}} + 
\tilde{\mathbf{D}}\tilde{\bm{\Sigma}}\tilde{\mathbf{D}}'\right)}\exp{
\left(t\tilde{\bm{\pi}} + \frac{1}{2}t^2\tilde{\bm{\Sigma}}\right)}</code>
</p>

<p>where <code class="reqn">\tilde{\bm{\pi}} = \frac{-S\epsilon_i\sigma_u^2}{\sigma_v^2 + \sigma_u^2}</code>,
<code class="reqn">\tilde{\bm{\Sigma}} = \frac{\sigma_v^2\sigma_u^2}{\sigma_v^2 + \sigma_u^2}</code>,
<code class="reqn">\tilde{\mathbf{D}} = \begin{pmatrix} \frac{S\rho}{\sigma_v} \\ 1 \end{pmatrix}</code>,
<code class="reqn">\tilde{\bm{\kappa}} = \begin{pmatrix} - \mathbf{Z}'_{si}\bm{\gamma} - 
\frac{\rho\sigma_v\epsilon_i}{\sigma_v^2 + \sigma_u^2}\\ 
\frac{S\sigma_u^2\epsilon_i}{\sigma_v^2 + \sigma_u^2} \end{pmatrix}</code>,
<code class="reqn">\tilde{\bm{\Delta}} = \begin{pmatrix}1-\rho^2 &amp; 0 \\ 0 &amp; 0\end{pmatrix}</code>.
</p>
<p>The derivation of the efficiency and the reciprocal efficiency is obtained by replacing
<code class="reqn">t = -1</code> and <code class="reqn">t =1</code>, respectively. To obtain the inefficiency as
<code class="reqn">E\left[u_i|\epsilon_i\right]</code> is more complicated as it requires the
derivation of a multivariate normal cdf. We have:
</p>
<p style="text-align: center;"><code class="reqn">E\left[u_i|\epsilon_i\right] = \left. \frac{\partial M_{u|\epsilon}(t)}{\partial t}\right\rvert_{t = 0}</code>
</p>

<p>Then
</p>
<p style="text-align: center;"><code class="reqn">E\left[u_i|\epsilon_i\right] = \tilde{\bm{\pi}} + 
\left(\tilde{\mathbf{D}}\tilde{\bm{\Sigma}}\right)'\frac{\Phi_2^*
\left(\mathbf{0}; \tilde{\bm{\kappa}}, \ddot{\bm{\Delta}}\right)}{
\Phi_2\left(\mathbf{0}; \tilde{\bm{\kappa}}, \ddot{\bm{\Delta}}\right)}</code>
</p>

<p>where <code class="reqn">\Phi_2^* \left(\mathbf{s}; \tilde{\bm{\kappa}}, \ddot{\bm{\Delta}}\right)=
\frac{\partial \Phi_2\left(\mathbf{s}; \tilde{\bm{\kappa}}, \ddot{\bm{\Delta}} \right)}{\partial \mathbf{s}}</code>
</p>


<h3>Value</h3>

<p>A data frame that contains individual (in-)efficiency estimates.
These are ordered in the same way as the corresponding observations in the
dataset used for the estimation.
</p>
<p><b>- For object of class <code>'sfacross'</code> the following elements are returned:</b>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Conditional inefficiency. In the case argument <code>udist</code> of
sfacross is set to <code>'uniform'</code>, two conditional inefficiency
estimates are returned: <code>u1</code> for the classic conditional inefficiency
following Jondrow <em>et al.</em> (1982), and <code>u2</code> which is obtained when
<code class="reqn">\theta/\sigma_v \longrightarrow \infty</code> (see Nguyen, 2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uLB</code></td>
<td>
<p>Lower bound for conditional inefficiency. Only when the argument
<code>udist</code> of sfacross is set to <code>'hnormal'</code>,
<code>'exponential'</code>, <code>'tnormal'</code> or <code>'uniform'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uUB</code></td>
<td>
<p>Upper bound for conditional inefficiency. Only when the argument
<code>udist</code> of sfacross is set to <code>'hnormal'</code>,
<code>'exponential'</code>, <code>'tnormal'</code> or <code>'uniform'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teJLMS</code></td>
<td>
<p><code class="reqn">\exp{(-E[u|\epsilon])}</code>. When the argument <code>udist</code> of
sfacross is set to <code>'uniform'</code>, <code>teJLMS1</code> =
<code class="reqn">\exp{(-E[u_1|\epsilon])}</code> and <code>teJLMS2</code> =
<code class="reqn">\exp{(-E[u_2|\epsilon])}</code>. Only when <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Conditional model. Only when the argument <code>udist</code> of
sfacross is set to <code>'hnormal'</code>, <code>'exponential'</code>,
<code>'tnormal'</code>, or <code>'rayleigh'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teMO</code></td>
<td>
<p><code class="reqn">\exp{(-m)}</code>. Only when, in the function sfacross,
<code>logDepVar = TRUE</code> and <code>udist = 'hnormal'</code>, <code>'exponential'</code>,
<code>'tnormal'</code>, <code>'uniform'</code>, or <code>'rayleigh'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC</code></td>
<td>
<p>Battese and Coelli (1988) conditional efficiency. Only when, in
the function sfacross,  <code>logDepVar = TRUE</code>.
In the case <code>udist = 'uniform'</code>, two
conditional efficiency estimates are returned:
<code>teBC1</code> which is the classic conditional efficiency following
Battese and Coelli (1988) and <code>teBC2</code> when
<code class="reqn">\theta/\sigma_v \longrightarrow \infty</code> (see Nguyen, 2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_reciprocal</code></td>
<td>
<p>Reciprocal of Battese and Coelli (1988) conditional
efficiency. Similar to <code>teBC</code> except that it is computed as
<code class="reqn">E\left[\exp{(u)}|\epsilon\right]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBCLB</code></td>
<td>
<p>Lower bound for Battese and Coelli (1988) conditional
efficiency. Only when, in the function sfacross, <code>logDepVar = TRUE</code> and
<code>udist = 'hnormal'</code>, <code>'exponential'</code>, <code>'tnormal'</code>,
or <code>'uniform'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBCUB</code></td>
<td>
<p>Upper bound for Battese and Coelli (1988) conditional
efficiency. Only when, in the function sfacross, <code>logDepVar = TRUE</code> and
<code>udist = 'hnormal'</code>, <code>'exponential'</code>, <code>'tnormal'</code>,
or <code>'uniform'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>In the case <code>udist = 'uniform'</code>. <code class="reqn">u \in [0, \theta]</code>.</p>
</td>
</tr>
</table>
<p><b>- For object of class <code>'sfalcmcross'</code> the following elements are returned:</b>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Group_c</code></td>
<td>
<p>Most probable class for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PosteriorProb_c</code></td>
<td>
<p>Highest posterior probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u_c</code></td>
<td>
<p>Conditional inefficiency of the most probable class given the
posterior probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teJLMS_c</code></td>
<td>
<p><code class="reqn">\exp{(-E[u_c|\epsilon_c])}</code>. Only when, in the function
sfalcmcross <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_c</code></td>
<td>
<p><code class="reqn">E\left[\exp{(-u_c)}|\epsilon_c\right]</code>. Only when, in the
function sfalcmcross <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_reciprocal_c</code></td>
<td>
<p><code class="reqn">E\left[\exp{(u_c)}|\epsilon_c\right]</code>. Only
when, in the function sfalcmcross <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PosteriorProb_c#</code></td>
<td>
<p>Posterior probability of class #.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PriorProb_c#</code></td>
<td>
<p>Prior probability of class #.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u_c#</code></td>
<td>
<p>Conditional inefficiency associated to class #, regardless of
<code>Group_c</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_c#</code></td>
<td>
<p>Conditional efficiency
(<code class="reqn">E\left[\exp{(-u_c)}|\epsilon_c\right]</code>) associated to class #,
regardless of <code>Group_c</code>. Only when, in the function
sfalcmcross <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_reciprocal_c#</code></td>
<td>
<p>Reciprocal conditional efficiency
(<code class="reqn">E\left[\exp{(u_c)}|\epsilon_c\right]</code>) associated to class #,
regardless of <code>Group_c</code>. Only when, in the function
sfalcmcross <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ineff_c#</code></td>
<td>
<p>Conditional inefficiency (<code>u_c</code>) for observations in
class # only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effBC_c#</code></td>
<td>
<p>Conditional efficiency (<code>teBC_c</code>) for observations in
class # only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ReffBC_c#</code></td>
<td>
<p>Reciprocal conditional efficiency (<code>teBC_reciprocal_c</code>)
for observations in class # only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_c#</code></td>
<td>
<p>In the case <code>udist = 'uniform'</code>. <code class="reqn">u \in [0, \theta_{c\#}]</code>.</p>
</td>
</tr>
</table>
<p><b>- For object of class <code>'sfaselectioncross'</code> the following elements are returned:</b>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Conditional inefficiency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teJLMS</code></td>
<td>
<p><code class="reqn">\exp{(-E[u|\epsilon])}</code>. Only when <code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC</code></td>
<td>
<p>Battese and Coelli (1988) conditional efficiency. Only when, in
the function sfaselectioncross,
<code>logDepVar = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teBC_reciprocal</code></td>
<td>
<p>Reciprocal of Battese and Coelli (1988) conditional
efficiency. Similar to <code>teBC</code> except that it is computed as
<code class="reqn">E\left[\exp{(u)}|\epsilon\right]</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Battese, G.E., and T.J. Coelli. 1988. Prediction of firm-level
technical efficiencies with a generalized frontier production function and
panel data. <em>Journal of Econometrics</em>, <b>38</b>:387–399.
</p>
<p>Bera, A.K., and S.C. Sharma. 1999. Estimating production uncertainty in
stochastic frontier production function models. <em>Journal of
Productivity Analysis</em>, <b>12</b>:187-210.
</p>
<p>Gonzalez-Farias, G., Dominguez-Molina, A., Gupta, A. K., 2004. Additive
properties of skew normal random vectors.
<em>Journal of Statistical Planning and Inference</em>. <b>126</b>: 521-534.
</p>
<p>Greene, W., 2010. A stochastic frontier model with correction
for sample selection. <em>Journal of Productivity Analysis</em>. <b>34</b>, 15–24.
</p>
<p>Hjalmarsson, L., S.C. Kumbhakar, and A. Heshmati. 1996. DEA, DFA and SFA: A
comparison. <em>Journal of Productivity Analysis</em>, <b>7</b>:303-327.
</p>
<p>Horrace, W.C., and P. Schmidt. 1996. Confidence statements for efficiency
estimates from stochastic frontier models. <em>Journal of Productivity
Analysis</em>, <b>7</b>:257-282.
</p>
<p>Jondrow, J., C.A.K. Lovell, I.S. Materov, and P. Schmidt. 1982. On the
estimation of technical inefficiency in the stochastic frontier production
function model. <em>Journal of Econometrics</em>, <b>19</b>:233–238.
</p>
<p>Lai, H. P., 2015. Maximum likelihood estimation of the stochastic frontier
model with endogenous switching or sample selection.
<em>Journal of Productivity Analysis</em>, <b>43</b>: 105-117.
</p>
<p>Nguyen, N.B. 2010. Estimation of technical efficiency in stochastic frontier
analysis. PhD Dissertation, Bowling Green State University, August.
</p>


<h3>See Also</h3>

<p><code>sfalcmcross</code>, for the latent class stochastic frontier analysis
model fitting function using cross-sectional or pooled data.
</p>
<p><code>sfacross</code>, for the stochastic frontier analysis model
fitting function using cross-sectional or pooled data.
</p>
<p><code>sfaselectioncross</code> for sample selection in stochastic frontier
model fitting function using cross-sectional or pooled data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## Using data on fossil fuel fired steam electric power generation plants in the U.S.
# Translog SFA (cost function) truncated normal with scaling property
tl_u_ts &lt;- sfacross(formula = log(tc/wf) ~ log(y) + I(1/2 * (log(y))^2) + log(wl/wf) +
log(wk/wf) + I(1/2 * (log(wl/wf))^2) + I(1/2 * (log(wk/wf))^2) + I(log(wl/wf) *
log(wk/wf)) + I(log(y) * log(wl/wf)) + I(log(y) * log(wk/wf)), udist = 'tnormal',
muhet = ~ regu, uhet = ~ regu, data = utility, S = -1, scaling = TRUE, method = 'mla')
eff.tl_u_ts &lt;- efficiencies(tl_u_ts)
head(eff.tl_u_ts)
summary(eff.tl_u_ts)

## End(Not run)

</code></pre>


</div>