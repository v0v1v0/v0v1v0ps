<div class="container">

<table style="width: 100%;"><tr>
<td>pc_Sigma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Method to simulate correlated variables with change-points</h2>

<h3>Description</h3>

<p>An S4 method that takes a <code>simMGarch</code> object and outputs simulated correlated time series with a piecewise constant covariance matrix. 
The correlations are generated as <code class="reqn">\sigma_{i, i'} =  \rho^{|i-i'|}</code> with <code class="reqn">\rho</code> taking values from <code class="reqn">(-1,1)</code>. The exact variables that will contain a change-point are
randomly selected and controlled by <code>r</code> in the <code>simMGarch</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pc_Sigma(object)

## S4 method for signature 'simMGarch'
pc_Sigma(object)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>simMGarch</code> object.</p>
</td>
</tr></table>
<h3>References</h3>

<p>Cho, Haeran, and Karolos Korkas. "High-dimensional GARCH process segmentation with an application to Value-at-Risk." arXiv preprint arXiv:1706.01155 (2017).
</p>


<h3>Examples</h3>

<pre><code class="language-R">cp=500
n=2000
pw.CCC.obj &lt;- new("simMGarch")
pw.CCC.obj@changepoints=cp
pw.CCC.obj@n=n
pc_Sigma.obj &lt;- pc_Sigma(pw.CCC.obj)
par(mfrow=c(1,2))
#requires corrplot library
#correlation matrix before the changepoint
#corrplot::corrplot.mixed(cor(pc_Sigma.obj@cor_errors[1:cp,]), order="hclust", tl.col="black")
#correlation matrix after the changepoint
#corrplot::corrplot.mixed(cor(pc_Sigma.obj@cor_errors[(cp+1):n,]), order="hclust", tl.col="black")
</code></pre>


</div>