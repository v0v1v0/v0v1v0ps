<div class="container">

<table style="width: 100%;"><tr>
<td>turnover</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Specifying a Dynamic Population </h2>

<h3>Description</h3>

<p><code>sim.popn</code> can simulate a multi-session population with known between-session survival, recruitment and movement probabilities. The parameter settings to achieve this are passed to <code>sim.popn</code> in its ‘details’ argument. Components of ‘details’ that are relevant to turnover are described below; see <code>sim.popn</code> for others.
</p>
<p>Multi-session populations are generated in <code>sim.popn</code> whenever its argument ‘nsessions’ is greater than 1. If <code>details$lambda</code> remains NULL (the default) then the population for each successive session is generated de novo from the given density model (model2D, D etc.). If a value is specified for <code>details$lambda</code> then only the first population is generated de novo; remaining populations are generated iteratively with probabilistic mortality, recruitment and movement as described here.
</p>


<h3>Turnover components of <code>sim.popn</code> details argument</h3>


<table>
<tr>
<td style="text-align: left;">
Component </td>
<td style="text-align: left;"> Description </td>
<td style="text-align: left;"> Default </td>
</tr>
<tr>
<td style="text-align: left;">
<code>phi</code> </td>
<td style="text-align: left;"> per capita survival rate <code class="reqn">\phi</code> </td>
<td style="text-align: left;"> 0.7 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>survmodel</code> </td>
<td style="text-align: left;"> probability model for number of survivors </td>
<td style="text-align: left;"> ``binomial" </td>
</tr>
<tr>
<td style="text-align: left;">
<code>lambda</code> </td>
<td style="text-align: left;"> finite rate of increase <code class="reqn">\lambda = N_{t+1} / N_t</code> </td>
<td style="text-align: left;"> none </td>
</tr>
<tr>
<td style="text-align: left;">
<code>recrmodel</code> </td>
<td style="text-align: left;"> probability model for number of recruits </td>
<td style="text-align: left;"> ``poisson" </td>
</tr>
<tr>
<td style="text-align: left;">
<code>superN</code> </td>
<td style="text-align: left;"> optional superpopulation size for `multinomial' recruitment model</td>
<td style="text-align: left;"> see below </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Nrecruits</code> </td>
<td style="text-align: left;"> number of recruits to add at t+1 for `specified' recruitment model </td>
<td style="text-align: left;"> 0 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>movemodel</code> </td>
<td style="text-align: left;"> ``static", ``uncorrelated", ``normal", ``exponential", ``t2D" or a user function </td>
<td style="text-align: left;"> ``static" </td>
</tr>
<tr>
<td style="text-align: left;">
<code>move.a</code> </td>
<td style="text-align: left;"> first parameter of movement kernel (replacing sigma.m) </td>
<td style="text-align: left;"> 0 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>move.b</code> </td>
<td style="text-align: left;"> second parameter of movement kernel </td>
<td style="text-align: left;"> 1 </td>
</tr>
<tr>
<td style="text-align: left;">

<code>edgemethod</code> </td>
<td style="text-align: left;"> treatment of animals that cross the boundary </td>
<td style="text-align: left;"> ``wrap" </td>
</tr>
<tr>
<td style="text-align: left;">
<code>sigma.m</code> </td>
<td style="text-align: left;"> deprecated in 3.2.1; use move.a </td>
<td style="text-align: left;"> 0 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>wrap</code> </td>
<td style="text-align: left;"> deprecated in 3.1.6; use edgemethod </td>
<td style="text-align: left;"> TRUE i.e. edgemethod = ``wrap" </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Survival</h3>

<p>Survival is usually thought of as a Bernoulli process (outcome 0 or 1 for each individual) so the number of survivors <code class="reqn">S</code> is a binomial variable (survmodel = "binomial"). Another approach is to fix the proportion surviving, but this can be done exactly only when <code class="reqn">\phi N</code> is an integer. A (slightly ad hoc) solution is to randomly choose between the two nearest integers with probability designed in the long term (over many sessions) to give the required <code class="reqn">\phi</code> (survmodel = "discrete").
</p>


<h3>Population growth and recruitment</h3>

<p>Per capita recruitment (<code class="reqn">f</code>) is the difference between lambda and phi (<code class="reqn">f = \lambda - \phi</code>), which must be non-negative (phi &gt; lambda causes an error). The number of recruits B is a random variable whose probability distribution is controlled by details$recrmodel:
</p>

<table>
<tr>
<td style="text-align: left;">
Value </td>
<td style="text-align: left;"> Probability model </td>
</tr>
<tr>
<td style="text-align: left;">
"constantN" </td>
<td style="text-align: left;"> Exact replacement of animals that die (B = <code class="reqn">N_t - S</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
"binomial" </td>
<td style="text-align: left;"> Binomial number of recruits (B ~ bin(<code class="reqn">N_t, f</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
"poisson" </td>
<td style="text-align: left;"> Poisson number of recruits (B ~ pois(<code class="reqn">f N_t</code>)) </td>
</tr>
<tr>
<td style="text-align: left;">
"discrete" </td>
<td style="text-align: left;"> Minimum-variance number of recruits (see Survival) </td>
</tr>
<tr>
<td style="text-align: left;">
"multinomial" </td>
<td style="text-align: left;"> The POPAN model, conditioning on superpopulation size (e.g., Schwarz and Arnason 1996)) </td>
</tr>
<tr>
<td style="text-align: left;">
"specified" </td>
<td style="text-align: left;"> Add the number of recruits specified in Nrecruits (may be vector) </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>In the case of binomial recruitment there is a maximum of one recruit per existing individual, so lambda &lt;= (phi+1). Multinomial recruitment requires a value for the superpopulation size. This may be provided as the details component "superN". If not specified directly, a value is inferred by projecting a trial initial (simulated) population using the specified phi and lambda.
</p>
<p>Specifying the integer number of recruits in each year (recrmodel ‘specified’) overrides the value of lambda, but a non-null value should be given for lambda.
</p>


<h3>Movement</h3>

<p>Individuals may shift their home range centre between sessions. Movement probability is governed by a circular kernel specified by ‘movemodel’ and the parameter values ‘move.a’ and ‘move.b’ (optional). By default there is no movement between sessions (movemodel = "static"). Other options are
</p>

<table>
<tr>
<td style="text-align: left;">
``IND" </td>
<td style="text-align: left;"> ``uncorrelated" </td>
<td style="text-align: left;"> individuals are randomly assigned a new, independent location within the buffered area</td>
</tr>
<tr>
<td style="text-align: left;">
``BVN" </td>
<td style="text-align: left;"> ``normal"</td>
<td style="text-align: left;"> bivariate normal (Gaussian) kernel with parameter move.a (previously called sigma.m)</td>
</tr>
<tr>
<td style="text-align: left;">
``BVE" </td>
<td style="text-align: left;"> ``exponential" </td>
<td style="text-align: left;"> negative exponential (Laplace) kernel with parameter move.a </td>
</tr>
<tr>
<td style="text-align: left;">
``BVT" </td>
<td style="text-align: left;"> ``t2D"</td>
<td style="text-align: left;"> circular 2-dimensional t-distribution with scale parameter move.a and shape parameter move.b = df/2 (2Dt of Clark et al. 1999)</td>
</tr>
<tr>
<td style="text-align: left;">
``RDE" </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> exponential distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
<td style="text-align: left;">
``RDG" </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> gamma distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
<td style="text-align: left;">
``RDL" </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> log-normal distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">  (parameterized with move.a = exp(mu), move.b = 1/CV^2 = 1 / (exp(SD^2) - 1) </td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
</table>
<p>The package <span class="pkg">openCR</span> &gt;=1.4.0 provides functions for constructing and plotting these kernels and summarising their properties (<code>make.kernel</code>; <code>plot</code> and <code>summary</code> methods for kernel objects). The <span class="pkg">secr</span> function <code>extractMoves</code> is useful for checking simulations of movement.
</p>
<p>Models IND, BVN, BVE, and RDE may also be zero-inflated (suffix “zi"). The parameter ‘move.a’ (INDzi) or ‘move.b’ (BVNzi, BVEzi, RDEzi) is the zero-inflation probability. See Examples.
</p>
<p>In <span class="pkg">secr</span> &lt;3.2.1 sigma.m was also used to indicate two special cases; these continue to work but may be discontinued in the future:
</p>
<p>sigma.m = 0 corresponds to movemodel = ‘static’
</p>
<p>sigma.m &lt; 0 corresponds to movemodel = ‘uncorrelated’
</p>
<p>In <span class="pkg">secr</span> &gt;= 4.4.0, the ‘movemodel’ component may also be a user-provided function with these characteristics: two or three arguments, the first being the number of centres to be moved (e.g., n) and the others parameters of the dispersal distribution (e.g., a,b); the function should return a matrix of n rows and 2 columns, the displacements in the x- and y-directions. The output is a set of random points from the bivariate dispersal kernel. The function will be called with the current number of centres and parameter values move.a and move.b as needed.
</p>
<p>If movement takes an animal across the boundary of the arena (buffered area) in <code>sim.popn</code> the component "edgemethod" comes into play. By default, locations are toroidally wrapped i.e. the animal re-joins the population on the opposing edge. Other options are “clip” (discard), “clipandreplace” (assign new identity at original location), “stop” (stop just inside the boundary), “reflect” (bounce off edges to the limit of the dispersal), “normalize” = “truncate” (truncate kernel and scale probability to 1.0) and “none" (allow centres outside the buffered area). The “normalize” option (new in <span class="pkg">secr</span> 4.3.3) can take longer as it repeatedly relocates each individual until its destination lies within the bounding box, up to a maximum of 500 attempts.
</p>


<h3>References</h3>

<p>Clark, J. S, Silman, M., Kern, R., Macklin, E. and HilleRisLambers, J. (1999) Seed dispersal near and far: patterns across temperate and tropical forests. <em>Ecology</em> <b>80</b>, 1475–1494.
</p>
<p>Nathan , R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) 
Dispersal kernels: a review. In: J Clobert et al. <em>Dispersal Ecology and Evolution</em>. Oxford University Press. Pp 187–210.
</p>


<h3>See Also</h3>

<p><code>sim.popn</code>, <code>extractMoves</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
par (mfrow = c(2,3), mar = c(1,1,1,1))

## birth and death only
grid &lt;- make.grid(nx = 7, ny = 4, detector = 'proximity', spacing = 10)
pop &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 0.8, phi = 0.6))
sapply(pop, nrow)  ## how many individuals?
plot(pop)

## movement only
pop2 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "wrap"))
pop3 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "clip"))
pop4 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 10,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "stop"))
sapply(pop2, nrow)  ## how many individuals?
plot(pop2)

## show effect of edgemethod --
## first session blue, last session red
cols &lt;- c('blue',rep('white',4),'red')
par (mfrow=c(1,2))
plot(pop2, collapse = TRUE, seqcol = cols)
plot(pop3, collapse = TRUE, seqcol = cols)

## zero-inflated movement
## move.b is zero-inflation probability
pop5 &lt;- sim.popn (Nbuffer = 1000, core = grid, nsessions = 6,    
     details = list(lambda = 1, phi = 1, movemodel = 'RDEzi', 
         move.a = 50, move.b = 0.5, edgemethod = "none"))
mean(do.call(rbind,extractMoves(pop5))$d)   # approx 50 * 0.5

</code></pre>


</div>