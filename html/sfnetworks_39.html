<div class="container">

<table style="width: 100%;"><tr>
<td>spatial_node_predicates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Query nodes with spatial predicates</h2>

<h3>Description</h3>

<p>These functions allow to interpret spatial relations between nodes and
other geospatial features directly inside <code>filter</code>
and <code>mutate</code> calls. All functions return a logical
vector of the same length as the number of nodes in the network. Element i
in that vector is <code>TRUE</code> whenever <code>any(predicate(x[i], y[j]))</code> is
<code>TRUE</code>. Hence, in the case of using <code>node_intersects</code>, element i
in the returned vector is <code>TRUE</code> when node i intersects with any of
the features given in y.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_intersects(y, ...)

node_is_disjoint(y, ...)

node_touches(y, ...)

node_is_within(y, ...)

node_equals(y, ...)

node_is_covered_by(y, ...)

node_is_within_distance(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The geospatial features to test the nodes against, either as an
object of class <code>sf</code> or <code>sfc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed on to the corresponding spatial predicate
function of sf. See <code>geos_binary_pred</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>geos_binary_pred</code> for details on each spatial
predicate. Just as with all query functions in tidygraph, these functions
are meant to be called inside tidygraph verbs such as
<code>mutate</code> or <code>filter</code>, where
the network that is currently being worked on is known and thus not needed
as an argument to the function. If you want to use an algorithm outside of
the tidygraph framework you can use <code>with_graph</code> to
set the context temporarily while the algorithm is being evaluated.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as the number of nodes in the
network.
</p>


<h3>Note</h3>

<p>Note that <code>node_is_within_distance</code> is a wrapper around the
<code>st_is_within_distance</code> predicate from sf. Hence, it is based on
'as-the-crow-flies' distance, and not on distances over the network. For
distances over the network, use <code>node_distance_to</code>
with edge lengths as weights argument.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network.
net = as_sfnetwork(roxel) %&gt;%
  st_transform(3035)

# Create a geometry to test against.
p1 = st_point(c(4151358, 3208045))
p2 = st_point(c(4151340, 3207520))
p3 = st_point(c(4151756, 3207506))
p4 = st_point(c(4151774, 3208031))

poly = st_multipoint(c(p1, p2, p3, p4)) %&gt;%
  st_cast('POLYGON') %&gt;%
  st_sfc(crs = 3035)

# Use predicate query function in a filter call.
within = net %&gt;%
  activate("nodes") %&gt;%
  filter(node_is_within(poly))

disjoint = net %&gt;%
  activate("nodes") %&gt;%
  filter(node_is_disjoint(poly))
oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(net)
plot(within, col = "red", add = TRUE)
plot(disjoint, col = "blue", add = TRUE)
par(oldpar)

# Use predicate query function in a mutate call.
net %&gt;%
  activate("nodes") %&gt;%
  mutate(within = node_is_within(poly)) %&gt;%
  select(within)

</code></pre>


</div>