<div class="container">

<table style="width: 100%;"><tr>
<td>xxirt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
User Defined Item Response Model
</h2>

<h3>Description</h3>

<p>Estimates a user defined item response model. Both, item response functions
and latent trait distributions can be specified by the user (see Details).
By default, the EM algorithm is used for estimation. The number of maximum
EM iterations can be defined with the argument <code>maxit</code>. The <code>xxirt</code>
function also allows Newton-Raphson optimization by specifying values of maximum
number of iterations in <code>maxit_nr</code> larger than zero. Typically, a small initial
number of EM iterations should be chosen to obtain reasonable starting values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">xxirt(dat, Theta=NULL, itemtype=NULL, customItems=NULL, partable=NULL,
       customTheta=NULL, group=NULL, weights=NULL, globconv=1e-06, conv=1e-04,
       maxit=1000, mstep_iter=4, mstep_reltol=1e-06, maxit_nr=0, optimizer_nr="nlminb",
       control_nr=list(trace=1), h=1E-4, use_grad=TRUE, verbose=TRUE,
       penalty_fun_item=NULL, np_fun_item=NULL, verbose_index=NULL,
       cv_kfold=0, cv_maxit=10)

## S3 method for class 'xxirt'
summary(object, digits=3, file=NULL, ...)

## S3 method for class 'xxirt'
print(x, ...)

## S3 method for class 'xxirt'
anova(object,...)

## S3 method for class 'xxirt'
coef(object,...)

## S3 method for class 'xxirt'
logLik(object,...)

## S3 method for class 'xxirt'
vcov(object,...)

## S3 method for class 'xxirt'
confint(object, parm, level=.95, ... )

## S3 method for class 'xxirt'
IRT.expectedCounts(object,...)

## S3 method for class 'xxirt'
IRT.factor.scores(object, type="EAP", ...)

## S3 method for class 'xxirt'
IRT.irfprob(object,...)

## S3 method for class 'xxirt'
IRT.likelihood(object,...)

## S3 method for class 'xxirt'
IRT.posterior(object,...)

## S3 method for class 'xxirt'
IRT.modelfit(object,...)

## S3 method for class 'IRT.modelfit.xxirt'
summary(object,...)

## S3 method for class 'xxirt'
IRT.se(object,...)

# computes Hessian matrix
xxirt_hessian(object, h=1e-4, use_shortcut=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>Data frame with item responses
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>

<p>Matrix with <code class="reqn">\bold{\theta}</code> grid vector of latent trait
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemtype</code></td>
<td>

<p>Vector of item types
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customItems</code></td>
<td>

<p>List containing types of item response functions created by
<code>xxirt_createDiscItem</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>

<p>Item parameter table which is initially created by
<code>xxirt_createParTable</code> and which can be modified by
<code>xxirt_modifyParTable</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customTheta</code></td>
<td>

<p>User defined <code class="reqn">\bold{\theta}</code> distribution created by
<code>xxirt_createThetaDistribution</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>

<p>Optional vector of group indicators
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of person weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globconv</code></td>
<td>

<p>Convergence criterion for relative change in deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>Convergence criterion for absolute change in parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of iterations in the EM algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstep_iter</code></td>
<td>

<p>Maximum number of iterations in M-step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstep_reltol</code></td>
<td>

<p>Convergence criterion in M-step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit_nr</code></td>
<td>
<p>Number of Newton-Raphson iterations after EM algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer_nr</code></td>
<td>
<p>Type of optimizer for Newton-Raphson optimization.
Alternatives are <code>"optim"</code> or <code>"nlminb"</code> or other options of
<code>sirt_optimizer</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_nr</code></td>
<td>
<p>Argument <code>control</code> for optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Numerical differentiation parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_grad</code></td>
<td>
<p>Logical indicating whether the gradient should be supplied
to <code>stats::optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical indicating whether iteration progress should be displayed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty_fun_item</code></td>
<td>
<p>Optional penalty function used in regularized
estimation. Used as a function of <code>x</code> (vector of item parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>np_fun_item</code></td>
<td>
<p>Function that counts the number of item parameters in regularized
estimation. Used as a function of <code>x</code> (vector of item parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>xxirt</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to be rounded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name to which <code>summary</code> output is written</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>Optional vector of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Confidence level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose_index</code></td>
<td>
<p>Logical indicating whether item index should be
printed in estimation output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_kfold</code></td>
<td>
<p>Number of k folds in cross validation. The default is 0 (no
cross-validation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_maxit</code></td>
<td>
<p>Maximum number of iterations for each cross-validation sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>xxirt</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of person parameter estimate. Currently, only
<code>EAP</code> is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_shortcut</code></td>
<td>
<p>Logical indicating whether a shortcut in the computation
should be utilized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Item response functions can be specified as functions of unknown parameters
<code class="reqn">\bold{\delta}_i</code> such that
<code class="reqn">P(X_{i}=x | \bold{\theta})=f_i( x | \bold{\theta} ; \bold{\delta}_i  )</code>
The item response model is estimated under the assumption of
local stochastic independence of items. Equality constraints of
item parameters <code class="reqn">\bold{\delta}_i</code> among items are allowed.
</p>
<p>The probability distribution <code class="reqn">P(\bold{\theta})</code> are specified as functions
of an unknown parameter vector <code class="reqn">\bold{\gamma}</code>.
</p>
<p>A penalty function for item parameters can be specified in
<code>penalty_fun_item</code>. The penalty function should be differentiable and
a non-differentiable function (e.g., the absolute value function) should
be approximated by a differentiable function.
</p>


<h3>Value</h3>

<p>List with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>
<p>Item parameter table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_items</code></td>
<td>
<p>Vector with estimated item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_items_summary</code></td>
<td>
<p>Data frame with item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_items_bounds</code></td>
<td>
<p>Data frame with summary on bounds of estimated
item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_Theta</code></td>
<td>
<p>Vector with estimated parameters of theta distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>Matrix with <code class="reqn">\bold{\theta}</code> grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs_items</code></td>
<td>
<p>Item response functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs_Theta</code></td>
<td>
<p>Theta distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>Log likelihood value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item_list</code></td>
<td>
<p>List with item functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customItems</code></td>
<td>
<p>Used customized item response functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customTheta</code></td>
<td>
<p>Used customized theta distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_loglike</code></td>
<td>
<p>Cross-validated log-likelihood value (if <code>cv_kfold&gt;0</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.xi.aj</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.aj.xi</code></td>
<td>
<p>Individual posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll_case</code></td>
<td>
<p>Case-wise log-likelihood values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ik</code></td>
<td>
<p>Array of expected counts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EAP</code></td>
<td>
<p>EAP person parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>Used dataset with item responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat_resp</code></td>
<td>
<p>Dataset with response indicators</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Vector of person weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Number of groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Integer vector of group indicators</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_orig</code></td>
<td>
<p>Vector of original group_identifiers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncat</code></td>
<td>
<p>Number of categories per item</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Logical whether model has converged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations needed</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>See the <code>mirt::createItem</code> and
<code>mirt::mirt</code> functions in the <span class="pkg">mirt</span>
package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
## EXAMPLE 1: Unidimensional item response functions
#############################################################################

data(data.read)
dat &lt;- data.read

#------ Definition of item response functions

#*** IRF 2PL
P_2PL &lt;- function( par, Theta, ncat){
    a &lt;- par[1]
    b &lt;- par[2]
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,1] &lt;- 1
    for (cc in 2:ncat){
        P[,cc] &lt;- exp( (cc-1) * a * Theta[,1] - b )
    }
    P &lt;- P / rowSums(P)
    return(P)
}

#*** IRF 1PL
P_1PL &lt;- function( par, Theta, ncat){
    b &lt;- par[1]
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,1] &lt;- 1
    for (cc in 2:ncat){
        P[,cc] &lt;- exp( (cc-1) * Theta[,1] - b )
    }
    P &lt;- P / rowSums(P)
    return(P)
}

#** created item classes of 1PL and 2PL models
par &lt;- c( "a"=1, "b"=0 )
# define some slightly informative prior of 2PL
item_2PL &lt;- sirt::xxirt_createDiscItem( name="2PL", par=par, est=c(TRUE,TRUE),
               P=P_2PL, prior=c(a="dlnorm"), prior_par1=c( a=0 ),
               prior_par2=c(a=5) )
item_1PL &lt;- sirt::xxirt_createDiscItem( name="1PL", par=par[2], est=c(TRUE),
               P=P_1PL )
customItems &lt;- list( item_1PL,  item_2PL )

#---- definition theta distribution

#** theta grid
Theta &lt;- matrix( seq(-6,6,length=21), ncol=1 )

#** theta distribution
P_Theta1 &lt;- function( par, Theta, G){
    mu &lt;- par[1]
    sigma &lt;- max( par[2], .01 )
    TP &lt;- nrow(Theta)
    pi_Theta &lt;- matrix( 0, nrow=TP, ncol=G)
    pi1 &lt;- dnorm( Theta[,1], mean=mu, sd=sigma )
    pi1 &lt;- pi1 / sum(pi1)
    pi_Theta[,1] &lt;- pi1
    return(pi_Theta)
}
#** create distribution class
par_Theta &lt;- c( "mu"=0, "sigma"=1 )
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta, est=c(FALSE,TRUE),
                       P=P_Theta1 )

#****************************************************************************
#******* Model 1: Rasch model

#-- create parameter table
itemtype &lt;- rep( "1PL", 12 )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype,
                        customItems=customItems )

# estimate model
mod1 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable,
                   customItems=customItems, customTheta=customTheta)
summary(mod1)

# estimate Rasch model by providing starting values
partable1 &lt;- sirt::xxirt_modifyParTable( partable, parname="b",
                   value=- stats::qlogis( colMeans(dat) ) )
# estimate model again
mod1b &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable1,
                   customItems=customItems, customTheta=customTheta )
summary(mod1b)

# extract coefficients, covariance matrix and standard errors
coef(mod1b)
vcov(mod1b)
IRT.se(mod1b)

#** start with EM and finalize with Newton-Raphson algorithm
mod1c &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable,
                   customItems=customItems, customTheta=customTheta,
                   maxit=20, maxit_nr=300)
summary(mod1c)

#****************************************************************************
#******* Model 2: 2PL Model with three groups of item discriminations

#-- create parameter table
itemtype &lt;- rep( "2PL", 12 )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype, customItems=customItems)
# modify parameter table: set constraints for item groups A, B and C
partable1 &lt;- sirt::xxirt_modifyParTable(partable, item=paste0("A",1:4),
                         parname="a", parindex=111)
partable1 &lt;- sirt::xxirt_modifyParTable(partable1, item=paste0("B",1:4),
                         parname="a", parindex=112)
partable1 &lt;- sirt::xxirt_modifyParTable(partable1, item=paste0("C",1:4),
                         parname="a", parindex=113)
# delete prior distributions
partable1 &lt;- sirt::xxirt_modifyParTable(partable1, parname="a", prior=NA)

#-- fix sigma to 1
customTheta1 &lt;- customTheta
customTheta1$est &lt;- c("mu"=FALSE,"sigma"=FALSE )

# estimate model
mod2 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable1,
                  customItems=customItems, customTheta=customTheta1 )
summary(mod2)

#****************************************************************************
#******* Model 3: Cloglog link function

#*** IRF cloglog
P_1N &lt;- function( par, Theta, ncat){
    b &lt;- par
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,2] &lt;- 1 - exp( - exp( Theta - b ) )
    P[,1] &lt;- 1 - P[,2]
    return(P)
}
par &lt;- c("b"=0)
item_1N &lt;- sirt::xxirt_createDiscItem( name="1N", par=par, est=c(TRUE),
                    P=P_1N )
customItems &lt;- list( item_1N )
itemtype &lt;- rep( "1N", I )
partable &lt;- sirt::xxirt_createParTable( dat[,items], itemtype=itemtype,
                      customItems=customItems )
partable &lt;- sirt::xxirt_modifyParTable( partable=partable, parname="b",
                 value=- stats::qnorm( colMeans(dat[,items] )) )

#*** estimate model
mod3 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable, customItems=customItems,
                customTheta=customTheta )
summary(mod3)
IRT.compareModels(mod1,mod3)

#****************************************************************************
#******* Model 4: Latent class model

K &lt;- 3 # number of classes
Theta &lt;- diag(K)

#*** Theta distribution
P_Theta1 &lt;- function( par, Theta, G  ){
    logitprobs &lt;- par[1:(K-1)]
    l1 &lt;- exp( c( logitprobs, 0 ) )
    probs &lt;- matrix( l1/sum(l1), ncol=1)
    return(probs)
}

par_Theta &lt;- stats::qlogis( rep( 1/K, K-1 ) )
names(par_Theta) &lt;- paste0("pi",1:(K-1) )
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta,
                     est=rep(TRUE,K-1), P=P_Theta1)

#*** IRF latent class
P_lc &lt;- function( par, Theta, ncat){
    b &lt;- par
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,1] &lt;- 1
    for (cc in 2:ncat){
        P[,cc] &lt;- exp( Theta %*% b )
    }
    P &lt;- P / rowSums(P)
    return(P)
}
par &lt;- seq( -1.5, 1.5, length=K )
names(par) &lt;- paste0("b",1:K)
item_lc &lt;- sirt::xxirt_createDiscItem( name="LC", par=par,
                 est=rep(TRUE,K), P=P_lc )
customItems &lt;- list( item_lc )

# create parameter table
itemtype &lt;- rep( "LC", 12 )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype, customItems=customItems)
partable

#*** estimate model
mod4 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable, customItems=customItems,
                customTheta=customTheta)
summary(mod4)
# class probabilities
mod4$probs_Theta
# item response functions
imod4 &lt;- IRT.irfprob( mod5 )
round( imod4[,2,], 3 )

#****************************************************************************
#******* Model 5: Ordered latent class model

K &lt;- 3 # number of classes
Theta &lt;- diag(K)
Theta &lt;- apply( Theta, 1, cumsum )

#*** Theta distribution
P_Theta1 &lt;- function( par, Theta, G  ){
    logitprobs &lt;- par[1:(K-1)]
    l1 &lt;- exp( c( logitprobs, 0 ) )
    probs &lt;- matrix( l1/sum(l1), ncol=1)
    return(probs)
}
par_Theta &lt;- stats::qlogis( rep( 1/K, K-1 ) )
names(par_Theta) &lt;- paste0("pi",1:(K-1) )
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta,
                est=rep(TRUE,K-1), P=P_Theta1  )

#*** IRF ordered latent class
P_olc &lt;- function( par, Theta, ncat){
    b &lt;- par
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,1] &lt;- 1
    for (cc in 2:ncat){
        P[,cc] &lt;- exp( Theta %*% b )
    }
    P &lt;- P / rowSums(P)
    return(P)
}

par &lt;- c( -1, rep( .5,, length=K-1 ) )
names(par) &lt;- paste0("b",1:K)
item_olc &lt;- sirt::xxirt_createDiscItem( name="OLC", par=par, est=rep(TRUE,K),
                    P=P_olc, lower=c( -Inf, 0, 0 ) )
customItems &lt;- list( item_olc )
itemtype &lt;- rep( "OLC", 12 )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype, customItems=customItems)
partable

#*** estimate model
mod5 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable, customItems=customItems,
                customTheta=customTheta )
summary(mod5)
# estimated item response functions
imod5 &lt;- IRT.irfprob( mod5 )
round( imod5[,2,], 3 )

#############################################################################
## EXAMPLE 2: Multiple group models with xxirt
#############################################################################

data(data.math)
dat &lt;- data.math$data
items &lt;- grep( "M[A-Z]", colnames(dat), value=TRUE )
I &lt;- length(items)

Theta &lt;- matrix( seq(-8,8,len=31), ncol=1 )

#****************************************************************************
#******* Model 1: Rasch model, single group

#*** Theta distribution
P_Theta1 &lt;- function( par, Theta, G  ){
    mu &lt;- par[1]
    sigma &lt;- max( par[2], .01 )
    p1 &lt;- stats::dnorm( Theta[,1], mean=mu, sd=sigma)
    p1 &lt;- p1 / sum(p1)
    probs &lt;- matrix( p1, ncol=1)
    return(probs)
}

par_Theta &lt;- c(0,1)
names(par_Theta) &lt;- c("mu","sigma")
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta,
                   est=c(FALSE,TRUE), P=P_Theta1  )
customTheta

#*** IRF 1PL logit
P_1PL &lt;- function( par, Theta, ncat){
    b &lt;- par
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,2] &lt;- plogis( Theta - b )
    P[,1] &lt;- 1 - P[,2]
    return(P)
}
par &lt;- c("b"=0)
item_1PL &lt;- sirt::xxirt_createDiscItem( name="1PL", par=par, est=c(TRUE), P=P_1PL)
customItems &lt;- list( item_1PL )

itemtype &lt;- rep( "1PL", I )
partable &lt;- sirt::xxirt_createParTable( dat[,items], itemtype=itemtype,
                       customItems=customItems )
partable &lt;- sirt::xxirt_modifyParTable( partable=partable, parname="b",
                  value=- stats::qlogis( colMeans(dat[,items] )) )

#*** estimate model
mod1 &lt;- sirt::xxirt( dat=dat[,items], Theta=Theta, partable=partable,
                customItems=customItems, customTheta=customTheta )
summary(mod1)

#****************************************************************************
#******* Model 2: Rasch model, multiple groups

#*** Theta distribution
P_Theta2 &lt;- function( par, Theta, G  ){
    mu1 &lt;- par[1]
    mu2 &lt;- par[2]
    sigma1 &lt;- max( par[3], .01 )
    sigma2 &lt;- max( par[4], .01 )
    TP &lt;- nrow(Theta)
    probs &lt;- matrix( NA, nrow=TP, ncol=G)
    p1 &lt;- stats::dnorm( Theta[,1], mean=mu1, sd=sigma1)
    probs[,1] &lt;- p1 / sum(p1)
    p1 &lt;- stats::dnorm( Theta[,1], mean=mu2, sd=sigma2)
    probs[,2] &lt;- p1 / sum(p1)
    return(probs)
}
par_Theta &lt;- c(0,0,1,1)
names(par_Theta) &lt;- c("mu1","mu2","sigma1","sigma2")
customTheta2  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta,
                    est=c(FALSE,TRUE,TRUE,TRUE), P=P_Theta2  )
print(customTheta2)

#*** estimate model
mod2 &lt;- sirt::xxirt( dat=dat[,items], group=dat$female, Theta=Theta, partable=partable,
           customItems=customItems, customTheta=customTheta2, maxit=40)
summary(mod2)
IRT.compareModels(mod1, mod2)

#*** compare results with TAM package
library(TAM)
mod2b &lt;- TAM::tam.mml( resp=dat[,items], group=dat$female )
summary(mod2b)
IRT.compareModels(mod1, mod2, mod2b)

#############################################################################
## EXAMPLE 3: Regularized 2PL model
#############################################################################

data(data.read, package="sirt")
dat &lt;- data.read

#------ Definition of item response functions

#*** IRF 2PL
P_2PL &lt;- function( par, Theta, ncat){
    a &lt;- par[1]
    b &lt;- par[2]
    TP &lt;- nrow(Theta)
    P &lt;- matrix( NA, nrow=TP, ncol=ncat)
    P[,1] &lt;- 1
    for (cc in 2:ncat){
        P[,cc] &lt;- exp( (cc-1) * a * Theta[,1] - b )
    }
    P &lt;- P / rowSums(P)
    return(P)
}

#** created item classes of 1PL and 2PL models
par &lt;- c( "a"=1, "b"=0 )
# define some slightly informative prior of 2PL
item_2PL &lt;- sirt::xxirt_createDiscItem( name="2PL", par=par, est=c(TRUE,TRUE),
               P=P_2PL, prior=c(a="dlnorm"), prior_par1=c( a=0 ),
               prior_par2=c(a=5) )
customItems &lt;- list( item_2PL )

#---- definition theta distribution

#** theta grid
Theta &lt;- matrix( seq(-6,6,length=21), ncol=1 )

#** theta distribution
P_Theta1 &lt;- function( par, Theta, G){
    mu &lt;- par[1]
    sigma &lt;- max( par[2], .01 )
    TP &lt;- nrow(Theta)
    pi_Theta &lt;- matrix( 0, nrow=TP, ncol=G)
    pi1 &lt;- dnorm( Theta[,1], mean=mu, sd=sigma )
    pi1 &lt;- pi1 / sum(pi1)
    pi_Theta[,1] &lt;- pi1
    return(pi_Theta)
}
#** create distribution class
par_Theta &lt;- c( "mu"=0, "sigma"=1 )
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta, est=c(FALSE,FALSE),
                       P=P_Theta1 )

#****************************************************************************
#******* Model 1: 2PL model

itemtype &lt;- rep( "2PL", 12 )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype,
                        customItems=customItems )

mod1 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable,
                   customItems=customItems, customTheta=customTheta)
summary(mod1)

#****************************************************************************
#******* Model 2: Regularized 2PL model with regularization on item loadings

# define regularized estimation of item loadings
parindex &lt;- partable[ partable$parname=="a","parindex"]

#** penalty is defined by -N*lambda*sum_i (a_i-1)^2
N &lt;- nrow(dat)
lambda &lt;- .02
penalty_fun_item &lt;- function(x)
{
    val &lt;- N*lambda*sum( ( x[parindex]-1)^2)
    return(val)
}
# estimate standard deviation
customTheta1  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta, est=c(FALSE,TRUE),
                       P=P_Theta1 )
mod2 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable,
                   customItems=customItems, customTheta=customTheta1,
                   penalty_fun_item=penalty_fun_item)
summary(mod2)

#############################################################################
## EXAMPLE 4: 2PL mixture model
#############################################################################

#*** simulate data
set.seed(123)
N &lt;- 4000   # number of persons
I &lt;- 15     # number of items
prop &lt;- .25 # mixture proportion for second class

# discriminations and difficulties in first class
a1 &lt;- rep(1,I)
b1 &lt;- seq(-2,2,len=I)
# distribution in second class
mu2 &lt;- 1
sigma2 &lt;- 1.2
# compute parameters with constraint N(0,1) in second class
# a*(sigma*theta+mu-b)=a*sigma*(theta-(b-mu)/sigma)
#=&gt; a2=a*sigma and b2=(b-mu)/sigma
a2 &lt;- a1
a2[c(2,4,6,8)] &lt;- 0.2  # some items with different discriminations
a2 &lt;- a2*sigma2
b2 &lt;- b1
b2[1:5] &lt;- 1   # first 5 item with different difficulties
b2 &lt;- (b2-mu2)/sigma2
dat1 &lt;- sirt::sim.raschtype(theta=stats::rnorm(N*(1-prop)), b=b1, fixed.a=a1)
dat2 &lt;- sirt::sim.raschtype(theta=stats::rnorm(N*prop), b=b2, fixed.a=a2)
dat &lt;- rbind(dat1, dat2)

#**** model specification

#*** define theta distribution
TP &lt;- 21
theta &lt;- seq(-6,6,length=TP)
# stack theta vectors below each others=&gt; 2 latent classes
Theta &lt;- matrix( c(theta, theta ), ncol=1 )
# distribution of theta (i.e., N(0,1))
w_theta &lt;- dnorm(theta)
w_theta &lt;- w_theta / sum(w_theta)

P_Theta1 &lt;- function( par, Theta, G){
    p2_logis &lt;- par[1]
    p2 &lt;- stats::plogis( p2_logis )
    p1 &lt;- 1-p2
    pi_Theta &lt;- c( p1*w_theta, p2*w_theta)
    pi_Theta &lt;- matrix(pi_Theta, ncol=1)
    return(pi_Theta)
}

par_Theta &lt;- c( p2_logis=qlogis(.25))
customTheta  &lt;- sirt::xxirt_createThetaDistribution( par=par_Theta, est=c(TRUE),
                       P=P_Theta1)

# IRF for 2-class mixture 2PL model
par &lt;- c(a1=1, a2=1, b1=0, b2=.5)

P_2PLmix &lt;- function( par, Theta, ncat)
{
    a1 &lt;- par[1]
    a2 &lt;- par[2]
    b1 &lt;- par[3]
    b2 &lt;- par[4]
    P &lt;- matrix( NA, nrow=2*TP, ncol=ncat)
    TP &lt;- nrow(Theta)/2
    P1 &lt;- stats::plogis( a1*(Theta[1:TP,1]-b1) )
    P2 &lt;- stats::plogis( a2*(Theta[TP+1:(2*TP),1]-b2) )
    P[,2] &lt;- c(P1, P2)
    P[,1] &lt;- 1-P[,2]
    return(P)
}

# define some slightly informative prior of 2PL
item_2PLmix &lt;- sirt::xxirt_createDiscItem( name="2PLmix", par=par,
               est=c(TRUE,TRUE,TRUE,TRUE), P=P_2PLmix )
customItems &lt;- list( item_2PLmix )

#****************************************************************************
#******* Model 1: 2PL mixture model

itemtype &lt;- rep( "2PLmix", I )
partable &lt;- sirt::xxirt_createParTable( dat, itemtype=itemtype,
                        customItems=customItems )
mod1 &lt;- sirt::xxirt( dat=dat, Theta=Theta, partable=partable,
                   customItems=customItems, customTheta=customTheta)
summary(mod1)

## End(Not run)
</code></pre>


</div>