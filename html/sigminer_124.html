<div class="container">

<table style="width: 100%;"><tr>
<td>sig_fit_bootstrap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Obtain Bootstrap Distribution of Signature Exposures of a Certain Tumor Sample</h2>

<h3>Description</h3>

<p>This can be used to obtain the confidence of signature exposures or search
the suboptimal decomposition solution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sig_fit_bootstrap(
  catalog,
  sig,
  n = 100L,
  sig_index = NULL,
  sig_db = "legacy",
  db_type = c("", "human-exome", "human-genome"),
  show_index = TRUE,
  method = c("QP", "NNLS", "SA"),
  auto_reduce = FALSE,
  SA_not_bootstrap = FALSE,
  type = c("absolute", "relative"),
  rel_threshold = 0,
  mode = c("SBS", "DBS", "ID", "copynumber"),
  find_suboptimal = FALSE,
  suboptimal_ref_error = NULL,
  suboptimal_factor = 1.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>catalog</code></td>
<td>
<p>a named numeric vector or a numeric matrix with dimension Nx1.
N is the number of component, 1 is the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig</code></td>
<td>
<p>a <code>Signature</code> object obtained either from sig_extract or sig_auto_extract,
or just a raw signature matrix/<code>data.frame</code> with row representing components (motifs) and
column representing signatures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig_index</code></td>
<td>
<p>a vector for signature index. "ALL" for all signatures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of "SBS_Nik_lab_Organ", "RS_Nik_lab_Organ",
"SBS_Nik_lab", "RS_Nik_lab" to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
"RS_BRCA560", "RS_USARC" to reference signatures from BRCA560 and USARC cohorts;
"CNS_USARC" (40 categories), "CNS_TCGA" (48 categories) to reference copy number signatures from USARC cohort and TCGA;
"CNS_TCGA176" (176 categories) and "CNS_PCAWG176" (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. "latest_SBS_GRCh37").
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>db_type</code></td>
<td>
<p>only used when <code>sig_db</code> is enabled.
"" for keeping default, "human-exome" for transforming to exome frequency of component,
and "human-genome" for transforming to whole genome frequency of component.
Currently only works for 'SBS'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_index</code></td>
<td>
<p>if <code>TRUE</code>, show valid indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to solve the minimazation problem.
'NNLS' for non-negative least square; 'QP' for quadratic programming; 'SA' for simulated annealing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto_reduce</code></td>
<td>
<p>if <code>TRUE</code>, try reducing the input reference signatures to increase
the cosine similarity of reconstructed profile to observed profile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SA_not_bootstrap</code></td>
<td>
<p>if <code>TRUE</code>, directly run 'SA' multiple times with original input instead of
bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>'absolute' for signature exposure and 'relative' for signature relative exposure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel_threshold</code></td>
<td>
<p>numeric vector, a signature with relative exposure
lower than (equal is included, i.e. <code>&lt;=</code>) this value will be set to 0
(both absolute exposure and relative exposure).
In this case, sum of signature contribution may not equal to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>signature type for plotting, now supports 'copynumber', 'SBS',
'DBS', 'ID' and 'RS' (genome rearrangement signature).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>find_suboptimal</code></td>
<td>
<p>logical, if <code>TRUE</code>, find suboptimal decomposition with
slightly higher error than the optimal solution by method 'SA'. This is useful
to explore hidden dependencies between signatures. More see reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suboptimal_ref_error</code></td>
<td>
<p>baseline error used for finding suboptimal solution.
if it is <code>NULL</code>, then use 'SA' method to obtain the optimal error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suboptimal_factor</code></td>
<td>
<p>suboptimal factor to get suboptimal error, default is <code>1.05</code>,
i.e., suboptimal error is <code>1.05</code> times baseline error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>control parameters passing to argument <code>control</code> in <code>GenSA</code> function when use method 'SA'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>list</code>
</p>


<h3>References</h3>

<p>Huang X, Wojtowicz D, Przytycka TM. Detecting presence of mutational signatures in cancer with confidence. Bioinformatics. 2018;34(2):330â€“337. doi:10.1093/bioinformatics/btx604
</p>


<h3>See Also</h3>

<p>report_bootstrap_p_value, sig_fit, sig_fit_bootstrap_batch
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This function is designed for processing
# one sample, thus is not very useful in practice
# please check `sig_fit_bootstrap_batch`

# For general purpose -------------------
W &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)
colnames(W) &lt;- c("sig1", "sig2")
W &lt;- apply(W, 2, function(x) x / sum(x))

H &lt;- matrix(c(2, 5, 3, 6, 1, 9, 1, 2), ncol = 4)
colnames(H) &lt;- paste0("samp", 1:4)

V &lt;- W %*% H
V

if (requireNamespace("quadprog", quietly = TRUE)) {
  H_bootstrap &lt;- sig_fit_bootstrap(V[, 1], W, n = 10, type = "absolute")
  ## Typically, you have to run many times to get close to the answer
  boxplot(t(H_bootstrap$expo))
  H[, 1]

  ## Return P values
  ## In practice, run times &gt;= 100
  ## is recommended
  report_bootstrap_p_value(H_bootstrap)
  ## For multiple samples
  ## Input a list
  report_bootstrap_p_value(list(samp1 = H_bootstrap, samp2 = H_bootstrap))

  #   ## Find suboptimal decomposition
  #   H_suboptimal &lt;- sig_fit_bootstrap(V[, 1], W,
  #     n = 10,
  #     type = "absolute",
  #     method = "SA",
  #     find_suboptimal = TRUE
  #   )
}
</code></pre>


</div>