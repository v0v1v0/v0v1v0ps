<div class="container">

<table style="width: 100%;"><tr>
<td>scores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Proper Scoring Rules for Poisson or Negative Binomial Predictions
</h2>

<h3>Description</h3>

<p>Proper scoring rules for Poisson or negative binomial predictions
of count data are described in Czado et al. (2009).
The following scores are implemented:
logarithmic score (<code>logs</code>),
ranked probability score (<code>rps</code>),
Dawid-Sebastiani score (<code>dss</code>),
squared error score (<code>ses</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">scores(x, ...)

## Default S3 method:
scores(x, mu, size = NULL,
       which = c("logs", "rps", "dss", "ses"),
       sign = FALSE, ...)

logs(x, mu, size = NULL)
rps(x, mu, size = NULL, k = 40, tolerance = sqrt(.Machine$double.eps))
dss(x, mu, size = NULL)
ses(x, mu, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>the observed counts.
All functions are vectorized and also accept matrices or arrays.
Dimensions are preserved.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>the means of the predictive distributions for the
observations <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>

<p>either <code>NULL</code> (default), indicating Poisson predictions with mean
<code>mu</code>, or dispersion parameters of
negative binomial forecasts for the observations <code>x</code>,
parametrized as in <code>dnbinom</code> with variance
<code>mu*(1+mu/size)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p>a character vector specifying which scoring rules to apply.
By default, all four proper scores are calculated.
The normalized squared error score (<code>"nses"</code>) is also available
but it is improper and hence not computed by default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign</code></td>
<td>

<p>a logical indicating if the function should also return
<code>sign(x-mu)</code>, i.e., the sign of the difference between
the observed counts and corresponding predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>unused (argument of the generic).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>scalar argument controlling the finite sum approximation for the
<code>rps</code> with truncation at <code>max(x, ceiling(mu + k*sd))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>

<p>absolute tolerance for the finite sum approximation employed in the
<code>rps</code> calculation. A warning is produced if the approximation
with <code>k</code> summands is insufficient for the specified
<code>tolerance</code>. In this case, increase <code>k</code> for higher
precision (or use a larger tolerance).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The scoring functions return the individual scores for the predictions
of the observations in <code>x</code> (maintaining their dimension attributes).
</p>
<p>The default <code>scores</code>-method applies the selected (<code>which</code>)
scoring functions (and calculates <code>sign(x-mu)</code>) and returns the
results in an array (via <code>simplify2array</code>), where the last
dimension corresponds to the different scores.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer and Michaela Paul
</p>


<h3>References</h3>

<p>Czado, C., Gneiting, T. and Held, L. (2009):
Predictive model assessment for count data.
<em>Biometrics</em>, <b>65</b> (4), 1254-1261.
<a href="https://doi.org/10.1111/j.1541-0420.2009.01191.x">doi:10.1111/j.1541-0420.2009.01191.x</a>
</p>


<h3>See Also</h3>

<p>The R package <a href="https://CRAN.R-project.org/package=scoringRules"><span class="pkg">scoringRules</span></a> implements the logarithmic
score and the (continuous) ranked probability score for many
distributions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">mu &lt;- c(0.1, 1, 3, 6, 3*pi, 100)
size &lt;- 0.5
set.seed(1)
y &lt;- rnbinom(length(mu), mu = mu, size = size)
scores(y, mu = mu, size = size)
scores(y, mu = mu, size = 1)  # ses ignores the variance
scores(y, mu = 1, size = size)

## apply a specific scoring rule
scores(y, mu = mu, size = size, which = "rps")
rps(y, mu = mu, size = size)

## rps() gives NA (with a warning) if the NegBin is too wide
rps(1e5, mu = 1e5, size = 1e-5)
</code></pre>


</div>