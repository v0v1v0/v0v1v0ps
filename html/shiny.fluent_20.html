<div class="container">

<table style="width: 100%;"><tr>
<td>CommandBar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CommandBar</h2>

<h3>Description</h3>

<p>CommandBar is a surface that houses commands that operate on the content of
the window, panel, or parent region it resides above. CommandBars are one of the most
visible and recognizable ways to surface commands, and can be an intuitive
method for interacting with content on the page; however, if overloaded or
poorly organized, they can be difficult to use and hide valuable commands from
your user. CommandBars can also display a search box for finding content, hold
simple commands as well as menus, or display the status of ongoing actions.
</p>
<p>Commands should be sorted in order of importance, from left-to-right or right-to-left
depending on the culture. Secondarily, organize commands in logical
groupings for easier recall. CommandBars work best when they display no more
than 5-7 commands. This helps users quickly find your most valuable features.
If you need to show more commands, consider using the overflow menu. If you
need to render status or viewing controls, these go on the right side of the
CommandBar (or left side if in a left-to-right experience). Do not display
more than 2-3 items on the right side as it will make the overall CommandBar
difficult to parse.
</p>
<p>All command items should have an icon and a label. Commands can render as
labels only as well. In smaller widths, commands can just use icon only, but
only for the most recognizable and frequently used commands. All other
commands should go into an overflow where text labels can be shown.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/CommandBar">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CommandBar(...)

CommandBar.shinyInput(inputId, ..., itemValueGetter = function(el) el$key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputId</code></td>
<td>
<p>ID of the component. Value of the clicked CommandBarItem will be sent to this ID.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemValueGetter</code></td>
<td>
<p>A function that takes a CommandBarItem and returns a value to be sent to Shiny. By default it returns <code>key</code> of the item.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li> <p><b> buttonStyles </b> <code>IButtonStyles</code> <br> Custom styles for individual button
</p>
</li>
<li> <p><b> cacheKey </b> <code>string</code> <br> A custom cache key to be used for this item. If <code>cacheKey</code> is changed, the cache will invalidate. Defaults to <code>key</code> value.
</p>
</li>
<li> <p><b> commandBarButtonAs </b> <code style="white-space: pre;">⁠IComponentAs&lt;ICommandBarItemProps&gt;⁠</code> <br> Method to override the render of the individual command bar button. Not used when item is rendered in overflow.
</p>
</li>
<li> <p><b> iconOnly </b> <code>boolean</code> <br> Show only an icon for this item, not text. Does not apply if item is in the overflow.
</p>
</li>
<li> <p><b> renderedInOverflow </b> <code>boolean</code> <br> Context under which the item is being rendered. This value is mutated by the CommandBar and is useful for adjusting the <code>onRender</code> function.
</p>
</li>
<li> <p><b> tooltipHostProps </b> <code>ITooltipHostProps</code> <br> Props for the tooltip when in <code>iconOnly</code> mode.
</p>
</li>
<li> <p><b> ariaLabel </b> <code>string</code> <br> Accessibility text to be read by the screen reader when the user's focus enters the command bar. The screen reader will read this text after reading information about the first focusable item in the command bar.
</p>
</li>
<li> <p><b> buttonAs </b> <code style="white-space: pre;">⁠IComponentAs&lt;IButtonProps&gt;⁠</code> <br> Custom component for the near and far item buttons. Not used for overflow menu items.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> Additional css class to apply to the command bar
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;ICommandBar&gt;⁠</code> <br> Optional callback to access the ICommandBar interface. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> dataDidRender </b> <code style="white-space: pre;">⁠(renderedData: any) =&gt; void⁠</code> <br> Function to be called every time data is rendered. It provides the data that was actually rendered. A use case would be adding telemetry when a particular control is shown in an overflow or dropped as a result of <code>onReduceData</code>, or to count the number of renders that an implementation of <code>onReduceData</code> triggers.
</p>
</li>
<li> <p><b> farItems </b> <code>ICommandBarItemProps[]</code> <br> Items to render on the right side (or left, in RTL). ICommandBarItemProps extends IContextualMenuItem.
</p>
</li>
<li> <p><b> items </b> <code>ICommandBarItemProps[]</code> <br> Items to render. ICommandBarItemProps extends IContextualMenuItem.
</p>
</li>
<li> <p><b> onDataGrown </b> <code style="white-space: pre;">⁠(movedItem: ICommandBarItemProps) =&gt; void⁠</code> <br> Callback invoked when data has been grown.
</p>
</li>
<li> <p><b> onDataReduced </b> <code style="white-space: pre;">⁠(movedItem: ICommandBarItemProps) =&gt; void⁠</code> <br> Callback invoked when data has been reduced.
</p>
</li>
<li> <p><b> onGrowData </b> <code style="white-space: pre;">⁠(data: ICommandBarData) =&gt; ICommandBarData | undefined⁠</code> <br> Custom function to grow data if items are too small for the given space. Return <code>undefined</code> if no more steps can be taken to avoid infinate loop.
</p>
</li>
<li> <p><b> onReduceData </b> <code style="white-space: pre;">⁠(data: ICommandBarData) =&gt; ICommandBarData | undefined⁠</code> <br> Custom function to reduce data if items do not fit in given space. Return <code>undefined</code> if no more steps can be taken to avoid infinate loop.
</p>
</li>
<li> <p><b> overflowButtonAs </b> <code style="white-space: pre;">⁠IComponentAs&lt;IButtonProps&gt;⁠</code> <br> Custom component for the overflow button.
</p>
</li>
<li> <p><b> overflowButtonProps </b> <code>IButtonProps</code> <br> Props to be passed to overflow button. If <code>menuProps</code> are passed through this prop, any items provided will be prepended to any computed overflow items.
</p>
</li>
<li> <p><b> overflowItems </b> <code>ICommandBarItemProps[]</code> <br> Default items to have in the overflow menu. ICommandBarItemProps extends IContextualMenuItem.
</p>
</li>
<li> <p><b> shiftOnReduce </b> <code>boolean</code> <br> When true, items will be 'shifted' off the front of the array when reduced, and unshifted during grow.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;ICommandBarStyleProps, ICommandBarStyles&gt;⁠</code> <br> Customized styling that will layer on top of the variant rules.
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme provided by HOC.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(shiny)
library(shiny.fluent)

items &lt;- function(ns) {
  list(
    CommandBarItem(
      key = ns("newItem"),
      text = "New",
      cacheKey = "myCacheKey",
      split = TRUE,
      iconProps = list(iconName = "Add"),
      subMenuProps = list(
        items = list(
          CommandBarItem(
            key = ns("emailMessage"),
            text = "Email message",
            iconProps = list(iconName = "Mail")
          ),
          CommandBarItem(
            key = ns("calendarEvent"),
            text = "Calendar event",
            iconProps = list(iconName = "Calendar")
          )
        )
      )
    ),
    CommandBarItem(
      key = ns("upload"),
      text = "Upload",
      iconProps = list(iconName = "Upload")
    ),
    CommandBarItem(
      key = ns("share"),
      text = "Share",
      iconProps = list(iconName = "Share")
    ),
    CommandBarItem(
      key = ns("download"),
      text = "Download",
      iconProps = list(iconName = "Download")
    )
  )
}

farItems &lt;- function(ns) {
  list(
    CommandBarItem(
      key = ns("tile"),
      text = "Grid view",
      ariaLabel = "Grid view",
      iconOnly = TRUE,
      iconProps = list(iconName = "Tiles")
    ),
    CommandBarItem(
      key = ns("info"),
      text = "Info",
      ariaLabel = "Info",
      iconOnly = TRUE,
      iconProps = list(iconName = "Info")
    )
  )
}

ui &lt;- function(id) {
  ns &lt;- NS(id)
  tagList(
    CommandBar(
      items = items(ns),
      farItems = farItems(ns)
    ),
    textOutput(ns("commandBarItems")),
    CommandBar.shinyInput(
      inputId = ns("commandBar"),
      items = items(identity),
      farItems = farItems(identity)
    ),
    textOutput(ns("commandBar"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    commandBarItemClicked &lt;- reactiveVal()
    observeEvent(input$newItem, commandBarItemClicked("newItem clicked (explicitly observed)"))
    observeEvent(input$upload, commandBarItemClicked("upload clicked (explicitly observed)"))
    output$commandBarItems &lt;- renderText(commandBarItemClicked())
    output$commandBar &lt;- renderText(input$commandBar)
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>