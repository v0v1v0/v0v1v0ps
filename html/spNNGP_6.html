<div class="container">

<table style="width: 100%;"><tr>
<td>predict.NNGP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for prediction at new locations using <code>NNGP</code> models.</h2>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples
for a set of new locations given an object of
class <code>NNGP</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'NNGP'
predict(object, X.0, coords.0, sub.sample,
        n.omp.threads = 1, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>NNGP</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.0</code></td>
<td>
<p>the design matrix for prediction locations. An
intercept should be provided in the first column if one is specified
in <code>sp.obj</code> model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to
<code>X.0</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub.sample</code></td>
<td>
<p>an optional list that specifies the samples to included in
the composition sampling a non-Conjugate model. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
      as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and
<code>thin=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report sampling progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>predict.NNGP</code> which is a list comprising:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.y.0</code></td>
<td>
<p>a matrix that holds the response variable posterior
predictive samples where rows are locations corresponding to
<code>coords.0</code> and columns are samples. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.0</code></td>
<td>
<p>a matrix that holds the random effect posterior
predictive samples where rows are locations corresponding to
<code>coords.0</code> and columns are samples. This is only returned if the
input class has <code>method = "latent".</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Jurnal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

##Make some data
set.seed(1)
n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

x &lt;- cbind(1, rnorm(n))

B &lt;- as.matrix(c(1,5))

sigma.sq &lt;- 5
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

ho &lt;- sample(1:n, 50)

y.ho &lt;- y[ho]
x.ho &lt;- x[ho,,drop=FALSE]
w.ho &lt;- w[ho]
coords.ho &lt;- coords[ho,]

y &lt;- y[-ho]
x &lt;- x[-ho,,drop=FALSE]
w &lt;- w[-ho,,drop=FALSE]
coords &lt;- coords[-ho,]

##Fit a Response, Latent, and Conjugate NNGP model
n.samples &lt;- 500

starting &lt;- list("phi"=phi, "sigma.sq"=5, "tau.sq"=1)

tuning &lt;- list("phi"=0.5, "sigma.sq"=0.5, "tau.sq"=0.5)

priors &lt;- list("phi.Unif"=c(3/1, 3/0.01), "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 1))

cov.model &lt;- "exponential"

n.report &lt;- 500

##Latent
m.s &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="latent", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1, n.report=n.report)

p.s &lt;- predict(m.s, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

plot(apply(p.s$p.w.0, 1, mean), w.ho)
plot(apply(p.s$p.y.0, 1, mean), y.ho)

##Response
m.r &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="response", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1, n.report=n.report)

p.r &lt;- predict(m.r, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

points(apply(p.r$p.y.0, 1, mean), y.ho, pch=19, col="blue")

##Conjugate
theta.alpha &lt;- c(phi, tau.sq/sigma.sq)
names(theta.alpha) &lt;- c("phi", "alpha")

m.c &lt;- spConjNNGP(y~x-1, coords=coords, n.neighbors=10,
                  theta.alpha=theta.alpha, sigma.sq.IG=c(2, sigma.sq),
                  cov.model=cov.model, n.omp.threads=1)

p.c &lt;- predict(m.c, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

points(p.c$y.0.hat, y.ho, pch=19, col="orange")

</code></pre>


</div>