<div class="container">

<table style="width: 100%;"><tr>
<td>gen_loc_outl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Contamination with Local Outliers
</h2>

<h3>Description</h3>

<p>Generates synthetic local outliers and contaminates a given p-variate random field by swapping observations based on the first principal component score.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gen_loc_outl(x, coords, alpha = 0.05, 
             neighborhood_type = c("radius", "fixed_n"), 
             radius = NULL, 
             neighborhood_size = NULL, 
             swap_order = c("regular", "reverse", "random"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix or data frame with dimension <code>c(n,2)</code> containing the coordinates of the observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>a numeric value between 0 and 1 determining the proportion of the contaminated observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighborhood_type</code></td>
<td>

<p>a string determining the type of neighborhood. If <code>'radius'</code>, each neighborhood contains all points within the radius determined by the parameter <code>radius</code>. If <code>'fixed_n'</code>, each neighborhood contains a constant number of closest points, where the constant is determined by the parameter <code>neighborhood_size</code>. Default is <code>'radius'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>

<p>a positive numeric value defining the size of the radius when the <br><code>neighborhood_type</code> is <code>'radius'</code>. If <code>NULL</code> the radius defaults as <code>0.01*n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighborhood_size</code></td>
<td>

<p>a positive integer defining the number of points in each neighborhood when the <code>neighborhood_type</code> is <code>'fixed_n'</code>. If <code>NULL</code> the number of points defaults as <code>ceiling(0.01*n)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap_order</code></td>
<td>

<p>a string to determine which swap order is used. Either <code>'regular'</code> (default), <code>'reverse'</code> or <code>'random'</code>. See details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gen_loc_outl</code> generates local outliers by swapping the most extreme and the least extreme observations based on the first principal component score under the condition that at most one outliers lies in each neighborhood. For each location <code class="reqn">s_i</code>, the neighborhood <code class="reqn">N_i</code> is defined based on the parameter 
<code>neighborhood_type</code>. When <code>neighborhood_type</code> is <code>'radius'</code>, the neighborhood <code class="reqn">N_i</code> contains all locations <code class="reqn">s_j</code> for which the Euclidean norm <code class="reqn">||s_i - s_j|| &lt; r</code>, where <code class="reqn">r</code> is determined by the parameter <code>radius</code>. When <code>neighborhood_type</code> is <code>'fixed_n'</code>, the neighborhood <code class="reqn">N_i</code> contains <code class="reqn">m - 1</code> nearest locations of <code class="reqn">s_i</code>, where <code class="reqn">m</code> is determined by the parameter <code>neighborhood_size</code>. For more details see Ernst &amp; Haesbroeck, (2017).
</p>
<p>After calculating the neighborhoods, the local outliers are generated following Ernst &amp; Haesbroeck, (2017) and Harris
et al. (2014) using the steps:
</p>

<ol>
<li>
<p>Sort the observations from highest to lowest by their principle component analysis (PCA) scores of the first component (PC-1).

</p>
</li>
<li>
<p>Set <code class="reqn">k</code> to be <code class="reqn">\alpha N/2</code> rounded to nearest integer and select the set of local outlier points <code class="reqn">S^{out}</code> by finding <code class="reqn">k</code> observations with the highest PC-1 values and <code class="reqn">k</code> observations with the lowest PC-1 values under the condition that for all <code class="reqn">s_i, s_j \in S_{out}</code> it holds that <code class="reqn">N_i \neq N_j</code>.

</p>
</li>
<li>
<p>Form sets <code class="reqn">X_{large}</code>, which contains <code class="reqn">k</code> observations with the largest PC-1 values of outlier points <code class="reqn">S_{out}</code> and <code class="reqn">X^{small}</code>, which contains <code class="reqn">k</code> observations with the smallest PC-1 values of outlier points <code class="reqn">S^{out}</code>. Generate the local outliers by swapping <code class="reqn">X^{small,i}</code> with <code class="reqn">X^{large, k + 1 - i}</code>, <code class="reqn">i=1,...,k</code>. The parameter <code>swap_order</code> defines how the sets <code class="reqn">X^{large}</code> and <code class="reqn">X^{small}</code> are ordered.

</p>
</li>
</ol>
<p>If the parameter <code>swap_order</code> is <code>'regular'</code>, <code class="reqn">X^{small}</code> and <code class="reqn">X^{large}</code> are sorted by PC-1 score from smallest to largest.
If the parameter <code>swap_order</code> is <code>'reverse'</code>, <code class="reqn">X^{small}</code> is sorted from largest to smallest and <code class="reqn">X^{large}</code> from smallest to largest.
If the parameter <code>swap_order</code> is <code>'random'</code>, <code class="reqn">X^{small}</code> and <code class="reqn">X^{large}</code> are in random order.
</p>


<h3>Value</h3>

<p><code>gen_loc_outl</code> returns a <code>data.frame</code> containing the contaminated fields as <code class="reqn">p</code> first columns. The column <code class="reqn">p + 1</code> contains a logical indicator whether the observation is an outlier or not.
</p>


<h3>Note</h3>

<p>This function is a modified version of code originally
provided by M. Ernst and G. Haesbroeck.
</p>


<h3>References</h3>

<p>Ernst, M., &amp; Haesbroeck, G. (2017). <em>Comparison of local outlier detection techniques in spatial multivariate data</em>. Data Mining and Knowledge Discovery, 31 , 371-399. <a href="https://doi.org/10.1007/s10618-016-0471-0">doi:10.1007/s10618-016-0471-0</a>
</p>
<p>Harris, P., Brunsdon, C., Charlton, M., Juggins, S., &amp; Clarke, A. (2014). <em>Multivariate spatial outlier detection using robust geographically weighted methods</em>. Mathematical Geosciences, 46 , 1-31. <a href="https://doi.org/10.1007/s11004-013-9491-0">doi:10.1007/s11004-013-9491-0</a>
</p>


<h3>See Also</h3>

<p><code>gen_glob_outl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
                   
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  
  # Generate 5 % local outliers to data using radius neighborhoods 
  # and regular swap_order.
  field_cont &lt;- gen_loc_outl(field, coords, alpha = 0.05,
                             neighborhood_type = "radius", 
                             radius = 0.5, swap_order = "regular")

  # Generate 10 % local outliers to data using fixed_n neighborhoods 
  # and reverse swap_order.
  field_cont2 &lt;- gen_loc_outl(field, coords, alpha = 0.1, 
                              neighborhood_type = "fixed_n", 
                              neighborhood_size = 10, swap_order = "reverse")
}
</code></pre>


</div>