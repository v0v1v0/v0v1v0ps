<div class="container">

<table style="width: 100%;"><tr>
<td>unfolding</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nonmetric unfolding</h2>

<h3>Description</h3>

<p>Variant of smacof for rectangular matrices (typically ratings, preferences) that allows for nonmetric transformations. Also known as nonmetric unfolding.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unfolding(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)

smacofRect(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)

prefscal(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Data frame or matrix of preferences, ratings, dissimilarities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>Number of dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code>, or <code>"mspline"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditionality</code></td>
<td>
<p>A single transformations are applied for the entire matrix <code>"unconditional"</code>, or for each row separately <code>"row"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty strength balancing the loss contribution of stress and the penalty (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>Penalty width determines for what values of the variation coefficient the penalty should become active (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circle</code></td>
<td>
<p>If <code>"column"</code>, the column configurations are restricted to be on a circle, if <code>"row"</code>, row configurations are on a circle, if <code>"none"</code>, there are no restrictions on row and column configurations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Optional list of length two with starting values for the row coordinates (first element) and column coordinates (second element).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Do external unfolding by fixing the <code>row</code> coordinates, <code>column</code> coordinate, or choose <code>none</code> (default) to do normal unfolding. Even fixed coordinates are uniformly scaled by a constant to fit the loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.coord</code></td>
<td>
<p>Matrix with fixed coordinates of the appropriate size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties</code></td>
<td>
<p>Tie specification for <code>ordinal</code> transformations: <code>primary</code> unties the ties and <code>secondary</code> keeps the ties tied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization after 100 iterations. It tends to reduce the number of iterations by a factor 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itmax</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.degree</code></td>
<td>
<p>Degree of the spline for an <code>"mspline"</code> transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for a <code>"mspline"</code> transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallelize</code></td>
<td>
<p>Tries to parallelize the computations when <code>conditionality = "row"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Unfolding tries to match a rectangular matrix <code>delta</code> of dissimilarities between row and column objects by Euclidean distances between row and column points. Badness of fit is measured by raw Stress as the sum of squared differences between <code>delta</code> and the Euclidean distances. Instead of dissimilarities optimal transformations (dhats) can be found. The dhats should be a function of the original <code>delta</code> restricted to be <code>"ratio"</code>, <code>"interval"</code>, <code>"ordinal"</code>, or <code>"mspline"</code>. These transformations can be the same for the entire matrix (<code>conditionality = "unconditional"</code>) of data, or different per row (<code>conditionality = "row"</code>). To avoid a degenerate solution with all dhats and distances equal to 1, the prefscal penalty is is used. 
</p>
<p>A penalty is added based on the variation coefficient of the dhats (mean dhat divided by the standard deviation of the dhats). The penalty width (<code>omega</code>) weights the penalty and determines from what value of the variation coefficient of the dhats the penalty should become active. The penalty strength (<code>lambda</code>) is needed to ensure that the penalty can be strong enough. Busing et al. (2005) suggest to use <code class="reqn">\lambda = 0.5</code> and <code class="reqn">\omega = 1.0</code> (for unconditional solutions <code class="reqn">\omega</code> can be lowered to a value as low as 0.1). 
</p>
<p>External unfolding can be done by specifying <code>fixed = "row"</code> or <code>"column"</code> and providing the fixed coordinates in <code>fixed.coord</code>. Then, either the rows or columns are fixed up to a uniform constant.
</p>
<p>Creates an object of class <code>smacofR</code>. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obsdiss</code></td>
<td>
<p>Observed dissimilarities, corresponds to <code>delta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confdist</code></td>
<td>
<p>Configuration dissimilarities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dhat</code></td>
<td>
<p>Matrix with optimal transformation of size <code>delta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iord</code></td>
<td>
<p>List of size 1 for matrix conditional and size <code>nrow(delta)</code> for row conditional with the index that orders the dhats. Needed for the Shepard plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.row</code></td>
<td>
<p>Matrix of final row configurations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.col</code></td>
<td>
<p>Matrix of final column configurations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stress</code></td>
<td>
<p>Final, normalized stress value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pstress</code></td>
<td>
<p>Penalized stress value (the criterion that is minimized)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spp.row</code></td>
<td>
<p>Stress per point, rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spp.col</code></td>
<td>
<p>Stress per point, columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>congvec</code></td>
<td>
<p>Vector of congruency coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Type of smacof model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nind</code></td>
<td>
<p>Number of individuals (rows)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>Transformation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditionality</code></td>
<td>
<p>Conditionality of the transformation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobj</code></td>
<td>
<p>Number of objects (columns)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Patrick Groenen, Jan de Leeuw and Patrick Mair</p>


<h3>References</h3>

<p>De Leeuw, J. &amp; Mair, P. (2009). Multidimensional scaling using majorization: 
The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a> 
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. 
Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>
<p>Busing, F. M. T. A., Groenen, P. J. F., &amp; Heiser, W. J. (2005). Avoiding degeneracy in multidimensional unfolding by penalizing on the coefficient of variation. Psychometrika, 70, 71-98.
</p>


<h3>See Also</h3>

<p><code>plot.smacof</code>, <code>smacofConstraint</code>, <code>smacofSym</code>, <code>smacofIndDiff</code>, <code>smacofSphere</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Ratio unfolding
res &lt;- unfolding(breakfast)
res

## various configuration plots
plot(res)
plot(res, type = "p", pch = 25)
plot(res, type = "p", pch = 25, col.columns = 3, 
     label.conf.columns = list(label = TRUE, pos = 3, col = 3), 
     col.rows = 8, label.conf.rows = list(label = TRUE, pos = 3, col = 8))

## Shepard plot
plot(res, "Shepard")

## Stress decomposition chart
plot(res, "stressplot")

## Not run: 
## Ordinal unfolding, row-conditional
## Note that ordinal unfolding may need many iterations (several thousands)
res &lt;- unfolding(breakfast, type = "ordinal", conditionality = "row", omega = 0.1, itmax = 3000)
res
plot(res, "Shepard")      ## Shepard plot
plot(res)

## End(Not run)
</code></pre>


</div>