<div class="container">

<table style="width: 100%;"><tr>
<td>sr_vcov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute variance covariance of Sharpe Ratios.</h2>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample Sharpe ratios.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sr_vcov(X,vcov.func=vcov,ope=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.
It not a matrix, but a numeric of length <code class="reqn">n</code>, then it is
coerced into a <code class="reqn">n \times 1</code> matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code> returns
streams, this function estimates the asymptotic variance
covariance matrix of the vector of sample Sharpes, 
<code class="reqn">\left[\zeta_1,\zeta_2,\ldots,\zeta_p\right]</code>
</p>
<p>One may use the default method for computing covariance,
via the <code>vcov</code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>
<p>This code first estimates the covariance of the <code class="reqn">2p</code> vector of 
the vector <code class="reqn">x</code> stacked on its Hadamard square, <code class="reqn">x^2</code>. This is
then translated back to a variance covariance on the vector of
sample Sharpe ratios via the Delta method.
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>SR</code></td>
<td>
<p>a vector of (annualized) Sharpe ratios.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ohat</code></td>
<td>
<p>a <code class="reqn">p \times p</code> variance covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the number of assets.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Sharpe, William F. "Mutual fund performance." Journal of business (1966): 119-138.
<a href="https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html">https://ideas.repec.org/a/ucp/jnlbus/v39y1965p119.html</a>
</p>
<p>Lo, Andrew W. "The statistics of Sharpe ratios." Financial Analysts Journal 58, no. 4 
(2002): 36-52. <a href="https://www.ssrn.com/paper=377260">https://www.ssrn.com/paper=377260</a>
</p>


<h3>See Also</h3>

<p><code>reannualize</code>
</p>
<p>sr-distribution functions, <code>dsr</code>
</p>
<p>Other sr: 
<code>as.sr()</code>,
<code>confint.sr()</code>,
<code>dsr()</code>,
<code>is.sr()</code>,
<code>plambdap()</code>,
<code>power.sr_test()</code>,
<code>predint()</code>,
<code>print.sr()</code>,
<code>reannualize()</code>,
<code>se()</code>,
<code>sr_equality_test()</code>,
<code>sr_test()</code>,
<code>sr_unpaired_test()</code>,
<code>sr</code>,
<code>summary.sr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- matrix(rnorm(1000*3),ncol=3)
colnames(X) &lt;- c("ABC","XYZ","WORM")
Sigmas &lt;- sr_vcov(X)
# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- sr_vcov(X)

if (require(sandwich)) {
Sigmas &lt;- sr_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- sr_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- sr_vcov(Xf,vcov.func=vcovHAC)
}

# should run for a vector as well
X &lt;- rnorm(1000)
SS &lt;- sr_vcov(X)

</code></pre>


</div>