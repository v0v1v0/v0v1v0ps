<div class="container">

<table style="width: 100%;"><tr>
<td>stb.VCA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simultaneous Tolerance Bounds on Residuals and Random Effects for 'VCA' Objects.</h2>

<h3>Description</h3>

<p>Simulate <code class="reqn">N</code>-times data incorporating the estimated variance-covariance
matrix of observations <code class="reqn">y</code> and construct a 100(1-alpha)% simultaneous tolerance band.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'VCA'
stb(
  obj,
  term = NULL,
  mode = c("raw", "student", "standard", "pearson"),
  N = 5000,
  alpha = 0.05,
  algo = c("rank", "R", "C"),
  q.type = 2L,
  plot = TRUE,
  legend = TRUE,
  orient = 1,
  main1 = NULL,
  main2 = NULL,
  seed = NULL,
  type = 1,
  pb = TRUE,
  parallel = TRUE,
  Ncpu = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>(VCA) object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term</code></td>
<td>
<p>(character, integer) specifying a type of residuals if one of c("conditional",
"marginal"), or, the name of a random term (one of obj$re.assign$terms). If 'term'
is a integer, it is interpreted as the i-th random term in 'obj$re.assign$terms'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>(character) string specifying a possible transformation of random effects or 
residuals (see <code>residuals.VCA</code> and <code>ranef.VCA</code>for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>(integer) specifying the number of simulated datasets <code class="reqn">y_sim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(numeric) value 0 &lt; alpha &lt; 1 specifying the min. 100(1-alpha)% coverage of the
simultaneous tolerance band (STB)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>(character) (string) specifying the method to be used for constructing a 100(1-alpha)% STB,
choose "rank" for the rank-based, "C" for a C-implementation of the quantile-based, and
"R" for an R-implentation of the quantile-based algorithm (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.type</code></td>
<td>
<p>(integer) value specifying the quantile type to be used as offered in <code>quantile</code>
in case 'algo="R"'.    Whenever 'algo="C"', quantiles are computed according to SAS PCTLDEF5, 
which is identical to type 2. The rank-based algorithm does not employ quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>(logical) TRUE = create 'stbVCA' object and plot it, FALSE = only create the 'stbVCA' object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>(logical) TRUE = add legend to the plot(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orient</code></td>
<td>
<p>(integer) in QQ-plot, specifying whether to plot expected values vs. observed values (1)
or observed vs. expected (2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main1</code></td>
<td>
<p>(character) string specifying an user-defined main-title of the 'type=1' plot (STB)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main2</code></td>
<td>
<p>(character) string specifying an user-defined main-title of the 'type=2' plot (STI)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>(integer) value used as seed for the RNG</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>(integer) 1 = QQ-plot with simultaneous tolerance band (STB), 2 = residual plot with simultaneous 
tolerance interval (STI), 3 = both plot at once</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pb</code></td>
<td>
<p>(logical) TRUE = a text-based progress bar will display the simulation progress</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>(logical) TRUE = parallel processing will be attempted on 'Ncpu' cores of the local machine.
FALSE = no parallel processing applied, only in this case, 'pb' will have an effect, since this 
is only available for non-parallel processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncpu</code></td>
<td>
<p>(integer) specifying the number of CPUs on which the parallelization will be carried out.
In case that 'Ncup' is larger than the number of existing CPUs, the max. number of CPUs will be used
instead. Note, that setting 'Ncpu' to the max. number available may not result in the min. time 
spent on computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A Linear Mixed Models, noted in standard matrix notation, can be written as <code class="reqn">y = Xb + Zg + e</code>, where
<code class="reqn">y</code> is the column vector of observations, <code class="reqn">X</code> and <code class="reqn">Z</code> are design matrices assigning fixed (<code class="reqn">b</code>),
respectively, random (<code class="reqn">g</code>) effects to observations, and <code class="reqn">e</code> is the column vector of residual errors.
</p>
<p>Here, simulation is performed incorporating the variance-covariance matrix <code class="reqn">V = ZGZ^{T}+R</code> of observations <code class="reqn">y</code>. 
There are two types of random variates in a mixed model, random effects <code class="reqn">g</code> and residual errors <code class="reqn">e</code>. These
follow a multivariate normal distribution with expectation zero and covariance matrices <code class="reqn">G</code> and <code class="reqn">R</code>. See the 1st 
reference for a detailed description of the properties. 
Following Schuetzenmeister and Piepho (2012), a Cholesky decomposition <code class="reqn">V = CC'</code> is applied to <code class="reqn">V</code>, 
yielding the upper triangular matrix <code class="reqn">C</code>, which can be used to simulate a new set of observations 
<code class="reqn">y_{sim}=Cz</code>, where <code class="reqn">z</code> is a vector of independent standard normal deviates of the same size as <code class="reqn">y</code>.
Actually, <code class="reqn">y_sim = C'z</code> is used here, because the Cholesky decomposition in <code>R</code> is defined as <code class="reqn">V=C'C</code>. 
For each simulated dataset, random variates of interest ('term') are extracted, possibly transformed ('mode') and
stored in ordered form (order statistics) in a <code class="reqn">N x n</code> matrix, <code class="reqn">N</code> being the number of simulated datasets and
<code class="reqn">n</code> being the number of random variates of interest. For each column of this matrix tolerance intervals 
are computed iteratively untill the joint coverage is as close to but &gt;= 100(1-alpha)/
iterations is reached. This quantile-based algorithm is exact for <code class="reqn">N --&gt; Infinity</code>.
</p>
<p>SAS-quantile definition PCTLDEF=5 is used in the fast C-implementation of the STB-algorithm (<code>SASquantile</code>),
i.e. in case <code>algo="C"</code>. One can compute and plot two types of plots (see argument 'type'). Simultaneous tolerance
bands (STB) are helpful in assessing the general distribution of a random variate, i.e. checking for departure from
the normality assumption. Outlying observations may also be detected using STB. Simultaneous tolerance intervals (STI)
are taylored for identification of extreme values (possible outliers). STI are a simplification of STB, where simultaneous
coverage is only required for extreme values of each simulation, i.e. an STB is constructed from the min and max values 
from all N simulations. This results in lower and upper bounds, which can be used in residuals plots for assessing outliers.
</p>
<p>One can choose between 3 methods for constructing the 100(1-alpha)% STB. The fastest one is the rank-based algorithm ("rank"), which
should only be applied for reasonably large number of simulations (rule of thumb: N&gt;5000). For fewer simulations,
the quantile-based algorithm is recommended. It exists in two flavours, a native R-implementation ("R") and a pure C-implementation ("C").
Both can be applied using parallel-processing (see arguments 'parallel' and 'Ncpu'). Only the R-implementation allows to specify
a specific quantile-definition other than <code>type=2</code> of function <code>quantile</code>.
</p>


<h3>Value</h3>

<p>(stbVCA) object, a list with all information needed to create the QQ-plot with ~100(1-alpha)% STB.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>
<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P., 2012. Checking the assumptions of normality and homoscedasticity in 
the general linear model using diagnostic plots. Communications in Statistics-Simulation and Computation 41, 141-154.
</p>


<h3>See Also</h3>

<p><code>getSTB</code>, <code>fastSTB</code>, <code>rankSTB</code>
</p>
<p><code>fastSTB</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(VCA)
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
fit

# use studentized conditional residuals
stb.obj1 &lt;- stb(fit, term="cond", mode="student", N=1000)

# plot it again
plot(stb.obj1)

# now request also plotting the corresponding residual plot
# capture additional computation results which are invisibly 
# returned
stb.obj1 &lt;- plot(stb.obj1, type=3)

# use other type of legend in QQ-plot
plot(stb.obj1, stb.lpos="topleft")

# use random effects "day" and apply standardization
stb.obj2 &lt;- stb(fit, term="day", mode="stand", N=1000)
# plot it again
plot(stb.obj2)

# more complex example
data(Orthodont)
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit.Ortho &lt;- anovaMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)

# studentized conditional residuals
stb.cr.stud &lt;- stb(fit.Ortho, term="cond", mode="stud", N=1000)

# same model fitted via REML (same covariance structure of random effects by
# constraining it to be diagonal)
fit.Ortho.reml1 &lt;- remlMM(distance~Sex*age2+(Subject)*age2, Ortho, cov=FALSE)

# allow block-diagonal covariance structure of random effects due to non-zero
# correlation between intercept and slope of random regression part,
# not 'cov=TRUE' is the default
fit.Ortho.reml2 &lt;- remlMM(distance~Sex*age2+(Subject)*age2, Ortho)
fit.Ortho.reml1
fit.Ortho.reml2

# covariance matrices of random effects 'G' differ
getMat(fit.Ortho.reml1, "G")[1:10, 1:10]
getMat(fit.Ortho.reml2, "G")[1:10, 1:10]

# therefore, (conditional) residuals differ
resid(fit.Ortho.reml1)
resid(fit.Ortho.reml2)

# therefore, STB differ

# studentized conditional residuals
system.time({
stb.cr.stud.reml1 &lt;- stb(fit.Ortho.reml1, term="cond", mode="stud", 
                         N=5000, Ncpu=2, seed=11) })
system.time({
stb.cr.stud.reml2 &lt;- stb(fit.Ortho.reml2, term="cond", mode="stud", 
                         N=5000, Ncpu=4, seed=11) })

# same seed-value should yield identical results
system.time({
stb.cr.stud.reml3 &lt;- stb(fit.Ortho.reml2, term="cond", mode="stud", 
                         N=5000, Ncpu=4, seed=11) })

par(mfrow=c(1,2))
plot(stb.cr.stud.reml2)
plot(stb.cr.stud.reml3)

# both type of plots side-by-side
plot(stb.cr.stud.reml2, type=3)

# and enabling identification of points
# identified elements in the 1st plot will
# be automatically added to the 2nd one
plot(stb.cr.stud.reml2, type=3, pick=TRUE)

# raw "day" random effects
stb.re.subj &lt;- stb(fit.Ortho, term="Subject", N=1000)

# identify points using the mouse
stb.re.subj &lt;- plot(stb.re.subj, pick=TRUE, type=3)

# now click on points

## End(Not run)

</code></pre>


</div>