<div class="container">

<table style="width: 100%;"><tr>
<td>spGLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for fitting univariate Bayesian generalized linear spatial regression models</h2>

<h3>Description</h3>

<p>The function <code>spGLM</code> fits univariate Bayesian
generalized linear spatial regression models. Given a set of knots,
<code>spGLM</code> will also fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class="language-R">spGLM(formula, family="binomial", weights, data = parent.frame(),
      coords, knots, starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE,
      n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spGLM</code> is called.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g., easting and northing)
or a vector of length two or three with the first and second elements recording the
number of columns and rows in the desired knot grid. The third,
optional, element sets the offset of the outermost knots from the
extent of the <code>coords</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>phi</code>, <code>nu</code>, and <code>w</code>.  The value portion of each tag is the parameter's starting value. If the predictive
process is used then <code>w</code> must be of length <code class="reqn">m</code>; otherwise,
it must be of length <code class="reqn">n</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>phi</code>, <code>nu</code>, and <code>w</code>. The value portion of each tag
defines the variance of the Metropolis sampler Normal proposal
distribution. 
</p>
<p>The tuning value for <code>beta</code> can be a
vector of length <code class="reqn">p</code> (where <code class="reqn">p</code> is the number of
regression coefficients) or, if an adaptive MCMC is not used,
i.e., <code>amcmc</code> is not specified, the lower-triangle of the
<code class="reqn">p\times p</code> Cholesky square-root of the desired proposal
covariance matrix. If the <em>predictive process</em> is used then <code>w</code> must be of length <code class="reqn">m</code>; otherwise,
it must be of length <code class="reqn">n</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>,
<code>phi.unif</code>, <code>nu.unif</code>,
<code>beta.norm</code>,  and <code>beta.flat</code>. Variance parameter
<code>simga.sq</code> is assumed to follow an
inverse-Gamma distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Gamma are
passed as a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first
and second elements corresponding to the lower and upper support,
respectively. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler, see Roberts and Rosenthal (2007) for an explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code>glm</code> <code>offset</code> argument which is passed as the
log of this value.  
</p>
<p>A non-spatial model is fit when <code>coords</code> is not specified. See
example below.
</p>


<h3>Value</h3>

<p>An object of class <code>spGLM</code>, which is a list with the following
tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.w</code></td>
<td>
<p>if this is a non-predictive process model and
<code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.w.knots</code></td>
<td>
<p>if this is a <em>predictive process</em> model and <code>amcmc</code> is used then this will be a matrix of
the Metropolis sampler acceptance rate for each knot's spatial random effect. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.knots.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the knots' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">m</code> knot locations and the columns are the
posterior samples. This is only returned if a <em>predictive process</em> model
is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">n</code> point observations and the columns are the
posterior samples. </p>
</td>
</tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825â€“848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004) Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1â€“28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O., S. Banerjee, and R.E. McRoberts. (2008) A Bayesian approach to quantifying uncertainty in multi-source forest area estimates. <em>Environmental and Ecological Statistics</em>, 15:241â€“258.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006) Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint.
</p>


<h3>See Also</h3>

<p><code>spMvGLM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(MBA)
library(coda)

set.seed(1)

rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p) %*% D + rep(mu,rep(n,p)))
}

################################
##Spatial binomial
################################

##Generate binary data
coords &lt;- as.matrix(expand.grid(seq(0,100,length.out=8), seq(0,100,length.out=8)))
n &lt;- nrow(coords)

phi &lt;- 3/50
sigma.sq &lt;- 2

R &lt;- sigma.sq*exp(-phi*as.matrix(dist(coords)))
w &lt;- rmvn(1, rep(0,n), R)

x &lt;- as.matrix(rep(1,n))
beta &lt;- 0.1
p &lt;- 1/(1+exp(-(x%*%beta+w)))

weights &lt;- rep(1, n)
weights[coords[,1]&gt;mean(coords[,1])] &lt;- 10

y &lt;- rbinom(n, size=weights, prob=p)

##Collect samples
fit &lt;- glm((y/weights)~x-1, weights=weights, family="binomial")
beta.starting &lt;- coefficients(fit)
beta.tuning &lt;- t(chol(vcov(fit)))

n.batch &lt;- 200
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

m.1 &lt;- spGLM(y~1, family="binomial", coords=coords, weights=weights, 
             starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1, "w"=0),
             tuning=list("beta"=beta.tuning, "phi"=0.5, "sigma.sq"=0.5, "w"=0.5),
             priors=list("beta.Normal"=list(0,10), "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)),
             amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
             cov.model="exponential", verbose=TRUE, n.report=10)

burn.in &lt;- 0.9*n.samples
sub.samps &lt;- burn.in:n.samples

print(summary(window(m.1$p.beta.theta.samples, start=burn.in)))

beta.hat &lt;- m.1$p.beta.theta.samples[sub.samps,"(Intercept)"]
w.hat &lt;- m.1$p.w.samples[,sub.samps]

p.hat &lt;- 1/(1+exp(-(x%*%beta.hat+w.hat)))

y.hat &lt;- apply(p.hat, 2, function(x){rbinom(n, size=weights, prob=p.hat)})

y.hat.mu &lt;- apply(y.hat, 1, mean)
y.hat.var &lt;- apply(y.hat, 1, var)

##Take a look
par(mfrow=c(1,2))
surf &lt;- mba.surf(cbind(coords,y.hat.mu),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Interpolated mean of posterior rate\n(observed rate)")
contour(surf, add=TRUE)
text(coords, label=paste("(",y,")",sep=""))

surf &lt;- mba.surf(cbind(coords,y.hat.var),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Interpolated variance of posterior rate\n(observed #
of trials)")
contour(surf, add=TRUE)
text(coords, label=paste("(",weights,")",sep=""))

###########################
##Spatial poisson
###########################
##Generate count data
set.seed(1)

n &lt;- 100

coords &lt;- cbind(runif(n,1,100),runif(n,1,100))

phi &lt;- 3/50
sigma.sq &lt;- 2

R &lt;- sigma.sq*exp(-phi*as.matrix(dist(coords)))
w &lt;- rmvn(1, rep(0,n), R)

x &lt;- as.matrix(rep(1,n))
beta &lt;- 0.1
y &lt;- rpois(n, exp(x%*%beta+w))

##Collect samples
beta.starting &lt;- coefficients(glm(y~x-1, family="poisson"))
beta.tuning &lt;- t(chol(vcov(glm(y~x-1, family="poisson"))))

n.batch &lt;- 500
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

##Note tuning list is now optional

m.1 &lt;- spGLM(y~1, family="poisson", coords=coords,
             starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1, "w"=0),
             tuning=list("beta"=0.1, "phi"=0.5, "sigma.sq"=0.5, "w"=0.5),
             priors=list("beta.Flat", "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)),
             amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
             cov.model="exponential", verbose=TRUE, n.report=10)

##Just for fun check out the progression of the acceptance
##as it moves to 43% (same can be seen for the random spatial effects).
plot(mcmc(t(m.1$acceptance)), density=FALSE, smooth=FALSE)

##Now parameter summaries, etc.
burn.in &lt;- 0.9*n.samples
sub.samps &lt;- burn.in:n.samples

m.1$p.samples[,"phi"] &lt;- 3/m.1$p.samples[,"phi"]

plot(m.1$p.beta.theta.samples)
print(summary(window(m.1$p.beta.theta.samples, start=burn.in)))

beta.hat &lt;- m.1$p.beta.theta.samples[sub.samps,"(Intercept)"]
w.hat &lt;- m.1$p.w.samples[,sub.samps]

y.hat &lt;- apply(exp(x%*%beta.hat+w.hat), 2, function(x){rpois(n, x)})

y.hat.mu &lt;- apply(y.hat, 1, mean)

##Take a look
par(mfrow=c(1,2))
surf &lt;- mba.surf(cbind(coords,y),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed counts")
contour(surf, add=TRUE)
text(coords, labels=y, cex=1)

surf &lt;- mba.surf(cbind(coords,y.hat.mu),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Fitted counts")
contour(surf, add=TRUE)
text(coords, labels=round(y.hat.mu,0), cex=1)

## End(Not run)
</code></pre>


</div>