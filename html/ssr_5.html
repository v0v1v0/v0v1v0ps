<div class="container">

<table style="width: 100%;"><tr>
<td>ssr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fits a semi-supervised regression model</h2>

<h3>Description</h3>

<p>This function implements the <em>co-training by committee</em> and <em>self-learning</em> semi-supervised regression algorithms with a set of <em>n</em> base regressor(s) specified by the user.
When only one model is present in the list of regressors, self-learning is performed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssr(theFormula, L, U, regressors = list(lm = lm, knn = caret::knnreg),
  regressors.params = NULL, pool.size = 20, gr = 1, maxits = 20,
  testdata = NULL, shuffle = TRUE, verbose = TRUE,
  plotmetrics = FALSE, U.y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theFormula</code></td>
<td>
<p>a <code>formula</code> that specifies the response and the predictor variables.
Two formats are supported: <code>"Y ~ ."</code> and <code>"Y ~ var1 + var2 + ... + varn"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a data frame that contains the initial labeled training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>a data frame that contains the unlabeled data.
If the provided data frame has the response variable as one of its columns, it will be discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regressors</code></td>
<td>
<p>a list of custom functions and/or strings naming the regression models to be used.
The strings must contain a valid name of a regression model from the 'caret' package.
The list of available regression models from the 'caret' package can be found <a href="https://topepo.github.io/caret/available-models.html">here</a>.
Functions must be named, e.g., <code>list(linearModel=lm)</code>. List names for models defined with strings are optional.
A list can contain both, strings and functions: <code>list("kknn", linearModel=lm)</code>.
For better performance in time, it is recommended to pass functions directly rather than using 'caret' strings since 'caret' does additional preprocessing when training models.
Examples can be found in the vignettes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regressors.params</code></td>
<td>
<p>a list of lists that specifies the parameters for each custom function.
For 'caret' models specified as strings in <code>regressors</code>, parameters cannot be passed, use <code>NULL</code> instead.
The parameters are specified with a named list.
For example, if <code>regressors = list("lm", knn=knnreg)</code>, the number of nearest neighbors for knn can be set with <code>list(NULL, list(k = 7))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool.size</code></td>
<td>
<p>specifies the number of candidate elements to be sampled from the unlabeled set <code>U</code>.
The best candidate elements from the pool are labeled and added to the training set.
The <code>gr</code> parameter controls how many of the best candidates are used to augment the training set at each iteration.
This parameter has big influence in computational time since in each iteration, <code>pool.size * length(regressors)</code> models are trained and evaluated in order to find the best candidate data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>an integer specifying the <em>growth rate</em>, i.e., how many of the best elements from the pool are added to the training set for each base model at each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxits</code></td>
<td>
<p>an integer that specifies the maximum number of iterations.
The training phase will terminate either when <code>maxits</code> is reached or when <code>U</code> becomes empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testdata</code></td>
<td>
<p>a data frame containing the test set to be evaluated within each iteration.
If <code>verbose = TRUE</code> and <code>plotmetrics = TRUE</code> the predictive performance of the model on the test set will be printed/plotted for each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle</code></td>
<td>
<p>a boolean specifying whether or not to shuffle the data frames rows before training the models. Defaults to <code>TRUE</code>.
Some models like neural networks are sensitive to row ordering. Often, you may want to shuffle before training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a boolean specifying whether or not to print diagnostic information to the console within each iteration.
If <code>testdata</code> is provided, the information includes performance on the test set such as RMSE and improvement percent with respect to the initial model before data from <code>U</code> was used.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotmetrics</code></td>
<td>
<p>a boolean that specifies if performance metrics should be plotted for each iteration when <code>testdata</code> is provided. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.y</code></td>
<td>
<p>an optional numeric vector with the true values fo the response variable for the unlabeled set <code>U</code>.
If this parameter is <code>!= NULL</code> then, the true values will be used to determine the best candidates to augment the training set
and the true values will be kept when adding them to the training set.
<em>This parameter should be used with caution</em> and is intended to be used to generate an upper bound model for comparison purposes only.
This is to simulate the case when the model can label the unlabeled data points used to augment the training set with 100% accuracy.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The co-training by committee implementation is based on Hady et al. (2009). It consists of a set of <em>n</em> base models (the committee), each, initially trained with independent bootstrap samples from the labeled training set <code>L</code>. The Out-of-Bag (OOB) elements are used for validation. The training set for each base model <em>b</em> is augmented by selecting the most relevant elements from the unlabeled data set <code>U</code>. To determine the most relevant elements for each base model <em>b</em>, the other models (excluding <em>b</em>) label a set of data <code>pool.size</code> points sampled from <code>U</code> by taking the average of their predictions. For each newly labeled data point, the base model <em>b</em> is trained with its current labeled training data plus the new data point and the error on its OOB validation data is computed. The top <code>gr</code> points that reduce the error the most are kept and used to augment the labeled training set of <em>b</em> and removed from <code>U</code>.
</p>
<p>When the <code>regressors</code> list contains a single model, <em>self-learning</em> is performed. In this case, the base model labels its own data points as opposed to co-training by committee in which the data points for a given model are labeled by the other models.
</p>
<p>In the original paper, Hady et al. (2009) use the same type of regressor for the base models but with different parameters to introduce diversity. The <code>ssr</code> function allows the user to specify any type of regressors as the base models. The regressors can be models from the 'caret' package, other packages, or custom functions. Models from other packages or custom functions need to comply with certain structure. First, the model's function used for training must have a formula as its first parameter and a parameter named <code>data</code> that accepts a data frame as the training set. Secondly, the <code>predict()</code> function must have the trained model as its first parameter. Most of the models from other libraries follow this pattern. If they do not follow this pattern, you can still use them by writing a wrapper function. To see examples of all those cases, please check the vignettes.
</p>


<h3>Value</h3>

<p>A list object of class "ssr" containing:
</p>
<p><b>models</b> A list of the final trained models in the last iteration.
</p>
<p><b>formula</b> The formula provided by the user in <code>theFormula</code>.
</p>
<p><b>regressors</b> The list of initial <code>regressors</code> set by the user with formatted names.
</p>
<p><b>regressors.names</b> The names of the regressors <code>names(regressors)</code>.
</p>
<p><b>regressors.params</b> The initial list of parameters provided by the user.
</p>
<p><b>pool.size</b> The initial <code>pool.size</code> specified by the user.
</p>
<p><b>gr</b> The initial <code>gr</code> specified by the user.
</p>
<p><b>testdata</b> A boolean indicating if test data was provided by the user: <code>!is.null(testdata)</code>.
</p>
<p><b>U.y</b> A boolean indicating if <code>U.y</code> was provided by the user: <code>!is.null(U.y)</code>.
</p>
<p><b>numits</b> The total number of iterations performed by the algorithm.
</p>
<p><b>shuffle</b> The initial <code>shuffle</code> value specified by the user.
</p>
<p><b>valuesRMSE</b> A numeric vector with the Root Mean Squared error on the <code>testdata</code> for each iteration.
The length is the number of iterations + 1.
The first position <code>valuesRMSE[1]</code> stores the initial RMSE before using any data from <code>U</code>.
</p>
<p><b>valuesRMSE.all</b> A numeric matrix with <em>n</em> rows and <em>m</em> columns.
Stores Root Mean Squared Errors of the individual regression models.
The number of rows is equal to the number of iterations + 1 and the number of columns is equal to the number of regressors.
A column represents a regressor in the same order as they were provided in <code>regressors</code>.
Each row stores the RMSE for each iteration and for each regression model.
The first row stores the initial RMSE before using any data from <code>U</code>.
</p>
<p><b>valuesMAE</b> Stores Mean Absolute Error information. Equivalent to <b>valuesRMSE</b>.
</p>
<p><b>valuesMAE.all</b> Stores Mean Absolute Errors of the individual regression models. Equivalent to <b>valuesRMSE.all</b>
</p>
<p><b>valuesCOR</b> Stores Pearson Correlation information. Equivalent to <b>valuesRMSE</b>.
</p>
<p><b>valuesCOR.all</b> Stores the Pearson Correlation of the individual regression models. Equivalent to <b>valuesRMSE.all</b>
</p>


<h3>References</h3>

<p>Hady, M. F. A., Schwenker, F., &amp; Palm, G. (2009). Semi-supervised Learning for Regression with Co-training by Committee. In International Conference on Artificial Neural Networks (pp. 121-130). Springer, Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class="language-R">dataset &lt;- friedman1 # Load friedman1 dataset.

set.seed(1234)

# Split the dataset into 70% for training and 30% for testing.
split1 &lt;- split_train_test(dataset, pctTrain = 70)

# Choose 5% of the train set as the labeled set L and the remaining will be the unlabeled set U.
split2 &lt;- split_train_test(split1$trainset, pctTrain = 5)

L &lt;- split2$trainset

U &lt;- split2$testset[, -11] # Remove the labels.

testset &lt;- split1$testset

# Define list of regressors. Here, only one regressor (KNN). This trains a self-learning model.
# For co-training by committee, add more regressors to the list. See the vignettes for examples.
regressors &lt;- list(knn = caret::knnreg)

# Fit the model.
model &lt;- ssr("Ytrue ~ .", L, U, regressors = regressors, testdata = testset, maxits = 10)

# Plot RMSE.
plot(model)

# Get the predictions on the testset.
predictions &lt;- predict(model, testset)

# Calculate RMSE on the test set.
sqrt(mean((predictions - testset$Ytrue)^2))
</code></pre>


</div>