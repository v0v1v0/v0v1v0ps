<div class="container">

<table style="width: 100%;"><tr>
<td>white_data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Different Approaches of Data Whitening
</h2>

<h3>Description</h3>

<p><code>white_data</code> whites the data with respect to the sample covariance matrix, or different spatial scatter matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">white_data(x, whitening = c("standard", "rob", "hr"), 
           lcov = c('lcov', 'ldiff', 'lcov_norm'), 
           kernel_mat = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whitening</code></td>
<td>

<p>a string indicating the whitening method. If <code>'standard'</code> then the whitening is carried out with respect to sample covariance matrix, if <code>'rob'</code> then the first spatial scatter matrix is used instead of sample the covariance matrix and if <code>'hr'</code> then the Hettmansperger-Randles location and scatter estimates are used for whitening. See details for more. Default is <code>'standard'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix is used for whitening, when the whitening method <code>'rob'</code> is used. Either <code>'lcov'</code> (default) or <code>'ldiff'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_mat</code></td>
<td>

<p>a spatial kernel matrix with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The inverse square root of a positive definite matrix <code class="reqn">M(x)</code> with eigenvalue decomposition <code class="reqn">UDU'</code> is defined as <code class="reqn">M(x)^{-1/2} = UD^{-1/2}U'</code>. <code>white_data</code> whitens the data by <code class="reqn">M(x)^{-1/2}(x - T(x))</code> where <code class="reqn">T(x)</code> is a location functional of <code class="reqn">x</code> and the matrix <code class="reqn">M(x)</code> is a scatter functional. If the argument <code>whitening</code> is <code>'standard'</code>, <code class="reqn">M(x)</code> is the sample covariance matrix and <code class="reqn">T(x)</code> is a vector of column means of <code class="reqn">x</code>. If the argument <code>whitening</code> is <code>'hr'</code>, the Hettmansperger-Randles location and scatter estimates (Hettmansperger &amp; Randles, 2002) are used as location functional <code class="reqn">T(x)</code> and scatter functional <code class="reqn">M(x)</code>. The Hettmansperger-Randles location and scatter estimates are robust variants of sample mean and covariance matrices, that are used for whitening in <code>robsbss</code>. If the argument <code>whitening</code> is <code>'rob'</code>, the argument <code>lcov</code> determines the scatter functional <code class="reqn">M(x)</code> to be one of the following local scatter matrices:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}),</code>
</p>

</li>
</ul>
<p>where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code>sbss_asymp</code> and <code>sbss_boot</code>. See also <code>sbss</code> for details.
</p>
<p>Note that <code class="reqn">LCov(f)</code> are usually not positive definite, therefore in that case the matrix cannot be inverted and an error is produced. Whitening with <code class="reqn">LCov(f)</code> matrices might be favorable in the presence of spatially uncorrelated noise, and whitening with <code class="reqn">LDiff(f)</code> might be favorable when a non-constant smooth drift is present in the data.
</p>
<p>The argument <code>kernel_mat</code> is a matrix of dimension <code>c(n,n)</code> where each entry corresponds to the spatial kernel function evaluated at the distance between two sample locations, mathematically the entry ij of each kernel matrix is <code class="reqn">f(d_{i,j})</code>. This matrix is usually computed with the function <code>spatial_kernel_matrix</code>.
</p>


<h3>Value</h3>

<p><code>white_data</code> returns a list with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>a numeric vector of length <code>ncol(x)</code> containing the column means of the data matrix <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_0</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> containing the columns centered data of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_w</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> containing the whitened data of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which is the scatter matrix <code class="reqn">M</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_inv_sqrt</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which equals the inverse square root of the scatter matrix <code class="reqn">M</code> used for whitening.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_sqrt</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which equals the square root of the scatter matrix <code class="reqn">M</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>
<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>spatial_kernel_matrix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  X &lt;- as.matrix(field)

  # white the data with the usual sample covariance 
  x_w_1 &lt;- white_data(X)
  
  # white the data with a ldiff matrix and ring kernel
  kernel_params_ring &lt;- c(0, 1)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  x_w_2 &lt;- white_data(field, whitening = 'rob',
    lcov = 'ldiff', kernel_mat = ring_kernel_list[[1]])
  
  # Generate 5 % of global outliers to data
  field_cont &lt;- gen_glob_outl(field)[,1:3]
  X &lt;- as.matrix(field_cont)
  # white the data using Hettmansperger-Randles location and scatter estimates
  x_w_3 &lt;- white_data(X, whitening = 'hr')
}
</code></pre>


</div>