<div class="container">

<table style="width: 100%;"><tr>
<td>clls-deprecated</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cumulative Link Location-Scale Models
</h2>

<h3>Description</h3>

<p>IMPORTANT: This function and its methods are no longer supported. The
user is adviced to use clm() from package ordinal instead.
</p>
<p>Fits a cumulative link location-scale model to an ordered response
variable. When the scale part is left unspecified, the model reduces
to a cumulative link model assuming a constant scale. With the default
logistic link function, the model reduces to the famous <em>Proportional
Odds Model</em>. With the probit link and a single two-level factor in both
location and scale parts, the model is known as the <em>Binormal</em>
model in the Signal Detection Theory and the Psychometric
literature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  clls(location, scale, data, weights, start, ..., subset,
           na.action, contrasts = NULL, Hess = FALSE, model = TRUE,
           method = c("logistic", "probit", "cloglog", "cauchit"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>location</code></td>
<td>

<p>a formula expression as for regression models, of the form
<code>response ~ predictors</code>. The response should be a factor
(preferably an ordered factor), which will be interpreted as an
ordinal response, with levels ordered as in the factor.
The model must have an intercept: attempts to remove one will
lead to a warning and be ignored. An offset may be used.  See the
documentation of <code>formula</code> for other details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>a optional formula expression as for the location part, of the form
<code> ~ predictors</code>, ie. with an empty left hand side.
If left unspecified, the model assumes a constant scale and reduces
to the cumulative link model.
An offset may be used.  See the
documentation of <code>formula</code> for other details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame in which to interpret the variables occurring
in <code>formula</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>optional case weights in fitting.  Default to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>initial values for the parameters.  This is in the format
<code>c(beta, theta, sigma)</code>: see the Values section.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to be passed to <code>optim</code>, most often a
<code>control</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>expression saying which subset of the rows of the data should  be used
in the fit.  All observations are included by default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>a function to filter missing data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>

<p>a list of contrasts to be used for some or all of
the factors appearing as variables in the model formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess</code></td>
<td>

<p>logical for whether the Hessian (the observed information matrix)
should be returned.  Use this if you intend to call <code>summary</code> or
<code>vcov</code> on the fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>logical for whether the model matrix should be returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>logistic or probit or complementary log-log or cauchit (corresponding
to a Cauchy latent variable).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The implementation is highly inspired by <code>polr</code> in
package MASS and should give compatible results, if <code>scale</code> is
left unspecified.
</p>
<p>Note that standard errors are appropriate for <code>tau</code> =
log <code>sigma</code> and not for <code>sigma</code>, because the profile
likelihood is usually more symmetric for <code>tau</code> than for
<code>sigma</code>. Therefore <code>vcov</code> will give the
variance-covariance matrix of the parameters with <code>tau</code> rather
than <code>sigma</code> and <code>summary.clls</code> will report standard errors
for log <code>sigma</code>. Notice also that a relevant test for
<code>sigma</code> is <code class="reqn">H_0: sigma = 1</code>, so the relevant test for log
<code>sigma</code> is <code class="reqn">H_0: log(sigma) = 0</code>. This is reflected in the z
value for <code>sigma</code> returned by <code>summary.clls</code>.
</p>
<p>There are methods for the standard model-fitting functions, including
<code>summary</code>, <code>vcov</code>,
<code>anova</code>, and an
<code>extractAIC</code> method.
</p>


<h3>Value</h3>

<p>A object of class <code>"clls"</code>. This has components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the coefficients of the location
(<code>beta</code>), the intercepts (<code>theta</code>) and the scale
(<code>sigma</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the parameter estimates of the location part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the intercepts/thresholds for the class boundaries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>the parameter estimates of the scale part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>parameter estimates of the scale part on the log scale;
ie. <code>tau</code> = log <code>sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>the residual deviance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>a matrix, with a column for each level of the
response with the fitted probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.case</code></td>
<td>
<p>a vector of same length as <code>response</code>, with
the fitted probabilities on a case-by-case basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lev</code></td>
<td>
<p>the names of the response levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms.location</code></td>
<td>
<p>a <code>terms</code> structure describing the location
part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms.scale</code></td>
<td>
<p>a <code>terms</code> structure describing the scale
part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>the number of residual degrees of freedoms,
calculated using the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>the (effective) number of degrees of freedom used by the
model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n, nobs</code></td>
<td>
<p>the (effective) number of observations, calculated
using the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the matched method used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>the convergence code returned by <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>the number of function and gradient evaluations used by
<code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hessian</code></td>
<td>
<p>if <code>Hess</code> is true, the observed Fisher information
matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>location</code></td>
<td>
<p>if <code>model</code> is true, the <code>model.frame</code> for
the location part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>if <code>model</code> is true, the <code>model.frame</code> for
the scale part.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Agresti, A. (2002) <em>Categorical Data.</em> Second edition.  Wiley.
</p>
<p>Christensen, R.H.B., Cleaver, G. and Brockhoff, P.B. (2011). 
Statistical and Thurstonian models for the A-not A protocol
with and without sureness. <em>Food Quality and Preference</em>, 
22(6), pp.542-549.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em> Fourth edition.  Springer.
</p>


<h3>See Also</h3>

<p><code>polr</code>, <code>optim</code>, <code>glm</code>,
<code>multinom</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  old &lt;- options(contrasts = c("contr.treatment", "contr.poly"))
  ## Extend example from polr in package MASS:
  ## Fit model from polr example:
  data(housing, package = "MASS")
  fm1 &lt;- clls(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
  fm1
  summary(fm1)
  ## With probit link:
  summary(update(fm1, method = "probit"))

  ## Allow scale to depend on Cont-variable
  summary(fm2 &lt;- update(fm1, scale =~ Cont))
  anova(fm1, fm2)
  ## which seems to improve the fit
  options(old)

</code></pre>


</div>