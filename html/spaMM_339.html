<div class="container">

<table style="width: 100%;"><tr>
<td>simulate.HLfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulate realizations of a fitted model.
</h2>

<h3>Description</h3>

<p>From an HLfit object, <code>simulate.HLfit</code> function generates new samples given the estimated fixed effects 
and dispersion parameters. Simulation may be unconditional (the default, useful in many applications of parametric bootstrap), or conditional on the predicted values of random effects, or may draw from the conditional distribution of random effects given the observed response. Simulations may be run for the original sampling design (i.e., original values of fixed-effect predictor variables and of random-effect levels, including spatial locations if relevant), or for a new design as specified by the <code>newdata</code> argument. 
</p>
<p><code>simulate4boot</code> is a wrapper around <code>simulate.HLfit</code> that can be used to precompute the bootstrap samples to be used by <code>spaMM_boot</code> or <code>spaMM2boot</code> through their <code>boot_samples</code> argument (and is called internally by these functions when <code>boot_samples</code> is NULL). 
</p>
<p><code>simulate_ranef</code> will only simulate and return a vector of random effects, more specifically some elements of the <b>b</b> vector appearing in the standard form <code>offset</code>+ <b>X</b><code class="reqn">\beta</code> + <b>Z b</b> for the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'HLfit'
simulate(object, nsim = 1, seed = NULL, newdata = NULL, 
                         type = "marginal", re.form, conditional = NULL, 
                         verbose = c(type=TRUE,
                                     showpbar=eval(spaMM.getOption("barstyle"))), 
                         sizes = if (is.null(newdata)) object$BinomialDen, 
                         resp_testfn = NULL, phi_type = "predict", 
                         prior.weights = if (is.null(newdata)) object$prior.weights, 
                         variances=list(), ...)

## S3 method for class 'HLfitlist'
simulate(object, nsim = 1, seed = NULL, 
                             newdata = object[[1]]$data, sizes = NULL, ...)

simulate4boot(object, nsim, seed=NULL, resp_testfn=NULL, type="marginal", 
              showpbar=eval(spaMM.getOption("barstyle")), ...)
simulate_ranef(object, which=NULL, newdata = NULL, nsim = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>The return object of HLfit or similar function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>number of response vectors to simulate.  Defaults to '1'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>A seed for <code>set.seed</code>. If such a value is provided, the initial state of the random number generator at a global level is restored on exit from simulate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>A data frame closely matching the original data, except that response values are not needed. May provide new values of fixed predictor variables, new spatial locations, new individuals within a block, or new values of the LHS in random-effect terms of the form <code>(&lt;LHS&gt;|&lt;RHS&gt;)</code>.   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.weights</code></td>
<td>

<p>Prior weights that may be substituted to those of the original fit, with the same effect on the residual variance.
See Details for the definition of the default when <code>newdata</code> are provided. For multivariate-response fits, this is a list with one element per submodel, each element being a vector whose size is the number of response levels to be simulated for each submodel (the <code>object$prior.weights</code> provides an example). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizes</code></td>
<td>

<p>A vector of sample sizes to simulate in the case of a binomial or <code>betabin</code> fit. See Details for the definition of the default when <code>newdata</code> are provided. For multivariate-response fits, the <code>sizes</code> argument should contain elements for response levels for all submodels whatever their response families (e.g. for submodels with families and response levels <code>poisson: 3</code> and <code>binomial: 2</code>, respectively, the <code>sizes</code> vector should contain 5 elements, e.g. 1 1 1 5 10, only the last two of which having nontrivial meaning).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re.form</code></td>
<td>
<p> formula for random effects to condition on. Default behaviour depends on the <code>type</code> argument. The joint default is the latter's default, i.e., unconditional simulation. <code>re.form</code> is currently ignored when 
<code>type="predVar"</code> 
(with a warning). Otherwise, <code>re.form=NULL</code> conditions on all random effects (as <code>type="residual"</code> does), and <code>re.form=NA</code> conditions on none of the random effects (as <code>type="marginal"</code> or <code>re.form=~0</code> do).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>character string specifying which uncertainties are taken into account in the linear predictor and notably in the random effect terms. Whatever the <code>type</code>, the residual variance is always accounted in the simulation output. <code>"marginal"</code> accounts for the marginal variance of the random effect (and, by default, also for the uncertainty in fixed effects); <code>"predVar"</code> accounts for the conditional distribution of the random effects given the data (see Details); and <code>"residual"</code> should perhaps be <code>"none"</code> as no uncertainty is accounted in the linear predictor: the simulation variance is only the residual variance of the fitted model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>

<p>Obsolete and will be deprecated. Boolean; TRUE and FALSE are equivalent to <code>type="residual"</code> and <code>type="marginal"</code>, respectively. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Either a single boolean (which determines <code>verbose[["type"]]</code>, or a vector of booleans with possible elements <code>"type"</code> (to display basic information about the type of simulation) and <code>"showpbar"</code> (see <code>predict(.,verbose)</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp_testfn</code></td>
<td>

<p>NULL, or a function that tests a condition which simulated samples should satisfy. This function takes a response vector as argument and return a boolean (TRUE indicating that the sample satisfies the condition). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_type</code></td>
<td>

<p>Character string, either <code>"predict"</code> or one of the values possible for <code>type</code>. This controls the residual variance parameter <code class="reqn">\phi</code>. The default is to use predicted <code class="reqn">\phi</code> values from the fit, which are the fitted <code class="reqn">\phi</code> values except when a structured-dispersion model is involved together with non-NULL <code>newdata</code>. However, when a structured-dispersion model is involved, it is also possible to simulate new <code class="reqn">\phi</code> values, and for a mixed-effects structured-dispersion model, the same types of simulation controlled by <code>type</code> for the mean response can be performed as controlled by <code>phi_type</code>. For a fixed-effects structured-dispersion model, these types cannot be distinguished, and any <code>phi_type</code> distinct from <code>"predict"</code> will imply simulation under the fixed-effect model (see Examples). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variances</code></td>
<td>

<p>Used when <code>type="predVar"</code>: see Details. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>For <code>simulate4boot</code>, further arguments passed to <code>simulate.HLfit</code> (e.g., <code>newdata</code>). For <code>simulate.HLfit</code>, further arguments only passed to <code>predict</code> in a speculative bit of code (see Details). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p>Integer, or integer vector: the random effect(s) (indexed as ordered as in the model formula) to be simulated. If NULL, all of them are simulated. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showpbar</code></td>
<td>

<p>Controls display of progress bar. See <code>barstyle</code> option for details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>type="predVar"</code> accounts for the uncertainty of the linear predictor, by drawing new values of the predictor in a multivariate gaussian distribution with mean and covariance matrix of prediction. In this case, the user has to provide a <code>variances</code> argument, passed to <code>predict</code>, which controls what goes into this covariance matrix. For example, with <code>variances=list(linPred=TRUE,disp=TRUE)</code>), the covariance matrix takes into account the joint uncertainty in the fixed-effect coefficients and of any random effects given the response and the point estimates of dispersion and correlation parameters (<code>"linPred"</code> variance component), and in addition accounts for uncertainty in the dispersion parameters (effect of <code>"disp"</code> variance component as further described in <code>predict.HLfit</code>).  The total simulation variance is then the response variance. Uncertainty in correlation parameters (such a parameters of the Matern family) is not taken into account. The <code>"linPred"</code> uncertainty is known exactly in LMMs, and otherwise approximated as a Gaussian distribution with mean vector and covariance matrix given as per the Laplace approximation. 
</p>
<p><code>type="(ranef|response)"</code> can be viewed as a special version of <code>type="predVar"</code> where<br><code>variances=list(linPred=TRUE,disp=FALSE)</code>) and only the uncertainty in the random effects is taken into account.
</p>
<p>A full discussion of the merits of the different <code>type</code>s is beyond the scope of this documentation, but these different types may not all be useful. <code>type="marginal"</code> is typically used for computation of confidence intervals by parametric bootstrap methods. <code>type="residual"</code> is used by <code>get_cPredVar</code> for its evaluation of a bias term. The other <code>type</code>s may be used to simulate the uncertainty in the random effects, conditionally on the data, and may therefore be more akin to the computation of prediction intervals conditionally on an (unknown but inferred) realization of the random effects. But these should presumably not be used in a bootstrap computation of such intervals, as this would represent a double accounting of the uncertainty that the bootstrap aims to quantify.
</p>
<p>There are cases where simulation without a <code>newdata</code> argument may give results of different length than simulation with <code>newdata=</code>&lt;original data&gt;, as for <code>predict</code>.
</p>
<p>When <code>newdata</code> are provided but new values of <code>prior.weights</code> or <code>sizes</code> are missing, new values of these missing arguments are guessed, and warnings may be issued depending on the kind of guess made for response families dependent on such arguments. The <code>prior.weights</code> values used in the fit are re-used without warning when such values were identical (generally, unit) for all response values, and labelled as such in the <code>object$prior.weights</code>. Unit weights will be used otherwise, with a warning. Unit binomial sizes will be used, with a warning, whenever there are <code>newdata</code>.  
</p>


<h3>Value</h3>

<p><code>simulate.HLfit</code> returns a vector (if nsim=1) or a matrix with <code>nsim</code> columns, each containing simulated responses (or simulated random effects, for <code>simulated_ranef()</code>). For multivariate-response simulations, an <code>nobs</code> attribute gives the number of responses for each submodel if no <code>resp_testfn</code> was applied.
</p>
<p><code>simulate4boot</code> returns a list with elements 
</p>

<dl>
<dt>bootreps</dt>
<dd>
<p>the result of <code>simulate.HLfit</code> as a matrix with <code>nsim</code> columns;</p>
</dd>
<dt>RNGstate</dt>
<dd>
<p>the state of <code>.Random.seed</code> at the beginning of the sample simulation.</p>
</dd>  
</dl>
<p>The <code>simulate.HLfitlist</code> method returns a list of simulated responses.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Loaloa")
HLC &lt;- HLCor(cbind(npos,ntot-npos)~Matern(1|longitude+latitude),
           data=Loaloa,family=binomial(),
           ranPars=list(lambda=1,nu=0.5,rho=1/0.7)) 
simulate(HLC,nsim=2)

## Structured dispersion model 
data("wafers")
hl &lt;- HLfit(y ~X1+X2+X1*X3+X2*X3+I(X2^2)+(1|batch),family=Gamma(log),
            resid.model = ~ X3+I(X3^2) ,data=wafers)
simulate(hl,type="marginal",phi_type="simulate",nsim=2)
simulate_ranef(hl,nsim=2)
</code></pre>


</div>