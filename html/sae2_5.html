<div class="container">

<table style="width: 100%;"><tr>
<td>geo_ratios</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute rates or ratios for a set of geographic entities over a set 
of years
</h2>

<h3>Description</h3>

<p>The function computes rates or ratios by a geographic code and 
the variable <code>Year</code>. If <code>designvars</code> is specified, the function 
also returns a data frame with linear substitutes to compute Taylor 
series variances.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geo_ratios(data,  geocode,  numerators,  denominators,  geonames, 
           new.names,  designvars)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame with the required variables, including a variable 
named <code>Year</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geocode</code></td>
<td>
<p>A character variable with the name of the geographic 
variable for which separate estimates are of interest.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numerators</code></td>
<td>
<p>A character vector listing the names in <code>data</code> of the
numerators of the ratios.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denominators</code></td>
<td>
<p>A character vector listing the names in <code>data</code> of 
the denominators of the ratios. If a single value is given,
it  will be used for all of the ratios.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geonames</code></td>
<td>
<p>An optional data frame containing <code>geocode</code> and one or
more geographic variables, such as names, that will be merged
into the results. There should be only one row for each
value of <code>geocode</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.names</code></td>
<td>
<p>An optional character vector of the same length as 
<code>numerators</code> naming the resulting ratios. 
If <code>new.names</code> is not specified, the output ratios
will have the same names as <code>numerators</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designvars</code></td>
<td>
<p>Optional. If given, a character vector naming one or more 
survey design variables in <code>data</code> to use in forming 
linear substitutes for variance calculation of the ratios 
cross-classified by <code>Year</code> and the variable named by 
<code>geocode</code>. The vector should not include the 
<code>geocode</code> variable or <code>Year</code>. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For programming simplicity, the function enforces the requirement that names 
should not be repeated in either <code>numerators</code> or <code>new.names</code>. Names 
may be repeated in <code>denominators</code>.
</p>
<p>Rather than a typical survey file, the function expects the data frame 
<code>data</code> to contain weighted estimates for each analytic variable. As a 
simple example, to find the variance of the weighted mean of <code>y</code> with
weights <code>w</code>, <code>data</code> should contain <code>w</code> and 
<code>y * w</code>. For convenience, the weighted estimates can still be 
assigned their original names in <code>data</code>, such as <code>y</code>. In this 
case,
</p>
<p><code>numerators = y, denominators=w</code>
</p>
<p>would create the appropriate linear substitutes for the variance of the 
weighted mean.
</p>
<p>This design of the function allows complex possibilities, such as estimating
the variance of a rate where the numerator is based on one weight and the 
denominator is based on another. For example, estimation for the National 
Crime Victimization Survey requires this capability.
</p>


<h3>Value</h3>

<p>If <code>designvars</code> is not specified, a named list with one element,
a data frame containing the ratios sorted by <code>geocode</code>
and <code>Year</code>. 
</p>
<p>If <code>designvars</code> is specified, a second element is added 
to the list, a data frame giving the totals of the linear 
substitutes by <code>Year</code>, <code>geocode</code>, and 
<code>designvars</code>. The elements of the list are named 
<code>estimates</code> and <code>linear.subs</code>.               
</p>


<h3>Author(s)</h3>

<p>Robert E. Fay
</p>


<h3>References</h3>

<p>- Woodruff, R.S. (1971). A simple method for approximating the variance of a complex estimate. Journal of the American Statistical Association 66, 411-414.
</p>


<h3>See Also</h3>

<p><code>vcovgen</code></p>


<h3>Examples</h3>

<pre><code class="language-R">require(survey)
require(MASS)
D &lt;- 20 # number of domains
T &lt;- 5 # number of years
samp &lt;- 16 # number of sample cases per domain
set.seed(1)
# use conditional.mean=TRUE to generate true small area values
# without sampling error
Y.list &lt;- mvrnormSeries(D=D, T=T, rho.dyn=.9, sigma.v.dyn=1, 
   sigma.u.dyn=.19, sigma.e=diag(5), conditional.mean=TRUE)
# generate sampling errors
e &lt;- rnorm(samp * T * D, mean=0, sd=4)
Y &lt;- Y.list[[2]] + tapply(e, rep(1:100, each=16), mean) 
data &lt;- data.frame(Y=Y, X=rep(1:T, times=D))
# model fit with the true sampling variances
result.dyn  &lt;- eblupDyn(Y ~ X, D, T, vardir = diag(100), data=data)
# individual level observations consistent with Y
Y2 &lt;- rep(Y.list[[2]], each=16) + e 
data2 &lt;- data.frame(Y=Y2, X=rep(rep(1:T, each=samp), times=D), 
                   Year=rep(rep(1:T, each=samp), times=D), 
                   weight=rep(1, times=samp*T*D),
                   d=rep(1:D, each=samp*T), 
                   strata=rep(1:(D*T), each=samp),
                   ids=1:(D*T*samp))
# geo_ratios with designvars specified
geo.results &lt;- geo_ratios(data2, geocode="d", numerators="Y",
                          denominators="weight",
                          designvars=c("strata", "ids"))
# illustrative check                          
max(abs(geo.results[[1]]$Y - Y))
vcov.list &lt;- vcovgen(geo.results[[2]], year.list=1:5, geocode="d", 
      designvars=c("strata", "ids"))
vcov.list[[1]]
# model fitted with directly estimated variance-covariances
result2.dyn &lt;- eblupDyn(Y ~ X, D, T, vardir=vcov.list, data=data)
cor(result.dyn$eblup, result2.dyn$eblup)
</code></pre>


</div>