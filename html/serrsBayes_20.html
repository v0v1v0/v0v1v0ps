<div class="container">

<table style="width: 100%;"><tr>
<td>serrsBayes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian modelling and quantification of Raman spectroscopy</h2>

<h3>Description</h3>

<p>This R package implements sequential Monte Carlo (SMC) algorithms for fitting a
generalised additive mixed model (GAMM) to Raman spectra. These multivariate observations are highly collinear
and lend themselves to a reduced-rank representation.  The GAMM separates the
hyperspectral signal into three components: a sequence of Lorentzian or Gaussian peaks; a
smoothly-varying baseline; and zero-mean, additive white noise. The parameters of each component of
the model are estimated iteratively using SMC. The posterior distributions of the parameters
given the observed spectra are represented as a population of weighted particles.
</p>


<h3>Details</h3>

<p>Raman spectroscopy can be used to identify molecules by the characteristic scattering of light from a laser.
The pattern of peaks in a Raman spectrum corresponds to the vibrational modes of the molecule. The shift in
wavenumber of the photons is proportional to the change in energy state, which is reflected in the locations
of the peaks. Surface-enhanced Raman scattering (SERS) is a technique that amplifies the Raman
signal using metallic substrates, such as nanoparticles. The laser can also be tuned to the resonant frequency
of the molecule, which is known as surface-enhanced resonance Raman scattering (SERRS). Under controlled experimental
conditions, the amplitudes of the peaks are linearly related to the concentration of the molecule, from the limit
of detection (LOD) up to monolayer coverage of the nanoparticle surface.
</p>
<p>The GAMM represents the peaks and baseline as continuous functions. The background fluorescence is modelled
using a penalised cubic spline, while the peaks are an additive mixture of squared exponential (Gaussian) or Lorentzian
(Cauchy) kernels:
</p>
<p style="text-align: center;"><code class="reqn">Y = \sum_{m=1}^M \alpha_{i,m}B_m(\nu_j) + \sum_{p=1}^P s(\nu_j | l_p, A_p, \phi_p) + \epsilon_{i,j}</code>
</p>

<p>where <code class="reqn">Y</code> is a matrix of hyperspectral observations <code class="reqn">y_{i,j}</code> that have been discretised at wavenumbers <code class="reqn">\nu_j</code>;
<code class="reqn">B_m</code> are the <code class="reqn">M</code> spline basis functions with coefficients <code class="reqn">\alpha_{i,m}</code>; <code class="reqn">s(\nu_j | l_p, A_p, \phi_p)</code> 
are the radial basis functions for each peak, with location <code class="reqn">l_p</code>, amplitude <code class="reqn">A_p</code>, and scale <code class="reqn">\phi_p</code> parameters.
<code class="reqn">\epsilon_{i,j}</code> is assumed to be zero mean, additive white noise with constant variance <code class="reqn">\sigma^2</code>.
</p>
<p>This model-based approach accounts for differences in resolution and experimental conditions,
enabling comparison and alignment of heterogeneous spectra. The relationship between concentration
and peak intensity can be quantified by fitting a Bayesian functional regression:
</p>
<p style="text-align: center;"><code class="reqn">A_p = c_i \beta_p</code>
</p>

<p>where <code class="reqn">c_i</code> is the nanomolar (nM) concentration of the molecule in the <code class="reqn">i</code>th spectrum,
<code class="reqn">c_{LOD} &lt; c_i &lt;= c_{MLC}</code>. The regression model produces highest posterior density (HPD) intervals for the
limit of detection of each peak. A consistent, unbiased estimate of the model evidence (also known as the marginal likelihood)
is also computed. This can be used to evaluate whether Gaussian or Lorentzian peaks are a better fit to the data.
</p>


<h3>Author(s)</h3>

<p>M. T. Moores, J. Carson &amp; M. Girolami
</p>
<p>Maintainer: Matt Moores &lt;mmoores@gmail.com&gt;
</p>


<h3>References</h3>

<p>Moores, Gracie, Carson, Faulds, Graham &amp; Girolami "Bayesian modelling and quantification of Raman spectroscopy," <a href="https://arxiv.org/abs/1604.07299">arXiv preprint</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate some data with known parameter values
wavenumbers &lt;- seq(700,1400,by=2)
spectra &lt;- matrix(nrow=1, ncol=length(wavenumbers))
peakLocations &lt;- c(840,  960, 1140, 1220, 1290)
peakAmplitude &lt;- c(11500, 2500, 4000, 3000, 2500)
peakScale &lt;- c(10, 15, 20, 10, 12)
signature &lt;- weightedLorentzian(peakLocations, peakScale, peakAmplitude, wavenumbers)
baseline &lt;- 1000*cos(wavenumbers/200) + 2*wavenumbers
spectra[1,] &lt;- signature + baseline + rnorm(length(wavenumbers),0,200)
plot(wavenumbers, spectra[1,], type='l', xlab="Raman offset", ylab="intensity")
lines(wavenumbers, baseline, col=2, lty=4)
lines(wavenumbers, baseline + signature, col=4, lty=2)

# fit the model using SMC
lPriors &lt;- list(scale.mu=log(11.6) - (0.4^2)/2, scale.sd=0.4, bl.smooth=10^11, bl.knots=50,
                beta.mu=5000, beta.sd=5000, noise.sd=200, noise.nu=4)

## Not run: 
## takes approx. 1 minute for 100 SMC iterations with 10,000 particles
result &lt;- fitSpectraSMC(wavenumbers, spectra, peakLocations, lPriors)
plot.ts(result$ess, xlab="SMC iterations", ylab="ESS")

# sample 200 particles from the posterior distribution
samp.idx &lt;- sample.int(length(result$weights), 200, prob=result$weights)
plot(wavenumbers, spectra[1,], type='l', xlab="Raman offset", ylab="intensity")
for (pt in samp.idx) {
  bl.est &lt;- result$basis %*% result$alpha[,1,pt]
  lines(wavenumbers, bl.est, col="#C3000009")
  lines(wavenumbers, bl.est + result$expFn[pt,], col="#0000C309")
}

## End(Not run)
</code></pre>


</div>