<div class="container">

<table style="width: 100%;"><tr>
<td>VE.Jk.EB.SW2.Total.Hajek</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The self-weighted two-stage sampling Escobar-Berger (2013) jackknife variance estimator for the Hajek (1971) estimator of a total</h2>

<h3>Description</h3>

<p>Computes the self-weighted two-stage sampling Escobar-Berger (2013) jackknife variance estimator for the Hajek estimator of a total.  </p>


<h3>Usage</h3>

<pre><code class="language-R">VE.Jk.EB.SW2.Total.Hajek(VecY.s, VecPk.s, nII, VecPi.s,
                         VecCluLab.s, VecCluSize.s, N)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>VecY.s</code></td>
<td>
<p>vector of the variable of interest; its length is equal to <code class="reqn">n</code>, the total sample size. Its length has to be the same as that of <code>VecPk.s</code>. There must not be missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VecPk.s</code></td>
<td>
<p>vector of the elements' first-order inclusion probabilities; its length is equal to <code class="reqn">n</code>, the total sample size. Values in <code>VecPk.s</code> must be greater than zero and less than or equal to one. There must not be missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nII</code></td>
<td>
<p>the second stage sample size, i.e. the fixed number of ultimate sampling units that were selected within each cluster. Its size must be less than or equal to the minimum cluster size in the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VecPi.s</code></td>
<td>
<p>vector of the clusters' first-order inclusion probabilities; its length is equal to <code class="reqn">n</code>, the total sample size. Hence values are expected to be repeated in the utilised sample dataset. Values in <code>VecPi.s</code> must be greater than zero and less than or equal to one. There must not be missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VecCluLab.s</code></td>
<td>
<p>vector of the clusters' labels for the elements; its length is equal to <code class="reqn">n</code>, the total sample size. The labels must be integer numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VecCluSize.s</code></td>
<td>
<p>vector of the clusters' sizes; its length is equal to <code class="reqn">n</code>, the total sample size. Hence values are expected to be repeated in the utilised sample dataset. None of the sizes must be smaller than <code>nII</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>the population size. It must be an integer or a double-precision scalar with zero-valued fractional part.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the population total of the variable <code class="reqn">y</code>:
</p>
<p style="text-align: center;"><code class="reqn">t = \sum_{k\in U} y_k</code>
</p>

<p>the approximately unbiased Hajek (1971) estimator of <code class="reqn">t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{t}_{Hajek} = N \frac{\sum_{k\in s} w_k y_k}{\sum_{k\in s} w_k}</code>
</p>

<p>where <code class="reqn">w_k=1/\pi_k</code> and <code class="reqn">\pi_k</code> denotes the inclusion probability of the <code class="reqn">k</code>-th element in the sample <code class="reqn">s</code>. If <code class="reqn">s</code> is a self-weighted two-stage sample, the variance of <code class="reqn">\hat{t}_{Hajek}</code> can be estimated by the Escobar-Berger (2013) jackknife variance estimator (implemented by the current function):
</p>
<p style="text-align: center;"><code class="reqn">\hat{V}(\hat{t}_{Hajek}) = v_{clu} + v_{obs}</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{clu} = \sum_{i\in s} (1-\pi_{Ii}^{*}) \varsigma_{(Ii)}^{2} - \frac{1}{\hat{d}}\left(\sum_{i\in s} (1-\pi_{Ii}) \varsigma_{(Ii)}\right)^{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{obs} = \sum_{k\in s} \phi_k \varepsilon_{(k)}^{2}</code>
</p>

<p>where <code class="reqn">\hat{d}={\sum}_{i\in s}{(1-\pi_{Ii})}</code>, <code class="reqn">\phi_k = I\{k\in s_{i}\}\pi_{Ii}^{*}(M_{i}-n_{II})/(M_{i}-1)</code>, <code class="reqn">\pi_{Ii}^{*} = \pi_{Ii}n_{II}(M_{i}-1)/(n_{II}-1)M_{i}</code>, with <code class="reqn">s_{i}</code> denoting the sample elements from the <code class="reqn">i</code>-th cluster, <code class="reqn">I\{k\in s_{i}\}</code> is an indicator that takes the value <code class="reqn">1</code> if the <code class="reqn">k</code>-th observation is within the <code class="reqn">i</code>-th cluster and <code class="reqn">0</code> otherwise, <code class="reqn">\pi_{Ii}</code> is the inclusion probability of the <code class="reqn">i</code>-th cluster in the sample <code class="reqn">s</code>, <code class="reqn">M_{i}</code> is the size of the <code class="reqn">i</code>-th cluster, <code class="reqn">n_{II}</code> is the sample size within each cluster, <code class="reqn">n_{I}</code> is the number of sampled clusters, and where
</p>
<p style="text-align: center;"><code class="reqn">\varsigma_{(Ii)}=\frac{n_{I}-1}{n_{I}} (\hat{t}_{Hajek}-\hat{t}_{Hajek(Ii)})</code>
</p>

<p style="text-align: center;"><code class="reqn">\varepsilon_{(k)}=\frac{n-1}{n} (\hat{t}_{Hajek}-\hat{t}_{Hajek(k)})</code>
</p>

<p>where  <code class="reqn">\hat{t}_{Hajek(Ii)}</code> and <code class="reqn">\hat{t}_{Hajek(k)}</code> have the same functional form as <code class="reqn">\hat{t}_{Hajek}</code> but omitting the <code class="reqn">i</code>-th cluster and the <code class="reqn">k</code>-th element, respectively, from the sample <code class="reqn">s</code>.
Note that this variance estimator implicitly utilises the Hajek (1964) approximations that are designed for large-entropy sampling designs, large samples, and large populations, i.e., care should be taken with highly-stratified samples, e.g. Berger (2005).
</p>


<h3>Value</h3>

<p>The function returns a value for the estimated variance.
</p>


<h3>Author(s)</h3>

<p>Emilio Lopez Escobar.</p>


<h3>References</h3>

<p>Berger, Y. G. (2005) Variance estimation with highly stratified sampling designs with unequal probabilities. <em>Australian &amp; New Zealand Journal of Statistics</em>, <b>47</b>, 365–373.
</p>
<p>Escobar, E. L. and Berger, Y. G. (2013) A jackknife variance estimator for self-weighted two-stage samples. <em>Statistica Sinica</em>, <b>23</b>, 595–613.
</p>
<p>Hajek, J. (1964) Asymptotic theory of rejective sampling with varying probabilities from a finite population. <em>The Annals of Mathematical Statistics</em>, <b>35</b>, 4, 1491–1523.
</p>
<p>Hajek, J. (1971) Comment on <em>An essay on the logical foundations of survey sampling</em> by Basu, D. in <em>Foundations of Statistical Inference</em> (Godambe, V.P. and Sprott, D.A. eds.), p. 236. Holt, Rinehart and Winston.
</p>


<h3>See Also</h3>

<p><code>VE.Jk.Tukey.Total.Hajek</code><br><code>VE.Jk.CBS.HT.Total.Hajek</code><br><code>VE.Jk.CBS.SYG.Total.Hajek</code><br><code>VE.Jk.B.Total.Hajek</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(oaxaca)                          #Loads the Oaxaca municipalities dataset
s         &lt;- oaxaca$sSW_10_3          #Defines the sample to be used
N         &lt;- dim(oaxaca)[1]           #Defines the population size
SampData  &lt;- oaxaca[s==1, ]           #Defines the sample dataset
nII       &lt;- 3                        #Defines the 2nd stage fixed sample size
CluLab.s  &lt;- SampData$IDDISTRI        #Defines the clusters' labels
CluSize.s &lt;- SampData$SIZEDIST        #Defines the clusters' sizes
piIi.s    &lt;- (10 * CluSize.s / 570)   #Reconstructs clusters' 1st order incl. probs.
pik.s     &lt;- piIi.s * (nII/CluSize.s) #Reconstructs elements' 1st order incl. probs.
y1.s      &lt;- SampData$POP10           #Defines the variable of interest y1
y2.s      &lt;- SampData$POPMAL10        #Defines the variable of interest y2
#Computes the var. est. of the Hajek total point estimator using y1
VE.Jk.EB.SW2.Total.Hajek(y1.s, pik.s, nII, piIi.s, CluLab.s, CluSize.s, N)
#Computes the var. est. of the Hajek total point estimator using y2
VE.Jk.EB.SW2.Total.Hajek(y2.s, pik.s, nII, piIi.s, CluLab.s, CluSize.s, N)
</code></pre>


</div>