<div class="container">

<table style="width: 100%;"><tr>
<td>xTAx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Common quadratic forms</h2>

<h3>Description</h3>

<p>Common quadratic forms
</p>


<h3>Usage</h3>

<pre><code class="language-R">xTAx(x, A)

xAxT(x, A)

xTAx_solve(x, A, ...)

xTAx_qrsolve(x, A, tol = 1e-07, ...)

sandwich_solve(A, B, ...)

xTAx_eigen(x, A, tol = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a square matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to subroutines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance argument passed to the relevant subroutine</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a square matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These are somewhat inspired by emulator::quad.form.inv()
and others.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>xTAx()</code>: Evaluate <code class="reqn">x'Ax</code> for vector <code class="reqn">x</code> and square
matrix <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>xAxT()</code>: Evaluate <code class="reqn">xAx'</code> for vector <code class="reqn">x</code> and square
matrix <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>xTAx_solve()</code>: Evaluate <code class="reqn">x'A^{-1}x</code> for vector <code class="reqn">x</code> and
invertible matrix <code class="reqn">A</code> using <code>solve()</code>.
</p>
</li>
<li> <p><code>xTAx_qrsolve()</code>: Evaluate <code class="reqn">x'A^{-1}x</code> for vector <code class="reqn">x</code> and
matrix <code class="reqn">A</code> using QR decomposition and confirming that <code class="reqn">x</code>
is in the span of <code class="reqn">A</code> if <code class="reqn">A</code> is singular; returns <code>rank</code>
and <code>nullity</code> as attributes just in case subsequent calculations
(e.g., hypothesis test degrees of freedom) are affected.
</p>
</li>
<li> <p><code>sandwich_solve()</code>: Evaluate <code class="reqn">A^{-1}B(A')^{-1}</code> for <code class="reqn">B</code> a
square matrix and <code class="reqn">A</code> invertible.
</p>
</li>
<li> <p><code>xTAx_eigen()</code>: Evaluate <code class="reqn">x' A^{-1} x</code> for vector <code class="reqn">x</code> and
matrix <code class="reqn">A</code> (symmetric, nonnegative-definite) via
eigendecomposition; returns <code>rank</code> and <code>nullity</code> as attributes
just in case subsequent calculations (e.g., hypothesis test
degrees of freedom) are affected.
</p>
<p>Decompose <code class="reqn">A = P L P'</code> for <code class="reqn">L</code> diagonal matrix of
eigenvalues and <code class="reqn">P</code> orthogonal. Then <code class="reqn">A^{-1} = P L^{-1}
  P'</code>.
</p>
<p>Substituting, </p>
<p style="text-align: center;"><code class="reqn">x' A^{-1} x = x' P L^{-1} P' x
  = h' L^{-1} h</code>
</p>
<p> for <code class="reqn">h = P' x</code>.
</p>
</li>
</ul>
</div>