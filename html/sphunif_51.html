<div class="container">

<table style="width: 100%;"><tr>
<td>locdev</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local projected alternatives to uniformity</h2>

<h3>Description</h3>

<p>Density and random generation for local projected alternatives
to uniformity with densities
</p>
<p style="text-align: center;"><code class="reqn">f_{\kappa, \boldsymbol{\mu}}({\bf x}): =
\frac{1 - \kappa}{\omega_p} + \kappa f({\bf x}'\boldsymbol{\mu})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">f(z) = \frac{1}{\omega_p}\left\{1 + \sum_{k = 1}^\infty u_{k, p}
C_k^{p / 2 - 1}(z)\right\}</code>
</p>

<p>is the <em>angular function</em> controlling the local alternative in a
Gegenbauer series, <code class="reqn">0\le \kappa \le 1</code>,
<code class="reqn">\boldsymbol{\mu}</code> is a direction on <code class="reqn">S^{p - 1}</code>, and
<code class="reqn">\omega_p</code> is the surface area of <code class="reqn">S^{p - 1}</code>. The sequence
<code class="reqn">\{u_{k, p}\}</code> is typically such that
<code class="reqn">u_{k, p} = \left(1 + \frac{2k}{p - 2}\right) b_{k, p}</code> for the Gegenbauer coefficients
<code class="reqn">\{b_{k, p}\}</code> of the kernel function of a Sobolev statistic (see the
transformation between the coefficients <code class="reqn">u_{k, p}</code>
and <code class="reqn">b_{k, p}</code>).
</p>
<p>Also, automatic truncation of the series <code class="reqn">\sum_{k = 1}^\infty u_{k, p}
C_k^{p / 2 - 1}(z)</code>
according to the proportion of "Gegenbauer norm"
explained.
</p>


<h3>Usage</h3>

<pre><code class="language-R">f_locdev(z, p, uk)

con_f(f, p, N = 320)

d_locdev(x, mu, f, kappa)

r_locdev(n, mu, f, kappa, F_inv = NULL, ...)

cutoff_locdev(p, K_max = 10000, thre = 0.001, type, Rothman_t = 1/3,
  Pycke_q = 0.5, verbose = FALSE, Gauss = TRUE, N = 320, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>projected evaluation points for <code class="reqn">f</code>, a vector with entries on
<code class="reqn">[-1, 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uk</code></td>
<td>
<p>coefficients <code class="reqn">u_{k, p}</code> associated to the indexes
<code>1:length(uk)</code>, a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>angular function defined on <code class="reqn">[-1, 1]</code>. Must be vectorized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of points used in the 
Gauss–Legendre quadrature for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of rotational
symmetry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>the strength of the local alternative, between <code>0</code>
and <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F_inv</code></td>
<td>
<p>quantile function associated to <code class="reqn">f</code>. Computed by
<code>F_inv_from_f</code> if <code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters passed to <code>F_inv_from_f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_max</code></td>
<td>
<p>integer giving the truncation of the series. Defaults to
<code>1e4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thre</code></td>
<td>
<p>proportion of norm <em>not</em> explained by the first terms of the
truncated series. Defaults to <code>1e-3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>name of the Sobolev statistic, using the naming from
<code>avail_cir_tests</code> and <code>avail_sph_tests</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke "<code class="reqn">q</code>-test", a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>output information about the truncation (<code>TRUE</code> or
<code>1</code>) and a diagnostic plot (<code>2</code>)? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gauss</code></td>
<td>
<p>use a Gauss–Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code>integrate</code>. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance passed to <code>integrate</code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the definitions of local alternatives in Prentice (1978) and in
García-Portugués et al. (2023).
</p>
<p>The truncation of <code class="reqn">\sum_{k = 1}^\infty u_{k, p} C_k^{p / 2 - 1}(z)</code> is done to the first
<code>K_max</code> terms and then up to the index such that the first terms
leave unexplained the proportion <code>thre</code> of the norm of the whole series.
Setting <code>thre = 0</code> truncates to <code>K_max</code> terms exactly. If the
series only contains odd or even non-zero terms, then only <code>K_max / 2</code>
addends are <em>effectively</em> taken into account in the first truncation.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>f_locdev</code>: angular function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>con_f</code>: normalizing constant <code class="reqn">c_f</code> of <code class="reqn">f</code>, a scalar.
</p>
</li>
<li> <p><code>d_locdev</code>: density function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>r_locdev</code>: a matrix of size <code>c(n, p)</code> containing a random
sample from the density <code class="reqn">f_{\kappa, \boldsymbol{\mu}}</code>.
</p>
</li>
<li> <p><code>cutoff_locdev</code>: vector of coefficients <code class="reqn">\{u_{k, p}\}</code>
automatically truncated according to <code>K_max</code> and <code>thre</code>
(see details).
</p>
</li>
</ul>
<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181–204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>
<p>Prentice, M. J. (1978). On invariant tests of uniformity for directions and
orientations. <em>The Annals of Statistics</em>, 6(1):169–176.
<a href="https://doi.org/10.1214/aos/1176344075">doi:10.1214/aos/1176344075</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Local alternatives diagnostics

loc_alt_diagnostic  &lt;- function(p, type, thre = 1e-3, K_max = 1e3) {

  # Coefficients of the alternative
  uk &lt;- cutoff_locdev(K_max = K_max, p = p, type = type, thre = thre,
                      N = 640)

  old_par &lt;- par(mfrow = c(2, 2))

  # Construction of f
  z &lt;- seq(-1, 1, l = 1e3)
  f &lt;- function(z) f_locdev(z = z, p = p, uk = uk)
  plot(z, f(z), type = "l", xlab = expression(z), ylab = expression(f(z)),
       main = paste0("Local alternative f, ", type, ", p = ", p), log = "y")

  # Projected density on [-1, 1]
  f_proj &lt;- function(z) rotasym::w_p(p = p - 1) * f(z) *
    (1 - z^2)^((p - 3) / 2)
  plot(z, f_proj(z), type = "l", xlab = expression(z),
       ylab = expression(omega[p - 1] * f(z) * (1 - z^2)^{(p - 3) / 2}),
       main = paste0("Projected density, ", type, ", p = ", p), log = "y",
       sub = paste("Integral:", round(con_f(f = f, p = p), 4)))

  # Quantile function for projected density
  mu &lt;- c(rep(0, p - 1), 1)
  F_inv &lt;- F_inv_from_f(f = f, p = p, K = 5e2)
  plot(F_inv, xlab = expression(x), ylab = expression(F^{-1}*(x)),
       main = paste0("Quantile function, ", type, ", p = ", p))

  # Sample from the alternative and plot the projected sample
  n &lt;- 5e4
  samp &lt;- r_locdev(n = n, mu = mu, f = f, kappa = 1, F_inv = F_inv)
  plot(z, f_proj(z), col = 2, type = "l",
       main = paste0("Simulated projected data, ", type, ", p = ", p),
       ylim = c(0, 1.75))
  hist(samp %*% mu, freq = FALSE, breaks = seq(-1, 1, l = 50), add = TRUE)

  par(old_par)

}

## Local alternatives for the PCvM test

loc_alt_diagnostic(p = 2, type = "PCvM")
loc_alt_diagnostic(p = 3, type = "PCvM")
loc_alt_diagnostic(p = 4, type = "PCvM")
loc_alt_diagnostic(p = 5, type = "PCvM")
loc_alt_diagnostic(p = 11, type = "PCvM")

## Local alternatives for the PAD test

loc_alt_diagnostic(p = 2, type = "PAD")
loc_alt_diagnostic(p = 3, type = "PAD")
loc_alt_diagnostic(p = 4, type = "PAD")
loc_alt_diagnostic(p = 5, type = "PAD")
loc_alt_diagnostic(p = 11, type = "PAD")

## Local alternatives for the PRt test

loc_alt_diagnostic(p = 2, type = "PRt")
loc_alt_diagnostic(p = 3, type = "PRt")
loc_alt_diagnostic(p = 4, type = "PRt")
loc_alt_diagnostic(p = 5, type = "PRt")
loc_alt_diagnostic(p = 11, type = "PRt")

</code></pre>


</div>