<div class="container">

<table style="width: 100%;"><tr>
<td>string_is</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Detects whether a pattern is in a character string</h2>

<h3>Description</h3>

<p>Function that detects if one or more patterns are in a string. The patterns can be
chained, by default this is a regex search but special flags be triggered with a
specific syntax, supports negation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_is(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame(),
  last = NULL
)

string_any(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

string_all(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

string_which(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

st_is(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame(),
  last = NULL
)

st_any(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

st_all(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

stwhich(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Character scalars representing the patterns to be found. By default they are (perl) regular-expressions.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with "".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>or</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. In the presence of two or more patterns,
whether to combine them with a logical "or" (the default is to combine them with a logical "and").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>(If provided, elements of <code>...</code> are ignored.) A character vector representing the
patterns to be found. By default a (perl) regular-expression search is triggered.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: "ignore/sepal" would get "Sepal.Length" (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: "if/dt[" would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with "".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>last</code></td>
<td>
<p>A function or <code>NULL</code> (default). If a function, it will be applied to the vector
just before returning it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The internal function used to find the patterns is <code>base::grepl()</code> with <code>perl = TRUE</code>.
</p>


<h3>Value</h3>

<p>It returns a logical vector of the same length as <code>x</code>.
</p>
<p>The function <code>string_which</code> returns a numeric vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_any()</code>: Detects if at least one element of a vector matches a regex pattern
</p>
</li>
<li> <p><code>string_all()</code>: Detects if all elements of a vector match a regex pattern
</p>
</li>
<li> <p><code>string_which()</code>: Returns the indexes of the values in which a pattern is detected
</p>
</li>
<li> <p><code>st_is()</code>: Alias to <code>string_is</code>
</p>
</li>
<li> <p><code>st_any()</code>: Alias to <code>string_any</code>
</p>
</li>
<li> <p><code>st_all()</code>: Alias to <code>string_all</code>
</p>
</li>
<li> <p><code>stwhich()</code>: Alias to <code>string_which</code>
</p>
</li>
</ul>
<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant <em>"any character"</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".
</p>
<p>The four flags always available are: "ignore", "fixed", "word" and "magic".
</p>

<ul>
<li>
<p> "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)"
at the beginning of the pattern.
</p>
</li>
<li>
<p> "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li>
<p> "word" adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, "word/one, two" is treated as "\b(one|two)\b". Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to " I ambushed?" thanks to the flags "ignore" and "word".
</p>
</li>
<li>
<p> "magic" allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code>string_is()</code>, <code>string_get()</code>, <code>string_clean()</code>, <code>string_split2df()</code>.
Chain basic operations with <code>string_ops()</code>. Clean character vectors efficiently
with <code>string_clean()</code>.
</p>
<p>Use <code>string_vec()</code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code>string_magic()</code>. You can change <code>string_magic</code>
default values with <code>string_magic_alias()</code> and add custom operations with <code>string_magic_register_fun()</code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code>cat_magic()</code> and <code>message_magic()</code>.
</p>
<p>Other tools with aliases: 
<code>cat_magic_alias()</code>,
<code>string_magic()</code>,
<code>string_magic_alias()</code>,
<code>string_ops_alias()</code>,
<code>string_vec_alias()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# NOTA: using `string_get` instead of `string_is` may lead to a faster understanding 
#       of the examples 

x = string_vec("One, two, one... two, microphone, check")

# default is regular expression search
# =&gt; 3 character items
string_is(x, "^...$")

# to trigger fixed search use the flag 'fixed'
string_is(x, "fixed/...")
# you can just use the first letter
string_is(x, "f/...")

# to negate, use '!' as the first element of the pattern
string_is(x, "f/!...")

# you can combine several patterns with " &amp; " or " | "
string_is(x, "one &amp; c")
string_is(x, "one | c")

#
# word: adds word boundaries
#

# compare
string_is(x, "one")
# with
string_is(x, "w/one")

# words can be chained with commas (it is like an OR logical operation)
string_is(x, "w/one, two")
# compare with
string_is(x, "w/one &amp; two")
# remember that you can still negate
string_is(x, "w/one &amp; !two")

# you can combine the flags
# compare
string_is(x, "w/one")
# with
string_is(x, "wi/one")

#
# the `magic` flag
#

p = "one"
string_is(x, "m/{p}")
# Explanation:
# - "p" is interpolated into "one"
# - we get the equivalent: string_is(x, "one")


#
# string_which
#

# it works exactly the same way as string_is
# Which are the items containing an 'e' and an 'o'?
string_which(x, "e", "o")
# equivalently
string_which(x, "e &amp; o")


</code></pre>


</div>