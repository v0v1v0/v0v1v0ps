<div class="container">

<table style="width: 100%;"><tr>
<td>get_stacking_weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal stacking weights</h2>

<h3>Description</h3>

<p>Obtains optimal stacking weights given leave-one-out predictive densities for
each candidate model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_stacking_weights(log_loopd, solver = "ECOS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>log_loopd</code></td>
<td>
<p>an <code class="reqn">n \times M</code> matrix with <code class="reqn">i</code>-th row
containing the leave-one-out predictive densities for the <code class="reqn">i</code>-th
data point for the <code class="reqn">M</code> candidate models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>specifies the solver to use for obtaining optimal weights.
Default is <code>"ECOS"</code>. Internally calls
<code>CVXR::psolve()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of length 2.
</p>

<dl>
<dt><code>weights</code></dt>
<dd>
<p>optimal stacking weights as a numeric vector of
length <code class="reqn">M</code></p>
</dd>
<dt><code>status</code></dt>
<dd>
<p>solver status, returns <code>"optimal"</code> if solver
succeeded.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Yao Y, Vehtari A, Simpson D, Gelman A (2018). "Using Stacking to
Average Bayesian Predictive Distributions (with Discussion)." <em>Bayesian
Analysis</em>, <strong>13</strong>(3), 917-1007. <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>


<h3>See Also</h3>

<p><code>CVXR::psolve()</code>, <code>spLMstack()</code>, <code>spGLMstack()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(simGaussian)
dat &lt;- simGaussian[1:100, ]

mod1 &lt;- spLMstack(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  params.list = list(phi = c(1.5, 3),
                                     nu = c(0.5, 1),
                                     noise_sp_ratio = c(1)),
                  n.samples = 1000, loopd.method = "exact",
                  parallel = FALSE, solver = "ECOS", verbose = TRUE)

loopd_mat &lt;- do.call('cbind', mod1$loopd)
w_hat &lt;- get_stacking_weights(loopd_mat)
print(round(w_hat$weights, 4))
print(w_hat$status)
</code></pre>


</div>