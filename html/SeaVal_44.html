<div class="container">

<table style="width: 100%;"><tr>
<td>ggplot_dt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>plotting function for spatial data</h2>

<h3>Description</h3>

<p>Plots spatial data from a data.table. The data table needs to contain columns named 'lon' and 'lat'. The grid needs to be regular.
If spatial data is contained for several levels (e.g. mutliple times or multiple ensemble members), only the data for the first level is plotted.
By default, the first column that is not recognized as a dimension variable is plotted, see <code>data_col</code>. For the most common data-columns, reasonable
color scales are selected automatically.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ggplot_dt(
  dt,
  data_col = NULL,
  mn = NULL,
  discrete_cs = FALSE,
  rr = NULL,
  low = NULL,
  mid = NULL,
  high = NULL,
  name = data_col,
  midpoint = NULL,
  breaks = NULL,
  na.value = "gray75",
  oob = NULL,
  guide = guide_colorbar(barwidth = 0.5, barheight = 10),
  ...,
  binwidth = NULL,
  bin_midpoint = midpoint,
  add_map = TRUE,
  extent = NULL,
  expand.x = c(0, 0),
  expand.y = c(0, 0),
  dimension_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>Data table containing the data for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_col</code></td>
<td>
<p>The name of the column in dt containing the data for plotting. If nothing is provided (the default), the first column that is not a dimension variable or 'member' is selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mn</code></td>
<td>
<p>optional plot title</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete_cs</code></td>
<td>
<p>Logical. Should the color scale be discretized?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rr, low, mid, high, name, breaks, na.value, oob, guide, ...</code></td>
<td>
<p>Arguments for the color scale, passed to scale_fill_gradient2 or scale_fill_steps2 (depending on whether discrete_cs == TRUE).
rr replaces limits (specifying the range of the color scale) for consistency with the older plotting functions from the PostProcessing package.
<code>na.value</code> specifies the color of missing values. <code>oob</code> specifies the treatment of out-of-boundary values, i.e. values beyond the
limits.
The ... argument can in particular be used to customize the legend/colorbar using the function <code>guide_colorbar</code>,
see https://ggplot2.tidyverse.org/reference/guide_colourbar.html. Moreover, when <code>discrete_cs == TRUE</code> you can pass the arguments <code>n.breaks,breaks</code> to customize the scale.
If you use n.breaks you might also want to set nice.breaks = FALSE, see ?scale_fill_steps2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>midpoint</code></td>
<td>
<p>midpoint of the color scale, passed to <code>scale_fill_gradient2</code> or <code>scale_fill_steps2</code> (depending on whether <code>discrete_cs == TRUE</code>).
If you set it to NULL (the default), the midpoint is set to the center of the data range (or the center of rr, if provided), such that the entire color scale is used.
Note that this default differs from the default behavior of <code>scale_fill_gradient2</code> or <code>scale_fill_steps2</code>.
Specifying the midpoint can often be a convenient way to force a color scale with only two colors (for example, by setting it
to the minimum or maximum of your data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binwidth, bin_midpoint</code></td>
<td>
<p>only used when <code>discrete_cs == TRUE</code>. Normally, the breaks for the discrete colorscale are specified by n.breaks (which is not reliable,
since they're adjusted to be 'nice'), or by specifying the breaks explicitly (which is often tedious). This gives you a third option, namely specifying how far the breaks
should be apart, and specifying the centerpoint for one of the bins (default is midpoint, or the center of rr if midpoint is not provided). For example, if your color scale shows
percentages and you'd like 4 categories, ranging from white to red, this is easiest achieved by <code>binwidth = 25, midpoint = 12.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_map</code></td>
<td>
<p>logical, defaults to <code>TRUE</code>, mostly for internal use. Set to <code>FALSE</code> to remove borders (e.g. if you want to add them yourself from a shapefile).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extent</code></td>
<td>
<p>An optional four-element vector in the order xmin,xmax,ymin,ymax for specifying the spatial extent of the plot. Default is to fit the extent to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand.x, expand.y</code></td>
<td>
<p>vectors with two entries to be added to xlims/ylims of the plot. E.g. expand.x = c(-0.5,0.5)
expands the plot by half a longitude both on the right and left hand side</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimension_check</code></td>
<td>
<p>Logical. By default the function checks that there are not multiple values per coordinate
(and subsets to the first level if there are several, e.g. to the first year and month (by appearance in <code>dt</code>) if <code>dt</code> contains data for several years and months).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>Author(s)</h3>

<p>Claudio Heinrich
</p>


<h3>Examples</h3>

<pre><code class="language-R">ex_dt = chirps_monthly[lat &lt;0 &amp; month == 12 &amp; year == 2020]
pp = ggplot_dt(ex_dt)
if(interactive()) plot(pp)

</code></pre>


</div>