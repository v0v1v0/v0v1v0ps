<div class="container">

<table style="width: 100%;"><tr>
<td>discretize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rasterize Area Search or Transect Data</h2>

<h3>Description</h3>

<p>It is sometimes useful to re-cast area-search (polygon or polygonX) data as if it was from a
set of closely spaced point detectors, i.e. to rasterize the detection locations. This function makes that conversion. Each polygon detector in the input is replaced by a number of point detectors, each representing a square pixel. Detections are mapped to the new detectors on the basis of their x-y coordinates.
</p>
<p>If <code>object</code> contains transect data the problem is passed to <code>snip</code> and <code>reduce.capthist</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
discretize(object, spacing = 5, outputdetector = c("proximity", "count", "multi"), 
    tol = 0.001, cell.overlap = FALSE, type = c("centre","any", "all"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>secr capthist or traps object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacing</code></td>
<td>
<p>numeric spacing between point detectors in metres </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputdetector</code></td>
<td>
<p>character output detector type</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>numeric fractional inflation of perimeter (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.overlap</code></td>
<td>
<p>logical; if TRUE the area of overlap is stored in usage attribute </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>snip</code> if object is transect</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input should have detector type ‘polygon’ or ‘polygonX’.
</p>
<p>A new array of equally spaced detectors is generated within
each polygon of the input, inflated radially by 1 + tol to avoid some
inclusion problems. The origin of the superimposed grid is fixed automatically. If <code>type = "centre"</code> detectors are included if they lie within the (inflated) polygon. Otherwise, the decision on whether to include a candidate new detector is based on the corner vertices of the cell around the detector (side = <code>spacing</code>); <code>type = "any"</code> and  <code>type = "all"</code> have the obvious meanings. 
</p>
<p><code>tol</code> may be negative, in which case the array(s) will be shrunk relative
to the polygon(s). 
</p>
<p>For irregular polygons the edge cells in the output may be only partially contained within the polygon they represent. Set <code>cell.overlap = TRUE</code> to retain the proportion of overlap as the ‘usage’ of the new traps object. This can take a few seconds to compute. If ‘usage’ is already defined then the new ‘usage’ is the old multiplied by the proportion of overlap.
</p>
<p>Combining <code>type = "any"</code> and <code>cell.overlap = TRUE</code> with <code>tol</code> &gt; 0 can have the odd effect of including some marginal detectors that are assigned zero usage.
</p>
<p>With <code>type = "any"</code>, the sum of the overlap proportions times cell area is equal to the area of the polygons.
</p>


<h3>Value</h3>

<p>A capthist or traps object of the requested detector type, but otherwise
carrying forward all attributes of the input. The embedded traps object has a 
factor covariate ‘polyID’ recording the polygon to which each point detector relates.
</p>


<h3>Note</h3>

<p>Consider the likely number of detectors in the output before you start. 
</p>


<h3>See Also</h3>

<p><code>reduce.capthist</code>, <code>snip</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

## generate some polygon data
pol &lt;- make.poly()
CH &lt;- sim.capthist(pol, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(CH, border = 10, gridl = FALSE, varycol = FALSE)

## discretize and plot
CH1 &lt;- discretize(CH, spacing = 10, output = 'count')
plot(CH1, add = TRUE, cappar = list(col = 'orange'), varycol =
    FALSE, rad = 0)
plot(traps(CH1), add = TRUE)
# overlay cell boundaries
plot(as.mask(traps(CH1)), dots = FALSE, col = NA, meshcol = 'green', 
    add = TRUE)

## show how detections are snapped to new detectors
newxy &lt;- traps(CH1)[nearesttrap(xy(CH),traps(CH1)),]
segments(xy(CH)[,1], xy(CH)[,2], newxy[,1], newxy[,2])

plot(traps(CH), add = TRUE)  # original polygon

## Incomplete overlap

pol &lt;- rotate(make.poly(), 45)
CH2 &lt;- sim.capthist(pol, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(CH2, border = 10, gridl = FALSE, varycol = FALSE)
CH3 &lt;- discretize(CH2, spacing = 10, output = 'count', type = 'any', 
    cell.overlap = TRUE, tol=0.05)
    
plot(CH3, add = TRUE, cappar = list(col = 'orange'), varycol =
    FALSE, rad = 0)
plot(traps(CH3), add = TRUE)

# overlay cell boundaries and usage
msk &lt;- as.mask(traps(CH3))
covariates(msk) &lt;- data.frame(usage = usage(traps(CH3))[,1])
plot(msk, dots = FALSE, cov='usage', meshcol = 'green', 
    add = TRUE)
    

## End(Not run)

</code></pre>


</div>