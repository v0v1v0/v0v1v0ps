<div class="container">

<table style="width: 100%;"><tr>
<td>sim_n_datasets</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate multiple datasets from a single <code>DAG</code> object
</h2>

<h3>Description</h3>

<p>This function takes a single <code>DAG</code> object and generates a list of multiple datasets, possible using parallel processing
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_n_datasets(dag, n_sim, n_repeats, n_cores=parallel::detectCores(),
               data_format="raw", data_format_args=list(),
               seed=stats::runif(1), progressbar=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dag</code></td>
<td>

<p>A <code>DAG</code> object created using the <code>empty_dag</code> function with nodes added to it using the <code>+</code> syntax. See <code>?empty_dag</code> or <code>?node</code> for more details. If the <code>dag</code> contains time-varying nodes added using the <code>node_td</code> function, the <code>sim_discrete_time</code> function will be used to generate the data. Otherwise, the <code>sim_from_dag</code> function will be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sim</code></td>
<td>

<p>A single number specifying how many observations per dataset should be generated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_repeats</code></td>
<td>

<p>A single number specifying how many datasets should be generated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>

<p>A single number specifying the amount of cores that should be used. If <code>n_cores = 1</code>, a simple for loop is used to generate the datasets with no parallel processing. If <code>n_cores &gt; 1</code> is used, the <span class="pkg">doSNOW</span> package is used in conjunction with the <span class="pkg">doRNG</span> package to generate the datasets in parallel. By using the <span class="pkg">doRNG</span> package, the results are completely reproducible by setting a <code>seed</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_format</code></td>
<td>

<p>An optional character string specifying the output format of the generated datasets. If <code>"raw"</code> (default), the dataset will be returned as generated by the respective data generation function. If the <code>dag</code> contains time-varying nodes added using the <code>node_td</code> function and this argument is set to either <code>"start_stop"</code>, <code>"long"</code> or <code>"wide"</code>, the <code>sim2data</code> function will be called to transform the dataset into the defined format. If any other string is supplied, regardless of whether time-varying nodes are included in the <code>dag</code> or not, the function with the name given in the string is called to transform the data. This can be any function. The only requirement is that it has a named argument called <code>data</code>. Arguments to the function can be set using the <code>data_format_args</code> argument (see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_format_args</code></td>
<td>

<p>An optional list of named arguments passed to the function specified by <code>data_format</code>. Set to <code>list()</code> to use no arguments. Ignored if <code>data_format="raw"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>A seed for the random number generator. By supplying a value to this argument, the results will be replicable, even if parallel processing is used to generate the datasets (using <code>n_cores &gt; 1</code>), thanks to the magic performed by the <span class="pkg">doRNG</span> package.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressbar</code></td>
<td>

<p>Either <code>TRUE</code> (default) or <code>FALSE</code>, specifying whether a progressbar should be used. Currently only works if <code>n_cores &gt; 1</code>, ignored otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to the <code>sim_from_dag</code> function (if the <code>dag</code> does not contain time-varying nodes) or the <code>sim_discrete_time</code> function (if the <code>dag</code> contains time-varying nodes).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Generating a number of datasets from a single defined <code>dag</code> object is usually the first step when conducting monte-carlo simulation studies. This is simply a convenience function which automates this process using parallel processing (if specified).
</p>
<p>Note that for more complex monte-carlo simulations this function may not be ideal, because it does not allow the user to vary aspects of the data-generation mechanism inside the main for loop, because it can only handle a single <code>dag</code>. For example, if the user wants to simulate <code>n_repeats</code> datasets with confounding and <code>n_repeats</code> datasets without confounding, he/she has to call this function twice. This is not optimal, because setting up the clusters for parallel processing takes some processing time. If many different <code>dag</code>s should be used, it would make more sense to write a single function that generates the <code>dag</code> itself for each of the desired settings. This can sadly not be automated by us though.
</p>


<h3>Value</h3>

<p>Returns a list of length <code>n_repeats</code> containing datasets generated according to the supplied <code>dag</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code>empty_dag</code>, <code>node</code>, <code>node_td</code>, <code>sim_from_dag</code>, <code>sim_discrete_time</code>, <code>sim2data</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(simDAG)

# some example DAG
dag &lt;- empty_dag() +
  node("death", type="binomial", parents=c("age", "sex"), betas=c(1, 2),
       intercept=-10) +
  node("age", type="rnorm", mean=10, sd=2) +
  node("sex", parents="", type="rbernoulli", p=0.5) +
  node("smoking", parents=c("sex", "age"), type="binomial",
       betas=c(0.6, 0.2), intercept=-2)

# generate 10 datasets without parallel processing
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100)

if (requireNamespace("doSNOW") &amp; requireNamespace("doRNG") &amp;
    requireNamespace("foreach")) {

# generate 10 datasets with parallel processing
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=2, n_sim=100)
}

# generate 10 datasets and transforming the output
# (using the sim2data function internally)
dag &lt;- dag + node_td("CV", type="time_to_event", prob_fun=0.01)
out &lt;- sim_n_datasets(dag, n_repeats=10, n_cores=1, n_sim=100,
                      max_t=20, data_format="start_stop")
</code></pre>


</div>