<div class="container">

<table style="width: 100%;"><tr>
<td>make_gen_boot_factors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates replicate factors for the generalized survey bootstrap</h2>

<h3>Description</h3>

<p>Creates replicate factors for the generalized survey bootstrap method.
The generalized survey bootstrap is a method for forming bootstrap replicate weights
from a textbook variance estimator, provided that the variance estimator
can be represented as a quadratic form whose matrix is positive semidefinite
(this covers a large class of variance estimators).
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_gen_boot_factors(Sigma, num_replicates, tau = "auto", exact_vcov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>The matrix of the quadratic form used to represent the variance estimator.
Must be positive semidefinite.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_replicates</code></td>
<td>
<p>The number of bootstrap replicates to create.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Either <code>"auto"</code>, or a single number. This is the rescaling constant
used to avoid negative weights through the transformation <code class="reqn">\frac{w + \tau - 1}{\tau}</code>,
where <code class="reqn">w</code> is the original weight and <code class="reqn">\tau</code> is the rescaling constant <code>tau</code>. <br>
If <code>tau="auto"</code>, the rescaling factor is determined automatically as follows:
if all of the adjustment factors are nonnegative, then <code>tau</code> is set equal to 1;
otherwise, <code>tau</code> is set to the smallest value needed to rescale
the adjustment factors such that they are all at least <code>0.01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact_vcov</code></td>
<td>
<p>If <code>exact_vcov=TRUE</code>, the replicate factors will be generated
such that their variance-covariance matrix exactly matches the target variance estimator's
quadratic form (within numeric precision).
This is desirable as it causes variance estimates for totals to closely match
the values from the target variance estimator.
This requires that <code>num_replicates</code> exceeds the rank of <code>Sigma</code>.
The replicate factors are generated by applying PCA-whitening to a collection of draws
from a multivariate Normal distribution, then applying a coloring transformation
to the whitened collection of draws.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix with the same number of rows as <code>Sigma</code>, and the number of columns
equal to <code>num_replicates</code>. The object has an attribute named <code>tau</code> which can be retrieved
by calling <code>attr(which = 'tau')</code> on the object. The value <code>tau</code> is a rescaling factor
which was used to avoid negative weights.
</p>
<p>In addition, the object has attributes named <code>scale</code> and <code>rscales</code> which can be
passed directly to svrepdesign. Note that the value of <code>scale</code> is <code class="reqn">\tau^2/B</code>,
while the value of <code>rscales</code> is vector of length <code class="reqn">B</code>, with every entry equal to <code class="reqn">1</code>.
</p>


<h3>Statistical Details</h3>

<p>Let <code class="reqn">v( \hat{T_y})</code> be the textbook variance estimator for an estimated population total <code class="reqn">\hat{T}_y</code> of some variable <code class="reqn">y</code>.
The base weight for case <code class="reqn">i</code> in our sample is <code class="reqn">w_i</code>, and we let <code class="reqn">\breve{y}_i</code> denote the weighted value <code class="reqn">w_iy_i</code>.
Suppose we can represent our textbook variance estimator as a quadratic form: <code class="reqn">v(\hat{T}_y) = \breve{y}\Sigma\breve{y}^T</code>,
for some <code class="reqn">n \times n</code> matrix <code class="reqn">\Sigma</code>.
The only constraint on <code class="reqn">\Sigma</code> is that, for our sample, it must be symmetric and positive semidefinite.
</p>
<p>The bootstrapping process creates <code class="reqn">B</code> sets of replicate weights, where the <code class="reqn">b</code>-th set of replicate weights is a vector of length <code class="reqn">n</code> denoted <code class="reqn">\mathbf{a}^{(b)}</code>, whose <code class="reqn">k</code>-th value is denoted <code class="reqn">a_k^{(b)}</code>.
This yields <code class="reqn">B</code> replicate estimates of the population total, <code class="reqn">\hat{T}_y^{*(b)}=\sum_{k \in s} a_k^{(b)} \breve{y}_k</code>, for <code class="reqn">b=1, \ldots B</code>, which can be used to estimate sampling variance.
</p>
<p style="text-align: center;"><code class="reqn">
  v_B\left(\hat{T}_y\right)=\frac{\sum_{b=1}^B\left(\hat{T}_y^{*(b)}-\hat{T}_y\right)^2}{B}
</code>
</p>

<p>This bootstrap variance estimator can be written as a quadratic form:
</p>
<p style="text-align: center;"><code class="reqn">
    v_B\left(\hat{T}_y\right) =\mathbf{\breve{y}}^{\prime}\Sigma_B \mathbf{\breve{y}}
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\Sigma}_B = \frac{\sum_{b=1}^B\left(\mathbf{a}^{(b)}-\mathbf{1}_n\right)\left(\mathbf{a}^{(b)}-\mathbf{1}_n\right)^{\prime}}{B}
  </code>
</p>

<p>Note that if the vector of adjustment factors <code class="reqn">\mathbf{a}^{(b)}</code> has expectation <code class="reqn">\mathbf{1}_n</code> and variance-covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>,
then we have the bootstrap expectation <code class="reqn">E_{*}\left( \boldsymbol{\Sigma}_B \right) = \boldsymbol{\Sigma}</code>. Since the bootstrap process takes the sample values <code class="reqn">\breve{y}</code> as fixed, the bootstrap expectation of the variance estimator is <code class="reqn">E_{*} \left( \mathbf{\breve{y}}^{\prime}\Sigma_B \mathbf{\breve{y}}\right)= \mathbf{\breve{y}}^{\prime}\Sigma \mathbf{\breve{y}}</code>.
Thus, we can produce a bootstrap variance estimator with the same expectation as the textbook variance estimator simply by randomly generating <code class="reqn">\mathbf{a}^{(b)}</code> from a distribution with the following two conditions:
<br><br><strong>Condition 1</strong>: <code class="reqn">\quad \mathbf{E}_*(\mathbf{a})=\mathbf{1}_n</code>
<br><strong>Condition 2</strong>: <code class="reqn">\quad \mathbf{E}_*\left(\mathbf{a}-\mathbf{1}_n\right)\left(\mathbf{a}-\mathbf{1}_n\right)^{\prime}=\mathbf{\Sigma}</code>
<br><br>
While there are multiple ways to generate adjustment factors satisfying these conditions,
the simplest general method is to simulate from a multivariate normal distribution: <code class="reqn">\mathbf{a} \sim MVN(\mathbf{1}_n, \boldsymbol{\Sigma})</code>.
This is the method used by this function.
</p>


<h3>Details on Rescaling to Avoid Negative Adjustment Factors</h3>

<p>Let <code class="reqn">\mathbf{A} = \left[ \mathbf{a}^{(1)} \cdots \mathbf{a}^{(b)} \cdots \mathbf{a}^{(B)} \right]</code> denote the <code class="reqn">(n \times B)</code> matrix of bootstrap adjustment factors.
To eliminate negative adjustment factors, Beaumont and Patak (2012) propose forming a rescaled matrix of nonnegative replicate factors <code class="reqn">\mathbf{A}^S</code> by rescaling each adjustment factor <code class="reqn">a_k^{(b)}</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
   a_k^{S,(b)} = \frac{a_k^{(b)} + \tau - 1}{\tau}
 </code>
</p>

<p>where <code class="reqn">\tau \geq 1 - a_k^{(b)} \geq 1</code> for all <code class="reqn">k</code> in <code class="reqn">\left\{ 1,\ldots,n \right\}</code> and all <code class="reqn">b</code> in <code class="reqn">\left\{1, \ldots, B\right\}</code>.
</p>
<p>The value of <code class="reqn">\tau</code> can be set based on the realized adjustment factor matrix <code class="reqn">\mathbf{A}</code> or by choosing <code class="reqn">\tau</code> prior to generating the adjustment factor matrix <code class="reqn">\mathbf{A}</code> so that <code class="reqn">\tau</code> is likely to be large enough to prevent negative bootstrap weights.
</p>
<p>If the adjustment factors are rescaled in this manner, it is important to adjust the scale factor used in estimating the variance with the bootstrap replicates, which becomes <code class="reqn">\frac{\tau^2}{B}</code> instead of <code class="reqn">\frac{1}{B}</code>.
</p>
<p style="text-align: center;"><code class="reqn">
 \textbf{Prior to rescaling: } v_B\left(\hat{T}_y\right) = \frac{1}{B}\sum_{b=1}^B\left(\hat{T}_y^{*(b)}-\hat{T}_y\right)^2
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \textbf{After rescaling: } v_B\left(\hat{T}_y\right) = \frac{\tau^2}{B}\sum_{b=1}^B\left(\hat{T}_y^{S*(b)}-\hat{T}_y\right)^2
</code>
</p>

<p>When sharing a dataset that uses rescaled weights from a generalized survey bootstrap, the documentation for the dataset should instruct the user to use replication scale factor <code class="reqn">\frac{\tau^2}{B}</code> rather than <code class="reqn">\frac{1}{B}</code> when estimating sampling variances.
</p>


<h3>References</h3>

<p>The generalized survey bootstrap was first proposed by Bertail and Combris (1997).
See Beaumont and Patak (2012) for a clear overview of the generalized survey bootstrap.
The generalized survey bootstrap represents one strategy for forming replication variance estimators
in the general framework proposed by Fay (1984) and Dippo, Fay, and Morganstein (1984).
<br><br>
- Beaumont, Jean-François, and Zdenek Patak. 2012. “On the Generalized Bootstrap for Sample Surveys with Special Attention to Poisson Sampling: Generalized Bootstrap for Sample Surveys.” International Statistical Review 80 (1): 127–48. https://doi.org/10.1111/j.1751-5823.2011.00166.x.
<br><br>
- Bertail, and Combris. 1997. “Bootstrap Généralisé d’un Sondage.” Annales d’Économie Et de Statistique, no. 46: 49. https://doi.org/10.2307/20076068.
<br><br>
- Dippo, Cathryn, Robert Fay, and David Morganstein. 1984. “Computing Variances from Complex Samples with Replicate Weights.” In, 489–94. Alexandria, VA: American Statistical Association. http://www.asasrms.org/Proceedings/papers/1984_094.pdf.
<br><br>
- Fay, Robert. 1984. “Some Properties of Estimates of Variance Based on Replication Methods.” In, 495–500. Alexandria, VA: American Statistical Association. http://www.asasrms.org/Proceedings/papers/1984_095.pdf.
<br></p>


<h3>See Also</h3>

<p>The function <code>make_quad_form_matrix</code> can be used to
represent several common variance estimators as a quadratic form's matrix,
which can then be used as an input to <code>make_gen_boot_factors()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  library(survey)

# Load an example dataset that uses unequal probability sampling ----
  data('election', package = 'survey')

# Create matrix to represent the Horvitz-Thompson estimator as a quadratic form ----
  n &lt;- nrow(election_pps)
  pi &lt;- election_jointprob
  horvitz_thompson_matrix &lt;- matrix(nrow = n, ncol = n)
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      horvitz_thompson_matrix[i,j] &lt;- 1 - (pi[i,i] * pi[j,j])/pi[i,j]
    }
  }

  ## Equivalently:

  horvitz_thompson_matrix &lt;- make_quad_form_matrix(
    variance_estimator = "Horvitz-Thompson",
    joint_probs = election_jointprob
  )

# Make generalized bootstrap adjustment factors ----

  bootstrap_adjustment_factors &lt;- make_gen_boot_factors(
    Sigma = horvitz_thompson_matrix,
    num_replicates = 80,
    tau = 'auto'
  )

# Determine replication scale factor for variance estimation ----
  tau &lt;- attr(bootstrap_adjustment_factors, 'tau')
  B &lt;- ncol(bootstrap_adjustment_factors)
  replication_scaling_constant &lt;- tau^2 / B

# Create a replicate design object ----
  election_pps_bootstrap_design &lt;- svrepdesign(
    data = election_pps,
    weights = 1 / diag(election_jointprob),
    repweights = bootstrap_adjustment_factors,
    combined.weights = FALSE,
    type = "other",
    scale = attr(bootstrap_adjustment_factors, 'scale'),
    rscales = attr(bootstrap_adjustment_factors, 'rscales')
  )

# Compare estimates to Horvitz-Thompson estimator ----

  election_pps_ht_design &lt;- svydesign(
    id = ~1,
    fpc = ~p,
    data = election_pps,
    pps = ppsmat(election_jointprob),
    variance = "HT"
  )

svytotal(x = ~ Bush + Kerry,
         design = election_pps_bootstrap_design)
svytotal(x = ~ Bush + Kerry,
         design = election_pps_ht_design)

## End(Not run)
</code></pre>


</div>