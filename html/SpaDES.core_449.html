<div class="container">

<table style="width: 100%;"><tr>
<td>simInit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Initialize a new simulation</h2>

<h3>Description</h3>

<p>Create a new simulation object, the <code>sim</code> object (a <code>simList</code>).
This object is implemented using an <code>environment</code> where all objects and functions are placed.
Since environments in <code>R</code> are pass by reference, "putting" objects in
the <code>sim</code> object does no actual copy.
The <code>simList</code> also stores all parameters, and other important simulation
information, such as times, paths, modules, and module load order.
See more details below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simInit(
  times,
  params,
  modules,
  objects,
  paths,
  inputs,
  outputs,
  loadOrder,
  notOlderThan = NULL,
  ...
)

## S4 method for signature 
## 'list,list,list,list,list,data.frame,data.frame,character'
simInit(
  times,
  params,
  modules,
  objects,
  paths,
  inputs,
  outputs,
  loadOrder,
  notOlderThan = NULL,
  ...
)

## S4 method for signature 'ANY,ANY,ANY,character,ANY,ANY,ANY,ANY'
simInit(
  times,
  params,
  modules,
  objects,
  paths,
  inputs,
  outputs,
  loadOrder,
  notOlderThan = NULL,
  ...
)

## S4 method for signature 'ANY,ANY,character,ANY,ANY,ANY,ANY,ANY'
simInit(
  times,
  params,
  modules,
  objects,
  paths,
  inputs,
  outputs,
  loadOrder,
  notOlderThan = NULL,
  ...
)

## S4 method for signature 'ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY'
simInit(
  times,
  params,
  modules,
  objects,
  paths,
  inputs,
  outputs,
  loadOrder,
  notOlderThan = NULL,
  ...
)

simInitDefaults()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>A named list of numeric simulation start and end times
(e.g., <code>times = list(start = 0.0, end = 10.0, timeunit = "year")</code>),
with the final optional element, <code>timeunit</code>, overriding the default
time unit used in the simulation which is the "smallest time unit" across all
modules. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>A list of lists of the form <code>list(moduleName=list(param1=value, param2=value))</code>.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modules</code></td>
<td>
<p>A named list of character strings specifying the names of modules to be loaded
for the simulation.
Note: the module name should correspond to the R source file from which the module is loaded.
Example: a module named "caribou" will be sourced form the file ‘<span class="file">caribou.R</span>’,
located at the specified <code>modulePath(simList)</code> (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objects</code></td>
<td>
<p>(optional) A vector of object names (naming objects
that are in the calling environment of
the <code>simInit</code>, which is often the
<code>.GlobalEnv</code> unless used programmatically.
NOTE: this mechanism will
fail if object name is in a package dependency), or
a named list of data objects to be
passed into the <code>simList</code> (more reliable).
These objects will be accessible
from the <code>simList</code> as a normal list, e.g,. <code>mySim$obj</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>An optional named list with up to 4 named elements,
<code>modulePath</code>, <code>inputPath</code>, <code>outputPath</code>, and <code>cachePath</code>.
See details. NOTE: Experimental feature now allows for multiple <code>modulePath</code>s
to be specified in a character vector. The modules will be searched for sequentially
in the first <code>modulePath</code>, then if it doesn't find it, in the second etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputs</code></td>
<td>
<p>A <code>data.frame</code>. Can specify from 1 to 6
columns with following column names: <code>objectName</code> (character, required),
<code>file</code> (character), <code>fun</code> (character), <code>package</code> (character),
<code>interval</code> (numeric), <code>loadTime</code> (numeric).
See <code>inputs()</code> and vignette("ii-modules") section about inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputs</code></td>
<td>
<p>A <code>data.frame</code>. Can specify from 1 to 5
columns with following column names: <code>objectName</code> (character, required),
<code>file</code> (character), <code>fun</code> (character), <code>package</code> (character),
<code>saveTime</code> (numeric) and <code>eventPriority</code> (numeric). If
<code>eventPriority</code> is not set, it defaults to <code>.last()</code>. If <code>eventPriority</code>
is set to a low value, e.g., 0, 1, 2 and <code>saveTime</code> is <code>start(sim)</code>,
it should give "initial conditions".
</p>
<p>See <code>outputs()</code> and
<code>vignette("ii-modules")</code> section about outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadOrder</code></td>
<td>
<p>An optional character vector of module names specifying the order in
which to load the modules. If not specified, the module
load order will be determined automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notOlderThan</code></td>
<td>
<p>A time, as in from <code>Sys.time()</code>. This is passed into
the <code>Cache</code> function that wraps <code>.inputObjects</code>.
If the module uses the <code>.useCache</code> parameter and it is
set to <code>TRUE</code> or <code>".inputObjects"</code>,
then the <code>.inputObjects</code> will be cached.
Setting <code>notOlderThan = Sys.time()</code> will cause the
cached versions of <code>.inputObjects</code> to be refreshed,
i.e., rerun.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>An alternative way to pass <code>objects</code>, i.e., they can just be named
arguments rather than in a <code>objects = list(...)</code>. It can also be any
<code>options</code> that begins with <code>spades</code>, <code>reproducible</code> or <code>Require</code>, i.e.,
those identified in <code>spadesOptions()</code>,
<code>reproducibleOptions()</code> or <code>RequireOptions()</code>.
These will be assigned to the equivalent option <em>during</em> the <code>simInit</code> and <code>spades</code>
calls only, i.e., they will revert after the <code>simInit</code> or <code>spades</code> calls
are complete. NOTE: these are not passed to the <code>simList</code> per se, i.e., they are
not be available in the <code>simList</code> during either
the <code>simInit</code> or <code>spades</code> calls via <code>sim$xxx</code>, though they will be returned to the <code>simList</code>
at the end of each of these calls (so that the next call to e.g., <code>spades</code> can
see them). For convenience, these can be supplied without their package prefix,
e.g., <code>lowMemory</code> can be specified instead of <code>spades.lowMemory</code>. In cases that
share option name (<code>reproducible.verbose</code> and <code>Require.verbose</code> both exist),
passing <code>verbose = FALSE</code> will set both. Obviously this may cause unexpected
problems if a module is also expecting a value.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Calling this <code>simInit</code> function does the following:</h4>


<table>
<tr>
<td style="text-align: left;">
<strong>What</strong> </td>
<td style="text-align: left;"> <strong>Details</strong> </td>
<td style="text-align: left;"> <strong>Argument(s) to use</strong> </td>
</tr>
<tr>
<td style="text-align: left;">
fills <code>simList</code> slots </td>
<td style="text-align: left;"> places the arguments <code>times</code>,
<code>params</code>, <code>modules</code>, <code>paths</code> into equivalently named
<code>simList</code> slots </td>
<td style="text-align: left;"> <code>times</code>,
<code>params</code>, <code>modules</code>, <code>paths</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
sources all module files </td>
<td style="text-align: left;"> places all function definitions in the
<code>simList</code>, specifically, into a sub-environment of the main
<code>simList</code> environment: e.g., <code style="white-space: pre;">⁠sim$&lt;moduleName&gt;$function1⁠</code>
(see section on <strong>Scoping</strong>) </td>
<td style="text-align: left;"> <code>modules</code> </td>
</tr>
<tr>
<td style="text-align: left;">
copies objects </td>
<td style="text-align: left;"> from the global environment to the
<code>simList</code> environment </td>
<td style="text-align: left;"> <code>objects</code> </td>
</tr>
<tr>
<td style="text-align: left;">
loads objects </td>
<td style="text-align: left;"> from disk into the <code>simList</code> </td>
<td style="text-align: left;"> <code>inputs</code> </td>
</tr>
<tr>
<td style="text-align: left;">
schedule object loading/copying </td>
<td style="text-align: left;"> Objects can be loaded into the
<code>simList</code> at any time during a simulation  </td>
<td style="text-align: left;"> <code>inputs</code> </td>
</tr>
<tr>
<td style="text-align: left;">
schedule object saving </td>
<td style="text-align: left;"> Objects can be saved to disk at any arbitrary
time during the simulation. If specified here, this will be in addition
to any saving due code inside a module (i.e., a module may manually
run <code>write.table(...)</code> </td>
<td style="text-align: left;"> <code>outputs</code> </td>
</tr>
<tr>
<td style="text-align: left;">
schedules "init" events </td>
<td style="text-align: left;"> from all modules (see <code>events()</code>)
</td>
<td style="text-align: left;"> automatic  </td>
</tr>
<tr>
<td style="text-align: left;">
assesses module dependencies </td>
<td style="text-align: left;"> via the inputs and outputs identified in their
metadata. This gives the order of the <code>.inputObjects</code> and <code>init</code>
events. This can be overridden by <code>loadOrder</code>. </td>
<td style="text-align: left;"> automatic </td>
</tr>
<tr>
<td style="text-align: left;">
determines time unit </td>
<td style="text-align: left;"> takes time units of modules
and how they fit together </td>
<td style="text-align: left;"> <code>times</code> or automatic </td>
</tr>
<tr>
<td style="text-align: left;">
runs <code>.inputObjects</code> functions </td>
<td style="text-align: left;"> from every module
<em>in the module order as determined above</em> </td>
<td style="text-align: left;"> automatic </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p><code>params</code> can only contain updates to any parameters that are defined in
the metadata of modules. Take the example of a module named, <code>Fire</code>, which
has a parameter named <code>.plotInitialTime</code>. In the metadata of that module,
it says <code>TRUE</code>. Here we can override that default with:
<code>list(Fire=list(.plotInitialTime=NA))</code>, effectively turning off plotting.
Since this is a list of lists, one can override the module defaults for multiple
parameters from multiple modules all at once, with say:
<code>list(Fire = list(.plotInitialTime = NA, .plotInterval = 2), caribouModule = list(N = 1000))</code>.
</p>
<p>The <code>params</code> list can contain a list (named <code>.globals</code>) of named objects
e.g., <code>.globals = list(climateURL = "https:\\something.com")</code> entry. Any and every
module that has a parameter with that name (in this case <code>climateURL</code>) will be
overridden with this value as passed.
</p>
<p><code>params</code> can be used to set the seed for a specific event in a module. This
is done using the normal <code>params</code> argument, specifying <code>.seed</code> as a list
where the elements are a numeric for the seed and the name is the event. Since
parameters must be specific to a module, this creates a module and event specific
seed e.g., <code>params = list(moduleName = list(.seed = list(init = 123)))</code> will
set the <code>init</code> event of module named <code>moduleName</code> to 123. The RN stream
will be reset to its state prior to the <code>set.seed</code> call after the event.
</p>
<p>We implement a discrete event simulation in a more modular fashion so it is
easier to add modules to the simulation. We use S4 classes and methods,
and fast lists to manage the event queue.
</p>
<p><code>paths</code> specifies the location of the module source files,
the data input files, and the saving output files. If no paths are specified
the defaults are as follows:
</p>

<ul>
<li> <p><code>cachePath</code>: <code>getOption("reproducible.cachePath")</code>;
</p>
</li>
<li> <p><code>inputPath</code>: <code>getOption("spades.inputPath")</code>;
</p>
</li>
<li> <p><code>modulePath</code>: <code>getOption("spades.modulePath")</code>;
</p>
</li>
<li> <p><code>outputPath</code>: <code>getOption("spades.outputPath")</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>simList</code> simulation object, pre-initialized from values
specified in the arguments supplied.
</p>


<h3>Parsing and Checking Code</h3>

<p>The <code>simInit</code> function will attempt to find usage of <code>sim$xxx</code> or <code>sim[['xxx']]</code>
on either side of the assignment (<code style="white-space: pre;">⁠&lt;-⁠</code>) operator.
It will compare these to the module metadata, specifically <code>inputObjects</code> for cases where
objects or "gotten" from the <code>simList</code> and <code>outputObjects</code> for cases where objects are
assigned to the <code>simList.</code>
</p>
<p>It will also attempt to find potential, common function name conflicts with things like
<code>scale</code> and <code>stack</code> (both in <span class="pkg">base</span> and <span class="pkg">raster</span>), and
<code>Plot</code> (in <span class="pkg">quickPlot</span> and some modules).
</p>
<p><em>This code checking is young and may get false positives and false negatives,
i.e., miss things</em>.
It also takes computational time, which may be undesirable in operational code.
To turn off checking (i.e., if there are too many false positives and negatives), set
<code>options(spades.moduleCodeChecks = FALSE)</code>.
</p>


<h3>Caching</h3>

<p>Using caching with <code>SpaDES</code> is vital when building re-usable and reproducible content.
Please see the vignette dedicated to this topic.
</p>


<h3>Note</h3>

<p>Since the objects in the <code>simList</code> are passed-by-reference, it is useful
to create a copy of the initialized <code>simList</code> object prior to running
the simulation (e.g., <code>mySimOut &lt;- spades(Copy(mySim))</code>).
This ensures you retain access to the original objects, which would otherwise
be overwritten/modified during the simulation.
</p>
<p>The user can opt to run a simpler <code>simInit</code> call without inputs, outputs, and times.
These can be added later with the accessor methods (See example).
These are not required for initializing the simulation via <code>simInit</code>.
All of <code>modules</code>, <code>paths</code>, <code>params</code>, and <code>objects</code> are needed
for successful initialization.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty and Eliot McIntire
</p>


<h3>References</h3>

<p>Matloff, N. (2011). The Art of R Programming (ch. 7.8.3).
San Francisco, CA: No Starch Press, Inc..
Retrieved from <a href="https://nostarch.com/artofr.htm">https://nostarch.com/artofr.htm</a>
</p>


<h3>See Also</h3>

<p><code>spades()</code>, <code>defineModule()</code> to get help on metadata elements,
<code>times()</code>, <code>params()</code>, <code>objs()</code>, <code>paths()</code>,
<code>modules()</code>, <code>inputs()</code>, <code>outputs()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> # Tests take several seconds
if (requireNamespace("SpaDES.tools", quietly = TRUE) &amp;&amp;
requireNamespace("NLMR", quietly = TRUE)) {
opts &lt;- options("spades.moduleCodeChecks" = FALSE, "spades.useRequire" = FALSE)
if (!interactive()) opts &lt;- append(opts, options("spades.plots" = NA,
                                                 "spades.debug" = FALSE))

mySim &lt;- simInit(
 times = list(start = 0.0, end = 2.0, timeunit = "year"),
 params = list(
   .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
 ),
 modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
 paths = list(modulePath = getSampleModules(tempdir()))
)
spades(mySim) # shows plotting

# Change more parameters, removing plotting
mySim &lt;- simInit(
 times = list(start = 0.0, end = 2.0, timeunit = "year"),
 params = list(
   .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
   fireSpread = list(.plotInitialTime = NA)
 ),
 modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
 paths = list(modulePath = getSampleModules(tempdir()))
)
outSim &lt;- spades(mySim)

# A little more complicated with inputs and outputs
mapPath &lt;- system.file("maps", package = "quickPlot")
mySim &lt;- simInit(
  times = list(start = 0.0, end = 2.0, timeunit = "year"),
  params = list(
    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
  ),
  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
  paths = list(modulePath = getSampleModules(tempdir()),
               outputPath = tempdir()),
  inputs = data.frame(
    files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
    functions = "rast",
    package = "terra",
    loadTime = 1,
    stringsAsFactors = FALSE),
  outputs = data.frame(
    expand.grid(objectName = c("caribou","landscape"),
    saveTime = 1:2,
    stringsAsFactors = FALSE)))

 # Use accessors for inputs, outputs
 mySim2 &lt;- simInit(
   times = list(start = 0.0, end = 2.0, timeunit = "year"),
   modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     randomLandscapes = list(nx = 10, ny = 10)
     ),
   paths = list(
     modulePath = getSampleModules(tempdir()),
     outputPath = tempdir()
   )
 )

 # add by accessor is equivalent
 inputs(mySim2) &lt;- data.frame(
     files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
     functions = "rast",
     package = "terra",
     loadTime = 1,
     stringsAsFactors = FALSE)
 outputs(mySim2) &lt;- data.frame(
     expand.grid(objectName = c("caribou", "landscape"),
     saveTime = 1:2,
     stringsAsFactors = FALSE))
 all.equal(mySim, mySim2) # TRUE

 # Use accessors for times -- does not work as desired because times are
 #   adjusted to the input timeunit during simInit
 mySim2 &lt;- simInit(
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
   ),
   modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
   paths = list(modulePath = getSampleModules(tempdir()),
                outputPath = tempdir()),
   inputs = data.frame(
     files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
     functions = "rast",
     package = "terra",
     loadTime = 1,
     stringsAsFactors = FALSE),
   outputs = data.frame(
     expand.grid(objectName = c("caribou","landscape"),
     saveTime = 1:2,
     eventPriority = c(0,10), # eventPriority 0 may give "initial" conditions
     stringsAsFactors = FALSE))
 )

 # add times by accessor fails all.equal test because "year" was not
 #   declared during module loading, so month became the default
 times(mySim2) &lt;- list(current = 0, start = 0.0, end = 2.0, timeunit = "year")
 all.equal(mySim, mySim2) # fails because time units are all different, so
                          # several parameters that have time units in
                          # "months" because they were loaded that way
 params(mySim)$fireSpread$.plotInitialTime
 params(mySim2)$fireSpread$.plotInitialTime
 events(mySim) # load event is at time 1 year
 events(mySim2) # load event is at time 1 month, reported in years because of
                #   update to times above
options(opts)

}


</code></pre>


</div>