<div class="container">

<table style="width: 100%;"><tr>
<td>int_sph_MC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Monte Carlo integration of functions on the (hyper)sphere</h2>

<h3>Description</h3>

<p>Monte Carlo approximation of the integral
</p>
<p style="text-align: center;"><code class="reqn">\int_{S^{p-1}}f(x)\,\mathrm{d}x</code>
</p>

<p>of a function <code class="reqn">f:S^{p-1} \rightarrow R</code> defined on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">int_sph_MC(f, p, M = 10000, cores = 1, chunks = ceiling(M/1000),
  seeds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>function to be integrated. Its first argument must be the
(hyper)sphere position. Must be vectorized and return a vector of size
<code>nrow(x)</code> for a matrix input <code>x</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of Monte Carlo samples. Defaults to <code>1e4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cores to perform the integration. Defaults to
<code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunks</code></td>
<td>
<p>number of chunks to split the <code>M</code> Monte Carlo
samples. Useful for parallelizing the integration in <code>chunks</code>
tasks containing <code>ceiling(M / chunks)</code> replications. Useful also for
avoiding memory bottlenecks when <code>M</code> is large. Defaults to
<br><code>ceiling(M / 1e3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>if provided, a vector of size <code>chunks</code> for fixing the
seeds on each of the simulation chunks (useful for reproducing parallel
simulations). Specifically, for <code>k in 1:chunks</code>, seeds are
set as <code>set.seed(seeds[k], kind = "Mersenne-Twister")</code> in each chunk.
Defaults to <code>NULL</code> (no seed setting is done).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments to be passed to <code>f</code> or to
<code>foreach</code> (for example, <code>.export</code> to export global
variables or other functions to the <code>foreach</code> environment).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is possible to have a progress bar if <code>int_sph_MC</code> is wrapped with
<code>progressr::with_progress</code> or if
<code>progressr::handlers(global = TRUE)</code> is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.
</p>


<h3>Value</h3>

<p>A scalar with the approximate integral.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Sequential simulation

# Vectorized functions to be integrated
x1 &lt;- function(x) x[, 1]
quad &lt;- function(x, a = 0) a + rowSums(x^4)

# Approximate \int_{S^{p-1}} x_1 dx = 0
int_sph_MC(f = x1, p = 3, M = 1e4, chunks = 2)

# Approximate \int_{S^{p-1}} (a + \sum_i x_i^4) dx
int_sph_MC(f = quad, p = 2, M = 1e4, a = 0, chunks = 2)

# Compare with Gauss--Legendre integration on S^2
th_k &lt;- Gauss_Legen_nodes(a = 0, b = 2 * pi, N = 40)
w_k &lt;- Gauss_Legen_weights(a = 0, b = 2 * pi, N = 40)
sum(w_k * quad(cbind(cos(th_k), sin(th_k)), a = 1))

## Parallel simulation with a progress bar

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = paste("(:spin) [:bar] :percent Iter: :current/:total Rate:",
                 ":tick_rate iter/sec ETA: :eta Elapsed: :elapsedfull"),
  clear = FALSE))
# Call int_sph_MC() within with_progress()
with_progress(int_sph_MC(f = x1, p = 3, cores = 2, M = 1e5, chunks = 100))

# Instead of using with_progress() each time, it is more practical to run
# handlers(global = TRUE)
# once to activate progress bars in your R session

</code></pre>


</div>