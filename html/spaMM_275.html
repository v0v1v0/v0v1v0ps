<div class="container">

<table style="width: 100%;"><tr>
<td>numInfo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Information matrix
</h2>

<h3>Description</h3>

<p>Computes by numerical derivation the observed information matrix for (ideally) all parameters for mean response model, that is, the matrix of second derivatives of negative log likelihood. 
The default value of the <code>which</code> argument shows all classes of parameters that should be handled, including random-effect parameters (<code>lambda</code>, <code>ranCoefs</code>, <code>corrPars</code>, and <code>hyper</code>), residual dispersion parameters (<code>phi</code>, <code>NB_shape</code> for <code>negbin1</code> and <code>negbin2</code>, and <code>beta_prec</code> for <code>beta_resp</code> and <code>betabin</code>), and fixed-effect coefficients (<code>beta</code>).
</p>
<p>Model fits including a <code>phi-resid.model</code> are not fully handled, in two ways: the information matrix does not include their parameters; and if the residual dispersion model include random effects, there is good reason for the <code>numInfo</code> calculation to detect that the fit has not maximized marginal likelihood with respect to most parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">numInfo(fitobject, transf = FALSE, which = NULL, check_deriv = TRUE,
        sing=1e-05, verbose=FALSE, refit_hacks=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitobject</code></td>
<td>

<p>Fit object returned by a <span class="pkg">spaMM</span> fitting function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transf</code></td>
<td>

<p>Whether to perform internal computations on a transformed scale (but computation on 
transformed scale may be implemented for fewer classes of models than default computation). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p> NULL, or character vector giving the sets of parameters with respect to which derivatives are to be computed.
The NULL default is equivalent to <code>c("lambda", "ranCoefs", "corrPars", "hyper", "phi", "NB_shape", "beta_prec", "beta")</code> for ML fits,
and to the same except <code>"beta"</code> (fixed effects) for REML fits.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_deriv</code></td>
<td>

<p>Boolean; whether to perform some checks for possible problems (see Details). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sing</code></td>
<td>

<p>numeric value, or <code>FALSE</code>; if it is a nonzero numeric value, eigenvalues of the matrix are checked and values smaller than <code>sing</code>
are highlighted in output (see Value). This will highlight nearly-singular information matrices, but also those with large negative eigenvalues.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Boolean: whether to print (as a list) the estimates of the parameters for which the Hessian will be computed, additional information about possibly ignored parameters, possible misuse of REML fits, and a (sort of) progress bar if the procedure is expected to last more than a few seconds.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit_hacks</code></td>
<td>

<p>list of arguments; its name anticipates that it might allow hazardous manipulations in a later version of <span class="pkg">spaMM</span>. But currently only the innocuous element <code>verbose</code> of the list will be taken into account. Notably, <code>refit_hacks=list(verbose=c(TRACE=TRUE))</code> can be used to give information on parameter values used in the computation of numerical derivatives.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>numDeriv::hessian</code> and <code>numDeriv::grad</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The computation of a second derivatives is not necessarily meaningful if a first derivative does not vanish at the parameter estimates. This may occur in particular when the objective function (say, marginal likelihood) is maximized at a boundary of the parameter space (say, at zero for <code>lambda</code> estimates). Further, for such values at a boundary, only one-sided derivatives can be computed, and this is not handled by <code>numDeriv::hessian</code>. So, some checks may be requested to detect non-zero gradients and parameters estimated at their boundaries. The boundary checks are currently performed for <code>lambda</code> and <code>ranCoefs</code> estimates, if <code>check_deriv</code> is set to TRUE or to NULL. Other parameters are not (yet) checked, so <code>numInfo</code> may sometimes fails when such other parameter estimates are at a boundary. If <code>check_deriv</code> is set to TRUE, an additional systematic check of the gradient with respect to all target parameters is performed. 
</p>


<h3>Value</h3>

<p>NULL or a matrix.
</p>
<p>NULL is returned if no parameter is found with respect to which a numerical information “should” be computed (where what should be done depends on the <code>which</code> and <code>check_derivs</code> arguments). 
</p>
<p>Otherwise a matrix is returned, with an <code>eigvals</code> attribute if <code>sing</code> was non-zero. This attribute is a numeric vector of eigenvalues of the matrix. If some eigenvalue(s) were lower than <code>sing</code>, the vector has additional class <code>"singeigs"</code> so that its printing is controlled by an ad-hoc <code>print.singeigs</code> method highlighting the small eigenvalues. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("wafers")
lmmfit &lt;- fitme(y ~X1+X2+X1*X3+X2*X3+I(X2^2)+(1|batch),data=wafers)
numinfo &lt;- numInfo(lmmfit)
(SEs &lt;- sqrt(diag(solve(numinfo))))
#
# =&gt; beta SEs here equal to conditional SEs shown by fit summary.
# Other SEs can be compared to the approximate ones 
# for log(phi) and log(lambda), given by 
#
# update(lmmfit, control=list(refit=TRUE))
#
# =&gt; 1118*0.5289 and 10840*0.1024

data("blackcap")
maternfit &lt;- fitme(migStatus ~ means+ Matern(1|longitude+latitude),data=blackcap) 
numInfo(maternfit)
</code></pre>


</div>