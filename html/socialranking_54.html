<div class="container">

<table style="width: 100%;"><tr>
<td>L2Scores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>L2 Ranking</h2>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{(2)}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">L2Scores(powerRelation, elements = powerRelation$elements)

L2Ranking(powerRelation)

lexcel2Scores(powerRelation, elements = powerRelation$elements)

lexcel2Ranking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>Given two elements <code class="reqn">i, j \in N</code>, <code class="reqn">L^{(2)}</code> then ranks
<code class="reqn">i</code> <em>strictly above</em> <code class="reqn">j</code> if there is some row
<code class="reqn">p^0 \in \lbrace 1, \dots, |N| \rbrace</code> and column
<code class="reqn">q^0 \in \lbrace 1, \dots, m \rbrace</code> such that
</p>

<ol>
<li> <p><code class="reqn">\sum_{p = 1}^{|N|} (M^\succsim_i)_{p,q} = \sum_{p = 1}^{|N|} (M^\succsim_j)_{p,q}\text{ for all } q &lt; q^0</code>,
</p>
</li>
<li> <p><code class="reqn">\begin{cases}
\text{(i)\hphantom{i} either } &amp; \sum_{p=1}^{|N|} (M^\succsim_i)_{p,q^0} &gt; \sum_{p=1}^{|N|} (M^\succsim_j)_{p,q^0}\\[5pt]
\text{(ii) or } &amp; (M^\succsim_i)_{p^0,q^0} &gt; (M^\succsim_j)_{p^0,q^0} \text{ and } (M^\succsim_i)_{p,q^0} = (M^\succsim_j)_{p,q^0} \text{ for all } p &lt; p^0
\end{cases}</code>
</p>
</li>
</ol>
<p>Note that the conditions are very similar to <code>L1Ranking()</code>, with the difference that condition 3.(i)
also ranks an element over another if they simply appear more often in an equivalence class, regardless of coalition size.
This implies that a row <code class="reqn">p^0</code> for condition 3.(ii) to be satisfied may not have to exist.
</p>


<h3>Value</h3>

<p>Score function returns a list of type <code>L2Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a matrix with <code>length(powerRelation$eqs)</code> columns and <code>1 + length(powerRelation$elements)</code> rows.
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">N = \lbrace 1, 2, 3, 4 \rbrace</code> and <code class="reqn">\succsim: (123 \sim 12 \sim 13 \sim 14 \sim 2 \sim 4) \succ S</code>,
where <code class="reqn">S</code> is every other coalition not present in the first equivalence class.
From this, we get the following four matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 1\\
3 &amp; 0\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0\\
1 &amp; 2\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 1\\
1 &amp; 2\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_4 = \begin{bmatrix}
1 &amp; 0\\
1 &amp; 2\\
0 &amp; 3\\
0 &amp; 1
\end{bmatrix}
</code>
</p>

<p>For the sums in column 1, we get
</p>
<p style="text-align: center;"><code class="reqn">\begin{aligned}\sum_{p=1}^{4} (M^\succsim_1)_{p,1} &amp;= 4,\\\sum_{p=1}^{4} (M^\succsim_2)_{p,1} &amp;= 3,\\\sum_{p=1}^{4} (M^\succsim_3)_{p,1} = \sum_{p=1}^{4} (M^\succsim_4)_{p,1} &amp;= 2\end{aligned}.</code>
</p>

<p>This immediately puts <code class="reqn">1</code> above all other elements and <code class="reqn">2</code> above <code class="reqn">3</code> and <code class="reqn">4</code> according to the <code class="reqn">L^{(2)}</code>.
<code class="reqn">L^{(1)}</code> would in this case prefer <code class="reqn">2</code> over <code class="reqn">1</code>, simply because <code class="reqn">2</code> appears once in a coalition of size 1 and <code class="reqn">1</code> doesn't.
</p>
<p>Since the column sum for <code class="reqn">3</code> and <code class="reqn">4</code> is the same, we can next evaluate if the individual row values are also the same.
Here, since <code class="reqn">(M^\succsim_4)_{1,1} &gt; (M^\succsim_3)_{1,1}</code>, this gives an edge of element <code class="reqn">4</code> over <code class="reqn">3</code>.
</p>
<p>Note that, if the column was identical for <code class="reqn">3</code> and <code class="reqn">4</code>, we would go to the next column and repeat the process.
Elements are only then considered indifferent from each other, if the entire matrix is identical between the two.
</p>


<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
“Lexicographic solutions for coalitional rankings based on individual and collective performances.”
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code>L1Scores()</code> function.
</p>
<p>For less complexity, another row is prepended to the matrix showing the sum of each column.
Through this, a simple <code class="reqn">L^{(1)}</code> comparison can be applied.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcel2Scores()</code> and <code>lexcel2Ranking()</code> serve as aliases for <code>L2Scores()</code> and <code>L2Ranking()</code>, respectively.
</p>


<h3>References</h3>

<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
“Lexicographic solutions for coalitional rankings.”
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1–33.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code>L1Scores()</code>,
<code>LPSScores()</code>,
<code>LPScores()</code>,
<code>copelandScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>lexcelScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("123 ~ 12 ~ 13 ~ 14 ~ 2 ~ 4")
pr &lt;- appendMissingCoalitions(pr)
scores &lt;- L2Scores(pr)
scores$`1`
#      [,1] [,2]
# [1,]    0    1
# [2,]    3    0
# [3,]    1    2
# [3,]    0    1

L2Ranking(pr)
# 1 &gt; 2 &gt; 4 &gt; 3

L1Ranking(pr)
# 2 &gt; 4 &gt; 1 &gt; 3

</code></pre>


</div>