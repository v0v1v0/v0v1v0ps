<div class="container">

<table style="width: 100%;"><tr>
<td>sm_vcov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute variance covariance of 'Unified' Second Moment</h2>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample mean and second moment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sm_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
"normal", we assume multivariate normal returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code>, the 'unified' sample is the 
<code class="reqn">p(p+3)/2</code> vector of <code class="reqn">x</code> stacked on top 
of <code class="reqn">\mbox{vech}(x x^{\top})</code>. 
Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function computes the mean and the variance-covariance
matrix of the 'unified' sample. 
</p>
<p>One may use the default method for computing covariance,
via the <code>vcov</code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = p(p+3)/2</code> vector of the mean, then the vech'd second
moment of the sample data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance covariance 
matrix. Only the informative part is returned: one may assume a row and
column of zeros in the upper left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the number of assets.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function will be deprecated in future releases of this package.
Users should migrate at that time to a similar function in the
MarkowitzR package.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. "Asymptotic Distribution of the Markowitz Portfolio."
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>


<h3>See Also</h3>

<p><code>ism_vcov</code>, <code>sr_vcov</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- matrix(rnorm(1000*3),ncol=3)
Sigmas &lt;- sm_vcov(X)
Sigmas.n &lt;- sm_vcov(X,vcov.func="normal")
Sigmas.n &lt;- sm_vcov(X,fit.intercept=FALSE)

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- sm_vcov(X)

if (require(sandwich)) {
 Sigmas &lt;- sm_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- sm_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- sm_vcov(Xf,vcov.func=vcovHAC)
}


</code></pre>


</div>