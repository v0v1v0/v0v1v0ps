<div class="container">

<table style="width: 100%;"><tr>
<td>findOptimalPointAlignment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimally aligns one point set to another</h2>

<h3>Description</h3>

<p>This function translates and rotates one point set, optimally aligning it with another point set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findOptimalPointAlignment(m1, m2, sign = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m1</code></td>
<td>
<p>a point set matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2</code></td>
<td>
<p>a second point set matrix of the same dimensions as <code>m1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign</code></td>
<td>
<p>Used for debugging.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function optimally aligns point set <code>m2</code> with point set <code>m1</code>. <code>m1</code> and <code>m2</code> must contain the exact same landmarks or points in the same order. Points present in <code>m2</code> but not <code>m1</code> should be <code>NA</code> in <code>m1</code>. They do not need to be <code>NA</code> in <code>m2</code>; all translations and rotations will be applied to all points in <code>m2</code> even though only shared points will be used in the alignment.
</p>
<p>The function first centers the centroid <code>m2</code> about the centroid of <code>m1</code>. The function <code>svd()</code> is then used to find the 3D rotation matrix that optimally aligns <code>m2</code> to <code>m1</code> based on common points. The positions of points in <code>m2</code> relative to one another are unchanged. Thus, optimal rotation is constrained to already translated point sets. Depending on the point sets, a better alignment may be possible by allowing translation and rotation to be optimized simultaneously.
</p>
<p>This function is called by <code>unifyLandmarks</code> to align landmark sets and by <code>dltTestCalibration</code> to test accuracy in reconstructed calibration grids.
</p>


<h3>Value</h3>

<p><code>m2</code> after alignment.</p>


<h3>Note</h3>

<p>Modified from <code>unifyVD()</code> by Annat Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>References</h3>

<p>Rohlf, F.J. (1990) "Chapter 10. Rotational fit (Procrustes) Methods." <em>Proceedings of the Michigan Morphometrics Workshop</em>. Ed. F. James Rohlf and Fred L. Bookstein. The University of Michigan Museum of Zoology, 1990. 227â€“236. <a href="http://deepblue.lib.umich.edu/handle/2027.42/49535">Info page at lib.umich.edu</a>
</p>


<h3>See Also</h3>

<p><code>unifyLandmarks</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## MAKE MATRIX OF 3D POINTS
m1 &lt;- matrix(c(0,0,0, 1,3,2, 4,2,1, 5,5,3, 1,4,2, 3,6,4), nrow=6, ncol=3)

## COPY TO M2
m2 &lt;- m1

## MAKE MISSING POINT IN M1
## ALTHOUGH NOT USED IN THE ALIGNMENT THE CORRESPONDING POINT
##  IN M2 IS STILL RETURNED AFTER ALIGNMENT
m1[3, ] &lt;- NA

## CENTER M2 ABOUT CE
m2 &lt;- m2 %*% rotationMatrixZYX_SM(pi/6, -pi/3, pi/8)

## TRANSLATE M2
m2 &lt;- m2 + matrix(c(2,3,4), nrow=6, ncol=3, byrow=TRUE)

## ALIGN M2 TO M1
m3 &lt;- findOptimalPointAlignment(m1, m2)

## NOTE THAT RETURNED MATRIX IS IDENTICAL TO M1
## OF COURSE REAL WORLD DATA WILL HAVE SOME ERROR
m1
m3
</code></pre>


</div>