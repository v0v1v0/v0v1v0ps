<div class="container">

<table style="width: 100%;"><tr>
<td>control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Miscellanea of functions</h2>

<h3>Description</h3>

<p>Utility functions for least squares estimation in large data sets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">control(B, symmetric = TRUE, tol.values = 1e-7, tol.vectors = 1e-7,
       out.B = TRUE, method = c("eigen", "Cholesky"))
cp(X, w = NULL, row.chunk = NULL, sparse = FALSE)
is.sparse(X, sparselim = .9, camp = .05)               
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a squared matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>logical, is <code>B</code> symmetric?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.values</code></td>
<td>
<p>tolerance to be consider eigenvalues equals to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.vectors</code></td>
<td>
<p>tolerance to be consider eigenvectors equals to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.B</code></td>
<td>
<p>Have the matrix B to be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method to check for singularity. By default is "eigen", and
an eigendecomposition of X'X is made. The "Cholesky" method is 
faster than "eigen" and does not use tolerance, but the former 
seems to be more stable for opportune tolerance values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>the model matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a weights vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>logical, is <code>X</code> sparse?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparselim</code></td>
<td>
<p>a real in the interval [0; 1]. It indicates 
the minimal proportion of zeroes in the data matrix X in order 
to consider X as sparse </p>
</td>
</tr>
</table>
<p>eigendec Logical. Do you want to investigate on rank of X? You may set to
</p>
<table>
<tr style="vertical-align: top;">
<td><code>row.chunk</code></td>
<td>
<p>an integer which indicates the total rows number 
compounding each of the first g-1 blocks. If <code>row.chunk</code> is not a divisor 
of nrow(X), the g-th block will be formed by the remaining data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>camp</code></td>
<td>
<p>the sample proportion of elements of X on which the survey will be based.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>control</code> makes an eigendecomposition of B according established values of tolerance. 
Function <code>cp</code> makes the cross-product X'X by partitioning X in row-blocks. 
When an optimized BLAS, such as ATLAS, is not installed, the function represents an attempt 
to speed up the calculation and avoid overflows with medium-large data sets loaded in R memory.
The results depending on processor type. Good results are obtained, for example, with an AMD Athlon 
dual core 1.5 Gb RAM by setting <code>row.chunk</code> to some value less than 1000. Try the example below 
by changing the matrix size and the value of <code>row.chunk</code>. If the matrix X is sparse, it will have 
class "dgCMatrix" (the package Matrix is required) and the cross-product will be made without 
partitioning. However, good performances are usually obtained with a very 
high zeroes proportion. 
Function <code>is.sparse</code> makes a quick sample survey on sample proportion of zeroes in X.
</p>


<h3>Value</h3>

<p>for the function <code>control</code>, a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>XTX</code></td>
<td>
<p>the matrix product B without singularities (if there are).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>the rank of B</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pivot</code></td>
<td>
<p>an ordered set of column indeces of B with, if the case, the last <code class="reqn">rank+1,...,p</code>  
columns which indicate possible linear combinations.</p>
</td>
</tr>
</table>
<p>for the function <code>cp</code>:  
</p>
<table><tr style="vertical-align: top;">
<td><code>new.B</code></td>
<td>
<p>the matrix product X'X (weighted, if <code>w</code> is given).</p>
</td>
</tr></table>
<p>for the function <code>is.sparse</code>:  
</p>
<table><tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>a logical value which indicates if the sample proportion of zeroes is 
greater than <code>sparselim</code>, with the sample proportion as attribute.</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Marco ENEA</p>


<h3>See Also</h3>

 <p>eigen, chol, qr, crossprod</p>


<h3>Examples</h3>

<pre><code class="language-R">#### example 1.

n &lt;- 100
k &lt;- 5
x &lt;- round(matrix(rnorm(n*k),n,k),digits=4)
y &lt;- rnorm(n)

# if an optimized BLAS is not installed, depending on processor type, cp() may be 
# faster than crossprod() for large matrices.

a1 &lt;- crossprod(x)
a2 &lt;- cp(x,,row.chunk = 50)
all.equal(a1, a2)  

#### example 2.1.
x[,2] &lt;- x[,1] + 2*x[,3]  # x has rank 9

# estimation by least squares 
A &lt;- function(){
  A1 &lt;- control(crossprod(x))
  ok &lt;- A1$pivot[1:A1$rank]
  as.vector(solve(A1$XTX,crossprod(x[,ok],y)))
}
# estimation by QR decomposition
B &lt;- function(){
  B1 &lt;- qr(x)
  qr.solve(x[,B1$pivot[1:B1$rank]],y)    
}  
a &lt;- A()
b &lt;- B()

all.equal(a,b)


### example 3. 
n &lt;- 1000
fat1 &lt;- gl(20,50)
y &lt;- rnorm(n)
da &lt;- data.frame(y,fat1)
m &lt;- model.matrix(y ~ factor(fat1),data = da)
is.sparse(m)





</code></pre>


</div>