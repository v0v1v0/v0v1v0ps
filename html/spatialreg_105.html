<div class="container">

<table style="width: 100%;"><tr>
<td>SpatialFiltering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Semi-parametric spatial filtering</h2>

<h3>Description</h3>

<p>The function selects eigenvectors in a semi-parametric spatial filtering approach to removing spatial dependence from linear models. Selection is by brute force by finding the single eigenvector reducing the standard variate of Moran's I for regression residuals most, and continuing until no candidate eigenvector reduces the value by more than <code>tol</code>. It returns a summary table from the selection process and a matrix of selected eigenvectors for the specified model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SpatialFiltering(formula, lagformula=NULL, data=list(), na.action=na.fail,
 nb=NULL, glist = NULL,
 style = "C", zero.policy = NULL, tol = 0.1, zerovalue = 1e-04,
 ExactEV = FALSE, symmetric = TRUE, alpha=NULL, alternative="two.sided",
 verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit, assuming a spatial error representation; when lagformula is given, it should include only the response and the intercept term</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagformula</code></td>
<td>
<p>An extra one-sided formula to be used when a spatial lag representation is desired; the intercept is excluded within the function if present because it is part of the formula argument, but excluding it explicitly in the lagformula argument in the presence of factors generates a collinear model matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glist</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p><code>style</code> can take values W, B, C, U, and S</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function (default <code>options("na.action")</code>), can also be <code>na.omit</code> or <code>na.exclude</code> with consequences for residuals and fitted values - in these cases the spatial weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance value for convergence of spatial filtering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zerovalue</code></td>
<td>
<p>eigenvectors with eigenvalues of an absolute value smaller than zerovalue will be excluded in eigenvector search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ExactEV</code></td>
<td>
<p>Set ExactEV=TRUE to use exact expectations and variances rather than the expectation and variance of Moran's I from the previous iteration, default FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>Should the spatial weights matrix be forced to symmetry, default TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>if not NULL, used instead of the tol= argument as a stopping rule to choose all eigenvectors up to and including the one with a probability value exceeding alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater, less or two.sided (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>default NULL, use global option value; if TRUE report eigenvectors selected</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>SfResult</code> object, with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>selection</code></td>
<td>
<p>a matrix summarising the selection of eigenvectors for inclusion, with columns:
</p>

<dl>
<dt>Step</dt>
<dd>
<p>Step counter of the selection procedure</p>
</dd>
<dt>SelEvec</dt>
<dd>
<p>number of selected eigenvector (sorted descending)</p>
</dd>
<dt>Eval</dt>
<dd>
<p>its associated eigenvalue</p>
</dd>
<dt>MinMi</dt>
<dd>
<p>value Moran's I for residual autocorrelation</p>
</dd>
<dt>ZMinMi</dt>
<dd>
<p>standardized value of Moran's I assuming a normal approximation</p>
</dd>
<dt>pr(ZI)</dt>
<dd>
<p>probability value of the permutation-based standardized deviate for the given value of the alternative argument</p>
</dd>
<dt>R2</dt>
<dd>
<p>R^2 of the model including exogenous variables and eigenvectors</p>
</dd>
<dt>gamma</dt>
<dd>
<p>regression coefficient of selected eigenvector in fit</p>
</dd>
</dl>
<p>The first row is the value at the start of the search
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>a matrix of the selected eigenvectors in order of selection</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yongwan Chun, Michael Tiefelsdorf, Roger Bivand</p>


<h3>References</h3>

<p>Tiefelsdorf M, Griffith DA. (2007) Semiparametric Filtering of Spatial Autocorrelation: The Eigenvector Approach. Environment and Planning A, 39 (5) 1193 - 1221.</p>


<h3>See Also</h3>

<p><code>lm</code>, <code>eigen</code>, <code>nb2listw</code>, <code>listw2U</code></p>


<h3>Examples</h3>

<pre><code class="language-R">require("sf", quietly=TRUE)
columbus &lt;- st_read(system.file("shapes/columbus.gpkg", package="spData")[1], quiet=TRUE)
#require("spdep", quietly=TRUE)
col.gal.nb &lt;- spdep::read.gal(system.file("weights/columbus.gal", package="spData")[1])
lmbase &lt;- lm(CRIME ~ INC + HOVAL, data=columbus)
sarcol &lt;- SpatialFiltering(CRIME ~ INC + HOVAL, data=columbus,
 nb=col.gal.nb, style="W", ExactEV=TRUE)
sarcol
lmsar &lt;- lm(CRIME ~ INC + HOVAL + fitted(sarcol), data=columbus)
(x &lt;- summary(lmsar))
coef(x)
anova(lmbase, lmsar)
spdep::lm.morantest(lmsar, spdep::nb2listw(col.gal.nb))
lagcol &lt;- SpatialFiltering(CRIME ~ 1, ~ INC + HOVAL - 1, data=columbus,
 nb=col.gal.nb, style="W")
lagcol
lmlag &lt;- lm(CRIME ~ INC + HOVAL + fitted(lagcol), data=columbus)
lmlag
anova(lmbase, lmlag)
spdep::lm.morantest(lmlag, spdep::nb2listw(col.gal.nb))
NA.columbus &lt;- columbus
NA.columbus$CRIME[20:25] &lt;- NA
COL.SF.NA &lt;- SpatialFiltering(CRIME ~ INC + HOVAL, data=NA.columbus,
 nb=col.gal.nb, style="W", na.action=na.exclude)
COL.SF.NA$na.action
summary(lm(CRIME ~ INC + HOVAL + fitted(COL.SF.NA), data=NA.columbus,
 na.action=na.exclude))
</code></pre>


</div>