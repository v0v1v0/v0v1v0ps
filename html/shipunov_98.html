<div class="container">

<table style="width: 100%;"><tr>
<td>Pinhull</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Point in hull</h2>

<h3>Description</h3>

<p>For each observation, returns if it is within a polygon</p>


<h3>Usage</h3>

<pre><code class="language-R">
Pinhull(pts, ppts)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pts</code></td>
<td>
<p>Data points, 2-dimensional</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ppts</code></td>
<td>
<p>List with polygon information (e.g., output from Hulls() or
Ellipses())</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For each 'pts' observation, Pinhull() uses PBSmapping::findPolys() to
find if it is within (or on the border) of each polygon described in
'ppts'.
</p>
<p>The output or Pinhull is easy to use to calculate the "observation
overlap", it also allows to reveal "outliers" (points outside all
polygons) and all polygon membership features (e.g., which points belong
to more than one polygon).
</p>


<h3>Value</h3>

<p>Logical matrix, each column is the hull (polygon) name, rows correspond
with rows of data points.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code>Hulls</code>, <code>Ellipses</code>, <code>Overlap</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.h &lt;- Hulls(iris.p, iris$Species, plot=FALSE)
iris.e &lt;- Ellipses(iris.p, iris$Species, plot=FALSE)

## convex hulls
iris.pih &lt;- Pinhull(iris.p, iris.h)

## confidence ellipses
iris.pie &lt;- Pinhull(iris.p, iris.e)
## membership overlap
dist(t(iris.pie), method="binary")
## how to find outliers (points outside of all ellipses)
which(apply(iris.pie, 1, sum) == 0) # outliers
## how to make membership table
iris.pie.g &lt;- cbind(iris.pie, group=Alldups(iris.pie, groups=TRUE))
key &lt;- iris.pie.g[!duplicated(iris.pie), ]
key &lt;- key[order(key[, "group"]), ]
mem &lt;- aggregate(1:nrow(iris.p), list(group=iris.pie.g[, "group"]), paste0, collapse=", ")
mem &lt;- cbind(key, mem)
mem[, mem %-% "group"] # all memberships

## distance based on membership intersection, Overlap() analog
dist(t(iris.pie), method="binary") # asymmetric binary
SM.dist(t(iris.pie)) # symmetric binary

## uniqueness of species
lapply(1:3, function(.x) sum(rowSums(iris.pie[as.numeric(iris$Species) == .x,
 ]) &gt; 1)/table(iris$Species)[.x]) ## versicolor is least unique

</code></pre>


</div>