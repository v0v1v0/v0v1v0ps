<div class="container">

<table style="width: 100%;"><tr>
<td>is.robinson</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create and Recognize Robinson and Pre-Robinson Matrices</h2>

<h3>Description</h3>

<p>Provides functions to create and recognize (anti) Robinson and pre-Robinson
matrices. A (anti) Robinson matrix has strictly decreasing (increasing)
values when moving away from the main diagonal. A pre-Robinson matrix is a
matrix which can be transformed into a perfect Robinson matrix using
simultaneous permutations of rows and columns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.robinson(x, anti = TRUE, pre = FALSE)

random.robinson(n, anti = TRUE, pre = FALSE, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a symmetric, positive matrix or a dissimilarity matrix (a
<code>dist</code> object).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anti</code></td>
<td>
<p>logical; check for anti Robinson structure? Note that for
distances, anti Robinson structure is appropriate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>
<p>logical; recognize/create pre-Robinson matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>noise intensity between 0 and 1. Zero means no noise.  Noise
more than zero results in non-Robinson matrices.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that the default matrices are anti Robinson matrices. This is done
because distance matrices (the default in R) are typically anti Robinson
matrices with values increasing when moving away from the diagonal.
</p>
<p>Robinson matrices are recognized using the fact that they have zero anti
Robinson events. For pre-Robinson matrices we use spectral seriation first
since spectral seriation is guaranteed to perfectly reorder pre-Robinson
matrices (see Laurent and Seminaroti, 2015).
</p>
<p>Random pre-Robinson matrices are generated by reversing the process of
unidimensional scaling. We randomly (uniform distribution with range
<code class="reqn">[0,1]</code>) choose <code class="reqn">x</code> coordinates for <code>n</code> points on a straight
line and calculate the pairwise distances. For Robinson matrices, the points
are sorted first according to <code class="reqn">x</code>. For noise, <code class="reqn">y</code> coordinates is
added. The coordinates are chosen uniformly between 0 and <code>noise</code>, with
<code>noise</code> between 0 and 1.
</p>


<h3>Value</h3>

<p>A single logical value.
</p>


<h3>References</h3>

<p>M. Laurent, M. Seminaroti (2015): The quadratic assignment
problem is easy for Robinsonian matrices with Toeplitz structure,
<em>Operations Research Letters</em> <strong>43</strong>(1), 103â€“109.
</p>


<h3>See Also</h3>

<p>Other data: 
<code>Chameleon</code>,
<code>Irish</code>,
<code>Munsingen</code>,
<code>SupremeCourt</code>,
<code>Townships</code>,
<code>Wood</code>,
<code>Zoo</code>,
<code>create_lines_data()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## create a perfect anti Robinson structure
m &lt;- random.robinson(10)
pimage(m)

is.robinson(m)

## permute the structure to make it not Robinsonian. However,
## it is still pre-Robinson.
o &lt;- sample(10)
m2 &lt;- permute(m, ser_permutation(o,o))
pimage(m2)

is.robinson(m2)
is.robinson(m2, pre = TRUE)

## create a binary random Robinson matrix (not anti Robinson)
m3 &lt;- random.robinson(10, anti = FALSE) &gt; .7
pimage(m3)
is.robinson(m3, anti = FALSE)

## create matrices with noise (as distance matrices)
m4 &lt;- as.dist(random.robinson(50, pre = FALSE, noise = .1))
pimage(m4)
criterion(m4, method = "AR")

m5 &lt;- as.dist(random.robinson(50, pre = FALSE, noise = .5))
pimage(m5)
criterion(m5, method = "AR")
</code></pre>


</div>