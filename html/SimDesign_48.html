<div class="container">

<table style="width: 100%;"><tr>
<td>rejectionSampling</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rejection sampling (i.e., accept-reject method)</h2>

<h3>Description</h3>

<p>This function supports the rejection sampling (i.e., accept-reject) approach
to drawing values from seemingly difficult (probability) density functions
by sampling values from more manageable proxy distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rejectionSampling(
  n,
  df,
  dg,
  rg,
  M,
  method = "optimize",
  interval = NULL,
  logfuns = FALSE,
  maxM = 1e+05,
  parstart = rg(1L),
  ESRS_Mstart = 1.0001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of samples to draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the desired (potentially un-normed) density function to draw
independent samples from. Must be in the form of a <code>function</code> with a
single input corresponding to the values sampled from <code>rg</code>. Function
is assumed to be vectorized (if not, see <code>Vectorize</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dg</code></td>
<td>
<p>the proxy (potentially un-normed) density function to
draw samples from in lieu of drawing samples from <code>df</code>.
The support for this density function should be the same as <code>df</code>
(i.e., when <code>df(x) &gt; 0</code> then <code>dg(x) &gt; 0</code>).
Must be in the form of a <code>function</code> with a single input
corresponding to the values sampled from <code>rg</code>. Function is
assumed to be vectorized (if not, see <code>Vectorize</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rg</code></td>
<td>
<p>the proxy random number generation function, associated with
<code>dg</code>, used to draw proposal samples from.
Must be in the form of a <code>function</code> with a single input corresponding
to the number of values to draw, while the output can either be a vector
or a matrix (if a matrix, each independent observation must be stored in
a unique row). Function is assumed to be vectorized (if not, see
<code>Vectorize</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>the upper-bound of the ratio of probability density functions to help
minimize the number of discarded draws and define the corresponding
rescaled proposal envelope. When missing, <code>M</code> is computed
internally by finding a reasonable maximum of <code>log(df(x)) - log(dg(x))</code>,
and this value is returned to the console.
When both <code>df</code> and <code>dg</code> are true probability density functions
(i.e., integrate to 1) the acceptance probability is equal to 1/M</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>when M is missing, the optimization of M is done either by
finding the mode of the log-density values (<code>"optimize"</code>) or by
using the "Empirical Supremum Rejection Sampling" method (<code>"ESRS"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>when M is missing, for univariate density function draws,
the interval to search within via <code>optimize</code>.
If not specified, a sample of 5000 values from the <code>rg</code>
function definition will be
collected, and the min/max will be obtained via this random sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logfuns</code></td>
<td>
<p>logical; have the <code>df</code> and <code>dg</code> function been
written so as to return log-densities instead of the original densities?
The FALSE default assumes the original densities are returned
(use TRUE when higher accuracy is required when generating each density
definition)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxM</code></td>
<td>
<p>logical; if when optimizing M the value is greater than this
cut-off then stop; ampler would likelihood be too efficient,
or optimization is failing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parstart</code></td>
<td>
<p>starting value vector for optimization of M in
multidimensional distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ESRS_Mstart</code></td>
<td>
<p>starting M value for the ESRS algorithm</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The accept-reject algorithm is a flexible approach to obtaining i.i.d.'s from
a difficult to sample from (probability) density function  where either the
transformation method fails or inverse transform method is
difficult to manage. The algorithm does so by sampling from
a more "well-behaved" proxy distribution (with identical support, up to some
proportionality constant <code>M</code> that reshapes the proposal density
to envelope the target density), and accepts the
draws if they are likely within the target density. Hence, the closer the
shape of <code>dg(x)</code> is to the desired <code>df(x)</code>, the more likely the draws
are to be accepted; otherwise, many iterations of the accept-reject algorithm
may be required, which decreases the computational efficiency.
</p>


<h3>Value</h3>

<p>returns a vector or matrix of draws (corresponding to the
output class from <code>rg</code>) from the desired <code>df</code>
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Caffo, B. S., Booth, J. G., and Davison, A. C. (2002). Empirical supremum
rejection sampling. <code>Biometrika</code>, 89, 745â€“754.
</p>
<p>Chalmers, R. P., &amp; Adkins, M. C.  (2020). Writing Effective and Reliable
Monte Carlo Simulations with the SimDesign Package.
<code>The Quantitative Methods for Psychology, 16</code>(4), 248-280.
<a href="https://doi.org/10.20982/tqmp.16.4.p248">doi:10.20982/tqmp.16.4.p248</a>
</p>
<p>Sigal, M. J., &amp; Chalmers, R. P. (2016). Play it again: Teaching statistics
with Monte Carlo simulation. <code>Journal of Statistics Education, 24</code>(3),
136-156. <a href="https://doi.org/10.1080/10691898.2016.1246953">doi:10.1080/10691898.2016.1246953</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# Generate X ~ beta(a,b), where a and b are a = 2.7 and b = 6.3,
# and the support is Y ~ Unif(0,1)
dfn &lt;- function(x) dbeta(x, shape1 = 2.7, shape2 = 6.3)
dgn &lt;- function(x) dunif(x, min = 0, max = 1)
rgn &lt;- function(n) runif(n, min = 0, max = 1)

# when df and dg both integrate to 1, acceptance probability = 1/M
M &lt;- rejectionSampling(df=dfn, dg=dgn, rg=rgn)
M
dat &lt;- rejectionSampling(10000, df=dfn, dg=dgn, rg=rgn, M=M)
hist(dat, 100)
hist(rbeta(10000, 2.7, 6.3), 100) # compare

# obtain empirical estimate of M via ESRS method
M &lt;- rejectionSampling(1000, df=dfn, dg=dgn, rg=rgn, method='ESRS')
M

# generate using better support function (here, Y ~ beta(2,6)),
#   and use log setup in initial calls (more numerically accurate)
dfn &lt;- function(x) dbeta(x, shape1 = 2.7, shape2 = 6.3, log = TRUE)
dgn &lt;- function(x) dbeta(x, shape1 = 2, shape2 = 6, log = TRUE)
rgn &lt;- function(n) rbeta(n, shape1 = 2, shape2 = 6)
M &lt;- rejectionSampling(df=dfn, dg=dgn, rg=rgn, logfuns=TRUE) # better M
M

## Alternative estimation of M
## M &lt;- rejectionSampling(10000, df=dfn, dg=dgn, rg=rgn, logfuns=TRUE,
##                        method='ESRS')
dat &lt;- rejectionSampling(10000, df=dfn, dg=dgn, rg=rgn, M=M, logfuns=TRUE)
hist(dat, 100)

#------------------------------------------------------
# sample from wonky (and non-normalized) density function, like below
dfn &lt;- function(x){
    ret &lt;- numeric(length(x))
    ret[x &lt;= .5] &lt;- dnorm(x[x &lt;= .5])
    ret[x &gt; .5] &lt;-  dnorm(x[x &gt; .5]) + dchisq(x[x &gt; .5], df = 2)
    ret
}
y &lt;- seq(-5,5, length.out = 1000)
plot(y, dfn(y), type = 'l', main = "Function to sample from")

# choose dg/rg functions that have support within the range [-inf, inf]
rgn &lt;- function(n) rnorm(n, sd=4)
dgn &lt;- function(x) dnorm(x, sd=4)

## example M height from above graphic
##  (M selected using ESRS to help stochastically avoid local mins)
M &lt;- rejectionSampling(10000, df=dfn, dg=dgn, rg=rgn, method='ESRS')
M
lines(y, dgn(y)*M, lty = 2)
dat &lt;- rejectionSampling(10000, df=dfn, dg=dgn, rg=rgn, M=M)
hist(dat, 100, prob=TRUE)

# true density (normalized)
C &lt;- integrate(dfn, -Inf, Inf)$value
ndfn &lt;- function(x) dfn(x) / C
curve(ndfn, col='red', lwd=2, add=TRUE)


#-----------------------------------------------------
# multivariate distribution
dfn &lt;- function(x) sum(log(c(dnorm(x[1]) + dchisq(x[1], df = 5),
                   dnorm(x[2], -1, 2))))
rgn &lt;- function(n) c(rnorm(n, sd=3), rnorm(n, sd=3))
dgn &lt;- function(x) sum(log(c(dnorm(x[1], sd=3), dnorm(x[1], sd=3))))

# M &lt;- rejectionSampling(df=dfn, dg=dgn, rg=rgn, logfuns=TRUE)
dat &lt;- rejectionSampling(5000, df=dfn, dg=dgn, rg=rgn, M=4.6, logfuns=TRUE)
hist(dat[,1], 30)
hist(dat[,2], 30)
plot(dat)



## End(Not run)

</code></pre>


</div>