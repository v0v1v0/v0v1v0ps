<div class="container">

<table style="width: 100%;"><tr>
<td>robsbss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Robust Spatial Blind Source Separation
</h2>

<h3>Description</h3>

<p><code>robsbss</code> is a robust variant of <code>sbss</code>. It estimates the unmixing matrix assuming a spatial blind source separation model by jointly diagonalizing the Hettmansperger-Randles scatter matrix and one/many generalized local sign covariance matrices. These local generalized sign covariance matrices are determined by spatial kernel functions and radial functions. Three types of such kernel functions and three types of radial functions are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">robsbss(x, ...)

## Default S3 method:
robsbss(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, lcov = c('norm', 'winsor', 'qwinsor'), 
     ordered = TRUE, kernel_list = NULL, ...)
## S3 method for class 'SpatialPointsDataFrame'
robsbss(x, ...)
## S3 method for class 'sf'
robsbss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code>SpatialPointsDataFrame</code> or an object of class <code>sf</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which radial function or type of robust local covariance matrix to use. Either <code>'norm'</code> (default), <code>'winsor'</code> or <code>'qwinsor'</code>. See also <br><code>local_gss_covariance_matrix</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared (pseudo-)eigenvalues of the diagonalized local covariance matrix/matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code>frjd</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>robsbss</code> is a robust variant of <code>sbss</code> which uses Hettmansperger-Randles (HR) location and scatter estimates (Hettmansperger &amp; Randles, 2002) for whitening (see <code>white_data</code> for details) and jointly diagonalizes HR scatter matrix and generalized local sign matrices to estimate the unmixing matrix. The generalized local sign matrices are determined by radial functions <code class="reqn">w(l_i)</code>, where <code class="reqn">l_i = ||x(s_i)-T(x)||</code> and <code class="reqn">T(x)</code> is HR location estimator, and kernel functions <code class="reqn">f(d_{i,j})</code>, where <code class="reqn">d_{i,j}=||s_i - s_j||</code>. Generalized local sign covariance (gLSCM) matrix is then calculated as
</p>
<p style="text-align: center;"><code class="reqn">gLSCM(f,w) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j})  w(l_i)w(l_j)(x(s_i)-T(x)) (x(s_j)-T(x))'</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

<p>Three radial functions (Raymaekers &amp; Rousseeuw, 2019) <code class="reqn">w(l_i)</code> are implemented, the parameter <code>lcov</code> defines which is used:
</p>

<ul>
<li> <p><code>'norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = 1/l_i </code>
</p>

</li>
<li> <p><code>'winsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q/l_i </code>
</p>

</li>
<li> <p><code>'qwinsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q^2/l_i^2.</code>
</p>

</li>
</ul>
<p>The cutoff <code class="reqn">Q</code> is defined as <code class="reqn">Q = l_{(h)}</code>, where <code class="reqn">l_{(h)}</code> is <code class="reqn">h</code>th order statistic of <code class="reqn">\{l_1, ..., l_n\}</code> and <code class="reqn">h = (n + p + 1)/2</code>.
In addition, three kernel functions <code class="reqn">f(d)</code> are implemented, the parameter <code>kernel_type</code> defines which is used:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_{in}</code> and outer radius <code class="reqn">r_{out}</code>, with <code class="reqn">r_{in} &lt; r_{out}</code>, and <code class="reqn">r_{in}, r_{out} \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_{in}, r_{out}) = I(r_{in} &lt; d \le r_{out})</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2).</code>
</p>

</li>
</ul>
<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> local covariance matrices are used. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_in1, r_out1, r_in2, r_out2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> local covariance matrices are used.
</p>
<p><code>robsbss</code> calls <code>spatial_kernel_matrix</code> internally to compute a list of <code>c(n,n)</code> kernel matrices based on the parameters given, where each entry of those matrices corresponds to <code class="reqn">f(d_{i,j})</code>. Alternatively, such a list of kernel matrices can be given directly to the function <code>robsbss</code> via the <code>kernel_list</code> argument. This is useful when <code>robsbss</code> is called numerous times with the same coordinates/kernel functions as the computation of the kernel matrices is then done only once prior the actual <code>robsbss</code> calls. For details see also <code>spatial_kernel_matrix</code>.
</p>
<p>If more than one generalized local sign covariance matrix is used <code>robsbss</code> jointly diagonalizes these matrices with the function <code>frjd</code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>robsbss</code> returns a list of class <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>robsbss</code> call.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>numeric vector of <code>length(n)</code> giving the weights for each observation for the robust local covariance estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pevals</code></td>
<td>

<p>(pseudo-)eigenvalues for each latent field entry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c(length(kernel_parameters)*p,p)</code> for <code>'ball'</code> and <code>'gauss'</code> kernel or <code>c(</code>
<code>(length(kernel_parameters) / 2)*p,p)</code> for <code>'ring'</code> kernel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diags</code></td>
<td>

<p>matrix of dimension <code>c(length(kernel_parameters),p)</code> where the rows contain the diagonal of the diagonalized local autocovariance matrices.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>robustly estimated columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>
<p>Raymaekers, J., &amp; Rousseeuw, P. (2019). <em>A generalized spatial sign covariance matrix. Journal of Multivariate Analysis</em>, 171 , 94-111. <a href="https://doi.org/10.1016/j.jmva.2018.11.010">doi:10.1016/j.jmva.2018.11.010</a>.
</p>
<p>Sipila, M., Muehlmann, C. Nordhausen, K. &amp; Taskinen, S. (2022). <em>Robust second order stationary spatial blind source separation using generalized sign matrices</em>. Manuscript.
</p>


<h3>See Also</h3>

<p><code>spatial_kernel_matrix</code>, <code>local_gss_covariance_matrix</code>, <code>sp</code>, <code>sf</code>, <code>frjd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  # Generate 5 % local outliers to data
  field_cont &lt;- gen_loc_outl(field, coords, radius = 2, 
                             swap_order = "regular")[,1:3]
  X &lt;- as.matrix(field_cont)
  
  # apply sbss with three ring kernels
  kernel_parameters &lt;- c(0, 1, 1, 2, 2, 3)
  robsbss_result &lt;- 
    robsbss(X, coords, kernel_type = 'ring', kernel_parameters = kernel_parameters)
  
  # print object
  print(robsbss_result)
  
  # plot latent field
  plot(robsbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid
  predict(robsbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix
  w_unmix &lt;- coef(robsbss_result)
}
</code></pre>


</div>