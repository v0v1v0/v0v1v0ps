<div class="container">

<table style="width: 100%;"><tr>
<td>SAGM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SAGM</h2>

<h3>Description</h3>

<p>This function applies the spatial autoregressive graphical model on a given dataset and array of spatial weight matrices. Different identifiability constraints can be imposed to estimate the <code class="reqn">\Psi_k</code>. The method allows for both normal and normal-gamma priors, where the values for the hyperparameters can be specified by the user. Returns posterior samples for <code class="reqn">\Theta_{E}</code> and the <code class="reqn">\Psi_k</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SAGM(X, W, prior, constraint, triangular, idx_mat, zeta, kappa, b0, b1,
nBurnin, nIter, verbose)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix, where <code class="reqn">n</code> is the number of observations and <code class="reqn">p</code> is the number of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A <code class="reqn">n \times n \times 2</code> array, where the 2 generated spatial matrices are stacked. Note that the order in which the weight matrices are stacked corresponds to the order of the estimated spatial effect matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>Prior choice on the spatial effects. Either normal (<code>"normal"</code>) or normal-gamma (<code>"ng"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraint</code></td>
<td>
<p>Identifiability constraint on the spatial effects. Either symmetric (<code>"symmetric"</code>), triangular (<code>"triangular"</code>) or informative (<code>"informative"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>triangular</code></td>
<td>
<p>Type of triangular restriction. Can be upper-triangular, or lower-triangular, or both, e.g. <code>triangular = c("upper","upper")</code>. Only has an effect whenever <code>constraint = "triangular"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx_mat</code></td>
<td>
<p>A <code class="reqn">\code{nknown} \times 5 \times</code> matrix, where <code>nknown</code> is the number of known spatial effects. This matrix contains the indices, means and standard deviations of the known spatial effects that is specified by the user. The matrix only needs to be specified whenever <code>constraint = "informative"</code> is entered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>
<p>Value of hyperparameter <code class="reqn">\zeta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Value of hyperparameter <code class="reqn">\kappa</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Value of hyperparameter <code class="reqn">b_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>Value of hyperparameter <code class="reqn">b_1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBurnin</code></td>
<td>
<p>Number of burnin samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>Number of post-burnin Gibbs samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Return progress of parameter estimation (<code>True</code>) or not (<code>False</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>A <code class="reqn">p \times p \times \code{nIter}</code> array consisting of the post-burnin samples for the within-plot dependencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Psi</code></td>
<td>
<p>A <code class="reqn">p \times p \times 2 \times \code{nIter}</code> array consisting of the post-burnin samples for the between-plot effects. The order of the third dimension of the array corresponds to that of the <code>W</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_sq</code></td>
<td>
<p>A <code class="reqn">p \times p \times \code{nIter}</code> array consisting of the post-burnin samples for <code class="reqn">\Lambda^2</code>. This output is of secondary interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau_sq</code></td>
<td>
<p>A vector of length <code>nIter</code> consisting of the post-burnin samples for <code class="reqn">\tau^2</code>. This output is of secondary interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accpt_rate</code></td>
<td>
<p>Value of the acceptance rate of the Metropolis Hastings step.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Sjoerd Hermes, Joost van Heerwaarden and Pariya Behrouzi<br>
Maintainer: Sjoerd Hermes <a href="mailto:sjoerd.hermes@wur.nl">sjoerd.hermes@wur.nl</a>
</p>


<h3>References</h3>

<p>1. Hermes, S., van Heerwaarden, J., and Behrouzi, P. (2023). A Spatial Autoregressive Graphical Model with Applications in Intercropping. arXiv preprint, arXiv:2308.04325. <br></p>


<h3>Examples</h3>

<pre><code class="language-R">
data(intercrop)
n &lt;- nrow(intercrop)

W &lt;- make_weights(n)

# Suppose we have 16 known effects. Here we assign informative normal
# priors to these effects
idx_mat &lt;- matrix(NA, 16, 5)
idx_mat[1,] &lt;- c(1,1,1,1, 0.1)
idx_mat[2,] &lt;- c(1,2,1,1, 0.1)
idx_mat[3,] &lt;- c(1,3,1,1, 0.1)
idx_mat[4,] &lt;- c(1,1,2,1, 0.1)
idx_mat[5,] &lt;- c(1,2,2,1, 0.1)
idx_mat[6,] &lt;- c(1,3,2,1, 0.1)
idx_mat[7,] &lt;- c(4,1,1,-1, 0.1)
idx_mat[8,] &lt;- c(4,2,1,-1, 0.1)
idx_mat[9,] &lt;- c(4,3,1,-1, 0.1)
idx_mat[10,] &lt;- c(4,4,1,-1, 0.1)
idx_mat[11,] &lt;- c(4,1,2,-1, 0.1)
idx_mat[12,] &lt;- c(4,2,2,-1, 0.1)
idx_mat[13,] &lt;- c(4,3,2,-1, 0.1)
idx_mat[14,] &lt;- c(4,4,2,-1, 0.1)
idx_mat[15,] &lt;- c(2,3,1,-1, 0.1)
idx_mat[16,] &lt;- c(2,3,2,-1, 0.1)

W &lt;- array(c(W$W_BA, W$W_AB), dim = c(n,n,2))
est &lt;- SAGM(X = intercrop, W = W, prior = "normal", constraint = "informative",
triangular = c("upper","upper"), idx_mat = idx_mat, zeta = 0.1, kappa = 0.1,
b0 = 0.01, b1 = 0.01, nBurnin = 1000, nIter = 1000, verbose = TRUE)

</code></pre>


</div>