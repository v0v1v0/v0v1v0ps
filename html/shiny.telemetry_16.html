<div class="container">

<table style="width: 100%;"><tr>
<td>Telemetry</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Telemetry class to manage analytics gathering at a global level</h2>

<h3>Description</h3>

<p>An instance of this class will define metadata and data storage provider
for gathering telemetry analytics of a Shiny dashboard.
</p>
<p>The <code>name</code> and <code>version</code> parameters will describe the dashboard name and
version to track using analytics, allowing to store the analytics data from
multiple dashboards in the same data storage provider. As well as
discriminate different versions of the dashboard.
</p>
<p>The default data storage provider uses a local SQLite database, but this
can be customizable when instantiating the class, by using another one of
the supported providers (see <code>DataStorage</code>).
</p>


<h3>Debugging</h3>

<p>Events are logged at the <code>DEBUG</code> level using the <code>logger</code> package.
To see the logs, you can set:
</p>
<div class="sourceCode r"><pre>logger::log_threshold("DEBUG", namespace = "shiny.telemetry")
</pre></div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>data_storage</code></dt>
<dd>
<p>instance of a class that inherits from
<code>DataStorage</code>. See the documentation on that class for more information.</p>
</dd>
<dt><code>app_name</code></dt>
<dd>
<p>string with name of dashboard</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Telemetry-new"><code>Telemetry$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-start_session"><code>Telemetry$start_session()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_navigation"><code>Telemetry$log_navigation()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_navigation_manual"><code>Telemetry$log_navigation_manual()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_login"><code>Telemetry$log_login()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_logout"><code>Telemetry$log_logout()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_click"><code>Telemetry$log_click()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_browser_version"><code>Telemetry$log_browser_version()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_button"><code>Telemetry$log_button()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_all_inputs"><code>Telemetry$log_all_inputs()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_input"><code>Telemetry$log_input()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_input_manual"><code>Telemetry$log_input_manual()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_custom_event"><code>Telemetry$log_custom_event()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_error"><code>Telemetry$log_error()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-log_errors"><code>Telemetry$log_errors()</code></a>
</p>
</li>
<li> <p><a href="#method-Telemetry-clone"><code>Telemetry$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Telemetry-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Constructor that initializes Telemetry instance with parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$new(
  app_name = "(dashboard)",
  data_storage = DataStorageSQLite$new(db_path = file.path("telemetry.sqlite"))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>app_name</code></dt>
<dd>
<p>(optional) string that identifies the name of the dashboard.
By default it will store data with <code>(dashboard)</code>.</p>
</dd>
<dt><code>data_storage</code></dt>
<dd>
<p>(optional) <code>DataStorage</code> instance where telemetry
data is being stored.
It can take any of data storage providers by this package,
By default it will store in a SQLite local database in the current
working directory with filename <code>telemetry.sqlite</code></p>
</dd>
<dt><code>version</code></dt>
<dd>
<p>(optional) string that identifies the version of the
dashboard. By default it will use <code>v0.0.0</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Telemetry-start_session"></a>



<h4>Method <code>start_session()</code>
</h4>

<p>Setup basic telemetry
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$start_session(
  track_inputs = TRUE,
  track_values = FALSE,
  login = TRUE,
  logout = TRUE,
  browser_version = TRUE,
  navigation_input_id = NULL,
  session = shiny::getDefaultReactiveDomain(),
  username = NULL,
  track_anonymous_user = TRUE,
  track_errors = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>track_inputs</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the inputs that change value. <code>TRUE</code> by default</p>
</dd>
<dt><code>track_values</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the values of the inputs that are changing. <code>FALSE</code> by default.
This parameter is ignored if <code>track_inputs</code> is <code>FALSE</code></p>
</dd>
<dt><code>login</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track when a session starts. <code>TRUE</code> by default.</p>
</dd>
<dt><code>logout</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track when the session ends. <code>TRUE</code> by default.</p>
</dd>
<dt><code>browser_version</code></dt>
<dd>
<p>flag that indicates that the browser version
should be tracked.<code>TRUE</code> by default.</p>
</dd>
<dt><code>navigation_input_id</code></dt>
<dd>
<p>string or vector of strings that represent
input ids and which value should be tracked as navigation events. i.e.
a change in the value represent a navigation to a page or tab.
By default, no navigation is tracked.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
<dt><code>username</code></dt>
<dd>
<p>Character with username. If set, it will overwrite username
from session object.</p>
</dd>
<dt><code>track_anonymous_user</code></dt>
<dd>
<p>flag that indicates to track anonymous user.
A cookie is used to track same user without login over multiple sessions,
This is only activated if none of the automatic methods produce a username
and when a username is not explicitly defined.<code>TRUE</code> by default.</p>
</dd>
<dt><code>track_errors</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the errors. <code>TRUE</code> by default. if using shiny version &lt; <code style="white-space: pre;">⁠1.8.1⁠</code>,
it can auto log errors only in UI output functions.
By using latest versions of shiny, it can auto log all types of errors.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_navigation"></a>



<h4>Method <code>log_navigation()</code>
</h4>

<p>Log an input change as a navigation event
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_navigation(input_id, session = shiny::getDefaultReactiveDomain())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_id</code></dt>
<dd>
<p>string that identifies the generic input in the Shiny
application so that the function can track and log changes to it.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_navigation_manual"></a>



<h4>Method <code>log_navigation_manual()</code>
</h4>

<p>Log a navigation event manually by indicating the id (as input id)
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_navigation_manual(
  navigation_id,
  value,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>navigation_id</code></dt>
<dd>
<p>string that identifies navigation event.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>string that indicates a value for the navigation</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_login"></a>



<h4>Method <code>log_login()</code>
</h4>

<p>Log when session starts
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_login(
  username = NULL,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt>
<dd>
<p>string with username from current session</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_logout"></a>



<h4>Method <code>log_logout()</code>
</h4>

<p>Log when session ends
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_logout(
  username = NULL,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>username</code></dt>
<dd>
<p>string with username from current session</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_click"></a>



<h4>Method <code>log_click()</code>
</h4>

<p>Log an action click
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_click(id, session = shiny::getDefaultReactiveDomain())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>string that identifies a manual click to the dashboard.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_browser_version"></a>



<h4>Method <code>log_browser_version()</code>
</h4>

<p>Log the browser version
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_browser_version(session = shiny::getDefaultReactiveDomain())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_button"></a>



<h4>Method <code>log_button()</code>
</h4>

<p>Track a button and track changes to this input (without storing the
values)
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_button(
  input_id,
  track_value = FALSE,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_id</code></dt>
<dd>
<p>string that identifies the button in the Shiny
application so that the function can track and log changes to it.</p>
</dd>
<dt><code>track_value</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the value of the input that are changing. <code>FALSE</code> by default.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_all_inputs"></a>



<h4>Method <code>log_all_inputs()</code>
</h4>

<p>Automatic tracking of all input changes in the App. Depending on the
parameters, it may only track a subset of inputs by excluding patterns
or by including specific vector of <code>input_ids</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_all_inputs(
  track_values = FALSE,
  excluded_inputs = c("browser_version"),
  excluded_inputs_regex = NULL,
  include_input_ids = NULL,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>track_values</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the values of the inputs that are changing. <code>FALSE</code> by default.
This parameter is ignored if <code>track_inputs</code> is <code>FALSE</code>.</p>
</dd>
<dt><code>excluded_inputs</code></dt>
<dd>
<p>vector of input_ids that should not be tracked.
By default it doesn't track browser version, which is added by this
package.</p>
</dd>
<dt><code>excluded_inputs_regex</code></dt>
<dd>
<p>vector of input_ids that should not be
tracked. All Special characters will be escaped.</p>
</dd>
<dt><code>include_input_ids</code></dt>
<dd>
<p>vector of input_ids that will be tracked.
This input_ids should be an exact match and will be given priority
over exclude list.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_input"></a>



<h4>Method <code>log_input()</code>
</h4>

<p>Track changes of a specific input id.
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_input(
  input_id,
  track_value = FALSE,
  matching_values = NULL,
  input_type = "text",
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_id</code></dt>
<dd>
<p>string (or vector of strings) that identifies the
generic input in the Shiny application so that the function can track and
log changes to it.
</p>
<p>When the <code>input_id</code> is a vector of strings, the function will behave just
as calling <code>log_input</code> one by one with the same arguments.</p>
</dd>
<dt><code>track_value</code></dt>
<dd>
<p>flag that indicates if the basic telemetry should
track the value of the input that are changing. <code>FALSE</code> by default.</p>
</dd>
<dt><code>matching_values</code></dt>
<dd>
<p>An object specified possible values to register.</p>
</dd>
<dt><code>input_type</code></dt>
<dd>
<p><code>"text"</code> to registered bare input value, <code>"json"</code> to parse
value from <code>JSON</code> format.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for its side effects.
</p>


<hr>
<a id="method-Telemetry-log_input_manual"></a>



<h4>Method <code>log_input_manual()</code>
</h4>

<p>Log a manual input value.
</p>
<p>This can be called in telemetry and is also used as a layer between
log_input family of functions and actual log event.
It creates the correct payload to log the event internally.
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_input_manual(
  input_id,
  value = NULL,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_id</code></dt>
<dd>
<p>string that identifies the generic input in the Shiny
application so that the function can track and log changes to it.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>(optional) scalar value or list with the value to register.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_custom_event"></a>



<h4>Method <code>log_custom_event()</code>
</h4>

<p>Log a manual event
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_custom_event(
  event_type,
  details = NULL,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>event_type</code></dt>
<dd>
<p>string that identifies the event type</p>
</dd>
<dt><code>details</code></dt>
<dd>
<p>(optional) scalar value or list with the value to register.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current
Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_error"></a>



<h4>Method <code>log_error()</code>
</h4>

<p>Log a manual error event
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_error(
  output_id,
  message,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output_id</code></dt>
<dd>
<p>string that refers to the output element where the error occurred.</p>
</dd>
<dt><code>message</code></dt>
<dd>
<p>string that describes the error.</p>
</dd>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-log_errors"></a>



<h4>Method <code>log_errors()</code>
</h4>

<p>Track errors as they occur in observe and reactive
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$log_errors(session = shiny::getDefaultReactiveDomain())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>session</code></dt>
<dd>
<p><code>ShinySession</code> object or NULL to identify the current Shiny session.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing. This method is called for side effects.
</p>


<hr>
<a id="method-Telemetry-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Telemetry$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>DataStorage</code> which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class="language-R">log_file_path &lt;- tempfile(fileext = ".txt")
telemetry &lt;- Telemetry$new(
  data_storage = DataStorageLogFile$new(log_file_path = log_file_path)
) # 1. Initialize telemetry with default options

#
# Use in a shiny application

if (interactive()) {
  library(shiny)

  shinyApp(
    ui = fluidPage(
      use_telemetry(), # 2. Add necessary javascript to Shiny
      numericInput("n", "n", 1),
      plotOutput('plot')
    ),
    server = function(input, output) {
      telemetry$start_session() # 3. Minimal setup to track events
      output$plot &lt;- renderPlot({ hist(runif(input$n)) })
    }
  )
}

#
# Manual logging of Telemetry that can be used inside Shiny Application
# to further customize the events to be tracked.

session &lt;- shiny::MockShinySession$new() # Create dummy session (only for example purposes)
class(session) &lt;- c(class(session), "ShinySession")

telemetry$log_click("a_button", session = session)

telemetry$log_error("global", message = "An error has occured")

telemetry$log_custom_event("a_button", list(value = 2023), session = session)
telemetry$log_custom_event("a_button", list(custom_field = 23), session = session)

# Manual call login with custom username
telemetry$log_login("ben", session = session)

# Read all data
telemetry$data_storage$read_event_data()

file.remove(log_file_path)

#
# Using SQLite

db_path &lt;- tempfile(fileext = ".sqlite")
telemetry_sqlite &lt;- Telemetry$new(
  data_storage = DataStorageSQLite$new(db_path = db_path)
)

telemetry_sqlite$log_custom_event("a_button", list(value = 2023), session = session)
telemetry_sqlite$log_custom_event("a_button", list(custom_field = 23), session = session)

# Read all data from time range
telemetry_sqlite$data_storage$read_event_data("2020-01-01", "2055-01-01")

file.remove(db_path)

</code></pre>


</div>