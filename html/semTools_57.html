<div class="container">

<table style="width: 100%;"><tr>
<td>lavTestScore.mi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score Test for Multiple Imputations</h2>

<h3>Description</h3>

<p>Score test (or "Lagrange multiplier" test) for lavaan models fitted to
multiple imputed data sets. Statistics for releasing one or more
fixed or constrained parameters in model can be calculated by pooling
the gradient and information matrices pooled across imputed data sets in a
method proposed by Mansolf, Jorgensen, &amp; Enders (2020)—analogous to
the "D1" Wald test proposed by Li, Meng, Raghunathan, &amp; Rubin's (1991)—or
by pooling the complete-data score-test statistics across imputed data sets
(i.e., "D2"; Li et al., 1991).
</p>


<h3>Usage</h3>

<pre><code class="language-R">lavTestScore.mi(object, add = NULL, release = NULL, test = c("D2", "D1"),
  scale.W = !asymptotic, omit.imps = c("no.conv", "no.se"),
  asymptotic = is.null(add), univariate = TRUE, cumulative = FALSE,
  epc = FALSE, standardized = epc, cov.std = epc, verbose = FALSE,
  warn = TRUE, information = "expected")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>lavaan.mi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>Either a <code>character</code> string (typically between single
quotes) or a parameter table containing additional (currently
fixed-to-zero) parameters for which the score test must be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>release</code></td>
<td>
<p>Vector of <code>integer</code>s. The indices of the <em>equality</em>
constraints that should be released. The indices correspond to the order of
the equality constraints as they appear in the parameter table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
<code>"D1"</code> requests Mansolf, Jorgensen, &amp; Enders' (2020) proposed
Wald-like test for pooling the gradient and information, which are then
used to calculate score-test statistics in the usual manner. <code>"D2"</code>
(default because it is less computationall intensive) requests to pool the
complete-data score-test statistics from each imputed data set, then pool
them across imputations, described by Li et al. (1991) and Enders (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.W</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the pooled
information matrix is calculated as the weighted sum of the
within-imputation and between-imputation components. Otherwise, the pooled
information is calculated by scaling the within-imputation component by
the average relative increase in variance (ARIV; Enders, 2010, p. 235),
which is <em>only</em> consistent when requesting the <em>F</em> test (i.e.,
<code>asymptotic = FALSE</code>.  Ignored (irrelevant) if <code>test = "D2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any "improper solutions" such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asymptotic</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code> (default when using
<code>add</code> to test adding fixed parameters to the model), the pooled test
will be returned as an <em>F</em>-distributed variable with numerator
(<code>df1</code>) and denominator (<code>df2</code>) degrees of freedom.
If <code>TRUE</code>, the pooled <em>F</em> statistic will be multiplied by its
<code>df1</code> on the assumption that its <code>df2</code> is sufficiently large
enough that the statistic will be asymptotically <code class="reqn">\chi^2</code> distributed
with <code>df1</code>. When using the <code>release</code> argument, <code>asymptotic</code>
will be set to <code>TRUE</code> because (A)RIV can only be calculated for
<code>add</code>ed parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>univariate</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, compute the univariate
score statistics, one for each constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, order the univariate score
statistics from large to small, and compute a series of multivariate
score statistics, each time including an additional constraint in the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epc</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, and we are releasing existing
constraints, compute the expected parameter changes for the existing
(free) parameters (and any specified with <code>add</code>), if all constraints
were released. For EPCs associated with a particular (1-<em>df</em>)
constraint, only specify one parameter in <code>add</code> or one constraint in
<code>release</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>If <code>TRUE</code>, two extra columns (<code>sepc.lv</code> and
<code>sepc.all</code>) in the <code>$epc</code> table will contain standardized values
for the EPCs. See <code>lavTestScore</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.std</code></td>
<td>
<p><code>logical</code>. See <code>standardizedSolution</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>. Not used for now.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, print warnings if they occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>information</code></td>
<td>
<p><code>character</code> indicating the type of information
matrix to use (check <code>lavInspect</code> for available options).
<code>"expected"</code> information is the default, which provides better
control of Type I errors.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing at least one <code>data.frame</code>:
</p>

<ul>
<li>
<p><code>$test</code>: The total score test, with columns for the score
test statistic (<code>X2</code>), its degrees of freedom (<code>df</code>), its
<em>p</em> value under the <code class="reqn">\chi^2</code> distribution (<code>p.value</code>),
and if <code>asymptotic=FALSE</code>, the average relative invrease in
variance (ARIV) used to calculate the denominator <em>df</em> is also
returned as a missing-data diagnostic, along with the fraction missing
information (FMI = ARIV / (1 + ARIV)).
</p>
</li>
<li>
<p><code>$uni</code>: Optional (if <code>univariate=TRUE</code>).
Each 1-<em>df</em> score test, equivalent to modification indices. Also
includes EPCs if <code>epc=TRUE</code>, and RIV and FMI if
<code>asymptotic=FALSE</code>.
</p>
</li>
<li>
<p><code>$cumulative</code>: Optional (if <code>cumulative=TRUE</code>).
Cumulative score tests, with ARIV and FMI if <code>asymptotic=FALSE</code>.
</p>
</li>
<li>
<p><code>$epc</code>: Optional (if <code>epc=TRUE</code>). Parameter estimates,
expected parameter changes, and expected parameter values if ALL
the tested constraints were freed.
</p>
</li>
</ul>
<p>See <code>lavTestScore</code> for details.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Adapted from <span class="pkg">lavaan</span> source code, written by
Yves Rosseel (Ghent University; <a href="mailto:Yves.Rosseel@UGent.be">Yves.Rosseel@UGent.be</a>)
</p>
<p><code>test = "D1"</code> method proposed by
Maxwell Mansolf (University of California, Los Angeles;
<a href="mailto:mamansolf@gmail.com">mamansolf@gmail.com</a>)
</p>


<h3>References</h3>

<p>Bentler, P. M., &amp; Chou, C.-P. (1992). Some new covariance structure model
improvement statistics. <em>Sociological Methods &amp; Research, 21</em>(2),
259–282. <a href="https://doi.org/10.1177/0049124192021002006">doi:10.1177/0049124192021002006</a>
</p>
<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data. <em>Statistica Sinica, 1</em>(1), 65–92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Mansolf, M., Jorgensen, T. D., &amp; Enders, C. K. (2020). A multiple
imputation score test for model modification in structural equation
models. <em>Psychological Methods, 25</em>(4), 393–411.
<a href="https://doi.org/10.1037/met0000243">doi:10.1037/met0000243</a>
</p>


<h3>See Also</h3>

<p><code>lavTestScore</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> ## Not run: 
## impose missing data for example
HSMiss &lt;- HolzingerSwineford1939[ , c(paste("x", 1:9, sep = ""),
                                      "ageyr","agemo","school")]
set.seed(12345)
HSMiss$x5 &lt;- ifelse(HSMiss$x5 &lt;= quantile(HSMiss$x5, .3), NA, HSMiss$x5)
age &lt;- HSMiss$ageyr + HSMiss$agemo/12
HSMiss$x9 &lt;- ifelse(age &lt;= quantile(age, .3), NA, HSMiss$x9)

## impute missing data
library(Amelia)
set.seed(12345)
HS.amelia &lt;- amelia(HSMiss, m = 20, noms = "school", p2s = FALSE)
imps &lt;- HS.amelia$imputations

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  speed =~ c(L1, L1)*x7 + c(L1, L1)*x8 + c(L1, L1)*x9
'

out &lt;- cfa.mi(HS.model, data = imps, group = "school", std.lv = TRUE)

## Mode 1: Score test for releasing equality constraints

## default test: Li et al.'s (1991) "D2" method
lavTestScore.mi(out, cumulative = TRUE)
## Li et al.'s (1991) "D1" method
lavTestScore.mi(out, test = "D1")

## Mode 2: Score test for adding currently fixed-to-zero parameters
lavTestScore.mi(out, add = 'x7 ~~ x8 + x9')


## End(Not run)

</code></pre>


</div>