<div class="container">

<table style="width: 100%;"><tr>
<td>convert_monthly_to_seasonal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert a data table from monthly to seasonal format</h2>

<h3>Description</h3>

<p>Converts monthly to seasonal data. The function default values are set for precipitation. In particular, default behavior is to <em>sum</em>
values over all months contained in a season. If you want to average instead (for temperature, for example), you can change the aggregation function <code>FUN</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convert_monthly_to_seasonal(
  dt,
  vars = NULL,
  by = NULL,
  FUN = sum,
  ...,
  seasons = c("MAM", "JJAS", "OND"),
  only_complete_seasons = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A data table containing the values for conversion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>Character vector of names of the columns containing the values for conversion. Default is to try converting everything that is not contained in <code>by</code> and that is not recognized as tercile category (see <code>tc_cols()</code>) or
tercile forecast (<code>'below'</code>, <code>'normal'</code>, <code>'above'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>Character vector of column names to group by. Separate values are derived for each unique combination of values in <code>by</code>.
Defaults to all <code>dimvars()</code> that are not <code>'month'</code>, which is usually what you want.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>function for aggregation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>FUN</code>, for example <code>na.rm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seasons</code></td>
<td>
<p>Vector of character strings specifying seasons. See details. Defaults to <code>c('MAM', 'JJAS', 'OND')</code>, which are the seasons considered in the COFs for the Greater Horn of Africa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only_complete_seasons</code></td>
<td>
<p>Logical. If <code>TRUE</code>, only values are kept for which we have data for all months. For example, no <code>OND</code> values would be derived if the data for December is missing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that it is impossible to derive seasonal tercile categories from monthly ones (and similar for seasonal tercile forecasts). For getting these, you should convert to seasonal
<em>before</em> deriving the tercile categories or forecasts, e.g. by using <code>add_tercile_cat()</code> or <code>tfc_from_efc()</code>.
</p>
<p>Seasons are provided as sequences of capitalized initial characters of the months they contain, e.g. <code>'MAM'</code> for March-April-May.
They can have any length from 1 to 12 months and are allowed to overlap and wrap over the end of the year
(for example, you can provide <code>seasons = c('OND', 'NDJ')</code> to derive values for October-December and November-January).
If a season includes months from 2 years, it gets assigned the year of its starting month. For example, <code>season = 'NDJ'</code> and <code>year = 2000</code> refers to values for the season November 2000 to January 2001.
</p>
<p>Factor- or Character-valued columns cannot be aggregated to seasonal values. If <code>vars</code> contains columns that are factor- or character-valued, it checks whether they take a unique value for each grouping level
provided in <code>by</code>. If yes, they are kept, else they are discarded. A typical case where this is useful is when your data table contains country names (see <code>add_country()</code>).
The grouping levels usually include <code>'lon'</code>, <code>'lat'</code>, so there is only one country name per grouping level and the name is kept.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# returns empty data table, because the example data does not contain data for a full season:
dt = convert_monthly_to_seasonal(chirps_monthly)

# remove terc_cat first to avoid the warning,
# and set season to the months we actually have data for:
dt2 = convert_monthly_to_seasonal(copy(chirps_monthly)[,terc_cat := NULL], seasons = c('ND'))
print(dt2)

# season OND, get monthly averages rather than sums, and force the function to derive values
# even though we do not have October-data:
dt3 = convert_monthly_to_seasonal(chirps_monthly,
                                  seasons = c('OND'),
                                  FUN = mean,
                                  only_complete_seasons = FALSE)
print(dt3)

</code></pre>


</div>