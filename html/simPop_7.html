<div class="container">

<table style="width: 100%;"><tr>
<td>calibPop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibration of 0/1 weights by Simulated Annealing</h2>

<h3>Description</h3>

<p>A Simulated Annealing Algorithm for calibration of synthetic population data
available in a <code>simPopObj</code>-object. The aims is to find,
given a population, a combination of different households which optimally
satisfy, in the sense of an acceptable error, a given table of specific
known marginals. The known marginals are also already available in slot
'table' of the input object 'inp'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calibPop(
  inp,
  split = NULL,
  splitUpper = NULL,
  temp = 1,
  epsP.factor = 0.05,
  epsH.factor = 0.05,
  epsMinN = 0,
  maxiter = 200,
  temp.cooldown = 0.9,
  factor.cooldown = 0.85,
  min.temp = 10^-3,
  nr_cpus = NULL,
  sizefactor = 2,
  choose.temp = TRUE,
  choose.temp.factor = 0.2,
  scale.redraw = 0.5,
  observe.times = 50,
  observe.break = 0.05,
  n.forceCooldown = 100,
  verbose = FALSE,
  hhTables = NULL,
  persTables = NULL,
  redist.var = NULL,
  redist.var.factor = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>inp</code></td>
<td>
<p>an object of class <code>simPopObj</code> with slot
'table' being non-null! (see <code>addKnownMargins</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>given strata in which the problem will be split. Has to
correspond to a column population data (slot 'pop' of input argument 'inp')
. For example <code>split = (c("region")</code>, problem will be split for
different regions. Parallel computing is performed automatically, if
possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitUpper</code></td>
<td>
<p>optional column in the population for which decides the part
of the population from which to sample for each entry in <code>split</code>.
Has to correspond to a column population data (slot 'pop' of input argument 'inp').
For example <code>split = c("region"), splitUpper = c("Country")</code>
all units from the country are eligable for donor sample when problem is split
into regions. Is usefull if <code>simInitSpatial()</code> was used and the variable to split
the problem into results in very small groups (~couple of hundreds to thousands).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp</code></td>
<td>
<p>starting temperatur for simulated annealing algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsP.factor</code></td>
<td>
<p>a factor (between 0 and 1) specifying the acceptance
error for contingency table on individual level. For example epsP.factor = 0.05 results in an acceptance error for the
objective function of <code>0.05*sum(People)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsH.factor</code></td>
<td>
<p>a factor (between 0 and 1) specifying the acceptance
error for contingency table on household level. For example epsH.factor = 0.05 results in an acceptance error for the
objective function of <code>0.05*sum(Households)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsMinN</code></td>
<td>
<p>integer specifying the minimum number of units from which the synthetic populatin can deviate from cells in contingency tables.
This overwrites <code>epsP.factor</code> and <code>epsH.factor</code>. Is especially usefull if cells in <code>hhTables</code> and <code>persTables</code> are very small, e.g. &lt;10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum iterations during a temperature step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp.cooldown</code></td>
<td>
<p>a factor (between 0 and 1) specifying the rate at which
temperature will be reduced in each step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor.cooldown</code></td>
<td>
<p>a factor (between 0 and 1) specifying the rate at
which the number of permutations of housholds, in each iteration, will be
reduced in each step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.temp</code></td>
<td>
<p>minimal temperature at which the algorithm will stop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_cpus</code></td>
<td>
<p>if specified, an integer number defining the number of cpus
that should be used for parallel processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizefactor</code></td>
<td>
<p>the factor for inflating the population before applying 0/1 weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choose.temp</code></td>
<td>
<p>if TRUE <code>temp</code> will be rescaled according to <code>eps</code> and <code>choose.temp.factor</code>. <code>eps</code> is defined by the product between <code>epsP.factor</code> and <code>epsP.factor</code> with the sum over the target population margins supplied by <code>addKnownMargins</code> or <code>hhTables</code> and <code>persTables</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choose.temp.factor</code></td>
<td>
<p>number between (0,1) for rescaling <code>temp</code> for simulated annealing. <code>temp</code> redefined by<code>max(temp,eps*choose.temp.factor)</code>.
Can be usefull if simulated annealing is split into subgroups with considerably different population sizes. Only used if <code>choose.temp=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.redraw</code></td>
<td>
<p>Number between (0,1) scaling the number of households that need to be drawn and discarded in each iteration step.
The number of individuals currently selected through simulated annealing is substracted from the sum over the target population margins added to <code>inp</code> via <code>addKnownMargins</code>.
This difference is divided by the median household size resulting in an estimated number of housholds that the current synthetic population differs from the population margins (~<code>redraw_gap</code>).
The next iteration will then adjust the number of housholds to be drawn or discarded (<code>redraw</code>) according to <code>max(ceiling(redraw-redraw_gap*scale.redraw),1)</code> or <code>max(ceiling(redraw+redraw_gap*scale.redraw),1)</code> respectively.
This keeps the number of individuals in the synthetic population relatively stable regarding the population margins. Otherwise the synthetic population might be considerably larger or smaller then the population margins, through selection of many large or small households.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observe.times</code></td>
<td>
<p>Number of times the new value of the objective function is saved. If <code>observe.times=0</code> values are not saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observe.break</code></td>
<td>
<p>When objective value has been saved <code>observe.times</code>-times the coefficient of variation is calculated over saved values; if the coefficient of variation falls below <code>observe.break</code>
simmulated annealing terminates. This repeats for each new set of <code>observe.times</code> new values of the objecive function. Can help save run time if objective value does not improve much. Disable this termination by either setting <code>observe.times=0</code> or <code>observe.break=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.forceCooldown</code></td>
<td>
<p>integer, if the solution does not move for <code>n.forceCooldown</code> iterations then a cooldown is automatically done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean variable; if TRUE some additional verbose output is
provided, however only if <code>split</code> is NULL. Otherwise the computation is
performed in parallel and no useful output can be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hhTables</code></td>
<td>
<p>information on population margins for households</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>persTables</code></td>
<td>
<p>information on population margins for persons</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redist.var</code></td>
<td>
<p>single column in the population which can be redistributed in each 'split'. Still experimental!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redist.var.factor</code></td>
<td>
<p>numeric in the interval (0,1]. Used in combinationo with 'redist.var', still experimental!</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calibrates data using simulated annealing. The algorithm searches for a
(near) optimal combination of different households, by swaping housholds at
random in each iteration of each temperature level. During the algorithm as
well as for the output the optimal (or so far best) combination will be
indicated by a logical vector containg only 0s (not inculded) and 1s
(included in optimal selection). The objective function for simulated
annealing is defined by the sum of absolute differences between target
marginals and synthetic marginals (=marginals of synthetic dataset). The sum
of target marginals can at most be as large as the sum of target marginals.
For every factor-level in “split”, data must at least contain as many
entries of this kind as target marginals.
</p>
<p>Possible donors are automatically generated within the procedure.
</p>
<p>The number of cpus are selected automatically in the following manner. The
number of cpus is equal the number of strata. However, if the number of cpus
is less than the number of strata, the number of cpus - 1 is used by
default.  This should be the best strategy, but the user can also overwrite
this decision.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>simPopObj</code> with an
updated population listed in slot 'pop'.
</p>


<h3>Author(s)</h3>

<p>Bernhard Meindl, Johannes Gussenbauer and Matthias Templ
</p>


<h3>References</h3>

<p>M. Templ, B. Meindl, A. Kowarik, A. Alfons, O. Dupriez (2017) Simulation of Synthetic Populations for Survey Data Considering Auxiliary
Information. <em>Journal of Statistical Survey</em>, <strong>79</strong> (10), 1–38. <a href="https://doi.org/10.18637/jss.v079.i10">doi:10.18637/jss.v079.i10</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(eusilcS) # load sample data
data(eusilcP) # population data
## Not run: 
inp &lt;- specifyInput(data=eusilcS, hhid="db030", hhsize="hsize", strata="db040", weight="db090")
simPop &lt;- simStructure(data=inp, method="direct", basicHHvars=c("age", "rb090"))
simPop &lt;- simCategorical(simPop, additional=c("pl030", "pb220a"), method="multinom", nr_cpus=1)

# add margins
margins &lt;- as.data.frame(
  xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$region + eusilcP$gender + eusilcP$citizenship))
colnames(margins) &lt;- c("db040", "rb090", "pb220a", "freq")
simPop &lt;- addKnownMargins(simPop, margins)
simPop_adj2 &lt;- calibPop(simPop, split="db040", 
  temp=1, epsP.factor=0.1,
 epsMinN=10, nr_cpus = 1)

## End(Not run)
# apply simulated annealing
## Not run: 
simPop_adj &lt;- calibPop(simPop, split="db040", temp=1,
epsP.factor=0.1,nr_cpus = 1)

## End(Not run)
## Not run: 
### use multiple different margins
# person margins
persTables &lt;- as.data.frame(
xtabs(rep(1, nrow(eusilcP)) ~ eusilcP$region + eusilcP$gender + eusilcP$citizenship))
colnames(persTables) &lt;- c("db040", "rb090", "pb220a", "Freq")

# household margins
filter_hid &lt;- !duplicated(eusilcP$hid)
eusilcP$hsize4 &lt;- pmin(4,as.numeric(eusilcP$hsize))
hhTables &lt;- as.data.frame(
  xtabs(rep(1, sum(filter_hid)) ~ eusilcP[filter_hid,]$region+eusilcP[filter_hid,]$hsize4))
colnames(hhTables) &lt;- c("db040", "hsize4", "Freq")
simPop@pop@data$hsize4 &lt;- pmin(4,as.numeric(simPop@pop@data$hsize))

simPop_adj_2 &lt;- calibPop(simPop, split="db040", 
                         temp=1, epsP.factor=0.1,
                         epsH.factor = 0.1,
                         persTables = persTables,
                         hhTables = hhTables,
                         nr_cpus = 1)

## End(Not run)
</code></pre>


</div>