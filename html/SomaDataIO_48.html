<div class="container">

<table style="width: 100%;"><tr>
<td>SeqId</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Working with SomaLogic SeqIds</h2>

<h3>Description</h3>

<p>The <code>SeqId</code> is the cornerstone used to uniquely identify
SomaLogic analytes.
<code>SeqIds</code> follow the format <strong><code style="white-space: pre;">⁠&lt;Pool&gt;-&lt;Clone&gt;_&lt;Version&gt;⁠</code></strong>, for example
<code>"1234-56_7"</code> can be represented as:
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Pool</strong> </td>
<td style="text-align: center;"> <strong>Clone</strong> </td>
<td style="text-align: center;"> <strong>Version</strong> </td>
</tr>
<tr>
<td style="text-align: center;">
<code>1234</code>   </td>
<td style="text-align: center;"> <code>56</code>      </td>
<td style="text-align: center;"> <code>7</code>
</td>
</tr>
</table>
<p>See <strong>Details</strong> below for the definition of each sub-unit.
The <strong><code style="white-space: pre;">⁠&lt;Pool&gt;-&lt;Clone&gt;⁠</code></strong> combination is sufficient to uniquely identify a
specific analyte and therefore versions are no longer provided (though
they may be present in legacy ADATs).
The tools below enable users to extract, test, identify, compare,
and manipulate <code>SeqIds</code> across assay runs and/or versions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getSeqId(x, trim.version = FALSE)

regexSeqId()

locateSeqId(x, trailing = TRUE)

seqid2apt(x)

apt2seqid(x)

is.apt(x)

is.SeqId(x)

matchSeqIds(x, y, order.by.x = TRUE)

getSeqIdMatches(x, y, show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character. A vector of strings, usually analyte/feature column
names, <code>AptNames</code>, or <code>SeqIds</code>. For <code>seqid2apt()</code>, a vector <em>of</em> <code>SeqIds</code>.
For <code>apt2seqid()</code>, a character vector <em>containing</em> <code>SeqIds</code>.
For <code>matchSeqIds()</code>, a vector of pattern matches containing <code>SeqIds</code>.
Can be <code>AptNames</code> with <code>GeneIDs</code>, the <code>seq.XXXX</code> format,
or even "naked" <code>SeqIds</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim.version</code></td>
<td>
<p>Logical. Whether to remove the version number,
i.e. "1234-56_7" -&gt; "1234-56". Primarily for legacy ADATs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trailing</code></td>
<td>
<p>Logical. Should the regular expression explicitly specify
<em>trailing</em> <code>SeqId</code> pattern match, i.e. <code>"regex$"</code>?
This is the most common case and the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Character. A second vector of <code>AptNames</code> containing <code>SeqIds</code>
to match against those in contained in <code>x</code>.
For <code>matchSeqIds()</code> these values are returned if there are matching elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.by.x</code></td>
<td>
<p>Logical. Order the returned character string by
the <code>x</code> (first) argument?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show</code></td>
<td>
<p>Logical. Return the data frame visibly?</p>
</td>
</tr>
</table>
<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
<strong>Pool:</strong>    </td>
<td style="text-align: left;"> ties back to the original well during <strong>SELEX</strong> </td>
</tr>
<tr>
<td style="text-align: left;">
<strong>Clone:</strong>   </td>
<td style="text-align: left;"> ties to the specific sequence within a pool </td>
</tr>
<tr>
<td style="text-align: left;">
<strong>Version:</strong> </td>
<td style="text-align: left;"> refers to custom modifications (optional/defunct)
</td>
</tr>
</table>
<dl>
<dt><code>AptName</code></dt>
<dd>
<p>a <code>SeqId</code> combined with a string, usually a <code>GeneId</code>- or
<code>seq.</code>-prefix, for convenient, human-readable
manipulation from within <code>R</code>.</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>getSeqId()</code>: a character vector of <code>SeqIds</code> captured from a string.
</p>
<p><code>regexSeqId()</code>: a regular expression (<code>regex</code>) string
pre-defined to match SomaLogic the <code>SeqId</code> pattern.
</p>
<p><code>locateSeqId()</code>: a data frame containing the <code>start</code> and <code>stop</code>
integer positions for <code>SeqId</code> matches at each value of <code>x</code>.
</p>
<p><code>seqid2apt()</code>: a character vector with the <code style="white-space: pre;">⁠seq.*⁠</code> prefix, i.e.
the inverse of <code>getSeqId()</code>.
</p>
<p><code>apt2seqid()</code>: a character vector of <code>SeqIds</code>. <code>is.SeqId()</code> will
return <code>TRUE</code> for all elements.
</p>
<p><code>is.apt()</code>, <code>is.SeqId()</code>: Logical. <code>TRUE</code> or <code>FALSE</code>.
</p>
<p><code>matchSeqIds()</code>: a character string corresponding to values
in <code>y</code> of the intersect of <code>x</code> and <code>y</code>. If no matches are
found, <code>character(0)</code>.
</p>
<p><code>getSeqIdMatches()</code>: a <code class="reqn">n x 2</code> data frame, where <code>n</code> is the
length of the intersect of the matching <code>SeqIds</code>.
The data frame is named by the passed arguments, <code>x</code> and <code>y</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getSeqId()</code>: extracts/captures the the <code>SeqId</code> match from an analyte column identifier,
i.e. column name of an ADAT loaded with <code>read_adat()</code>. Assumes the
<code>SeqId</code> pattern occurs at the end of the string, which for
the vast majority of cases will be true. For edge cases, see the
<code>trailing</code> argument to <code>locateSeqId()</code>.
</p>
</li>
<li> <p><code>regexSeqId()</code>: generates a pre-formatted regular expression for
matching of <code>SeqIds</code>. Note the <em>trailing</em> match, which is most
commonly required, but <code>locateSeqId()</code> offers
an alternative to mach <em>anywhere</em> in a string.
Used internally in <em>many</em> utility functions
</p>
</li>
<li> <p><code>locateSeqId()</code>: generates a data frame of the positional <code>SeqId</code> matches. Specifically
designed to facilitate <code>SeqId</code> extraction via <code>substr()</code>.
Similar to <code>stringr::str_locate()</code>.
</p>
</li>
<li> <p><code>seqid2apt()</code>: converts a <code>SeqId</code> into anonymous-AptName format, i.e.
<code>1234-56</code> -&gt; <code>seq.1234.56</code>. Version numbers (<code style="white-space: pre;">⁠1234-56_ver⁠</code>)
are always trimmed when present.
</p>
</li>
<li> <p><code>apt2seqid()</code>: converts an anonymous-AptName into <code>SeqId</code> format, i.e.
<code>seq.1234.56</code> -&gt; <code>1234-56</code>. Version numbers (<code>seq.1234.56.ver</code>)
are always trimmed when present.
</p>
</li>
<li> <p><code>is.apt()</code>: regular expression match to determine if a string <em>contains</em>
a <code>SeqId</code>, and thus is probably an <code>AptName</code> format string. Both
legacy <code>EntrezGeneSymbol-SeqId</code> combinations or newer
so-called <code>"anonymous-AptNames"</code> formats (<code>seq.1234.45</code>) are matched.
</p>
</li>
<li> <p><code>is.SeqId()</code>: tests for <code>SeqId</code> format, i.e. values returned from <code>getSeqId()</code>
will always return <code>TRUE</code>.
</p>
</li>
<li> <p><code>matchSeqIds()</code>: matches two character vectors on the basis of their
intersecting <code>SeqIds</code>. Note that elements in <code>y</code> not
containing a <code>SeqId</code> regular expression are silently dropped.
</p>
</li>
<li> <p><code>getSeqIdMatches()</code>: matches two character vectors on the basis of their intersecting <em>SeqIds</em>
only (irrespective of the <code>GeneID</code>-prefix). This produces a two-column
data frame which then can be used as to map between the two sets.
</p>
<p>The final order of the matches/rows is by the input
corresponding to the <em>first</em> argument (<code>x</code>).
</p>
<p>By default the data frame is invisibly returned to
avoid dumping excess output to the console (see the <code style="white-space: pre;">⁠show =⁠</code> argument.)
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code>intersect()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c("ABDC.3948.48.2", "3948.88",
       "3948.48.2", "3948-48_2", "3948.48.2",
       "3948-48_2", "3948-88",
       "My.Favorite.Apt.3948.88.9")

tibble::tibble(orig       = x,
               SeqId      = getSeqId(x),
               SeqId_trim = getSeqId(x, TRUE),
               AptName    = seqid2apt(SeqId))

# Logical Matching
is.apt("AGR2.4959.2") # TRUE
is.apt("seq.4959.2")  # TRUE
is.apt("4959-2")      # TRUE
is.apt("AGR2")        # FALSE


# SeqId Matching
x &lt;- c("seq.4554.56", "seq.3714.49", "PlateId")
y &lt;- c("Group", "3714-49", "Assay", "4554-56")
matchSeqIds(x, y)
matchSeqIds(x, y, order.by.x = FALSE)

# vector of features
feats &lt;- getAnalytes(example_data)

match_df &lt;- getSeqIdMatches(feats[1:100], feats[90:500])  # 11 overlapping
match_df

a &lt;- utils::head(feats, 15)
b &lt;- withr::with_seed(99, sample(getSeqId(a)))   # =&gt; SeqId &amp; shuffle
(getSeqIdMatches(a, b))                          # sorted by first vector "a"
</code></pre>


</div>