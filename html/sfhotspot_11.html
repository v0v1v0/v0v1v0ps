<div class="container">

<table style="width: 100%;"><tr>
<td>hotspot_classify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Classify hot-spots</h2>

<h3>Description</h3>

<p>Classify cells in a grid based on changes in the clustering of points
(typically representing events) in a two-dimensional regular grid over time.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hotspot_classify(
  data,
  time = NULL,
  period = NULL,
  start = NULL,
  cell_size = NULL,
  grid_type = "rect",
  grid = NULL,
  collapse = FALSE,
  params = hotspot_classify_params(),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>sf</code> data frame containing points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>Name of the column in <code>data</code> containing <code>Date</code> or
<code>POSIXt</code> values representing the date associated with each point. If
this argument is <code>NULL</code> and <code>data</code> contains a single column of
<code>Date</code> or <code>POSIXt</code> values, that column will be used
automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A character value containing a number followed by a unit of
time, e.g. for example, "12 months" or "3.5 days", where the unit of time
is one of second, minute, hour, day, week, month, quarter or year (or their
plural forms).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A <code>Date</code> or <code>POSIXt</code> value specifying when the first
temporal period should start. If <code>NULL</code> (the default), the first
period will start at the beginning of the earliest date found in the data
(if <code>period</code> is specified in days, weeks, months, quarters or years)
or at the earliest time found in the data otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p><code>sf</code> data frame containing points containing
polygons, which will be used as the grid for which counts are made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>If the range of dates in the data is not a multiple of
<code>period</code>, the final period will be shorter than the others. In that
case, should this shorter period be collapsed into the penultimate period?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>A list of optional parameters that can affect the output. The
list can be produced most easily using the
<code>hotspot_classify_params</code> helper function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>sf</code> tibble of regular grid cells with
corresponding hot-spot classifications for each cell. This can be plotted
using <code>autoplot</code>.
</p>
<p>Hot-spots are spatial areas that contain more points than would be expected
by chance; cold-spots are areas that contain fewer points than would be
expected. Whether an area is a hot-spot can vary over time. This function
creates a space-time cube, determines whether an area is a hot-spot for each
of several consecutive time periods and uses that to classify areas according
to whether they are persistent, intermittent, emerging or former hot- or
cold-spots.
</p>


<h4>Hot and cold spots</h4>

<p>Hot- and cold-spots are identified by calculating the Getis-Ord
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(gi-star) or
<i>G</i><sub><i>i</i></sub><sup>*</sup><code class="reqn">Z</code>-score statistic for each cell in a regular grid for each time period.
Cells are classified as follows, using the parameters provided in the
<code>params</code> argument:
</p>

<ul>
<li> <p><em>Persistent hot-/cold-spots</em> are cells that have been hot-/cold-spots
consistently over time. Formally: if the <em>p</em>-value is less than
<code>critical_p</code> for at least <code>persistent_prop</code> proportion of time periods.
</p>
</li>
<li> <p><em>Emerging hot-/cold-spots</em> are cells that have become hot-/cold-spots
recently but were not previously. Formally: if the <em>p</em>-value is less
than <code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
recent by <code>recent_prop</code> but the <em>p</em>-value was <em>not</em> less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
non-recent by <code>1 - recent_prop</code>.
</p>
</li>
<li> <p><em>Former hot-/cold-spots</em> are cells that used to be hot-/cold-spots but have
not been more recently. Formally: if the <em>p</em>-value was less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
non-recent by <code>1 - recent_prop</code> but the <em>p</em>-value was <em>not</em> less than
<code>critical_p</code> for for at least <code>hotspot_prop</code> of time periods defined as
recent by <code>recent_prop</code>.
</p>
</li>
<li> <p><em>Intermittent hot-/cold-spots</em> are cells that have been hot-/cold-spots,
but not as frequently as persistent hotspots and not only during
recent/non-recent periods. Formally: if the <em>p</em>-value is less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods but the cell is
not an emerging or former hotspot.
</p>
</li>
<li> <p><em>No pattern</em> if none of the above categories apply.
</p>
</li>
</ul>
<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values for cells that are outside the area for which data were provided,
which could be misleading. To handle this, consider cropping the output layer
to the area for which data are available. For example, if you only have crime
data for a particular district, crop the output dataset to the district
boundary using <code>st_intersection</code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>References</h3>

<p>Chainey, S. (2020). <em>Understanding Crime: Analyzing the Geography of
Crime</em>. Redlands, CA: ESRI.
</p>


</div>