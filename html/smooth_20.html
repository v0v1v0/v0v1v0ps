<div class="container">

<table style="width: 100%;"><tr>
<td>gum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalised Univariate Model</h2>

<h3>Description</h3>

<p>Function constructs Generalised Univariate Model, estimating matrices F, w,
vector g and initial parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gum(y, orders = c(1, 1), lags = c(1, frequency(y)), type = c("additive",
  "multiplicative"), persistence = NULL, transition = NULL,
  measurement = rep(1, sum(orders)), initial = c("optimal", "backcasting"),
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("restricted", "admissible", "none"), silent = c("all",
  "graph", "legend", "output", "none"), xreg = NULL, regressors = c("use",
  "select"), initialX = NULL, ...)

ges(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orders</code></td>
<td>
<p>Order of the model. Specified as vector of number of states
with different lags. For example, <code>orders=c(1,1)</code> means that there are
two states: one of the first lag type, the second of the second type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>
<p>Defines lags for the corresponding orders. If, for example,
<code>orders=c(1,1)</code> and lags are defined as <code>lags=c(1,12)</code>, then the
model will have two states: the first will have lag 1 and the second will
have lag 12. The length of <code>lags</code> must correspond to the length of
<code>orders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of model. Can either be <code>"A"</code> - additive - or
<code>"M"</code> - multiplicative. The latter means that the GUM is fitted on
log-transformed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transition</code></td>
<td>
<p>Transition matrix <code class="reqn">F</code>. Can be provided as a vector.
Matrix will be formed using the default <code>matrix(transition,nc,nc)</code>,
where <code>nc</code> is the number of components in state vector. If <code>NULL</code>,
then estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurement</code></td>
<td>
<p>Measurement vector <code class="reqn">w</code>. If <code>NULL</code>, then
estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li>
</ul>
<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words ("n",
"a", "g", "l", "o").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using es function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other non-documented parameters.  For example parameter
<code>model</code> can accept a previously estimated GUM model and use all its
parameters.  <code>FI=TRUE</code> will make the function produce Fisher
Information matrix, which then can be used to calculated variances of
parameters of the model.
You can also pass two parameters to the optimiser: 1. <code>maxeval</code> - maximum
number of evaluations to carry on; 2. <code>xtol_rel</code> - the precision of the
optimiser. The default values used in es() are <code>maxeval=5000</code> and
<code>xtol_rel=1e-8</code>. You can read more about these parameters in the
documentation of nloptr function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function estimates the Single Source of Error state space model of the
following type:
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = o_{t} (w' v_{t-l} + x_t a_{t-1} + \epsilon_{t})</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{t} = F v_{t-l} + g \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{t} = F_{X} a_{t-1} + g_{X} \epsilon_{t} / x_{t}</code>
</p>

<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data equal to 1), <code class="reqn">v_{t}</code> is the state vector (defined using
<code>orders</code>) and <code class="reqn">l</code> is the vector of <code>lags</code>, <code class="reqn">x_t</code> is the
vector of exogenous parameters. <code class="reqn">w</code> is the <code>measurement</code> vector,
<code class="reqn">F</code> is the <code>transition</code> matrix, <code class="reqn">g</code> is the <code>persistence</code>
vector, <code class="reqn">a_t</code> is the vector of parameters for exogenous variables,
<code class="reqn">F_{X}</code> is the <code>transitionX</code> matrix and <code class="reqn">g_{X}</code> is the
<code>persistenceX</code> matrix. Finally, <code class="reqn">\epsilon_{t}</code> is the error term.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("gum","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class "smooth" is returned. It contains:
</p>

<ul>
<li> <p><code>model</code> - name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - matrix of fuzzy components of GUM, where <code>rows</code>
correspond to time and <code>cols</code> to states.
</p>
</li>
<li> <p><code>initialType</code> - Type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - initial values of state vector (extracted from
<code>states</code>).
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>measurement</code> - matrix w.
</p>
</li>
<li> <p><code>transition</code> - matrix F.
</p>
</li>
<li> <p><code>persistence</code> - persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>fitted</code> - fitted values.
</p>
</li>
<li> <p><code>forecast</code> - point forecast.
</p>
</li>
<li> <p><code>lower</code> - lower bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - higher bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom
into account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - original data.
</p>
</li>
<li> <p><code>holdout</code> - holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If
<code>regressors="s"</code>, then this value will contain only selected exogenous variables.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes
AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code> or
when <code>FI</code> variable is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample.
In case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li>
<p> Svetunkov I. (2015 - Inf) "smooth" package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li>
</ul>
<ul>
<li>
<p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li>
<p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>adam, es, ces,
sim.es</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Something simple:
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="a",interval="p")

# A more complicated model with seasonality
ourModel &lt;- gum(rnorm(118,100,3),orders=c(2,1),lags=c(1,4),h=18,holdout=TRUE)

# Redo previous model on a new data and produce prediction interval
gum(rnorm(118,100,3),model=ourModel,h=18,interval="sp")

# Produce something crazy with optimal initials (not recommended)
gum(rnorm(118,100,3),orders=c(1,1,1),lags=c(1,3,5),h=18,holdout=TRUE,initial="o")

# Simpler model estiamted using trace forecast error loss function and its analytical analogue
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="n",loss="TMSE")
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="n",loss="aTMSE")

# Introduce exogenous variables
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,xreg=c(1:118))

# Or select the most appropriate one
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,xreg=c(1:118),regressors="s")

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))

</code></pre>


</div>