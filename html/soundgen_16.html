<div class="container">

<table style="width: 100%;"><tr>
<td>.modulationSpectrum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modulation spectrum per sound</h2>

<h3>Description</h3>

<p>Internal soundgen function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">.modulationSpectrum(
  audio,
  specSource = c("STFT", "audSpec")[1],
  windowLength = 15,
  step = 1,
  wn = "hanning",
  zp = 0,
  audSpec_pars = list(filterType = "butterworth", nFilters = 32, bandwidth = 1/24, yScale
    = "bark", dynamicRange = 120),
  msType = c("1D", "2D")[2],
  amRes = 5,
  maxDur = 5,
  specMethod = c("spec", "meanspec")[2],
  logSpec = FALSE,
  logMPS = FALSE,
  power = 1,
  normalize = TRUE,
  roughRange = c(30, 150),
  roughMean = NULL,
  roughSD = NULL,
  roughMinFreq = 1,
  amRange = c(10, 200),
  returnMS = TRUE,
  returnComplex = FALSE,
  plot = TRUE,
  savePlots = NULL,
  logWarpX = NULL,
  logWarpY = NULL,
  quantiles = c(0.5, 0.8, 0.9),
  kernelSize = 5,
  kernelSD = 0.5,
  colorTheme = c("bw", "seewave", "heat.colors", "...")[1],
  col = NULL,
  main = NULL,
  xlab = "Hz",
  ylab = "1/kHz",
  xlim = NULL,
  ylim = NULL,
  width = 900,
  height = 500,
  units = "px",
  res = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>audio</code></td>
<td>
<p>a list returned by <code>readAudio</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specSource</code></td>
<td>
<p>'STFT' = Short-Time Fourier Transform; 'audSpec' = a bank
of bandpass filters (see <code>audSpectrogram</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windowLength, step, wn, zp</code></td>
<td>
<p>parameters for extracting a spectrogram if
<code>specType = 'STFT'</code>. Window length and step are specified in ms (see
<code>spectrogram</code>). If <code>specType = 'audSpec'</code>, these settings
have no effect</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>audSpec_pars</code></td>
<td>
<p>parameters for extracting an auditory spectrogram if
<code>specType = 'audSpec'</code>. If <code>specType = 'STFT'</code>, these settings
have no effect</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msType</code></td>
<td>
<p>'2D' = two-dimensional Fourier transform of a spectrogram; '1D'
= separately calculated spectrum of each frequency band</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amRes</code></td>
<td>
<p>target resolution of amplitude modulation, Hz. If <code>NULL</code>,
the entire sound is analyzed at once, resulting in a single roughness value
(unless it is longer than <code>maxDur</code>, in which case it is analyzed in
chunks <code>maxDur</code> s long). If <code>amRes</code> is set, roughness is
calculated for windows <code>~1000/amRes</code> ms long (but at least 3 STFT
frames). <code>amRes</code> also affects the amount of smoothing when calculating
<code>amMsFreq</code> and <code>amMsPurity</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxDur</code></td>
<td>
<p>sounds longer than <code>maxDur</code> s are split into fragments,
and the modulation spectra of all fragments are averaged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specMethod</code></td>
<td>
<p>the function to call when calculating the spectrum of each
frequency band (only used when <code>msType = '1D'</code>); 'meanspec' is faster
and less noisy, whereas 'spec' produces higher resolution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logSpec</code></td>
<td>
<p>if TRUE, the spectrogram is log-transformed prior to taking 2D
FFT</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logMPS</code></td>
<td>
<p>if TRUE, the modulation spectrum is log-transformed prior to
calculating roughness</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>raise modulation spectrum to this power (eg power = 2 for ^2, or
"power spectrum")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>if TRUE, the modulation spectrum of each analyzed fragment
<code>maxDur</code> in duration is separately normalized to have max = 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roughRange</code></td>
<td>
<p>the range of temporal modulation frequencies that
constitute the "roughness" zone, Hz</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roughMean, roughSD</code></td>
<td>
<p>the mean (Hz) and standard deviation (semitones) of
a lognormal distribution used to weight roughness estimates. If either is
null, roughness is calculated simply as the proportion of spectrum within
<code>roughRange</code>. If both <code>roughMean</code> and <code>roughRange</code> are
defined, weights outside <code>roughRange</code> are set to 0; a very large SD (a
flat weighting function) gives the same result as just <code>roughRange</code>
without any weighting (see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roughMinFreq</code></td>
<td>
<p>frequencies below roughMinFreq (Hz) are ignored when
calculating roughness (ie the estimated roughness increases if we disregard
very low-frequency modulation, which is often strong)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amRange</code></td>
<td>
<p>the range of temporal modulation frequencies that we are
interested in as "amplitude modulation" (AM), Hz</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnMS</code></td>
<td>
<p>if FALSE, only roughness is returned (much faster). Careful
with exporting the modulation spectra of a lot of sounds at once as this
requires a lot of RAM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnComplex</code></td>
<td>
<p>if TRUE, returns a complex modulation spectrum (without
normalization and warping)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>if TRUE, plots the modulation spectrum of each sound (see
<code>plotMS</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savePlots</code></td>
<td>
<p>if a valid path is specified, a plot is saved in this folder
(defaults to NA)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logWarpX, logWarpY</code></td>
<td>
<p>numeric vector of length 2: c(sigma, base) of
pseudolog-warping the modulation spectrum, as in function
pseudo_log_trans() from the "scales" package</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>labeled contour values, % (e.g., "50" marks regions that
contain 50% of the sum total of the entire modulation spectrum)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernelSize</code></td>
<td>
<p>the size of Gaussian kernel used for smoothing (1 = no
smoothing)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernelSD</code></td>
<td>
<p>the SD of Gaussian kernel used for smoothing, relative to its
size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorTheme</code></td>
<td>
<p>black and white ('bw'), as in seewave package ('seewave'),
matlab-type palette ('matlab'), or any palette from
<code>palette</code> such as 'heat.colors', 'cm.colors', etc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>actual colors, eg rev(rainbow(100)) - see ?hcl.colors for colors
in base R (overrides colorTheme)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab, main, xlim, ylim</code></td>
<td>
<p>graphical parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width, height, units, res</code></td>
<td>
<p>parameters passed to
<code>png</code> if the plot is saved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other graphical parameters passed on to <code>filled.contour.mod</code>
and <code>contour</code> (see <code>spectrogram</code>)</p>
</td>
</tr>
</table>
</div>