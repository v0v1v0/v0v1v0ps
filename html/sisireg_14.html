<div class="container">

<table style="width: 100%;"><tr>
<td>ssr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Onedimensional SSR-model calculation</h2>

<h3>Description</h3>

<p>Calculates L1- and L2-functions satisfiying the partial sum criterium.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssr(df, y1=NULL, yn=NULL, fn=0, iter=10000, 
        minStat=FALSE, ne=TRUE, l1=TRUE, ps=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>data frame with two-dimensional data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y1</code></td>
<td>
<p>optional: fixed value left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yn</code></td>
<td>
<p>optional: fixed value right.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>optional: partial-sum-quantile (standard: generic calculation from data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>optional: maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minStat</code></td>
<td>
<p>optional: boolean value for the minimum statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ne</code></td>
<td>
<p>optional: boolean value for non-equidistant observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l1</code></td>
<td>
<p>optional: boolean value for function type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>
<p>optional: sign criterium (partial sum or run).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>SSR-function as array.</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Dr. Lars Metzner
</p>


<h3>References</h3>

<p>Dr. Lars Metzner (2021) <em>Ad√§quates Maschinelles Lernen</em>.
Independently Published.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate equidistant data
set.seed(1234)
x &lt;- seq(0, 2*pi, length.out = 200)
y &lt;- 4*sin(x) + rnorm(200)
df &lt;- data.frame(x=x, y=y)
# calculate regression functions
l1 &lt;- ssr(df, ne=FALSE, ps=FALSE)
l2 &lt;- ssr(df, ne=FALSE, l1=FALSE)
lmin &lt;- ssr(df, ne=FALSE, minStat=TRUE, ps=FALSE)
# plot results
plot(x, y, main = 'Sign-Simplicity-Regression', 
        xlab = 't', ylab = 'sin(t)+noise')
lines(x, l1, col = 'blue')
lines(x, l2, col = 'red')
lines(x, lmin, col = 'purple')
legend("topleft", inset=c(0.01,0.01), 
        legend=c("L1 run-crit.", "L2 ps-crit.", "L1 min-stat."),
        col=c("blue", "red", "purple"), lty=1:1)

# generate nonequidistant data
df &lt;- data.frame(x=runif(500, min=-1, max=1)*pi)
df$y &lt;- sin(df$x)*20 + rnorm(nrow(df), mean=0, sd=10)
# calculate regression function
dfl1 &lt;- ssr(df, fn = 5)
# plot results
plot(df)
lines(dfl1, col = 'red')
</code></pre>


</div>