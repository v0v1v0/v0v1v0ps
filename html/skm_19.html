<div class="container">

<table style="width: 100%;"><tr>
<td>skm_mls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>skm_mls</h2>

<h3>Description</h3>

<p>a selective k-means problem solver - wrapper over skm_mls_cpp
</p>


<h3>Usage</h3>

<pre><code class="language-R">skm_mls(x, k = 1L, s_colname = "s", t_colname = "t", d_colname = "d",
  w_colname = NULL, s_ggrp = integer(0L), s_must = integer(0L),
  max_it = 100L, max_at = 100L, auto_create_ggrp = TRUE,
  extra_immaculatism = TRUE, extra_at = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data.table with s - t - d(s, t): s&lt;source&gt; - t&lt;target&gt; - d&lt;distance&gt;
where s&lt;source&gt; and t&lt;target&gt; must characters and d&lt;distance&gt; must numeric.
aware d&lt;distance&gt; is not necessary as an euclidean or any distance and even
necessary as symmetric - d(s, t) can be unequal to d(t, s) - view d as such
a measure of the cost of assigning one to the other!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of centers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_colname</code></td>
<td>
<p>s&lt;source&gt;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_colname</code></td>
<td>
<p>t&lt;target&gt;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_colname</code></td>
<td>
<p>d&lt;distance&gt; - view d as cost of assigning t into s.
also modify the input data or build in the algorithm can solve problem with
a different fixed cost on using each s as source - i prefer to moddify data
so that the algorithm is clean and clear - i will show a how to in vignette</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_colname</code></td>
<td>
<p>w&lt;weighting&gt; - optional: when not null will optimize toward
objective to minimize d = d * w such as weighted cost of assigning t into s</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_ggrp</code></td>
<td>
<p>s_init will be stratified sampling from s w.r.t s_ggrp.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_must</code></td>
<td>
<p>length &lt;= k-1 s must in result: conditional optimizing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_it</code></td>
<td>
<p>max number of iterations can run for optimizing result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_at</code></td>
<td>
<p>max number of attempts/repeats on running for optimial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto_create_ggrp</code></td>
<td>
<p>boolean indicator of whether auto creating the group
structure using the first letter of s when s_ggrp is integer(0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra_immaculatism</code></td>
<td>
<p>boolean indicator of whether making extra runs for
improving result consistency when multiple successive k is specified, e.g.,
k = c(9L, 10L).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra_at</code></td>
<td>
<p>an integer specifying the number of extra runs when argument
extra_immaculatism is TRUE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>a selective k-means problem is defined as finding a subset of k rows from
a m x n matrix such that the sum of each column minimial is minimized.
</p>
<p>skm_mls would take data.table (data.frame) as inputs, rather than a matrix,
assume that a data.table of s - t - d(s, t) for all combination of s and t,
choose k of s that minimizes sum(min(d(s, t) over selected k of s) over t).
</p>


<h3>Value</h3>

<p>data.table
</p>
<p>o - objective - based on d_colname
</p>
<p>w - weighting - based on w_colname
</p>
<p>k - k&lt;k-list&gt; - based on k - input
</p>
<p>s - s&lt;source&gt; - based on s_colname
</p>
<p>d - weighed averge value of d_colname weighed by w_column when s are selected.
</p>


</div>