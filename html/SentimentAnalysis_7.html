<div class="container">

<table style="width: 100%;"><tr>
<td>analyzeSentiment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sentiment analysis</h2>

<h3>Description</h3>

<p>Performs sentiment analysis  of given object (vector of strings, document-term 
matrix, corpus).
</p>


<h3>Usage</h3>

<pre><code class="language-R">analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)

## S3 method for class 'Corpus'
analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)

## S3 method for class 'character'
analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)

## S3 method for class 'data.frame'
analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)

## S3 method for class 'TermDocumentMatrix'
analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)

## S3 method for class 'DocumentTermMatrix'
analyzeSentiment(
  x,
  language = "english",
  aggregate = NULL,
  rules = defaultSentimentRules(),
  removeStopwords = TRUE,
  stemming = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of characters, a <code>data.frame</code>, an object of type 
<code>Corpus</code>, <code>TermDocumentMatrix</code> or
<code>DocumentTermMatrix</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>language</code></td>
<td>
<p>Language used for preprocessing operations (default: 
English)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>A factor variable by which documents can be grouped. 
This helpful when joining e.g. news from the same day or move reviews
by the same author</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>A named list containing individual sentiment metrics. 
Therefore, each entry consists itself of a list with first a method,
followed by an optional dictionary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeStopwords</code></td>
<td>
<p>Flag indicating whether to remove stopwords or not (default: yes)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stemming</code></td>
<td>
<p>Perform stemming (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters passed to function for e.g. 
preprocessing</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function returns a data.frame with continuous values. If one desires 
other formats, one needs to convert these. Common examples of such formats are
binary response values (positive / negative) or tertiary (positive, neutral, 
negative). Hence, consider using the functions <code>convertToBinaryResponse</code> and
<code>convertToDirection</code>, which can convert a vector of continuous sentiment
scores into a factor object.
</p>


<h3>Value</h3>

<p>Result is a matrix with sentiment values for each document across
all defined rules
</p>


<h3>See Also</h3>

<p><code>compareToResponse</code> for evaluating the results, 
<code>convertToBinaryResponse</code> and <code>convertToDirection</code> for
for getting binary results, <code>generateDictionary</code> for dictionary generation, 
<code>plotSentiment</code> and <code>plotSentimentResponse</code> for visualization
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(tm)

# via vector of strings
corpus &lt;- c("Positive text", "Neutral but uncertain text", "Negative text")
sentiment &lt;- analyzeSentiment(corpus)
compareToResponse(sentiment, c(+1, 0, -2))

# via Corpus from tm package
data("crude")
sentiment &lt;- analyzeSentiment(crude)
    
# via DocumentTermMatrix (with stemmed entries)
dtm &lt;- DocumentTermMatrix(VCorpus(VectorSource(c("posit posit", "negat neutral")))) 
sentiment &lt;- analyzeSentiment(dtm)
compareToResponse(sentiment, convertToBinaryResponse(c(+1, -1)))

# By adapting the parameter rules, one can incorporate customized dictionaries
# e.g. in order to adapt to arbitrary languages
dictionaryAmplifiers &lt;- SentimentDictionary(c("more", "much"))
sentiment &lt;- analyzeSentiment(corpus,
                              rules=list("Amplifiers"=list(ruleRatio,
                                                           dictionaryAmplifiers)))
                                                           
# On can also restrict the number of computed methods to the ones of interest
# in order to achieve performance optimizations
sentiment &lt;- analyzeSentiment(corpus,
                              rules=list("SentimentLM"=list(ruleSentiment, 
                                                            loadDictionaryLM())))
sentiment

## End(Not run)

</code></pre>


</div>