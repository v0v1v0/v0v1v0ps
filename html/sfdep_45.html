<div class="container">

<table style="width: 100%;"><tr>
<td>local_colocation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local indicator of Colocation Quotient</h2>

<h3>Description</h3>

<p>The local indicator of the colocation quotient (LCLQ) is a Local Indicator of Spatial Association (LISA) that evaluates if a given observation's subcategory in A is colocated with subcategories in B. Like the CLQ, the LCLQ provides insight into the asymmetric relationships between subcategories of A and B (where B can also equal A) but at the local level.
</p>
<p>The LCLQ is defined using Gaussian kernel weights and an adaptive bandwidth (see <code>st_kernel_weights()</code>). However, any type of weights list can be used. Kernel weights are used to introduce a decay into the calculation of the CLQ. This ensures that points nearer to the focal point have more influence than those that are more distant.
</p>


<h3>Usage</h3>

<pre><code class="language-R">local_colocation(A, B, nb, wt, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a character or factor vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a character or factor vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>a neighbors list e.g. created by <code>st_knn()</code> or <code>st_contiguity()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>a weights list. Recommended that it is a Gaussian kernel weights list using an adaptive bandwidth e.g. created by <code>st_kernel_weights(nb, geometry, "gaussian", addaptive = TRUE)</code> that does not include the self.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>default <code>99</code>. An integer representing how many simulations to run for calculating the simulated p-values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The LCLQ is defined as <code class="reqn">LCLQ_{A_i \to B} = \frac{N_{A_i \to B}}{N_B / (N - 1)}</code> where <code class="reqn">N_{A_i \to B} = \sum_{j = 1(j \ne i)}^{N}(\frac{w_{ij}f_{ij}}{\sum_{j = 1(j \ne i)}^{N}w_{ij}})</code>. And the weights matrix, wij, uses adaptive bandwidth Gaussian kernel weights.
</p>
<p>LCLQ is only calculated for those subcategories which are present in the neighbor list. If a subcategory is not present, then the resultant LCLQ and simulated p-value will be <code>NA</code>.
</p>


<h3>Value</h3>

<p>a data frame with as many rows as observations in A and two times as many columns as unique values in B. Columns contain each unique value of B as well as the simulated p-value for each value of B.
</p>


<h3>References</h3>

<p>Fahui Wang, Yujie Hu, Shuai Wang &amp; Xiaojuan Li (2017) Local Indicator of Colocation Quotient with a Statistical Significance Test: Examining Spatial Association of Crime and Facilities, The Professional Geographer, 69:1, 22-31, <a href="https://doi.org/10.1080/00330124.2016.1157498">doi:10.1080/00330124.2016.1157498</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">A &lt;- guerry$main_city
B &lt;- guerry$region
geo &lt;- sf::st_centroid(sf::st_geometry(guerry))
nb &lt;- include_self(st_knn(geo, 5))
wt &lt;- st_kernel_weights(nb, geo, "gaussian", adaptive = TRUE)
res &lt;- local_colocation(A, B, nb, wt, 9)
tail(res)
</code></pre>


</div>