<div class="container">

<table style="width: 100%;"><tr>
<td>module_namespace_linter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Require usage of <code>ns()</code> in <code>inputId</code> and <code>outputId</code> arguments of UI functions
in <code>{shiny}</code> modules</h2>

<h3>Description</h3>

<p>A custom <em>linter</em> to be used by <code>{lintr}</code> package. Checks the functions in a
module's UI part for any missing <code>ns()</code> calls. These are often omitted when
working with the plain <code>{shiny}</code> or SIA modules. More details follows below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">module_namespace_linter(
  io_funs = default_shiny_io_functions,
  io_args = c("inputId", "outputId"),
  ns_funs = c("ns", "NS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>io_funs</code></td>
<td>
<p><em>character</em>, <code>{shiny}</code> input/output UI functions to check.
Defaults to default_shiny_io_functions, which covers all native ones and
several others from <code>{plotly}</code> or <code>{DT}</code>. The functions must include the
namespace, i.e., <code>shiny::textInput</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>io_args</code></td>
<td>
<p><em>character</em>, arguments of UI functions to check. <code>inputId</code> and
<code>outputId</code> by default. These are checked even if unnamed. Named arguments
that partially match are ignored and discouraged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ns_funs</code></td>
<td>
<p><em>character</em>, function names that are considered valid in order
to "namespace" inputs' or outputs' IDs. Defaults to both <code>ns</code> and <code>NS</code>
(although we recommend to stick with the former, which is predefined in the
module template).</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>How to use this linter</h4>

<p>The easiest way is to call <code>lint_ns()</code> which is essentially a wrapper around:
</p>
<div class="sourceCode"><pre>lintr::lint_package(linters = module_namespace_linter())
</pre></div>
<p>Both calls use our linter for the whole package. However, note that <em>only</em>
<code>module_namespace_linter</code> is considered. Using this custom linter with the
native ones is somewhat complicated, but not impossible. To the best of our
knowledge, the only place where the <code>{lintr}</code> documentation mentions the
actual usage of external linters, is in
linters_with_tags() help page. According to that,
you can pass the following call to <code>linters</code> argument in any supported
<code style="white-space: pre;">⁠lintr::lint_*⁠</code> function:
</p>
<div class="sourceCode"><pre>lintr::linters_with_tags(
 tags = NULL, packages = c("lintr", "SIAtools")
)
</pre></div>
<p>That should select all linters available in both packages.
</p>
<p>It is also possible to set up a configuration file that enables you to
shorten calls to <code>{lintr}</code> functions, use RStudio Addins to lint an active
file, or even apply linters during continuous integration workflows, e.g., in
GitHub Actions or in Travis. To opt for that, create <code>.lintr</code> file at your
package's root and fill in the following line:
</p>
<div class="sourceCode"><pre>linters: linters_with_tags(tags = NULL, packages = "SIAtools")
</pre></div>
<p>Then, you can use the provided addins or call <code>lintr::lint_package()</code> to get
your modules checked.
</p>



<h4>What the linter does</h4>

<p>By default, the linter looks for any <code>inputId</code> or <code>outputId</code> arguments of
<code>{shiny}</code>'s UI functions (such as numericInput or
plotOutput, respectively), and tests if the values
assigned to the arguments are all "namespaced", i.e., wrapped in <code>ns()</code>
function. This is crucial for inputs and outputs in the UI portion of a
module to match their counterparts in the server logic chunk.
</p>
<p>Only <code>{shiny}</code> UI calls that are inside of a tagList in a
function ("lambda" shorthand, <code style="white-space: pre;">⁠\( )⁠</code>, applies as well) are inspected. This is
because we don't want to cause false alarms for any "ordinary" <code>{shiny}</code> apps
that aren't modules. All UI portions of modules are usually defined as
functions, and all input/output UI functions are inside a
tagList, so we opted for the this strategy to minimalize
false positive matches outside <code>{shiny}</code> modules.
</p>
<p>We look for any <code>inputId</code> or <code>outputId</code> arguments that are named as such. On
top of that, the <code>ns()</code> omission is detected even if you call the function
without named arguments that would be evaluated as input or output IDs.
However, if you use partial matching (<code>numericInput(inp = "input")</code>), the
actual input won't get linted, even though it should, as it is eventually
evaluated as <code>inputId</code>. The same applies for arguments defined outside the
call and passed as a variable, e.g., <code style="white-space: pre;">⁠inp &lt;- "input"; numericInput(inputId = inp)⁠</code>. That is tricky to catch in a static code analysis, which is employed
in this linter.
</p>



<h3>Value</h3>

<p>A <code>linter</code> closure. To be used by <code>{lintr}</code> only. See the first
example below.
</p>


<h3>See Also</h3>

<p>linters for a complete list of linters available
in lintr.
</p>
<p>Other linter-related functions:
<code>lint_ns()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# will produce lints
lintr::lint(
  text =
    "module_ui &lt;- function(id, imports, ...) {
      tagList(
        numericInput(inputId = \"input_id_without_ns\", ...)
      )
    }",
  linter = module_namespace_linter()
)

# is OK
lintr::lint(
  text =
    "module_ui &lt;- function(id, imports, ...) {
      tagList(
        numericInput(inputId = ns(\"input_id_with_ns\"), ...)
      )
    }",
  linter = module_namespace_linter()
)

</code></pre>


</div>