<div class="container">

<table style="width: 100%;"><tr>
<td>bounds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bounds based on MRC</h2>

<h3>Description</h3>

<p>Computes two-sided bounds for a set of intervals based on a multiresolution criterion (MRC).
</p>
<p><b>Deprecation warning:</b> This function is deprecated, but still working, however, may be defunct in a future version. Please use instead the function <code>computeBounds</code>. An example how to reproduce results (currently only family <code>"gauss"</code> is supported) is given below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bounds(y, type = "MRC", ...)
bounds.MRC(y, q, alpha = 0.05, r = ceiling(50 / min(alpha, 1 - alpha)),
  lengths = if(family == "gaussKern")
    2^(floor(log2(length(y))):ceiling(log2(length(param$kern)))) else
    2^(floor(log2(length(y))):0), penalty = c("none", "len", "var", "sqrt"),
  name = if(family == "gaussKern") ".MRC.ktable" else ".MRC.table", pos = .MCstepR,
  family = c("gauss", "gaussvar", "poisson", "binomial","gaussKern"), param = NULL,
  subset, max.iter = 1e2, eps = 1e-3)
## S3 method for class 'bounds'
x[subset]
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>so far only bounds of type <code>"MRC"</code> are implemented</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on to <code>bounds.MRC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantile of the MRC; if specified, <code>alpha</code> and <code>r</code> will be ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>level of significance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of simulations to use to obtain quantile of MRC for specified <code>alpha</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lengths</code></td>
<td>
<p>vector of interval lengths to use, dyadic intervals by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>penalty term in the multiresolution statistic: <code>"none"</code> for no penalty, <code>"len"</code> for penalizing the length of an interval, <code>"var"</code> for penalizing the variance over an interval, and <code>"sqrt"</code> for penalizing the square root of the MRC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family, param</code></td>
<td>
<p>specifies distribution of data, see family</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a subset of indices of <code>y</code> for which bounds should be aggregated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name,pos</code></td>
<td>
<p>under which name and where precomputed results are stored, or retrieved, see <code>assign</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximal iterations in Newton's method to compute non-Gaussian MRC bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>tolerance in Newton's method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>bounds</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an object of class <code>bounds</code>, i.e. a list whose entry <code>bounds</code> contains two-sided bounds (<code>lower</code> and <code>upper</code>) of the considered intervals (with left index <code>li</code> and right index <code>ri</code>) in a <code>data.frame</code>, along with a vector <code>start</code> specifying in which row of entry <code>bounds</code> intervals with corresponding <code>li</code> start (if any; specified as a C-style index), and a <code>logical</code> <code>feasible</code> telling whether a feasible solution exists for these bounds (always <code>TRUE</code> for MRC bounds which are not restricted to a <code>subset</code>).
</p>


<h3>See Also</h3>

<p><code>computeBounds</code>, <code>stepbound</code>, family</p>


<h3>Examples</h3>

<pre><code class="language-R">y &lt;- rnorm(100, c(rep(0, 50), rep(1, 50)), 0.5)
b &lt;- computeBounds(y, q = 4, intervalSystem = "dyaLen", penalty = "none")
b &lt;- b[order(b$li, b$ri), ]
attr(b, "row.names") &lt;- seq(along = b$li)

# entries in bounds are recovered by computeBounds
all.equal(bounds(y, q = 4)$bounds, b) # TRUE


# simulate signal of 100 data points
Y &lt;- rpois(100, 1:100 / 10)
# compute bounds for intervals of dyadic lengths
b &lt;- bounds(Y, penalty="len", family="poisson", q=4)
# compute bounds for all intervals
b &lt;- bounds(Y, penalty="len", family="poisson", q=4, lengths=1:100)
</code></pre>


</div>