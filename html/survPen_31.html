<div class="container">

<table style="width: 100%;"><tr>
<td>survPenObject</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitted survPen object</h2>

<h3>Description</h3>

<p>A fitted survPen object returned by function <code>survPen</code> and of class "survPen". 
Method functions predict and summary are available for this class.
</p>


<h3>Value</h3>

<p>A <code>survPen</code> object has the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>original <code>survPen</code> call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula object specifying the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0.name</code></td>
<td>
<p>name of the vector of origin times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1.name</code></td>
<td>
<p>name of the vector of follow-up times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event.name</code></td>
<td>
<p>name of the vector of right-censoring indicators</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expected.name</code></td>
<td>
<p>name of the vector of expected hazard</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>haz</code></td>
<td>
<p>fitted hazard</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>estimated regression parameters. Unpenalized parameters are first, followed by the penalized ones</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"net" for net survival estimation with penalized excess hazard model or "overall" for overall survival with penalized hazard model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.para</code></td>
<td>
<p>degrees of freedom associated with fully parametric terms (unpenalized)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.smooth</code></td>
<td>
<p>degrees of freedom associated with penalized terms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>number of regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>effective degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf1</code></td>
<td>
<p>alternative effective degrees of freedom ; used as an upper bound for edf2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf2</code></td>
<td>
<p>effective degrees of freedom corrected for smoothing parameter uncertainty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>Akaike information criterion with number of parameters replaced by edf when there are penalized terms. Corresponds to 2*edf - 2*ll.unpen</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic2</code></td>
<td>
<p>Akaike information criterion corrected for smoothing parameter uncertainty. Be careful though, this is still a work in progress, especially when one of the smoothing parameters tends to infinity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.beta</code></td>
<td>
<p>vector of numbers of iterations needed to estimate the regression parameters for each smoothing parameters trial. It thus contains <code>iter.rho+1</code> elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>design matrix of the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>penalty matrix of the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.scale</code></td>
<td>
<p>vector of rescaling factors for the penalty matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.list</code></td>
<td>
<p>Equivalent to pen but with every element multiplied by its associated smoothing parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.smf</code></td>
<td>
<p>List of penalty matrices associated with all "smf" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.tensor</code></td>
<td>
<p>List of penalty matrices associated with all "tensor" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.tint</code></td>
<td>
<p>List of penalty matrices associated with all "tint" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.rd</code></td>
<td>
<p>List of penalty matrices associated with all "rd" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.smf</code></td>
<td>
<p>List of names for the "smf" calls associated with S.smf</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.tensor</code></td>
<td>
<p>List of names for the "tensor" calls associated with S.tensor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.tint</code></td>
<td>
<p>List of names for the "tint" calls associated with S.tint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.rd</code></td>
<td>
<p>List of names for the "rd" calls associated with S.rd</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.pen</code></td>
<td>
<p>List of all the rescaled penalty matrices redimensioned to df.tot size. Every element of <code>S.pen</code> noted <code>S.pen[[i]]</code> is made from a penalty matrix <code>pen[[i]]</code> returned by
<code>smooth.cons</code> and is multiplied by S.scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad.unpen.beta</code></td>
<td>
<p>gradient vector of the log-likelihood with respect to the regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad.beta</code></td>
<td>
<p>gradient vector of the penalized log-likelihood with respect to the regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess.unpen.beta</code></td>
<td>
<p>hessian of the log-likelihood with respect to the regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess.beta</code></td>
<td>
<p>hessian of the penalized log-likelihood with respect to the regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess.beta.modif</code></td>
<td>
<p>if TRUE, the hessian of the penalized log-likelihood has been perturbed at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll.unpen</code></td>
<td>
<p>log-likelihood at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll.pen</code></td>
<td>
<p>penalized log-likelihood at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.rho.beta</code></td>
<td>
<p>transpose of the Jacobian of beta with respect to the log smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.rho.inv.Hess.beta</code></td>
<td>
<p>list containing the derivatives of the inverse of <code>Hess</code> with respect to the log smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.rho.Hess.unpen.beta</code></td>
<td>
<p>list containing the derivatives of <code>Hess.unpen</code> with respect to the log smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>estimated or given smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.smooth</code></td>
<td>
<p>number of smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.rho</code></td>
<td>
<p>number of iterations needed to estimate the smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.rho</code></td>
<td>
<p>identify whether the smoothing parameters were estimated or not; 1 when exiting the function <code>NR.rho</code>; default is NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>criterion used for smoothing parameter estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion.val</code></td>
<td>
<p>value of the criterion used for smoothing parameter estimation at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LCV</code></td>
<td>
<p>Likelihood cross-validation criterion at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LAML</code></td>
<td>
<p>negative Laplace approximate marginal likelihood at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad.rho</code></td>
<td>
<p>gradient vector of criterion with respect to the log smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess.rho</code></td>
<td>
<p>hessian matrix of criterion with respect to the log smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.Hess.rho</code></td>
<td>
<p>inverse of <code>Hess.rho</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess.rho.modif</code></td>
<td>
<p>if TRUE, the hessian of LCV or LAML has been perturbed at convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ve</code></td>
<td>
<p>Frequentist covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vp</code></td>
<td>
<p>Bayesian covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vc</code></td>
<td>
<p>Bayesian covariance matrix corrected for smoothing parameter uncertainty (see Wood et al. 2016)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vc.approx</code></td>
<td>
<p>Kass and Steffey approximation of <code>Vc</code> (see Wood et al. 2016)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.smf</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraint to apply for <code>smf</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.tensor</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraint to apply for <code>tensor</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.tint</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraint to apply for <code>tint</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.smf</code></td>
<td>
<p>List of all <code>smf.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.tensor</code></td>
<td>
<p>List of all <code>tensor.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.tint</code></td>
<td>
<p>List of all <code>tint.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.rd</code></td>
<td>
<p>List of all <code>rd.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.F</code></td>
<td>
<p>Eigen vectors of S.F, useful for the initial reparameterization to separate penalized ad unpenalized subvectors. Allows stable evaluation of the log determinant of S and its derivatives</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.pwcst</code></td>
<td>
<p>TRUE if there is a piecewise constant (excess) hazard specification. In that case the cumulative hazard can be derived without Gauss-Legendre quadrature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pwcst.breaks</code></td>
<td>
<p>if is.pwcst is TRUE, vector of breaks defining the sub-intervals on which the hazard is constant. Otherwise NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor.structure</code></td>
<td>
<p>List containing the levels and classes of all factor variables present in the data frame used for fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>convergence indicator, TRUE or FALSE. TRUE if Hess.beta.modif=FALSE and Hess.rho.modif=FALSE (or NULL)</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wood, S.N., Pya, N. and Saefken, B. (2016), Smoothing parameter and model selection for general smooth models (with discussion). Journal of the American Statistical Association 111, 1548-1575
</p>


</div>