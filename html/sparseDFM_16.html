<div class="container">

<table style="width: 100%;"><tr>
<td>sparseDFM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate a Sparse Dynamic Factor Model</h2>

<h3>Description</h3>

<p>Main function to allow estimation of a DFM or a sparse DFM (with sparse loadings) on stationary data that may have arbitrary patterns of missing data. We allow the user:
</p>

<ul>
<li>
<p> an option for estimation method - <code>"PCA"</code>, <code>"2Stage"</code>, <code>"EM"</code> or <code>"EM-sparse"</code>
</p>
</li>
<li>
<p> an option for <code>IID</code> or <code>AR1</code> idiosyncratic errors
</p>
</li>
<li>
<p> an option for Kalman Filter/Smoother estimation using standard <code>multivariate</code> equations or fast <code>univariate</code> filtering equations
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">sparseDFM(
  X,
  r,
  q = 0,
  alphas = logspace(-2, 3, 100),
  alg = "EM-sparse",
  err = "IID",
  kalman = "univariate",
  store.parameters = FALSE,
  standardize = TRUE,
  max_iter = 100,
  threshold = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>n x p</code> numeric data matrix or data frame of (stationary) time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer. Number of factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Integer. The first q series (columns of X) should not be made sparse. Default q = 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>Numeric vector or value of LASSO regularisation parameters. Default is alphas = logspace(-2,3,100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg</code></td>
<td>
<p>Character. Option for estimation algorithm. Default is <code>"EM-sparse"</code>. Options are:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>"PCA"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> principle components analysis (PCA) for static factors seen in Stock and Watson (2002). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>"2Stage"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the two-stage framework of PCA plus Kalman filter/smoother seen in Giannone et al. (2008) and Doz et al. (2011). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>"EM"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the quasi-maximum likelihood approach using the EM algorithm to handle arbitrary patterns of missing data seen in Banbura and Modugno (2014). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>"EM-sparse"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the novel sparse EM approach allowing LASSO regularisation on factor loadings seen in (cite our paper). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err</code></td>
<td>
<p>Character. Option for idiosyncratic errors. Default is <code>"IID"</code>. Options are:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>"IID"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> errors are IID white noise. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>"AR1"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> errors follow an AR(1) process. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kalman</code></td>
<td>
<p>Character. Option for Kalman filter and smoother equations. Default is <code>"univariate"</code>. Options are:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>"multivariate"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> classic Kalman filter and smoother equations seen in Shumway and Stoffer (1982). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>"univaraite"</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> univariate treatment (sequential processing) of the multivariate equations for fast Kalman filter and smoother seen in Koopman and Durbin (2000). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.parameters</code></td>
<td>
<p>Logical. Store outputs for every alpha L1 penalty parameter. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical. Standardize the data before estimating the model. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>Integer. Maximum number of EM iterations. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Numeric. Tolerance on EM iterates. Default is 1e-4.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For full details of the model please refer to Mosley et al. (2023).
</p>


<h3>Value</h3>

<p>A list-of-lists-like S3 object of class 'sparseDFM' with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A list containing information about the data with the following elements:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>X</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is the original <code class="reqn">n \times p</code> numeric data matrix of (stationary) time series. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>standardize</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is a logical value indicating whether the original data was standardized.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>X.mean</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is a p-dimensional numeric vector of column means of <code class="reqn">X</code>.  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>X.sd</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is a p-dimensional numeric vector of column standard deviations of <code class="reqn">X</code>.  </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>X.bal</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is a <code class="reqn">n \times p</code> numeric data matrix of the original <code class="reqn">X</code> with missing data interpolated using <code>fillNA()</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>eigen</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is the eigen decomposition of <code>X.bal</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>fitted</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is the <code class="reqn">n \times p</code> predicted data matrix using the estimated parameters: <code class="reqn">\hat{\Lambda}\hat{F}</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>fitted.unscaled</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> is the <code class="reqn">n \times p</code> predicted data matrix using the estimated parameters: <code class="reqn">\hat{\Lambda}\hat{F}</code> that has been unscaled back to original data scale if <code>standardize</code> is <code>TRUE</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>method</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the estimation algorithm used (<code>alg</code>). </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>err</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the type of idiosyncratic errors assumed. Either <code>IID</code> or <code>AR1</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>call</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> call object obtained from <code>match.call()</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>A list containing the estimated parameters of the model with the following elements:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>A</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">r \times r</code> factor transition matrix. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>Phi</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the p-dimensional vector of AR(1) coefficients for the idiosyncratic errors. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>Lambda</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">p \times r</code> loadings matrix. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>Sigma_u</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">r \times r</code> factor transition error covariance matrix. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>Sigma_epsilon</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the p-dimensional vector of idiosyncratic error variances. As <code class="reqn">\bm{\Sigma}_{\epsilon}</code> is assumed to be diagonal. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>A list containing the estimated states and state covariances with the following elements:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>factors</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">n \times r</code> matrix of factor estimates. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>errors</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">n \times p</code> matrix of AR(1) idiosyncratic error estimates. For err = AR1 only. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>factors.cov</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">r \times r \times n</code> covariance matrices of the factor estimates. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>errors.cov</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the <code class="reqn">p \times p \times n</code> covariance matrices of the AR(1) idiosyncratic error estimates. For err = AR1 only. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>em</code></td>
<td>
<p>A list containing information about the EM algorithm with the following elements:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>converged</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> a logical value indicating whether the EM algorithm converged. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>alpha_grid</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> a numerical vector containing the LASSO tuning parameters considered in BIC evaluation before stopping. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>alpha_opt</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the optimal LASSO tuning parameter used. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>bic</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> a numerical vector containing BIC values for the corresponding LASSO tuning parameter in <code>alpha_grid</code>. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>loglik</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> the log-likelihood of the innovations from the Kalman filter in the final model. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>num_iter</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> number of iterations taken by the EM algorithm. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>tol</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> tolerance for EM convergence. Matches <code>threshold</code> in the input. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>max_iter</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> maximum number of iterations allowed for the EM algorithm. Matches <code>max_iter</code> in the input. </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>em_time</code> </td>
<td style="text-align: left;"></td>
<td style="text-align: left;"> time taken for EM convergence </td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.output</code></td>
<td>
<p>Parameter and state outputs for each L1-norm penalty parameter in <code>alphas</code> if <code>store.parameters = TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Banbura, M., &amp; Modugno, M. (2014). Maximum likelihood estimation of factor models on datasets with arbitrary pattern of missing data. <em>Journal of Applied Econometrics, 29</em>(1), 133-160.
</p>
<p>Doz, C., Giannone, D., &amp; Reichlin, L. (2011). A two-step estimator for large approximate dynamic factor models based on Kalman filtering. <em>Journal of Econometrics, 164</em>(1), 188-205.
</p>
<p>Giannone, D., Reichlin, L., &amp; Small, D. (2008). Nowcasting: The real-time informational content of macroeconomic data. <em>Journal of monetary economics, 55</em>(4), 665-676.
</p>
<p>Koopman, S. J., &amp; Durbin, J. (2000). Fast filtering and smoothing for multivariate state space models. <em>Journal of Time Series Analysis, 21</em>(3), 281-296.
</p>
<p>Mosley, L., Chan, TS., &amp; Gibberd, A. (2023). sparseDFM: An R Package to Estimate Dynamic Factor Models with Sparse Loadings.
</p>
<p>Shumway, R. H., &amp; Stoffer, D. S. (1982). An approach to time series smoothing and forecasting using the EM algorithm. <em>Journal of time series analysis, 3</em>(4), 253-264.
</p>
<p>Stock, J. H., &amp; Watson, M. W. (2002). Forecasting using principal components from a large number of predictors. <em>Journal of the American statistical association, 97</em>(460), 1167-1179.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load inflation data set 
data = inflation

# reduce the size for these examples - full data found in vignette 
data = data[1:60,]

# make stationary by taking first differences 
new_data = transformData(data, rep(2,ncol(data)))

# tune for the number of factors to use 
tuneFactors(new_data, type = 2)

# fit a PCA using 3 PC's
fit.pca &lt;- sparseDFM(new_data, r = 3, alg = 'PCA')

# fit a DFM using the two-stage approach 
fit.2stage &lt;- sparseDFM(new_data, r = 3, alg = '2Stage')

# fit a DFM using EM algorithm with 3 factors 
fit.dfm &lt;- sparseDFM(new_data, r = 3, alg = 'EM')

# fit a Sparse DFM with 3 factors
fit.sdfm &lt;- sparseDFM(new_data, r = 3, alg = 'EM-sparse')

# observe the factor loadings of the sparse DFM
plot(fit.sdfm, type = 'loading.heatmap')

# observe the factors 
plot(fit.sdfm, type = 'factor')

# observe the residuals 
plot(fit.sdfm, type = 'residual')

# observe the LASSO parameter selected and BIC values 
plot(fit.sdfm, type = 'lasso.bic')

# predict 3 steps ahead 
predict(fit.sdfm, h = 3)

 
</code></pre>


</div>