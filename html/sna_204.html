<div class="container">

<table style="width: 100%;"><tr>
<td>equiv.clust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Find Clusters of Positions Based on an Equivalence Relation </h2>

<h3>Description</h3>

<p><code>equiv.clust</code> uses a definition of approximate equivalence (<code>equiv.fun</code>) to form a hierarchical clustering of network positions.  Where <code>dat</code> consists of multiple relations, all specified relations are considered jointly in forming the equivalence clustering.
</p>


<h3>Usage</h3>

<pre><code class="language-R">equiv.clust(dat, g=NULL, equiv.dist=NULL, equiv.fun="sedist",
   method="hamming", mode="digraph", diag=FALSE, 
   cluster.method="complete", glabels=NULL, plabels=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> one or more graphs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p> the elements of <code>dat</code> to use in clustering the vertices; by default, all structures are used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equiv.dist</code></td>
<td>
<p> a matrix of distances, by which vertices should be clustered.  (Overrides <code>equiv.fun</code>.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equiv.fun</code></td>
<td>
<p> the distance function to use in clustering vertices (defaults to <code>sedist</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
 <p><code>method</code> parameter to be passed to <code>equiv.fun</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p> “graph” or “digraph,” as appropriate. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p> a boolean indicating whether or not matrix diagonals (loops) should be interpreted as useful data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.method</code></td>
<td>
<p> the hierarchical clustering method to use (see <code>hclust</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glabels</code></td>
<td>
<p> labels for the various graphs in <code>dat</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plabels</code></td>
<td>
<p> labels for the vertices of <code>dat</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to <code>equiv.dist</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This routine is essentially a joint front-end to <code>hclust</code> and various positional distance functions, though it defaults to structural equivalence in particular.  Taking the specified graphs as input, <code>equiv.clust</code> computes the distances between all pairs of positions using <code>equiv.fun</code> (unless distances are supplied in <code>equiv.dist</code>), and then performs a cluster analysis of the result.  The return value is an object of class <code>equiv.clust</code>, for which various secondary analysis methods exist.
</p>


<h3>Value</h3>

<p>An object of class <code>equiv.clust</code>
</p>


<h3>Note</h3>

<p> See <code>sedist</code> for an example of a distance function compatible with <code>equiv.clust</code>. </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

 
<p>Breiger, R.L.; Boorman, S.A.; and Arabie, P.  (1975).  “An Algorithm for Clustering Relational Data with Applications to Social Network Analysis and Comparison with Multidimensional Scaling.”  <em>Journal of Mathematical Psychology</em>, 12, 328-383.
</p>
<p>Burt, R.S.  (1976).  “Positions in Networks.”  <em>Social Forces</em>, 55, 93-122.
</p>
<p>Wasserman, S., and Faust, K.  <em>Social Network Analysis: Methods and Applications.</em>  Cambridge: Cambridge University Press. </p>


<h3>See Also</h3>

 <p><code>sedist</code>, <code>blockmodel</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
#Create a random graph with _some_ edge structure
g.p&lt;-sapply(runif(20,0,1),rep,20)  #Create a matrix of edge 
                                   #probabilities
g&lt;-rgraph(20,tprob=g.p)            #Draw from a Bernoulli graph 
                                   #distribution

#Cluster based on structural equivalence
eq&lt;-equiv.clust(g)
plot(eq)
</code></pre>


</div>