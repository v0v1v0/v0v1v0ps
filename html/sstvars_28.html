<div class="container">

<table style="width: 100%;"><tr>
<td>GAfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Genetic algorithm for preliminary estimation of a STVAR models</h2>

<h3>Description</h3>

<p><code>GAfit</code> estimates the specified STVAR model using a genetic algorithm.
It is designed to find starting values for gradient based methods and NOT to obtain
final estimates constituting a local maximum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GAfit(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  ngen = 200,
  popsize,
  smart_mu = min(100, ceiling(0.5 * ngen)),
  initpop = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  B_scale,
  weight_scale,
  ar_scale = 0.2,
  upper_ar_scale = 1,
  ar_scale2 = 1,
  regime_force_scale = 1,
  red_criteria = c(0.05, 0.01),
  pre_smart_mu_prob = 0,
  to_return = c("alt_ind", "best_ind"),
  minval,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt>
<code>"relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt>
<code>"logistic"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt>
<code>"exponential"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt>
<code>"exogenous"</code>:</dt>
<dd>
<p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>
<p>See the vignette for more details about the weight functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt>
<dd>
<p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt>
<dd>
<p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt>
<dd>
<p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt>
<dd>
<p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt>
<dd>
<p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, or <code>"ind_Student"</code>,
where the latest is the Student's <code class="reqn">t</code> distribution with independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 x 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> in order to constrain the
the weight parameter to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngen</code></td>
<td>
<p>a positive integer specifying the number of generations to be ran through in
the genetic algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popsize</code></td>
<td>
<p>a positive even integer specifying the population size in the genetic algorithm.
Default is <code>10*n_params</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smart_mu</code></td>
<td>
<p>a positive integer specifying the generation after which the random mutations
in the genetic algorithm are "smart". This means that mutating individuals will mostly mutate fairly
close (or partially close) to the best fitting individual (which has the least regimes with time varying
mixing weights practically at zero) so far.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initpop</code></td>
<td>
<p>a list of parameter vectors from which the initial population of the genetic algorithm
will be generated from. The parameter vectors should have the form
<code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where
</p>

<ul>
<li>
<p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li>
<p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>
</li>
<li>
<p><code class="reqn">\alpha</code> contains the transition weights parameters (see below)
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt>
<dd>
<p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu = (\nu_1,...,\nu_M)</code> <code class="reqn">(M \times 1)</code>, <code class="reqn">nu_m &gt; 2</code>.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>
<code>weight_function="relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt>
<code>weight_function="logistic"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>
<code>weight_function="exponential"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt>
<code>weight_function="exogenous"</code>:</dt>
<dd>
<p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt>
<dd>
<p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>vapply(1:d, function(i1) sd(data[,i1]), numeric(1))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_scale</code></td>
<td>
<p>For...
</p>

<dl>
<dt>
<code>weight_function %in% c("relative_dens", "exogenous")</code>:</dt>
<dd>
<p>not used.</p>
</dd>
<dt>
<code>weight_function %in% c("logistic", "exponential")</code>:</dt>
<dd>
<p>length three vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the location parameter is drawn from
in random mutations. The third element is the standard deviation of the normal distribution from whose absolute value
the location parameter is drawn from.</p>
</dd>
<dt>
<code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>length two vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the coefficients of the logit sub model's
constant terms are drawn from in random mutations. The third element is the standard deviation of the normal distribution
from which the non-constant regressors' coefficients are drawn from.</p>
</dd>
<dt>
<code>weight_function == "threshold"</code>:</dt>
<dd>
<p>a lenght two vector with the lower bound, in the first element
and the upper bound, in the second element, of the uniform distribution threshold parameters are drawn from
in random mutations.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale</code></td>
<td>
<p>a positive real number between zero and one adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_ar_scale</code></td>
<td>
<p>the upper bound for <code>ar_scale</code> parameter (see above) in the random mutations. Setting
this too high might lead to failure in proposing new parameters that are well enough inside the parameter space,
and especially with large <code>p</code> one might want to try smaller upper bound (e.g., 0.5). With large <code>p</code> or
<code>d</code>, <code>upper_ar_scale</code> is restricted from above, see the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong>
coefficients (in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to
be very small. If set smaller than 1, be careful as it might lead to failure in the creation of parameter candidates
that satisfy the stability condition.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regime_force_scale</code></td>
<td>
<p>a non-negative real number specifying how much should natural selection favor individuals
with less regimes that have almost all mixing weights (practically) at zero. Set to zero for no favoring or large
number for heavy favoring. Without any favoring the genetic algorithm gets more often stuck in an area of the
parameter space where some regimes are wasted, but with too much favouring the best genes might never mix into
the population and the algorithm might converge poorly. Default is <code>1</code> and it gives <code class="reqn">2x</code> larger surviving
probability weights for individuals with no wasted regimes compared to individuals with one wasted regime.
Number <code>2</code> would give <code class="reqn">3x</code> larger probability weights etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>red_criteria</code></td>
<td>
<p>a length 2 numeric vector specifying the criteria that is used to determine whether a regime is
redundant (or "wasted") or not.
Any regime <code>m</code> which satisfies <code>sum(transitionWeights[,m] &gt; red_criteria[1]) &lt; red_criteria[2]*n_obs</code> will
be considered "redundant". One should be careful when adjusting this argument (set <code>c(0, 0)</code> to fully disable
the 'redundant regime' features from the algorithm).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre_smart_mu_prob</code></td>
<td>
<p>A number in <code class="reqn">[0,1]</code> giving a probability of a "smart mutation" occuring randomly in each
iteration before the iteration given by the argument <code>smart_mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_return</code></td>
<td>
<p>should the genetic algorithm return the best fitting individual which has "positive enough" mixing
weights for as many regimes as possible (<code>"alt_ind"</code>) or the individual which has the highest log-likelihood
in general (<code>"best_ind"</code>) but might have more wasted regimes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minval</code></td>
<td>
<p>a real number defining the minimum value of the log-likelihood function that will be considered.
Values smaller than this will be treated as they were <code>minval</code> and the corresponding individuals will
never survive. The default is <code>-(10^(ceiling(log10(n_obs)) + d) - 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, that sets seed for the random number generator in
the beginning of the function call. If calling <code>GAfit</code> from <code>fitSTVAR</code>, use the argument <code>seeds</code>
instead of passing the argument <code>seed</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Only reduced form models are supported!
</p>
<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>.
It utilizes a slightly modified version of the individually adaptive crossover and mutation rates described
by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed by
<em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>By "redundant" or "wasted" regimes we mean regimes that have the time varying mixing weights practically at
zero for almost all t. A model including redundant regimes would have about the same log-likelihood value without
the redundant regimes and there is no purpose to have redundant regimes in a model.
</p>
<p>Some of the AR coefficients are drawn with the algorithm by Ansley and Kohn (1986). However,
when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical inaccuracies caused
by the imprecision of the float-point presentation may result in errors or nonstationary AR-matrices.
Using smaller <code>ar_scale</code> facilitates the usage of larger <code>p</code> or <code>d</code>. Therefore, we bound
<code>upper_ar_scale</code> from above by <code class="reqn">1-pd/150</code> when <code>p*d&gt;40</code> and by <code class="reqn">1</code> otherwise.
</p>
<p>Structural models are not supported here, as they are best estimated based on reduced form parameter estimates
using the function <code>fitSSTVAR</code>.
</p>


<h3>Value</h3>

<p>Returns the estimated parameter vector which has the form described in <code>initpop</code>,
<strong>with the exception</strong> that for models with <code>cond_dist == "ind_Student"</code> or
<code>identification="non-Gaussianity"</code>, the parameter vector is parametrized with <code class="reqn">B_1,B_2^*,...,B_M^*</code>
instead of  <code class="reqn">B_1,B_2,...,B_M</code>, where <code class="reqn">B_m^* = B_m - B_1</code>. Use the function <code>change_parametrization</code>
to change back to the original parametrization if desired.
</p>


<h3>References</h3>


<ul>
<li>
<p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity. <em>Journal of statistical computation
and simulation</em>, <strong>24</strong>:2,  99-106.
</p>
</li>
<li>
<p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li>
<p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li>
<p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
</ul>
</div>