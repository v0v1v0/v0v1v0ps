<div class="container">

<table style="width: 100%;"><tr>
<td>PowerRelation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PowerRelation object</h2>

<h3>Description</h3>

<p>Create a <code>PowerRelation</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PowerRelation(
  equivalenceClasses,
  elements = NULL,
  coalitionLookup = NULL,
  elementLookup = NULL
)

is.PowerRelation(x, ...)

## S3 method for class 'PowerRelation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>equivalenceClasses</code></td>
<td>
<p>A nested list of lists, each containing coalitions or groups represented as vectors that are in the same equivalence class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements in power relation. Only set this value if you know what you are doing. See Details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coalitionLookup</code></td>
<td>
<p>A function taking a vector parameter and returning an index. See return value for more details. Only set this value if you know what you are doing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elementLookup</code></td>
<td>
<p>A function taking an element and returning a list of 2-sized tuples. See return value for more details. Only set this value if you know what you are doing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A power relation describes the ordinal information between elements.
Here specifically, we are interested in the power relation between coalitions, or groups of elements.
Each coalition is assumed to be a vector containing zero (empty coalition), one (singleton) or more elements.
</p>
<p><code>createPowerset()</code> offers a convenient way of creating a power set over a set of elements that can be used to call <code>PowerRelation()</code> or <code>as.PowerRelation()</code>.
</p>
<p>Trying to figure out what equivalence class certain coalitions or elements belong to is quite common.
For these sets of problems, the functions <code style="white-space: pre;">⁠$coalitionLookup(v)⁠</code> and <code style="white-space: pre;">⁠$elementLookup(e)⁠</code> should be utilized.
We use some redundancy to speed up the lookup methods.
As such, it is highly discouraged to edit a <code>PowerRelation</code> object directly, as the different power relation representations will fall out of sync.
For more information, see the vignette: <code>vignette(package = 'socialranking')</code>
</p>
<p>The <code>PowerRelation()</code> function expects a nested list of coalitions as input. For alternatives, see <code>as.PowerRelation()</code>.
</p>


<h3>Value</h3>

<p><code>PowerRelation</code> object containing the following values:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$elements⁠</code>: vector of elements
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$eqs⁠</code>: equivalence classes. Nested list of lists, each containing vectors representing groups of elements in the same equivalence class
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$coalitionLookup⁠</code>: <code style="white-space: pre;">⁠function(v)⁠</code> taking a coalition vector <code>v</code> and returning the equivalence class it belongs to. See <code>coalitionLookup()</code> for more.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$elementLookup⁠</code>: <code style="white-space: pre;">⁠function(e)⁠</code> taking an element <code>e</code> and returning a list of 2-sized tuples. See <code>elementLookup()</code> for more.
</p>
</li>
</ul>
<h3>Mathematical background</h3>

<p>Let <code class="reqn">N = \lbrace 1, ..., n \rbrace</code> be a finite set of <em>elements</em> (also called players).
Any subset <code class="reqn">S \subseteq N</code> is considered to be a group or coalition of elements,
where <code class="reqn">\{\}</code> is referred to as the empty coalition, <code class="reqn">\{i\}</code> as a singleton (a coalition of size 1), and <code class="reqn">N</code> as the grand coalition.
The power set <code class="reqn">2^N</code> denotes the set of all subsets over <code class="reqn">N</code>.
</p>
<p>Let <code class="reqn">\mathcal{P} \subseteq 2^N</code> be a collection of coalitions.
A <em>power relation</em> on <code class="reqn">\mathcal{P}</code> is a total preorder <code class="reqn">\succsim \subseteq \mathcal{P} \times \mathcal{P}</code>.
That is, for any two coalitions <code class="reqn">S, T \in \mathcal{P}</code>, either <code class="reqn">(S,T) \in \succsim</code>, or <code class="reqn">(T,S) \in \succsim</code>, or both.
In other words, we can compare any two groups of elements in <code class="reqn">\mathcal{P}</code> and determine, if one group is better than, worse than, or equivalent to the other.
</p>
<p>More commonly, the relation <code class="reqn">(S,T) \in \succsim</code> is notated as <code class="reqn">S \succsim T</code>.
</p>
<p><code class="reqn">\mathcal{T}(\mathcal{P})</code> denotes the family of all power relations on every collection <code class="reqn">\mathcal{P} \subseteq 2^N</code>.
Given a power relation <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code>, <code class="reqn">\sim</code> denotes its symmetric part whereas <code class="reqn">\succ</code> its asymmetric part.
Let <code class="reqn">S, T \in \mathcal{P}</code>.
Then,
</p>
<p style="text-align: center;"><code class="reqn">
S \sim T \textrm{ if } S \succsim T \textrm{ and } T \succsim S,\\
S \succ T \textrm{ if } S \succsim T \textrm{ and not } T \succsim S.
</code>
</p>

<p>Coalitions which are deemed equivalent (<code class="reqn">S \sim T</code>) can be collected into an equivalence class <code class="reqn">\Sigma_i</code>.
The list of equivalence classes forms a linear order, <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code>.
</p>


<h3>Mathematical example</h3>

<p>As an example, consider the elements <code class="reqn">N = \{\textrm{apple}, \textrm{banana}, \textrm{chocolate}\}</code>.
Each of them individually may go well with pancakes, but we are also interested in the combination of condiments.
If we consider all possibilities, we will have to compare the sets
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{P} = 2^N = \{\{a,b,c\}, \{a,b\}, \{a,c\}, \{b,c\}, \{a\}, \{b\}, \{c\}, \{\}\}.</code>
</p>

<p>Looking for a way to rank this group of objects, one may arrive at the following total preorder <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code>:
</p>
<p style="text-align: center;"><code class="reqn">\{b,c\} \succ (\{a\} \sim \{c\}) \succ \{b\} \succ \{\} \succ (\{a,b,c\} \sim \{a,b\} \sim \{a, c\}).</code>
</p>

<p>In this particular case, we get five equivalence classes.
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_1 = \{\{b,c\}\}\\
\Sigma_2 = \{\{a\}, \{c\}\}\\
\Sigma_3 = \{\{b\}\}\\
\Sigma_4 = \{\{\}\}\\
\Sigma_5 = \{\{a,b,c\},\{a,b\},\{a,c\}\}
</code>
</p>

<p>The power relation <code class="reqn">\succsim</code> can be copy-pasted as a character string to the <code>as.PowerRelation()</code> function (it should accept the special characters <code class="reqn">\succsim</code> and <code class="reqn">\sim</code>).
</p>
<p><code>as.PowerRelation("{b,c} &gt; ({a} ~ {c}) &gt; {b} &gt; {} &gt; ({a,b,c} ~ {a,b} ~ {a,c})")</code>
</p>


<h3>References</h3>

<p>Moretti S, Öztürk M (2017).
“Some axiomatic and algorithmic perspectives on the social ranking problem.”
In <em>International Conference on Algorithmic Decision Theory</em>, 166–181.
Springer.
</p>
<p>Bernardi G, Lucchetti R, Moretti S (2019).
“Ranking objects from a preference relation over their subsets.”
<em>Social Choice and Welfare</em>, <b>52</b>(4), 589–606.
</p>
<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
“Lexicographic solutions for coalitional rankings.”
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1–33.
</p>


<h3>See Also</h3>

<p>Other ways to create a <code>PowerRelation()</code> object using <code>as.PowerRelation()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- PowerRelation(list(
  list(c(1,2,3)),
  list(c(1, 2), 2, 3),
  list(c(2, 3), c()),
  list(c(1, 3)),
  list(1)
))

pr
# 123 &gt; (12 ~ 2 ~ 3) &gt; (23 ~ {}) &gt; 13 &gt; 1

stopifnot(pr$elements == 1:3)
stopifnot(pr$coalitionLookup(1) == 5)
stopifnot(pr$coalitionLookup(c()) == 3)
stopifnot(pr$coalitionLookup(c(1,2)) == 2)

# find coalitions an element appears in
for(t in pr$elementLookup(2)) {
  stopifnot(2 %in% pr$eqs[[t[1]]][[t[2]]])
}

# use createPowerset to help generate a valid function call
if(interactive())
  createPowerset(letters[1:3], result = "copy")

# pasted, rearranged using alt+up / alt+down in RStudio

# note that the function call looks different if elements are multiple characters long
if(interactive())
  createPowerset(c("apple", "banana", "chocolate"), result = "copy")

# pasted clipboard
PowerRelation(rlang::list2(
  list(c("banana", "chocolate")),
  list(c("apple"),
       c("chocolate")),
  list(c("banana")),
  list(c()),
  list(c("apple", "banana", "chocolate"),
       c("apple", "banana"),
       c("apple", "chocolate")),
))
# {banana, chocolate} &gt; ({apple} ~ {chocolate}) &gt; {banana} &gt; {} &gt; ...

</code></pre>


</div>