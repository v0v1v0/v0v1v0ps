<div class="container">

<table style="width: 100%;"><tr>
<td>F_from_f</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distribution and quantile functions from angular function</h2>

<h3>Description</h3>

<p>Numerical computation of the distribution function <code class="reqn">F</code> and
the quantile function <code class="reqn">F^{-1}</code> for an angular function
<code class="reqn">f</code> in a tangent-normal decomposition.
<code class="reqn">F^{-1}(x)</code> results from the inversion of
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \int_{-1}^x \omega_{p - 1}c_f f(z) (1 - z^2)^{(p - 3) / 2}
\,\mathrm{d}z</code>
</p>

<p>for <code class="reqn">x\in [-1, 1]</code>, where <code class="reqn">c_f</code> is a normalizing constant and
<code class="reqn">\omega_{p - 1}</code> is the surface area of <code class="reqn">S^{p - 2}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">F_from_f(f, p, Gauss = TRUE, N = 320, K = 1000, tol = 1e-06, ...)

F_inv_from_f(f, p, Gauss = TRUE, N = 320, K = 1000, tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>angular function defined on <code class="reqn">[-1, 1]</code>. Must be vectorized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gauss</code></td>
<td>
<p>use a Gauss–Legendre quadrature
rule to integrate <code class="reqn">f</code> with <code>N</code> nodes? Otherwise, rely on
<code>integrate</code> Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of points used in the Gauss–Legendre quadrature. Defaults
to <code>320</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">F^{-1}</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance passed to <code>uniroot</code> for the inversion of
<code class="reqn">F</code>. Also, passed to <code>integrate</code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters passed to <code>f</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The normalizing constant <code class="reqn">c_f</code> is such that <code class="reqn">F(1) = 1</code>. It does not
need to be part of <code>f</code> as it is computed internally.
</p>
<p>Interpolation is performed by a monotone cubic spline. <code>Gauss = TRUE</code>
yields more accurate results, at expenses of a heavier computation.
</p>
<p>If <code>f</code> yields negative values, these are silently truncated to zero.
</p>


<h3>Value</h3>

<p>A <code>splinefun</code> object ready to evaluate <code class="reqn">F</code> or
<code class="reqn">F^{-1}</code>, as specified.
</p>


<h3>Examples</h3>

<pre><code class="language-R">f &lt;- function(x) rep(1, length(x))
plot(F_from_f(f = f, p = 4, Gauss = TRUE), ylab = "F(x)", xlim = c(-1, 1))
plot(F_from_f(f = f, p = 4, Gauss = FALSE), col = 2, add = TRUE,
     xlim = c(-1, 1))
curve(p_proj_unif(x = x, p = 4), col = 3, add = TRUE, n = 300)
plot(F_inv_from_f(f = f, p = 4, Gauss = TRUE), ylab = "F^{-1}(x)")
plot(F_inv_from_f(f = f, p = 4, Gauss = FALSE), col = 2, add = TRUE)
curve(q_proj_unif(u = x, p = 4), col = 3, add = TRUE, n = 300)
</code></pre>


</div>