<div class="container">

<table style="width: 100%;"><tr>
<td>plot_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot regression models</h2>

<h3>Description</h3>

<p><code>plot_model()</code> creates plots from regression models, either
estimates (as so-called forest or dot whisker plots) or marginal effects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_model(
  model,
  type = c("est", "re", "eff", "emm", "pred", "int", "std", "std2", "slope", "resid",
    "diag"),
  transform,
  terms = NULL,
  sort.est = NULL,
  rm.terms = NULL,
  group.terms = NULL,
  order.terms = NULL,
  pred.type = c("fe", "re"),
  mdrt.values = c("minmax", "meansd", "zeromax", "quart", "all"),
  ri.nr = NULL,
  title = NULL,
  axis.title = NULL,
  axis.labels = NULL,
  legend.title = NULL,
  wrap.title = 50,
  wrap.labels = 25,
  axis.lim = NULL,
  grid.breaks = NULL,
  ci.lvl = NULL,
  se = NULL,
  robust = FALSE,
  vcov.fun = NULL,
  vcov.type = NULL,
  vcov.args = NULL,
  colors = "Set1",
  show.intercept = FALSE,
  show.values = FALSE,
  show.p = TRUE,
  show.data = FALSE,
  show.legend = TRUE,
  show.zeroinf = TRUE,
  value.offset = NULL,
  value.size,
  jitter = NULL,
  digits = 2,
  dot.size = NULL,
  line.size = NULL,
  vline.color = NULL,
  p.threshold = c(0.05, 0.01, 0.001),
  p.val = NULL,
  p.adjust = NULL,
  grid,
  case,
  auto.label = TRUE,
  prefix.labels = c("none", "varname", "label"),
  bpe = "median",
  bpe.style = "line",
  bpe.color = "white",
  ci.style = c("whisker", "bar"),
  std.response = TRUE,
  ...
)

get_model_data(
  model,
  type = c("est", "re", "eff", "pred", "int", "std", "std2", "slope", "resid", "diag"),
  transform,
  terms = NULL,
  sort.est = NULL,
  rm.terms = NULL,
  group.terms = NULL,
  order.terms = NULL,
  pred.type = c("fe", "re"),
  ri.nr = NULL,
  ci.lvl = NULL,
  colors = "Set1",
  grid,
  case = "parsed",
  digits = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A regression model object. Depending on the <code>type</code>, many
kinds of models are supported, e.g. from packages like <span class="pkg">stats</span>,
<span class="pkg">lme4</span>, <span class="pkg">nlme</span>, <span class="pkg">rstanarm</span>, <span class="pkg">survey</span>, <span class="pkg">glmmTMB</span>,
<span class="pkg">MASS</span>, <span class="pkg">brms</span> etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of plot. There are three groups of plot-types: <br><br><em>Coefficients</em> (<a href="https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html">related vignette</a>)
</p>

<dl>
<dt><code>type = "est"</code></dt>
<dd>
<p>Forest-plot of estimates. If the fitted model
only contains one predictor, slope-line is plotted.</p>
</dd>
<dt><code>type = "re"</code></dt>
<dd>
<p>For mixed effects models, plots the random
effects.</p>
</dd>
<dt><code>type = "std"</code></dt>
<dd>
<p>Forest-plot of standardized coefficients.</p>
</dd>
<dt><code>type = "std2"</code></dt>
<dd>
<p>Forest-plot of standardized coefficients,
however, standardization is done by dividing by two SD (see 'Details').</p>
</dd>
</dl>
<p><em>Marginal Effects</em>  (<a href="https://strengejacke.github.io/sjPlot/articles/plot_marginal_effects.html">related vignette</a>)
</p>

<dl>
<dt><code>type = "pred"</code></dt>
<dd>
<p>Predicted values (marginal effects) for
specific model terms. See <code>ggpredict</code> for details.</p>
</dd>
<dt><code>type = "eff"</code></dt>
<dd>
<p>Similar to <code>type = "pred"</code>, however,
discrete predictors are held constant at their proportions (not reference
level). See <code>ggeffect</code> for details.</p>
</dd>
<dt><code>type = "emm"</code></dt>
<dd>
<p>Similar to <code>type = "eff"</code>, see
<code>ggemmeans</code> for details.</p>
</dd>
<dt><code>type = "int"</code></dt>
<dd>
<p>Marginal effects of interaction terms in
<code>model</code>.</p>
</dd>
</dl>
<p><em>Model diagnostics</em>
</p>

<dl>
<dt><code>type = "slope"</code></dt>
<dd>
<p>Slope of coefficients for each single
predictor, against the response (linear relationship between each model
term and response). See 'Details'.</p>
</dd>
<dt><code>type = "resid"</code></dt>
<dd>
<p>Slope of coefficients for each single
predictor, against the residuals (linear relationship between each model
term and residuals). See 'Details'.</p>
</dd>
<dt><code>type = "diag"</code></dt>
<dd>
<p>Check model assumptions. See 'Details'.</p>
</dd>
</dl>
<p><strong>Note:</strong> For mixed models, the diagnostic plots like linear relationship
or check for Homoscedasticity, do <strong>not</strong> take the uncertainty of
random effects into account, but is only based on the fixed effects part
of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>A character vector, naming a function that will be applied
on estimates and confidence intervals. By default, <code>transform</code> will
automatically use <code>"exp"</code> as transformation for applicable classes of
<code>model</code> (e.g. logistic or poisson regression). Estimates of linear
models remain untransformed. Use <code>NULL</code> if you want the raw,
non-transformed estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>Character vector with the names of those terms from <code>model</code>
that should be plotted. This argument depends on the plot-type:
</p>

<dl>
<dt><em>Coefficients</em></dt>
<dd>
<p>Select terms that should be plotted. All other
term are removed from the output. Note that the term names must match
the names of the model's coefficients. For factors, this means that
the variable name is suffixed with the related factor level, and each
category counts as one term. E.g. <code>rm.terms = "t_name [2,3]"</code>
would remove the terms <code>"t_name2"</code> and <code>"t_name3"</code> (assuming
that the variable <code>t_name</code> is categorical and has at least
the factor levels <code>2</code> and <code>3</code>). Another example for the
<em>iris</em>-dataset: <code>terms = "Species"</code> would not work, instead
you would write <code>terms = "Species [versicolor,virginica]"</code> to
remove these two levels, or <code>terms = "Speciesversicolor"</code> if you
just want to remove the level <em>versicolor</em> from the plot.</p>
</dd>
<dt><em>Marginal Effects</em></dt>
<dd>
<p>Here <code>terms</code> indicates for which
terms marginal effects should be displayed. At least one term is
required to calculate effects, maximum length is three terms, where
the second and third term indicate the groups, i.e. predictions of
first term are grouped by the levels of the second (and third) term.
<code>terms</code> may also indicate higher order terms (e.g. interaction
terms). Indicating levels in square brackets allows for selecting only
specific groups. Term name and levels in brackets must be separated by
a whitespace character, e.g. <code>terms = c("age", "education [1,3]")</code>.
It is also possible to specify a range of numeric values for the
predictions with a colon, for instance <code>terms = c("education [1,3]",
     "age [30:50]")</code>. Furthermore, it is possible to specify a function name.
Values for predictions will then be transformed, e.g.
<code>terms = "income [exp]"</code>. This is useful when model predictors were
transformed for fitting the model and should be back-transformed to the
original scale for predictions. Finally, numeric vectors for which no
specific values are given, a "pretty range" is calculated, to avoid
memory allocation problems for vectors with many unique values. If a
numeric vector is specified as second or third term (i.e. if this vector
represents a grouping structure), representative values (see
<code>values_at</code>) are chosen. If all values for a
numeric vector should be used to compute predictions, you may use
e.g. terms = "age [all]". For more details, see
<code>ggpredict</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.est</code></td>
<td>
<p>Determines in which way estimates are sorted in the plot:
</p>

<ul>
<li>
<p> If <code>NULL</code> (default), no sorting is done and estimates are sorted in the same order as they appear in the model formula.
</p>
</li>
<li>
<p> If <code>TRUE</code>, estimates are sorted in descending order, with highest estimate at the top.
</p>
</li>
<li>
<p> If <code>sort.est = "sort.all"</code>, estimates are re-sorted for each coefficient (only applies if <code>type = "re"</code> and <code>grid = FALSE</code>), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
</p>
</li>
<li>
<p> If <code>type = "re"</code>, specify a predictor's / coefficient's name to sort estimates according to this random effect.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.terms</code></td>
<td>
<p>Character vector with names that indicate which terms should
be removed from the plot. Counterpart to <code>terms</code>. <code>rm.terms =
"t_name"</code> would remove the term <em>t_name</em>. Default is <code>NULL</code>, i.e.
all terms are used. For factors, levels that should be removed from the plot
need to be explicitely indicated in square brackets, and match the model's
coefficient names, e.g. <code>rm.terms = "t_name [2,3]"</code> would remove the terms
<code>"t_name2"</code> and <code>"t_name3"</code> (assuming that the variable <code>t_name</code>
was categorical and has at least the factor levels <code>2</code> and <code>3</code>).
Another example for the <em>iris</em> dataset would be
<code>rm.terms = "Species [versicolor,virginica]"</code>. Note that the
<code>rm.terms</code>-argument does not apply to <em>Marginal Effects</em> plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.terms</code></td>
<td>
<p>Numeric vector with group indices, to group coefficients.
Each group of coefficients gets its own color (see 'Examples').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.terms</code></td>
<td>
<p>Numeric vector, indicating in which order the coefficients
should be plotted. See examples in
<a href="https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html">this package-vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.type</code></td>
<td>
<p>Character, only applies for <em>Marginal Effects</em> plots
with mixed effects models. Indicates whether predicted values should be
conditioned on random effects (<code>pred.type = "re"</code>) or fixed effects
only (<code>pred.type = "fe"</code>, the default). For details, see documentation
of the <code>type</code>-argument in <code>ggpredict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mdrt.values</code></td>
<td>
<p>Indicates which values of the moderator variable should be
used when plotting interaction terms (i.e. <code>type = "int"</code>). </p>

<dl>
<dt><code>"minmax"</code></dt>
<dd>
<p>(default) minimum and maximum values (lower and
upper bounds) of the moderator are used to plot the interaction between
independent variable and moderator(s).</p>
</dd> <dt><code>"meansd"</code></dt>
<dd>
<p>uses the
mean value of the moderator as well as one standard deviation below and
above mean value to plot the effect of the moderator on the independent
variable (following the convention suggested by Cohen and Cohen and
popularized by Aiken and West (1991), i.e. using the mean, the value one
standard deviation above, and the value one standard deviation below the
mean as values of the moderator, see
<a href="https://www.theanalysisfactor.com/3-tips-interpreting-moderation/">Grace-Martin
K: 3 Tips to Make Interpreting Moderation Effects Easier</a>).</p>
</dd>
<dt><code>"zeromax"</code></dt>
<dd>
<p>is similar to the <code>"minmax"</code> option, however,
<code>0</code> is always used as minimum value for the moderator. This may be
useful for predictors that don't have an empirical zero-value, but absence
of moderation should be simulated by using 0 as minimum.</p>
</dd>
<dt><code>"quart"</code></dt>
<dd>
<p>calculates and uses the quartiles (lower, median and
upper) of the moderator value.</p>
</dd> <dt><code>"all"</code></dt>
<dd>
<p>uses all values of the
moderator variable.</p>
</dd> </dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ri.nr</code></td>
<td>
<p>Numeric vector. If <code>type = "re"</code> and fitted model has more
than one random intercept, <code>ri.nr</code> indicates which random effects of
which random intercept (or: which list elements of
<code>ranef</code>) will be plotted. Default is <code>NULL</code>, so all
random effects will be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>Character vector, used as plot title. By default,
<code>response_labels</code> is called to retrieve the label of
the dependent variable, which will be used as title. Use <code>title = ""</code>
to remove title.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis.title</code></td>
<td>
<p>Character vector of length one or two (depending on the
plot function and type), used as title(s) for the x and y axis. If not
specified, a default labelling  is chosen. <strong>Note:</strong> Some plot types
may not support this argument sufficiently. In such cases, use the returned
ggplot-object and add axis titles manually with
<code>labs</code>. Use <code>axis.title = ""</code> to remove axis
titles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis.labels</code></td>
<td>
<p>Character vector with labels for the model terms, used as
axis labels. By default, <code>term_labels</code> is
called to retrieve the labels of the coefficients, which will be used as
axis labels. Use <code>axis.labels = ""</code> or <code>auto.label = FALSE</code> to
use the variable names as labels instead. If <code>axis.labels</code> is a named
vector, axis labels (by default, the names of the model's coefficients)
will be matched with the names of <code>axis.label</code>. This ensures that
labels always match the related axis value, no matter in which way
axis labels are sorted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.title</code></td>
<td>
<p>Character vector, used as legend title for plots that
have a legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap.title</code></td>
<td>
<p>Numeric, determines how many chars of the plot title are
displayed in one line and when a line break is inserted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap.labels</code></td>
<td>
<p>Numeric, determines how many chars of the value, variable
or axis labels are displayed in one line and when a line break is inserted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis.lim</code></td>
<td>
<p>Numeric vector of length 2, defining the range of the plot
axis. Depending on plot-type, may effect either x- or y-axis. For
<em>Marginal Effects</em> plots, <code>axis.lim</code> may also be a list of two
vectors of length 2, defining axis limits for both the x and y axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.breaks</code></td>
<td>
<p>Numeric value or vector; if <code>grid.breaks</code> is a
single value, sets the distance between breaks for the axis at every
<code>grid.breaks</code>'th position, where a major grid line is plotted. If
<code>grid.breaks</code> is a vector, values will be used to define the
axis positions of the major grid lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.lvl</code></td>
<td>
<p>Numeric, the level of the confidence intervals (error bars).
Use <code>ci.lvl = NA</code> to remove error bars. For <code>stanreg</code>-models,
<code>ci.lvl</code> defines the (outer) probability for the <em>credible interval</em>
that is plotted (see <code>ci</code>). By
default, <code>stanreg</code>-models are printed with two intervals: the "inner"
interval, which defaults to the 50%-CI; and the "outer" interval, which
defaults to the 89%-CI. <code>ci.lvl</code> affects only the outer interval in
such cases. See <code>prob.inner</code> and <code>prob.outer</code> under the
<code>...</code>-argument for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the standard errors are
also printed. If robust standard errors are required, use arguments
<code>vcov.fun</code>, <code>vcov.type</code> and <code>vcov.args</code> (see
<code>standard_error</code> for details), or use argument
<code>robust</code> as shortcut. <code>se</code> overrides
<code>ci.lvl</code>: if not <code>NULL</code>, arguments <code>ci.lvl</code> and <code>transform</code>
will be ignored. Currently, <code>se</code> only applies to <em>Coefficients</em> plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>Deprecated. Please use <code>vcov.fun</code> directly to specify
the estimation of the variance-covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.fun</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty
estimates (e.g., for robust standard errors). This argument accepts a
covariance matrix, a function which returns a covariance matrix, or a
string which identifies the function to be used to compute the covariance
matrix. See <code>model_parameters()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.type</code></td>
<td>
<p>Deprecated. The <code>type</code>-argument is now included in
<code>vcov.args</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.args</code></td>
<td>
<p>List of arguments to be passed to the function identified by
the <code>vcov.fun</code> argument. This function is typically supplied by the
<span class="pkg">sandwich</span> or <span class="pkg">clubSandwich</span> packages. Please refer to their
documentation (e.g., <code>?sandwich::vcovHAC</code>) to see the list of
available arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colors</code></td>
<td>
<p>May be a character vector of color values in hex-format, valid
color value names (see <code>demo("colors")</code>) or a name of a pre-defined
color palette. Following options are valid for the <code>colors</code> argument:
</p>

<ul>
<li>
<p> If not specified, a default color brewer palette will be used, which is suitable for the plot style.
</p>
</li>
<li>
<p> If <code>"gs"</code>, a greyscale will be used.
</p>
</li>
<li>
<p> If <code>"bw"</code>, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see <a href="https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html">this package-vignette</a>).
</p>
</li>
<li>
<p> If <code>colors</code> is any valid color brewer palette name, the related palette will be used. Use <code>RColorBrewer::display.brewer.all()</code> to view all available palette names.
</p>
</li>
<li>
<p> There are some pre-defined color palettes in this package, see <code>sjPlot-themes</code> for details.
</p>
</li>
<li>
<p> Else specify own color values or names as vector (e.g. <code>colors = "#00ff00"</code> or <code>colors = c("firebrick", "blue")</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.intercept</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the intercept of the fitted
model is also plotted. Default is <code>FALSE</code>. If <code>transform =
"exp"</code>, please note that due to exponential transformation of estimates,
the intercept in some cases is non-finite and the plot can not be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.values</code></td>
<td>
<p>Logical, whether values should be plotted or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.p</code></td>
<td>
<p>Logical, adds asterisks that indicate the significance level of
estimates to the value labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.data</code></td>
<td>
<p>Logical, for <em>Marginal Effects</em> plots, also plots the
raw data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>For <em>Marginal Effects</em> plots, shows or hides the
legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.zeroinf</code></td>
<td>
<p>Logical, if <code>TRUE</code>, shows the zero-inflation part of
hurdle- or zero-inflated models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.offset</code></td>
<td>
<p>Numeric, offset for text labels to adjust their position
relative to the dots or lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.size</code></td>
<td>
<p>Numeric, indicates the size of value labels. Can be used
for all plot types where the argument <code>show.values</code> is applicable,
e.g. <code>value.size = 4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>Numeric, between 0 and 1. If <code>show.data = TRUE</code>, you can
add a small amount of random variation to the location of each data point.
<code>jitter</code> then indicates the width, i.e. how much of a bin's width
will be occupied by the jittered values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Numeric, amount of digits after decimal point when rounding
estimates or values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dot.size</code></td>
<td>
<p>Numeric, size of the dots that indicate the point estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line.size</code></td>
<td>
<p>Numeric, size of the lines that indicate the error bars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vline.color</code></td>
<td>
<p>Color of the vertical "zero effect" line. Default color is
inherited from the current theme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.threshold</code></td>
<td>
<p>Numeric vector of length 3, indicating the treshold for
annotating p-values with asterisks. Only applies if
<code>p.style = "asterisk"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val</code></td>
<td>
<p>Character specifying method to be used to calculate p-values.
Defaults to "profile" for glm/polr models, otherwise "wald".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.adjust</code></td>
<td>
<p>Character vector, if not <code>NULL</code>, indicates the method
to adjust p-values. See <code>p.adjust</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Logical, if <code>TRUE</code>, multiple plots are plotted as grid
layout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case</code></td>
<td>
<p>Desired target case. Labels will automatically converted into the
specified character case. See <code>snakecase::to_any_case()</code> for more
details on this argument. By default, if <code>case</code> is not specified,
it will be set to <code>"parsed"</code>, unless <code>prefix.labels</code> is not
<code>"none"</code>. If <code>prefix.labels</code> is either <code>"label"</code> (or
<code>"l"</code>) or <code>"varname"</code> (or <code>"v"</code>) and <code>case</code> is not
specified, it will be set to <code>NULL</code> - this is a more convenient
default when prefixing labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto.label</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default),
and <a href="https://strengejacke.github.io/sjlabelled/articles/intro_sjlabelled.html">data is labelled</a>,
<code>term_labels</code> is called to retrieve the labels
of the coefficients, which will be used as predictor labels. If data is
not labelled, <a href="https://easystats.github.io/parameters/reference/format_parameters.html">format_parameters()</a>
is used to create pretty labels. If <code>auto.label = FALSE</code>,
original variable names and value labels (factor levels) are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix.labels</code></td>
<td>
<p>Indicates whether the value labels of categorical variables
should be prefixed, e.g. with the variable name or variable label. See
argument <code>prefix</code> in <code>term_labels</code> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bpe</code></td>
<td>
<p>For <strong>Stan</strong>-models (fitted with the <span class="pkg">rstanarm</span>- or
<span class="pkg">brms</span>-package), the Bayesian point estimate is, by default, the median
of the posterior distribution. Use <code>bpe</code> to define other functions to
calculate the Bayesian point estimate. <code>bpe</code> needs to be a character
naming the specific function, which is passed to the <code>fun</code>-argument in
<code>typical_value</code>. So, <code>bpe = "mean"</code> would
calculate the mean value of the posterior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bpe.style</code></td>
<td>
<p>For <strong>Stan</strong>-models (fitted with the <span class="pkg">rstanarm</span>- or
<span class="pkg">brms</span>-package), the Bayesian point estimate is indicated as a small,
vertical line by default. Use <code>bpe.style = "dot"</code> to plot a dot
instead of a line for the point estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bpe.color</code></td>
<td>
<p>Character vector, indicating the color of the Bayesian
point estimate. Setting <code>bpe.color = NULL</code> will inherit the color
from the mapped aesthetic to match it with the geom's color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.style</code></td>
<td>
<p>Character vector, defining whether inner and outer intervals
for Bayesion models are shown in boxplot-style (<code>"whisker"</code>) or in
bars with different alpha-levels (<code>"bar"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.response</code></td>
<td>
<p>Logical, whether the response variable will also be
standardized if standardized coefficients are requested. Setting both
<code>std.response = TRUE</code> and <code>show.std = TRUE</code> will behave as if
the complete data was standardized before fitting the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments, passed down to various functions. Here is a list
of supported arguments and their description in detail.
</p>

<dl>
<dt>
<code>prob.inner</code> and <code>prob.outer</code>
</dt>
<dd>
<p>For <strong>Stan</strong>-models
(fitted with the <span class="pkg">rstanarm</span>- or <span class="pkg">brms</span>-package) and coefficients
plot-types, you can specify numeric values between 0 and 1 for
<code>prob.inner</code> and <code>prob.outer</code>, which will then be used as inner
and outer probabilities for the uncertainty intervals (HDI). By default,
the inner probability is 0.5 and the outer probability is 0.89 (unless
<code>ci.lvl</code> is specified - in this case, <code>ci.lvl</code> is used as outer
probability).
</p>
</dd>
<dt><code>size.inner</code></dt>
<dd>
<p>For <strong>Stan</strong>-models and <em>Coefficients</em>
plot-types, you can specify the width of the bar for the inner
probabilities. Default is <code>0.1</code>. Setting <code>size.inner = 0</code>
removes the inner probability regions.
</p>
</dd>
<dt>
<code>width</code>, <code>alpha</code>, and <code>scale</code>
</dt>
<dd>
<p>Passed
down to <code>geom_errorbar()</code> or <code>geom_density_ridges()</code>, for
forest or diagnostic plots.
</p>
</dd>
<dt>
<code>width</code>, <code>alpha</code>, <code>dot.alpha</code>, <code>dodge</code> and <code>log.y</code>
</dt>
<dd>
<p>Passed
down to <code>plot.ggeffects</code> for <em>Marginal Effects</em>
plots.
</p>
</dd>
<dt><code>show.loess</code></dt>
<dd>
<p>Logical, for diagnostic plot-types <code>"slope"</code>
and <code>"resid"</code>, adds (or hides) a loess-smoothed line to the plot.
</p>
</dd>
<dt>
<em>Marginal Effects</em> plot-types</dt>
<dd>
<p>When plotting marginal effects,
arguments are also passed down to <code>ggpredict</code>,
<code>ggeffect</code> or <code>plot.ggeffects</code>.
</p>
</dd>
<dt>Case conversion of labels</dt>
<dd>
<p>For case conversion of labels (see argument
<code>case</code>), arguments <code>sep_in</code> and <code>sep_out</code> will be passed
down to <code>snakecase::to_any_case()</code>. This only
applies to automatically retrieved term labels, <em>not</em> if
term labels are provided by the <code>axis.labels</code>-argument.
</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Different Plot Types</h4>


<dl>
<dt><code>type = "std"</code></dt>
<dd>
<p>Plots standardized estimates. See details below.</p>
</dd>
<dt><code>type = "std2"</code></dt>
<dd>
<p>Plots standardized estimates, however,
standardization follows Gelman's (2008) suggestion, rescaling the
estimates by dividing them by two standard deviations instead of just one.
Resulting coefficients are then directly comparable for untransformed
binary predictors.
</p>
</dd>
<dt><code>type = "pred"</code></dt>
<dd>
<p>Plots estimated marginal means (or marginal effects).
Simply wraps <code>ggpredict</code>. See also
<a href="https://strengejacke.github.io/sjPlot/articles/plot_marginal_effects.html">this package-vignette</a>.
</p>
</dd>
<dt><code>type = "eff"</code></dt>
<dd>
<p>Plots estimated marginal means (or marginal effects).
Simply wraps <code>ggeffect</code>. See also
<a href="https://strengejacke.github.io/sjPlot/articles/plot_marginal_effects.html">this package-vignette</a>.
</p>
</dd>
<dt><code>type = "int"</code></dt>
<dd>
<p>A shortcut for marginal effects plots, where
interaction terms are automatically detected and used as
<code>terms</code>-argument. Furthermore, if the moderator variable (the second
- and third - term in an interaction) is continuous, <code>type = "int"</code>
automatically chooses useful values based on the <code>mdrt.values</code>-argument,
which are passed to <code>terms</code>. Then, <code>ggpredict</code>
is called. <code>type = "int"</code> plots the interaction term that appears
first in the formula along the x-axis, while the second (and possibly
third) variable in an interaction is used as grouping factor(s)
(moderating variable). Use <code>type = "pred"</code> or <code>type = "eff"</code>
and specify a certain order in the <code>terms</code>-argument to indicate
which variable(s) should be used as moderator. See also
<a href="https://strengejacke.github.io/sjPlot/articles/plot_interactions.html">this package-vignette</a>.
</p>
</dd>
<dt>
<code>type = "slope"</code> and <code>type = "resid"</code>
</dt>
<dd>
<p>Simple diagnostic-plots,
where a linear model for each single predictor is plotted against the
response variable, or the model's residuals. Additionally, a loess-smoothed
line is added to the plot. The main purpose of these plots is to check whether
the relationship between outcome (or residuals) and a predictor is roughly
linear or not. Since the plots are based on a simple linear regression with
only one model predictor at the moment, the slopes (i.e. coefficients) may
differ from the coefficients of the complete model.
</p>
</dd>
<dt><code>type = "diag"</code></dt>
<dd>
<p>For <strong>Stan-models</strong>, plots the prior versus
posterior samples. For <strong>linear (mixed) models</strong>, plots for
multicollinearity-check (Variance Inflation Factors), QQ-plots,
checks for normal distribution of residuals and homoscedasticity
(constant variance of residuals) are shown. For <strong>generalized
linear mixed models</strong>, returns the QQ-plot for random effects.
</p>
</dd>
</dl>
<h4>Standardized Estimates</h4>

<p>Default standardization is done by completely refitting the model on the
standardized data. Hence, this approach is equal to standardizing the
variables before fitting the model, which is particularly recommended for
complex models that include interactions or transformations (e.g., polynomial
or spline terms). When <code>type = "std2"</code>, standardization of estimates
follows <a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">Gelman's (2008)</a>
suggestion, rescaling the estimates by dividing them by two standard deviations
instead of just one. Resulting coefficients are then directly comparable for
untransformed binary predictors.
</p>



<h3>Value</h3>

<p>Depending on the plot-type, <code>plot_model()</code> returns a
<code>ggplot</code>-object or a list of such objects. <code>get_model_data</code>
returns the associated data with the plot-object as tidy data frame, or
(depending on the plot-type) a list of such data frames.
</p>


<h3>References</h3>

<p>Gelman A (2008) "Scaling regression inputs by dividing by two
standard deviations." <em>Statistics in Medicine 27: 2865-2873.</em>
<a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf</a>
<br><br>
Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># prepare data
if (requireNamespace("haven")) {
library(sjmisc)
data(efc)
efc &lt;- to_factor(efc, c161sex, e42dep, c172code)
m &lt;- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)

# simple forest plot
plot_model(m)

# grouped coefficients
plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))

# keep only selected terms in the model: pos_v_4, the
# levels 3 and 4 of factor e42dep and levels 2 and 3 for c172code
plot_model(m, terms = c("pos_v_4", "e42dep [3,4]", "c172code [2,3]"))
}

# multiple plots, as returned from "diagnostic"-plot type,
# can be arranged with 'plot_grid()'
## Not run: 
p &lt;- plot_model(m, type = "diag")
plot_grid(p)
## End(Not run)

# plot random effects
if (require("lme4") &amp;&amp; require("glmmTMB")) {
  m &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
  plot_model(m, type = "re")

  # plot marginal effects
  plot_model(m, type = "pred", terms = "Days")
}
# plot interactions
## Not run: 
m &lt;- glm(
  tot_sc_e ~ c161sex + c172code * neg_c_7,
  data = efc,
  family = poisson()
)
# type = "int" automatically selects groups for continuous moderator
# variables - see argument 'mdrt.values'. The following function call is
# identical to:
# plot_model(m, type = "pred", terms = c("c172code", "neg_c_7 [7,28]"))
plot_model(m, type = "int")

# switch moderator
plot_model(m, type = "pred", terms = c("neg_c_7", "c172code"))
# same as
# ggeffects::ggpredict(m, terms = c("neg_c_7", "c172code"))
## End(Not run)

# plot Stan-model
## Not run: 
if (require("rstanarm")) {
  data(mtcars)
  m &lt;- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
  plot_model(m, bpe.style = "dot")
}
## End(Not run)

</code></pre>


</div>