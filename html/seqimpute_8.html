<div class="container">

<table style="width: 100%;"><tr>
<td>seqimpute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>seqimpute: Imputation of missing data in longitudinal categorical data</h2>

<h3>Description</h3>

<p>The seqimpute package implements the MICT and MICT-timing 
methods. These are multiple imputation methods for longitudinal data. 
The core idea of the algorithms is to fills gaps of missing data, which is 
the typical form of missing data in a longitudinal setting, recursively from 
their edges. The prediction is based on either a multinomial or a 
random forest regression model. Covariates and time-dependent covariates 
can be included in the model. 
</p>
<p>The MICT-timing algorithm is an extension of the MICT algorithm designed 
to address a key limitation of the latter: its assumption that position in 
the trajectory is irrelevant.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seqimpute(
  data,
  var = NULL,
  np = 1,
  nf = 1,
  m = 5,
  timing = FALSE,
  frame.radius = 0,
  covariates = NULL,
  time.covariates = NULL,
  regr = "multinom",
  npt = 1,
  nfi = 1,
  ParExec = FALSE,
  ncores = NULL,
  SetRNGSeed = FALSE,
  verbose = TRUE,
  available = TRUE,
  pastDistrib = FALSE,
  futureDistrib = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing sequences of a categorical
variable with missing data (coded as <code>NA</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>np</code></td>
<td>
<p>number of previous observations in the imputation model 
of the internal gaps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nf</code></td>
<td>
<p>number of future observations in the imputation model 
of the internal gaps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of multiple imputations  (default: <code>5</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timing</code></td>
<td>
<p>a logical value that specifies if the MICT algorithm 
(timing=FALSE) or the MICT-timing algorithm (timing=TRUE) should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frame.radius</code></td>
<td>
<p>parameter relative to the MICT-timing algorithm 
specifying the radius of the timeframe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>the list of columns containing the covariates to include
in the imputation process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.covariates</code></td>
<td>
<p>the list of columns containing the time-varying 
covariates to include in the imputation process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regr</code></td>
<td>
<p>a character specifying the imputation method. If 
<code>regr="multinom"</code>, multinomial models are used, while 
if <code>regr="rf"</code>, random forest models are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npt</code></td>
<td>
<p>number of previous observations in the imputation model 
of the terminal gaps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfi</code></td>
<td>
<p>number of future observations in the imputation model 
of the initial gaps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ParExec</code></td>
<td>
<p>logical. If <code>TRUE</code>, the multiple imputations are run 
in parallel. This allows faster run time depending of how many cores 
the processor has.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>integer. Number of cores to be used for the parallel 
computation. If no value is set for this parameter, the number of cores 
will be set to the maximum number of CPU cores minus 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SetRNGSeed</code></td>
<td>
<p>an integer that is used to set the seed in the case of 
parallel computation. Note that setting <code>set.seed()</code> alone before the 
seqimpute function won't work in case of parallel computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, seqimpute will print history and 
warnings on console. Use <code>verbose=FALSE</code> for silent computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>available</code></td>
<td>
<p>a logical value allowing the user to choose whether 
to consider the already imputed data in the predictive model 
(<code>available = TRUE</code>) or not (<code>available = FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pastDistrib</code></td>
<td>
<p>a logical indicating if the past distribution should be 
used as predictor in the imputation model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>futureDistrib</code></td>
<td>
<p>a logical indicating if the future distribution 
should be used as predictor in the imputation model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Named arguments that are passed down to the imputation functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The imputation process is divided into several steps, depending on
the type of gaps of missing data. The order of imputation of the gaps are:
</p>

<dl>
<dt><code>Internal gap: </code></dt>
<dd>
<p>there is at least <code>np</code> observations 
before an internal gap and <code>nf</code> after the gap</p>
</dd>
<dt><code>Initial gap: </code></dt>
<dd>
<p>gaps situated at the very beginning 
of a trajectory</p>
</dd>
<dt><code>Terminal gap: </code></dt>
<dd>
<p>gaps situated at the very end
of a trajectory</p>
</dd>
<dt><code>Left-hand side specifically located gap (SLG): </code></dt>
<dd>
<p>gaps 
that have at least <code>nf</code> observations after the gap, but less than
<code>np</code> observation before it</p>
</dd>
<dt><code>Right-hand side SLG: </code></dt>
<dd>
<p>gaps 
that have at least <code>np</code> observations before the gap, but less than
<code>nf</code> observation after it</p>
</dd>
<dt><code>Both-hand side SLG: </code></dt>
<dd>
<p>gaps 
that have less than <code>np</code> observations before the gap, and less than
<code>nf</code> observations after it</p>
</dd>
</dl>
<p>The primary difference between the MICT and MICT-timing 
algorithms lies in their approach to selecting patterns from other 
sequences for fitting the multinomial model. While the MICT algorithm 
considers all similar patterns regardless of their temporal placement, 
MICT-timing restricts pattern selection to those that are temporally 
closest to the missing value. This refinement ensures that the 
imputation process adequately accounts for temporal dynamics, resulting 
in more accurate imputed values.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>seqimp</code>.
</p>


<h3>Author(s)</h3>

<p>Kevin Emery &lt;kevin.emery@unige.ch&gt;, Andre Berchtold,  
Anthony Guinchard, and Kamyar Taher
</p>


<h3>References</h3>

<p>HALPIN, Brendan (2012). Multiple imputation for life-course 
sequence data. Working Paper WP2012-01, Department of Sociology, 
University of Limerick. http://hdl.handle.net/10344/3639.
</p>
<p>HALPIN, Brendan (2013). Imputing sequence data: Extensions to 
initial and terminal gaps, Stata's. Working Paper WP2013-01, 
Department of Sociology, 
University of Limerick. http://hdl.handle.net/10344/3620
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Default multiple imputation of the trajectories of game addiction with the
# MICT algorithm

## Not run: 
set.seed(5)
imp1 &lt;- seqimpute(data = gameadd, var = 1:4)


# Default multiple imputation with the MICT-timing algorithm
set.seed(3)
imp2 &lt;- seqimpute(data = gameadd, var = 1:4, timing = TRUE)


# Inclusion in the MICt-timing imputation process of the three background 
# characteristics (Gender, Age and Track), and the time-varying covariate 
# about gambling


set.seed(4)
imp3 &lt;- seqimpute(data = gameadd, var = 1:4, covariates = 5:7, 
  time.covariates = 8:11)

  
# Parallel computation


imp4 &lt;- seqimpute(data = gameadd, var = 1:4, covariates = 5:7, 
  time.covariates = 8:11, ParExec = TRUE, ncores=5, SetRNGSeed = 2)

## End(Not run)

</code></pre>


</div>