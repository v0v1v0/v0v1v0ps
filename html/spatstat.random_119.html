<div class="container">

<table style="width: 100%;"><tr>
<td>rpoint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate N Random Points</h2>

<h3>Description</h3>

<p>Generate a random point pattern
containing <code class="reqn">n</code> independent, identically distributed random points
with any specified distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> rpoint(n, f, fmax=NULL, win=unit.square(),
        ..., giveup=1000, warn=TRUE, verbose=FALSE,
        nsim=1, drop=TRUE, forcewin=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>Number of points to generate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>

<p>The probability density of the points,
possibly un-normalised.
Either a constant,
a function <code>f(x,y,...)</code>, or a pixel image object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fmax</code></td>
<td>

<p>An upper bound on the values of <code>f</code>.
If missing, this number will be estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>win</code></td>
<td>

<p>Window in which to simulate the pattern.
(Ignored if <code>f</code> is a pixel image, unless <code>forcewin=TRUE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to the function <code>f</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>giveup</code></td>
<td>

<p>Number of attempts in the rejection method after which
the algorithm should stop trying to generate new points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>

<p>Logical value specifying whether to issue a warning if <code>n</code> is very large.
See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Flag indicating whether to report details of performance
of the simulation algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forcewin</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then simulations will be generated
inside <code>win</code> in all cases. If <code>FALSE</code> (the default),
the argument <code>win</code> is ignored when <code>f</code> is a pixel image.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates <code>n</code> independent, identically distributed
random points with common probability density proportional to
<code>f</code>.
</p>
<p>The argument <code>f</code> may be
</p>

<dl>
<dt>a numerical constant:</dt>
<dd>
<p>uniformly distributed random points will
be generated.
</p>
</dd>
<dt>a function:</dt>
<dd>
<p>random points will be generated
in the window <code>win</code> with probability density proportional
to <code>f(x,y,...)</code> where <code>x</code> and <code>y</code> are the cartesian
coordinates. The function <code>f</code> must accept 
two <em>vectors</em> of coordinates <code>x,y</code> and return the corresponding
vector of function values. Additional arguments <code>...</code> of any kind
may be passed to the function.
</p>
</dd>
<dt>a pixel image:</dt>
<dd>
<p>if <code>f</code> is a pixel image
(object of class <code>"im"</code>, see <code>im.object</code>)
then random points will be generated
with probability density
proportional to the pixel values of <code>f</code>.
To be precise, pixels are selected with probabilities proportional
to the pixel values, and within each selected pixel,
a point is generated with a uniform distribution inside the pixel.
</p>
<p>The window of the simulated point pattern is determined as follows.
If <code>forcewin=FALSE</code> (the default) then the argument
<code>win</code> is ignored, and the simulation window is the
window of the pixel image, <code>Window(f)</code>.
If <code>forcefit=TRUE</code> then the simulation window is <code>win</code>.
</p>
</dd>
</dl>
<p>The algorithm is as follows:
</p>

<ul>
<li>
<p>If <code>f</code> is a constant, we invoke <code>runifpoint</code>.
</p>
</li>
<li>
<p>If <code>f</code> is a function, then we use the rejection method.
Proposal points are generated from the uniform distribution.
A proposal point <code class="reqn">(x,y)</code> is accepted with probability
<code>f(x,y,...)/fmax</code> and otherwise rejected.
The algorithm continues until <code>n</code> points have been
accepted. It gives up after <code>giveup * n</code> proposals
if there are still fewer than <code>n</code> points.
</p>
</li>
<li> 
<p>If <code>f</code> is a pixel image, then a random sequence of 
pixels is selected (using <code>sample</code>)
with probabilities proportional to the
pixel values of <code>f</code>.  Then for each pixel in the sequence
we generate a uniformly distributed random point in that pixel.
</p>
</li>
</ul>
<p>The algorithm for pixel images is more efficient than that for
functions.
</p>
<p>If <code>warn=TRUE</code> (the default), a warning will be issued if <code>n</code> is very large.
The threshold is <code>spatstat.options("huge.npoints")</code>.
This warning has no consequences,
but it helps to trap a number of common errors.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>ppp.object</code>,
<code>owin.object</code>,
<code>im.object</code>,
<code>runifpoint</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> # 100 uniform random points in the unit square
 X &lt;- rpoint(100)

 # 100 random points with probability density proportional to x^2 + y^2
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2}, 1)

 # `fmax' may be omitted
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2})

 # irregular window
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2}, win=letterR)

 # make a pixel image 
 Z &lt;- setcov(letterR)
 # 100 points with density proportional to pixel values
 X &lt;- rpoint(100, Z)
</code></pre>


</div>