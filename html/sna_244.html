<div class="container">

<table style="width: 100%;"><tr>
<td>sedist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Find a Matrix of Distances Between Positions Based on Structural Equivalence </h2>

<h3>Description</h3>

<p><code>sedist</code> uses the graphs indicated by <code>g</code> in <code>dat</code> to assess the extent to which each vertex is structurally equivalent; <code>joint.analysis</code> determines whether this analysis is simultaneous, and <code>method</code> determines the measure of approximate equivalence which is used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sedist(dat, g=c(1:dim(dat)[1]), method="hamming", 
    joint.analysis=FALSE, mode="digraph", diag=FALSE, code.diss=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> a graph or set thereof. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p> a vector indicating which elements of <code>dat</code> should be examined. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> one of <code>"correlation"</code>, <code>"euclidean"</code>, <code>"hamming"</code>, or <code>"gamma"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint.analysis</code></td>
<td>
<p> should equivalence be assessed across all networks jointly (<code>TRUE</code>), or individually within each (<code>FALSE</code>)? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
 <p><code>"digraph"</code> for directed data, otherwise <code>"graph"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p> boolean indicating whether diagonal entries (loops) should be treated as meaningful data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code.diss</code></td>
<td>
<p> reverse-code the raw comparison values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sedist</code> provides a basic tool for assessing the (approximate) structural equivalence of actors.  (Two vertices i and j are said to be structurally equivalent if i-&gt;k iff j-&gt;k for all k.)  SE similarity/difference scores are computed by comparing vertex rows and columns using the measure indicated by <code>method</code>:
</p>

<ol>
<li>
<p> correlation: the product-moment correlation
</p>
</li>
<li>
<p> euclidean: the euclidean distance
</p>
</li>
<li>
<p> hamming: the Hamming distance
</p>
</li>
<li>
<p> gamma: the gamma correlation
</p>
</li>
</ol>
<p>Once these similarities/differences are calculated, the results can be used with a clustering routine (such as <code>equiv.clust</code>) or an MDS (such as <code>cmdscale</code>).
</p>


<h3>Value</h3>

<p>A matrix of similarity/difference scores
</p>


<h3>Note</h3>

<p> Be careful to verify that you have computed what you meant to compute, with respect to similarities/differences. Also, note that (despite its popularity) the product-moment correlation can give rather strange results in some cases.
</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p>Breiger, R.L.; Boorman, S.A.; and Arabie, P.  (1975).  “An Algorithm for Clustering Relational Data with Applications to Social Network Analysis and Comparison with Multidimensional Scaling.”  <em>Journal of Mathematical Psychology</em>, 12, 328-383.
</p>
<p>Burt, R.S.  (1976).  “Positions in Networks.”  <em>Social Forces</em>, 55, 93-122.
</p>
<p>Wasserman, S., and Faust, K.  <em>Social Network Analysis: Methods and Applications.</em>  Cambridge: Cambridge University Press.   </p>


<h3>See Also</h3>

 <p><code>equiv.clust</code>, <code>blockmodel</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#Create a random graph with _some_ edge structure
g.p&lt;-sapply(runif(20,0,1),rep,20)  #Create a matrix of edge 
                                   #probabilities
g&lt;-rgraph(20,tprob=g.p)            #Draw from a Bernoulli graph 
                                   #distribution

#Get SE distances
g.se&lt;-sedist(g)

#Plot a metric MDS of vertex positions in two dimensions
plot(cmdscale(as.dist(g.se)))
</code></pre>


</div>