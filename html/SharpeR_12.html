<div class="container">

<table style="width: 100%;"><tr>
<td>as.sropt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the Sharpe ratio of the Markowitz portfolio.</h2>

<h3>Description</h3>

<p>Computes the Sharpe ratio of the Markowitz portfolio of some observed returns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.sropt(X, drag = 0, ope = 1, epoch = "yr")

## Default S3 method:
as.sropt(X, drag = 0, ope = 1, epoch = "yr")

## S3 method for class 'xts'
as.sropt(X, drag = 0, ope = 1, epoch = "yr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>matrix of returns, or <code>xts</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code>sr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). Let
</p>
<p style="text-align: center;"><code class="reqn">\zeta(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2} \zeta(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = \zeta\left(w_*\right)</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">w_* = R \frac{S^{-1}\bar{x}}{\sqrt{\bar{x}^{\top}S^{-1}\bar{x}}}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">z_* = \sqrt{\bar{x}^{\top} S^{-1} \bar{x}} - \frac{c_0}{R}</code>
</p>

<p>The units of <code class="reqn">z_*</code> are <code class="reqn">\mbox{time}^{-1/2}</code>.
Typically the Sharpe ratio is <em>annualized</em> by multiplying by
<code class="reqn">\sqrt{\mbox{ope}}</code>, where <code class="reqn">\mbox{ope}</code> 
is the number of observations
per year (or whatever the target annualization epoch.)
</p>
<p>Note that if <code>ope</code> and <code>epoch</code> are not given, the 
converter from <code>xts</code> attempts to infer the observations per epoch,
assuming yearly epoch.
</p>


<h3>Value</h3>

<p>An object of class <code>sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>sropt</code>, <code>sr</code>, sropt-distribution functions, 
<code>dsropt, psropt, qsropt, rsropt</code>
</p>
<p>Other sropt: 
<code>confint.sr()</code>,
<code>dsropt()</code>,
<code>is.sropt()</code>,
<code>pco_sropt()</code>,
<code>power.sropt_test()</code>,
<code>reannualize()</code>,
<code>sropt_test()</code>,
<code>sropt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
# under the alternative:
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0.0005,sd=0.0125),ncol=nfac)
asro &lt;- as.sropt(Returns,drag=0,ope=ope)
# generating correlated multivariate normal data in a more sane way
if (require(MASS)) {
  nstok &lt;- 10
  nfac &lt;- 3
  nyr &lt;- 10
  ope &lt;- 253
  X.like &lt;- 0.01 * matrix(rnorm(500*nfac),ncol=nfac) %*% 
    matrix(runif(nfac*nstok),ncol=nstok)
  Sigma &lt;- cov(X.like) + diag(0.003,nstok)
  # under the null:
  Returns &lt;- mvrnorm(ceiling(ope*nyr),mu=matrix(0,ncol=nstok),Sigma=Sigma)
  asro &lt;- as.sropt(Returns,ope=ope)
  # under the alternative
  Returns &lt;- mvrnorm(ceiling(ope*nyr),mu=matrix(0.001,ncol=nstok),Sigma=Sigma)
  asro &lt;- as.sropt(Returns,ope=ope)
}

# using real data.
if (require(xts)) {
 data(stock_returns)
 asro &lt;- as.sropt(stock_returns)
}  
</code></pre>


</div>