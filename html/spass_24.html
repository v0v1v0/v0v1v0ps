<div class="container">

<table style="width: 100%;"><tr>
<td>test.nb.gf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Testing Hypotheses in Gamma Frailty models</h2>

<h3>Description</h3>

<p><code>test.nb.gf</code> tests hypotheses for certain trends in Gamma frailty models
</p>


<h3>Usage</h3>

<pre><code class="language-R">test.nb.gf(
  dataC,
  dataE,
  h,
  hgrad,
  h0 = 0,
  trend = c("constant", "exponential", "custom"),
  H0 = FALSE,
  one.sided = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataC</code></td>
<td>
<p>a matrix or data frame containing count data from the control group. Columns correspond to time points, rows to observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataE</code></td>
<td>
<p>a matrix or data frame containing count data from the experiment group. Columns correspond to time points, rows to observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>hypothesis to be tested. The function must return a single value when evaluated on lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hgrad</code></td>
<td>
<p>gradient of function h</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h0</code></td>
<td>
<p>the value against which h is tested, see 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>the trend which assumed to be underlying in the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H0</code></td>
<td>
<p>indicates if the sandwich estimator is calculated under the null hypothesis or alternative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>one.sided</code></td>
<td>
<p>indicates if the hypothesis should be tested one- or two-sided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed to function <code>fit.nb.gf()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>the function <code>test.nb.gf</code> tests for the null hypothesis <code class="reqn">h(\eta, \lambda) = h_0</code> against the alternative <code class="reqn">h(\eta, \lambda) \neq h_0</code>.
The fitting function allows for incomplete follow up, but not for intermittent missingness.
</p>
<p>If parameter H0 is set to TRUE, the hessian and outer gradient are calculated under the assumption that <code>lambda[2]</code> <code class="reqn">\geq</code> <code>h0</code> if
<code>trend = "constant"</code> or <code>lambda[3]</code> <code class="reqn">\geq</code> <code>h0</code> if <code>trend = "exponential"</code>.
</p>


<h3>Value</h3>

<p><code>test.nb.gf</code> returns effect size, standard error, Z-statistic and p-value attained through standard normal approximation.
</p>


<h3>Source</h3>

<p><code>test.nb.gf</code> uses code contributed by Thomas Asendorf.
</p>


<h3>References</h3>

<p>Fiocco M, Putter H, Van Houwelingen JC, (2009), A new serially correlated gamma-frailty process for longitudinal count data <em>Biostatistics</em> Vol. 10, No. 2, pp. 245-257.
</p>


<h3>See Also</h3>

<p><code>rnbinom.gf</code> for information on the Gamma Frailty model, <code>n.nb.gf</code> for calculating
initial sample size required when performing inference, <code>fit.nb.gf</code> for calculating
initial parameters required when performing sample size estimation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Create data from two groups
random&lt;-get.groups(n=c(100,100), size=c(0.7, 0.7), lambda=c(0.8, 0), rho=c(0.6, 0.6),
  tp=7, trend="constant")

#Define hypothesis
h&lt;-function(lambda.eta){
  lambda.eta[2]
}
hgrad&lt;-function(lambda.eta){
  c(0, 1, 0)
}
test.nb.gf(dataC=random[101:200,], dataE=random[1:100,], h=h, hgrad=hgrad, h0=0,
  trend="constant", H0=FALSE)
</code></pre>


</div>