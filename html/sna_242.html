<div class="container">

<table style="width: 100%;"><tr>
<td>sdmat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Estimate the Structural Distance Matrix for a Graph Stack</h2>

<h3>Description</h3>

<p>Estimates the structural distances among all elements of <code>dat</code> using the method specified in <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sdmat(dat, normalize=FALSE, diag=FALSE, mode="digraph", 
    output="matrix", method="mc", exchange.list=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> graph set to be analyzed.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> divide by the number of available dyads? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p> boolean indicating whether or not the diagonal should be treated as valid data.  Set this true if and only if the data can contain loops.  <code>diag</code> is <code>FALSE</code> by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p> string indicating the type of graph being evaluated.  <code>"digraph"</code> indicates that edges should be interpreted as directed; <code>"graph"</code> indicates that edges are undirected.  <code>mode</code> is set to <code>"digraph"</code> by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
 <p><code>"matrix"</code> for matrix output, <code>"dist"</code> for a <code>dist</code> object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> method to be used to search the space of accessible permutations; must be one of <code>"none"</code>, <code>"exhaustive"</code>, <code>"anneal"</code>, <code>"hillclimb"</code>, or <code>"mc"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exchange.list</code></td>
<td>
<p> information on which vertices are exchangeable (see below); this must be a single number, a vector of length n, or a nx2 matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to <code>lab.optimize</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The structural distance between two graphs G and H is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_S\left(G,H \left| L_G,L_H\right.\right) = \min_{L_G,L_H} d\left(\ell\left(G\right),\ell\left(H\right)\right)</code>
</p>

<p>where <code class="reqn">L_G</code> is the set of accessible permutations/labelings of G, and <code class="reqn">\ell(G)</code> is a permuation/relabeling of the vertices of G (<code class="reqn">\ell(G) \in L_G</code>).  The set of accessible permutations on a given graph is determined by the <em>theoretical exchangeability</em> of its vertices; in a  nutshell, two vertices are considered to be theoretically exchangeable for a given problem if all predictions under the conditioning theory are invariant to a relabeling of the vertices in question (see Butts and Carley (2001) for a more formal exposition).  Where no vertices are exchangeable, the structural distance becomes the its labeled counterpart (here, the Hamming distance).  Where <em>all</em> vertices are exchangeable, the structural distance reflects the distance between unlabeled graphs; other cases correspond to distance under partial labeling.  
</p>
<p>The accessible permutation set is determined by the <code>exchange.list</code> argument, which is dealt with in the following manner. First, <code>exchange.list</code> is expanded to fill an nx2 matrix.  If <code>exchange.list</code> is a single number, this is trivially accomplished by replication; if <code>exchange.list</code> is a vector of length n, the matrix is formed by cbinding two copies together.  If <code>exchange.list</code> is already an nx2 matrix, it is left as-is.  Once the nx2 exchangeabiliy matrix has been formed, it is interpreted as follows: columns refer to graphs 1 and 2, respectively; rows refer to their corresponding vertices in the original adjacency matrices; and vertices are taken to be theoretically exchangeable iff their corresponding exchangeability matrix values are identical.  To obtain an unlabeled distance (the default), then, one could simply let <code>exchange.list</code> equal any single number.  To obtain the Hamming distance, one would use the vector <code>1:n</code>.
</p>
<p>Because the set of accessible permutations is, in general, very large (<code class="reqn">o(n!)</code>), searching the set for the minimum distance is a non-trivial affair.  Currently supported methods for estimating the structural distance are hill climbing, simulated annealing, blind monte carlo search, or exhaustive search (it is also possible to turn off searching entirely).  Exhaustive search is not recommended for graphs larger than size 8 or so, and even this may take days; still, this is a valid alternative for small graphs.  Blind monte carlo search and hill climbing tend to be suboptimal for this problem and are not, in general recommended, but they are available if desired.  The preferred (and default) option for permutation search is simulated annealing, which seems to work well on this problem (though some tinkering with the annealing parameters may be needed in order to get optimal performance).  See the help for <code>lab.optimize</code> for more information regarding these options.
</p>
<p>Structural distance matrices may be used in the same manner as any other distance matrices (e.g., with multidimensional scaling, cluster analysis, etc.)  Classical null hypothesis tests should not be employed with structural distances, and QAP tests are almost never appropriate (save in the uniquely labeled case).  See <code>cugtest</code> for a more reasonable alternative.
</p>


<h3>Value</h3>

<p>A matrix of distances (or an object of class <code>dist</code>)
</p>


<h3>Warning </h3>

<p>The search process can be <em>very slow</em>, particularly for large graphs.  In particular, the <em>exhaustive</em> method is order factorial, and will take approximately forever for unlabeled graphs of size greater than about 7-9.</p>


<h3>Note</h3>

<p> For most applications, <code>sdmat</code> is dominated by <code>structdist</code>; the former is retained largely for reasons of compatibility.</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p>Butts, C.T. and Carley, K.M.  (2005).  “Some Simple Algorithms for Structural Comparison.”  <em>Computational and Mathematical Organization Theory,</em> 11(4), 291-305.
</p>
<p>Butts, C.T., and Carley, K.M.  (2001).  “Multivariate Methods for Interstructural Analysis.”  CASOS Working Paper, Carnegie Mellon University. 
</p>


<h3>See Also</h3>

 <p><code>hdist</code>, <code>structdist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate two random graphs
g&lt;-array(dim=c(3,5,5))
g[1,,]&lt;-rgraph(5)
g[2,,]&lt;-rgraph(5)

#Copy one of the graphs and permute it
g[3,,]&lt;-rmperm(g[2,,])

#What are the structural distances between the labeled graphs?
sdmat(g,exchange.list=1:5)

#What are the structural distances between the underlying unlabeled 
#graphs?
sdmat(g,method="anneal", prob.init=0.9, prob.decay=0.85, 
    freeze.time=50, full.neighborhood=TRUE)
</code></pre>


</div>