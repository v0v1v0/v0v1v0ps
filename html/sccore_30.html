<div class="container">

<table style="width: 100%;"><tr>
<td>plapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</h2>

<h3>Description</h3>

<p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plapply(
  ...,
  progress = FALSE,
  n.cores = parallel::detectCores(),
  mc.preschedule = FALSE,
  mc.allow.recursive = TRUE,
  fail.on.error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to mclapply(), lapply(), or pbmcapply::pbmclapply()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Show progress bar via pbmcapply::pbmclapply() (default=FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>Number of cores to use (default=parallel::detectCores()). When n.cores=1, regular lapply() is used. Note: doesn't work when progress=TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.preschedule</code></td>
<td>
<p>if set to <code>TRUE</code> then the computation is
first divided to (at most) as many jobs are there are cores and then
the jobs are started, each job possibly covering more than one
value.  If set to <code>FALSE</code> then one job is forked for each value
of <code>X</code>.  The former is better for short computations or large
number of values in <code>X</code>, the latter is better for jobs that
have high variance of completion time and not too many values of
<code>X</code> compared to <code>mc.cores</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.allow.recursive</code></td>
<td>
<p>boolean Unless true, calling mclapply in a child process will use the child and not fork again (default=TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fail.on.error</code></td>
<td>
<p>boolean Whether to fail and report and error (using stop()) as long as any of the individual tasks has failed (default =FALSE)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list, as returned by lapply
</p>


<h3>Examples</h3>

<pre><code class="language-R">square = function(x){ x**2 }
plapply(1:10, square, n.cores=1, progress=TRUE)

</code></pre>


</div>