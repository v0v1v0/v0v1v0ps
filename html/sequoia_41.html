<div class="container">

<table style="width: 100%;"><tr>
<td>MakeAgePrior</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Age Priors</h2>

<h3>Description</h3>

<p>Estimate probability ratios <code class="reqn">P(R|A) / P(R)</code> for age
differences A and five categories of parent-offspring and sibling
relationships R.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MakeAgePrior(
  Pedigree = NULL,
  LifeHistData = NULL,
  MinAgeParent = NULL,
  MaxAgeParent = NULL,
  Discrete = NULL,
  Flatten = NULL,
  lambdaNW = -log(0.5)/100,
  Smooth = TRUE,
  Plot = TRUE,
  Return = "LR",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire in columns 1-3, and optional
column with birth years. Other columns are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LifeHistData</code></td>
<td>
<p>dataframe with 3 or 5 columns: id - sex (not used) -
birthyear (optional columns BY.min - BY.max - YearLast not used), with
unknown birth years coded as negative numbers or NA. "Birth year" may be in
any arbitrary discrete time unit relevant to the species (day, month,
decade), as long as parents are never born in the same time unit as their
offspring. It may include individuals not in the pedigree, and not all
individuals in the pedigree need to be in LifeHistData.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MinAgeParent</code></td>
<td>
<p>minimum age of a parent, a single number (min across
dams and sires) or a vector of length two (dams, sires). Defaults to 1.
When there is a conflict with the minimum age in the pedigree, the pedigree
takes precedent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxAgeParent</code></td>
<td>
<p>maximum age of a parent, a single number (max across
dams and sires) or a vector of length two (dams, sires). If NULL, it will
be set to latest - earliest birth year in <code>LifeHistData</code>, or estimated
from the pedigree if one is provided. See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Discrete</code></td>
<td>
<p>discrete generations? By default (NULL), discrete
generations are assumed if all parent-offspring pairs have an age
difference of 1, and all siblings an age difference of 0, and there are at
least 20 pairs of each category (mother, father, maternal sibling, paternal
sibling). Otherwise, overlapping generations are presumed. When
<code>Discrete=TRUE</code> (explicitly or deduced), <code>Smooth</code> and
<code>Flatten</code> are always automatically set to <code>FALSE</code>. Use
<code>Discrete=FALSE</code> to enforce (potential for) overlapping generations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Flatten</code></td>
<td>
<p>logical. To deal with small sample sizes for some or all
relationships, calculate weighed average between the observed age
difference distribution among relatives and a flat (0/1) distribution. When
<code>Flatten=NULL</code> (the default) automatically set to TRUE when there are
fewer than 20 parents with known age of either sex assigned, or fewer than
20 maternal or paternal siblings with known age difference. Also advisable
if the sampled relative pairs with known age difference are non-typical of
the pedigree as a whole.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaNW</code></td>
<td>
<p>control weighing factors when <code>Flatten=TRUE</code>. Weights
are calculated as <code class="reqn">W(R) = 1 - exp(-lambdaNW * N(R))</code>, where <code class="reqn">N(R)</code>
is the number of pairs with relationship R for which the age difference is
known. Large values (&gt;0.2) put strong emphasis on the pedigree, small
values (&lt;0.0001) cause the pedigree to be ignored. Default results in
<code class="reqn">W=0.5</code> for <code class="reqn">N=100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Smooth</code></td>
<td>
<p>smooth the tails of and any dips in the distribution? Sets dips
(&lt;10% of average of neighbouring ages) to the average of the neighbouring
ages, sets the age after the end (oldest observed age) to LR(end)/2, and
assigns a small value (0.001) to the ages before the front (youngest
observed age) and after the new end. Peaks are not smoothed out, as these
are less likely to cause problems than dips, and are more likely to be
genuine characteristics of the species. Is set to <code>FALSE</code> when
generations do not overlap (<code>Discrete=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Plot</code></td>
<td>
<p>plot a heatmap of the results?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Return</code></td>
<td>
<p>return only a matrix with the likelihood-ratio <code class="reqn">P(A|R) /
P(A)</code> (<code>"LR"</code>) or a list including also various intermediate
statistics (<code>"all"</code>) ?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>suppress messages.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code class="reqn">\alpha_{A,R}</code> is the ratio between the observed
counts of pairs with age difference A and relationship R (<code class="reqn">N_{A,R}</code>),
and the expected counts if age and relationship were independent
(<code class="reqn">N_{.,.}*p_A*p_R</code>).
</p>
<p>During pedigree reconstruction, <code class="reqn">\alpha_{A,R}</code> are multiplied by the
genetic-only <code class="reqn">P(R|G)</code> to obtain a probability that the
pair are relatives of type R conditional on both their age difference and
their genotypes.
</p>
<p>The age-difference prior is used for pairs of genotyped individuals, as
well as for dummy individuals. This assumes that the propensity for a pair
with a given age difference to both be sampled does not depend on their
relationship, so that the ratio <code class="reqn">P(A|R) / P(A)</code> does not differ between
sampled and unsampled pairs.
</p>
<p>For further details, see the vignette.
</p>


<h3>Value</h3>

<p>A matrix with the probability ratio of the age difference between two
individuals conditional on them being a certain type of relative
(<code class="reqn">P(A|R)</code>) versus being a random draw from the sample (<code class="reqn">P(A)</code>).
Assuming conditional independence, this equals the probability ratio of
being a certain type of relative conditional on the age difference, versus
being a random draw.
</p>
<p>The matrix has one row per age difference (0 - nAgeClasses) and five
columns, one for each relationship type, with abbreviations:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Mothers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Fathers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FS</code></td>
<td>
<p>Full siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MS</code></td>
<td>
<p>Maternal half-siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PS</code></td>
<td>
<p>Paternal half-siblings</p>
</td>
</tr>
</table>
<p>When <code>Return</code>='all', a list is returned with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>BirthYearRange</code></td>
<td>
<p>vector length 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxAgeParent</code></td>
<td>
<p>vector length 2, see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tblA.R</code></td>
<td>
<p>matrix with the counts per age difference (rows) /
relationship (columns) combination, plus a column 'X' with age
differences across all pairs of individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PA.R</code></td>
<td>
<p>Proportions, i.e. <code>tblA.R</code> divided by its <code>colSums</code>,
with full-sibling correction applied if necessary (see vignette).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LR.RU.A.raw</code></td>
<td>
<p>Proportions <code>PA.R</code> standardised by global age
difference distribution (column 'X'); <code>LR.RU.A</code> prior to flattening
and smoothing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Weights</code></td>
<td>
<p>vector length 4, the weights used to flatten the
distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LR.RU.A</code></td>
<td>
<p>the ageprior, flattend and/or smoothed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Specs.AP</code></td>
<td>
<p>the names of the input <code>Pedigree</code> and
<code>LifeHistData</code> (or <code>NULL</code>), <code>lambdaNW</code>, and the 'effective'
settings (i.e. after any automatic update) of <code>Discrete</code>,
<code>Smooth</code>, and <code>Flatten</code>.</p>
</td>
</tr>
</table>
<h3>CAUTION</h3>

<p>The small sample correction with <code>Smooth</code> and/or <code>Flatten</code>
prevents errors in one dataset, but may introduce errors in another; a
single solution that fits to the wide variety of life histories and
datasets is impossible. Please do inspect the matrix, e.g. with
<code>PlotAgePrior</code>, and adjust the input parameters and/or the output
matrix as necessary.
</p>


<h3>Single cohort</h3>

<p>When all individuals in <code>LifeHistData</code> have the same birth year, it is
assumed that <code>Discrete=TRUE</code> and <code>MaxAgeParent=1</code>. Consequently,
it is assumed there are no avuncular pairs present in the sample; cousins
are considered as alternative. To enforce overlapping generations, and
thereby the consideration of full- and half- avuncular relationships, set
<code>MaxAgeParent</code> to some value greater than <code class="reqn">1</code>.
</p>
<p>When no birth year information is given at all, a single cohort is assumed,
and the same rules apply.
</p>


<h3>Other time units</h3>

<p>"Birth year" may be in any arbitrary time unit relevant to the species
(day, month, decade), as long as parents are always born before their
putative offspring, and never in the same time unit (e.g. parent's
BirthYear= 1 (or 2001) and offspring BirthYear=5 (or 2005)). Negative
numbers and NA's are interpreted as unknown, and fractional numbers are not
allowed.
</p>


<h3>MaxAgeParent</h3>

<p>The maximum parental age for each sex equals the maximum of:
</p>

<ul>
<li>
<p> the maximum age of parents in <code>Pedigree</code>,
</p>
</li>
<li>
<p> the input parameter <code>MaxAgeParent</code>,
</p>
</li>
<li>
<p> the maximum range of birth years in <code>LifeHistData</code> (including
BY.min and BY.max). Only used if both of the previous are <code>NA</code>, or
if there are fewer than 20 parents of either sex assigned.
</p>
</li>
<li>
<p> 1, if <code>Discrete=TRUE</code> or the previous three are all <code>NA</code>
</p>
</li>
</ul>
<p>If the age distribution of assigned parents does not capture the maximum
possible age of parents, it is advised to specify <code>MaxAgeParent</code> for
one or both sexes. Not doing so may hinder subsequent assignment of both
dummy parents and grandparents. Not compatible with <code>Smooth</code>. If the
largest age difference in the pedigree is larger than the specified
<code>MaxAgeParent</code>, the pedigree takes precedent (i.e. the largest of the
two is used).
</p>
<p>@section grandparents &amp; avuncular
The agepriors for grand-parental and avuncular pairs is calculated from
these by <code>sequoia</code>, and included in its output as
'AgePriorExtra'.
</p>


<h3>See Also</h3>

<p><code>sequoia</code> and its argument <code>args.AP</code>,
<code>PlotAgePrior</code> for visualisation. The age vignette gives
further details, mathematical justification, and some examples.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># without pedigree or lifehistdata:
MakeAgePrior(MaxAgeParent = c(2,3))
MakeAgePrior(Discrete=TRUE)

# single cohort:
MakeAgePrior(LifeHistData = data.frame(ID = letters[1:5], Sex=3,
  BirthYear=1984))

# overlapping generations:
# without pedigree: MaxAgeParent = max age difference between any pair +1
MakeAgePrior(LifeHistData = SeqOUT_griffin$LifeHist)
# with pedigree:
MakeAgePrior(Pedigree=Ped_griffin,
             LifeHistData=SeqOUT_griffin$LifeHist,
             Smooth=FALSE, Flatten=FALSE)
# with small-sample correction:
MakeAgePrior(Pedigree=Ped_griffin,
             LifeHistData=SeqOUT_griffin$LifeHist,
             Smooth=TRUE, Flatten=TRUE)

# Call from sequoia() via args.AP:
Seq_HSg5 &lt;- sequoia(SimGeno_example, LH_HSg5, Module="par",
                args.AP=list(Discrete = TRUE),  # non-overlapping generations
                CalcLLR = FALSE,   # skip time-consuming calculation of LLR's
                Plot = FALSE)      # no summary plots when finished

</code></pre>


</div>