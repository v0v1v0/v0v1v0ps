<div class="container">

<table style="width: 100%;"><tr>
<td>st_as_binary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert sfc object to an WKB object</h2>

<h3>Description</h3>

<p>Convert sfc object to an WKB object
</p>


<h3>Usage</h3>

<pre><code class="language-R">st_as_binary(x, ...)

## S3 method for class 'sfc'
st_as_binary(
  x,
  ...,
  EWKB = FALSE,
  endian = .Platform$endian,
  pureR = FALSE,
  precision = attr(x, "precision"),
  hex = FALSE
)

## S3 method for class 'sfg'
st_as_binary(
  x,
  ...,
  endian = .Platform$endian,
  EWKB = FALSE,
  pureR = FALSE,
  hex = FALSE,
  srid = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object to convert</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EWKB</code></td>
<td>
<p>logical; use EWKB (PostGIS), or (default) ISO-WKB?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endian</code></td>
<td>
<p>character; either "big" or "little"; default: use that of platform</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pureR</code></td>
<td>
<p>logical; use pure R solution, or C++?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>numeric; if zero, do not modify; to reduce precision: negative values convert to float (4-byte real); positive values convert to round(x*precision)/precision. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hex</code></td>
<td>
<p>logical; return as (unclassed) hexadecimal encoded character vector?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srid</code></td>
<td>
<p>integer; override srid (can be used when the srid is unavailable locally).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>st_as_binary</code> is called on sfc objects on their way to the GDAL or GEOS libraries, and hence does rounding (if requested) on the fly before e.g. computing spatial predicates like st_intersects. The examples show a round-trip of an <code>sfc</code> to and from binary.
</p>
<p>For the precision model used, see also <a href="https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html">https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html</a>. There, it is written that: “... to specify 3 decimal places of precision, use a scale factor of 1000. To specify -3 decimal places of precision (i.e. rounding to the nearest 1000), use a scale factor of 0.001.”. Note that ALL coordinates, so also Z or M values (if present) are affected.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># examples of setting precision:
st_point(c(1/3, 1/6)) %&gt;% st_sfc(precision = 1000) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(c(1/3, 1/6)) %&gt;% st_sfc(precision =  100) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(1e6 * c(1/3, 1/6)) %&gt;% st_sfc(precision = 0.01) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(1e6 * c(1/3, 1/6)) %&gt;% st_sfc(precision = 0.001) %&gt;% st_as_binary %&gt;% st_as_sfc
</code></pre>


</div>