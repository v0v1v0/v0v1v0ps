<div class="container">

<table style="width: 100%;"><tr>
<td>pseudoR2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pseudo R-squared
</h2>

<h3>Description</h3>

<p>Generalization of R-squared based on likelihood ratios, called pseudo-R2 below, and variously attributed to Cragg &amp; Uhler (1970), Cox &amp; Snell (1989), Magee (1990) and some other authors (see comments in the References section). The null model used in the definition of R2 can be modified by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pseudoR2(fitobject, nullform = . ~ 1, R2fun = LR2R2, rescale=FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitobject</code></td>
<td>

<p>The fitted model object, obtained as the return value of a <span class="pkg">spaMM</span> fitting function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullform</code></td>
<td>

<p>Mean-response formula for the null model. The default value (including only an intercept) represents the traditional choice in R2 computation for linear models. Alternative formulas (including, e.g., random effects) can be specified using either the <code>update.formula</code> syntax (e.g., with a <code>'.'</code> on the right hand side; note that <span class="pkg">spaMM</span>'s updating conventions differ from those implemented by <code>stats::update.formula</code>, see <code>update.HLfit</code>), or a full formula (which may be a safer syntax).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2fun</code></td>
<td>

<p>The backend function computing R2 given the fitted and null model. The default implements the pseudo-R2. For linear models, it reduces to the canonical R2 and the value adjusted as in <code>summary.lm</code> is also returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>Boolean or formula, controlling whether and how to rescale R2 so that its maximum possible value is 1 (often considered for discrete-response models). If a formula, it should specify the model with maximal R2. If TRUE, rescaling is performed in a way meaningful only for binary logistic regression (see  Examples for how this is implemented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Boolean; whether to display various informations about the procedure (most notably, to warn about some potential problem in applying the default procedure to <code>fitobject</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>None of the R2-like computations I am aware of helps in addressing, for the general class of models handled by <span class="pkg">spaMM</span>, a well-defined inference task (comparable to, say, formally testing goodness of fit, or measuring accuracy of prediction of new data as considered for AIC). This problem has been well-known (e.g., Magee, 1990), and the canonical R2 itself for linear models is not devoid of weaknesses from this perspective (e.g., <a href="https://stats.stackexchange.com/questions/13314/is-r2-useful-or-dangerous">https://stats.stackexchange.com/questions/13314/is-r2-useful-or-dangerous</a>). As a consequence, strong statements about the properties that R2 should have are difficult to follow (and this includes the claim that it should always have maximum value 1).
</p>
<p>Given the above problems, (1) ultimately the main reason for computing R2 may be to deal with requests by misguided reviewers; (2) no attempt has been made here to implement the wide diversity of R2-like descriptors discussed in the literature. The <code>LR2R2</code> backend function implements the pseudo-R2, chosen on the basis that this is the simplest general method that makes at least as much sense as any other computation I have seen; and implementation of rescaling by maximal R2 is minimal (the examples explain some of its details). <code>LR2R2</code> allows adaptation of the R2 definition for mixed-effect models, by including some random effect(s) in the null model, using the  <code>nullform</code> argument.
</p>


<h3>Value</h3>

<p>As returned by the function specified by argument <code>R2fun</code>. The default function returns a numeric vector of length 2 for linear models and a single value otherwise.
</p>


<h3>References</h3>

<p>Cox, D.R., Snell, E.J. (1989). The analysis of binary data (2nd ed.). Chapman and Hall.<br>
Often cited in this context, but they barely mention the topic, in an exercise p. 208-209.
</p>
<p>Pseudo-R2 is known to go back at least to<br> 
Cragg, J. G., &amp; Uhler, R. S. (1970). The demand for automobiles. The Canadian Journal of Economics, 3(3), 386. <a href="https://doi.org/10.2307/133656">doi:10.2307/133656</a><br>
where they already discussed its rescaling by a maximum value, in the context of binary regression.
</p>
<p>Magee, L. (1990) R2 Measures based on Wald and likelihood ratio joint significance tests. The American Statistician, 44, 250-253. <a href="https://doi.org/10.1080/00031305.1990.10475731">doi:10.1080/00031305.1990.10475731</a><br>
also often cited for the pseudo-R2, this paper reformulates some related descriptors and concisely reviews earlier literature. 
</p>
<p>Nagelkerke, N.J.D. (1991) A note on a general definition of the coefficient of determination. Biometrika, Vol. 78, No. 3. (Sep., 1991), pp. 691-692. <a href="https://doi.org/10.1093/biomet/78.3.691">doi:10.1093/biomet/78.3.691</a><br>
details the properties of pseudo-R2 (including the way it “partitions” variation). Argues emphatically for its rescaling, for which it is often cited.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#### Pseudo-R2 *is* R2 for linear models:
#
# lmfit &lt;- lm(sr ~ pop15+pop75+dpi+ddpi , data = LifeCycleSavings)
# summary(lmfit) # Multiple R-squared = 0.3385, adjusted = 0.2797
#
spfit &lt;- fitme(sr ~ pop15+pop75+dpi+ddpi , data = LifeCycleSavings)
pseudoR2(spfit)  # consistent with summary(lmfit)

#### Toy example of pseudo-R2 for binary data
#
set.seed(123)
toydf &lt;- data.frame(x=seq(50), y=sample(0:1,50,TRUE))
#
##   Binary logistic regression:
#
binlog &lt;- fitme(y~x, data=toydf, family=binomial())
(blR2 &lt;- pseudoR2(binlog)) # quite low, despite the model being correct
#
##   Rescaling by 'maximum possible' R2 for binary logistic regression:
#
pseudoR2(binlog, rescale=TRUE)
#
#    which is acheived by silently computing the maximum possible R2 value 
#    by the following brutal but effective way:
#
perfbinlog &lt;- fitme(y~I(y), data=toydf, family=binomial())
(maxblR2 &lt;- pseudoR2(perfbinlog)) # = 0.7397...
#
# (this 'maximum possible' value would be modified if the null model were modified).
#
blR2/maxblR2       # again, rescaled value 
#
##   Same by more general syntax:
#
pseudoR2(binlog, rescale=y~I(y)) 
</code></pre>


</div>