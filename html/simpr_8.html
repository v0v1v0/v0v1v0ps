<div class="container">

<table style="width: 100%;"><tr>
<td>apply_fits</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a given function or formula expression on a
simpr_mod object and tidy the output.</h2>

<h3>Description</h3>

<p>This function applies a given function to all
fit objects and returns the result in a tidy
tibble.  Any function or <code>purrr</code>-style
lambda function can be used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">apply_fits(obj, .f, ..., .progress = FALSE, .options = furrr_options())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>a <code>simpr_tibble</code> with
repetition number, metaparameters, simulated
data, and fitted models, from
<code>fit</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>A function or <code>purrr</code>-style
lambda function (see
<code>as_mapper</code>) used for
computing on the fit object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>.f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.progress</code></td>
<td>
<p>A logical, for whether or not
to print a progress bar for multiprocess,
multisession, and multicore plans .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.options</code></td>
<td>
<p>The <code>future</code> specific
options to use with the workers when using
futures. This must be the result from a call
to
<code>furrr_options()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>tibble</code> with columns <code>.sim_id</code>,
<code>rep</code>, <code>Source</code> (which contains the name of the
fit column), any metaparameters from
<code>define</code>, and additional columns
containing the results of <code>.f</code> applied to each fit
object.
</p>


<h3>See Also</h3>

<p><code>tidy_fits</code>,
<code>glance_fits</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(100)
logit_fit = specify(a = ~ sample(0:1, size = n, replace = TRUE),
        b = ~ a + rlnorm(n)) %&gt;%
  define(n = c(40, 50)) %&gt;%
  generate(1) %&gt;%
  fit(logit = ~ glm(a ~ b, family = "binomial"))

logit_fit %&gt;%
  apply_fits(broom::augment)

## Arguments to the function can be passed in ...
logit_fit %&gt;%
  apply_fits(broom::augment, se_fit = TRUE)

## Using a purrr-style lambda function
logit_fit %&gt;%
  apply_fits(~ summary(.)$cov.scaled)

</code></pre>


</div>