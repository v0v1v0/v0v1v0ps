<div class="container">

<table style="width: 100%;"><tr>
<td>fit.sf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non-parametric stochastic frontier</h2>

<h3>Description</h3>

<p>Fits stochastic frontier of data with kernel smoothing, imposing monotonicity and/or concavity constraints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit.sf(X, y, X.constrained = NA, H.inv = NA, H.mult = 1,
  method = "u", scale.constraints = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of inputs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of outputs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.constrained</code></td>
<td>
<p>Matrix of inputs where constraints apply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.inv</code></td>
<td>
<p>Inverse of the smoothing matrix (must be positive definite); defaults to rule of thumb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.mult</code></td>
<td>
<p>Scaling factor for rule of thumb smoothing matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Constraints to apply; "u" for unconstrained, "m" for monotonically increasing, and "mc" for monotonically increasing and concave</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.constraints</code></td>
<td>
<p>Boolean, whether to scale constraints by their average value, can help with convergence</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method fits non-parametric stochastic frontier models. The data-generating process
is assumed to be of the form
</p>
<p style="text-align: center;"><code class="reqn">\ln y_i = \ln f(x_i) + v_i - u_i,</code>
</p>

<p>where <code class="reqn">y_i</code> is the <code class="reqn">i</code>th observation of output, <code class="reqn">f</code> is a continuous
function, <code class="reqn">x_i</code> is the <code class="reqn">i</code>th observation of input, <code class="reqn">v_i</code> is a
normally-distributed error term (<code class="reqn">v_i\sim N(0, \sigma_v^2)</code>), and <code class="reqn">u_i</code> is a
normally-distributed error term truncated below at zero (<code class="reqn">u_i\sim N^+(0, \sigma_u)</code>). 
Aigner et al. developed methods to decompose
<code class="reqn">\varepsilon_i = v_i - u_i</code> into its basic components.
</p>
<p>This procedure first fits the mean of the data using <code>fit.mean</code>,
producing estimates of output <code class="reqn">\hat{y}</code>. Log-proportional errors are calculated as
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_i = \ln(y_i / \hat{y}_i).</code>
</p>

<p>Following Aigner et al. (1977), parameters of one- and two-sided error distributions
are estimated via maximum likelihood. First,
</p>
<p style="text-align: center;"><code class="reqn">\hat{\sigma}^2 = \frac1N \sum_{i=1}^N \varepsilon_i^2.</code>
</p>

<p>Then, <code class="reqn">\hat{\lambda}</code> is estimated by solving
</p>
<p style="text-align: center;"><code class="reqn">\frac1{\hat{\sigma}^2} \sum_{i=1}^N \varepsilon_i\hat{y}_i + \frac{\hat{\lambda}}{\hat{\sigma}} \sum_{i=1}^N \frac{f_i^*}{1 - F_i^*}y_i = 0,</code>
</p>

<p>where <code class="reqn">f_i^*</code> and <code class="reqn">F_i^*</code> are standard normal density and distribution function,
respectively, evaluated at <code class="reqn">\varepsilon_i\hat{\lambda}\hat{\sigma}^{-1}</code>. Parameters of
the one- and two-sided distributions are found by solving the identities
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2 = \sigma_u^2 + \sigma_v^2</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda = \frac{\sigma_u}{\sigma_v}.</code>
</p>

<p>Mean efficiency over the sample is given by 
</p>
<p style="text-align: center;"><code class="reqn">\exp\left(-\frac{\sqrt{2}}{\sqrt{\pi}}\right)\sigma_u,</code>
</p>

<p>and modal efficiency for each observation is given by
</p>
<p style="text-align: center;"><code class="reqn">-\varepsilon(\sigma_u^2/\sigma^2).</code>
</p>



<h3>Value</h3>

<p>Returns a list with the following elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>y.fit</code></td>
<td>
<p>Estimated value of the frontier at X.fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient.fit</code></td>
<td>
<p>Estimated gradient of the frontier at X.fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.efficiency</code></td>
<td>
<p>Average efficiency for X, y as a whole</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode.efficiency</code></td>
<td>
<p>Modal efficiencies for each observation in X, y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.eval</code></td>
<td>
<p>Matrix of inputs used for fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.constrained</code></td>
<td>
<p>Matrix of inputs where constraints apply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.fit</code></td>
<td>
<p>Matrix of inputs where curve is fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.inv</code></td>
<td>
<p>Inverse smoothing matrix used in fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method used to fit frontier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling.factor</code></td>
<td>
<p>Factor by which constraints are multiplied before quadratic programming</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Aigner D, Lovell CK, Schmidt P (1977).
“Formulation and estimation of stochastic frontier production function models.”
<em>Journal of econometrics</em>, <b>6</b>(1), 21–37.<br><br>
Racine JS, Parmeter CF, Du P (2009).
“Constrained nonparametric kernel regression: Estimation and inference.”
Working paper.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(USMacro)

USMacro &lt;- USMacro[complete.cases(USMacro),]

#Extract data
X &lt;- as.matrix(USMacro[,c("K", "L")])
y &lt;- USMacro$Y

#Fit frontier
fit.sf &lt;- fit.sf(X, y,
                 X.constrained = X,
                 method = "mc")

print(fit.sf$mean.efficiency)
# [1] 0.9772484

#Plot efficiency over time
library(ggplot2)

plot.df &lt;- data.frame(Year = USMacro$Year,
                      Efficiency = fit.sf$mode.efficiency)

ggplot(plot.df, aes(Year, Efficiency)) +
  geom_line()
  
</code></pre>


</div>