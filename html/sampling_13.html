<div class="container">

<table style="width: 100%;"><tr>
<td>gencalib</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>g-weights of the generalized calibration estimator</h2>

<h3>Description</h3>

<p>Computes the g-weights of the generalized calibration estimator. The g-weights should lie in the specified bounds for the 
truncated and logit methods. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">gencalib(Xs,Zs,d,total,q=rep(1,length(d)),method=c("linear","raking","truncated","logit"),
bounds=c(low=0,upp=10),description=FALSE,max_iter=500,C=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xs</code></td>
<td>
<p>matrix of calibration variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Zs</code></td>
<td>
<p>matrix of instrumental variables with same dimension as Xs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>vector of initial weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>vector of population totals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity; the variation of the g-weights is reduced for small values of q.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>calibration method (linear, raking, logit, truncated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>vector of bounds for the g-weights used in the truncated and logit methods; 
'low' is the smallest value and 'upp' is the largest value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>if description=TRUE, summary of initial and final weights are printed, 
and their boxplots and histograms are drawn; by default, its value is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>maximum number of iterations in the Newton's method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>value of the centering constant, by default equals 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The generalized calibration or the instrument vector method computes the g-weights 
<code class="reqn">g_k=F(\lambda'z_k),</code> where <code class="reqn">z_k</code> is a vector with values defined for <code class="reqn">k\in s</code> (or <code class="reqn">k\in r</code> where <code class="reqn">r</code> is the set of respondents) and sharing the dimension of the specified auxiliary vector 
<code class="reqn">x_k</code>. The vectors <code class="reqn">z_k</code> and <code class="reqn">x_k</code> have to be stronlgy correlated. The vector <code class="reqn">\lambda</code> is determined from the calibration equation <code class="reqn">\sum_{k\in s} d_kg_k x_k=\sum_{k\in U} x_k</code> or <code class="reqn">\sum_{k\in r} d_kg_k x_k=\sum_{k\in U} x_k</code>. 
The function <code class="reqn">F</code> plays the same role as in the calibration method (see <code>calib</code>). If Xs=Zs the calibration method is obtain. If the method is "logit"
the g-weights will be centered around the constant C, with low&lt;C&lt;upp. In the calibration method C=1 (see <code>calib</code>). 
</p>


<h3>Value</h3>

<p>The function returns the vector of g-weights.</p>


<h3>References</h3>

 
<p>Deville, J.-C. (1998). La correction de la nonréponse par calage ou par échantillonnage équilibré. Paper presented at the <em>Congrès de l'ACFAS, Sherbrooke, Québec</em>.<br>
Deville, J.-C. (2000). Generalized calibration and application for weighting for non-response, <em>COMPSTAT 2000: proceedings in computational statistics</em>, p. 65–76.<br>
Estevao, V.M., and Särndal, C.E. (2000). A functional form approach to calibration. <em>Journal of Official Statistics</em>, 16, 379–399.<br>
Kott, P.S. (2006). Using calibration weighting to adjust for nonresponse and coverage errors. <em>Survey Methodology</em>, 32, 133–142.<br></p>


<h3>See Also</h3>

<p><code>checkcalibration</code>, <code>calib</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">############
## Example 1
############
# matrix of sample calibration variables 
Xs=cbind(
c(1,1,1,1,1,0,0,0,0,0),
c(0,0,0,0,0,1,1,1,1,1),
c(1,2,3,4,5,6,7,8,9,10))
# inclusion probabilities
piks=rep(0.2,times=10)
# vector of population totals
total=c(24,26,290)
# matrix of instrumental variables
Zs=Xs+matrix(runif(nrow(Xs)*ncol(Xs)),nrow(Xs),ncol(Xs))
# the g-weights using the truncated method
g=gencalib(Xs,Zs,d=1/piks,total,method="truncated",bounds=c(0.5,1.5))
# the calibration estimator of X is equal to the 'total' vector
t(g/piks)%*%Xs
# the g-weights are between lower and upper bounds
summary(g)
############
## Example 2
############
# Example of generalized g-weights (linear, raking, truncated, logit),
# with the data of Belgian municipalities as population.
# Firstly, a sample is selected by means of Poisson sampling.
# Secondly, the g-weights are calculated.
data(belgianmunicipalities)
attach(belgianmunicipalities)
# matrix of calibration variables for the population
X=cbind(Totaltaxation/mean(Totaltaxation),medianincome/mean(medianincome))
# selection of a sample with expected size equal to 200
# by means of Poisson sampling
# the inclusion probabilities are proportional to the average income 
pik=inclusionprobabilities(averageincome,200)
N=length(pik)               # population size
s=UPpoisson(pik)            # sample
Xs=X[s==1,]                 # sample calibration variable matrix 
piks=pik[s==1]              # sample inclusion probabilities
n=length(piks)              # expected sample size
# vector of population totals of the calibration variables
total=c(t(rep(1,times=N))%*%X)  
Z=cbind(TaxableIncome/mean(TaxableIncome),averageincome/mean(averageincome))
# defines the instrumental variables (sample level)
Zs=Z[s==1,]
# computation of the generalized g-weights
# by means of different generalized calibration methods
g1=gencalib(Xs,Zs,d=1/piks,total,method="linear")
g2=gencalib(Xs,Zs,d=1/piks,total,method="raking")
g3=gencalib(Xs,Zs,d=1/piks,total,method="truncated",bounds=c(0.5,8))
g4=gencalib(Xs,Zs,d=1/piks,total,method="logit",bounds=c(0.5,1.5))
# In some cases, the calibration is not possible
# particularly when bounds are used.
# if the calibration is possible, the calibration estimator of X total is printed
if(checkcalibration(Xs,d=1/piks,total,g1)$result) print(c((g1/piks)%*% Xs)) else print("error")
if(!is.null(g2))
if(checkcalibration(Xs,d=1/piks,total,g2)$result) print(c((g2/piks)%*% Xs)) else print("error")
if(!is.null(g3))
if(checkcalibration(Xs,d=1/piks,total,g3)$result) print(c((g3/piks)%*% Xs)) else print("error")
if(!is.null(g4))
if(checkcalibration(Xs,d=1/piks,total,g4)$result) print(c((g4/piks)%*% Xs)) else print("error")
detach(belgianmunicipalities)
############
## Example 3
############
# Generalized calibration and adjustment for unit nonresponse in the 'calibration' vignette
# vignette("calibration", package="sampling")
</code></pre>


</div>