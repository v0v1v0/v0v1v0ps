<div class="container">

<table style="width: 100%;"><tr>
<td>loglin.smooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pre-smoothing using log-linear models.</h2>

<h3>Description</h3>

<p>This function fits log-linear models to score data and provides estimates of 
the (vector of) score probabilities as well as the <code>C</code> matrix decomposition of their 
covariance matrix, according to the specified equating design (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">loglin.smooth(scores, degree, design, scores2, degreeXA, degreeYA, 
J, K, L, wx, wy, w, gapsX, gapsY, gapsA, lumpX, lumpY, lumpA,...)</code></pre>


<h3>Arguments</h3>

<p>		Note that depending on the specified equating design, not all arguments are necessary 
as detailed below. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>	If the "EG" design is specified, a vector containing the raw sample frequencies 
coming from one group taking the test.
</p>
<p>If the "SG" design is specified, a matrix containing the (joint) bivariate sample 
frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> (columns).
</p>
<p>If the "CB" design is specified, a two column matrix containing the observed scores 
of the sample taking test <code class="reqn">X</code> first, followed by test <code class="reqn">Y</code>. The <code>scores2</code> 
argument is then used for the scores of the sample taking test Y first followed by test 
<code class="reqn">X</code>.
</p>
<p>If either the "NEAT_CB" or "NEAT_PSE" design is selected, a two column matrix containing 
the observed scores on	test <code class="reqn">X</code> (first column) and the observed scores on the anchor 
test <code class="reqn">A</code> (second column). The <code>scores2</code> argument is then used for the observed 
scores on test <code class="reqn">Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>	Either a number or vector indicating the number of power moments to be fitted to the 
marginal distributions, or the number or cross moments to be fitted to the joint 
distributions, respectively. For the "EG" design it will be a number (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>	A character string indicating the equating design (one of "EG", "SG", "CB", "NEAT_CE", 
"NEAT_PSE")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores2</code></td>
<td>
<p>       Only used for the "CB", "NEAT_CE" and "NEAT_PSE" designs. See the description of
<code>scores</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degreeXA</code></td>
<td>
<p>  A vector indicating the	number of power moments to be fitted to the marginal distributions <code class="reqn">X</code> and <code class="reqn">A</code>,
and the number or cross moments to be fitted to the joint distribution <code class="reqn">(X,A)</code>
(see details). Only used for the "NEAT_CE" and "NEAT_PSE" designs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degreeYA</code></td>
<td>
<p>	Only used for the "NEAT_CE" and "NEAT_PSE" designs (see the description for
<code>degreeXA</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>		The number of possible <code class="reqn">X</code> scores. Only needed for "CB", "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>		The number of possible <code class="reqn">Y</code> scores. Only needed for "CB", "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>		The number of possible <code class="reqn">A</code> scores. Needed for "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wx</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_X\leq 1</code> indicating the weight put on the 
data that is not subject to order effects. Only used for the "CB" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_Y\leq 1</code> indicating the weight put on the 
data that is not subject to order effects. Only used for the "CB" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w\leq 1</code> indicating the weight given to 
population <code class="reqn">P</code>. Only used for the "NEAT" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsX</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">J</code> to smooth "gaps", usually ocurring at regular intervals due to scores rounded to integer values and other methodological factors. </p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted by the log-linear model.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsY</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">K</code>.</p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsA</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">L</code>. </p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpX</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">X</code> due to recording of negative rounded formulas or any other methodological artifact.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpY</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpA</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">A</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function fits loglinear models as described in Holland and Thayer (1987), and Von Davier 
et al. (2004). The following general equation can be used to represent the models according to 
the different designs used, in which the vector <code class="reqn">o</code> (or matrix) of (marginal or bivariate) 
score probabilities satisfies the log-linear model: 
</p>
<p style="text-align: center;"><code class="reqn">\log(o_{gh})=\alpha_m+Z_m(z_g)+W_m(w_h)+ZW_m(z_g,w_h)</code>
</p>

<p>where <code class="reqn">Z_m(z_g)=\sum_{i=1}^{T_{Zm}}\beta_{zmi}(z_g)^i</code>, 
<code class="reqn">W_m(w_h)=\sum_{i=1}^{T_{Wm}}\beta_{Wmi}(w_h)^i</code>, and, 
<code class="reqn">ZW_m(z_g,w_h)=\sum_{i=1}^{I_{Zm}}\sum_{i'=1}^{I_{Wm}}\beta_{ZWmii'}(z_g)^i(w_h)^{i'}</code>.
</p>
<p>The symbols will vary according to the different equating designs specified. Possible values are: 
<code class="reqn">o=p_{(12)}, p_{(21)}, p, q</code>; <code class="reqn">Z=X, Y</code>; <code class="reqn">W=Y, A</code>; 
<code class="reqn">z=x, y</code>; <code class="reqn">w=y, a</code>; <code class="reqn">m=(12), (21), P, Q</code>; <code class="reqn">g=j, k</code>; 
<code class="reqn">h=l, k</code>.
</p>
<p>Particular cases of this general equation for each of the equating designs can be found in 
Von Davier et al (2004) (e.g., Equations (7.1) and (7.2) for the "EG" design, Equation (8.1) for the "SG" design, 
Equations (9,1) and (9.2) for the "CB" design).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sp.est</code></td>
<td>
<p>The estimated score probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The C matrix which is so that <code class="reqn">\Sigma=CC^t</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1987). Notes on the use of loglinear models for fitting 
discrete probability distributions. Research Report 87-31, Princeton NJ: Educational 
Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>
<p>[1]	Moses, T. "Paper SA06_05 Using PROC GENMOD for Loglinear Smoothing Tim Moses and Alina A. von Davier, Educational Testing Service, Princeton, NJ".
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>ker.eq</code></p>


<h3>Examples</h3>

<pre><code class="language-R">#Table 7.4 from Von Davier et al. (2004)
data(Math20EG)
rj&lt;-loglin.smooth(scores=Math20EG[,1],degree=2,design="EG")$sp.est
sk&lt;-loglin.smooth(scores=Math20EG[,2],degree=3,design="EG")$sp.est
score&lt;-0:20
Table7.4&lt;-cbind(score,rj,sk)
Table7.4

## Example taken from [1]
score &lt;- 0:20
freq &lt;- c(10, 2, 5, 8, 7, 9, 8, 7, 8, 5, 5, 4, 3, 0, 2, 0, 1, 0, 2, 1, 0)
ldata &lt;- data.frame(score, freq)

plot(ldata, pch=16, main="Data w Lump at 0")
m1 = loglin.smooth(scores=ldata$freq,kert="gauss",degree=c(3),design="EG")
m2 = loglin.smooth(scores=ldata$freq,kert="gauss",degree=c(3),design="EG",lumpX=0)
Ns = sum(ldata$freq)
points(m1$sp.est*Ns, col=2, pch=16)
points(m2$sp.est*Ns, col=3, pch=16) # Preserves the lump
</code></pre>


</div>