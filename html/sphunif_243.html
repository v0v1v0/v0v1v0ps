<div class="container">

<table style="width: 100%;"><tr>
<td>unif_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Circular and (hyper)spherical uniformity tests</h2>

<h3>Description</h3>

<p>Implementation of several uniformity tests on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>, with calibration either in
terms of their asymptotic/exact distributions, if available, or Monte Carlo.
</p>
<p><code>unif_test</code> receives a sample of directions
<code class="reqn">{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}</code> in
<em>Cartesian coordinates</em>, except for the circular case (<code class="reqn">p=2</code>) in
which the sample can be represented in terms of <em>angles</em>
<code class="reqn">\Theta_1,\ldots,\Theta_n\in [0, 2\pi)</code>.
</p>
<p><code>unif_test</code> allows to perform several tests within a single call,
facilitating thus the exploration of a dataset by applying several tests.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unif_test(data, type = "all", p_value = "asymp", alpha = c(0.1, 0.05,
  0.01), M = 10000, stats_MC = NULL, crit_val = NULL,
  data_sorted = FALSE, K_max = 10000, method = "I", CCF09_dirs = NULL,
  CJ12_beta = 0, CJ12_reg = 3, cov_a = 2 * pi, Cressie_t = 1/3,
  K_CCF09 = 25, Poisson_rho = 0.5, Pycke_q = 0.5, Rayleigh_m = 1,
  Riesz_s = 1, Rothman_t = 1/3, Sobolev_vk2 = c(0, 0, 1),
  Softmax_kappa = 1, Stereo_a = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>sample to perform the test. A matrix of size <code>c(n, p)</code>
containing a sample of size <code>n</code> of directions (in Cartesian
coordinates) on <code class="reqn">S^{p-1}</code>. Alternatively if <code>p = 2</code>, a matrix of
size <code>c(n, 1)</code> containing the <code>n</code> angles on <code class="reqn">[0, 2\pi)</code> of the
circular sample on <code class="reqn">S^{1}</code>. Other objects accepted are an array of size
<code>c(n, p, 1)</code> with directions (in Cartesian coordinates), or a vector of
size <code>n</code> or an array of size <code>c(n, 1, 1)</code> with angular data.
Must not contain <code>NA</code>'s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension <code class="reqn">p</code>:
</p>

<ul>
<li>
<p> Circular data: any of the names available at object
<code>avail_cir_tests</code>.
</p>
</li>
<li>
<p> (Hyper)spherical data: any of the names available at object
<code>avail_sph_tests</code>.
</p>
</li>
</ul>
<p>If <code>type = "all"</code> (default), then <code>type</code> is set as
<code>avail_cir_tests</code> or <code>avail_sph_tests</code>, depending on the value of
<code class="reqn">p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_value</code></td>
<td>
<p>type of <code class="reqn">p</code>-value computation. Either <code>"MC"</code> for
employing the approximation by Monte Carlo of the exact null distribution,
<code>"asymp"</code> (default) for the use of the asymptotic/exact null
distribution (if available), or <code>"crit_val"</code> for approximation by means
of the table of critical values <code>crit_val</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>vector with significance levels. Defaults to
<code>c(0.10, 0.05, 0.01)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of Monte Carlo replications for approximating the null
distribution when <code>approx = "MC"</code>. Also, number of Monte Carlo samples
for approximating the asymptotic distributions based on weighted sums of chi
squared random variables. Defaults to <code>1e4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats_MC</code></td>
<td>
<p>a data frame of size <code>c(M, length(type))</code>, with column
names containing the character vector <code>type</code>, that results from
extracting <code>$stats_MC</code> from a call to <code>unif_stat_MC</code>. If
provided, the computation of Monte Carlo statistics when <code>approx = "MC"</code>
is skipped. <code>stats_MC</code> is checked internally to see if it is sorted.
Internally computed if <code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit_val</code></td>
<td>
<p>table with critical values for the tests, to be used if
<code>p_value = "crit_val"</code>. A data frame, with column names containing the
character vector <code>type</code> and rows corresponding to the significance
levels <code>alpha</code>, that results from extracting <code>$crit_val_MC</code> from
a call to <code>unif_stat_MC</code>. Internally computed if
<code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_sorted</code></td>
<td>
<p>is the circular data sorted? If <code>TRUE</code>, certain
statistics are faster to compute. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method for approximating the density, distribution, or
quantile function of the weighted sum of chi squared random variables. Must
be <code>"I"</code> (Imhof), <code>"SW"</code> (Satterthwaite–Welch), <code>"HBE"</code>
(Hall–Buckley–Eagleson), or <code>"MC"</code> (Monte Carlo; only for distribution
or quantile functions). Defaults to <code>"I"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CCF09_dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing
<code>n_proj</code> random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>
to perform the CCF09 test. If <code>NULL</code> (default), a sample of size
<code>n_proj = 50</code> directions is computed internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CJ12_beta</code></td>
<td>
<p><code class="reqn">\beta</code> parameter in the exponential regime of CJ12
test, a positive real.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CJ12_reg</code></td>
<td>
<p>type of asymptotic regime for CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_a</code></td>
<td>
<p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cressie_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Cressie test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>25</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke "<code class="reqn">q</code>-test", a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rayleigh_m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test.
Defaults to <code>m = 1</code> (the standard Rayleigh test).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>If <code>p_value = "MC"</code> or <code>p_value = "crit_val"</code>, optional
performance parameters to be passed to <code>unif_stat_MC</code>:
<code>chunks</code>, <code>cores</code>, and <code>seed</code>. If <code>p_value = "MC"</code>,
additional parameters to <code>unif_stat_distr</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All the tests reject for large values of the test statistic, so the critical
values for the significance levels <code>alpha</code> correspond to the
<code>alpha</code>-upper quantiles of the null distribution of the test statistic.
</p>
<p>When <code>p_value = "asymp"</code>, tests that do not have an implemented or
known asymptotic are omitted, and a warning is generated.
</p>
<p>When <code>p_value = "MC"</code>, it is possible to have a progress bar indicating
the Monte Carlo simulation progress if <code>unif_test</code> is wrapped with
<code>progressr::with_progress</code> or if
<code>progressr::handlers(global = TRUE)</code> is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.
</p>
<p>All the statistics are continuous random variables except the
Hodges–Ajne statistic (<code>"Hodges_Ajne"</code>), the Cressie statistic
(<code>"Cressie"</code>), and the number of (different) uncovered spacings
(<code>"Num_uncover"</code>). These three statistics are discrete random variables.
</p>
<p>The Monte Carlo calibration for the CCF09 test is made conditionally
on the choice of <br><code>CCF09_dirs</code>. That is, all the Monte
Carlo statistics share the same random directions.
</p>
<p>Except for <code>CCF09_dirs</code>, <code>K_CCF09</code>, and <code>CJ12_reg</code>, all the
test-specific parameters are vectorized.
</p>
<p>Descriptions and references for most of the tests are available
in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>

<p>If only a <b>single test</b> is performed, a list with class
<code>htest</code> containing the following components:
</p>

<ul>
<li> <p><code>statistic</code>: the value of the test statistic.
</p>
</li>
<li> <p><code>p.value</code>: the p-value of the test. If
<code>p_value = "crit_val"</code>, an <code>NA</code>.
</p>
</li>
<li> <p><code>alternative</code>: a character string describing the alternative
hypothesis.
</p>
</li>
<li> <p><code>method</code>: a character string indicating what type of test was
performed.
</p>
</li>
<li> <p><code>data.name</code>: a character string giving the name of the data.
</p>
</li>
<li> <p><code>reject</code>: the rejection decision for the levels of significance
<code>alpha</code>.
</p>
</li>
<li> <p><code>crit_val</code>: a vector with the critical values for the
significance levels <code>alpha</code> used with <code>p_value = "MC"</code> or
<code>p_value = "asymp"</code>.
</p>
</li>
<li> <p><code>param</code>: parameter(s) used in the test (if any).
</p>
</li>
</ul>
<p>If <b>several tests</b> are performed, a <code>type</code>-named list with
entries for each test given by the above list.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://doi.org/10.48550/arXiv.1804.00286">doi:10.48550/arXiv.1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Asymptotic distribution

# Circular data
n &lt;- 10
samp_cir &lt;- r_unif_cir(n = n)

# Matrix
unif_test(data = samp_cir, type = "Ajne", p_value = "asymp")

# Vector
unif_test(data = samp_cir[, 1], type = "Ajne", p_value = "asymp")

# Array
unif_test(data = array(samp_cir, dim = c(n, 1, 1)), type = "Ajne",
          p_value = "asymp")

# Several tests
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "asymp")

# Spherical data
n &lt;- 10
samp_sph &lt;- r_unif_sph(n = n, p = 3)

# Array
unif_test(data = samp_sph, type = "Bingham", p_value = "asymp")

# Matrix
unif_test(data = samp_sph[, , 1], type = "Bingham", p_value = "asymp")

# Several tests
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "asymp")

## Monte Carlo

# Circular data
unif_test(data = samp_cir, type = "Ajne", p_value = "MC")
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "MC")

# Spherical data
unif_test(data = samp_sph, type = "Bingham", p_value = "MC")
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC")

# Caching stats_MC
stats_MC_cir &lt;- unif_stat_MC(n = nrow(samp_cir), p = 2)$stats_MC
stats_MC_sph &lt;- unif_stat_MC(n = nrow(samp_sph), p = 3)$stats_MC
unif_test(data = samp_cir, type = avail_cir_tests,
          p_value = "MC", stats_MC = stats_MC_cir)
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
          stats_MC = stats_MC_sph)

## Critical values

# Circular data
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "crit_val")

# Spherical data
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "crit_val")

# Caching crit_val
crit_val_cir &lt;- unif_stat_MC(n = n, p = 2)$crit_val_MC
crit_val_sph &lt;- unif_stat_MC(n = n, p = 3)$crit_val_MC
unif_test(data = samp_cir, type = avail_cir_tests,
          p_value = "crit_val", crit_val = crit_val_cir)
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "crit_val",
          crit_val = crit_val_sph)

## Specific arguments

# Rothman
unif_test(data = samp_cir, type = "Rothman", Rothman_t = 0.5)

# CCF09
unif_test(data = samp_sph, type = "CCF09", p_value = "MC",
          CCF09_dirs = samp_sph[1:2, , 1])
unif_test(data = samp_sph, type = "CCF09", p_value = "MC",
          CCF09_dirs = samp_sph[3:4, , 1])

## Using a progress bar when p_value = "MC"

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = paste("(:spin) [:bar] :percent Iter: :current/:total Rate:",
                 ":tick_rate iter/sec ETA: :eta Elapsed: :elapsedfull"),
  clear = FALSE))

# Call unif_test() within with_progress()
with_progress(
  unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
            chunks = 10, M = 1e3)
)

# With several cores
with_progress(
  unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
            cores = 2, chunks = 10, M = 1e3)
)

# Instead of using with_progress() each time, it is more practical to run
# handlers(global = TRUE)
# once to activate progress bars in your R session

</code></pre>


</div>