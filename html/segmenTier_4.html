<div class="container">

<table style="width: 100%;"><tr>
<td>calculateScore</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>segmenTier's core dynamic programming routine in Rcpp</h2>

<h3>Description</h3>

<p>segmenTier's core dynamic programming routine in Rcpp
</p>


<h3>Usage</h3>

<pre><code class="language-R">calculateScore(seq, C, score, csim, M, Mn, multi = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seq</code></td>
<td>
<p>the cluster sequence (where clusters at positions k:i are
considered). Note, that unlike the R wrapper, clustering numbers
here are 0-based, where 0 is the nuisance cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>the list of clusters, including nuisance cluster '0', see 
<code>seq</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>the scoring function to be used, one of "ccor" or "icor",
an apt similarity matrix must be supplied via option <code>csim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csim</code></td>
<td>
<p>a matrix, providing either the cluster-cluster (scoring 
function "ccor") or the position-cluster similarity function
(scoring function "icor")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>minimal sequence length; Note, that this is not a strict
cut-off but defined as an accumulating penalty that must be
"overcome" by good score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mn</code></td>
<td>
<p>minimal sequence length for nuisance cluster, Mn&lt;M will allow
shorter distances between segments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multi</code></td>
<td>
<p>if multiple <code>k</code> are found which return the same maximal
score, should the "max" (shorter segment) or "min" (longer segment) be used?
This has little effect on real-life large data sets, since the situation
will rarely occur. Default is "max".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is <code>segmenTier</code>'s core dynamic programming
routine. It constructs the total score matrix S(i,c), based on
the passed scoring function ("icor" or "ccor"), and length penalty
<code>M</code>. "Nuisance" cluster "0" can have a smaller penalty <code>Mn</code>
to allow for shorter distances between "real" segments.
</p>
<p>Scoring function "icor" calculates the sum of similarities of
data at positions k:i to cluster centers c over all k and i.
The similarities are calculated e.g., as a (Pearson) correlation between
the data at individual positions and the tested cluster c center.
</p>
<p>Scoring function "ccor" calculates the sum of similarities
between the clusters at positions k:i to cluster c over all k and i.
</p>
<p>Scoring function "ccls" is a special case of "ccor" and is NOT handled
here, but is reflected in the cluster similarity matrix <code>csim</code>. It
is handled and automatically constructed in the R wrapper 
<code>segmentClusters</code>, and merely counts the 
number of clusters in sequence k:i, over all k and i, that are identical
to the tested cluster <code>c</code>, and sub-tracts 
a penalty for the count of non-identical clusters.
</p>


<h3>Value</h3>

<p>Returns the total score matrix <code>S(i,c)</code> and the matrix 
<code>K(i,c)</code> which stores the position <code>k</code> which delivered
the maximal score at position <code>i</code>. This is used in the back-tracing
phase.
</p>


<h3>References</h3>

<p>Machne, Murray &amp; Stadler (2017)
&lt;doi:10.1038/s41598-017-12401-8&gt;
</p>


</div>