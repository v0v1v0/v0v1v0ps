<div class="container">

<table style="width: 100%;"><tr>
<td>mlf.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maxima Likelihood First Scan Test</h2>

<h3>Description</h3>

<p><code>mlf.test</code> implements the Maxima Likelihood First
scan test of Yao et al. (2011), which is actually a
special case of the Dynamic Minimum Spanning Tree of
Assuncao et al. (2006).  Find the single region that
maximizes the likelihood ratio test statistic.  Starting
with this single region as a current zone, new candidate
zones are constructed by combining the current zone with
the connected region that maximizes the likelihood ratio
test statisic.  This procedure is repeated until the
population and/or distance upper bound is reached.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlf.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 0.5,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>A cluster object created by <code>makeCluster</code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Only a single candidate zone is ever returned because the
algorithm only constructs a single sequence of starting
zones, and overlapping zones are not returned.  Only the
zone that maximizes the likelihood ratio test statistic
is returned.
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components: </p>
<table>
<tr style="vertical-align: top;">
<td><code>locids</code></td>
<td>
<p>The location ids of
regions in a significant cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p>The total
population in the cluser window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>The
observed number of cases in the cluster window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expected</code></td>
<td>
<p>The expected number of cases in the
cluster window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smr</code></td>
<td>
<p>Standarized mortaility
ratio (observed/expected) in the cluster window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for the
cluster window (i.e., the log of the test statistic).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvalue</code></td>
<td>
<p>The pvalue of the test statistic
associated with the cluster window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>The
adjacency matrix of the cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The maximum
radius of the cluster (in terms of intercentroid
distance from the starting region).</p>
</td>
</tr>
</table>
<p> The second element
of the list is the centroid coordinates.  This is
needed for plotting purposes.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Yao, Z., Tang, J., &amp; Zhan, F. B. (2011).
Detection of arbitrarily-shaped clusters using a
neighbor-expanding approach: A case study on murine
typhus in South Texas. International journal of health
geographics, 10(1), 1.
</p>
<p>Assuncao, R.M., Costa, M.A., Tavares, A. and Neto,
S.J.F. (2006). Fast detection of arbitrarily shaped
disease clusters, Statistics in Medicine, 25, 723-742.
</p>


<h3>See Also</h3>

<p><code>print.smerc_cluster</code>,
<code>summary.smerc_cluster</code>,
<code>plot.smerc_cluster</code>,
<code>scan.stat</code>, <code>scan.test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- mlf.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 10, ubpop = 0.1, ubd = 0.5
)
plot(out)
</code></pre>


</div>