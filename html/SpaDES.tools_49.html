<div class="container">

<table style="width: 100%;"><tr>
<td>spokes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify outward radiating spokes from initial points</h2>

<h3>Description</h3>

<p>This is a generalized version of a notion of a viewshed.
The main difference is that there can be many "viewpoints".
</p>


<h3>Usage</h3>

<pre><code class="language-R">spokes(
  landscape,
  coords,
  loci,
  maxRadius = ncol(landscape)/4,
  minRadius = maxRadius,
  allowOverlap = TRUE,
  stopRule = NULL,
  includeBehavior = "includePixels",
  returnDistances = FALSE,
  angles = NA_real_,
  nAngles = NA_real_,
  returnAngles = FALSE,
  returnIndices = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>landscape</code></td>
<td>
<p>Raster on which the circles are built.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>Either a matrix with 2 (or 3) columns, <code>x</code> and <code>y</code> (and <code>id</code>), representing the
coordinates (and an associated id, like cell index),
or a <code style="white-space: pre;">⁠SpatialPoints*⁠</code> object around which to make circles. Must be same
coordinate system as the <code>landscape</code> argument. Default is missing,
meaning it uses the default to <code>loci</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci</code></td>
<td>
<p>Numeric. An alternative to <code>coords</code>.
These are the indices on <code>landscape</code> to initiate this function (see <code>coords</code>).
Default is one point in centre of <code>landscape</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code>. Default is
<code>maxRadius</code>, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than <code>maxRadius</code>,
then this will create a buffer or doughnut or ring.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowOverlap</code></td>
<td>
<p>Logical. Should duplicates across id be removed or kept. Default TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopRule</code></td>
<td>
<p>A function. If the spokes are to stop. This can be a function
of <code>landscape</code>, <code>fromCell</code>, <code>toCell</code>, <code>x</code>
(distance from coords cell), or any other named argument passed
into the <code>...</code> of this function. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeBehavior</code></td>
<td>
<p>Character string. Currently accepts only <code>"includePixels"</code>, the default,
and <code>"excludePixels"</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDistances</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the distance from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>.
Default <code>FALSE</code>, which is faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angles</code></td>
<td>
<p>Numeric. Optional vector of angles, in radians, to use. This will create
"spokes" outward from <code>coords.</code> Default is <code>NA</code>, meaning, use internally
derived angles that will "fill" the circle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nAngles</code></td>
<td>
<p>Numeric, length one. Alternative to angles. If provided, the function
will create a sequence of angles from <code>0</code> to <code>2*pi</code>,
with a length <code>nAngles</code>, and not including <code>2*pi</code>.
Will not be used if <code>angles</code> is provided, and will show
warning of both are given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnAngles</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the angle from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>. Default <code>FALSE.</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Objects to be used by <code>stopRule()</code>. See examples.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix containing columns id (representing the row numbers of <code>coords</code>),
angles (from <code>coords</code> to each point along the spokes), x and y coordinates
of each point along the spokes, the corresponding indices on the <code>landscape</code>
Raster, dists (the distances between each <code>coords</code> and each point along the
spokes), and stop, indicating if it was a point that caused a spoke to stop
going outwards due to <code>stopRule</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)
library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1234)

ras &lt;- terra::rast(terra::ext(0, 10, 0, 10), res = 1, val = 0)
rp &lt;- randomPolygons(ras, numTypes = 10)

if (interactive())
  terra::plot(rp)

angles &lt;- seq(0, pi * 2, length.out = 17)
angles &lt;- angles[-length(angles)]
n &lt;- 2
loci &lt;- sample(terra::ncell(rp), n)
coords &lt;- terra::vect(terra::xyFromCell(rp, loci))
stopRule &lt;- function(landscape) landscape &lt; 3
d2 &lt;- spokes(rp, coords = coords, stopRule = stopRule,
             minRadius = 0, maxRadius = 50,
             returnAngles = TRUE, returnDistances = TRUE,
             allowOverlap = TRUE, angles = angles, returnIndices = TRUE)

# Assign values to the "patches" that were in the viewshed of a ray
rasB &lt;- terra::rast(ras)
rasB[] &lt;- 0
rasB[d2[d2[, "stop"] == 1, "indices"]] &lt;- 1

if (interactive()) {
  rasB[rasB == 0] &lt;- NA
  terra::plot(rasB, add = TRUE, col = "red", legend = FALSE)
}

if (NROW(d2) &gt; 0) {
  sp1 &lt;- terra::vect(d2[, c("x", "y")])
  if (interactive())
    terra::plot(sp1, add = TRUE, pch = 19)
}
if (interactive())
  terra::plot(coords, add = TRUE, pch = 19, col = "blue")

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>


</div>