<div class="container">

<table style="width: 100%;"><tr>
<td>sRDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sRDA.</h2>

<h3>Description</h3>

<p>sRDA.
</p>
<p>Sparse Redundancy Analysis (sRDA) to express the maximum variance in the
predicted data set by a linear combination of variables (latent variable)
of the predictive data set. Elastic net penalization (with its variants, UST,
Ridge and Lasso penalization) is implemented for sparsity and smoothness
with a  built in cross validation procedure to obtain the optimal
penalization parameters. It is possible to obtain multiple latent variables
which are orthogonal to each other, thus each explaining a different protion
of variance in the predicted data set. sRDA is implemented in a Partial Least
Squares framework, for more details see Csala et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sRDA(predictor, predicted, penalization = "enet", ridge_penalty = 1,
  nonzero = 1, max_iterations = 100, tolerance = 1 * 10^-20,
  cross_validate = FALSE, parallel_CV = FALSE, nr_subsets = 10,
  multiple_LV = FALSE, nr_LVs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>predictor</code></td>
<td>
<p>The n*p matrix of the predictor data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicted</code></td>
<td>
<p>The n*q matrix of the predicted data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalization</code></td>
<td>
<p>The penalization method applied during the analysis (none, enet or ust)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge_penalty</code></td>
<td>
<p>The ridge penalty parameter of the predictor set's latent variable used
for enet (an integer if cross_validate = FALSE, a list otherwise)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonzero</code></td>
<td>
<p>The number of non-zero weights of the predictor set's latent variable used
for enet or ust (an integer if cross_validate = FALSE, a list otherwise)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>The maximum number of iterations of the algorithm (integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>Convergence criteria (number, a small positive tolerance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross_validate</code></td>
<td>
<p>K-fold cross validation to find best optimal penalty parameters
(TRUE or FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel_CV</code></td>
<td>
<p>Run the cross validation parallel (TRUE or FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_subsets</code></td>
<td>
<p>Number of subsets for k-fold cross validation (integer, the value for k)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple_LV</code></td>
<td>
<p>Obtain multiple latent variable pairs (TRUE or FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_LVs</code></td>
<td>
<p>Number of latent variable pairs (components) to be obtained (integer)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"sRDA"</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>XI</code></td>
<td>

<p>Predictor set's latent variable scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ETA</code></td>
<td>

<p>Predictive set's latent variable scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ALPHA</code></td>
<td>

<p>Weights of the predictor set's latent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BETA</code></td>
<td>

<p>Weights of the predicted set's latent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_iterations</code></td>
<td>

<p>Number of iterations ran before convergence (or max number of iterations)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SOLVE_XIXI</code></td>
<td>

<p>Inverse of the predictor set's latent variable variance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations_crts</code></td>
<td>

<p>The convergence criterion value (a small positive tolerance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum_absolute_betas</code></td>
<td>

<p>Sum of the absolute values of beta weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge_penalty</code></td>
<td>

<p>The ridge penalty parameter used for the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_nonzeros</code></td>
<td>

<p>The number of nonzero alpha weights in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr_latent_variables</code></td>
<td>

<p>The number of latient variable pairs (components) in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CV_results</code></td>
<td>

<p>The detailed results of cross validations (if cross_validate is TRUE)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Attila Csala
</p>


<h3>References</h3>

<p>Csala A., Voorbraak F.P.J.M., Zwinderman A.H., and Hof M.H. (2017) Sparse
redundancy analysis of high-dimensional genetic and genomic data.
<em>Bioinformatics</em>, <b>33</b>, pp.3228-3234.
<a href="https://doi.org/10.1093/bioinformatics/btx374">https://doi.org/10.1093/bioinformatics/btx374</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate data with few highly correlated variahbles
dataXY &lt;- generate_data(nr_LVs = 2,
                           n = 250,
                           nr_correlated_Xs = c(5,20),
                           nr_uncorrelated_Xs = 250,
                           mean_reg_weights_assoc_X =
                             c(0.9,0.5),
                           sd_reg_weights_assoc_X =
                             c(0.05, 0.05),
                           Xnoise_min = -0.3,
                           Xnoise_max = 0.3,
                           nr_correlated_Ys = c(10,15),
                           nr_uncorrelated_Ys = 350,
                           mean_reg_weights_assoc_Y =
                             c(0.9,0.6),
                           sd_reg_weights_assoc_Y =
                             c(0.05, 0.05),
                           Ynoise_min = -0.3,
                           Ynoise_max = 0.3)



# seperate predictor and predicted sets
X &lt;- dataXY$X
Y &lt;- dataXY$Y

# run sRDA
RDA.res &lt;- sRDA(predictor = X, predicted = Y, nonzero = 5,
ridge_penalty = 1, penalization = "ust")


# check first 10 weights of X
RDA.res$ALPHA[1:10]

## Not run: 
# run sRDA with cross-validation to determine best penalization parameters
RDA.res &lt;- sRDA(predictor = X, predicted = Y, nonzero = c(5,10,15),
ridge_penalty = c(0.1,1), penalization = "enet", cross_validate = TRUE,
parallel_CV = TRUE)

# check first 10 weights of X
RDA.res$ALPHA[1:10]

# check the Ridge parameter and the number of nonzeros included in the model
RDA.res$ridge_penalty
RDA.res$nr_nonzeros

# check how much time the cross validation did take
RDA.res$CV_results$stime

# obtain multiple latent variables (components)
RDA.res &lt;- sRDA(predictor = X, predicted = Y, nonzero = c(5,10,15),
ridge_penalty = c(0.1,1), penalization = "enet", cross_validate = TRUE,
parallel_CV = TRUE, multiple_LV = TRUE, nr_LVs = 2, max_iterations = 5)

# check first 20 weights of X in first two component
RDA.res$ALPHA[[1]][1:20]
RDA.res$ALPHA[[2]][1:20]

# components are orthogonal to each other
t(RDA.res$XI[[1]]) %*% RDA.res$XI[[2]]


## End(Not run)
</code></pre>


</div>