<div class="container">

<table style="width: 100%;"><tr>
<td>summary.segmented</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Summarizing  model fits for segmented regression </h2>

<h3>Description</h3>

<p>summary method for class <code>segmented</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'segmented'
summary(object, short = FALSE, var.diff = FALSE, p.df="p", .vcov=NULL, ...)

## S3 method for class 'summary.segmented'
print(x, short=x$short, var.diff=x$var.diff, 
    digits = max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"),...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> Object of class "segmented". </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>short</code></td>
<td>
<p> logical indicating if the ‘short’ summary should be printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.diff</code></td>
<td>
<p> logical indicating if different error variances should be computed 
in each interval of the segmented variable, see Details. If <code>.vcov</code> is provided, <code>var.diff</code> is set to <code>FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.df</code></td>
<td>
<p> A character as a function of <code>'p'</code> (number of parameters) and <code>'K'</code> (number of groups or segments) affecting computations of the group-specific 
variance (and the standard errors) if <code>var.diff=TRUE</code>, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.vcov</code></td>
<td>
<p> Optional. The full covariance matrix for the parameter estimates. If provided, standard errors are computed (and displayed) according to this matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>summary.segmented</code> object produced by <code>summary.segmented()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>controls number of digits printed in output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signif.stars</code></td>
<td>
<p>logical, should stars be printed on summary tables of coefficients?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>short=TRUE</code> only coefficients of the segmented relationships are printed.
If <code>var.diff=TRUE</code> and there is only one segmented variable, different error variances are 
computed in the intervals defined by the estimated breakpoints of the segmented variable. 
For the jth interval with <code class="reqn">n_j</code> observations, the error variance is estimated via <code class="reqn">RSS_j/(n_j-p)</code>, 
where <code class="reqn">RSS_j</code> is the residual sum of squares in interval j, and <code class="reqn">p</code> is the number of model parameters. This number to be subtracted from <code class="reqn">n_j</code> can be changed via argument <code>p.df</code>. For instance <code>p.df="0"</code> uses <code class="reqn">RSS_j/(n_j)</code>, and <code>p.df="p/K"</code> leads to <code class="reqn">RSS_j/(n_j-p/K)</code>, where <code class="reqn">K</code> is the number of groups (segments), and <code class="reqn">p/K</code> can be interpreted as the average number of model parameter in that group. 
</p>
<p>Note <code>var.diff=TRUE</code> only affects the estimates covariance matrix. It does <em>not</em> affect the parameter estimates, neither the log likelihood and relevant measures, such as AIC  or BIC. In other words, <code>var.diff=TRUE</code> just provides 'alternative' standard errors, probably appropriate when the error variances are different before/after the estimated breakpoints. Also <code class="reqn">p-values</code> are computed using the t-distribution with 'naive' degrees of freedom (as reported in <code>object$df.residual</code>).
</p>
<p>If <code>var.diff=TRUE</code> the variance-covariance matrix of the estimates is computed via the 
sandwich formula, 
</p>
<p style="text-align: center;"><code class="reqn">(X^TX)^{-1}X^TVX(X^TX)^{-1}</code>
</p>
 
<p>where V is the diagonal matrix including the different group-specific error variance estimates. Standard errors are the square root of the main diagonal of this matrix.
</p>


<h3>Value</h3>

<p>A list (similar to one returned by <code>segmented.lm</code> or <code>segmented.glm</code>) with additional components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>psi </code></td>
<td>
<p>estimated break-points and relevant (approximate) standard errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ttable </code></td>
<td>
<p>estimates and standard errors of the model parameters. This is similar
to the matrix <code>coefficients</code> returned by <code>summary.lm</code> or <code>summary.glm</code>,
but without the rows corresponding to the breakpoints. Even the p-values relevant to the
difference-in-slope parameters have been replaced by NA, since they are meaningless in
this case, see <code>davies.test</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap</code></td>
<td>
<p>estimated coefficients, standard errors and t-values for the ‘gap’ variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.var.diff</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the covaraince matrix accounting for heteroscedastic errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the square root of the estimated error variances in each interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the residual degrees of freedom in each interval.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code>print.segmented</code>, <code>davies.test</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">##continues example from segmented()
# summary(segmented.model,short=TRUE)

## an heteroscedastic example..
# set.seed(123)
# n&lt;-100
# x&lt;-1:n/n
# y&lt;- -x+1.5*pmax(x-.5,0)+rnorm(n,0,1)*ifelse(x&lt;=.5,.4,.1)
# o&lt;-lm(y~x)
# oseg&lt;-segmented(o,seg.Z=~x,psi=.6)
# summary(oseg,var.diff=TRUE)$sigma.new
</code></pre>


</div>