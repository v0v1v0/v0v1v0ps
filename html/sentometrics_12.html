<div class="container">

<table style="width: 100%;"><tr>
<td>ctr_agg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set up control for aggregation into sentiment measures</h2>

<h3>Description</h3>

<p>Sets up control object for (computation of textual sentiment and) aggregation into textual
sentiment measures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ctr_agg(
  howWithin = "proportional",
  howDocs = "equal_weight",
  howTime = "equal_weight",
  do.sentence = FALSE,
  do.ignoreZeros = TRUE,
  by = "day",
  lag = 1,
  fill = "zero",
  alphaExpDocs = 0.1,
  alphasExp = seq(0.1, 0.5, by = 0.1),
  do.inverseExp = FALSE,
  ordersAlm = 1:3,
  do.inverseAlm = TRUE,
  aBeta = 1:4,
  bBeta = 1:4,
  weights = NULL,
  tokens = NULL,
  nCore = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>howWithin</code></td>
<td>
<p>a single <code>character</code> vector defining how to perform aggregation within
documents or sentences. Coincides with the <code>how</code> argument in the <code>compute_sentiment</code> function. Should
<code>length(howWithin) &gt; 1</code>, the first element is used. For available options see <code>get_hows()$words</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>howDocs</code></td>
<td>
<p>a single <code>character</code> vector defining how aggregation across documents (and/or sentences) per date will
be performed. Should <code>length(howDocs) &gt; 1</code>, the first element is used. For available options
see <code>get_hows()$docs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>howTime</code></td>
<td>
<p>a <code>character</code> vector defining how aggregation across dates will be performed. More than one choice
is possible. For available options see <code>get_hows()$time</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.sentence</code></td>
<td>
<p>see <code>compute_sentiment</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.ignoreZeros</code></td>
<td>
<p>a <code>logical</code> indicating whether zero sentiment values have to be ignored in the determination of
the document (and/or sentence) weights while aggregating across documents (and/or sentences). By default
<code>do.ignoreZeros = TRUE</code>, such that documents (and/or sentences) with a raw sentiment score of zero or for which
a given feature indicator is equal to zero are considered irrelevant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>a single <code>character</code> vector, either <code>"day", "week", "month"</code> or <code>"year"</code>, to indicate at what
level the dates should be aggregated. Dates are displayed as the first day of the period, if applicable (e.g.,
<code>"2017-03-01"</code> for March 2017).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p>a single <code>integer</code> vector, being the time lag to be specified for aggregation across time. By default
equal to <code>1</code>, meaning no aggregation across time; a time weighting scheme named <code>"dummyTime"</code> is used in
this case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>a single <code>character</code> vector, one of <code>c("zero", "latest", "none")</code>, to control how missing
sentiment values across the continuum of dates considered are added. This impacts the aggregation across time,
applying the <code>measures_fill</code> function before aggregating, except if <code>fill = "none"</code>. By default equal to
<code>"zero"</code>, which sets the scores (and thus also the weights) of the added dates to zero in the time aggregation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaExpDocs</code></td>
<td>
<p>a single <code>integer</code> vector. A weighting smoothing factor, used if <br><code>"exponential" %in% howDocs</code> or <code>"inverseExponential" %in% howDocs</code>. Value should be between 0 and 1
(both excluded); see <code>weights_exponential</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphasExp</code></td>
<td>
<p>a <code>numeric</code> vector of all exponential weighting smoothing factors, used if <br><code>"exponential" %in% howTime</code>. Values should be between 0 and 1 (both excluded); see
<code>weights_exponential</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.inverseExp</code></td>
<td>
<p>a <code>logical</code> indicating if for every exponential curve its inverse has to be added,
used if <code>"exponential" %in% howTime</code>; see <code>weights_exponential</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordersAlm</code></td>
<td>
<p>a <code>numeric</code> vector of all Almon polynomial orders (positive) to calculate weights for, used if
<code>"almon" %in% howTime</code>; see <code>weights_almon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.inverseAlm</code></td>
<td>
<p>a <code>logical</code> indicating if for every Almon polynomial its inverse has to be added, used
if <code>"almon" %in% howTime</code>; see <code>weights_almon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aBeta</code></td>
<td>
<p>a <code>numeric</code> vector of positive values as first Beta weighting decay parameter; see
<code>weights_beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bBeta</code></td>
<td>
<p>a <code>numeric</code> vector of positive values as second Beta weighting decay parameter; see
<code>weights_beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional own weighting scheme(s), used if provided as a <code>data.frame</code> with the number of rows
equal to the desired <code>lag</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tokens</code></td>
<td>
<p>see <code>compute_sentiment</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCore</code></td>
<td>
<p>see <code>compute_sentiment</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For available options on how aggregation can occur (via the <code>howWithin</code>,
<code>howDocs</code> and <code>howTime</code> arguments), inspect <code>get_hows</code>. The control parameters
associated to <code>howDocs</code> are used both for aggregation across documents and across sentences.
</p>


<h3>Value</h3>

<p>A <code>list</code> encapsulating the control parameters.
</p>


<h3>Author(s)</h3>

<p>Samuel Borms, Keven Bluteau
</p>


<h3>See Also</h3>

<p><code>measures_fill</code>, <code>almons</code>, <code>compute_sentiment</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(505)

# simple control function
ctr1 &lt;- ctr_agg(howTime = "linear", by = "year", lag = 3)

# more elaborate control function (particular attention to time weighting schemes)
ctr2 &lt;- ctr_agg(howWithin = "proportionalPol",
                howDocs = "exponential",
                howTime = c("equal_weight", "linear", "almon", "beta", "exponential", "own"),
                do.ignoreZeros = TRUE,
                by = "day",
                lag = 20,
                ordersAlm = 1:3,
                do.inverseAlm = TRUE,
                alphasExp = c(0.20, 0.50, 0.70, 0.95),
                aBeta = c(1, 3),
                bBeta = c(1, 3, 4, 7),
                weights = data.frame(myWeights = runif(20)),
                alphaExp = 0.3)

# set up control function with one linear and two chosen Almon weighting schemes
a &lt;- weights_almon(n = 70, orders = 1:3, do.inverse = TRUE, do.normalize = TRUE)
ctr3 &lt;- ctr_agg(howTime = c("linear", "own"), by = "year", lag = 70,
                weights = data.frame(a1 = a[, 1], a2 = a[, 3]),
                do.sentence = TRUE)

</code></pre>


</div>