<div class="container">

<table style="width: 100%;"><tr>
<td>trW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial weights matrix powers traces</h2>

<h3>Description</h3>

<p>The function is used to prepare a vector of traces of powers of a spatial weights matrix</p>


<h3>Usage</h3>

<pre><code class="language-R">trW(W=NULL, m = 30, p = 16, type = "mult", listw=NULL, momentsSymmetry=TRUE)
mom_calc(lw, m)
mom_calc_int2(is, m, nb, weights, Card)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>A spatial weights matrix in CsparseMatrix form</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The number of powers; must be an even number for ‘type’=“moments” (default changed from 100 to 30 (2010-11-17))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The number of samples used in Monte Carlo simulation of the traces if type is MC (default changed from 50 to 16 (2010-11-17))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Either “mult” (default) for powering a sparse matrix (with moderate or larger N, the matrix becomes dense, and may lead to swapping), or “MC” for Monte Carlo simulation of the traces (the first two simulated traces are replaced by their analytical equivalents), or “moments” to use the looping space saving algorithm proposed by Smirnov and Anselin (2009) - for “moments”, <code>W</code> must be symmetric, for row-standardised weights through a similarity transformation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw, lw</code></td>
<td>
<p>a listw object, which should either be fully symmetric, or be constructed as similar to symmetric from intrinsically symmetric neighbours using <code>similar.listw</code>, used with ‘type’=“moments”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentsSymmetry</code></td>
<td>
<p>default TRUE; assert Smirnov/Anselin symmetry assumption</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is</code></td>
<td>
<p>(used internally only in <code>mom_calc_int2</code> for ‘type’=“moments” on a cluster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>(used internally only in <code>mom_calc_int2</code> for ‘type’=“moments” on a cluster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>(used internally only in <code>mom_calc_int2</code> for ‘type’=“moments” on a cluster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Card</code></td>
<td>
<p>(used internally only in <code>mom_calc_int2</code> for ‘type’=“moments” on a cluster)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector of <code>m</code> traces, with “timings” and “type” attributes; the ‘type’=“MC” also returns the standard deviation of the p-vector V divided by the square root of p as a measure of spread for the trace estimates.
</p>


<h3>Note</h3>

<p><code>mom_calc</code> and <code>mom_calc_int2</code> are for internal use only</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>LeSage J and RK Pace (2009) <em>Introduction to Spatial Econometrics</em>. CRC Press, Boca Raton, pp. 96–105; Smirnov O and L Anselin (2009) An O(N) parallel method of computing the Log-Jacobian of the variable transformation for models with spatial interaction on a lattice. <em>Computational Statistics and Data Analysis</em> 53 (2009) 2983–2984.</p>


<h3>See Also</h3>

<p><code>as_dgRMatrix_listw</code>, <code>nb2listw</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("sf", quietly=TRUE) 
columbus &lt;- st_read(system.file("shapes/columbus.gpkg", package="spData")[1], quiet=TRUE)
#require(spdep, quietly=TRUE)
col.gal.nb &lt;- spdep::read.gal(system.file("weights/columbus.gal", package="spData")[1])
listw &lt;- spdep::nb2listw(col.gal.nb)
W &lt;- as(listw, "CsparseMatrix")
system.time(trMat &lt;- trW(W, type="mult"))
str(trMat)
set.seed(1100)
system.time(trMC &lt;- trW(W, type="MC"))
str(trMC)
plot(trMat, trMC)
abline(a=0, b=1)
for(i in 3:length(trMC)) {
 segments(trMat[i], trMC[i]-2*attr(trMC, "sd")[i], trMat[i],
  trMC[i]+2*attr(trMC, "sd")[i])
}
listwS &lt;- similar.listw(listw)
W &lt;- forceSymmetric(as(listwS, "CsparseMatrix"))
system.time(trmom &lt;- trW(listw=listwS, m=24, type="moments"))
str(trmom)
all.equal(trMat[1:24], trmom, check.attributes=FALSE)
system.time(trMat &lt;- trW(W, m=24, type="mult"))
str(trMat)
all.equal(trMat, trmom, check.attributes=FALSE)
set.seed(1)
system.time(trMC &lt;- trW(W, m=24, type="MC"))
str(trMC)
## Not run: 
data(boston, package="spData")
listw &lt;- spdep::nb2listw(boston.soi)
listwS &lt;- similar.listw(listw)
system.time(trmom &lt;- trW(listw=listwS, m=24, type="moments"))
str(trmom)
library(parallel)
nc &lt;- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L
# set nc to 1L here
if (nc &gt; 1L) nc &lt;- 1L
coresOpt &lt;- get.coresOption()
invisible(set.coresOption(nc))
if(!get.mcOption()) {
  cl &lt;- makeCluster(get.coresOption())
  set.ClusterOption(cl)
}
system.time(trmomp &lt;- trW(listw=listwS, m=24, type="moments"))
if(!get.mcOption()) {
  set.ClusterOption(NULL)
  stopCluster(cl)
}
all.equal(trmom, trmomp, check.attributes=FALSE)
invisible(set.coresOption(coresOpt))

## End(Not run)
</code></pre>


</div>