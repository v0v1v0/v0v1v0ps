<div class="container">

<table style="width: 100%;"><tr>
<td>glt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalised Link Transformation</h2>

<h3>Description</h3>

<p>Transform a numeric variable using a GLM link function, or
return an estimate of same.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glt(x, family = NULL, force.est = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a positive numeric vector, corresponding to a variable to be
transformed. Can also be a list or nested list of such vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Optional, the error distribution family containing the link
function which will be used to transform <code>x</code> (see <code>family()</code> for
specification details). If not supplied, it is determined from <code>x</code> (see
Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.est</code></td>
<td>
<p>Logical, whether to force the return of the estimated rather
than direct transformation, where the latter is available (i.e. does not
contain undefined values).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>glt()</code> can be used to provide a 'generalised' transformation of a
numeric variable, using the link function from a generalised linear model
(GLM) fit to the variable. The transformation is generalised in the sense
that it can extend even to cases where a standard link transformation would
produce undefined values. It achieves this by using an estimate based on
the 'working' response variable of the GLM (see below). If the error
distribution <code>family</code> is not specified (default), then it is determined
(roughly) from <code>x</code>, with <code>binomial(link = "logit")</code> used when all x &lt;= 1
and <code>poisson(link = "log")</code> otherwise. Although the function is generally
intended for variables with a binomial or Poisson distribution, any
variable which can be fit using <code>glm()</code> can be supplied. One of the key
purposes of <code>glt()</code> is to allow the calculation of fully standardised
effects (coefficients) for GLMs (in which case <code>x</code> = the response
variable), while it can also facilitate the proper calculation of SEM
indirect effects (see below).
</p>
<p><strong>Estimating the direct link transformation</strong>
</p>
<p>A key challenge in generating fully standardised effects for a GLM with a
non-gaussian link function is the difficulty in calculating appropriate
standardised ranges (typically the standard deviation) for the response
variable in the link scale. This is because a direct transformation of the
response will often produce undefined values. Although methods for
circumventing this issue by indirectly estimating the variance of the
response on the link scale have been proposed – including a
latent-theoretic approach for binomial models (McKelvey &amp; Zavoina, 1975)
and a more general variance-based method using pseudo R-squared (Menard,
2011) – here an alternative approach is used. Where transformed values are
undefined, the function will instead return the synthetic 'working'
response from the iteratively reweighted least squares (IRLS) algorithm of
the GLM (McCullagh &amp; Nelder, 1989). This is reconstructed as the sum of the
linear predictor and the working residuals – with the latter comprising the
error of the model on the link scale. The advantage of this approach is
that a relatively straightforward 'transformation' of any non-gaussian
response is readily attainable in all cases. The standard deviation (or
other relevant range) can then be calculated using values of the
transformed response and used to scale the effects. An additional benefit
for piecewise SEMs is that the transformed rather than original response
can be specified as a predictor in other models, ensuring that standardised
indirect and total effects are calculated correctly (i.e. using the same
units).
</p>
<p>To ensure a high level of 'accuracy' in the working response – in the sense
that the inverse-transformation is practically indistinguishable from the
original response variable – the function uses the following iterative
fitting procedure to calculate a 'final' working response:
</p>

<ol>
<li>
<p> A new GLM of the same error family is fit with the original response
variable as both predictor and response, and using a single IRLS iteration.
</p>
</li>
<li>
<p> The working response is reconstructed from this model.
</p>
</li>
<li>
<p> The inverse transformation of the working response is calculated.
</p>
</li>
<li>
<p> If the inverse transformation is 'effectively equal' to the original
response (tested using <code>all.equal()</code> with the default tolerance of
<code>1.5e-8</code>), the working response is returned; otherwise, the GLM is refit
with the working response now as the predictor, and steps 2-4 are repeated
– each time with an additional IRLS iteration.
</p>
</li>
</ol>
<p>This approach will generate a very reasonable transformation of the
response variable, which will also be practically indistinguishable from
the direct transformation, where this can be compared (see Examples). It
also ensures that the transformed values, and hence the standard deviation,
are the same for any GLM fitting the same response (provided it uses the
same link function) – facilitating model comparisons, selection, and
averaging.
</p>


<h3>Value</h3>

<p>A numeric vector of the transformed values, or an array, list of
vectors/arrays, or nested list.
</p>


<h3>Note</h3>

<p>As we often cannot directly observe the GLM response variable on the
link scale, any method estimating its values or statistics will be wrong to
some degree. The heuristic approach described here aims to reduce this
error as far as (reasonably) possible, while also generating standardised
effects whose interpretation most closely resembles those of the ordinary
linear model. The solution of using the working response from the GLM to
scale effects is a practical, but reasonable one, and one that takes
advantage of modern computing power to minimise error through iterative
model fitting. An added bonus is that the estimated variance is constant
across models fit to the same response variable, which cannot be said of
previous methods (Menard, 2011). The overall approach would be classed as
'observed-empirical' by Grace et al. (2018), as it utilises model error
variance (the estimated working residuals) rather than theoretical
distribution-specific variance.
</p>


<h3>References</h3>

<p>Grace, J. B., Johnson, D. J., Lefcheck, J. S., &amp; Byrnes, J. E. K.
(2018). Quantifying relative importance: computing standardized effects in
models with binary outcomes. <em>Ecosphere</em>, <em>9</em>, e02283. <a href="https://doi.org/10/gdm5bj">doi:10/gdm5bj</a>
</p>
<p>McCullagh P., &amp; Nelder, J. A. (1989). <em>Generalized Linear Models</em> (2nd
Edition). Chapman and Hall.
</p>
<p>McKelvey, R. D., &amp; Zavoina, W. (1975). A statistical model for the analysis
of ordinal level dependent variables. <em>The Journal of Mathematical
Sociology</em>, <em>4</em>(1), 103-120. <a href="https://doi.org/10/dqfhpp">doi:10/dqfhpp</a>
</p>
<p>Menard, S. (2011). Standards for Standardized Logistic Regression
Coefficients. <em>Social Forces</em>, <em>89</em>, 1409-1428. <a href="https://doi.org/10/bvxb6s">doi:10/bvxb6s</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compare estimate with a direct link transformation
# (test with a poisson variable, log link)
set.seed(13)
y &lt;- rpois(30, lambda = 10)
yl &lt;- unname(glt(y, force.est = TRUE))

# Effectively equal?
all.equal(log(y), yl)
# TRUE

# Actual difference...
all.equal(log(y), yl, tolerance = .Machine$double.eps)
# "Mean relative difference: 2.489317e-10"
</code></pre>


</div>