<div class="container">

<table style="width: 100%;"><tr>
<td>concat.split</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split Concatenated Cells in a Dataset</h2>

<h3>Description</h3>

<p>The <code>concat.split</code> function takes a column with multiple values, splits
the values into a <code>list</code> or into separate columns, and returns a new
<code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">concat.split(data, split.col, sep = ",", structure = "compact",
  mode = NULL, type = NULL, drop = FALSE, fixed = FALSE,
  fill = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The source <code>data.frame</code> or <code>data.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.col</code></td>
<td>
<p>The variable that needs to be split; can be specified
either by the column number or the variable name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>The character separating each value (defaults to <code>","</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structure</code></td>
<td>
<p>Can be either <code>"compact"</code>, <code>"expanded"</code>, or <code>list</code>. Defaults
to <code>"compact"</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>Can be either <code>"binary"</code> or <code>"value"</code> (where <code>"binary"</code> is default
and it recodes values to 1 or <code>NA</code>, like Boolean data, but without assuming 0
when data is not available). This setting only applies when
<code>structure = "expanded"</code>; a warning message will be issued if used with other
structures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Can be either <code>"numeric"</code> or <code>"character"</code> (where <code>"numeric"</code> is
default).  This setting only applies when <code>structure = "expanded"</code>; a warning
message will be issued if used with other structures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Logical (whether to remove the original variable from the output
or not). Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Is the input for the <code>sep</code> value <em>fixed</em>, or a <em>regular
expression</em>? See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>The "fill" value for missing values when <code>structure = "expanded"</code>.
Defaults to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>cSplit()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><em>structure</em>
</p>

<ul>
<li> <p><code>"compact"</code> creates as many columns as the maximum length of the resulting
split. This is the most useful general-case application of this function.
</p>
</li>
<li>
<p> When the input is numeric, <code>"expanded"</code> creates as many columns as the
maximum value of the input data. This is most useful when converting to
<code>mode = "binary"</code>.
</p>
</li>
<li> <p><code>"list"</code> creates a single new column that is structurally a <code>list</code> within a
<code>data.frame</code> or <code>data.table</code>.
</p>
</li>
</ul>
<p><em>fixed</em>
</p>

<ul><li>
<p> When <code>structure = "expanded"</code> or <code>structure = "list"</code>, it is possible to
supply a a regular expression containing the characters to split on. For
example, to split on <code>","</code>, <code>";"</code>, or <code>"|"</code>, you can set <code>sep = ",|;|\|"</code> or
<code>sep = "[,;|]"</code>, and <code>fixed = FALSE</code> to split on any of those characters.
</p>
</li></ul>
<h3>Note</h3>

<p>This is more of a "legacy" or "convenience" wrapper function encompassing
the features available in the separated functions of <code>cSplit()</code>, <code>cSplit_l()</code>,
and <code>cSplit_e()</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code>cSplit()</code>, <code>cSplit_l()</code>, <code>cSplit_e()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Load some data
temp &lt;- head(concat.test)

# Split up the second column, selecting by column number
concat.split(temp, 2)

# ... or by name, and drop the offensive first column
concat.split(temp, "Likes", drop = TRUE)

# The "Hates" column uses a different separator
concat.split(temp, "Hates", sep = ";", drop = TRUE)

## Not run: 
# You'll get a warning here, when trying to retain the original values
concat.split(temp, 2, mode = "value", drop = TRUE)

## End(Not run)

# Try again. Notice the differing number of resulting columns
concat.split(temp, 2, structure = "expanded",
mode = "value", type = "numeric", drop = TRUE)

# Let's try splitting some strings... Same syntax
concat.split(temp, 3, drop = TRUE)

# Strings can also be split to binary representations
concat.split(temp, 3, structure = "expanded",
type = "character", fill = 0, drop = TRUE)

# Split up the "Likes column" into a list variable; retain original column
head(concat.split(concat.test, 2, structure = "list", drop = FALSE))

# View the structure of the output to verify
# that the new column is a list; note the
# difference between "Likes" and "Likes_list".
str(concat.split(temp, 2, structure = "list", drop = FALSE))

</code></pre>


</div>