<div class="container">

<table style="width: 100%;"><tr>
<td>to_rjson</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert R object to and from RJSON specification</h2>

<h3>Description</h3>

<p>RJSON is an object specification that is not unlike JSON, but
better adapted to represent <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects (i.e., richer than JSON). It is also
easier to parse and evaluate in both <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and JavaScript to render the objects
in both languages. RJSON objects are used by SciViews to exchange data
between <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and SciViews GUIs like Komodo/SciViews-K.
</p>


<h3>Usage</h3>

<pre><code class="language-R">to_rjson(x, attributes = FALSE)

eval_rjson(rjson)

list_to_json(x)

toRjson(x, attributes = FALSE)

evalRjson(rjson)

listToJson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Any <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object to be converted into RJSON (do not work with objects
containing C pointers, environments, promises or expressions, but should
work with almost all other <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attributes</code></td>
<td>
<p>If <code>FALSE</code> (by default), a simple object is created by
ignoring all attributes. This is usually the suitable option to transfer data
to another language, like JavaScript that do not understand R attributes
anyway. With <code>attributes = TRUE</code>, the complete information about the object
is written, so that the object could be recreated (almost) identical when
evaluated in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> (but prefer <code>save()</code> and <code>load()</code> to transfer objects between
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sessions!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rjson</code></td>
<td>
<p>A string containing an object specified in RJSON notation. The
specification is evaluated in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>... and it can contain also R code. There is
no protection provided against execution of bad code. So, you must trust the
source!</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>JSON (JavaScript Object Notation) allows to specify fairly complex
objects that can be rather easily exchanged between languages. The notation
is also human-readable and not too difficult to edit manually (although not
advised, of course). However, JSON has too many limitations to represent <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
objects (no <code>NA</code> versus <code>NaN</code>, no infinite numbers, no distinction between
lists and objects with attributes, or S4 objects, etc.). Moreover, JSON is
not very easy to interpret in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and the existing implementations can convert
only specified objects (simple objects, lists, data frames, ...).
</p>
<p>RJSON slightly modifies and enhances JSON to make it: (1) more complete to
represent almost any <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object (except objects with pointers, environments,
..., of course), and (2) to make it very easy to parse and evaluate in both
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and JavaScript (and probably many other) languages.
</p>
<p>With <code>attributes = FALSE</code>, factors and Dates are converted to their usual
character representation before encoding the RJSON object. If
<code>attributes = TRUE</code>, they are left as numbers and their attributes (class,
-and levels for factor-) completely characterize them (i.e., using
<code>eval_rjson()</code> and such objects recreate factors or Dates, respectively).
However, they are probably less easy to handle in JavaScript of other
language where you import the RJSON representation.
</p>
<p>Note also that a series of objects are not yet handled correctly. These
include: complex numbers, the different date flavors other that Date,
functions, expressions, environments, pointers. Do not use such items in
objects that you want to convert to RJSON notation.
</p>
<p>A last restriction: you cannot have any special characters like linefeed,
tabulation, etc. in names. If you want to make your names most compatible
with JavaScript, note that the dot is not allowed in syntactically valid
names, but the dollar sign is allowed.
</p>


<h3>Value</h3>

<p>For <code>to_rjson()</code>, a character string vector with the RJSON
specification of the argument.
</p>
<p>For <code>eval_rjson()</code>, the corresponding <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object in case of a pure RJSON
object specification, or the result of evaluating the code, if it contains <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
commands (for instance, a RJSONp -RJSON with padding- item where a RJSON
object is an argument of an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that is evaluated. In this case, the
result of the evaluation is returned).
</p>
<p>For <code>list_to_json()</code>, correct (standard) JSON code is generated if <code>x</code> is a
list of character strings, or lists.
</p>


<h3>See Also</h3>

<p><code>parse_text()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A complex R object
obj &lt;- structure(list(
  a = as.double(c(1:5, 6)),
  LETTERS,
  c = c(c1 = 4.5, c2 = 7.8, c3 = Inf, c4 = -Inf, NA, c6 = NaN),
  c(TRUE, FALSE, NA),
  e = factor(c("a", "b", "a")),
  f = 'this is a "string" with quote',
  g = matrix(rnorm(4), ncol = 2),
  `h&amp;$@` = data.frame(x = 1:3, y = rnorm(3),
    fact = factor(c("b", "a", "b"))),
  i = Sys.Date(),
  j = list(1:5, y = "another item")),
  comment = "My comment",
  anAttrib = 1:10,
  anotherAttrib = list(TRUE, y = 1:4))

# Convert to simplest RJSON, without attributes
rjson1 &lt;- to_rjson(obj)
rjson1
eval_rjson(rjson1)

# More complex RJSON, with attributes
rjson2 &lt;- to_rjson(obj, TRUE)
rjson2
obj2 &lt;- eval_rjson(rjson2)
obj2
# Numbers near equivalence comparison (note: identical(Robj, Robj2) is FALSE)
all.equal(obj, obj2)

rm(obj, obj2, rjson1, rjson2)
</code></pre>


</div>