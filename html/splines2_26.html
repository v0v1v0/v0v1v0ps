<div class="container">

<table style="width: 100%;"><tr>
<td>naturalSpline</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Natural Cubic Spline Basis for Polynomial Splines</h2>

<h3>Description</h3>

<p>Functions <code>naturalSpline()</code> and <code>nsk()</code> generate the natural cubic
spline basis functions, the corresponding derivatives or integrals (from the
left boundary knot).  Both of them are different from <code>splines::ns()</code>.
However, for a given model fitting procedure, using different variants of
spline basis functions should result in identical prediction values.  The
coefficient estimates of the spline basis functions returned by <code>nsk()</code>
are more interpretable compared to <code>naturalSpline()</code> or
<code>splines::ns()</code> .
</p>


<h3>Usage</h3>

<pre><code class="language-R">naturalSpline(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)

nsp(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)

nsk(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degree of freedom that equals to the column number of returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - 1 - as.integer(intercept)</code> internal knots at
suitable quantiles of <code>x</code> ignoring missing values and those
<code>x</code> outside of the boundary.  Thus, <code>df</code> must be greater than
or equal to <code>2</code>.  If internal knots are specified via <code>knots</code>,
the specified <code>df</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.
Duplicated internal knots are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>The fraction (0 to 0.5) of observations to be trimmed from each
end of <code>x</code> before placing the default internal and boundary knots.
This argument will be ignored if <code>Boundary.knots</code> is specified.
The default value is <code>0</code> for backward compatibility, which sets the
boundary knots as the range of <code>x</code>.  If a positive fraction is
specified, the default boundary knots will be equivalent to
<code>quantile(x, probs = c(trim, 1 - trim), na.rm = TRUE)</code>, which can
be a more sensible choice in practice due to the existence of outliers.
The default internal knots are placed within the boundary afterwards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
natural splines. The default value is <code>0L</code> for the spline basis
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integral</code></td>
<td>
<p>A logical value.  The default value is <code>FALSE</code>.  If
<code>TRUE</code>, this function will return the integrated natural splines
from the left boundary knot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The constructed spline basis functions from <code>naturalSpline()</code> are
nonnegative within boundary with the second derivatives being zeros at
boundary knots.  The implementation utilizes the close-form null space that
can be derived from the recursive formula for the second derivatives of
B-splines.  The function <code>nsp()</code> is an alias of <code>naturalSpline()</code>
to encourage the use in a model formula.
</p>
<p>The function <code>nsk()</code> produces another variant of natural cubic spline
matrix such that only one of the basis functions is nonzero and takes a
value of one at every boundary and internal knot.  As a result, the
coefficients of the resulting fit are the values of the spline function at
the knots, which makes it easy to interpret the coefficient estimates.  In
other words, the coefficients of a linear model will be the heights of the
function at the knots if <code>intercept = TRUE</code>.  If <code>intercept =
FALSE</code>, the coefficients will be the change in function value between each
knot.  This implementation closely follows the function <code>nsk()</code> of the
<span class="pkg">survival</span> package (version 3.2-8).  The idea corresponds directly to
the physical implementation of a spline by passing a flexible strip of wood
or metal through a set of fixed points, which is a traditional way to create
smooth shapes for things like a ship hull.
</p>
<p>The returned basis matrix can be obtained by transforming the corresponding
B-spline basis matrix with the matrix <code>H</code> provided in the attribute of
the returned object.  Each basis is assumed to follow a linear trend for
<code>x</code> outside of boundary.  A similar implementation is provided by
<code>splines::ns</code>, which uses QR decomposition to find the null space of
the second derivatives of B-spline basis at boundary knots.  See
Supplementray Materials of Wang and Yan (2021) for a more detailed
introduction.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code>
columns if <code>df</code> is specified or <code>length(knots) + 1 +
    as.integer(intercept)</code> columns if <code>knots</code> are specified instead.
Attributes that correspond to the arguments specified are returned for
usage of other functions in this package.
</p>


<h3>See Also</h3>

<p><code>bSpline</code> for B-splines;
<code>mSpline</code> for M-splines;
<code>iSpline</code> for I-splines.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(splines2)

x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

## naturalSpline()
nsMat0 &lt;- naturalSpline(x, knots = knots, intercept = TRUE)
nsMat1 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, integral = TRUE)
nsMat2 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, derivs = 1)
nsMat3 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, derivs = 2)

op &lt;- par(mfrow = c(2, 2), mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(nsMat0, ylab = "basis")
plot(nsMat1, ylab = "integral")
plot(nsMat2, ylab = "1st derivative")
plot(nsMat3, ylab = "2nd derivative")
par(op) # reset to previous plotting settings

## nsk()
nskMat &lt;- nsk(x, knots = knots, intercept = TRUE)
plot(nskMat, ylab = "nsk()", mark_knots = "all")
abline(h = 1, col = "red", lty = 3)

## use the deriv method
all.equal(nsMat0, deriv(nsMat1), check.attributes = FALSE)
all.equal(nsMat2, deriv(nsMat0))
all.equal(nsMat3, deriv(nsMat2))
all.equal(nsMat3, deriv(nsMat0, 2))

## a linear model example
fit1 &lt;- lm(weight ~ -1 + nsk(height, df = 4, intercept = TRUE), data = women)
fit2 &lt;- lm(weight ~ nsk(height, df = 3), data = women)

## the knots (same for both fits)
knots &lt;- unlist(attributes(fit1$model[[2]])[c("Boundary.knots", "knots")])

## predictions at the knot points
predict(fit1, data.frame(height = sort(unname(knots))))
unname(coef(fit1)) # equal to the coefficient estimates

## different interpretation when "intercept = FALSE"
unname(coef(fit1)[-1] - coef(fit1)[1]) # differences: yhat[2:4] - yhat[1]
unname(coef(fit2))[-1]                 # ditto
</code></pre>


</div>