<div class="container">

<table style="width: 100%;"><tr>
<td>marktable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tabulate Marks in Neighbourhood of Every Point in a Point Pattern</h2>

<h3>Description</h3>

<p>Visit each point in a multitype point pattern, find the neighbouring points,
and compile a frequency table of the marks of these neighbour points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">   marktable(X, R, N, exclude=TRUE, collapse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A multitype point pattern. 
An object of class <code>"ppp"</code>, <code>"lpp"</code>,
<code>"pp3"</code> or <code>"ppx"</code>, with marks which are a factor.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>

<p>Neighbourhood radius. Incompatible with <code>N</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>

<p>Number of neighbours of each point. Incompatible with <code>R</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>

<p>Logical. If <code>exclude=TRUE</code>, the neighbours of a point
do not include the point itself. If <code>exclude=FALSE</code>,
a point belongs to its own neighbourhood.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>

<p>Logical. If <code>collapse=FALSE</code> (the default) the results for
each point are returned as separate rows of a table.
If <code>collapse=TRUE</code>, the results are aggregated according to the
type of point.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This algorithm visits each point in the point pattern <code>X</code>,
inspects all the neighbouring points within a radius <code>R</code> of the current
point (or the <code>N</code> nearest neighbours of the current point),
and compiles a frequency table of the marks attached to the
neighbours. 
</p>
<p>The dataset <code>X</code> must be a multitype point pattern, that is,
<code>marks(X)</code> must be a <code>factor</code>.
</p>
<p>If <code>collapse=FALSE</code> (the default), 
the result is a two-dimensional contingency table with one row for
each point in the pattern, and one column for each possible mark
value. The <code>[i,j]</code> entry in the table gives the number of
neighbours of point <code>i</code> that have mark <code>j</code>.
</p>
<p>If <code>collapse=TRUE</code>, this contingency table is aggregated
according to the type of point, so that the result is a contingency
table with one row and one column for each possible mark value.
The  <code>[i,j]</code> entry in the table gives the number of
neighbours of a point with mark <code>i</code> that have mark <code>j</code>.
</p>
<p>To perform more complicated calculations on the neighbours of every
point, use <code>markstat</code> or <code>applynbd</code>. 
</p>


<h3>Value</h3>

<p>A contingency table (object of class <code>"table"</code>).
If <code>collapse=FALSE</code>, the table has one row for
each point in <code>X</code>, and one column for each possible mark value.
If <code>collapse=TRUE</code>, the table has one row and one column
for each possible mark value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>markstat</code>,
<code>applynbd</code>,
<code>Kcross</code>,
<code>ppp.object</code>,
<code>table</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  head(marktable(amacrine, 0.1))
  head(marktable(amacrine, 0.1, exclude=FALSE))
  marktable(amacrine, N=1, collapse=TRUE)
</code></pre>


</div>