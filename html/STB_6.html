<div class="container">

<table style="width: 100%;"><tr>
<td>rankSTB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rank-Based Algorithm for Computing 100(1-alpha)% Simulataneous Tolerance Bounds.</h2>

<h3>Description</h3>

<p>Implementation of a rank-based algorithm for constructing 100(1-alpha)% STBs as outlined in the reference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rankSTB(mat, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>(numeric) matrix of dimension (N, n), where i-th row corrsponds to ordered values 
of the i-th simulation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(numeric) value defining the desired coverage as 100(1-alpha)%</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a performance optimized version of the original rank-based algorithm avoiding the time-consuming
iteration. In principle it sorts out simulation results which have at least one extreme order statistic untill
exactly 100(1-alpha)% of all simulation results remain. From these, bounds of the STB are constructed determining
extreme-values per order-statistic (column).
</p>
<p>This implementation also corrects step 4) of the published algorithm, which has to find those indices of elements being
equal to "min(c)" OR being equal to "N-min(c)+1". This reflects the construction of vector "c", where max. rank-values
are transformed to min. rank-values. In step 6) the "N_k-1-(1-alpha)*N largest" elements of "d_l^theta" have to
be selected, which needs also correction.
</p>
<p>Parallel processing did not minimize the computation time in contrast to the algorithms for computing the quantile-based algorithm.
Thus, parallel processing is not supported for this algorithm.
</p>


<h3>Value</h3>

<p>(list) with two elements:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>(matrix) 1st row stores lower bounds, 2nd row upper bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>(numeric) value corresponding the coverage</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# for following problem size the rank-based algo
# outperforms the quantile based one, although,
# ran serially
mat &lt;- matrix(rnorm(10000*100), ncol=100)
mat &lt;- t(apply(mat, 1, sort))
system.time(stb.rank &lt;- rankSTB(mat))
system.time(stb.q.R  &lt;- getSTB(mat))
system.time(stb.q.C  &lt;- fastSTB(mat))
x &lt;- apply(mat, 2, mean)
plot(x,x, ylim=c(-5,5))
lines(x, stb.q.R$Q[1,], col="blue", lwd=2)
lines(x, stb.q.R$Q[2,], col="blue", lwd=2)
lines(x, stb.q.C$Q[1,], col="red",  lwd=2)
lines(x, stb.q.C$Q[2,], col="red",  lwd=2)
lines(x, stb.rank$Q[1,],  col="cyan", lwd=2)
lines(x, stb.rank$Q[2,],  col="cyan", lwd=2)
legend("top", legend=c("R-quantile", "C-quantile", "rank-based"), 
       fill=c("blue", "red", "cyan"))

# varying Ncpu for the C-implementation of the quantile-based algo
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=4))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=6))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=8))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=10))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=12))

## End(Not run)
</code></pre>


</div>