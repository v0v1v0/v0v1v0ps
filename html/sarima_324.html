<div class="container">

<table style="width: 100%;"><tr>
<td>xarmaFilter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Applies an extended ARMA filter to a time series </h2>

<h3>Description</h3>

<p>Filter time series with an extended arma filter.
If <code>whiten</code> is <code>FALSE</code> (default) the function applies
the given ARMA filter to <code>eps</code> (<code>eps</code> is often
white noise).  If <code>whiten</code> is <code>TRUE</code> the function applies
the “inverse filter” to <code class="reqn">x</code>, effectively computing
residuals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">xarmaFilter(model, x = NULL, eps = NULL, from = NULL, whiten = FALSE,
            xcenter = NULL, xintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> the time series to be filtered, a vector. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> residuals, a vector or NULL. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>the model parameters, a list with components <code>"ar"</code>,
<code>"ma"</code>, <code>"center"</code> and <code>"intercept"</code>, see Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p> the index from which to start filtering. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiten</code></td>
<td>

<p>if TRUE use <code>x</code> as input and apply the inverse filter to
produce <code>eps</code> ("whiten" <code>x</code>), if FALSE use <code>eps</code> as
input and generate <code>x</code> ("colour" <code>eps</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xcenter</code></td>
<td>

<p>a vector of means of the same length as the time series, see Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xintercept</code></td>
<td>

<p>a vector of intercepts having the length of the series, see Details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model is specified by argument <code>model</code>, which is a list with
the following components:
</p>

<dl>
<dt><code>ar</code></dt>
<dd>
<p> the autoregression parameters,</p>
</dd>
<dt><code>ma</code></dt>
<dd>
<p> the moving average parameters,</p>
</dd>
<dt><code>center</code></dt>
<dd>
<p> center by this value,</p>
</dd>
<dt><code>intercept</code></dt>
<dd>
<p>intercept.</p>
</dd>
</dl>
<p><code>model$center</code> and <code>model$intercept</code> are scalars and usually
at most one of them is nonzero. They can be considered part of the
model specification. In contrast, arguments <code>xcenter</code> and
<code>xintercept</code> are vectors of the same length as <code>x</code>. They can
represent contributions from covariate variables. Usually at most one
of <code>xcenter</code> and <code>xintercept</code> is used.
</p>
<p>The description below uses <code class="reqn">\mu_t</code> and <code class="reqn">c_t</code> for
the contributions by <code>model$center</code> plus <code>xcenter</code> and
<code>model$intercept</code> plus <code>xintercept</code>, respectively.
The time series <code class="reqn">\{x_t\}</code> and <code class="reqn">\{\varepsilon_t\}</code> are
represented by <code>x</code> and <code>eps</code> in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> code.
Let
</p>
<p style="text-align: center;"><code class="reqn">y_t = x_t - \mu_t</code>
</p>

<p>be the centered series.  where the centering term <code class="reqn">\mu_t</code>
is essentially the sum of <code>center</code> and <code>xcenter</code> and is not
necessarilly the mean.  The equation relating the centered series,
<code class="reqn">y_t=x_t - \mu_t</code>, and <code>eps</code> is the
following:
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    =   c_t
      + \sum_{i=1}^{p} \phi(i)y            _{t-i}
      + \sum_{i=1}^{q} \theta(i)\varepsilon_{t-i}
      + \varepsilon_t
    </code>
</p>

<p>where <code class="reqn">c_t</code> is the intercept (basically the sum of
<code>intercept</code> with <code>xintercept</code>).
</p>
<p>If <code>whiten = FALSE</code>, <code class="reqn">y_t</code> is computed for
<code>t=from,...,n</code> using the above formula, i.e. the filter is
applied to get <code>y</code> from <code>eps</code> (and some initial values). If
<code>eps</code> is white noise, it can be said that <code>y</code> is obtained by
“colouring” the white noise <code>eps</code>. This can be used, for
example, to simulate ARIMA time series.  Finally, the centering term
is added back, <code class="reqn">x_t=y_t+\mu_t</code> for <code>t=from,...,n</code>, and the
modified <code>x</code> is returned.  The first <code>from - 1</code> elements of
<code>x</code> are left unchanged.
</p>
<p>The inverse filter is obtained by rewriting the above equation as an equation
expressing <code class="reqn">\varepsilon_t</code> in terms of the remaining quantities:
</p>
<p style="text-align: center;"><code class="reqn"> \varepsilon_t
    = - c_t
      - \sum_{i=1}^{q} \theta(i)\varepsilon_{t-i}
      - \sum_{i=1}^{p} \phi  (i)y          _{t-i}
      + y_t
    </code>
</p>

<p>If <code>whiten = TRUE</code>, <code>xarmaFilter</code> uses this formula for
<code>t=from,...,n</code> to compute <code>eps</code> from <code>y</code> (and some
initial values). If <code>eps</code> is white noise, then it can be said
that the time series <code>y</code> has been whitened.
</p>
<p>In both cases the first few values in <code>x</code> and/or
<code>eps</code> are used as initial values.
</p>
<p>The centering is formed from <code>model$center</code> and argument
<code>xcenter</code>.  If <code>model$center</code> is supplied it is recycled
to the length of the series, <code>x</code>, and subtracted from
<code>x</code>. If argument <code>xcenter</code> is supplied, it is subtracted
from <code>x</code>. If both <code>model$center</code> and <code>xcenter</code> are
supplied their sum is subtracted from <code>x</code>.
</p>
<p><code>xarmaFilter</code> can be used to simulate ARMA series with the
default value of <code>whiten = FALSE</code>. In this case <code>eps</code> is the
input series and <code>y</code> the output:
Then <code>model$center</code> and/or <code>xcenter</code> are added to <code>y</code>
to form the output vector <code>x</code>.
</p>
<p>Residuals corresponding to a series <code>x</code> can be obtained by
setting <code>whiten = TRUE</code>. In this case <code>x</code> is the input series.
The elements of the output vector <code>eps</code> are calculated by the
formula for <code class="reqn">\varepsilon_{t}</code> given above.
There is no need in this case to restore <code>x</code> since <code>eps</code> is
returned.
</p>
<p>In both cases any necessary initial values are assumed to be already
in the vectors and provide the first <code>from - 1</code> values in the
returned vectors.  Argument <code>from</code> should not be smaller than the
default value <code>max(p,q)+1</code>.
</p>
<p><code>xarmaFilter</code> calls the lower level function <code>coreXarmaFilter</code>
to do the computation.
</p>


<h3>Value</h3>

<p>the result of applying the filter or its inverse, as descibed in Details:
if <code>whiten = FALSE</code>, the modified <code>x</code>;
if <code>whiten = TRUE</code>, the modified <code>eps</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class="language-R">## define a seasonal ARIMA model
m1 &lt;- new("SarimaModel", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)

model0 &lt;- modelCoef(m1, "ArmaModel")
model1 &lt;- as(model0, "list")

ap.1 &lt;- xarmaFilter(model1, x = AirPassengers, whiten = TRUE)
ap.2 &lt;- xarmaFilter(model1, x = AirPassengers, eps = ap.1, whiten = FALSE)
ap &lt;- AirPassengers
ap[-(1:13)] &lt;- 0 # check that the filter doesn't use x, except for initial values.
ap.2a &lt;- xarmaFilter(model1, x = ap, eps = ap.1, whiten = FALSE)
ap.2a - ap.2 ## indeed = 0
##ap.3 &lt;- xarmaFilter(model1, x = list(init = AirPassengers[1:13]), eps = ap.1, whiten = TRUE)

## now set some non-zero initial values for eps
eps1 &lt;- numeric(length(AirPassengers))
eps1[1:13] &lt;- rnorm(13)
ap.A &lt;- xarmaFilter(model1, x = AirPassengers, eps = eps1, whiten = TRUE)
ap.Ainv &lt;- xarmaFilter(model1, x = ap, eps = ap.A, whiten = FALSE)
AirPassengers - ap.Ainv # = 0

## compare with sarima.f (an old function)
## compute predictions starting at from = 14
pred1 &lt;- sarima.f(past = AirPassengers[1:13], n = 131, ar = model1$ar, ma = model1$ma)
pred2 &lt;- xarmaFilter(model1, x = ap, whiten = FALSE)
pred2 &lt;- pred2[-(1:13)]
all(pred1 == pred2) ##TRUE
</code></pre>


</div>