<div class="container">

<table style="width: 100%;"><tr>
<td>groupGenerics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group Generics for <code>soma_adat</code> Class Objects</h2>

<h3>Description</h3>

<p>S3 group generic methods to apply group specific prototype functions
to the RFU data <strong>only</strong> of <code>soma_adat</code> objects.
The clinical meta data are <em>not</em> transformed and remain unmodified in
the returned object (<code>Math()</code> and <code>Ops()</code>) or are ignored for the
<code>Summary()</code> group. See <code>groupGeneric()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'soma_adat'
Math(x, ...)

antilog(x, base = 10)

## S3 method for class 'soma_adat'
Ops(e1, e2 = NULL)

## S3 method for class 'soma_adat'
Summary(..., na.rm = FALSE)

## S3 method for class 'soma_adat'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The <code>soma_adat</code> class object to perform the transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the various group generics
as appropriate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>A positive or complex number: the base with respect to
which logarithms are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>Objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical. Should missing values be removed?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>soma_adat</code> object with the same dimensions of the input
object with the feature columns transformed by the specified generic.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>antilog()</code>: performs the inverse or anti-log transform for a numeric vector of
<code>soma_adat</code> object. <strong>note:</strong> default is <code>base = 10</code>, which differs from
the <code>log()</code> default base <em>e</em>.
</p>
</li>
<li> <p><code>Ops(soma_adat)</code>: performs binary mathematical operations on class <code>soma_adat</code>. See <code>Ops()</code>.
</p>
</li>
<li> <p><code>Summary(soma_adat)</code>: performs summary calculations on class <code>soma_adat</code>. See <code>Summary()</code>.
</p>
</li>
<li> <p><code> == </code>: compares left- and right-hand sides of the operator <em>unless</em> the RHS
is also a <code>soma_adat</code>, in which case <code>diffAdats()</code> is invoked.
</p>
</li>
</ul>
<h3>Math</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt;  [1] "abs"      "acos"     "acosh"    "asin"     "asinh"    "atan"    
#&gt;  [7] "atanh"    "ceiling"  "cos"      "cosh"     "cospi"    "cummax"  
#&gt; [13] "cummin"   "cumprod"  "cumsum"   "digamma"  "exp"      "expm1"   
#&gt; [19] "floor"    "gamma"    "lgamma"   "log"      "log10"    "log1p"   
#&gt; [25] "log2"     "sign"     "sin"      "sinh"     "sinpi"    "sqrt"    
#&gt; [31] "tan"      "tanh"     "tanpi"    "trigamma" "trunc"
</pre></div>
<p>Commonly used generics of this group include:
</p>

<ul><li> <p><code>log()</code>, <code>log10()</code>, <code>log2()</code>, <code>antilog()</code>,
<code>abs()</code>, <code>sign()</code>, <code>floor()</code>, <code>sqrt()</code>, <code>exp()</code>
</p>
</li></ul>
<h3>Ops</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt;  [1] "+"   "-"   "*"   "^"   "%%"  "%/%" "/"   "=="  "&gt;"   "&lt;"   "!="  "&lt;=" 
#&gt; [13] "&gt;="
</pre></div>
<p>Note that for the <code style="white-space: pre;">⁠`==`⁠</code> method if the RHS is also a <code>soma_adat</code>,
<code>diffAdats()</code> is invoked which compares LHS vs. RHS.
Commonly used generics of this group include:
</p>

<ul><li> <p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>, <code>&gt;</code>, <code>&lt;</code>
</p>
</li></ul>
<h3>Summary</h3>

<p>Group members:
</p>
<div class="sourceCode"><pre>#&gt; [1] "all"   "any"   "max"   "min"   "prod"  "range" "sum"
</pre></div>
<p>Commonly used generics of this group include:
</p>

<ul><li> <p><code>max()</code>, <code>min()</code>, <code>range()</code>, <code>sum()</code>, <code>any()</code>
</p>
</li></ul>
<h3>Author(s)</h3>

<p>Stu Field
</p>


<h3>See Also</h3>

<p><code>groupGeneric()</code>, <code>getGroupMembers()</code>, <code>getGroup()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># subset `example_data` for speed
# all SeqIds from 2000 -&gt; 2999
seqs &lt;- grep("^seq\\.2[0-9]{3}", names(example_data), value = TRUE)
ex_data_small &lt;- head(example_data[, c(getMeta(example_data), seqs)], 10L)
dim(ex_data_small)

ex_data_small$seq.2991.9

# Math Generics:
# -------------
# log-transformation
a &lt;- log(ex_data_small)
a$seq.2991.9

b &lt;- log10(ex_data_small)
b$seq.2991.9
isTRUE(all.equal(b, log(ex_data_small, base = 10)))

# floor
c &lt;- floor(ex_data_small)
c$seq.2991.9

# square-root
d &lt;- sqrt(ex_data_small)
d$seq.2991.9

# rounding
e &lt;- round(ex_data_small)
e$seq.2991.9

# inverse log
antilog(1:4)

alog &lt;- antilog(b)
all.equal(ex_data_small, alog)    # return `b` -&gt; linear space

# Ops Generics:
# -------------
plus1 &lt;- ex_data_small + 1
times2 &lt;- ex_data_small * 2

sq &lt;- ex_data_small^2
all.equal(sqrt(sq), ex_data_small)

gt100k &lt;- ex_data_small &gt; 100000
gt100k

ex_data_small == ex_data_small   # invokes diffAdats()

# Summary Generics:
# -------------
sum(ex_data_small)

any(ex_data_small &lt; 100)  # low RFU analytes

sum(ex_data_small &lt; 100)  # how many

min(ex_data_small)

min(ex_data_small, 0)

max(ex_data_small)

max(ex_data_small, 1e+7)

range(ex_data_small)
</code></pre>


</div>