<div class="container">

<table style="width: 100%;"><tr>
<td>pit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Non-Randomized Version of the PIT Histogram (for Count Data)
</h2>

<h3>Description</h3>

<p>See Czado et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pit(x, ...)
## Default S3 method:
pit(x, pdistr, J = 10, relative = TRUE, ..., plot = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>numeric vector representing the observed counts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdistr</code></td>
<td>

<p>either a list of predictive cumulative distribution functions for
the observations <code>x</code>, or (the name of) a single predictive CDF
used for all <code>x</code> (with potentially varying arguments <code>...</code>).
It is checked that the predictive CDF returns 0 at <code>x=-1</code>.
The name of its first argument can be different from <code>x</code>, e.g.,
<code>pdistr="pnbinom"</code> is possible.<br>
If <code>pdistr</code> is a single function and no additional <code>...</code>
arguments are supplied, <code>pdistr</code> is assumed to be vectorized,
i.e., it is simply called as <code>pdistr(x)</code> and <code>pdistr(x-1)</code>.
Otherwise, the predictive CDF is called sequentially and does not
need to be vectorized.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>

<p>the number of bins of the histogram.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>

<p>logical indicating if relative frequency or the density should be plotted.
Due to a historical bug, <code>relative=TRUE</code> (the default) actually
plots a density histogram while <code>relative=FALSE</code> plots relative
frequencies.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>ignored if <code>pdistr</code> is a list. Otherwise, such additional
arguments are used in sequential calls of <code>pdistr</code> via
<code>mapply(pdistr, x, ...)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>

<p>a list of arguments for <code>plot.histogram</code>.
Otherwise, no plot will be produced.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class <code>"pit"</code>, which inherits from class
<code>"histogram"</code> (see <code>hist</code>).
It is returned invisibly if a plot is produced.
</p>


<h3>Author(s)</h3>

<p>Michaela Paul and Sebastian Meyer
</p>


<h3>References</h3>

<p>Czado, C., Gneiting, T. and Held, L. (2009):
Predictive model assessment for count data.
<em>Biometrics</em>, <b>65</b> (4), 1254-1261.
<a href="https://doi.org/10.1111/j.1541-0420.2009.01191.x">doi:10.1111/j.1541-0420.2009.01191.x</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulation example of Czado et al. (2009, Section 2.4)
set.seed(100)
x &lt;- rnbinom(200, mu = 5, size = 2)
pdistrs &lt;- list("NB(5,0)"   = function (x) ppois(x, lambda=5),
                "NB(5,1/2)" = function (x) pnbinom(x, mu=5, size=2),
                "NB(5,1)"   = function (x) pnbinom(x, mu=5, size=1))
## Reproduce Figure 1
op &lt;- par(mfrow = c(1,3))
for (i in seq_along(pdistrs)) {
    pit(x, pdistr = pdistrs[[i]], J = 10,
        plot = list(ylim = c(0,2.75), main = names(pdistrs)[i]))
    box()
}
par(op)

## Alternative call using ... arguments for pdistr (less efficient)
stopifnot(identical(pit(x, "pnbinom", mu = 5, size = 2, plot = FALSE),
                    pit(x, pdistrs[[2]], plot = FALSE)))
</code></pre>


</div>