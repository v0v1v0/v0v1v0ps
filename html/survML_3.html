<div class="container">

<table style="width: 100%;"><tr>
<td>stackL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate a conditional survival function via local survival stacking</h2>

<h3>Description</h3>

<p>Estimate a conditional survival function via local survival stacking
</p>


<h3>Usage</h3>

<pre><code class="language-R">stackL(
  time,
  event = rep(1, length(time)),
  entry = NULL,
  X,
  newX,
  newtimes,
  direction = "prospective",
  bin_size = NULL,
  time_basis = "continuous",
  learner = "SuperLearner",
  SL_control = list(SL.library = c("SL.mean"), V = 10, method = "method.NNLS", stratifyCV
    = FALSE),
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>entry</code></td>
<td>
<p>Study entry variable, if applicable. Defaults to <code>NULL</code>,
indicating that there is no truncation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values
on which to train the estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study.
This determines whether the data are treated as subject to left truncation and
right censoring (<code>"prospective"</code>) or right truncation alone
(<code>"retrospective"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin_size</code></td>
<td>
<p>Size of bins for the discretization of time.
A value between 0 and 1 indicating the size of observed event time quantiles
on which to grid times (e.g. 0.02 creates a grid of 50 times evenly spaced on the
quantile scaled). If NULL, defaults to every observed event time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_basis</code></td>
<td>
<p>How to treat time for training the binary
classifier. Options are <code>"continuous"</code> and <code>"dummy"</code>, meaning
an indicator variable is included for each time in the time grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>Which binary regression algorithm to use. Currently, only
<code>SuperLearner</code> is supported, but more learners will be added.
See below for algorithm-specific arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process. These parameters are passed directly to the <code>SuperLearner</code> function.
Parameters include <code>SL.library</code> (library of algorithms to include in the
binary classification Super Learner), <code>V</code> (Number of cross validation folds on
which to train the Super Learner classifier, defaults to 10), <code>method</code> (Method for
estimating coefficients for the Super Learner, defaults to <code>"method.NNLS"</code>),
<code>stratifyCV</code> (logical indicating whether to stratify by outcome in <code>SuperLearner</code>'s cross-validation
scheme), and <code>obsWeights</code>
(observation weights, passed directly to prediction algorithms by <code>SuperLearner</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation. Rather than dealing
with right truncation separately than left truncation, it is simpler to
estimate the survival function of <code>tau - time</code>. Defaults to <code>NULL</code>,
in which case the maximum study entry time is chosen as the
reference point.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A named list of class <code>stackL</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>The Super Learner fit for binary classification on the stacked
dataset.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Polley E.C. and van der Laan M.J. (2011).
"Super Learning for Right-Censored Data" in Targeted Learning.
</p>
<p>Craig E., Zhong C., and Tibshirani R. (2021).
"Survival stacking: casting survival analysis as a classification problem."
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This is a small simulation example
set.seed(123)
n &lt;- 500
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackL(time = time,
               event = event,
               entry = entry,
               X = X,
               newX = X,
               newtimes = seq(0, 15, .1),
               direction = "prospective",
               bin_size = 0.1,
               time_basis = "continuous",
               SL_control = list(SL.library = SL.library,
                                 V = 5))

plot(fit$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')

</code></pre>


</div>