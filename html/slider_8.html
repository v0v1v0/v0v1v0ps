<div class="container">

<table style="width: 100%;"><tr>
<td>hop_index2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hop along multiple inputs simultaneously relative to an index</h2>

<h3>Description</h3>

<p><code>hop_index2()</code> and <code>phop_index()</code> represent the combination
of <code>slide2()</code> and <code>pslide()</code> with <code>hop_index()</code>, allowing you to iterate
over multiple vectors at once, relative to an <code>.i</code>-ndex with
boundaries defined by <code>.starts</code> and <code>.stops</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hop_index2(.x, .y, .i, .starts, .stops, .f, ...)

hop_index2_vec(.x, .y, .i, .starts, .stops, .f, ..., .ptype = NULL)

phop_index(.l, .i, .starts, .stops, .f, ...)

phop_index_vec(.l, .i, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x, .y</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.i</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li>
<p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li>
<p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li>
<p> The index cannot have missing values.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.starts, .stops</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>Vectors of boundary values that make up the windows to bucket <code>.i</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
the same type as <code>.i</code>. These boundaries are both <em>inclusive</em>, meaning
that the slice of <code>.x</code> that will be used in each call to <code>.f</code> is where
<code>.i &gt;= start &amp; .i &lt;= stop</code> returns <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p><code style="white-space: pre;">⁠[function / formula]⁠</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ptype</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(0) / NULL]⁠</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.l</code></td>
<td>
<p><code style="white-space: pre;">⁠[list]⁠</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop_index2()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index2(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index2(.x, .y, .starts, .stops)) == list()</code>
</p>
</li>
</ul>
<h4><code>hop_index2_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index2_vec(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop_index2_vec(.x, .y, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index2_vec(.x, .y, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h4><code>phop_index()</code></h4>


<ul>
<li> <p><code>vec_size(phop_index(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(phop_index(.l, .starts, .stops)) == list()</code>
</p>
</li>
</ul>
<h4><code>phop_index_vec()</code></h4>


<ul>
<li> <p><code>vec_size(phop_index_vec(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(phop_index_vec(.l, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(phop_index_vec(.l, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>slide2()</code>, <code>slide_index2()</code>, <code>hop_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Notice that `i` is an irregular index!
x &lt;- 1:5
i &lt;- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# Manually create starts/stops. They don't have to be equally spaced,
# and they don't have to be the same size as `.x` or `.i`.
starts &lt;- as.Date(c("2019-08-15", "2019-08-18"))
stops &lt;- as.Date(c("2019-08-16", "2019-08-23"))

# The output size is equal to the common size of `.starts` and `.stops`
hop_index2(x, i, i, starts, stops, ~data.frame(x = .x, y = .y))

</code></pre>


</div>