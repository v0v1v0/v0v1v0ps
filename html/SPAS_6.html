<div class="container">

<table style="width: 100%;"><tr>
<td>SPAS.fit.model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Stratified-Petersen (SP) model using  TMB.</h2>

<h3>Description</h3>

<p>This function fits a Stratified-Petersen (Plante, 1996) to data and specify which rows/columns of the data
should be pooled. The number of rows after pooling should be &lt;= number of columns after
pooling
.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SPAS.fit.model(
  model.id = "Stratified Petersen Estimator",
  rawdata,
  autopool = FALSE,
  row.pool.in = NULL,
  col.pool.in = NULL,
  row.physical.pool = TRUE,
  theta.pool = FALSE,
  CJSpool = FALSE,
  optMethod = c("nlminb"),
  optMethod.control = list(maxit = 50000),
  svd.cutoff = 1e-04,
  chisq.cutoff = 0.1,
  min.released = 100,
  min.inspected = 50,
  min.recaps = 50,
  min.rows = 1,
  min.cols = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model.id</code></td>
<td>
<p>Character string identifying the name of the model including any pooling..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawdata</code></td>
<td>
<p>An (s+1) x (t+1) of the raw data BEFORE pooling.
The s x t upper left matrix is the number of animals released in row stratum i and recovered in
column stratum j. Row s+1 contains the total number of UNMARKED animals recovered in column stratum j.
Column t+1 contains the number of animals marked in each row stratum but not recovered in any column stratum.
The rawdata[s+1, t+1] is not used and can be set to 0 or NA.
The sum of the entries in each of the first s rows is then the number of animals marked in each row stratum.
The sum of the entries in each of the first t columns is then the number of animals captured (marked and unmarked) in each column stratum.
The row/column names of the matrix may be set to identify the entries in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autopool</code></td>
<td>
<p>Should the automatic pooling algorithms be used.
Give more details here on these rule work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.pool.in, col.pool.in</code></td>
<td>
<p>Vectors (character/numeric) of length s and t respectively. These identify the rows/columns to be pooled before the analysis is done.
The vectors consists of entries where pooling takes place if the entries are the same. For example, if s=4, then 
row.pool.in = c(1,2,3,4) implies no pooling because all entries are distinct; row.pool.in=c("a","a","b","b") implies that the 
first two rows will be pooled and the last two rows will be pooled. It is not necessary that row/columns be continuous to be pooled, but
this is seldom sensible. A careful choice of pooling labels helps to remember what as done, e.g. row.pool.in=c("123","123","123","4") indicates
that the first 3 rows are pooled and the 4th row is not pooled. Character entries ensure that the resulting matrix is sorted properly (e.g. if 
row.pool.in=c(123,123,123,4), then the same pooling is done, but the matrix rows are sorted rather strangely.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.physical.pool</code></td>
<td>
<p>Should physical pooling be done (default) or should logical pooling be done. For example, if there are 3 rows in 
the data matrix and row.pool.in=c(1,1,3), then in physical pooling, the entries in rows 1 and 2 are physically added together to create
2 rows in the data matrix before fitting. Because the data has changed, you cannot compare physical pooling using AIC. In logical pooling,
the data matrix is unchanged, but now parameters p1=p2 but the movement parameters for the rest of the matrix are not forced equal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.pool, CJSpool</code></td>
<td>
<p>NOT YET IMPLEMENTED. DO NOT CHANGE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optMethod</code></td>
<td>
<p>What optimization method is used. Defaults is the nlminb() function..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optMethod.control</code></td>
<td>
<p>Control parameters for optimization method. See the documentation on the different optimization methods for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>svd.cutoff</code></td>
<td>
<p>When finding the variance-covariance matrix, a singular value decomposition is used. This identifies the smallest 
singular value to retain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chisq.cutoff</code></td>
<td>
<p>When finding a goodness of fit statistic using (obs-exp)^2/exp, all cell whose Exp &lt; gof.cutoff are ignored
to try and remove structural zero cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.released</code></td>
<td>
<p>Minimum number of releases in a pooled row</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.inspected</code></td>
<td>
<p>Minimum number of inspections in a pooled column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.recaps</code></td>
<td>
<p>Minimum number of recaptures before any rows can be pooled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.rows, min.cols</code></td>
<td>
<p>Minimum number or rows and columns after pooling</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with many entries. Refer to the vignettes for more details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">conne.data.csv &lt;- textConnection("
9  ,    21  ,     0  ,    0  ,    0  ,    0  ,   171
0  ,   101  ,    22  ,    1  ,    0  ,    0  ,   763
0  ,     0  ,   128  ,   49  ,    0  ,    0  ,   934
0  ,     0  ,     0  ,   48  ,   12  ,    0  ,   434
0  ,     0  ,     0  ,    0  ,    7  ,    0  ,    49
0  ,     0  ,     0  ,    0  ,    0  ,    0  ,     4
351,  2736  ,  3847  , 1818  ,  543  ,   191 ,     0")
conne.data &lt;- as.matrix(read.csv(conne.data.csv, header=FALSE))
close(conne.data.csv)
 
mod1 &lt;- SPAS.fit.model(conne.data, model.id="Pooling rows 1/2, 5/6; pooling columns 5/6",
                      row.pool.in=c("12","12","3","4","56","56"),
                      col.pool.in=c(1,2,3,4,56,56))
mod2 &lt;- SPAS.fit.model(conne.data, model.id="Auto pool",
                      autopool=TRUE)
</code></pre>


</div>