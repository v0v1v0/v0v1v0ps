<div class="container">

<table style="width: 100%;"><tr>
<td>over-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> consistent spatial overlay for points, grids and polygons </h2>

<h3>Description</h3>

<p> consistent spatial overlay for points, grids and
polygons: at the spatial locations of object x retrieves the indexes
or attributes from spatial object y </p>


<h3>Usage</h3>

<pre><code class="language-R">over(x, y, returnList = FALSE, fn = NULL, ...)
x %over% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>geometry (locations) of the queries</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>layer from which the geometries or attributes are queried</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnList</code></td>
<td>
<p> logical; see value </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>(optional) a function; see value </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed on to function <code>fn</code>, except for the special
argument <code>minDimension</code>: minimal dimension for an intersection to be counted;
-1 takes any intersection, and does not order; 0 takes any intersection
but will order according to dimensionality of the intersections (if returnList
is TRUE, 1 (2) selects intersections with dimension 1, meaning
lines (2, meaning areas); see <code>vignette("over")</code> for details </p>
</td>
</tr>
</table>
<h3>Value</h3>

 
<p>If <code>y</code> is only geometry an object of length <code>length(x)</code>.
If <code>returnList</code> is <code>FALSE</code>, a vector with the (first) index
of <code>y</code> for each geometry (point, grid cell centre, polygon
or lines) matching <code>x</code>.  if <code>returnList</code> is TRUE, a list of
length <code>length(x)</code>, with list element <code>i</code> the vector of
all indices of the geometries in <code>y</code> that correspond to the
$i$-th geometry in <code>x</code>.
</p>
<p>If <code>y</code> has attribute data, attribute data are
returned. <code>returnList</code> is FALSE, a <code>data.frame</code> with
number of rows equal to <code>length(x)</code> is returned, if it is
TRUE a list with <code>length(x)</code> elements is returned, with a list
element the <code>data.frame</code> elements of all geometries in <code>y</code>
that correspond to that element of <code>x</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>x = "SpatialPoints", y = "SpatialPolygons"</dt>
<dd>
<p> returns a numeric
vector of length equal to the number of points; the number is the
index (number) of the polygon of <code>y</code> in which a point falls;
NA denotes the point does not fall in a polygon; if a point falls
in multiple polygons, the last polygon is recorded.  </p>
</dd>
<dt>x = "SpatialPointsDataFrame", y = "SpatialPolygons"</dt>
<dd>
<p> equal
to the previous method, except that an argument <code>fn=xxx</code> is
allowed, e.g. <code>fn = mean</code> which will then report a data.frame
with the mean attribute values of the <code>x</code> points falling 
in each polygon (set) of <code>y</code> </p>
</dd>
<dt>x = "SpatialPoints", y = "SpatialPolygonsDataFrame"</dt>
<dd>
<p> returns
a data.frame of the second argument with row entries corresponding
to the first argument </p>
</dd>
<dt>x = "SpatialPolygons", y = "SpatialPoints"</dt>
<dd>
<p> returns
the polygon index of points in <code>y</code>; if <code>x</code> is
a <code>SpatialPolygonsDataFrame</code>, a data.frame with rows from
<code>x</code> corresponding to points in <code>y</code> is returned.</p>
</dd>
<dt>x = "SpatialGridDataFrame", y = "SpatialPoints"</dt>
<dd>
<p> returns
object of class SpatialPointsDataFrame with grid attribute values
x at spatial point locations y; NA for NA grid cells or points
outside grid, and NA values on NA grid cells. </p>
</dd>
<dt>x = "SpatialGrid", y = "SpatialPoints"</dt>
<dd>
<p> returns grid values
x at spatial point locations y; NA for NA grid cells or points
outside the grid </p>
</dd>
<dt>x = "SpatialPixelsDataFrame", y = "SpatialPoints"</dt>
<dd>
<p> returns
grid values x at spatial point locations y; NA for NA grid cells
or points outside the grid </p>
</dd>
<dt>x = "SpatialPixels", y = "SpatialPoints"</dt>
<dd>
<p> returns grid
values x at spatial point locations y; NA for NA grid cells or
points outside the grid </p>
</dd>
<dt>x = "SpatialPoints", y = "SpatialGrid"</dt>
<dd>
<p> xx </p>
</dd>
<dt>x = "SpatialPoints", y = "SpatialGridDataFrame"</dt>
<dd>
<p> xx </p>
</dd>
<dt>x = "SpatialPoints", y = "SpatialPixels"</dt>
<dd>
<p> xx </p>
</dd>
<dt>x = "SpatialPoints", y = "SpatialPixelsDataFrame"</dt>
<dd>
<p> xx </p>
</dd>
<dt>x = "SpatialPolygons", y = "SpatialGridDataFrame"</dt>
<dd>
<p> xx </p>
</dd>
</dl>
<h3>Note</h3>

<p><code>over</code> can be seen as a left outer join in SQL; the
match is a spatial intersection.
</p>
<p>points on a polygon boundary and points corresponding to a
polygon vertex are considered to be inside the polygon.
</p>
<p>These methods assume that pixels and grid cells are never
overlapping; for objects of class <code>SpatialPixels</code> this is
not guaranteed.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>See Also</h3>

<p><code>vignette("over")</code> for examples and figures</p>


</div>