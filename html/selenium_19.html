<div class="container">

<table style="width: 100%;"><tr>
<td>wait_for_server</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Is a selenium server instance running?</h2>

<h3>Description</h3>

<p><code>wait_for_server()</code> takes a server process returned by <code>selenium_server()</code>
and waits for it to respond to status requests. If it doesn't, then an
error is thrown detailing any errors in the response and any error messages
from the server.
</p>
<p><code>selenium_server_available()</code> returns <code>TRUE</code> if a Selenium server is
running on a given port and host. <code>wait_for_selenium_available()</code> waits
for the Selenium server to become available for a given time, throwing an
error if one does not. It is similar to <code>wait_for_server()</code> except that it
works with servers not created by selenium.
</p>
<p><code>get_server_status()</code>, when given a port and host, figures out whether a
Selenium server instance is running, and if so, returns its status. This is
used by <code>selenium_server_available()</code> to figure out if the server is
running.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wait_for_server(
  server,
  port = 4444L,
  host = "localhost",
  max_time = 60,
  error = TRUE,
  verbose = FALSE,
  timeout = 20
)

selenium_server_available(
  port = 4444L,
  host = "localhost",
  verbose = FALSE,
  timeout = 20
)

wait_for_selenium_available(
  max_time = 60,
  port = 4444L,
  host = "localhost",
  error = TRUE,
  verbose = FALSE,
  timeout = 20
)

get_server_status(
  port = 4444L,
  host = "localhost",
  verbose = FALSE,
  timeout = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>server</code></td>
<td>
<p>The process object returned by <code>selenium_server()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>port</code></td>
<td>
<p>The port that the Selenium server is using, so we can
connect to it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>host</code></td>
<td>
<p>The host that the Selenium server is running on. This is
usually 'localhost' (i.e. Your own machine).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_time</code></td>
<td>
<p>The amount of time to wait for the Selenium server to
become available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>Whether to throw an error if the web request fails
after the timeout is exceeded. If not, and we can't connect to a server,
<code>FALSE</code> is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print information about the web request that is
sent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeout</code></td>
<td>
<p>How long to wait for a request to recieve a response before
throwing an error.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>wait_for_server()</code> and <code>wait_for_selenium_available()</code> return <code>TRUE</code> if
the server is ready to be connected to, and throw an error otherwise.
</p>
<p><code>selenium_server_available()</code> returns <code>TRUE</code> if a Selenium server is
running, and <code>FALSE</code> otherwise.
</p>
<p><code>get_server_status()</code> returns a list that can (but may not always) contain
the following fields:
</p>

<ul>
<li> <p><code>ready</code>: Whether the server is ready to be connected to. This should
always be returned by the server.
</p>
</li>
<li> <p><code>message</code>: A message about the status of the server.
</p>
</li>
<li> <p><code>uptime</code>: How long the server has been running.
</p>
</li>
<li> <p><code>nodes</code>: Information about the slots that the server can take.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
server &lt;- selenium_server()

wait_for_server(server)

get_server_status()

selenium_server_available()

wait_for_selenium_available()

## End(Not run)

</code></pre>


</div>