<div class="container">

<table style="width: 100%;"><tr>
<td>densityEqualSplit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Equal-Split Algorithm for Kernel Density on a Network
</h2>

<h3>Description</h3>

<p>Computes a kernel density estimate on a linear network
using the Okabe-Sugihara equal-split algorithms.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> densityEqualSplit(x, sigma = NULL, ...,
                   at = c("pixels", "points"),
                   leaveoneout=TRUE,
                   weights = NULL,
                   kernel = "epanechnikov", continuous = TRUE,
                   epsilon = 1e-06, verbose = TRUE, debug = FALSE, savehistory = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>)
to be smoothed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Smoothing bandwidth (standard deviation of the kernel).
A numeric value in the same units as the spatial coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>X</code>,
for example, <code>bw.scott.iso</code> or <code>bw.lppl</code>.
There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to <code>as.mask</code> determining the
resolution of the result.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>

<p>String (partially matched)
specifying whether to compute the intensity values
at a fine grid of locations on the network
(<code>at="pixels"</code>, the default) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional. Numeric vector of weights associated with the
points of <code>x</code>. Weights may be positive, negative or zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>Character string specifying the smoothing kernel.
See <code>dkernel</code> for possible options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous</code></td>
<td>

<p>Logical value indicating whether to compute the
“equal-split continuous” smoother (<code>continuous=TRUE</code>, the
default) or the “equal-split discontinuous” smoother
(<code>continuous=FALSE</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>Tolerance value. A tail of the kernel with total mass
less than <code>epsilon</code> may be deleted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>

<p>Logical value indicating whether to print debugging information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savehistory</code></td>
<td>

<p>Logical value indicating whether to save the entire history of the
algorithm, for the purposes of evaluating performance.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>x</code>
using a kernel based on path distances in the network.
The result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
</p>
<p>Smoothing is performed using one of the “equal-split” rules described in
Okabe and Sugihara (2012).
</p>

<ul>
<li>
<p>If <code>continuous=TRUE</code> (the default), smoothing is performed
using the “equal-split continuous” rule described in
Section 9.2.3 of Okabe and Sugihara (2012).
The resulting function is continuous on the linear network.
</p>
</li>
<li>
<p>If <code>continuous=FALSE</code>, smoothing is performed
using the “equal-split discontinuous” rule described in
Section 9.2.2 of Okabe and Sugihara (2012). The
resulting function is not continuous.
</p>
</li>
</ul>
<p>Computation is performed by path-tracing
as described in Okabe and Sugihara (2012).
</p>
<p>It is advisable to choose a kernel with bounded support
such as <code>kernel="epanechnikov"</code>.
With a Gaussian kernel, computation time can be long, and
increases exponentially with <code>sigma</code>.
</p>
<p>Faster algorithms are available through <code>density.lpp</code>.
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default),
a pixel image on the linear network (object of class <code>"linim"</code>).
</p>
<p>If <code>at="points"</code>, a numeric vector with one entry for each point
of <code>x</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial analysis along networks</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code>density.lpp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  X &lt;- runiflpp(3, simplenet)
  De &lt;- density(X, 0.2, kernel="epanechnikov", verbose=FALSE)
  Ded &lt;- density(X, 0.2, kernel="epanechnikov", continuous=FALSE, verbose=FALSE)
</code></pre>


</div>