<div class="container">

<table style="width: 100%;"><tr>
<td>som</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to train a Self-Organizing Map
</h2>

<h3>Description</h3>

<p>Produces an object of class "som" which is a Self-Organizing Map fit of the data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">som.init(data, xdim, ydim, init="linear")
som(data, xdim, ydim, init="linear", alpha=NULL, alphaType="inverse",
neigh="gaussian", topol="rect", radius=NULL, rlen=NULL, err.radius=1,
inv.alp.c=NULL)
som.train(data, code, xdim, ydim, alpha=NULL, alphaType="inverse",
neigh="gaussian", topol="rect", radius=NULL, rlen=NULL, err.radius=1, inv.alp.c=NULL)
som.update(obj, alpha = NULL, radius = NULL, rlen = NULL, err.radius =
1, inv.alp.c = NULL)
som.project(obj, newdat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>a ‘som’ object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdat</code></td>
<td>
<p>a new dataset needs to be projected onto the map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>a matrix of initial code vector in the map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data frame or matrix of input data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xdim</code></td>
<td>

<p>an integer specifying the x-dimension of the map.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydim</code></td>
<td>

<p>an integer specifying the y-dimension of the map.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>a character string specifying the initializing method. The following
are permitted:
<code>"sample"</code> uses a radom sample from the data;
<code>"random"</code> uses random draws from N(0,1);
<code>"linear"</code> uses the linear grids upon the first two principle
components directin.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>a vector of initial learning rate parameter for the two training
phases. Decreases linearly to zero during training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaType</code></td>
<td>

<p>a character string specifying learning rate funciton type. Possible
choices are linear function (<code>"linear"</code>) and inverse-time type
function (<code>"inverse"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>

<p>a character string specifying the neighborhood function type. The
following are permitted:
</p>
<p><code>"bubble"</code>
<code>"gaussian"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topol</code></td>
<td>

<p>a character string specifying the topology type when measuring
distance in the map. The following are permitted:
</p>
<p><code>"hexa"</code>
<code>"rect"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>

<p>a vector of initial radius of the training area in som-algorithm for
the two training phases. Decreases linearly to one during training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlen</code></td>
<td>

<p>a vector of running length (number of steps) in the two training phases.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.radius</code></td>
<td>

<p>a numeric value specifying the radius when calculating average
distortion measure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.alp.c</code></td>
<td>

<p>the constant C in the inverse learning rate function:
alpha0 * C / (C + t);
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>‘som.init’ initializes a map and returns the code matrix. ‘som’ does
the two-step som training in a batch fashion and return a ‘som’
object. ‘som.train’ takes data, code, and traing parameters and
perform the requested som training. ‘som.update’ takes a ‘som’ object
and further train it with updated paramters. ‘som.project’ projects
new data onto the map.
</p>
<p>An object of class <code>"som"</code> representing the fit, which is a list
containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the dataset on which som was applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>a character string indicating the initializing method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xdim</code></td>
<td>
<p>an integer specifying the x-dimension of the map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydim</code></td>
<td>
<p>an integer specifying the y-dimension of the map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>a metrix with nrow = xdim*ydim, each row corresponding to
a code vector of a cell in the map. The mapping from cell coordinate
(x, y) to the row index in the code matrix is:
rownumber = x + y * xdim
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>visual</code></td>
<td>
<p>a data frame of three columns, with the same number of
rows as in data: x and y are the coordinate of the corresponding
observation in the map, and qerror is the quantization error
computed as the squared distance (depends topol) between the observation
vector and its coding vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha0</code></td>
<td>
<p>a vector of initial learning rate parameter for the two
training phases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a character string specifying learning rate funciton
type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>a character string specifying the neighborhood function
type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topol</code></td>
<td>
<p>a character string specifying the topology type when measuring
distance in the map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius0</code></td>
<td>
<p>a vector of initial radius of the training area in
som-algorithm for the two training phases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlen</code></td>
<td>
<p>a vector of running length in the two training phases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qerror</code></td>
<td>
<p>a numeric value of average distortion measure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code.sum</code></td>
<td>
<p>a dataframe summaries the number of observations in
each map cell.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jun Yan &lt;jyan@stat.uiowa.edu&gt;
</p>


<h3>References</h3>

<p>Kohonen, Hynninen, Kangas, and Laaksonen (1995), SOM-PAK, the
Self-Organizing Map Program Package (version 3.1).
<a href="http://www.cis.hut.fi/research/papers/som_tr96.ps.Z">http://www.cis.hut.fi/research/papers/som_tr96.ps.Z</a></p>


<h3>Examples</h3>

<pre><code class="language-R">data(yeast)
yeast &lt;- yeast[, -c(1, 11)]
yeast.f &lt;- filtering(yeast)
yeast.f.n &lt;- normalize(yeast.f)
foo &lt;- som(yeast.f.n, xdim=5, ydim=6)
foo &lt;- som(yeast.f.n, xdim=5, ydim=6, topol="hexa", neigh="gaussian")
plot(foo)
</code></pre>


</div>