<div class="container">

<table style="width: 100%;"><tr>
<td>wilma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Supervised Clustering of Predictor Variables</h2>

<h3>Description</h3>

<p>Performs supervised clustering of predictor variables for
large (microarray gene expression) datasets. Works in a greedy forward
strategy and optimizes a combination of the Wilcoxon and Margin
statistics for finding the clusters.</p>


<h3>Usage</h3>

<pre><code class="language-R">wilma(x, y, noc, genes = NULL, flip = TRUE, once.per.clust = FALSE, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric matrix of explanatory variables (<code class="reqn">p</code> variables in
columns, <code class="reqn">n</code> cases in rows). For example, these can be
microarray gene expression data which should be clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noc</code></td>
<td>
<p>Integer, the number of clusters that should be searched for
on the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genes</code></td>
<td>
<p>Defaults to <code>NULL</code>. An optional list (of length
<code>noc</code>) of vectors containing the indices (column numbers) of
the previously known initial clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code>. Is indicating whether
the clustering should be done with or without sign-flipping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>once.per.clust</code></td>
<td>
<p>Logical, defaults to <code>FALSE</code>. Is indicating
if each variable (gene) should only be allowed to enter into each
cluster once; equivalently, the cluster mean profile has only
weights <code class="reqn">\pm 1</code> for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Integer &gt;= 0; when positive, the output of the internal
loops is provided; <code>trace &gt;= 2</code> provides output even from the
internal C routines.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>wilma</code> returns an object of class "wilma". The functions
<code>print</code> and <code>summary</code> are used to obtain an overview of the
clusters that have been found. The function <code>plot</code> yields a
two-dimensional projection into the space of the first two clusters
that <code>wilma</code> found. The generic function <code>fitted</code> returns
the fitted values, these are the cluster representatives. Finally,
<code>predict</code> is used for classifying test data on the basis of
Wilma's cluster with either the nearest-neighbor-rule, diagonal linear
discriminant analysis, logistic regression or aggregated trees.
</p>
<p>An object of class "wilma" is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>clist</code></td>
<td>
<p>A list of length <code>noc</code>, containing integer vectors
consisting of the indices (column numbers) of the variables (genes)
that have been clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>Numerical vector of length <code>noc</code>, showing the number
of forward/backward cycles in the fitting process of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code> containing the class labels
of the individuals. These labels have to be coded by 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.means</code></td>
<td>
<p>A list of length <code>noc</code>, containing numerical
matrices consisting of the cluster representatives after insertion
of each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noc</code></td>
<td>
<p>Integer, the number of clusters that has been searched for
on the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signs</code></td>
<td>
<p>Numerical vector of length <code class="reqn">p</code>, saying whether the
<code class="reqn">i</code>th variable (gene) should be sign-flipped (-1) or not (+1).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marcel Dettling, <a href="mailto:dettling@stat.math.ethz.ch">dettling@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Marcel Dettling (2002)
<em>Supervised Clustering of Genes</em>, see
<a href="https://stat.ethz.ch/~dettling/supercluster.html">https://stat.ethz.ch/~dettling/supercluster.html</a>
</p>
<p>Marcel Dettling and Peter Bühlmann (2002).
Supervised Clustering of Genes.
<em>Genome Biology</em>, <b>3</b>(12): research0069.1-0069.15,
doi: <a href="https://doi.org/10.1186/gb-2002-3-12-research0069">10.1186/gb-2002-3-12-research0069</a> .
</p>
<p>Marcel Dettling and Peter Bühlmann (2004).
Finding Predictive Gene Groups from Microarray Data.
<em>Journal of Multivariate Analysis</em> <b>90</b>, 106–131,
doi: <a href="https://doi.org/10.1016/j.jmva.2004.02.012">10.1016/j.jmva.2004.02.012</a> .
</p>


<h3>See Also</h3>

<p><code>score</code>, <code>margin</code>, and for a newer
methodology, <code>pelora</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Working with a "real" microarray dataset
data(leukemia, package="supclust")

## Generating random test data: 3 observations and 250 variables (genes)
set.seed(724)
xN &lt;- matrix(rnorm(750), nrow = 3, ncol = 250)

## Fitting Wilma
fit  &lt;- wilma(leukemia.x, leukemia.y, noc = 3, trace = 1)

## Working with the output
fit
summary(fit)
plot(fit)
fitted(fit)

## Fitted values and class predictions for the training data
predict(fit, type = "cla")
predict(fit, type = "fitt")

## Predicting fitted values and class labels for test data
predict(fit, newdata = xN)
predict(fit, newdata = xN, type = "cla", classifier = "nnr", noc = c(1,2,3))
predict(fit, newdata = xN, type = "cla", classifier = "dlda", noc = c(1,3))
predict(fit, newdata = xN, type = "cla", classifier = "logreg")
predict(fit, newdata = xN, type = "cla", classifier = "aggtrees")
</code></pre>


</div>