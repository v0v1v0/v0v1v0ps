<div class="container">

<table style="width: 100%;"><tr>
<td>spam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Matrix Class</h2>

<h3>Description</h3>

<p>This group of functions evaluates and coerces changes in class structure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spam(x, nrow = 1, ncol = 1, eps = getOption("spam.eps"))


as.spam(x, eps = getOption("spam.eps"))


is.spam(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>is a matrix (of either dense or sparse form), a list, vector
object or a distance object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow</code></td>
<td>
<p>number of rows of matrix </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol</code></td>
<td>
<p>number of columns of matrix </p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A tolerance parameter:  elements of <code>x</code> such that
<code>abs(x) &lt; eps</code> set to zero. Defaults to <code>eps =
    getOption("spam.eps")</code> </p>
</td>
</tr></table>
<h3>Details</h3>

<p>The functions <code>spam</code> and <code>as.spam</code> act like <code>matrix</code>
and <code>as.matrix</code>
to coerce an object to a sparse matrix object of class <code>spam</code>.
</p>
<p>If <code>x</code> is a list, it should contain either two or three elements.
In case of the former, the list should contain a <code>n</code> by two
matrix of indicies (called <code>ind</code>) and the values.
In case of the latter, the list should contain three vectors
containing the row, column indices (called <code>i</code> and
<code>j</code>) and the values. In both cases partial matching is done.
In case there are several triplets with the same <code>i</code>, <code>j</code>,
the values are added.
</p>
<p><code>eps</code> should be at least as large as <code>.Machine$double.eps</code>.
</p>
<p>If <code>getOption("spam.force64")</code> is <code>TRUE</code>, a 64-bit
spam matrix is returned in any case. If <code>FALSE</code>, a 32-bit
matrix is returned when possible.
</p>


<h3>Value</h3>

<p>A valid <code>spam</code> object.<br><code>is.spam</code> returns <code>TRUE</code> if <code>x</code> is a <code>spam</code> object.</p>


<h3>Note</h3>

<p>The zero matrix has the element zero stored in (1,1).<br></p>
<p>The functions do not test the presence of <code>NA/NaN/Inf</code>. Virtually
all call a Fortran routine with the <code>NAOK=NAOK</code>
argument, which defaults to <code>FALSE</code> resulting in an error.
Hence, the <code>NaN</code> do not always properly propagate through (i.e.
<code>spam</code> is not IEEE-754 compliant).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Reinhard Furrer, Stephan R. Sain (2010).
"spam: A Sparse Matrix R Package with Emphasis on MCMC
Methods for Gaussian Markov Random Fields.",
<em>Journal of Statistical Software</em>, 36(10), 1-25,
<a href="https://doi.org/10.18637/jss.v036.i10">doi:10.18637/jss.v036.i10</a>.
</p>


<h3>See Also</h3>

<p><code>SPAM</code> for a general overview of the package;
<code>spam_random</code> to create matrices with a random sparsity pattern;
<code>cleanup</code> to purge a sparse matrix;
<code>spam.options</code> for details about the <code>safemode</code> flag;
<code>read.MM</code> and <code>foreign</code> to create <code>spam</code>
matrices from MatrixMarket
files and from certain <span class="pkg">Matrix</span> or <span class="pkg">SparseM</span> formats.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># old message, do not loop, when you create a large sparse matrix
set.seed(13)
nz &lt;- 128
ln &lt;- nz^2
smat &lt;- spam(0,ln,ln)
is &lt;- sample(ln,nz)
js &lt;- sample(ln,nz)
## IGNORE_RDIFF_BEGIN
system.time(for (i in 1:nz) smat[is[i], js[i]] &lt;- i)
system.time(smat[cbind(is,js)] &lt;- 1:nz)
## IGNORE_RDIFF_END

getClass("spam")


options(spam.NAOK=TRUE)
as.spam(c(1, NA))
</code></pre>


</div>