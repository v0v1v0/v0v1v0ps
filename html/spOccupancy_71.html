<div class="container">

<table style="width: 100%;"><tr>
<td>predict.svcPGOcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for prediction at new locations for single-species spatially-varying coefficient occupancy models</h2>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new 
locations given an object of class 'svcPGOcc'. Prediction is possible for both the 
latent occupancy state as well as detection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
## S3 method for class 'svcPGOcc'
predict(object, X.0, coords.0, weights.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ignore.RE = FALSE, type = 'occupancy', grid.index.0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>svcPGOcc</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.0</code></td>
<td>
<p>the design matrix of covariates at the prediction locations. This should include a column of 1s for the intercept if an intercept is included in the model. If random effects are included in the occupancy (or detection if <code>type = 'detection'</code>) portion of the model, the levels of the random effects at the new locations should be included as a column in the design matrix. The ordering of the levels should match the ordering used to fit the data in <code>svcPGOcc</code>. Columns should correspond to the order of how covariates were specified in the corresponding formula argument of <code>svcPGOcc</code>. Column names of the random effects must match the name of the random effects, if specified in the corresponding formula argument of <code>svcPGOcc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.0</code></td>
<td>
<p>not used for objects of class <code>svcTPGOcc</code>. Used when 
calling other functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.RE</code></td>
<td>
<p>a logical value indicating whether to include unstructured random 
effects for prediction. If TRUE, unstructured random effects will be ignored and 
prediction will only use the fixed effects and the spatial random effects. If FALSE, 
random effects will be included in the prediction for both observed and unobserved 
levels of the unstructured random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a quoted keyword indicating what type of prediction to produce. Valid keywords are 'occupancy' to predict latent occupancy probability and latent occupancy values (this is the default), or 'detection' to predict detection probability given new values of detection covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.index.0</code></td>
<td>
<p>an indexing vector used to specify how each row in <code>X.0</code> corresponds to the coordinates specified in <code>coords.0</code>. Only relevant if the SVCs were estimated at a higher spatial resolution (e.g., grid cells) than point locations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list object of class <code>predict.svcPGOcc</code>. When <code>type = 'occupancy'</code>, the list consists of:  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence probability values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples 
for the latent occurrence values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.0.samples</code></td>
<td>
<p>a three-dimensional array of posterior predictive samples
for the spatial random effects, with dimensions corresponding to MCMC iteration, 
coefficient, and site.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td>
</tr>
</table>
<p>When <code>type = 'detection'</code>, the list consists of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the 
detection probability values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Note</h3>

<p>When <code>ignore.RE = FALSE</code>, both sampled levels and non-sampled levels of random effects are supported for prediction. For sampled levels, the posterior distribution for the random intercept corresponding to that level of the random effect will be used in the prediction. For non-sampled levels, random values are drawn from a normal distribution using the posterior samples of the random effect variance, which results in fully propagated uncertainty in predictions with models that incorporate random effects.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br>
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(400)
# Simulate Data -----------------------------------------------------------
J.x &lt;- 8
J.y &lt;- 8
J &lt;- J.x * J.y
n.rep &lt;- sample(2:4, J, replace = TRUE)
beta &lt;- c(0.5, 2)
p.occ &lt;- length(beta)
alpha &lt;- c(0, 1)
p.det &lt;- length(alpha)
phi &lt;- c(3 / .6, 3 / .8)
sigma.sq &lt;- c(0.5, 0.9)
svc.cols &lt;- c(1, 2)
dat &lt;- simOcc(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha, 
              sigma.sq = sigma.sq, phi = phi, sp = TRUE, cov.model = 'exponential', 
              svc.cols = svc.cols)
# Split into fitting and prediction data set
pred.indx &lt;- sample(1:J, round(J * .5), replace = FALSE)
y &lt;- dat$y[-pred.indx, ]
# Occupancy covariates
X &lt;- dat$X[-pred.indx, ]
# Prediction covariates
X.0 &lt;- dat$X[pred.indx, ]
# Detection covariates
X.p &lt;- dat$X.p[-pred.indx, , ]
coords &lt;- as.matrix(dat$coords[-pred.indx, ])
coords.0 &lt;- as.matrix(dat$coords[pred.indx, ])
psi.0 &lt;- dat$psi[pred.indx]
w.0 &lt;- dat$w[pred.indx, , drop = FALSE]

# Package all data into a list
occ.covs &lt;- X[, -1, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list(det.cov.1 = X.p[, , 2])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs, 
                  det.covs = det.covs, 
                  coords = coords)

# Number of batches
n.batch &lt;- 10
# Batch length
batch.length &lt;- 25
n.iter &lt;- n.batch * batch.length
# Priors 
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = 0, var = 2.72),
                   sigma.sq.ig = list(a = 2, b = 0.5), 
                   phi.unif = list(a = 3/1, b = 3/.1)) 
# Initial values
inits.list &lt;- list(alpha = 0, beta = 0,
                   phi = 3 / .5, 
                   sigma.sq = 0.5,
                   z = apply(y, 1, max, na.rm = TRUE))
# Tuning
tuning.list &lt;- list(phi = 1) 

out &lt;- svcPGOcc(occ.formula = ~ occ.cov, 
                det.formula = ~ det.cov.1, 
                data = data.list, 
                inits = inits.list, 
                n.batch = n.batch, 
                batch.length = batch.length, 
                accept.rate = 0.43, 
                priors = prior.list,
                cov.model = 'exponential', 
                tuning = tuning.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                NNGP = TRUE, 
                svc.cols = c(1, 2),
                n.neighbors = 15, 
                search.type = 'cb', 
                n.report = 10, 
                n.burn = 50, 
                n.thin = 1)

summary(out) 

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>


</div>