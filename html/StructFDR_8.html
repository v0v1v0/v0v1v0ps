<div class="container">

<table style="width: 100%;"><tr>
<td>TreeFDR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

False Discovery Rate (FDR) Control Integrating Prior Tree Structure for Microbiome Data
</h2>

<h3>Description</h3>


<p>The procedure is based on an empirical Bayes hierarchical model, where a structure-based prior distribution is designed to utilize the phylogenetic tree. A moderated
statistic based on posterior mean is used for permutation-based FDR control. By borrowing information from neighboring bacterial species, it is able to 
improve the statistical power of detecting associated  bacterial species while controlling the FDR at desired levels. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">TreeFDR(X, Y, tree, test.func, perm.func, eff.sign = TRUE, B = 20, q.cutoff = 0.5,
       alpha = 1, adaptive = c('Fisher', 'Overlap'), alt.FDR = c('BH', 'Permutation'), 
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>


<p>a data matrix, rows are the features and columns are the samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>


<p>a vector of the phenotypic values, where association tests are being assessed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>


<p>an object of "phylo" class 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.func</code></td>
<td>


<p>a function that performs the actual tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>p.value</code> and <code>e.sign</code>, which are vectors of p-values 
and signs of the effects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm.func</code></td>
<td>


<p>a function that performs the permutation tests. It takes <code>X</code>, <code>Y</code> and ... as the inputs, and returns a list with two slots <code>X</code> and <code>Y</code>, which contain the permuted data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eff.sign</code></td>
<td>


<p>a logical value indicating whether the direction of the effects should be considered. If it is true (default), negative and positive effects provide conflicting 
information. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>


<p>the number of permutations.  The default is 20. If computation time is not a big concern, <code>B=100</code> is suggested to achieve excellent reproducibility between different runs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.cutoff</code></td>
<td>


<p>the quantile cutoff to determine the feature sets to estimate the number of false positives under the null. This cutoff is to protect the signal part of the distributions. The default is 0.5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>


<p>the exponent applied to the distance matrix. Large values have more smoothing effects for closely related species. The default is 1. If the underlying structure assumption is considered to be very strong, robustness
can be improved by decreasing the value to 0.5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>


<p>the proposed procedure is most powerful when the signal is clustered on the tree.  When this assumption is seriously violated, it loses power.  We provide two heuristic adaptive approaches
to compensate the power loss in such situations. 'Fisher' approach compares the number of hits by our method to the alternative FDR approach at an FDR of 20% and uses the alternative FDR approach 
if the number of hits is significantly less based on Fisher's exact test; 'Overlap' method selects the alternative approach when it fails to identify half of the hits from the alternative approach 
at an FDR of 20%. The default is 'Fisher'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt.FDR</code></td>
<td>


<p>the alternative FDR control used when the proposed approach is powerless. The default is 'BH' procedure and another option is the permutation-based FDR control ('Permutation')
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>


<p>further arguments such as covariates to be passed to <code>test.func</code>
</p>
</td>
</tr>
</table>
<h3>Value</h3>






<table>
<tr style="vertical-align: top;">
<td><code>p.adj </code></td>
<td>
<p>TreeFDR adjusted p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.unadj </code></td>
<td>
<p>raw p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.adj </code></td>
<td>
<p>moderated z-values. The scale may be different from the raw z-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.unadj </code></td>
<td>
<p>raw z-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k, rho </code></td>
<td>
<p>the estimates of the hyperparameters.  The values indicate the informativeness of the prior structure.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>


<p>Jun Chen
</p>


<h3>References</h3>


<p>Xiao, J., Cao, H., Chen, J. (2017). False discovery rate control incorporating phylogenetic tree increases detection power in microbiome-wide multiple testing. Bioinformatics, 33(18), 2873-2881.
</p>


<h3>See Also</h3>


<p><code>StructFDR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(ape) 
require(nlme)
require(cluster)
require(StructFDR)

# Generate a caelescence tree and partition into 10 clusters
set.seed(1234)
n &lt;- 20
p &lt;- 200
tree &lt;- rcoal(p)
D &lt;- cophenetic(tree)
clustering &lt;- pam(D, k=10)$clustering

# Simulate case-control data, assuming cluster 2 is differential  
X.control &lt;- matrix(rnorm(n*p), p, n)
X.case &lt;- matrix(rnorm(n*p), p, n)
eff.size &lt;- rnorm(sum(clustering == 2), 0.5, 0.2)     
X.case[clustering == 2, ] &lt;- X.case[clustering == 2, ] + eff.size
X &lt;- cbind(X.control, X.case)
Y &lt;- gl(2, n) 

# Define testing and permutation function
test.func &lt;- function (X, Y) {
	obj &lt;- apply(X, 1, function(x) {
				ttest.obj &lt;- t.test(x ~ Y)
				c(ttest.obj$p.value, sign(ttest.obj$statistic))
			})
    return(list(p.value=obj[1, ], e.sign=obj[2, ]))
}

perm.func &lt;- function (X, Y) {
	return(list(X=X, Y=sample(Y)))
}

# Call TreeFDR
tree.fdr.obj &lt;- TreeFDR(X, Y, tree, test.func, perm.func)

# Compare TreeFDR and BH
tree.fdr.obj$p.adj
tree.fdr.obj$p.adj[clustering == 2]
BH.p.adj &lt;- p.adjust(tree.fdr.obj$p.unadj, 'fdr')
BH.p.adj[clustering == 2]

# Adjusted statistics vs clustering
par(mfrow=c(1, 2))
plot(clustering, tree.fdr.obj$z.unadj)
plot(clustering, tree.fdr.obj$z.adj)
</code></pre>


</div>