<div class="container">

<table style="width: 100%;"><tr>
<td>standardized-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class <code>standardized</code> containing regression variables in a standardized space.</h2>

<h3>Description</h3>

<p>The <code>standardize</code> function returns a list of class
<code>standardized</code>, which has a <code>print</code> method,
and which can additionally be used to place new data into the same
standardized space as the data passed in the call to <code>standardize</code>
using the <code>predict</code> function.
The <code>standardized</code> list contains the following elements.
</p>


<h3>Details</h3>


<dl>
<dt>call</dt>
<dd>
<p>The call to <code>standardize</code> which created the
object.</p>
</dd>
<dt>scale</dt>
<dd>
<p>The <code>scale</code> argument to <code>standardize</code>.</p>
</dd>
<dt>formula</dt>
<dd>
<p>The regression formula in standardized space (with new
names) which can be used along with the <code>data</code> element to fit
regressions.  It has an attribute <code>standardized.scale</code> which is the
same as the <code>scale</code> element of the object (this allows users and
package developers to write regression-fitting functions which can tell
if the input is from a <code>standardized</code> object).</p>
</dd>
<dt>family</dt>
<dd>
<p>The regression family.</p>
</dd>
<dt>data</dt>
<dd>
<p>A data frame containing the regression variables in a
standardized space (renamed to have valid variable names corresponding
to those in the <code>formula</code> element).</p>
</dd>
<dt>offset</dt>
<dd>
<p>The offset passed through the <code>offset</code> argument to
<code>standardize</code> (scaled if <code>family = gaussian</code>), or
<code>NULL</code> if the <code>offset</code> argument was not used.</p>
</dd>
<dt>pred</dt>
<dd>
<p>A list containing unevaluated calls which allow the
<code>predict</code> method to work.</p>
</dd>
<dt>variables</dt>
<dd>
<p>A data frame with the name of the original variable,
the corresponding name in the standardized data frame and formula,
and the class of the variable in the standardized data frame.</p>
</dd>
<dt>contrasts</dt>
<dd>
<p>A named list of contrasts for all factors included as
predictors, or <code>NULL</code> if no predictors are factors.</p>
</dd>
<dt>groups</dt>
<dd>
<p>A named list of levels for random effects grouping factors,
or <code>NULL</code> if there are no random effects.</p>
</dd>
</dl>
<p>In the <code>variables</code> data frame, the <code>Variable</code> column contains the
name of the variable in the original formula passed to <code>standardize</code>.
The <code>Standardized Name</code> column contains the name of the variable in the standardized
formula and data frame. The original variable name is altered such that the
original name is still recoverable but is also a valid variable name for
regressions run using the <code>formula</code> and <code>data</code> elements of the
<code>standardized</code> object.  For example, <code>exp(x)</code> would become
<code>exp_x</code> and <code>log(x + 1)</code> would become <code>log_x.p.1</code>.  If
the indicator function is used, this can lead to a long and possibly
difficult to interpret name; e.g. <code>I(x1 &gt; 0 &amp; x2 &lt; 0)</code> would become
<code>I_x1.g.0.a.x2.l.0</code>. In such cases, it is better to create the variable
explicitly in the data frame and give it a meaningful name; in this case,
something like <code>mydata$x1Pos_x2Neg &lt;- mydata$x1 &gt; 0 &amp; mydata$x2 &lt; 0</code>,
and then use <code>x1Pos_x2Neg</code> in the call to <code>standardize</code>.
The <code>Class</code> column in the <code>variables</code> data frame takes the
following values (except for non-gaussian responses, which are left
unaltered, and so may have a different class; the class for the response is
always preceded by <code>response.</code>).
</p>

<dl>
<dt>numeric</dt>
<dd>
<p>A numeric vector.</p>
</dd>
<dt>poly</dt>
<dd>
<p>A numeric matrix resulting from a call to
<code>poly</code>.</p>
</dd>
<dt>scaledby</dt>
<dd>
<p>A numeric vector resulting from a call to
<code>scale_by</code>.</p>
</dd>
<dt>scaledby.poly</dt>
<dd>
<p>A numeric matrix resulting from a call to
<code>poly</code> nested within a call to
<code>scale_by</code>.</p>
</dd>
<dt>factor</dt>
<dd>
<p>An unordered factor.</p>
</dd>
<dt>ordered</dt>
<dd>
<p>An ordered factor.</p>
</dd>
<dt>group</dt>
<dd>
<p>A random effects grouping factor.</p>
</dd>
<dt>offset</dt>
<dd>
<p>If the offset function was used within the formula passed to
<code>standardize</code>, then the variable is numeric and labeled as
<code>offset</code>.  The <code>formula</code> element of the <code>standardize</code>
object contains offset calls to ensure regression fitting functions use
them properly.  If the <code>offset</code> argument was used in the call to
<code>standardize</code> (rather than putting offset calls in the
formula), then the offset is not in the <code>variables</code> data frame (it
is in the <code>offset</code> element of the <code>standardized</code> object).</p>
</dd>
</dl>
<p>The <code>standardized</code> object has a printing method which displays the call,
formula, and variable frame along with an explanation of the
standardization.  The <code>is.standardized</code> function returns
<code>TRUE</code> if an object is the result of a call to <code>standardize</code>
and <code>FALSE</code> otherwise.  The <code>predict</code>
method places new data into the same standardized space as the data
passed to the original <code>standardize</code> call.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


</div>