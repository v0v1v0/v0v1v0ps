<div class="container">

<table style="width: 100%;"><tr>
<td>Coachmark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coachmark</h2>

<h3>Description</h3>

<p>Coach marks (<code>Coachmark</code>) are used to draw a person’s attention to parts of the UI and increase engagement with those elements. A teaching bubble appears on hover or selection of the coach mark.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/Coachmark">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Coachmark(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr></table>
<h3>Details</h3>


<ul>
<li> <p><b> ariaAlertText </b> <code>string</code> <br> Text to announce to screen reader / narrator when Coachmark is displayed
</p>
</li>
<li> <p><b> ariaDescribedBy </b> <code>string</code> <br> Defines the element id referencing the element containing the description for the Coachmark.
</p>
</li>
<li> <p><b> ariaDescribedByText </b> <code>string</code> <br> Defines the text content for the ariaDescribedBy element
</p>
</li>
<li> <p><b> ariaLabelledBy </b> <code>string</code> <br> Defines the element id referencing the element containing label text for Coachmark.
</p>
</li>
<li> <p><b> ariaLabelledByText </b> <code>string</code> <br> Defines the text content for the ariaLabelledBy element
</p>
</li>
<li> <p><b> beaconColorOne </b> <code>string</code> <br> Beacon color one.
</p>
</li>
<li> <p><b> beaconColorTwo </b> <code>string</code> <br> Beacon color two.
</p>
</li>
<li> <p><b> beakHeight </b> <code>number</code> <br> The height of the Beak component.
</p>
</li>
<li> <p><b> beakWidth </b> <code>number</code> <br> The width of the Beak component.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> If provided, additional class name to provide on the root element.
</p>
</li>
<li> <p><b> collapsed </b> <code>boolean</code> <br> The starting collapsed state for the Coachmark. Use <code>isCollapsed</code> instead.
</p>
</li>
<li> <p><b> color </b> <code>string</code> <br> Color of the Coachmark/TeachingBubble.
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;ICoachmark&gt;⁠</code> <br> Optional callback to access the ICoachmark interface. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> delayBeforeCoachmarkAnimation </b> <code>number</code> <br> Delay in milliseconds before Coachmark animation appears.
</p>
</li>
<li> <p><b> delayBeforeMouseOpen </b> <code>number</code> <br> Delay before allowing mouse movements to open the Coachmark.
</p>
</li>
<li> <p><b> height </b> <code>number</code> <br> The height of the Coachmark.
</p>
</li>
<li> <p><b> isCollapsed </b> <code>boolean</code> <br> The starting collapsed state for the Coachmark.
</p>
</li>
<li> <p><b> isPositionForced </b> <code>boolean</code> <br> Whether or not to force the Coachmark/TeachingBubble content to fit within the window bounds.
</p>
</li>
<li> <p><b> mouseProximityOffset </b> <code>number</code> <br> The distance in pixels the mouse is located before opening up the Coachmark.
</p>
</li>
<li> <p><b> onAnimationOpenEnd </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Callback when the opening animation completes.
</p>
</li>
<li> <p><b> onAnimationOpenStart </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Callback when the opening animation begins.
</p>
</li>
<li> <p><b> onDismiss </b> <code style="white-space: pre;">⁠(ev?: any) =&gt; void⁠</code> <br> Callback when the Coachmark tries to close.
</p>
</li>
<li> <p><b> onMouseMove </b> <code style="white-space: pre;">⁠(e: MouseEvent) =&gt; void⁠</code> <br> Callback to run when the mouse moves.
</p>
</li>
<li> <p><b> persistentBeak </b> <code>boolean</code> <br> If true then the Coachmark beak (arrow pointing towards target) will always be visible as long as Coachmark is visible
</p>
</li>
<li> <p><b> positioningContainerProps </b> <code>IPositioningContainerProps</code> <br> Props to pass to the PositioningContainer component. Specify the <code>directionalHint</code> to indicate on which edge the Coachmark/TeachingBubble should be positioned.
</p>
</li>
<li> <p><b> preventDismissOnLostFocus </b> <code>boolean</code> <br> If true then the Coachmark will not dismiss when it loses focus
</p>
</li>
<li> <p><b> preventFocusOnMount </b> <code>boolean</code> <br> If true then focus will not be set to the Coachmark when it mounts. Useful in cases where focus on coachmark is causing other components in page to dismiss upon losing focus.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;ICoachmarkStyleProps, ICoachmarkStyles&gt;⁠</code> <br> Call to provide customized styling that will layer on top of the variant rules
</p>
</li>
<li> <p><b> target </b> <code>HTMLElement | string | null</code> <br> The target that the Coachmark should try to position itself based on.
</p>
</li>
<li> <p><b> teachingBubbleRef </b> <code>ITeachingBubble</code> <br> Ref for TeachingBubble
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme provided by higher order component.
</p>
</li>
<li> <p><b> width </b> <code>number</code> <br> The width of the Coachmark.
</p>
</li>
<li> <p><b> ariaDescribedBy </b> <code>string</code> <br> Defines the element id referencing the element containing the description for the positioningContainer.
</p>
</li>
<li> <p><b> ariaLabel </b> <code>string</code> <br> Accessible label text for positioningContainer.
</p>
</li>
<li> <p><b> ariaLabelledBy </b> <code>string</code> <br> Defines the element id referencing the element containing label text for positioningContainer.
</p>
</li>
<li> <p><b> backgroundColor </b> <code>string</code> <br> The background color of the positioningContainer in hex format ie. #ffffff.
</p>
</li>
<li> <p><b> bounds </b> <code>IRectangle</code> <br> The bounding rectangle for which the contextual menu can appear in.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> CSS class to apply to the positioningContainer.
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;IPositioningContainer&gt;⁠</code> <br> All props for your component are to be defined here.
</p>
</li>
<li> <p><b> coverTarget </b> <code>boolean</code> <br> If true the position returned will have the menu element cover the target. If false then it will position next to the target;
</p>
</li>
<li> <p><b> directionalHint </b> <code>DirectionalHint</code> <br> How the element should be positioned
</p>
</li>
<li> <p><b> directionalHintFixed </b> <code>boolean</code> <br> If true the position will not change sides in an attempt to fit the positioningContainer within bounds. It will still attempt to align it to whatever bounds are given.
</p>
</li>
<li> <p><b> directionalHintForRTL </b> <code>DirectionalHint</code> <br> How the element should be positioned in RTL layouts. If not specified, a mirror of <code>directionalHint</code> will be used instead
</p>
</li>
<li> <p><b> doNotLayer </b> <code>boolean</code> <br> If true do not render on a new layer. If false render on a new layer.
</p>
</li>
<li> <p><b> finalHeight </b> <code>number</code> <br> Specify the final height of the content. To be used when expanding the content dynamically so that positioningContainer can adjust its position.
</p>
</li>
<li> <p><b> minPagePadding </b> <code>number</code> <br> The minimum distance the positioningContainer will be away from the edge of the screen.
</p>
</li>
<li> <p><b> offsetFromTarget </b> <code>number</code> <br> The gap between the positioningContainer and the target
</p>
</li>
<li> <p><b> onDismiss </b> <code style="white-space: pre;">⁠(ev?: any) =&gt; void⁠</code> <br> Callback when the positioningContainer tries to close.
</p>
</li>
<li> <p><b> onLayerMounted </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Optional callback when the layer content has mounted.
</p>
</li>
<li> <p><b> onPositioned </b> <code style="white-space: pre;">⁠(positions?: IPositionedData) =&gt; void⁠</code> <br> Optional callback that is called once the positioningContainer has been correctly positioned.
</p>
</li>
<li> <p><b> positioningContainerMaxHeight </b> <code>number</code> <br> Set max height of positioningContainer When not set the positioningContainer will expand with contents up to the bottom of the screen
</p>
</li>
<li> <p><b> positioningContainerWidth </b> <code>number</code> <br> Custom width for positioningContainer including borders. If value is 0, no width is applied.
</p>
</li>
<li> <p><b> preventDismissOnScroll </b> <code>boolean</code> <br> If true then the onClose will not not dismiss on scroll
</p>
</li>
<li> <p><b> role </b> <code>string</code> <br> Aria role assigned to the positioningContainer (Eg. dialog, alertdialog).
</p>
</li>
<li> <p><b> setInitialFocus </b> <code>boolean</code> <br> If true then the positioningContainer will attempt to focus the first focusable element that it contains. If it doesn't find an element, no focus will be set and the method will return false. This means that it's the contents responsibility to either set focus or have focusable items.
</p>
</li>
<li> <p><b> target </b> <code>HTMLElement | string | MouseEvent | Point | null</code> <br> The target that the positioningContainer should try to position itself based on. It can be either an HTMLElement a querySelector string of a valid HTMLElement or a MouseEvent. If MouseEvent is given then the origin point of the event will be used.
</p>
</li>
<li> <p><b> targetPoint </b> <code>Point</code> <br> Point used to position the positioningContainer. Deprecated, use <code>target</code> instead.
</p>
</li>
<li> <p><b> useTargetPoint </b> <code>boolean</code> <br> If true use a point rather than rectangle to position the positioningContainer. For example it can be used to position based on a click.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
</p>


<h3>Best practices</h3>



<h4>Layout</h4>


<ul>
<li>
<p> Only one coach mark and teaching bubble combo should be displayed at a time.
</p>
</li>
<li>
<p> Coach marks can be standalone or sequential. Sequential coach marks should be used sparingly to walk through complex multistep interactions. It’s recommended that a sequence of coach marks doesn’t exceed three steps.
</p>
</li>
<li>
<p> Coach marks are designed to only hold teaching bubbles.
</p>
</li>
<li>
<p> Coach mark size, color, and animation shouldn’t be altered.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(shiny)
library(shiny.fluent)

ui &lt;- function(id) {
  ns &lt;- NS(id)
  tagList(
    uiOutput(ns("coachmark")),
    DefaultButton.shinyInput(ns("toggleCoachmark"),
      id = "target", text = "Toggle coachmark"
    )
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    ns &lt;- session$ns
    coachmarkVisible &lt;- reactiveVal(FALSE)
    observeEvent(input$toggleCoachmark, coachmarkVisible(!coachmarkVisible()))
    observeEvent(input$hideCoachmark, coachmarkVisible(FALSE))
    output$coachmark &lt;- renderUI({
      if (coachmarkVisible()) Coachmark(
        target = "#target",
        TeachingBubbleContent(
          hasCloseButton = TRUE,
          onDismiss = triggerEvent(ns("hideCoachmark")),
          headline = "Example title",
          primaryButtonProps = list(text = "Try it"),
          secondaryButtonProps = list(text = "Try it again"),
          "Welcome to the land of coachmarks!"
        )
      )
    })
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>