<div class="container">

<table style="width: 100%;"><tr>
<td>lsem.estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Local Structural Equation Models (LSEM)
</h2>

<h3>Description</h3>

<p>Local structural equation models (LSEM) are structural equation models (SEM)
which are evaluated for each value of a pre-defined moderator variable
(Hildebrandt et al., 2009, 2016).
As in nonparametric regression models, observations near a focal point - at
which the model is evaluated - obtain higher weights, far distant observations
obtain lower weights. The LSEM can be specified by making use of <span class="pkg">lavaan</span> syntax.
It is also possible to specify a discretized version of LSEM in which
values of the moderator are grouped and a multiple group SEM is specified.
The LSEM can be tested by employing a permutation test, see
<code>lsem.permutationTest</code>.
</p>
<p>The function <code>lsem.MGM.stepfunctions</code> outputs stepwise functions
for a multiple group model evaluated at a grid of focal points of the
moderator, specified in <code>moderator.grid</code>.
</p>
<p>The argument <code>pseudo_weights</code> provides an ad hoc solution to estimate
an LSEM for any model which can be fitted in <span class="pkg">lavaan</span>.
</p>
<p>It is also possible to constrain some of the parameters along the values
of the moderator in a joint estimation approach (<code>est_joint=TRUE</code>). Parameter
names can be specified which are assumed to be invariant (in <code>par_invariant</code>).
In addition, linear or quadratic constraints can be imposed on
parameters (<code>par_linear</code> or <code>par_quadratic</code>).
</p>
<p>Statistical inference in case of joint estimation (but also for separate estimation)
can be conducted via bootstrap using the function <code>lsem.bootstrap</code>.
Bootstrap at the level of a cluster identifier is allowed (argument <code>cluster</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">lsem.estimate(data, moderator, moderator.grid, lavmodel, type="LSEM", h=1.1, bw=NULL,
    residualize=TRUE, fit_measures=c("rmsea", "cfi", "tli", "gfi", "srmr"),
    standardized=FALSE, standardized_type="std.all", lavaan_fct="sem",
    sufficient_statistics=TRUE, pseudo_weights=0,
    sampling_weights=NULL, loc_linear_smooth=TRUE, est_joint=FALSE, par_invariant=NULL,
    par_linear=NULL, par_quadratic=NULL, partable_joint=NULL, pw_linear=1,
    pw_quadratic=1, pd=TRUE, est_DIF=FALSE, se=NULL, kernel="gaussian",
    eps=1e-08, verbose=TRUE, ...)

## S3 method for class 'lsem'
summary(object, file=NULL, digits=3, ...)

## S3 method for class 'lsem'
plot(x, parindex=NULL, ask=TRUE, ci=TRUE, lintrend=TRUE,
       parsummary=TRUE, ylim=NULL, xlab=NULL,  ylab=NULL, main=NULL,
       digits=3, ...)

lsem.MGM.stepfunctions( object, moderator.grid )

# compute local weights
lsem_local_weights(data.mod, moderator.grid, h, sampling_weights=NULL,  bw=NULL,
     kernel="gaussian")

lsem.bootstrap(object, R=100, verbose=TRUE, cluster=NULL,
     repl_design=NULL, repl_factor=NULL, use_starting_values=TRUE,
     n.core=1, cl.type="PSOCK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Data frame
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator</code></td>
<td>

<p>Variable name of the moderator
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator.grid</code></td>
<td>

<p>Focal points at which the LSEM should be evaluated. If <code>type="MGM"</code>,
breaks are defined in this vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavmodel</code></td>
<td>

<p>Specified SEM in <span class="pkg">lavaan</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of estimated model. The default is <code>type="LSEM"</code> which means
that a local structural equation model is estimated.
A multiple group model with a discretized moderator as the
grouping variable can be estimated with <code>type="MGM"</code>. In this
case, the breaks must be defined in <code>moderator.grid</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>Bandwidth factor
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>Optional bandwidth parameter if <code>h</code> should not be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residualize</code></td>
<td>
<p>Logical indicating whether a residualization
should be applied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit_measures</code></td>
<td>

<p>Vector with names of fit measures following the labels in <span class="pkg">lavaan</span>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>Optional logical indicating whether
standardized solution should be included as parameters in
the output using the
<code>lavaan::standardizedSolution</code>
function. Standardized parameters are labeled as <code>std__</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized_type</code></td>
<td>
<p>Type of standardization if <code>standardized=TRUE</code>.
The types are described in
<code>lavaan::standardizedSolution</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavaan_fct</code></td>
<td>
<p>String whether
<code>lavaan::lavaan</code> (<code>lavaan_fct="lavaan"</code>),
<code>lavaan::sem</code> (<code>lavaan_fct="sem"</code>),
<code>lavaan::cfa</code> (<code>lavaan_fct="cfa"</code>) or
<code>lavaan::growth</code> (<code>lavaan_fct="growth"</code>)
should be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sufficient_statistics</code></td>
<td>
<p>Logical whether sufficient statistics of weighted
means and covariances should be used for model fitting. This option
can be set to <code>sufficient_statistics=FALSE</code>
if the data contain missing values. Note that the option
<code>sufficient_statistics=TRUE</code> is
only valid for (approximate) missing completely at random (MCAR) data.
The option can only be used for continuous data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo_weights</code></td>
<td>
<p>Integer defining a target sample size. Local weights
are multiplied by a factor which is rounded to integers.
This approach is referred as a pseudo weighting approach.
For example, using <code>pseudo_weights=30000</code> implies
that the sum of local weights at each focal point is <code>30000</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_weights</code></td>
<td>
<p>Optional vector of sampling weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc_linear_smooth</code></td>
<td>
<p>Logical indicating whether local linear
smoothing should be used for computing sufficient statistics for
means and covariances. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_joint</code></td>
<td>
<p>Logical indicating whether LSEM should be estimated in a
joint estimation approach. This options only works wih continuous data and
sufficient statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_invariant</code></td>
<td>
<p>Vector of invariant parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_linear</code></td>
<td>
<p>Vector of parameters with linear function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_quadratic</code></td>
<td>
<p>Vector of parameters with quadratic function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable_joint</code></td>
<td>
<p>User-defined parameter table if joint estimation is
used (<code>est_joint=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pw_linear</code></td>
<td>
<p>Number of segments if piecewise linear estimation of parameters is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pw_quadratic</code></td>
<td>
<p>Number of segments if piecewise quadratic estimation of parameters
is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd</code></td>
<td>
<p>Logical indicating whether nearest positive definite covariance matrix
should be computed if sufficient statistics are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_DIF</code></td>
<td>
<p>Logical indicating whether parameters under differential
item functioning (DIF) should be additionally
computed for invariant item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Type of standard error used in <code>lavaan::lavaan</code>. If <code>NULL</code>,
the <span class="pkg">lavaan</span> default is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>Type of kernel function. Can be <code>"gaussian"</code>,
<code>"uniform"</code> or <code>"epanechnikov"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Minimum number for weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Optional logical printing information about computation progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>lsem</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>A file name in which the summary output will be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>lsem</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parindex</code></td>
<td>
<p>Vector of indices for parameters in plot function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>A logical which asks for changing the graphic for each parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Logical indicating whether confidence intervals should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lintrend</code></td>
<td>
<p>Logical indicating whether a linear trend should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parsummary</code></td>
<td>
<p>Logical indicating whether a parameter summary
should be displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Plot parameter <code>ylim</code>. Can be a list, see Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Plot parameter <code>xlab</code>. Can be a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Plot parameter <code>ylab</code>. Can be a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>Plot parameter <code>main</code>. Can be a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed to <code>lavaan::sem</code> or
<code>lavaan::lavaan</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.mod</code></td>
<td>
<p>Observed values of the moderator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of bootstrap samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Optional variable name for bootstrap at the level of a cluster identifier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repl_design</code></td>
<td>
<p>Optional matrix containing replication weights for computation of
standard errors. Note that sampling weights have to be already included in
<code>repl_design</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repl_factor</code></td>
<td>
<p>Replication factor in variance formula for statistical
inference, e.g., 0.05 in PISA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_starting_values</code></td>
<td>
<p>Logical indicating whether starting values should be
used from the original sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.core</code></td>
<td>
<p>A scalar indicating the number of cores that should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl.type</code></td>
<td>
<p>The cluster type.
Default value is <code>"PSOCK"</code>. Posix machines (Linux, Mac) generally benefit
from much faster cluster computation if type is set to <code>type="FORK"</code>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>Data frame with all parameters estimated at focal points of
moderator. Bias-corrected estimates under boostrap can be found in
the column <code>est_bc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Data frame with weights at each focal point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters_summary</code></td>
<td>
<p>Summary table for estimated parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametersM</code></td>
<td>
<p>Estimated parameters in matrix form. Parameters are in
columns and values of the grid of the moderator are in rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>Used bandwidth</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Used bandwidth factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator.density</code></td>
<td>
<p>Estimated frequencies and effective sample size for
moderator at focal points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator.stat</code></td>
<td>
<p>Descriptive statistics for moderator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator</code></td>
<td>
<p>Variable name of moderator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator.grid</code></td>
<td>
<p>Used grid of focal points for moderator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator.grouped</code></td>
<td>
<p>Data frame with informations about grouping of
moderator if <code>type="MGM"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residualized.intercepts</code></td>
<td>
<p>Estimated intercept functions used for
residualization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavmodel</code></td>
<td>
<p>Used lavaan model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Used data frame, possibly residualized if <code>residualize=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_parameters</code></td>
<td>
<p>Model parameters in LSEM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters_boot</code></td>
<td>
<p>Parameter values in each bootstrap sample
(for <code>lsem.bootstrap</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitstats_joint_boot</code></td>
<td>
<p>Fit statistics in each bootstrap sample
(for <code>lsem.bootstrap</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dif_effects</code></td>
<td>
<p>Estimated item parameters under DIF</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alexander Robitzsch, Oliver Luedtke, Andrea Hildebrandt
</p>


<h3>References</h3>

<p>Hildebrandt, A., Luedtke, O., Robitzsch, A., Sommer, C., &amp;
Wilhelm, O. (2016). Exploring factor model parameters across continuous variables
with local structural equation models.
<em>Multivariate Behavioral Research, 51</em>(2-3), 257-278.
<a href="https://doi.org/10.1080/00273171.2016.1142856">doi:10.1080/00273171.2016.1142856</a>
</p>
<p>Hildebrandt, A., Wilhelm, O., &amp; Robitzsch, A. (2009). Complementary and
competing factor analytic approaches for the investigation of measurement invariance.
<em>Review of Psychology, 16</em>, 87-102.
</p>


<h3>See Also</h3>

<p>See <code>lsem.permutationTest</code> for conducting a permutation test
and <code>lsem.test</code> for applying a Wald test to a bootstrapped LSEM model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: data.lsem01 | Age differentiation
#############################################################################

data(data.lsem01, package="sirt")
dat &lt;- data.lsem01

# specify lavaan model
lavmodel &lt;- "
        F=~ v1+v2+v3+v4+v5
        F ~~ 1*F"

# define grid of moderator variable age
moderator.grid &lt;- seq(4,23,1)

#********************************
#*** Model 1: estimate LSEM with bandwidth 2
mod1 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, std.lv=TRUE)
summary(mod1)
plot(mod1, parindex=1:5)

# perform permutation test for Model 1
pmod1 &lt;- sirt::lsem.permutationTest( mod1, B=10 )
          # only for illustrative purposes the number of permutations B is set
          # to a low number of 10
summary(pmod1)
plot(pmod1, type="global")

#* perform permutation test with parallel computation
pmod1a &lt;- sirt::lsem.permutationTest( mod1, B=10, n.core=3 )
summary(pmod1a)

#** estimate Model 1 based on pseudo weights
mod1b &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, std.lv=TRUE, pseudo_weights=50 )
summary(mod1b)

#** estimation with sampling weights

# generate random sampling weights
set.seed(987)
weights &lt;- stats::runif(nrow(dat), min=.4, max=3 )
mod1c &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, sampling_weights=weights)
summary(mod1c)

#********************************
#*** Model 2: estimate multiple group model with 4 age groups

# define breaks for age groups
moderator.grid &lt;- seq( 3.5, 23.5, len=5) # 4 groups
# estimate model
mod2 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
           lavmodel=lavmodel, type="MGM", std.lv=TRUE)
summary(mod2)

# output step functions
smod2 &lt;- sirt::lsem.MGM.stepfunctions( object=mod2, moderator.grid=seq(4,23,1) )
str(smod2)

#********************************
#*** Model 3: define standardized loadings as derived variables

# specify lavaan model
lavmodel &lt;- "
        F=~ a1*v1+a2*v2+a3*v3+a4*v4
        v1 ~~ s1*v1
        v2 ~~ s2*v2
        v3 ~~ s3*v3
        v4 ~~ s4*v4
        F ~~ 1*F
        # standardized loadings
        l1 :=a1 / sqrt(a1^2 + s1 )
        l2 :=a2 / sqrt(a2^2 + s2 )
        l3 :=a3 / sqrt(a3^2 + s3 )
        l4 :=a4 / sqrt(a4^2 + s4 )
        "
# estimate model
mod3 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, std.lv=TRUE)
summary(mod3)
plot(mod3)

#********************************
#*** Model 4: estimate LSEM and automatically include standardized solutions

lavmodel &lt;- "
        F=~ 1*v1+v2+v3+v4
        F ~~ F"
mod4 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, standardized=TRUE)
summary(mod4)
# permutation test (use only few permutations for testing purposes)
pmod1 &lt;- sirt::lsem.permutationTest( mod4, B=3 )

#**** compute LSEM local weights
wgt &lt;- sirt::lsem_local_weights(data.mod=dat$age, moderator.grid=moderator.grid,
             h=2)$weights
print(str(weights))

#********************************
#*** Model 5: invariance parameter constraints and other constraints

lavmodel &lt;- "
        F=~ 1*v1+v2+v3+v4
        F ~~ F"
moderator.grid &lt;- seq(4,23,4)

#- estimate model without constraints
mod5a &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, standardized=TRUE)
summary(mod5a)
# extract parameter names
mod5a$model_parameters

#- invariance constraints on residual variances
par_invariant &lt;- c("F=~v2","v2~~v2")
mod5b &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, standardized=TRUE, par_invariant=par_invariant)
summary(mod5b)

#- bootstrap for statistical inference
bmod5b &lt;- sirt::lsem.bootstrap(mod5b, R=100)
# inspect parameter values and standard errors
bmod5b$parameters

#- bootstrap using parallel computing (i.e., multiple cores)
bmod5ba &lt;- sirt::lsem.bootstrap(mod5b, R=100, n.core=3)

#- user-defined replication design
R &lt;- 100    # bootstrap samples
N &lt;- nrow(dat)
repl_design &lt;- matrix(0, nrow=N, ncol=R)
for (rr in 1:R){
    indices &lt;- sort( sample(1:N, replace=TRUE) )
    repl_design[,rr] &lt;- sapply(1:N, FUN=function(ii){ sum(indices==ii) } )
}
head(repl_design)
bmod5b1 &lt;- sirt::lsem.bootstrap(mod5a, repl_design=repl_design, repl_factor=1/R)

#- compare model mod5b with joint estimation without constraints
mod5c &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
               lavmodel=lavmodel, h=2, standardized=TRUE, est_joint=TRUE)
summary(mod5c)

#- linear and quadratic functions
par_invariant &lt;- c("F=~v1","v2~~v2")
par_linear &lt;- c("v1~~v1")
par_quadratic &lt;- c("v4~~v4")

mod5d &lt;- sirt::lsem.estimate( dat1, moderator="age", moderator.grid=moderator.grid,
            lavmodel=lavmodel, h=2, par_invariant=par_invariant, par_linear=par_linear,
            par_quadratic=par_quadratic)
summary(mod5d)

#- user-defined constraints: step functions for parameters

# inspect parameter table (from lavaan) of fitted model
pj &lt;- mod5d$partable_joint
#* modify parameter table for user-defined constraints
# define step function for F=~v1 which is constant on intervals 1:4 and 5:7
pj2 &lt;- pj[ pj$con==1, ]
pj2[ c(5,6), "lhs" ] &lt;- "p1g5"
pj2 &lt;- pj2[ -4, ]
partable_joint &lt;- rbind(pj1, pj2)
# estimate model with constraints
mod5e &lt;- lsem::lsem.estimate( dat1, moderator="age", moderator.grid=moderator.grid,
             lavmodel=lavmodel, h=2, std.lv=TRUE, estimator="ML",
             partable_joint=partable_joint)
summary(mod5e)

#############################################################################
# EXAMPLE 2: data.lsem01 | FIML with missing data
#############################################################################

data(data.lsem01)
dat &lt;- data.lsem01
# induce artifical missing values
set.seed(98)
dat[ stats::runif(nrow(dat)) &lt; .5, c("v1")] &lt;- NA
dat[ stats::runif(nrow(dat)) &lt; .25, c("v2")] &lt;- NA

# specify lavaan model
lavmodel1 &lt;- "
        F=~ v1+v2+v3+v4+v5
        F ~~ 1*F"

# define grid of moderator variable age
moderator.grid &lt;- seq(4,23,2)

#*** estimate LSEM with FIML
mod1 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
                lavmodel=lavmodel1, h=2, std.lv=TRUE, estimator="ML", missing="fiml")
summary(mod1)

#############################################################################
# EXAMPLE 3: data.lsem01 | WLSMV estimation
#############################################################################

data(data.lsem01)
dat &lt;- data.lsem01

# create artificial dichotomous data
for (vv in 2:6){
dat[,vv] &lt;- 1*(dat[,vv] &gt; mean(dat[,vv]))
}

# specify lavaan model
lavmodel1 &lt;- "
        F=~ v1+v2+v3+v4+v5
        F ~~ 1*F
        v1 | t1
        v2 | t1
        v3 | t1
        v4 | t1
        v5 | t1
        "

# define grid of moderator variable age
moderator.grid &lt;- seq(4,23,2)

#*** local WLSMV estimation
mod1 &lt;- sirt::lsem.estimate( dat, moderator="age", moderator.grid=moderator.grid,
          lavmodel=lavmodel1, h=2, std.lv=TRUE, estimator="DWLS", ordered=paste0("v",1:5),
          residualize=FALSE, pseudo_weights=10000, parameterization="THETA" )
summary(mod1)

## End(Not run)
</code></pre>


</div>