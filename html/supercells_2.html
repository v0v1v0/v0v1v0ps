<div class="container">

<table style="width: 100%;"><tr>
<td>supercells</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates supercells</h2>

<h3>Description</h3>

<p>Creates supercells based on single- or multi-band spatial raster data. It uses a modified version of the SLIC Superpixel algorithm by Achanta et al. (2012), allowing specification of a distance function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">supercells(
  x,
  k,
  compactness,
  dist_fun = "euclidean",
  avg_fun = "mean",
  clean = TRUE,
  iter = 10,
  transform = NULL,
  step,
  minarea,
  metadata = TRUE,
  chunks = FALSE,
  future = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class SpatRaster (terra) or class stars (stars)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of supercells desired by the user (the output number can be slightly different!).
You can use either <code>k</code> or <code>step</code>.
It is also possible to provide a set of points (an <code>sf</code> object) as <code>k</code> together with the <code>step</code> value to create custom cluster centers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compactness</code></td>
<td>
<p>A compactness value. Larger values cause clusters to be more compact/even (square).
A compactness value depends on the range of input cell values and selected distance measure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_fun</code></td>
<td>
<p>A distance function. Currently implemented distance functions are <code>"euclidean"</code>, <code>"jsd"</code>, <code>"dtw"</code> (dynamic time warping), name of any distance function from the <code>philentropy</code> package (see <code>philentropy::getDistMethods()</code>; "log2" is used in this case), or any user defined function accepting two vectors and returning one value. Default: <code>"euclidean"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avg_fun</code></td>
<td>
<p>An averaging function - how the values of the supercells' centers are calculated?
It accepts any fitting R function (e.g., <code>base::mean()</code> or <code>stats::median()</code>) or one of internally implemented <code>"mean"</code> and <code>"median"</code>. Default: <code>"mean"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p>Should connectivity of the supercells be enforced?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iterations performed to create the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>Transformation to be performed on the input. By default, no transformation is performed. Currently available transformation is "to_LAB": first, the conversion from RGB to the LAB color space is applied, then the supercells algorithm is run, and afterward, a reverse transformation is performed on the obtained results. (This argument is experimental and may be removed in the future).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>The distance (number of cells) between initial supercells' centers. You can use either <code>k</code> or <code>step</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minarea</code></td>
<td>
<p>Specifies the minimal size of a supercell (in cells). Only works when <code>clean = TRUE</code>.
By default, when <code>clean = TRUE</code>, average area (A) is calculated based on the total number of cells divided by a number of supercells
Next, the minimal size of a supercell equals to A/(2^2) (A is being right shifted)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metadata</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the output object will have metadata columns ("supercells", "x", "y"). If <code>FALSE</code>, the output object will not have metadata columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunks</code></td>
<td>
<p>Should the input (<code>x</code>) be split into chunks before deriving supercells? Either <code>FALSE</code> (default), <code>TRUE</code> (only large input objects are split), or a numeric value (representing the side length of the chunk in the number of cells).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future</code></td>
<td>
<p>Should the future package be used for parallelization of the calculations? Default: <code>FALSE</code>. If <code>TRUE</code>, you also need to specify <code>future::plan()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>An integer specifying the level of text messages printed during calculations. 0 means no messages (default), 1 provides basic messages (e.g., calculation stage).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An sf object with several columns: (1) supercells - an id of each supercell, (2) y and x coordinates, (3) one or more columns with average values of given variables in each supercell
</p>


<h3>References</h3>

<p>Achanta, R., Shaji, A., Smith, K., Lucchi, A., Fua, P., &amp; Süsstrunk, S. (2012). SLIC Superpixels Compared to State-of-the-Art Superpixel Methods. IEEE Transactions on Pattern Analysis and Machine Intelligence, 34(11), 2274–2282. https://doi.org/10.1109/tpami.2012.120
</p>
<p>Nowosad, J. Motif: an open-source R tool for pattern-based spatial analysis. Landscape Ecol (2021). https://doi.org/10.1007/s10980-020-01135-0
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(supercells)
# One variable

vol = terra::rast(system.file("raster/volcano.tif", package = "supercells"))
vol_slic1 = supercells(vol, k = 50, compactness = 1)
terra::plot(vol)
plot(sf::st_geometry(vol_slic1), add = TRUE, lwd = 0.2)

# RGB variables
# ortho = terra::rast(system.file("raster/ortho.tif", package = "supercells"))
# ortho_slic1 = supercells(ortho, k = 1000, compactness = 10, transform = "to_LAB")
# terra::plot(ortho)
# plot(sf::st_geometry(ortho_slic1), add = TRUE)
#
# ### RGB variables - colored output
#
# rgb_to_hex = function(x){
#   apply(t(x), 2, function(x) rgb(x[1], x[2], x[3], maxColorValue = 255))
# }
# avg_colors = rgb_to_hex(sf::st_drop_geometry(ortho_slic1[4:6]))
#
# terra::plot(ortho)
# plot(sf::st_geometry(ortho_slic1), add = TRUE, col = avg_colors)
</code></pre>


</div>