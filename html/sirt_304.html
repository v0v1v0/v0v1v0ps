<div class="container">

<table style="width: 100%;"><tr>
<td>rm.sdt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Hierarchical Rater Model Based on Signal Detection Theory (HRM-SDT)
</h2>

<h3>Description</h3>

<p>This function estimates a version of the hierarchical rater
model (HRM) based on signal detection theory (HRM-SDT; DeCarlo, 2005;
DeCarlo, Kim &amp; Johnson, 2011; Robitzsch &amp; Steinfeld, 2018).
The model is estimated by means of an EM algorithm adapted from
multilevel latent class analysis (Vermunt, 2008).
</p>


<h3>Usage</h3>

<pre><code class="language-R">rm.sdt(dat, pid, rater, Qmatrix=NULL, theta.k=seq(-9, 9, len=30),
    est.a.item=FALSE, est.c.rater="n", est.d.rater="n", est.mean=FALSE, est.sigma=TRUE,
    skillspace="normal", tau.item.fixed=NULL, a.item.fixed=NULL,
    d.min=0.5, d.max=100, d.start=3, c.start=NULL, tau.start=NULL, sd.start=1,
    d.prior=c(3,100), c.prior=c(3,100), tau.prior=c(0,1000), a.prior=c(1,100),
    link_item="GPCM", max.increment=1, numdiff.parm=0.00001, maxdevchange=0.1,
    globconv=.001, maxiter=1000, msteps=4, mstepconv=0.001, optimizer="nlminb" )

## S3 method for class 'rm.sdt'
summary(object, file=NULL, ...)

## S3 method for class 'rm.sdt'
plot(x, ask=TRUE, ...)

## S3 method for class 'rm.sdt'
anova(object,...)

## S3 method for class 'rm.sdt'
logLik(object,...)

## S3 method for class 'rm.sdt'
IRT.factor.scores(object, type="EAP", ...)

## S3 method for class 'rm.sdt'
IRT.irfprob(object,...)

## S3 method for class 'rm.sdt'
IRT.likelihood(object,...)

## S3 method for class 'rm.sdt'
IRT.posterior(object,...)

## S3 method for class 'rm.sdt'
IRT.modelfit(object,...)

## S3 method for class 'IRT.modelfit.rm.sdt'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>Original data frame. Ratings on variables must be in rows,
i.e. every row corresponds to a person-rater combination.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pid</code></td>
<td>

<p>Person identifier.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rater</code></td>
<td>

<p>Rater identifier.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmatrix</code></td>
<td>

<p>An optional Q-matrix. If this matrix is not provided,
then by default the ordinary scoring of categories
(from 0 to the maximum score of <code class="reqn">K</code>) is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>

<p>A grid of theta values for the ability distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.a.item</code></td>
<td>

<p>Should item parameters <code class="reqn">a_i</code> be estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.c.rater</code></td>
<td>

<p>Type of estimation for item-rater parameters <code class="reqn">c_{ir}</code>
in the signal detection model. Options are <code>'n'</code> (no estimation),
<code>'e'</code> (set all parameters equal to each other),
<code>'i'</code> (itemwise estimation), <code>'r'</code> (rater wise estimation)
and <code>'a'</code> (all parameters are estimated independently
from each other).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.d.rater</code></td>
<td>

<p>Type of estimation of <code class="reqn">d</code> parameters. Options are
the same as in <code>est.c.rater</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.mean</code></td>
<td>
<p>Optional logical indicating whether the mean of the
trait distribution should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.sigma</code></td>
<td>
<p>Optional logical indicating whether the standard deviation of the
trait distribution should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skillspace</code></td>
<td>
<p>Specified <code class="reqn">\theta</code> distribution type. It can be
<code>"normal"</code> or <code>"discrete"</code>. In the latter case,
all probabilities of the distribution are separately
estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.item.fixed</code></td>
<td>
<p>Optional matrix with three columns specifying
fixed <code class="reqn">\tau</code> parameters. The first two columns denote item and
category indices, the third the fixed value. See Example 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.item.fixed</code></td>
<td>
<p>Optional matrix with two columns specifying fixed
<code class="reqn">a</code> parameters. First column: Item index. Second column:
Fixed <code class="reqn">a</code> parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.min</code></td>
<td>

<p>Minimal <code class="reqn">d</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.max</code></td>
<td>

<p>Maximal <code class="reqn">d</code> parameter to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.start</code></td>
<td>

<p>Starting value(s) of <code class="reqn">d</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.start</code></td>
<td>

<p>Starting values of <code class="reqn">c</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.start</code></td>
<td>

<p>Starting values of <code class="reqn">\tau</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.start</code></td>
<td>

<p>Starting value for trait standard deviation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.prior</code></td>
<td>
<p>Normal prior <code class="reqn">N(M,S^2)</code> for <code class="reqn">d</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.prior</code></td>
<td>
<p>Normal prior for <code class="reqn">c</code> parameters. The prior for
parameter <code class="reqn">c_{irk}</code> is defined as <code class="reqn">M \cdot ( k - 0.5) </code>
where <code class="reqn">M</code> is <code>c.prior[1]</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.prior</code></td>
<td>
<p>Normal prior for <code class="reqn">\tau</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.prior</code></td>
<td>
<p>Normal prior for <code class="reqn">a</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link_item</code></td>
<td>
<p>Type of item response function for latent responses.
Can be <code>"GPCM"</code> for the generalized partial credit model or
<code>"GRM"</code> for the graded response model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.increment</code></td>
<td>

<p>Maximum increment of item parameters during estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.parm</code></td>
<td>

<p>Numerical differentiation step width
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdevchange</code></td>
<td>

<p>Maximum relative deviance change as a convergence criterion
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globconv</code></td>
<td>

<p>Maximum parameter change
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msteps</code></td>
<td>

<p>Maximum number of iterations during an M step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstepconv</code></td>
<td>

<p>Convergence criterion in an M step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>Choice of optimization function in M-step for
item parameters. Options are <code>"nlminb"</code> for <code>stats::nlminb</code>
and <code>"optim"</code> for <code>stats::optim</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>rm.sdt</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name in which summary should be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>rm.sdt</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>Optional logical indicating whether a new plot should be asked for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Factor score estimation method. Up to now,
only <code>type="EAP"</code> is supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The specification of the model follows DeCarlo et al. (2011).
The second level models the ideal rating (latent response) <code class="reqn">\eta=0, ...,K</code>
of person <code class="reqn">p</code> on item <code class="reqn">i</code>. The option <code>link_item='GPCM'</code> follows the
generalized partial credit model
</p>
<p style="text-align: center;"><code class="reqn"> P( \eta_{pi}=\eta | \theta_p ) \propto
exp( a_{i} q_{i \eta } \theta_p - \tau_{i \eta } ) </code>
</p>
<p>. The option <code>link_item='GRM'</code> employs the
graded response model   </p>
<p style="text-align: center;"><code class="reqn"> P( \eta_{pi}=\eta | \theta_p )=
\Psi( \tau_{i,\eta + 1} - a_i \theta_p ) - \Psi( \tau_{i,\eta} - a_i \theta_p ) </code>
</p>

<p>At the first level, the ratings <code class="reqn">X_{pir}</code> for
person <code class="reqn">p</code> on item <code class="reqn">i</code> and rater <code class="reqn">r</code>
are modeled as a signal detection model
</p>
<p style="text-align: center;"><code class="reqn"> P( X_{pir} \le k | \eta_{pi} )=
G( c_{irk} - d_{ir} \eta_{pi} )</code>
</p>

<p>where <code class="reqn">G</code> is the logistic distribution function
and the categories are <code class="reqn">k=1,\ldots, K+1</code>.
Note that the item response model can be equivalently written
as </p>
<p style="text-align: center;"><code class="reqn"> P( X_{pir} \ge k | \eta_{pi} )=
G(   d_{ir} \eta_{pi} - c_{irk})</code>
</p>

<p>The thresholds <code class="reqn">c_{irk}</code> can be further restricted to
<code class="reqn">c_{irk}=c_{k}</code> (<code>est.c.rater='e'</code>),
<code class="reqn">c_{irk}=c_{ik}</code> (<code>est.c.rater='i'</code>) or
<code class="reqn">c_{irk}=c_{ir}</code> (<code>est.c.rater='r'</code>). The same
holds for rater precision parameters <code class="reqn">d_{ir}</code>.
</p>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria and number of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Data frame with item parameters. The columns
<code>N</code> and <code>M</code> denote the number of observed ratings and the
observed mean of all ratings, respectively. <br>
In addition to item parameters <code class="reqn">\tau_{ik}</code> and <code class="reqn">a_i</code>, the mean
for the latent response (<code>latM</code>) is computed as
<code class="reqn">E( \eta_i )=\sum_p P( \theta_p ) q_{ik} P( \eta_i=k | \theta_p ) </code>
which provides an item parameter at the original metric of ratings. The latent standard
deviation (<code>latSD</code>) is computed in the same manner.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rater</code></td>
<td>
<p>Data frame with rater parameters.
Transformed <code class="reqn">c</code> parameters
(<code>c_x.trans</code>) are computed as <code class="reqn">c_{irk} / ( d_{ir}  )</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>Data frame with person parameters: EAP and corresponding standard
errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EAP.rel</code></td>
<td>
<p>EAP reliability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EAP.rel</code></td>
<td>
<p>EAP reliability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Mean of the trait distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Standard deviation of the trait distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.item</code></td>
<td>
<p>Item parameters <code class="reqn">\tau_{ik}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.tau.item</code></td>
<td>
<p>Standard error of item parameters <code class="reqn">\tau_{ik}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.item</code></td>
<td>
<p>Item slopes <code class="reqn">a_i</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.a.item</code></td>
<td>
<p>Standard error of item slopes <code class="reqn">a_i</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.rater</code></td>
<td>
<p>Rater parameters <code class="reqn">c_{irk}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.c.rater</code></td>
<td>
<p>Standard error of rater severity parameter <code class="reqn">c_{irk}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.rater</code></td>
<td>
<p>Rater slope parameter <code class="reqn">d_{ir}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.d.rater</code></td>
<td>
<p>Standard error of rater slope parameter <code class="reqn">d_{ir}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.yi.qk</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.qk.yi</code></td>
<td>
<p>Individual posterior distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Item probabilities at grid <code>theta.k</code>. Note that these
probabilities are calculated on the pseudo items <code class="reqn">i \times r</code>,
i.e. the interaction of item and rater.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.item</code></td>
<td>
<p>Probabilities <code class="reqn">P( \eta_i=\eta | \theta )</code> of
latent item responses evaluated at theta grid <code class="reqn">\theta_p</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ik</code></td>
<td>
<p>Expected counts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.k</code></td>
<td>
<p>Estimated trait distribution <code class="reqn">P(\theta_p)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxK</code></td>
<td>
<p>Maximum number of categories</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>procdata</code></td>
<td>
<p>Processed data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further values</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>DeCarlo, L. T. (2005). A model of rater behavior in essay grading
based on signal detection theory.
<em>Journal of Educational Measurement, 42</em>, 53-76.
</p>
<p>DeCarlo, L. T. (2010). <em>Studies of a latent-class signal-detection model
for constructed response scoring II: Incomplete and hierarchical designs</em>.
ETS Research Report ETS RR-10-08. Princeton NJ: ETS.
</p>
<p>DeCarlo, T., Kim, Y., &amp; Johnson, M. S. (2011).
A hierarchical rater model for constructed responses,
with a signal detection rater model.
<em>Journal of Educational Measurement, 48</em>, 333-356.
</p>
<p>Robitzsch, A., &amp; Steinfeld, J. (2018). Item response models for human ratings: Overview,
estimation methods, and implementation in R.
<em>Psychological Test and Assessment Modeling, 60</em>(1), 101-139.
</p>
<p>Vermunt, J. K. (2008). Latent class and finite mixture models for
multilevel data sets. <em>Statistical Methods in Medical Research, 17</em>, 33-51.
</p>


<h3>See Also</h3>

<p>The facets rater model can be estimated with <code>rm.facets</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Hierarchical rater model (HRM-SDT) data.ratings1
#############################################################################
data(data.ratings1)
dat &lt;- data.ratings1

## Not run: 
# Model 1: Partial Credit Model: no rater effects
mod1 &lt;- sirt::rm.sdt( dat[, paste0( "k",1:5) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="n", d.start=100,  est.d.rater="n" )
summary(mod1)

# Model 2: Generalized Partial Credit Model: no rater effects
mod2 &lt;- sirt::rm.sdt( dat[, paste0( "k",1:5) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="n", est.d.rater="n",
            est.a.item=TRUE, d.start=100)
summary(mod2)

# Model 3: Equal effects in SDT
mod3 &lt;- sirt::rm.sdt( dat[, paste0( "k",1:5) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="e", est.d.rater="e")
summary(mod3)

# Model 4: Rater effects in SDT
mod4 &lt;- sirt::rm.sdt( dat[, paste0( "k",1:5) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="r", est.d.rater="r")
summary(mod4)

#############################################################################
# EXAMPLE 2: HRM-SDT data.ratings3
#############################################################################

data(data.ratings3)
dat &lt;- data.ratings3
dat &lt;- dat[ dat$rater &lt; 814, ]
psych::describe(dat)

# Model 1: item- and rater-specific effects
mod1 &lt;- sirt::rm.sdt( dat[, paste0( "crit",c(2:4)) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="a", est.d.rater="a" )
summary(mod1)
plot(mod1)

# Model 2: Differing number of categories per variable
mod2 &lt;- sirt::rm.sdt( dat[, paste0( "crit",c(2:4,6)) ], rater=dat$rater,
            pid=dat$idstud, est.c.rater="a", est.d.rater="a")
summary(mod2)
plot(mod2)

#############################################################################
# EXAMPLE 3: Hierarchical rater model with discrete skill spaces
#############################################################################

data(data.ratings3)
dat &lt;- data.ratings3
dat &lt;- dat[ dat$rater &lt; 814, ]
psych::describe(dat)

# Model 1: Discrete theta skill space with values of 0,1,2 and 3
mod1 &lt;- sirt::rm.sdt( dat[, paste0( "crit",c(2:4)) ], theta.k=0:3, rater=dat$rater,
            pid=dat$idstud, est.c.rater="a", est.d.rater="a", skillspace="discrete" )
summary(mod1)
plot(mod1)

# Model 2: Modelling of one item by using a discrete skill space and
#          fixed item parameters

# fixed tau and a parameters
tau.item.fixed &lt;- cbind( 1, 1:3,  100*cumsum( c( 0.5, 1.5, 2.5)) )
a.item.fixed &lt;- cbind( 1, 100 )
# fit HRM-SDT
mod2 &lt;- sirt::rm.sdt( dat[, "crit2", drop=FALSE], theta.k=0:3, rater=dat$rater,
            tau.item.fixed=tau.item.fixed,a.item.fixed=a.item.fixed, pid=dat$idstud,
            est.c.rater="a", est.d.rater="a", skillspace="discrete" )
summary(mod2)
plot(mod2)

## End(Not run)
</code></pre>


</div>