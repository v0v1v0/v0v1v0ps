<div class="container">

<table style="width: 100%;"><tr>
<td>spDiag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model fit diagnostics</h2>

<h3>Description</h3>

<p>The function <code>spDiag</code> calculates DIC, GP, GRS, and associated
statistics given a <code>spLM</code>, <code>spMvLM</code>,
<code>spGLM</code>, <code>spMvGLM</code>, <code>spMvGLM</code>, or
<code>spSVC</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  spDiag(sp.obj, start=1, end, thin=1, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sp.obj</code></td>
<td>
<p>an object returned by  <code>spLM</code>,
<code>spMvLM</code>, <code>spGLM</code>, <code>spMvGLM</code>. For <code>spSVC</code>, <code>sp.obj</code> is an object from <code>spRecover</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>specifies the first sample included in the computation. The <code>start</code>, <code>end</code>, and <code>thin</code> arguments only apply to <code>spGLM</code> or
<code>spMvGLM</code> objects. Sub-sampling for <code>spLM</code> and <code>spMvLM</code> is controlled using <code>spRecover</code> which
must be called prior to <code>spDiag</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>specifies the last sample included  in the computation.
The default is to use all posterior samples in <code>sp.obj</code>. See
<code>start</code> argument description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>a sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> calculation progress is printed to the
screen; otherwise, nothing is printed to the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with some of the following tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>DIC</code></td>
<td>
<p>a matrix holding DIC and associated statistics, see
Banerjee et al. (2004) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GP</code></td>
<td>
<p>a matrix holding GP and associated statistics, see Gelfand
and Ghosh (1998) for details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GRS</code></td>
<td>
<p>a scoring rule, see Equation 27 in Gneiting and Raftery
(2007) for details.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton,Fla.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Efficient implementation of spatially-varying coefficients
models.
</p>
<p>Gelfand A.E. and Ghosh, S.K. (1998). Model choice: a minimum posterior
predictive loss approach. <em>Biometrika</em>. 85:1-11.
</p>
<p>Gneiting, T. and Raftery, A.E. (2007). Strictly proper scoring rules, prediction, and estimation.
<em>Journal of the American Statistical Association</em>. 102:359-378.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)

sigma.sq &lt;- 2
tau.sq &lt;- 0.1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

n.samples &lt;- 1000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)

tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)

##too restrictive of prior on beta
priors.1 &lt;- list("beta.Norm"=list(rep(0,p), diag(1,p)),
                 "phi.Unif"=c(3/1, 3/0.1), "sigma.sq.IG"=c(2, 2),
                 "tau.sq.IG"=c(2, 0.1))

##more reasonable prior for beta
priors.2 &lt;- list("beta.Norm"=list(rep(0,p), diag(1000,p)),
                 "phi.Unif"=c(3/1, 3/0.1), "sigma.sq.IG"=c(2, 2),
                 "tau.sq.IG"=c(2, 0.1))

cov.model &lt;- "exponential"

n.report &lt;- 500
verbose &lt;- TRUE

m.1 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.1, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

m.2 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.2, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

##non-spatial model
m.3 &lt;- spLM(y~X-1, n.samples=n.samples, verbose=verbose, n.report=n.report)

burn.in &lt;- 0.5*n.samples

##recover beta and spatial random effects
m.1 &lt;- spRecover(m.1, start=burn.in, verbose=FALSE)
m.2 &lt;- spRecover(m.2, start=burn.in, verbose=FALSE)

##lower is better for DIC, GPD, and GRS
print(spDiag(m.1))
print(spDiag(m.2))
print(spDiag(m.3))

## End(Not run)
</code></pre>


</div>