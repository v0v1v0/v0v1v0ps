<div class="container">

<table style="width: 100%;"><tr>
<td>st_as_sf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert stars object into an sf object</h2>

<h3>Description</h3>

<p>Convert stars object into an sf object
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'stars'
st_as_sfc(x, ..., as_points, which = seq_len(prod(dim(x)[1:2])))

## S3 method for class 'stars'
st_as_sf(
  x,
  ...,
  as_points = FALSE,
  merge = FALSE,
  na.rm = TRUE,
  use_integer = is.logical(x[[1]]) || is.integer(x[[1]]),
  long = FALSE,
  connect8 = FALSE
)

## S3 method for class 'stars_proxy'
st_as_sf(x, ..., downsample = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_points</code></td>
<td>
<p>logical; should cells be converted to points or to polygons? See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>linear index of cells to keep (this argument is not recommended to be used)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, cells with identical values are merged (using <code>GDAL_Polygonize</code> or <code>GDAL_FPolygonize</code>); if <code>FALSE</code>, a polygon for each raster cell is returned; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical; should missing valued cells be removed, or also be converted to features?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_integer</code></td>
<td>
<p>(relevant only if <code>merge</code> is <code>TRUE</code>): if <code>TRUE</code>, before polygonizing values are rounded to 32-bits signed integer values (GDALPolygonize), otherwise they are converted to 32-bit floating point values (GDALFPolygonize).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>long</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a long table form <code>sf</code>, with geometries and other dimensions recycled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connect8</code></td>
<td>
<p>logical; if <code>TRUE</code>, use 8 connectedness. Otherwise the 4 connectedness algorithm will be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>downsample</code></td>
<td>
<p>see st_as_stars</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>merge</code> is <code>TRUE</code>, only the first attribute is converted into an <code>sf</code> object. If <code>na.rm</code> is <code>FALSE</code>, areas with <code>NA</code> values are also written out as polygons. Note that the resulting polygons are typically invalid, and use st_make_valid to create valid polygons out of them.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
x = x[,1:100,1:100,6] # subset of a band with lower values in it
x[[1]][x[[1]] &lt; 30] = NA # set lower values to NA
x[[1]] = x[[1]] &lt; 100 # make the rest binary
x
(p = st_as_sf(x)) # removes NA areas
(p = st_as_sf(x[,,,1], merge = TRUE)) # glues polygons together
all(st_is_valid(p)) # not all valid, see details
plot(p, axes = TRUE)
(p = st_as_sf(x, na.rm = FALSE, merge = TRUE)) # includes polygons with NA values
plot(p, axes = TRUE)
</code></pre>


</div>