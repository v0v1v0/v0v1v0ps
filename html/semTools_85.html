<div class="container">

<table style="width: 100%;"><tr>
<td>orthRotate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Implement orthogonal or oblique rotation</h2>

<h3>Description</h3>

<p>These functions will implement orthogonal or oblique rotation on
standardized factor loadings from a lavaan output.
</p>


<h3>Usage</h3>

<pre><code class="language-R">orthRotate(object, method = "varimax", ...)

oblqRotate(object, method = "quartimin", ...)

funRotate(object, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A lavaan output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method of rotations, such as <code>"varimax"</code>,
<code>"quartimax"</code>, <code>"geomin"</code>, <code>"oblimin"</code>, or any gradient
projection algorithms listed in the <code>GPA</code> function
in the <code>GPArotation</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for the <code>GPForth</code>
function (for <code>orthRotate</code>), the <code>GPFoblq</code>
function (for <code>oblqRotate</code>), or the function that users provide in the
<code>fun</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>The name of the function that users wish to rotate the
standardized solution. The functions must take the first argument as the
standardized loading matrix and return the <code>GPArotation</code> object. Check
this page for available functions: <code>rotations</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions will rotate the unrotated standardized factor loadings by
orthogonal rotation using the <code>GPForth</code> function or
oblique rotation using the <code>GPFoblq</code> function the
<code>GPArotation</code> package. The resulting rotation matrix will be used to
calculate standard errors of the rotated standardized factor loading by
delta method by numerically computing the Jacobian matrix by the
<code>lav_func_jacobian_simple</code> function.
</p>


<h3>Value</h3>

<p>An <code>linkS4class{EFA}</code> object that saves the rotated EFA solution
</p>


<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

unrotated &lt;- efaUnrotate(HolzingerSwineford1939, nf = 3,
                         varList = paste0("x", 1:9), estimator = "mlr")

# Orthogonal varimax
out.varimax &lt;- orthRotate(unrotated, method = "varimax")
summary(out.varimax, sort = FALSE, suppress = 0.3)

# Orthogonal Quartimin
orthRotate(unrotated, method = "quartimin")

# Oblique Quartimin
oblqRotate(unrotated, method = "quartimin")

# Geomin
oblqRotate(unrotated, method = "geomin")

# Target rotation
library(GPArotation)
target &lt;- matrix(0, 9, 3)
target[1:3, 1] &lt;- NA
target[4:6, 2] &lt;- NA
target[7:9, 3] &lt;- NA
colnames(target) &lt;- c("factor1", "factor2", "factor3")
## This function works with GPArotation version 2012.3-1
funRotate(unrotated, fun = "targetQ", Target = target)

## End(Not run)

</code></pre>


</div>