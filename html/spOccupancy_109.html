<div class="container">

<table style="width: 100%;"><tr>
<td>spIntPGOcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for Fitting Single-Species Integrated Spatial Occupancy Models Using Polya-Gamma Latent Variables</h2>

<h3>Description</h3>

<p>The function <code>spIntPGOcc</code> fits single-species integrated spatial occupancy models using Polya-Gamma latent variables. Models can be fit using either a full Gaussian process or a Nearest Neighbor Gaussian Process for large data sets. Data integration is done using a joint likelihood framework, assuming distinct detection models for each data source that are each conditional on a single latent occupancy process. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">spIntPGOcc(occ.formula, det.formula, data, inits, priors, 
           tuning, cov.model = "exponential", NNGP = TRUE, 
           n.neighbors = 15, search.type = 'cb', n.batch, 
           batch.length, accept.rate = 0.43, n.omp.threads = 1, 
           verbose = TRUE, n.report = 100, 
           n.burn = round(.10 * n.batch * batch.length), 
           n.thin = 1, n.chains = 1, k.fold, k.fold.threads = 1, 
           k.fold.seed, k.fold.data, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>det.formula</code></td>
<td>
<p>a list of symbolic descriptions of the models to be fit
for the detection portion of the model using R's model syntax for 
each data set. Each element in the list is a formula for the detection 
model of a given data set. Only right-hand side of formula is specified. 
See example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, <code>sites</code> and <code>coords</code>. 
<code>y</code> is a list of matrices or data frames for each data set used in 
the integrated model. Each element of the list has first dimension equal 
to the number of sites with that data source and second dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is 
a matrix or data frame containing the variables used in the occurrence 
portion of the model, with the number of rows being the number of sites 
with at least one data source for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model for each data source. 
<code>det.covs</code> should have the same number of elements as <code>y</code>, where
each element is itself a list. Each element of the list for a given data
source is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
with length equal to the number of observed sites of that data source,
while observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to the number of observed sites of that data source
and number of columns equal to the maximum number of replicates at a given site. 
<code>coords</code> is a matrix of the observation site coordinates. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, <code>alpha</code>, <code>sigma.sq</code>, <code>phi</code>, 
<code>w</code>, and <code>nu</code>. The value portion of all tags except <code>alpha</code> 
is the parameter's initial value. The tag <code>alpha</code> is a list comprised 
of the initial values for the detection parameters for each data source. 
Each element of the list should be a vector of initial values for all detection 
parameters in the given data source or a single value for each data source to 
assign all parameters for a given data source the same initial value. See 
<code>priors</code> description for definition of each parameter name.
Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code>, <code>alpha.normal</code>, <code>phi.unif</code>, 
<code>sigma.sq.ig</code>, <code>sigma.sq.unif</code>, and <code>nu.unif</code>. 
Occurrence (<code>beta</code>) and detection 
(<code>alpha</code>) regression coefficients are assumed to follow a normal 
distribution. For <code>beta</code> hyperparameters of the normal distribution 
are passed as a list of length two with the first and second elements 
corresponding to the mean and variance of the normal distribution, which are 
each specified as vectors of length equal to the number of coefficients 
to be estimated or of length one if priors are the same for all coefficients. 
For the detection coefficients <code>alpha</code>, the mean 
and variance hyperparameters are themselves passed in as lists, with each 
element of the list corresponding to the specific hyperparameters for the 
detection parameters in a given data source. If not specified, prior means 
are set to 0 and prior variances set to 2.73 for normal priors. The 
spatial variance parameter, <code>sigma.sq</code>, is assumed to follow an 
inverse-Gamma distribution or a uniform distribution (default is 
inverse-Gamma). <code>sigma.sq</code> can also be fixed at its 
initial value by setting the prior value to 
<code>"fixed"</code>. The spatial decay <code>phi</code> and 
smoothness <code>nu</code> parameters are assumed to follow Uniform 
distributions. The hyperparameters of the inverse-Gamma are passed as 
a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first 
and second elements corresponding to the lower and upper support, 
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each
tag defines the initial variance of the Adaptive sampler. See
Roberts and Rosenthal (2009) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NNGP</code></td>
<td>
<p>if <code>TRUE</code>, model is fit with an NNGP. If <code>FALSE</code>, 
a full Gaussian process is used. See Datta et al. (2016) and 
Finley et al. (2019) for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Only used if 
<code>NNGP = TRUE</code>. Datta et al. (2016) showed that 15 neighbors is usually 
sufficient, but that as few as 5 neighbors can be adequate for certain data
sets, which can lead to even greater decreases in run time. We recommend
starting with 15 neighbors (the default) and if additional gains in computation
time are desired, subsequently compare the results with a smaller number
of neighbors using WAIC or k-fold cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search.type</code></td>
<td>
<p>a quoted keyword that specifies the type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering then <code>"cb"</code> 
and <code>"brute"</code> should produce identical neighbor sets. 
However, if there are identical coordinate values on the axis used 
for nearest neighbor ordering, then <code>"cb"</code> and <code>"brute"</code> 
might produce different, but equally valid, neighbor sets, 
e.g., if data are on a grid. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.batch</code></td>
<td>
<p>the number of MCMC batches to run for each chain for the Adaptive MCMC 
sampler. See Roberts and Rosenthal (2009) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch.length</code></td>
<td>
<p>the length of each MCMC batch to run for the Adaptive 
MCMC sampler. See Roberts and Rosenthal (2009) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept.rate</code></td>
<td>
<p>target acceptance rate for Adaptive MCMC. Default is 
0.43. See Roberts and Rosenthal (2009) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and
MCMC progress. Note this is specified in terms of batches and not overall
samples for spatial models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.batch * batch.length</code> 
samples to discard as burn-in. By default, the first 10% of samples is discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation.
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples,
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated
<em>k</em> times (the folds). As a scoring rule, we use the model deviance
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.data</code></td>
<td>
<p>an integer specifying the specific data set to hold out
values from. If not specified, data from all data set locations will 
be incorporated into the k-fold cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>spIntPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occurrence regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients for all data sources.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occurrence values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occurrence probability values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for covariance parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for latent spatial random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. A 
separate deviance value is returned for each data source. Only included if 
<code>k.fold</code> is specified in function call. Only a single value is returned
if <code>k.fold.data</code> is specified.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br>
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, <a href="https://doi.org/10.1080/01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, <a href="https://doi.org/10.1080/10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R package 
for nearest neighbor Gaussian process models. <em>arXiv</em> preprint arXiv:2001.09111.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. <em>Ecological Monographs</em>, 85(1), 3-28.
</p>
<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. 
<em>CRC Press</em>.
</p>
<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables.
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Roberts, G.O. and Rosenthal J.S. (2009) Examples  of adaptive MCMC. 
<em>Journal of Computational and Graphical Statistics</em>, 18(2):349-367.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(400)

# Simulate Data -----------------------------------------------------------
# Number of locations in each direction. This is the total region of interest
# where some sites may or may not have a data source. 
J.x &lt;- 8
J.y &lt;- 8
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 0.5)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
alpha[[1]] &lt;- runif(2, 0, 1)
alpha[[2]] &lt;- runif(3, 0, 1)
alpha[[3]] &lt;- runif(2, -1, 1)
alpha[[4]] &lt;- runif(4, -1, 1)
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)
sigma.sq &lt;- 2
phi &lt;- 3 / .5
sp &lt;- TRUE

# Simulate occupancy data from multiple data sources. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = sp, 
                 sigma.sq = sigma.sq, phi = phi, cov.model = 'exponential')

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred
coords &lt;- as.matrix(dat$coords.obs)
coords.0 &lt;- as.matrix(dat$coords.pred)

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2], 
                      det.cov.2.2 = X.p[[2]][, , 3])
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2])
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2], 
                      det.cov.4.2 = X.p[[4]][, , 3], 
                      det.cov.4.3 = X.p[[4]][, , 4])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites, 
                  coords = coords)

J &lt;- length(dat$z.obs)

# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   phi = 3 / .5, 
                   sigma.sq = 2, 
                   w = rep(0, J), 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)),
                   phi.unif = c(3/1, 3/.1), 
                   sigma.sq.ig = c(2, 2))
# Tuning
tuning.list &lt;- list(phi = 0.3) 

# Number of batches
n.batch &lt;- 2
# Batch length
batch.length &lt;- 25

out &lt;- spIntPGOcc(occ.formula = ~ occ.cov, 
                  det.formula = list(f.1 = ~ det.cov.1.1, 
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2, 
                                     f.3 = ~ det.cov.3.1, 
                                     f.4 = ~ det.cov.4.1 + det.cov.4.2 + det.cov.4.3), 
                  data = data.list,  
                  inits = inits.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  accept.rate = 0.43, 
                  priors = prior.list, 
                  cov.model = "exponential", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = FALSE, 
                  n.report = 10, 
                  n.burn = 10, 
                  n.thin = 1)

summary(out)
</code></pre>


</div>