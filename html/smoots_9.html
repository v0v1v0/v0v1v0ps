<div class="container">

<table style="width: 100%;"><tr>
<td>gsmooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of Trends and their Derivatives via Local Polynomial Regression</h2>

<h3>Description</h3>

<p>This function is an R function for estimating the trend function
and its derivatives in an equidistant time series with local polynomial
regression and a fixed bandwidth given beforehand.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsmooth(y, v = 0, p = v + 1, mu = 1, b = 0.15, bb = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector that contains the time series data ordered from
past to present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>an integer <code>0</code>, <code>1</code>, ... that represents the order of
derivative that will be estimated; is set to <code>v = 0</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number (<code>v</code>)</strong> </td>
<td style="text-align: left;"> <strong>Degree of derivative</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> The function <em>f(x)</em> itself</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> The first derivative <em>f'(x)</em>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> The second derivative <em>f‚Äù(x)</em>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>...</code> </td>
<td style="text-align: left;"> ...
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer <code class="reqn">&gt;= (</code> <code>v</code> <code class="reqn">+ 1)</code> that represents the order
of polynomial; <code>p - v</code> must be an odd number; is set to <code>v + 1</code>
by default.
</p>
<p>Exemplary for <code>v = 0</code>:
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number (<code>p</code>)</strong> </td>
<td style="text-align: left;"> <strong>Polynomial</strong> </td>
<td style="text-align: center;">
<strong><code>p - v</code></strong> </td>
<td style="text-align: left;"> <strong><code>p - v</code> odd?</strong> </td>
<td style="text-align: left;">
<strong><code>p</code> usable?</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Linear </td>
<td style="text-align: center;"> 1 </td>
<td style="text-align: left;"> Yes
</td>
<td style="text-align: left;"> Yes</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Quadratic </td>
<td style="text-align: center;"> 2 </td>
<td style="text-align: left;"> No
</td>
<td style="text-align: left;"> No</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Cubic </td>
<td style="text-align: center;"> 3 </td>
<td style="text-align: left;"> Yes
</td>
<td style="text-align: left;"> Yes</td>
</tr>
<tr>
<td style="text-align: center;">
<code>...</code> </td>
<td style="text-align: left;"> ... </td>
<td style="text-align: center;"> ... </td>
<td style="text-align: left;"> ...
</td>
<td style="text-align: left;"> ...
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>an integer <code>0</code>, <code>1</code>, <code>2</code>, ... that represents the
smoothness parameter of the kernel weighting function that will be used; is
set to <code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number (<code>mu</code>)</strong> </td>
<td style="text-align: left;"> <strong>Kernel</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Triweight Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>...</code> </td>
<td style="text-align: left;"> ...
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a real number <code class="reqn">0 &lt;</code> <code>b</code> <code class="reqn">&lt; 0.5</code>; represents the
relative bandwidth that will be used for the smoothing process; is set to
<code>0.15</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bb</code></td>
<td>
<p>can be set to <code>0</code> or <code>1</code>; the parameter controlling the
bandwidth used at the boundary; is set to <code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number (<code>bb</code>)</strong> </td>
<td style="text-align: left;"> <strong>Estimation procedure at boundary
points</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Fixed bandwidth on one side with possible large
bandwidth on the other side at the boundary</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> The k-nearest neighbor method will be used
</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trend or its derivatives are estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> (see also Beran and Feng, 2002).
</p>
<p>This function is part of the package <code>smoots</code> and is used in
the field of analyzing equidistant time series data. It applies the local
polynomial regression method to the input data with an arbitrarily
selectable bandwidth. By these means, the trend as well as its derivatives
can be estimated nonparametrically, even though the result will strongly
depend on the bandwidth given beforehand as an input.
</p>
<p>NOTE:
</p>
<p>The estimates are obtained with regard to the rescaled time points on the
interval <code class="reqn">[0, 1]</code>. Thus, if <code class="reqn">\nu &gt; 0</code>, the estimates might not
reflect the values for the actual time points. To rescale the estimates, we
refer the user to the <code>rescale</code> function of the <code>smoots</code>
package.
</p>
<p>With package version 1.1.0, this function implements C++ code by means
of the <code>Rcpp</code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>The output object is a list with different components:
</p>

<dl>
<dt>b</dt>
<dd>
<p>the chosen (relative) bandwidth; input argument.</p>
</dd>
<dt>bb</dt>
<dd>
<p>the chosen bandwidth option at the boundaries; input argument.</p>
</dd>
<dt>mu</dt>
<dd>
<p>the chosen smoothness parameter for the second order kernel; input
argument.</p>
</dd>
<dt>n</dt>
<dd>
<p>the number of observations.</p>
</dd>
<dt>orig</dt>
<dd>
<p>the original input series; input argument.</p>
</dd>
<dt>p</dt>
<dd>
<p>the chosen order of polynomial; input argument.</p>
</dd>
<dt>res</dt>
<dd>
<p>a vector with the estimated residual series; is set to <code>NULL</code>
for <code>v &gt; 0</code>.</p>
</dd>
<dt>v</dt>
<dd>
<p>the order of derivative; input argument.</p>
</dd>
<dt>ws</dt>
<dd>
<p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt>
<dd>
<p>a vector with the estimates of the selected nonparametric order of
derivative on the rescaled time interval <code class="reqn">[0, 1]</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul>
<li>
<p> Yuanhua Feng (Department of Economics, Paderborn University), <br>
Author of the Algorithms <br>
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li>
<p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br>
Package Creator and Maintainer
</p>
</li>
</ul>
<h3>References</h3>

<p>Beran, J. and Feng, Y. (2002). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Feng, Y., Gries, T. and Fritz, M. (2020). Data-driven
local polynomial for the trend and its derivatives in economic time
series. Journal of Nonparametric Statistics, 32:2, 510-533.
</p>
<p>Feng, Y., Gries, T., Letmathe, S. and Schulz, D. (2019). The smoots package
in R for semiparametric modeling of trend stationary time series. Discussion
Paper. Paderborn University. Unpublished.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Logarithm of test data
test_data &lt;- gdpUS
y &lt;- log(test_data$GDP)

# Applied gsmooth function for the trend with two different bandwidths
results1 &lt;- gsmooth(y, v = 0, p = 1, mu = 1, b = 0.28, bb = 1)
results2 &lt;- gsmooth(y, v = 0, p = 1, mu = 1, b = 0.11, bb = 1)
trend1 &lt;- results1$ye
trend2 &lt;- results2$ye

# Plot of the results
t &lt;- seq(from = 1947, to = 2019.25, by = 0.25)
plot(t, y, type = "l", xlab = "Year", ylab = "log(US-GDP)", bty = "n",
 lwd = 2,
 main = "Estimated trend for log-quarterly US-GDP, Q1 1947 - Q2 2019")
points(t, trend1, type = "l", col = "red", lwd = 1)
points(t, trend2, type = "l", col = "blue", lwd = 1)
legend("bottomright", legend = c("Trend (b = 0.28)", "Trend (b = 0.11)"),
 fill = c("red", "blue"), cex = 0.6)
title(sub = expression(italic("Figure 1")), col.sub = "gray47",
 cex.sub = 0.6, adj = 0)


</code></pre>


</div>