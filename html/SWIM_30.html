<div class="container">

<table style="width: 100%;"><tr>
<td>stress_moment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stressing Moments</h2>

<h3>Description</h3>

<p>Provides weights on simulated scenarios from a baseline stochastic
model, such that stressed model components (random variables)
fulfill the moment constraints. Scenario weights are selected by
constrained minimisation of the relative entropy to the
baseline model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stress_moment(
  x,
  f,
  k,
  m,
  normalise = TRUE,
  show = FALSE,
  names = NULL,
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector, matrix or data frame
containing realisations of random variables. Columns of <code>x</code>
correspond to random variables; OR<br>
A <code>SWIM</code> object, where <code>x</code> corresponds to the
underlying data of the <code>SWIM</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A function, or list of functions, that, applied to
<code>x</code>, constitute the moment constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>A vector or list of vectors, same length as <code>f</code>,
indicating which columns of <code>x</code> each function
in <code>f</code> operates on.<br>
When <code>f</code> is a list, <code>k[[i]]</code> corresponds
to the input variables of <code>f[[i]]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Numeric vector, same length as <code>f</code>, containing
the stressed moments of <code>f(x)</code>. Must be in the
range of <code>f(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>
<p>Logical. If true, values of <code>f(x)</code> are linearly
scaled to the unit interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show</code></td>
<td>
<p>Logical. If true, print the result of the call to
<code>nleqslv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Character vector, the names of stressed models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Boolean, the option to print weights' statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to
<code>nleqslv</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The moment constraints are given by <code>E^Q( f(x) ) = m</code>,
where <code>E^Q</code> denotes the expectation under the stressed
model. <code>stress_moment</code> solves the subsequent set of equations
with respect to theta, using <code>nleqslv</code> from package
<code>nleqslv</code>:
</p>
<p style="text-align: center;"><code class="reqn">E^Q( f(x) ) = E( f(x) * exp(theta * f(x)) ) = m.</code>
</p>

<p>There is no guarantee that the set of equations
has a solution, or that the solution is unique. <code>SWIM</code> will
return a warning if the termination code provided by <code>nleqslv</code> is
different from 1 (convergence has been achieved). It is recommended to
check the result of the call to <code>nleqslv</code> using the "show" argument. The
user is referred to the <code>nleqslv</code> documentation for
further details.
</p>
<p>Normalising the data may help avoiding numerical issues when the range of values is wide.
</p>


<h3>Value</h3>

<p>A <code>SWIM</code> object containing:
</p>

<ul>
<li> <p><code>x</code>, a data.frame containing the data;
</p>
</li>
<li> <p><code>new_weights</code>, a list, each component corresponds to
a different stress and is a vector of scenario weights;
</p>
</li>
<li> <p><code>type = "moment"</code>;
</p>
</li>
<li> <p><code>specs</code>, a list, each component corresponds to
a different stress and contains <code>f</code>, <code>k</code> and <code>m</code>.
</p>
</li>
</ul>
<p>See <code>SWIM</code> for details.
</p>
<p>The function call will print a message containing the termination code returned by the call to <code>nleqslv</code> and a table with the required and achieved moment, and the absolute and relative error.
</p>


<h3>References</h3>

<p>Pesenti SM, Millossovich P, Tsanakas A (2019).
“Reverse sensitivity testing: What does it take to break the model?”
<em>European Journal of Operational Research</em>, <b>274</b>(2), 654–670.<br></p>
<p>Pesenti S BAMPTA (2020).
“Scenario Weights for Importance Measurement (SWIM) - An R package for sensitivity analysis.”
<em>Annals of Actuarial Science 15.2 (2021): 458-483. Available at SSRN: <a href="https://www.ssrn.com/abstract=3515274">https://www.ssrn.com/abstract=3515274</a></em>.<br></p>
<p>Csiszar I (1975).
“I-divergence geometry of probability distributions and minimization problems.”
<em>The Annals of Probability</em>, 146–158.
</p>


<h3>See Also</h3>

<p>See <code>stress_mean</code> for stressing means and
<code>stress_mean_sd</code> for stressing mean and standard
deviation jointly.
</p>
<p>Other stress functions: 
<code>stress_HARA_RM_w()</code>,
<code>stress_RM_mean_sd_w()</code>,
<code>stress_RM_w()</code>,
<code>stress_VaR_ES()</code>,
<code>stress_VaR()</code>,
<code>stress_mean_sd_w()</code>,
<code>stress_mean_sd()</code>,
<code>stress_mean_w()</code>,
<code>stress_mean()</code>,
<code>stress_prob()</code>,
<code>stress_user()</code>,
<code>stress_wass()</code>,
<code>stress()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(0)
x &lt;- data.frame(cbind(
  "normal" = rnorm(1000),
  "gamma" = rgamma(1000, shape = 2),
  "beta" = rbeta(1000, shape1 = 2, shape2 = 2)))

## stressing covariance of columns 1, 2 while leaving the means unchanged
res1 &lt;- stress_moment(x = x,
  f = list(function(x)x, function(x)x, function(x)x[1] * x[2]),
  k = list(1, 2, c(1, 2)), m = c(0, 2, 0.5),
  method = "Newton", control = list(maxit = 1000, ftol = 1E-10))
## means under the stressed model
summary(res1)
apply(x, 2, stats::weighted.mean, w = get_weights(res1))
## covariance of columns 1,2 under the stressed model
stats::weighted.mean(x[, 1] * x[, 2], w = get_weights(res1))

## stressing jointly the tail probabilities of columns 1, 3
res2 &lt;- stress_moment(x = x,
  f = list(function(x)(x &gt; 1.5), function(x)(x &gt; 0.9)),
  k = list(1, 3), m = c(0.9, 0.9))
summary(res2)
## probabilities under the stressed model
mean((x[, 1] &gt; 1.5) * get_weights(res2))
mean((x[, 3] &gt; 0.9) * get_weights(res2))

</code></pre>


</div>