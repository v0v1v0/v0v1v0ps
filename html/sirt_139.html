<div class="container">

<table style="width: 100%;"><tr>
<td>smirt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multidimensional Noncompensatory, Compensatory and Partially
Compensatory Item Response Model
</h2>

<h3>Description</h3>

<p>This function estimates the noncompensatory and compensatory multidimensional
item response model (Bolt &amp; Lall, 2003; Reckase, 2009) as well as
the partially compensatory item response model (Spray et al., 1990)
for dichotomous data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smirt(dat, Qmatrix, irtmodel="noncomp", est.b=NULL, est.a=NULL,
     est.c=NULL, est.d=NULL, est.mu.i=NULL, b.init=NULL, a.init=NULL,
     c.init=NULL, d.init=NULL, mu.i.init=NULL, Sigma.init=NULL,
     b.lower=-Inf, b.upper=Inf, a.lower=-Inf, a.upper=Inf,
     c.lower=-Inf, c.upper=Inf, d.lower=-Inf, d.upper=Inf,
     theta.k=seq(-6,6,len=20), theta.kDES=NULL,
     qmcnodes=0, mu.fixed=NULL, variance.fixed=NULL,  est.corr=FALSE,
     max.increment=1, increment.factor=1, numdiff.parm=0.0001,
     maxdevchange=0.1, globconv=0.001, maxiter=1000, msteps=4,
     mstepconv=0.001)

## S3 method for class 'smirt'
summary(object,...)

## S3 method for class 'smirt'
anova(object,...)

## S3 method for class 'smirt'
logLik(object,...)

## S3 method for class 'smirt'
IRT.irfprob(object,...)

## S3 method for class 'smirt'
IRT.likelihood(object,...)

## S3 method for class 'smirt'
IRT.posterior(object,...)

## S3 method for class 'smirt'
IRT.modelfit(object,...)

## S3 method for class 'IRT.modelfit.smirt'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>Data frame with dichotomous item responses
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmatrix</code></td>
<td>

<p>The Q-matrix which specifies the loadings to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irtmodel</code></td>
<td>

<p>The item response model. Options are the noncompensatory model (<code>"noncomp"</code>),
the compensatory model (<code>"comp"</code>) and
the partially compensatory model (<code>"partcomp"</code>).
See Details for more explanations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.b</code></td>
<td>

<p>An integer matrix (if <code>irtmodel="noncomp"</code>) or integer vector
(if <code>irtmodel="comp"</code>) for <code class="reqn">b</code> parameters to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.a</code></td>
<td>

<p>An integer matrix for <code class="reqn">a</code> parameters to be estimated.
If <code>est.a="2PL"</code>, then all item loadings will be estimated and the
variances are set to one (and therefore <code>est.corr=TRUE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.c</code></td>
<td>

<p>An integer vector for <code class="reqn">c</code> parameters to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.d</code></td>
<td>

<p>An integer vector for <code class="reqn">d</code> parameters to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.mu.i</code></td>
<td>

<p>An integer vector for <code class="reqn">\mu_i</code> parameters to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.init</code></td>
<td>

<p>Initial <code class="reqn">b</code> coefficients. For <code>irtmodel="noncomp"</code> it must be a
matrix, for <code>irtmodel="comp"</code> it is a vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.init</code></td>
<td>

<p>Initial <code class="reqn">a</code> coefficients arranged in a matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.init</code></td>
<td>

<p>Initial <code class="reqn">c</code> coefficients
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.init</code></td>
<td>

<p>Initial <code class="reqn">d</code> coefficients
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.i.init</code></td>
<td>

<p>Initial <code class="reqn">d</code> coefficients
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma.init</code></td>
<td>

<p>Initial covariance matrix <code class="reqn">\Sigma</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.lower</code></td>
<td>
<p>Lower bound for <code class="reqn">b</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.upper</code></td>
<td>
<p>Upper bound for <code class="reqn">b</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.lower</code></td>
<td>
<p>Lower bound for <code class="reqn">a</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.upper</code></td>
<td>
<p>Upper bound for <code class="reqn">a</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.lower</code></td>
<td>
<p>Lower bound for <code class="reqn">c</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.upper</code></td>
<td>
<p>Upper bound for <code class="reqn">c</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.lower</code></td>
<td>
<p>Lower bound for <code class="reqn">d</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.upper</code></td>
<td>
<p>Upper bound for <code class="reqn">d</code> parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>

<p>Vector of discretized trait distribution. This vector is expanded in all
dimensions by using the <code>base::expand.grid</code>
function. If a user specifies a design matrix <code>theta.kDES</code> of transformed
<code class="reqn">\bold{\theta}_p</code>
values (see Details and Examples), then <code>theta.k</code> must be a matrix, too.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.kDES</code></td>
<td>

<p>An optional design matrix. This matrix will differ from the ordinary
theta grid in case of nonlinear item response models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmcnodes</code></td>
<td>

<p>Number of integration nodes for quasi Monte Carlo integration (see Pan &amp;
Thompson, 2007; Gonzales et al., 2006). Integration points are obtained by using
the function <code>qmc.nodes</code>. Note that when using quasi Monte Carlo nodes,
no theta design matrix <code>theta.kDES</code> can be specified.
See Example 1, Model 11.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.fixed</code></td>
<td>

<p>Matrix with fixed entries in the mean vector. By default, all means
are set to zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance.fixed</code></td>
<td>

<p>Matrix (with rows and three columns) with fixed entries in the covariance matrix
(see Examples). The entry <code class="reqn">c_{kd}</code> of the covariance between dimensions
<code class="reqn">k</code> and <code class="reqn">d</code> is set to <code class="reqn">c_0</code> iff <code>variance.fixed</code> has a row with
a <code class="reqn">k</code> in the first column, a <code class="reqn">d</code> in the second column and the value
<code class="reqn">c_0</code> in the third column.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.corr</code></td>
<td>

<p>Should only a correlation matrix instead of a covariance matrix
be estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.increment</code></td>
<td>

<p>Maximum increment
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>increment.factor</code></td>
<td>

<p>A value (larger than one) which defines the extent of the decrease of the maximum
increment of item parameters in every iteration. The maximum increment in iteration
<code>iter</code> is defined as <code>max.increment*increment.factor^(-iter)</code>
where <code>max.increment=1</code>. Using a value larger than 1 helps
to reach convergence in some non-converging analyses (use values of 1.01, 1.02
or even 1.05). See also Example 1 Model 2a.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.parm</code></td>
<td>

<p>Numerical differentiation parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdevchange</code></td>
<td>

<p>Convergence criterion for change in relative deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globconv</code></td>
<td>

<p>Global convergence criterion for parameter change
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msteps</code></td>
<td>

<p>Number of iterations within a M step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstepconv</code></td>
<td>

<p>Convergence criterion within a M step
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>smirt</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The noncompensatory item response model (<code>irtmodel="noncomp"</code>;
e.g. Bolt &amp; Lall, 2003) is defined as
</p>
<p style="text-align: center;"><code class="reqn">P(X_{pi}=1 | \bold{\theta}_p )=c_i + (d_i - c_i )
\prod_l invlogit( a_{il} q_{il}  \theta_{pl} - b_{il} ) </code>
</p>

<p>where <code class="reqn">i</code>, <code class="reqn">p</code>, <code class="reqn">l</code> denote items, persons and dimensions
respectively.
</p>
<p>The compensatory item response model (<code>irtmodel="comp"</code>) is defined by
</p>
<p style="text-align: center;"><code class="reqn">P(X_{pi}=1 | \bold{\theta}_p )=c_i + (d_i - c_i )
invlogit( \sum_l  a_{il}  q_{il} \theta_{pl} - b_{i} ) </code>
</p>

<p>Using a design matrix <code>theta.kDES</code> the model can be made even more general
in a model which is linear in item parameters
</p>
<p style="text-align: center;"><code class="reqn">P(X_{pi}=1 | \bold{\theta}_p )=c_i + (d_i - c_i )
invlogit( \sum_l  a_{il}  q_{il} t_l ( \bold{ \theta_{p} } )   - b_{i} ) </code>
</p>

<p>with known functions <code class="reqn">t_l</code> of the trait vector <code class="reqn">\bold{\theta}_p</code>.
Fixed values of the functions <code class="reqn">t_l</code> are specified in the
<code class="reqn">\bold{\theta}_p</code> design matrix <code>theta.kDES</code>.
</p>
<p>The partially compensatory item response model (<code>irtmodel="partcomp"</code>)
is defined by
</p>
<p style="text-align: center;"><code class="reqn">P(X_{pi}=1 | \bold{\theta}_p )=c_i + (d_i - c_i )
\frac{ \exp \left( \sum_l ( a_{il}  q_{il} \theta_{pl} - b_{il} ) \right) }
{  \mu_i \prod_l ( 1 + \exp ( a_{il}  q_{il} \theta_{pl} - b_{il} ) ) +
    ( 1- \mu_i) ( 1 + \exp \left( \sum_l  ( a_{il}  q_{il} \theta_{pl} - b_{il} ) \right) )
        } </code>
</p>

<p>with item parameters <code class="reqn">\mu_i</code> indicating the degree of compensatory.
<code class="reqn">\mu_i=1</code> indicates a noncompensatory model while <code class="reqn">\mu_i=0</code>
indicates a (fully) compensatory model.
</p>
<p>The models are estimated by an EM algorithm employing marginal maximum
likelihood.
</p>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Data frame with item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>Data frame with person parameters. It includes
the person mean of all item responses (<code>M</code>; percentage correct
of all non-missing items), the
EAP estimate and its corresponding standard error for all dimensions
(<code>EAP</code> and <code>SE.EAP</code>) and the maximum likelihood estimate
as well as the mode of the posterior distribution (<code>MLE</code> and <code>MAP</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EAP.rel</code></td>
<td>
<p>EAP reliability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.trait</code></td>
<td>
<p>Means of trait</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.trait</code></td>
<td>
<p>Standard deviations of trait</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>Trait covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor.trait</code></td>
<td>
<p>Trait correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Matrix (vector) of <code class="reqn">b</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.b</code></td>
<td>
<p>Matrix (vector) of standard errors <code class="reqn">b</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Matrix of <code class="reqn">a</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.a</code></td>
<td>
<p>Matrix of standard errors of <code class="reqn">a</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>Vector of <code class="reqn">c</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.c</code></td>
<td>
<p>Vector of standard errors of <code class="reqn">c</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Vector of <code class="reqn">d</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.d</code></td>
<td>
<p>Vector of standard errors of <code class="reqn">d</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.i</code></td>
<td>
<p>Vector of <code class="reqn">\mu_i</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.mu.i</code></td>
<td>
<p>Vector of standard errors of <code class="reqn">\mu_i</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.yi.qk</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.qk.yi</code></td>
<td>
<p>Individual posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Probabilities of item response functions evaluated at <code>theta.k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ik</code></td>
<td>
<p>Expected counts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat2</code></td>
<td>
<p>Processed data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat2.resp</code></td>
<td>
<p>Data set of response indicators</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>Number of items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Number of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Maximum item response score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>
<p>Used theta integration grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.k</code></td>
<td>
<p>Distribution function evaluated at <code>theta.k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irtmodel</code></td>
<td>
<p>Used IRT model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmatrix</code></td>
<td>
<p>Used Q-matrix</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bolt, D. M., &amp; Lall, V. F. (2003). Estimation of compensatory and
noncompensatory multidimensional item response models using Markov chain
Monte Carlo. <em>Applied Psychological Measurement, 27</em>, 395-414.
</p>
<p>Gonzalez, J., Tuerlinckx, F., De Boeck, P., &amp; Cools, R. (2006).
Numerical integration in logistic-normal models.
<em>Computational Statistics &amp; Data Analysis, 51</em>, 1535-1548.
</p>
<p>Pan, J., &amp; Thompson, R. (2007). Quasi-Monte Carlo estimation in
generalized linear mixed models. <em>Computational Statistics &amp;
Data Analysis, 51</em>, 5765-5775.
</p>
<p>Reckase, M. (2009). <em>Multidimensional item response theory</em>.
New York: Springer. <a href="https://doi.org/10.1007/978-0-387-89976-3">doi:10.1007/978-0-387-89976-3</a>
</p>
<p>Spray, J. A., Davey, T. C., Reckase, M. D., Ackerman, T. A., &amp; Carlson, J. E. (1990).
<em>Comparison of two logistic multidimensional item response theory models</em>.
ACT Research Report No. ACT-RR-ONR-90-8.
</p>


<h3>See Also</h3>

<p>See the <code>mirt::mirt</code> and
<code>itemtype="partcomp"</code> for estimating noncompensatory item response models
using the <span class="pkg">mirt</span> package. See also <code>mirt::mixedmirt</code>.
</p>
<p>Other multidimensional IRT models can also be estimated
with <code>rasch.mml2</code> and <code>rasch.mirtlc</code>.
</p>
<p>See <code>itemfit.sx2</code> (<span class="pkg">CDM</span>) for item fit
statistics.
</p>
<p>See also the <span class="pkg">mirt</span> and <span class="pkg">TAM</span> packages for estimation of
compensatory multidimensional item response models.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
## EXAMPLE 1: Noncompensatory and compensatory IRT models
#############################################################################
set.seed(997)

# (1) simulate data from a two-dimensional noncompensatory
#     item response model
#   -&gt; increase number of iterations in all models!

N &lt;- 1000    # number of persons
I &lt;- 10        # number of items
theta0 &lt;- rnorm( N, sd=1 )
theta1 &lt;- theta0 + rnorm(N, sd=.7 )
theta2 &lt;- theta0 + rnorm(N, sd=.7 )
Q &lt;- matrix( 1, nrow=I,ncol=2 )
Q[ 1:(I/2), 2 ] &lt;- 0
Q[ I,1] &lt;- 0
b &lt;- matrix( rnorm( I*2 ), I, 2 )
a &lt;- matrix( 1, I, 2 )

# simulate data
prob &lt;- dat &lt;- matrix(0, nrow=N, ncol=I )
for (ii in 1:I){
prob[,ii] &lt;- ( stats::plogis( theta1 - b[ii,1]  ) )^Q[ii,1]
prob[,ii] &lt;- prob[,ii] * ( stats::plogis( theta2 - b[ii,2]  ) )^Q[ii,2]
            }
dat[ prob &gt; matrix( stats::runif( N*I),N,I) ] &lt;- 1
colnames(dat) &lt;- paste0("I",1:I)

#***
# Model 1: Noncompensatory 1PL model
mod1 &lt;- sirt::smirt(dat, Qmatrix=Q, maxiter=10 ) # change number of iterations
summary(mod1)

## Not run: 
#***
# Model 2: Noncompensatory 2PL model
mod2 &lt;- sirt::smirt(dat,Qmatrix=Q, est.a="2PL", maxiter=15 )
summary(mod2)

# Model 2a: avoid convergence problems with increment.factor
mod2a &lt;- sirt::smirt(dat,Qmatrix=Q, est.a="2PL", maxiter=30, increment.factor=1.03)
summary(mod2a)

#***
# Model 3: some fixed c and d parameters different from zero or one
c.init &lt;- rep(0,I)
c.init[ c(3,7)] &lt;- .2
d.init &lt;- rep(1,I)
d.init[c(4,8)] &lt;- .95
mod3 &lt;- sirt::smirt( dat, Qmatrix=Q, c.init=c.init, d.init=d.init )
summary(mod3)

#***
# Model 4: some estimated c and d parameters (in parameter groups)
est.c &lt;- c.init &lt;- rep(0,I)
c.estpars &lt;- c(3,6,7)
c.init[ c.estpars ] &lt;- .2
est.c[c.estpars] &lt;- 1
est.d &lt;- rep(0,I)
d.init &lt;- rep(1,I)
d.estpars &lt;- c(6,9)
d.init[ d.estpars ] &lt;- .95
est.d[ d.estpars ] &lt;- d.estpars   # different d parameters
mod4 &lt;- sirt::smirt(dat,Qmatrix=Q, est.c=est.c, c.init=c.init,
            est.d=est.d, d.init=d.init  )
summary(mod4)

#***
# Model 5: Unidimensional 1PL model
Qmatrix &lt;- matrix( 1, nrow=I, ncol=1 )
mod5 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix )
summary(mod5)

#***
# Model 6: Unidimensional 2PL model
mod6 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix, est.a="2PL" )
summary(mod6)

#***
# Model 7: Compensatory model with between item dimensionality
# Note that the data is simulated under the noncompensatory condition
# Therefore Model 7 should have a worse model fit than Model 1
Q1 &lt;- Q
Q1[ 6:10, 1] &lt;- 0
mod7 &lt;- sirt::smirt(dat,Qmatrix=Q1, irtmodel="comp", maxiter=30)
summary(mod7)

#***
# Model 8: Compensatory model with within item dimensionality
#         assuming zero correlation between dimensions
variance.fixed &lt;- as.matrix( cbind( 1,2,0) )
# set the covariance between the first and second dimension to zero
mod8 &lt;- sirt::smirt(dat,Qmatrix=Q, irtmodel="comp", variance.fixed=variance.fixed,
            maxiter=30)
summary(mod8)

#***
# Model 8b: 2PL model with starting values for a and b parameters
b.init &lt;- rep(0,10)  # set all item difficulties initially to zero
# b.init &lt;- NULL
a.init &lt;- Q       # initialize a.init with Q-matrix
# provide starting values for slopes of first three items on Dimension 1
a.init[1:3,1] &lt;- c( .55, .32, 1.3)

mod8b &lt;- sirt::smirt(dat,Qmatrix=Q, irtmodel="comp", variance.fixed=variance.fixed,
              b.init=b.init, a.init=a.init, maxiter=20, est.a="2PL" )
summary(mod8b)

#***
# Model 9: Unidimensional model with quadratic item response functions
# define theta
theta.k &lt;- seq( - 6, 6, len=15 )
theta.k &lt;- as.matrix( theta.k, ncol=1 )
# define design matrix
theta.kDES &lt;- cbind( theta.k[,1], theta.k[,1]^2 )
# define Q-matrix
Qmatrix &lt;- matrix( 0, I, 2 )
Qmatrix[,1] &lt;- 1
Qmatrix[ c(3,6,7), 2 ] &lt;- 1
colnames(Qmatrix) &lt;- c("F1", "F1sq" )
# estimate model
mod9 &lt;- sirt::smirt(dat,Qmatrix=Qmatrix, maxiter=50, irtmodel="comp",
           theta.k=theta.k, theta.kDES=theta.kDES, est.a="2PL" )
summary(mod9)

#***
# Model 10: Two-dimensional item response model with latent interaction
#           between dimensions
theta.k &lt;- seq( - 6, 6, len=15 )
theta.k &lt;- expand.grid( theta.k, theta.k )    # expand theta to 2 dimensions
# define design matrix
theta.kDES &lt;- cbind( theta.k, theta.k[,1]*theta.k[,2] )
# define Q-matrix
Qmatrix &lt;- matrix( 0, I, 3 )
Qmatrix[,1] &lt;- 1
Qmatrix[ 6:10, c(2,3) ] &lt;- 1
colnames(Qmatrix) &lt;- c("F1", "F2", "F1iF2" )
# estimate model
mod10 &lt;- sirt::smirt(dat,Qmatrix=Qmatrix,irtmodel="comp", theta.k=theta.k,
            theta.kDES=theta.kDES, est.a="2PL" )
summary(mod10)

#****
# Model 11: Example Quasi Monte Carlo integration
Qmatrix &lt;- matrix( 1, I, 1 )
mod11 &lt;- sirt::smirt( dat, irtmodel="comp", Qmatrix=Qmatrix, qmcnodes=1000 )
summary(mod11)

#############################################################################
## EXAMPLE 2: Dataset Reading data.read
##            Multidimensional models for dichotomous data
#############################################################################

data(data.read)
dat &lt;- data.read
I &lt;- ncol(dat)    # number of items

#***
# Model 1: 3-dimensional 2PL model

# define Q-matrix
Qmatrix &lt;- matrix(0,nrow=I,ncol=3)
Qmatrix[1:4,1] &lt;- 1
Qmatrix[5:8,2] &lt;- 1
Qmatrix[9:12,3] &lt;- 1

# estimate model
mod1 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix, irtmodel="comp", est.a="2PL",
            qmcnodes=1000, maxiter=20)
summary(mod1)

#***
# Model 2: 3-dimensional Rasch model
mod2 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix, irtmodel="comp",
              qmcnodes=1000, maxiter=20)
summary(mod2)

#***
# Model 3: 3-dimensional 2PL model with uncorrelated dimensions
# fix entries in variance matrix
variance.fixed &lt;- cbind( c(1,1,2), c(2,3,3), 0 )
# set the following covariances to zero: cov[1,2]=cov[1,3]=cov[2,3]=0

# estimate model
mod3 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix, irtmodel="comp", est.a="2PL",
             variance.fixed=variance.fixed, qmcnodes=1000, maxiter=20)
summary(mod3)

#***
# Model 4: Bifactor model with one general factor (g) and
#          uncorrelated specific factors

# define a new Q-matrix
Qmatrix1 &lt;- cbind( 1, Qmatrix )
# uncorrelated factors
variance.fixed &lt;- cbind( c(1,1,1,2,2,3), c(2,3,4,3,4,4), 0 )
# The first dimension refers to the general factors while the other
# dimensions refer to the specific factors.
# The specification means that:
# Cov[1,2]=Cov[1,3]=Cov[1,4]=Cov[2,3]=Cov[2,4]=Cov[3,4]=0

# estimate model
mod4 &lt;- sirt::smirt( dat, Qmatrix=Qmatrix1, irtmodel="comp", est.a="2PL",
             variance.fixed=variance.fixed, qmcnodes=1000, maxiter=20)
summary(mod4)

#############################################################################
## EXAMPLE 3: Partially compensatory model
#############################################################################

#**** simulate data
set.seed(7656)
I &lt;- 10         # number of items
N &lt;- 2000        # number of subjects
Q &lt;- matrix( 0, 3*I,2)  # Q-matrix
Q[1:I,1] &lt;- 1
Q[1:I + I,2] &lt;- 1
Q[1:I + 2*I,1:2] &lt;- 1
b &lt;- matrix( stats::runif( 3*I *2, -2, 2 ), nrow=3*I, 2 )
b &lt;- b*Q
b &lt;- round( b, 2 )
mui &lt;- rep(0,3*I)
mui[ seq(2*I+1, 3*I) ] &lt;- 0.65
# generate data
dat &lt;- matrix( NA, N, 3*I )
colnames(dat) &lt;- paste0("It", 1:(3*I) )
# simulate item responses
library(mvtnorm)
theta &lt;- mvtnorm::rmvnorm(N, mean=c(0,0), sigma=matrix( c( 1.2, .6,.6,1.6),2, 2 ) )
for (ii in 1:(3*I)){
    # define probability
    tmp1 &lt;- exp( theta[,1] * Q[ii,1] - b[ii,1] +  theta[,2] * Q[ii,2] - b[ii,2] )
    # non-compensatory model
    nco1 &lt;- ( 1 + exp( theta[,1] * Q[ii,1] - b[ii,1] ) ) *
                  ( 1 + exp( theta[,2] * Q[ii,2] - b[ii,2] ) )
    co1 &lt;- ( 1 + tmp1 )
    p1 &lt;- tmp1 / ( mui[ii] * nco1 + ( 1 - mui[ii] )*co1 )
    dat[,ii] &lt;- 1 * ( stats::runif(N) &lt; p1 )
}

#*** Model 1: Joint mu.i parameter for all items
est.mu.i &lt;- rep(0,3*I)
est.mu.i[ seq(2*I+1,3*I)] &lt;- 1
mod1 &lt;- sirt::smirt( dat, Qmatrix=Q, irtmodel="partcomp", est.mu.i=est.mu.i)
summary(mod1)

#*** Model 2: Separate mu.i parameter for all items
est.mu.i[ seq(2*I+1,3*I)] &lt;- 1:I
mod2 &lt;- sirt::smirt( dat, Qmatrix=Q, irtmodel="partcomp", est.mu.i=est.mu.i)
summary(mod2)

## End(Not run)
</code></pre>


</div>