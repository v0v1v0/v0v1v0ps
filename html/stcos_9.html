<div class="container">

<table style="width: 100%;"><tr>
<td>areal_spacetime_bisquare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Areal Space-Time Bisquare Basis</h2>

<h3>Description</h3>

<p>Space-Time bisquare basis on areal data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">areal_spacetime_bisquare(dom, period, knots, w_s, w_t, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dom</code></td>
<td>
<p>An <code>sf</code> or <code>sfc</code> object with areas
<code class="reqn">A_1, \ldots, A_n</code> to evaluate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A numeric vector of time periods <code class="reqn">v_1, \ldots, v_m</code>
to evaluate for each area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>Spatio-temporal knots
<code class="reqn">(\bm{c}_1,g_1), \ldots, (\bm{c}_r,g_r)</code>
for the basis. See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_s</code></td>
<td>
<p>Spatial radius for the basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_t</code></td>
<td>
<p>Temporal radius for the basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A <code>list</code> of control arguments. See "Details".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li> <p><code>knots</code> may be provided as either an <code>sf</code> or <code>sfc</code> object, or as a
matrix of points.
</p>
</li>
<li>
<p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
three-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 3</code> numeric matrix.
</p>
</li>
<li>
<p> If <code>knots</code> is an <code>sf</code> or <code>sfc</code> object, it is checked
to ensure the coordinate system matches <code>dom</code>.
</p>
</li>
</ul>
<p>For each area <code class="reqn">A</code> in the given domain, and time period
<code class="reqn">\bm{v} = (v_1, \ldots, v_m)</code> compute the basis
functions
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) = \frac{1}{m} \sum_{k=1}^m \frac{1}{|A|} \int_A \psi_j(\bm{u},v_k) d\bm{u},
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>. Here, <code class="reqn">\varphi_j{(\bm{u},v)}</code>
represent spacetime_bisquare basis functions defined at the point
level using <code class="reqn">\bm{c}_j</code>, <code class="reqn">g_j</code>, <code class="reqn">w_s</code>, and <code class="reqn">w_t</code>.
</p>
<p>The basis requires an integration which may be computed using one
of two methods. The <code>mc</code> method uses a Monte Carlo approximation
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{Q} \sum_{q=1}^Q \psi_j(\bm{u}_q, v_k),
</code>
</p>

<p>based on a random sample of locations <code class="reqn">\bm{u}_1, \ldots, \bm{u}_Q</code> from
a uniform distribution on area <code class="reqn">A</code>. The <code>rect</code> method uses
a simple quadrature approximation
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{|A|}  \sum_{a=1}^{n_x} \sum_{b=1}^{n_y} \psi_j(\bm{u}_{ab}, v_k)
I(\bm{u}_{ab} \in A) \Delta_x \Delta_y.
</code>
</p>

<p>Here, the bounding box <code>st_bbox(A)</code> is divided evenly into a grid of
<code class="reqn">n_x \times n_y</code> rectangles, each of size <code class="reqn">\Delta_x \times \Delta_y</code>.
Each <code class="reqn">\bm{u}_{ab} = (u_a, u_b)</code> is a point from the <code class="reqn">(a,b)</code>th
rectangle, for <code class="reqn">a = 1, \ldots, n_x</code> and <code class="reqn">b = 1, \ldots, n_y</code>.
</p>
<p>Due to the treatment of <code class="reqn">A_i</code> and <code class="reqn">\bm{c}_j</code> as objects in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>
<p>The <code>control</code> argument is a list which may provide any of the following:
</p>

<ul>
<li> <p><code>method</code> specifies computation method: <code>mc</code> or <code>rect</code>.
Default is <code>mc</code>.
</p>
</li>
<li> <p><code>mc_reps</code> is number of repetitions to use for <code>mc</code>.
Default is 1000.
</p>
</li>
<li> <p><code>nx</code> is number of x-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>ny</code> is number of y-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>report_period</code> is an integer; print a message with progress each
time this many areas are processed. Default is <code>Inf</code> so that message
is suppressed.
</p>
</li>
<li> <p><code>verbose</code> is a logical; if <code>TRUE</code> print descriptive
messages about the computation. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>mc_sampling_factor</code> is a positive number; an oversampling factor
used to compute <code>blocksize</code> in the rdomain function. I.e.,
<code>blocksize = ceiling(mc_sampling_factor * mc_reps)</code>. Default
is 1.2.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\psi_1^{(m)}(A_i), \ldots, \psi_r^{(m)}(A_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code>areal_spatial_bisquare()</code>,
<code>spacetime_bisquare()</code>,
<code>spatial_bisquare()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
seq_t = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y, t = seq_t)
knots_sf = st_as_sf(knots, coords = c("x","y","t"), crs = NA, dim = "XYM", agr = "constant")

# Create a simple domain (of rectangles) to evaluate
shape1 = matrix(c(0.0,0.0, 0.5,0.0, 0.5,0.5, 0.0,0.5, 0.0,0.0), ncol=2, byrow=TRUE)
shape2 = shape1 + cbind(rep(0.5,5), rep(0.0,5))
shape3 = shape1 + cbind(rep(0.0,5), rep(0.5,5))
shape4 = shape1 + cbind(rep(0.5,5), rep(0.5,5))
sfc = st_sfc(
   st_polygon(list(shape1)),
   st_polygon(list(shape2)),
   st_polygon(list(shape3)),
   st_polygon(list(shape4))
)
dom = st_sf(data.frame(geoid = 1:length(sfc), geom = sfc))

rad = 0.5
period = c(0.4, 0.7)
areal_spacetime_bisquare(dom, period, knots, w = rad, w_t = 1)
areal_spacetime_bisquare(dom, period, knots_sf, w_s = rad, w_t = 1)

# Plot the (spatial) knots and the (spatial) domain at which we evaluated
# the basis.
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
plot(dom[,1], col = NA, add = TRUE)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>


</div>