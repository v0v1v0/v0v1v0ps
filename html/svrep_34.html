<div class="container">

<table style="width: 100%;"><tr>
<td>make_twophase_quad_form</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine quadratic forms from each phase of a two phase design</h2>

<h3>Description</h3>

<p>This function combines quadratic forms from each phase of a two phase design,
so that the combined variance of the entire two-phase sampling design can be estimated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_twophase_quad_form(
  sigma_1,
  sigma_2,
  phase_2_joint_probs,
  ensure_psd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sigma_1</code></td>
<td>
<p>The quadratic form for the first phase variance estimator,
subsetted to only include cases selected in the phase two sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma_2</code></td>
<td>
<p>The quadratic form for the second phase variance estimator,
conditional on the selection of the first phase sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase_2_joint_probs</code></td>
<td>
<p>The matrix of conditional joint
inclusion probabilities for the second phase, given the selected
first phase sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ensure_psd</code></td>
<td>
<p>If <code>TRUE</code> (the default), ensures
that the result is a positive semidefinite matrix. This
is necessary if the quadratic form is used as an input for
replication methods such as the generalized bootstrap.
For details, see the help section entitled
"Ensuring the Result is Positive Semidefinite".</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A quadratic form matrix that can be used to estimate
the sampling variance from a two-phase sample design.
</p>


<h3>Statistical Details</h3>

<p>The two-phase variance estimator has a quadratic form matrix <code class="reqn">\boldsymbol{\Sigma}_{ab}</code> given by:
</p>
<p style="text-align: center;"><code class="reqn">
  \boldsymbol{\Sigma}_{ab} = {W}^{-1}_b(\boldsymbol{\Sigma}_{a^\prime} \circ D_b ){W}^{-1}_b + \boldsymbol{\Sigma}_b
</code>
</p>

<p>The first term estimates the variance contribution from the first phase of sampling,
while the second term estimates the variance contribution from the second phase of sampling. <br></p>
<p>The full quadratic form of the variance estimator is:
</p>
<p style="text-align: center;"><code class="reqn">
  v(\hat{t_y}) = \breve{\breve{y^{'}}} \boldsymbol{\Sigma}_{ab} \breve{\breve{y}}
</code>
</p>

<p>where the weighted variable <code class="reqn">\breve{\breve{y}}_k = \frac{y_k}{\pi_{ak}\pi_{bk}}</code>,
is formed using the first phase inclusion probability, denoted <code class="reqn">\pi_{ak}</code>, and
the conditional second phase inclusion probability (given the selected first phase sample),
denoted <code class="reqn">\pi_{bk}</code>. <br></p>
<p>The notation for this estimator is as follows: <br></p>

<ul>
<li> <p><code class="reqn">n_a</code> denotes the first phase sample size.
</p>
</li>
<li> <p><code class="reqn">n_b</code> denotes the second phase sample size.
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{\Sigma}_a</code> denotes the matrix of dimension <code class="reqn">n_a \times n_a</code>
representing the quadratic form for the variance estimator
used for the full first-phase design.
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{\Sigma}_{a^\prime}</code> denotes the matrix of dimension <code class="reqn">n_b \times n_b</code>
formed by subsetting the rows and columns of <code class="reqn">\boldsymbol{\Sigma}_a</code> to only include
cases selected in the second-phase sample.
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{\Sigma}_{b}</code> denotes
the matrix of dimension <code class="reqn">n_b \times n_b</code> representing the Horvitz-Thompson
estimator of variance for the second-phase sample, conditional on the selected
first-phase sample.
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{D}_b</code> denotes the <code class="reqn">n_b \times n_b</code> matrix of weights formed by the inverses of
the second-phase joint inclusion probabilities, with element <code class="reqn">kl</code> equal to <code class="reqn">\pi_{bkl}^{-1}</code>,
where <code class="reqn">\pi_{bkl}</code> is the conditional probability that units <code class="reqn">k</code> and <code class="reqn">l</code> are included
in the second-phase sample, given the selected first-phase sample. Note that this
matrix will often not be positive semidefinite, and so the two-phase variance estimator
has a quadratic form which is not necessarily positive semidefinite.
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{W}_b</code> denotes the diagonal <code class="reqn">n_b \times n_b</code> matrix
whose <code class="reqn">k</code>-th diagonal entry is the second-phase weight <code class="reqn">\pi_{bk}^{-1}</code>,
where <code class="reqn">\pi_{bk}</code> is the conditional probability that unit <code class="reqn">k</code>
is included in the second-phase sample, given the selected first-phase sample.
</p>
</li>
</ul>
<h3>Ensuring the Result is Positive Semidefinite</h3>

<p>Note that the matrix <code class="reqn">(\boldsymbol{\Sigma}_{a^\prime} \circ D_b )</code> may not be
positive semidefinite, since the matrix <code class="reqn">D_b</code> is not guaranteed to be positive semidefinite.
If <code class="reqn">(\boldsymbol{\Sigma}_{a^\prime} \circ D_b )</code> is found not to be positive semidefinite,
then it is approximated by the nearest positive semidefinite matrix in the Frobenius norm,
using the method of Higham (1988). <br><br>
This approximation is discussed by Beaumont and Patak (2012) in the context
of forming replicate weights for two-phase samples. The authors argue that
this approximation should lead to only a small overestimation of variance. <br><br>
Since <code class="reqn">(\boldsymbol{\Sigma}_{a^\prime} \circ D_b )</code>
is a real, symmetric matrix, this is equivalent to "zeroing out" negative eigenvalues.
To be more precise, denote <code class="reqn">A=(\boldsymbol{\Sigma}_{a^\prime} \circ D_b )</code>.
Then we can form the spectral decomposition <code class="reqn">A=\Gamma \Lambda \Gamma^{\prime}</code>, where <code class="reqn">\Lambda</code> is the diagonal matrix
whose entries are eigenvalues of <code class="reqn">A</code>. The method of Higham (1988)
is to  approximate
<code class="reqn">A</code> with <code class="reqn">\tilde{A} = \Gamma \Lambda_{+} \Gamma^{\prime}</code>,
where the <code class="reqn">ii</code>-th entry of <code class="reqn">\Lambda_{+}</code> is <code class="reqn">\max(\Lambda_{ii}, 0)</code>.
</p>


<h3>References</h3>

<p>See Section 7.5 of Tillé (2020) or Section 9.3 of Särndal, Swensson, and Wretman (1992)
for an overview of variance estimation for two-phase sampling. In the case where
the Horvitz-Thompson variance estimator is used for both phases, the method used in this function
is equivalent to equation (9.3.8) of Särndal, Swensson, and Wretman (1992)
and equation (7.7) of Tillé (2020). However, this function can be used
for any combination of first-phase and second-phase variance estimators,
provided that the joint inclusion probabilities from the second-phase design
are available and are all nonzero.
<br><br></p>

<ul>
<li>
<p> Beaumont, Jean-François, and Zdenek Patak. (2012). “On the Generalized Bootstrap for Sample Surveys with Special Attention to Poisson Sampling: Generalized Bootstrap for Sample Surveys.”
International Statistical Review 80 (1): 127–48.
<br><br></p>
</li>
<li>
<p> Higham, N. J. (1988). "<em>Computing a nearest symmetric positive semidefinite matrix.</em>" Linear Algebra and Its Applications, 103, 103–118.
<br><br></p>
</li>
<li>
<p> Särndal, C.-E., Swensson, B., &amp; Wretman, J. (1992). "<em>Model Assisted Survey Sampling</em>." Springer New York.
<br><br></p>
</li>
<li>
<p> Tillé, Y. (2020). "<em>Sampling and estimation from finite populations</em>." (I. Hekimi, Trans.). Wiley.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>For each phase of sampling, the function
make_quad_form_matrix can be used to create
the appropriate quadratic form matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

## ---------------------- Example 1 ------------------------##
## First phase is a stratified multistage sample            ##
## Second phase is a simple random sample                   ##
##----------------------------------------------------------##
data('library_multistage_sample', package = 'svrep')

# Load first-phase sample
  twophase_sample &lt;- library_multistage_sample

# Select second-phase sample
  set.seed(2022)

  twophase_sample[['SECOND_PHASE_SELECTION']] &lt;- sampling::srswor(
    n = 100,
    N = nrow(twophase_sample)
  ) |&gt; as.logical()

# Declare survey design
  twophase_design &lt;- twophase(
    method = "full",
    data = twophase_sample,
    # Identify the subset of first-phase elements
    # which were selected into the second-phase sample
    subset = ~ SECOND_PHASE_SELECTION,
    # Describe clusters, probabilities, and population sizes
    # at each phase of sampling
    id = list(~ PSU_ID + SSU_ID,
              ~ 1),
    probs = list(~ PSU_SAMPLING_PROB + SSU_SAMPLING_PROB,
                 NULL),
    fpc = list(~ PSU_POP_SIZE + SSU_POP_SIZE,
               NULL)
  )

# Get quadratic form matrix for the first phase design
  first_phase_sigma &lt;- get_design_quad_form(
    design = twophase_design$phase1$full,
    variance_estimator = "Stratified Multistage SRS"
  )

# Subset to only include cases sampled in second phase

  first_phase_sigma &lt;- first_phase_sigma[twophase_design$subset,
                                         twophase_design$subset]

# Get quadratic form matrix for the second-phase design
  second_phase_sigma &lt;- get_design_quad_form(
    design = twophase_design$phase2,
    variance_estimator = "Ultimate Cluster"
  )

# Get second-phase joint probabilities
  n &lt;- twophase_design$phase2$fpc$sampsize[1,1]
  N &lt;- twophase_design$phase2$fpc$popsize[1,1]

  second_phase_joint_probs &lt;- Matrix::Matrix((n/N)*((n-1)/(N-1)),
                                     nrow = n, ncol = n)
  diag(second_phase_joint_probs) &lt;- rep(n/N, times = n)

# Get quadratic form for entire two-phase variance estimator
  twophase_quad_form &lt;- make_twophase_quad_form(
   sigma_1 = first_phase_sigma,
   sigma_2 = second_phase_sigma,
   phase_2_joint_probs = second_phase_joint_probs
 )

 # Use for variance estimation

   rep_factors &lt;- make_gen_boot_factors(
     Sigma = twophase_quad_form,
     num_replicates = 500
   )

   library(survey)

   combined_weights &lt;- 1/twophase_design$prob

   twophase_rep_design &lt;- svrepdesign(
     data = twophase_sample |&gt;
       subset(SECOND_PHASE_SELECTION),
     type = 'other',
     repweights = rep_factors,
     weights = combined_weights,
     combined.weights = FALSE,
     scale = attr(rep_factors, 'scale'),
     rscales = attr(rep_factors, 'rscales')
   )

   svymean(x = ~ LIBRARIA, design = twophase_rep_design)


## ---------------------- Example 2 ------------------------##
## First phase is a stratified systematic sample            ##
## Second phase is nonresponse, modeled as Poisson sampling ##
##----------------------------------------------------------##

data('library_stsys_sample', package = 'svrep')

# Determine quadratic form for full first-phase sample variance estimator

  full_phase1_quad_form &lt;- make_quad_form_matrix(
    variance_estimator = "SD2",
    cluster_ids = library_stsys_sample[,'FSCSKEY',drop=FALSE],
    strata_ids = library_stsys_sample[,'SAMPLING_STRATUM',drop=FALSE],
    strata_pop_sizes = library_stsys_sample[,'STRATUM_POP_SIZE',drop=FALSE],
    sort_order = library_stsys_sample$SAMPLING_SORT_ORDER
  )

# Identify cases included in phase two sample
# (in this example, respondents)
  phase2_inclusion &lt;- (
    library_stsys_sample$RESPONSE_STATUS == "Survey Respondent"
  )
  phase2_sample &lt;- library_stsys_sample[phase2_inclusion,]

# Estimate response propensities

  response_propensities &lt;- glm(
    data = library_stsys_sample,
    family = quasibinomial('logit'),
    formula = phase2_inclusion ~ 1,
    weights = 1/library_stsys_sample$SAMPLING_PROB
  ) |&gt;
    predict(type = "response",
            newdata = phase2_sample)

# Estimate conditional joint inclusion probabilities for second phase

  phase2_joint_probs &lt;- outer(response_propensities, response_propensities)
  diag(phase2_joint_probs) &lt;- response_propensities

# Determine quadratic form for variance estimator of second phase
# (Horvitz-Thompson estimator for nonresponse modeled as Poisson sampling)

  phase2_quad_form &lt;- make_quad_form_matrix(
    variance_estimator = "Horvitz-Thompson",
    joint_probs = phase2_joint_probs
  )

# Create combined quadratic form for entire design

 twophase_quad_form &lt;- make_twophase_quad_form(
   sigma_1 = full_phase1_quad_form[phase2_inclusion, phase2_inclusion],
   sigma_2 = phase2_quad_form,
   phase_2_joint_probs = phase2_joint_probs
 )

 combined_weights &lt;- 1/(phase2_sample$SAMPLING_PROB * response_propensities)

# Use for variance estimation

  rep_factors &lt;- make_gen_boot_factors(
    Sigma = twophase_quad_form,
    num_replicates = 500
  )

  library(survey)

  twophase_rep_design &lt;- svrepdesign(
    data = phase2_sample,
    type = 'other',
    repweights = rep_factors,
    weights = combined_weights,
    combined.weights = FALSE,
    scale = attr(rep_factors, 'scale'),
    rscales = attr(rep_factors, 'rscales')
  )

  svymean(x = ~ LIBRARIA, design = twophase_rep_design)

## End(Not run)
</code></pre>


</div>