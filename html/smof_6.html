<div class="container">

<table style="width: 100%;"><tr>
<td>smof</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Scoring Methodology for Ordered Factors</h2>

<h3>Description</h3>

<p>Starting from an object representing a fitted model whose linear
predictor includes some ordered factor(s) among the explanatory variables, a
new model is constructed where each named factor is replaced by a single
numeric score, suitably chosen so that the new variable produces a data
fit comparable with the standard methodology based on a set of polynomial
contrasts. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">smof(object, data, factors, scoring, fast.fit = FALSE, original = FALSE,
      opt.control=list(), trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object produced by a fitting function; see ‘Details’
below for specification of the admissible classes of objects. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame used for producing <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>a character vector with the names of the ordered factors of 
<code>data</code> which must be converted to numeric scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoring</code></td>
<td>
<p>a list which selects the type of scoring technques and 
related ingredients.
Its key component is the character string <code>scoring$type</code> with possible
values <code>"distr"</code> and <code>"spline"</code>; the other components of the
list depend on this value, and are described in the  ‘Details’.
If <code>scoring</code> is missing, the default value 
<code>list(type="distr", family="gh")</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast.fit</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating 
whether a fast-fitting procedure must be used. 
This option is available only under certain circumstances specified 
in the ‘Details’ below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>original</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating
whether the original <code>object</code> must be included in the returned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.control</code></td>
<td>
<p>a list passed to <code>optim</code> as its <code>control</code>
argument. It must not be used to turn the minimization problem into a
maximization one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating 
whether details of the iterative procedure for parameter estimation must 
be printed at each iteration.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In its original formulation,
function <code>smof</code> implements  the methodology proposed by 
Azzalini (2023), briefly summarized in the ‘Background’ section.
It is recommended to read at least that section in case the referenced paper 
is not examined. The published paper has open access.  
Later on, in version 1.2.0 of <span class="pkg">smof</span>, a variant methodology has been 
included, based on the use of splines instead of quantile functions,
presented in Azzalini (2024).
</p>
<p>Start from an <code>object</code> obtained as the outcome from some fitting 
procedure, whose linear predictor includes one or more ordered factor(s)
among the explanatory variables. 
For each ordered factor whose name is included in vector <code>factors</code>, 
a suitable vector of numeric scores is constructed.
The selection process examines the quantiles of the members of a specified 
parametric  class of distributions  and selects the member with optimizes 
(i.e. minimizes) a suitable target criterion.
To avoid trivialities, each factor in vector <code>factors</code> must have at 
least three levels.
</p>
<p>There are two quite different options to build the numeric scores assigned
to an ordered factor. The selection of one of these options is made via
the component <code>type</code> of the list <code>scoring</code>, which 
can be either <code>"distr"</code> or <code>"spline"</code>. 
The other components of <code>scoring</code> depends on the chosen <code>type</code> 
and are described below.
</p>
<p>If <code>scoring$type="distr"</code>, the numeric scores are obtained as quantiles
of a probability distribution belonging to a certain parametric family;
this route corresponds to the original construction of <code>smof</code>,
following Azzalini (2023).
The admissible parametric families are all obtained by monotonic 
transformations of a standard normal variate.  
Specifically, the admissible families and corresponding strings to be
specified in <code>scoring$family</code> are as follows:
</p>

<table>
<tr>
<td style="text-align: left;">
  Johnson's <code class="reqn">S_U</code>            </td>
<td style="text-align: left;"> <code class="reqn">\quad</code> </td>
<td style="text-align: left;"> <code>"SU"</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  Tukey's <em>g</em>-and-<em>h</em>  </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> <code>"gh"</code>, <code>"g-and-h"</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  Jones and Pewsey's <em>sinh-arcsinh</em>
                            </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> <code>"sinh-arcsinh"</code>, <code>"SAS"</code>  
</td>
</tr>
</table>
<p>where either string name can be used when two of them are indicated. 
All these families involve two parameters for shape regulation; location and 
scale parameters are not considered, because irrelevant for our purposes.
Of the two shape paramters, the first one regulates asymmetry and can take
any value, while the second one regulates tail thickness and must be positive.
In each case, the adopted parameterization is the ‘standard’ one,
but explicit specifications are provided in the reference below.  
The same <code>family</code> is employed for all the components of <code>factors</code>.
</p>
<p>If <code>scoring$type="spline"</code>, the numeric scores are obtained via a
monotonic spline function. Specifically, the scores are generated using
<code>splinefun</code> with <code>method="monoH.FC"</code>. Since currently this is 
the only admissible form of spline, it does not need to be specified.
What must be specified is <code>scoring$in.knots</code>, the number of internal knots
between the fixed extremal knots <code>1</code> and <code>K</code>, if <code>K</code> denotes
the number of levels of any given factor.  Hence <code>scoring$in.knots</code>
should be an integer vector with as many components as <code>factors</code>;
if a shorter vector is supplied, its values will be recycled.
Since each internal knot involves the selection of two numeric values,
the total number of fitted parameters will equal the sum of twice the
<code>in.knots</code> values, summed over the components of <code>factors</code>.
</p>
<p>Estimation of the transformation parameters is performed by minimization,
performed by the optimizer <code>optim</code>, of a suitable target criterion,
which depends on <code>class(object)</code>.
The admissible classes for <code>object</code> are currently as follows,
listed along the corresponding target criteria:
</p>

<table>
<tr>
<td style="text-align: left;">
  <kbd>class</kbd> </td>
<td style="text-align: left;"> <kbd>fitting function (package)</kbd> </td>
<td style="text-align: left;"> <kbd>target criterion</kbd>
</td>
</tr>
<tr>
<td style="text-align: left;">
  <code class="reqn">\rule[0.8ex]{5em}{0.02ex}</code>
</td>
<td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{12em}{0.02ex}</code>
</td>
<td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{10em}{0.02ex}</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
   lm           </td>
<td style="text-align: left;"> lm (stats)         </td>
<td style="text-align: left;"> sum of squared residuals </td>
</tr>
<tr>
<td style="text-align: left;">
   mlm          </td>
<td style="text-align: left;"> lm (stats)         </td>
<td style="text-align: left;"> [see below] </td>
</tr>
<tr>
<td style="text-align: left;">
   glm          </td>
<td style="text-align: left;"> glm (stats)        </td>
<td style="text-align: left;"> deviance </td>
</tr>
<tr>
<td style="text-align: left;">
   survreg      </td>
<td style="text-align: left;"> survreg (survival) </td>
<td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
<td style="text-align: left;"> 
   coxph        </td>
<td style="text-align: left;"> coxph (survival)   </td>
<td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
<td style="text-align: left;">
   coxph.penal  </td>
<td style="text-align: left;"> coxph (survival)   </td>
<td style="text-align: left;"> <code class="reqn">-</code>loglikelihood 
</td>
</tr>
</table>
<p>For an object of class <code>mlm</code>, the target function is formed by summing
terms where the contribution  from the <code class="reqn">j</code>-th response variable is
<code class="reqn">(1-R^2_j)</code>, where <code class="reqn">R^2_j</code> is the <code>r-squared</code> statistic for 
that component of the fitted model. 
Note that, in the case of a single response variable,
its <code class="reqn">(1-R^2)</code> value is equivalent, up to an algebraic transformation, 
to the sum of squared residuals used for <code>lm</code> objects;
hence the chosen target criterion for <code>mlm</code> models is a direct extension
of the one for <code>lm</code>'s.
The above list of classes may be expanded in the future, depending on feedback.
</p>
<p>In certain cases, models involving  a large number of parameters for 
regulation of the  scores transformation(s) can lead to difficulties 
at the optimization step, which is performed by <code>optim</code>.
This situation may be flagged by the message
</p>
<pre>Non-zero error code returned by optim:...</pre>
<p>In these circumstances, one direction for improvement is to make use of
the argument <code>opt.control</code> for better tuning the working of <code>optim</code>. 
In more problematic cases, the axiliary function <code>smof_refit</code> is
provided to improve upon an intial fitting.
</p>
<p>The rest of this section is slightly of more technical nature, 
and it may be not of interest to the casual user, especially if
the option <code>fast.fit=TRUE</code> is not selected.
Operationally, estimation of the <code>scoring$family</code> parameters is performed 
via optimization of the pertaining target criterion,
as indicated by the table above.
For each candidate set of parameters, each factor included in 
<code>factors</code> is replaced by values determined by the 
quantiles of  <code>scoring$family</code>  and the current parameters.
The name of the new constructed variable is formed by adding <code>.score</code> 
to the original name.
For instance, an ordered factor called <code>ordfac</code> is replaced 
by the numeric variable <code>ordfac.score</code> both 
in the linear predictor of <code>object</code> and in the <code>data</code> frame.
A call to <code>update</code> using the modified linear predictor and data delivers
a new fitting, with attached a value of the  target criterion.
An interative optimization process the target criterion leads to 
the estimated parameters of <code>scoring$family</code>  with a corresponding 
fitted model.
</p>
<p>There are in fact two variants of the procedure. 
What has been just described refers to the more ‘general’ variant form.
However, in the prominent cases of an <code>object</code> of class <code>lm</code> 
or <code>glm</code>, the procedure can be speeded-up by setting <code>fast.fit=TRUE</code>, 
provided the fitted model is of a basic form, that is, a model specification
via  a formula, and a <code>family</code> in the <code>glm</code> case, without  
non-basic arguments such as <code>offset</code>, <code>subset</code> and alike.
If these non-basic arguments are included in the <code>object</code> call, 
they are ignored for estimation of the <code>scoring$family</code> parameter.
However, they are included for producing the final <code>object</code> 
returned by the function. 
With this option, the sequence of calls to <code>lm</code> and <code>glm</code>
involved by the iterative search procedure is replaced by faster calls
to  <code>lm.fit</code> and <code>glm.fit</code>.
Correspondingly, the internal target function (<code>target.fit</code>) is slightly
different from the one used on the more general case (<code>target.gen</code>). 
Since the selection of the parameters involves an iterative process with
dimensionality equal to twice the length of <code>factors</code> and each iteration
involves a new data fitting process, the saving in execution time can be 
substantial in some cases.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the calling statement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.object</code></td>
<td>
<p>an updated version of the original <code>object</code>, with 
the components of <code>factors</code> in the model replaced by new variables; 
this <code>object</code> is itself a list, whose structure depends on its class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.data</code></td>
<td>
<p>a new data frame where the ordered factors are replaced 
by numeric variables representing scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoring</code></td>
<td>
<p>a list similar to the input argument with the addition of
the estimates of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor.scores</code></td>
<td>
<p>a list of numeric vectors with the scores assigned 
to the levels of each factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>original.factors</code></td>
<td>
<p>a list with the names and the levels of the original 
<code>factors</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.criterion</code></td>
<td>
<p>the final value of the target criterion used for fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt</code></td>
<td>
<p>the list returned by <code>optim</code>.</p>
</td>
</tr>
</table>
<h3>Background</h3>

<p>The methodology proposed in the reference below deals with the presence of 
ordered factors used as explanatory variables, hence included in the linear 
predictor of some model under consideration.
For any given ordered factor with <em>K</em> levels, say, a set of <em>K</em> 
numeric scores is introduced, with a certain value assigned to each factor level.
In the end, the original factor is effectively replaced by a numeric variable.
This scheme represents a refinement of the elementary scoring system based
on the basic sequence <em>1, ..., K</em>, which constitutes a simple 
time-honoured option to deal with ordered factors, 
but it is not always appropriate.
</p>
<p>There are two variants of the methodology, selected with the value of
the component <code>type</code> of the list <code>scoring</code>.
Here we summarize the working of the original formulation, selected by
setting <code>type="distr"</code>. 
The actual construction of numeric scores proceeds by selecting <em>K</em> 
quantiles of a distribution belonging to some parametric family.
The adoption of a sufficiently flexible parametric family helps to find
a scoring system best suited for the data under consideration,
hence improving upon the basic sequence <em>1, ..., K</em>.
A concomitant product of this scheme is the identification of numeric values
which indicate how the <em>K</em> levels are “really” spaced.
Combining these two features, the key feature of the proposal is 
interpretability of the construction.
</p>
<p>The proposed method represents an alternative to the use of polynomial 
contrasts, which is the default action taken by <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> for ordered factors;
see the documentation of <code>contr.poly</code>.
</p>
<p>In the proposed logic, the constructed scores are intended to be used, and
interpreted, without further manipulation. Hence, for instance, building a 
polynomial form using one such variable would diverge somewhat from the 
proposed logic, although still conceivable.
With a single numeric variable to represent a given factor, 
one cannot expect to achieve the same numerical fit to the data 
as obtained the polynomial contrasts built for the original factor, 
when these constrasts involve high degrees polynomials, and 
correspondingly several parameters.
However, a range of numerical explorations has indicated that in many cases
the resulting fit is equal or similar to the one achieved via polynomial 
constrasts, with non-negligible simplification in the model specification, 
and easier interpretation, 
</p>
<p>In a nutshell, the aim of the approach is to achieve a satisfactory data fit
while improving an model parsimony, with simple interpretability of the 
score system.
</p>
<p>The alternative variant of the methodology is selected by setting  
<code>scoring$type="spline"</code>. The underlying principle is similar to the
one just described, but it makes use of splines instead of quantile functions.
Its operational working is described in the ‘Details’.
</p>
<p>For a more comprehensive exposition and discussion, see the references below.
</p>


<h3>Note</h3>

<p>For subsequent computations on the object returned by <code>smof</code>, difficulties 
may arise if the call to the fitting function does not set <code>model=TRUE</code>.
This is not a problem with <code>lm</code> and <code>glm</code>, if their default setting
<code>model=TRUE</code> has not been modified.
The  default setting of <code>coxph</code> is instead <code>model=FALSE</code>.
This implies, for instance, that issuing the <code>survival</code> command   
<code>survfit(smof4$new.object)</code>, right after running 
the code of Example 4 below, would cause an error. 
The main route to avoid this issue is to set <code>model=TRUE</code> in the call to
the fitting function, that is, <code>coxph</code> or whaterever function is used.
Alternatively, if one does not want to refit an already existing object,
there exist various ways to overcome this snag; the simplest one is to write  
</p>

<table>
<tr>
<td style="text-align: right;">
  </td>
<td style="text-align: left;"> <code>new.data &lt;- smof4$new.data</code> </td>
</tr>
<tr>
<td style="text-align: right;">
  </td>
<td style="text-align: left;"> <code>s &lt;- survfit(smof4$new.object)</code>
</td>
</tr>
</table>
<p>This indication is temporary and it may be superseded by a different design 
in future versions of the package.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. (2023). On the use of ordered factors as explanatory variables.
<em>Stat</em> <b>12</b>, e624. <a href="https://doi.org/10.1002/sta4.624">doi:10.1002/sta4.624</a>
</p>
<p>Azzalini, A. (2024). On the use of splines for representing ordered factors.
<em>arXiv:2406.15933</em>, <a href="https://doi.org/10.48550/arXiv.2406.15933">doi:10.48550/arXiv.2406.15933</a>
</p>


<h3>See Also</h3>

<p><code>smof_refit</code>, <code>optim</code>,
<code>contr.poly</code>, <code>update</code>, 
<code>splinefun</code>, <code>plogis</code>,
<code>lm</code>, <code>lm.fit</code>, 
<code>glm</code>, <code>glm.fit</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1, reconstructs Tables 1 and 2 (second part) of the reference
message("--- Example 1: esoph data ---")
library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6)  
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4)  
fit1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph) 
message("original fit:") 
print(summary(fit1))      
smof1 &lt;- smof(fit1, esoph, "alcgp")
# to select the Johnson's S_U family of distributions, write instead:
# smof1 &lt;- smof(fit1, esoph, "alcgp", scoring=list(type="distr", family="SU"))
print(smof1, type="b", pch=20, col=4)
print(summary(smof1))
plot(smof1)
#
# Example 2 , reconstructs Tables 3 and 4 (first part) of the reference
if(require(ggplot2, quietly=TRUE)) {
message("--- Example 2: diamonds data ---")
data(diamonds, package="ggplot2")  
dmd &lt;- data.frame(diamonds[seq(1, 53940, by=100),]) # use a subset of the data
dmd &lt;- dmd[-c(518, 519, 523),] # remove three outliers
contrasts(dmd$clarity, 3) &lt;- contr.poly(8)  
contrasts(dmd$color, 4) &lt;- contr.poly(7)
contrasts(dmd$cut, 1) &lt;- contr.poly(5) 
fit2 &lt;- lm(sqrt(price) ~ carat + clarity + color + cut, data=dmd)
smof2 &lt;- smof(fit2, dmd,  c("color", "clarity"))
message("smof fit:") 
print(smof2)
print(summary(smof2))
plot(smof2, which="clarity")
} # end diamonds example
#
# Example 3
if(require(survival, quietly=TRUE)) {
message("--- Example 3: lung data ---")
lung0 &lt;- lung
lung0$ph.karno &lt;- ordered(lung0$ph.karno)
contrasts(lung0$ph.karno, 3) &lt;- contr.poly(6)
fit3 &lt;- survreg(Surv(time, status) ~ ph.karno, data=lung0)
smof3 &lt;- smof(fit3, lung0, "ph.karno")
print(summary(smof3))
plot(smof3)  # Karnofsky scores do not seem to be linearly spaced
# 
message("--- Example 4: PBC data ---")
data(pbc, package="survival")
pbc$stage &lt;- ordered(pbc$stage)
fit4 &lt;- coxph(Surv(time) ~ strata(status) + stage, data=pbc)
smof4 &lt;- smof(fit4, data=pbc, factors="stage")
print(summary(smof4))
plot(smof4)
} # end of survival examples
</code></pre>


</div>