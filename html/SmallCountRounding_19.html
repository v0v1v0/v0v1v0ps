<div class="container">

<table style="width: 100%;"><tr>
<td>RoundViaDummy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Small Count Rounding of Tabular Data</h2>

<h3>Description</h3>

<p>Small count rounding via a dummy matrix and by an algorithm inspired by PLS
</p>


<h3>Usage</h3>

<pre><code class="language-R">RoundViaDummy(
  data,
  freqVar,
  formula = NULL,
  roundBase = 3,
  singleRandom = FALSE,
  crossTable = TRUE,
  total = "Total",
  maxIterRows = 1000,
  maxIter = 1e+07,
  x = NULL,
  hierarchies = NULL,
  xReturn = FALSE,
  maxRound = roundBase - 1,
  zeroCandidates = FALSE,
  forceInner = FALSE,
  identifyNew = TRUE,
  step = 0,
  preRounded = NULL,
  leverageCheck = FALSE,
  easyCheck = TRUE,
  printInc = TRUE,
  rndSeed = 123,
  dimVar = NULL,
  plsWeights = NULL,
  preDifference = NULL,
  allSmall = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input data as a data frame (inner cells)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqVar</code></td>
<td>
<p>Variable holding counts (name or number)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula defining publishable cells. Will be used to calculate <code>x</code> (via <code>ModelMatrix</code>).
When NULL, x must be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roundBase</code></td>
<td>
<p>Rounding base</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singleRandom</code></td>
<td>
<p>Single random draw when TRUE (instead of algorithm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossTable</code></td>
<td>
<p>When TRUE, cross table in output and caculations via FormulaSums()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>String used to name totals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIterRows</code></td>
<td>
<p>See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Dummy matrix defining publishable cells</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, a single string as hierarchy input is assumed to be a total code.
Exceptions are <code>"rowFactor"</code> or <code>""</code>, which correspond to only using the categories in the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xReturn</code></td>
<td>
<p>Dummy matrix in output when TRUE (as input parameter <code>x</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxRound</code></td>
<td>
<p>Inner cells contributing to original publishable cells equal to or less than maxRound will be rounded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroCandidates</code></td>
<td>
<p>When TRUE, inner cells in input with zero count (and multiple of roundBase when maxRound is in use)
contributing to publishable cells will be included as candidates to obtain roundBase value.
With vector input, the rule is specified individually for each cell.
This can be specified as a vector, a variable in data or a function generating it (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceInner</code></td>
<td>
<p>When TRUE, all inner cells will be rounded. Use vector input to force individual cells to be rounded.
This can be specified as a vector, a variable in data or a function generating it (see details).
Can be combined with parameter zeroCandidates to allow zeros and roundBase multiples to be rounded up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identifyNew</code></td>
<td>
<p>When <code>TRUE</code>, new cells may be identified after initial rounding to ensure all rounded publishable
cells equal to or less than <code>maxRound</code> to be <code>roundBase</code> multiples. Use <code>NA</code> for the a less conservative
behavior (old behavior). Then it is ensured that no nonzero rounded publishable cells are smaller
than <code>roundBase</code>. When <code>maxRound</code> is default, there is no difference between <code>TRUE</code> and <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>When <code>step&gt;1</code>, the original forward part of the algorithm is replaced by a kind of stepwise.
After <code>step</code> steps forward, backward steps may be performed. The <code>step</code> parameter is also used
for backward-forward iteration at the end of the algorithm; <code>step</code> backward steps may be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preRounded</code></td>
<td>
<p>A vector or a variable in data that contains a mixture of missing values and predetermined values of rounded inner cells.
Can also be specified as a function generating it (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leverageCheck</code></td>
<td>
<p>When TRUE, all inner cells that depends linearly on the published cells and with small frequencies
(<code>&lt;=maxRound</code>) will be rounded.
The computation of leverages can be very time and memory consuming.
The function <code>Reduce0exact</code> is called.
The default leverage limit is <code>0.999999</code>. Another limit can be sent as input instead of <code>TRUE</code>.
Checking is performed before and after (since new zeros) rounding. Extra iterations are performed when needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>easyCheck</code></td>
<td>
<p>A light version of the above leverage checking.
Checking is performed after rounding. Extra iterations are performed when needed.
<code>Reduce0exact</code> is called with <code>reduceByLeverage=FALSE</code> and <code>reduceByColSums=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rndSeed</code></td>
<td>
<p>If non-NULL, a random generator seed to be used locally within the function without affecting the random value stream in R.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plsWeights</code></td>
<td>
<p>A vector of weights for each cell to be published or a function generating it (see details). For use in the algorithm criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preDifference</code></td>
<td>
<p>A data.frame with differences already obtained from rounding another subset of data.
There must be columns that match <code>crossTable</code>. Differences must be in the last column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allSmall</code></td>
<td>
<p>When TRUE, all small inner cells (<code style="white-space: pre;">⁠&lt;= maxRound⁠</code>) are rounded. This parameter is a simplified alternative to specifying <code>forceInner</code>  (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further parameters sent to <code>ModelMatrix</code>.
In particular, one can specify <code>removeEmpty=TRUE</code> to omit empty combinations.
The parameter <code>inputInOutput</code> can be used to specify whether to include codes from input.
The parameter <code>avoidHierarchical</code> (<code>Formula2ModelMatrix</code>) can be combined with formula input.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Small count rounding of necessary inner cells are performed so that all small frequencies of cross-classifications to be published
(publishable cells) are rounded. This is equivalent to changing micro data since frequencies of unique combinations are changed.
Thus, additivity and consistency are guaranteed. The matrix multiplication formula is:
<code>yPublish</code> <code>=</code> <code>t(x)</code> <code>%*%</code>  <code>yInner</code>, where <code>x</code> is the dummy matrix.
</p>
<p>Parameters <code>zeroCandidates</code>, <code>forceInner</code>,  <code>preRounded</code> and <code>plsWeights</code> can be specified as functions.
The supplied functions take the following arguments: <code>data</code>, <code>yPublish</code>,  <code>yInner</code>, <code>crossTable</code>, <code>x</code>, <code>roundBase</code>, <code>maxRound</code>, and <code>...</code>,
where the first two are numeric vectors of original counts.
When <code>allSmall</code> is <code>TRUE</code>,  <code>forceInner</code> is set to  <code style="white-space: pre;">⁠function(yInner, maxRound, ...)⁠</code> <code>yInner &lt;= maxRound</code>.
</p>


<h3>Value</h3>

<p>A list where the two first elements are two column matrices.
The first matrix consists of inner cells and the second of cells to be published.
In each matrix the first and the second column contains, respectively, original and rounded values.
By default the cross table is the third element of the output list.
</p>


<h3>Note</h3>

<p>Iterations are needed since after initial rounding of identified cells, new cells are identified.
If cases of a high number of identified cells the algorithm can be too memory consuming (unless singleRandom=TRUE).
To avoid problems, not more than maxIterRows cells are rounded in each iteration.
The iteration limit (maxIter) is by default set to be high since a low number of maxIterRows may need a high number of iterations.
</p>


<h3>See Also</h3>

<p>See the  user-friendly wrapper <code>PLSrounding</code>
and see <code>Round2</code> for rounding by other algorithm
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See similar and related examples in PLSrounding documentation
RoundViaDummy(SmallCountData("e6"), "freq")
RoundViaDummy(SmallCountData("e6"), "freq", formula = ~eu * year + geo)
RoundViaDummy(SmallCountData("e6"), "freq", hierarchies = 
   list(geo = c("EU", "@Portugal", "@Spain", "Iceland"), year = c("2018", "2019")))

RoundViaDummy(SmallCountData('z2'), 
              'ant', ~region + hovedint + fylke*hovedint + kostragr*hovedint, 10)
mf &lt;- ~region*mnd + hovedint*mnd + fylke*hovedint*mnd + kostragr*hovedint*mnd
a &lt;- RoundViaDummy(SmallCountData('z3'), 'ant', mf, 5)
b &lt;- RoundViaDummy(SmallCountData('sosialFiktiv'), 'ant', mf, 4)
print(cor(b[[2]]),digits=12) # Correlation between original and rounded

# Demonstrate parameter leverageCheck 
# The 42nd inner cell must be rounded since it can be revealed from the published cells.
mf2 &lt;- ~region + hovedint + fylke * hovedint + kostragr * hovedint
RoundViaDummy(SmallCountData("z2"), "ant", mf2, leverageCheck = FALSE)$yInner[42, ]
RoundViaDummy(SmallCountData("z2"), "ant", mf2, leverageCheck = TRUE)$yInner[42, ]

## Not run: 
# Demonstrate parameters maxRound, zeroCandidates and forceInner 
# by tabulating the inner cells that have been changed.
z4 &lt;- SmallCountData("sosialFiktiv")
for (forceInner in c("FALSE", "z4$ant &lt; 10")) 
  for (zeroCandidates in c(FALSE, TRUE)) 
    for (maxRound in c(2, 5)) {
      set.seed(123)
      a &lt;- RoundViaDummy(z4, "ant", formula = mf, maxRound = maxRound, 
                         zeroCandidates = zeroCandidates, 
                         forceInner = eval(parse(text = forceInner)))
      change &lt;- a$yInner[, "original"] != a$yInner[, "rounded"]
      cat("\n\n---------------------------------------------------\n")
      cat("      maxRound:", maxRound, "\n")
      cat("zeroCandidates:", zeroCandidates, "\n")
      cat("    forceInner:", forceInner, "\n\n")
      print(table(original = a$yInner[change, "original"], rounded = a$yInner[change, "rounded"]))
      cat("---------------------------------------------------\n")
    }

## End(Not run)
</code></pre>


</div>