<div class="container">

<table style="width: 100%;"><tr>
<td>svsample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo (MCMC) Sampling for the Stochastic Volatility (SV)
Model</h2>

<h3>Description</h3>

<p><code>svsample</code> simulates from the joint posterior distribution of the SV
parameters <code>mu</code>, <code>phi</code>, <code>sigma</code> (and potentially <code>nu</code> and <code>rho</code>),
along with the latent log-volatilities <code>h_0,...,h_n</code> and returns the
MCMC draws. If a design matrix is provided, simple Bayesian regression can
also be conducted. For similar functionality with a formula interface,
see <code>svlm</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">svsample(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svtsample(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0.1,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svlsample(
  y,
  draws = 20000,
  burnin = 2000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = c(4, 4),
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svtlsample(
  y,
  draws = 20000,
  burnin = 2000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0.1,
  priorrho = c(4, 4),
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svsample2(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  thinpara = 1,
  thinlatent = 1,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric vector containing the data (usually log-returns), which
must not contain zeros. Alternatively, <code>y</code> can be an <code>svsim</code>
object. In this case, the returns will be extracted and a message is signalled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draws</code></td>
<td>
<p>single number greater or equal to 1, indicating the number of
draws after burn-in (see below). Will be automatically coerced to integer.
The default value is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of
draws discarded as burn-in. Will be automatically coerced to integer. The
default value is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designmatrix</code></td>
<td>
<p>regression design matrix for modeling the mean. Must
have <code>length(y)</code> rows. Alternatively, <code>designmatrix</code> may be a
string of the form <code>"arX"</code>, where <code>X</code> is a nonnegative integer. To
fit a constant mean model, use <code>designmatrix = "ar0"</code> (which is
equivalent to <code>designmatrix = matrix(1, nrow = length(y))</code>). To fit an
AR(1) model, use <code>designmatrix = "ar1"</code>, and so on. If some elements of
<code>designmatrix</code> are <code>NA</code>, the mean is fixed to zero (pre-1.2.0
behavior of <span class="pkg">stochvol</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priormu</code></td>
<td>
<p>numeric vector of length 2, indicating mean and standard
deviation for the Gaussian prior distribution of the parameter <code>mu</code>,
the level of the log-volatility. The default value is <code>c(0, 100)</code>,
which constitutes a practically uninformative prior for common exchange rate
datasets, stock returns and the like.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorphi</code></td>
<td>
<p>numeric vector of length 2, indicating the shape parameters
for the Beta prior distribution of the transformed parameter
<code>(phi + 1) / 2</code>, where <code>phi</code> denotes the persistence of the
log-volatility. The default value is <code>c(5, 1.5)</code>, which constitutes a
prior that puts some belief in a persistent log-volatility but also
encompasses the region where <code>phi</code> is around 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorsigma</code></td>
<td>
<p>single positive real number, which stands for the scaling
of the transformed parameter <code>sigma^2</code>, where <code>sigma</code> denotes the
volatility of log-volatility. More precisely, <code>sigma^2 ~ priorsigma *
chisq(df = 1)</code>. The default value is <code>1</code>, which constitutes a
reasonably vague prior for many common exchange rate datasets, stock returns
and the like.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priornu</code></td>
<td>
<p>single non-negative number, indicating the rate parameter
for the exponential prior distribution of the parameter; can be <code>Inf</code>
<code>nu</code>, the degrees-of-freedom parameter of the conditional innovations
t-distribution. The default value is <code>0</code>, fixing the
degrees-of-freedom to infinity. This corresponds to conditional standard
normal innovations, the pre-1.1.0 behavior of <span class="pkg">stochvol</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorrho</code></td>
<td>
<p>either <code>NA</code> for the no-leverage case or a numeric
vector of length 2 that specify the beta prior distribution for
<code>(rho+1)/2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorbeta</code></td>
<td>
<p>numeric vector of length 2, indicating the mean and
standard deviation of the Gaussian prior for the regression parameters. The
default value is <code>c(0, 10000)</code>, which constitutes a very vague prior
for many common datasets. Not used if <code>designmatrix</code> is <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorlatent0</code></td>
<td>
<p>either a single non-negative number or the string
<code>'stationary'</code> (the default, also the behavior before version 1.3.0).
When <code>priorlatent0</code> is equal to <code>'stationary'</code>, the stationary
distribution of the latent AR(1)-process is used as the prior for the
initial log-volatility <code>h_0</code>. When <code>priorlatent0</code> is equal to a
number <code class="reqn">B</code>, we have <code class="reqn">h_0 \sim N(\mu, B\sigma^2)</code> a priori.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorspec</code></td>
<td>
<p>in case one needs different prior distributions than the
ones specified by <code>priormu</code>, <code>...</code>, <code>priorrho</code>, a <code>priorspec</code>
object can be supplied here. A smart constructor for this usecase is
specify_priors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter and latent draw is kept and returned. The default
value is 1, corresponding to no thinning of the parameter draws i.e. every
draw is stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinpara</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter draw is kept and returned. The default
value is <code>thin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinlatent</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinlatent</code>th latent variable draw is kept and returned. The
default value is <code>thin</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keeptime</code></td>
<td>
<p>Either 'all' (the default) or 'last'. Indicates which latent
volatility draws should be stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical value indicating whether the progress bar and other
informative output during sampling should be omitted. The default value is
<code>FALSE</code>, implying verbose output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startpara</code></td>
<td>
<p><em>optional</em> named list, containing the starting values
for the parameter draws. If supplied, <code>startpara</code> may contain
elements named <code>mu</code>, <code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>,
<code>beta</code>, and <code>latent0</code>.
The default value is equal to the prior mean.
In case of parallel execution with <code>cl</code> provided, <code>startpara</code> can be a list of
named lists that initialize the parallel chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startlatent</code></td>
<td>
<p><em>optional</em> vector of length <code>length(y)</code>,
containing the starting values for the latent log-volatility draws. The
default value is <code>rep(-10, length(y))</code>.
In case of parallel execution with <code>cl</code> provided, <code>startlatent</code> can be a list of
numeric vectors that initialize the parallel chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p><em>optional</em> one of <code>"no"</code> (default), <code>"multicore"</code>, or <code>"snow"</code>,
indicating what type of parallellism is to be applied. Option
<code>"multicore"</code> is not available on Windows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cpus</code></td>
<td>
<p><em>optional</em> positive integer, the number of CPUs to be used in case of
parallel computations. Defaults to <code>1L</code>. Ignored if parameter
<code>cl</code> is supplied and <code>parallel != "snow"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p><em>optional</em> so-called SNOW cluster object as implemented in package
<code>parallel</code>. Ignored unless <code>parallel == "snow"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_chains</code></td>
<td>
<p><em>optional</em> positive integer specifying the number of independent MCMC chains</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_progress</code></td>
<td>
<p><em>optional</em> one of <code>"automatic"</code>, <code>"progressbar"</code>,
or <code>"iteration"</code>, controls the output. Ignored if <code>quiet</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expert</code></td>
<td>
<p><em>optional</em> named list of expert parameters. For most
applications, the default values probably work best. Interested users are
referred to the literature provided in the References section. If
<code>expert</code> is provided, it may contain the following named elements:
</p>

<dl>
<dt>interweave</dt>
<dd>
<p> Logical value. If <code>TRUE</code> (the default),
then ancillarity-sufficiency interweaving strategy (ASIS) is applied
to improve on the sampling efficiency for the parameters.
Otherwise one parameterization is used.</p>
</dd>
<dt>correct_model_misspecification</dt>
<dd>
<p> Logical value. If <code>FALSE</code>
(the default), then auxiliary mixture sampling is used to sample the latent
states. If <code>TRUE</code>, extra computations are made to correct for model
misspecification either ex-post by reweighting or on-line using a
Metropolis-Hastings step.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any extra arguments will be forwarded to
<code>updatesummary</code>, controlling the type of statistics calculated
for the posterior draws.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions <code>svtsample</code>, <code>svlsample</code>, and <code>svtlsample</code> are
wrappers around <code>svsample</code> with convenient default values for the SV
model with t-errors, leverage, and both t-errors and leverage, respectively.
</p>
<p>For details concerning the algorithm please see the paper by Kastner and
Frühwirth-Schnatter (2014) and Hosszejni and Kastner (2019).
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>svdraws</code> holding
</p>
<table>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>parameter</em> draws from
the posterior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latent</code></td>
<td>
<p><code>mcmc.list</code> object containing the
<em>latent instantaneous log-volatility</em> draws from the posterior
distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latent0</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent
initial log-volatility</em> draws from the posterior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent variance inflation
factors</em> for the sampler with conditional t-innovations <em>(optional)</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>regression coefficient</em>
draws from the posterior distribution <em>(optional)</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the left hand side of the observation equation, usually
the argument <code>y</code>. In case of an AR(<code>k</code>) specification, the
first <code>k</code> elements are removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runtime</code></td>
<td>
<p><code>proc_time</code> object containing the
run time of the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a <code>priorspec</code> object containing the parameter
values of the prior distributions for <code>mu</code>,
<code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>, and
<code>beta</code>s, and the variance of specification for <code>latent0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p><code>list</code> containing the thinning
parameters, i.e. the arguments <code>thinpara</code>, <code>thinlatent</code> and
<code>keeptime</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary</code></td>
<td>
<p><code>list</code> containing a collection of
summary statistics of the posterior draws for <code>para</code>, <code>latent</code>,
and <code>latent0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanmodel</code></td>
<td>
<p><code>character</code> containing information about how <code>designmatrix</code>
was employed.</p>
</td>
</tr>
</table>
<p>To display the output, use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the posterior draws (which is very likely
a lot of output); the <code>summary</code> method displays the summary statistics
currently stored in the object; the <code>plot</code> method
<code>plot.svdraws</code> gives a graphical overview of the posterior
distribution by calling <code>volplot</code>, <code>traceplot</code> and
<code>densplot</code> and displaying the results on a single page.
</p>


<h3>Note</h3>

<p>If <code>y</code> contains zeros, you might want to consider de-meaning your
returns or use <code>designmatrix = "ar0"</code>.
</p>
<p><code>svsample2</code> is deprecated.
</p>


<h3>References</h3>

<p>Kastner, G. and Frühwirth-Schnatter, S. (2014).
Ancillarity-sufficiency interweaving strategy (ASIS) for boosting MCMC
estimation of stochastic volatility models. <em>Computational Statistics &amp;
Data Analysis</em>, <b>76</b>, 408–423,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Hosszejni, D. and Kastner, G. (2019).
Approaches Toward the Bayesian Estimation of the Stochastic Volatility Model with Leverage.
<em>Springer Proceedings in Mathematics &amp; Statistics</em>, <b>296</b>, 75–83,
<a href="https://doi.org/10.1007/978-3-030-30611-3_8">doi:10.1007/978-3-030-30611-3_8</a>.
</p>


<h3>See Also</h3>

<p><code>svlm</code>, <code>svsim</code>, <code>specify_priors</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">###############
# Full examples
###############

# Example 1
## Simulate a short and highly persistent SV process 
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.2)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;-
  svsample(sim, draws = 5000, burnin = 100,
           priormu = c(-10, 1), priorphi = c(20, 1.5), priorsigma = 0.2)

## Check out the results
summary(draws)
plot(draws)



# Example 2
## Simulate an asymmetric and conditionally heavy-tailed SV process
sim &lt;- svsim(150, mu = -10, phi = 0.96, sigma = 0.3, nu = 10, rho = -0.3)

## Obtain 10000 draws from the sampler
## Use more advanced prior settings
## Run two parallel MCMC chains
advanced_draws &lt;-
  svsample(sim, draws = 10000, burnin = 5000,
           priorspec = specify_priors(mu = sv_normal(-10, 1),
                                      sigma2 = sv_gamma(0.5, 2),
                                      rho = sv_beta(4, 4),
                                      nu = sv_constant(5)),
           parallel = "snow", n_chains = 2, n_cpus = 2)

## Check out the results
summary(advanced_draws)
plot(advanced_draws)


# Example 3
## AR(1) structure for the mean
data(exrates)
len &lt;- 3000
ahead &lt;- 100
y &lt;- head(exrates$USD, len)

## Fit AR(1)-SVL model to EUR-USD exchange rates
res &lt;- svsample(y, designmatrix = "ar1")

## Use predict.svdraws to obtain predictive distributions
preddraws &lt;- predict(res, steps = ahead)

## Calculate predictive quantiles
predquants &lt;- apply(predy(preddraws), 2, quantile, c(.1, .5, .9))

## Visualize
expost &lt;- tail(head(exrates$USD, len+ahead), ahead)
ts.plot(y, xlim = c(length(y)-4*ahead, length(y)+ahead),
	       ylim = range(c(predquants, expost, tail(y, 4*ahead))))
for (i in 1:3) {
  lines((length(y)+1):(length(y)+ahead), predquants[i,],
        col = 3, lty = c(2, 1, 2)[i])
}
lines((length(y)+1):(length(y)+ahead), expost,
      col = 2)


# Example 4
## Predicting USD based on JPY and GBP in the mean
data(exrates)
len &lt;- 3000
ahead &lt;- 30
## Calculate log-returns
logreturns &lt;- apply(exrates[, c("USD", "JPY", "GBP")], 2,
                    function (x) diff(log(x)))
logretUSD &lt;- logreturns[2:(len+1), "USD"]
regressors &lt;- cbind(1, as.matrix(logreturns[1:len, ]))  # lagged by 1 day

## Fit SV model to EUR-USD exchange rates
res &lt;- svsample(logretUSD, designmatrix = regressors)

## Use predict.svdraws to obtain predictive distributions
predregressors &lt;- cbind(1, as.matrix(logreturns[(len+1):(len+ahead), ]))
preddraws &lt;- predict(res, steps = ahead,
                     newdata = predregressors)
predprice &lt;- exrates[len+2, "USD"] * exp(t(apply(predy(preddraws), 1, cumsum)))

## Calculate predictive quantiles
predquants &lt;- apply(predprice, 2, quantile, c(.1, .5, .9))

## Visualize
priceUSD &lt;- exrates[3:(len+2), "USD"]
expost &lt;- exrates[(len+3):(len+ahead+2), "USD"]
ts.plot(priceUSD, xlim = c(len-4*ahead, len+ahead+1),
	       ylim = range(c(expost, predquants, tail(priceUSD, 4*ahead))))
for (i in 1:3) {
  lines(len:(len+ahead), c(tail(priceUSD, 1), predquants[i,]),
        col = 3, lty = c(2, 1, 2)[i])
}
lines(len:(len+ahead), c(tail(priceUSD, 1), expost),
      col = 2)


########################
# Further short examples
########################

y &lt;- svsim(50, nu = 10, rho = -0.1)$y

# Supply initial values
res &lt;- svsample(y,
                startpara = list(mu = -10, sigma = 1))


# Supply initial values for parallel chains
res &lt;- svsample(y,
                startpara = list(list(mu = -10, sigma = 1),
                                 list(mu = -11, sigma = .1, phi = 0.9),
                                 list(mu = -9, sigma = .3, phi = 0.7)),
                parallel = "snow", n_chains = 3, n_cpus = 2)

# Parallel chains with with a pre-defined cluster object
cl &lt;- parallel::makeCluster(2, "PSOCK", outfile = NULL)  # print to console
res &lt;- svsample(y,
                parallel = "snow", n_chains = 3, cl = cl)
parallel::stopCluster(cl)


# Turn on correction for model misspecification
## Since the approximate model is fast and it is working very
##   well in practice, this is turned off by default
res &lt;- svsample(y,
                expert = list(correct_model_misspecification = TRUE))
print(res)

## Not run: 
# Parallel multicore chains (not available on Windows)
res &lt;- svsample(y, draws = 30000, burnin = 10000,
                parallel = "multicore", n_chains = 3, n_cpus = 2)

# Plot using a color palette
palette(rainbow(coda::nchain(para(res, "all"))))
plot(res)

# Use functionality from package 'coda'
## E.g. Geweke's convergence diagnostics
coda::geweke.diag(para(res, "all")[, c("mu", "phi", "sigma")])

# Use functionality from package 'bayesplot'
bayesplot::mcmc_pairs(res, pars = c("sigma", "mu", "phi", "h_0", "h_15"))

## End(Not run)

</code></pre>


</div>