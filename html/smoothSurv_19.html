<div class="container">

<table style="width: 100%;"><tr>
<td>minPenalty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Minimize the penalty term under the two (mean and variance)
constraints
</h2>

<h3>Description</h3>

<p>This function minimizes </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}\sum_{j=m+1}^g \Bigl(\Delta^m a_j\Bigr)^2</code>
</p>
<p> with respect to <code class="reqn">a_1,\dots, a_g</code>
under the constraints
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j = 0</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j (\mu_j^2 + \sigma_0^2) = 1,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^g}\exp(a_l)</code>
</p>

<p>with one of <code class="reqn">a</code>'s fixed to zero.
</p>
<p>Note that the minimum is always zero. We are thus mainly interested in
the point where the minimum is reached.
</p>


<h3>Usage</h3>

<pre><code class="language-R">minPenalty(knots = NULL, dist.range = c(-6, 6), by.knots = 0.3, sdspline = NULL,
    difforder = 3, init.c,
    maxiter = 200, rel.tolerance = 1e-10, toler.chol = 1e-15, toler.eigen = 1e-3,
    maxhalf = 10, debug = 0, info = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>

<p>A vector of knots <code class="reqn">\mu_1,\dots,\mu_g</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.range</code></td>
<td>

<p>Approximate minimal and maximal knot. If not given by <code>knots</code> the knots
are determined as <code>c(seq(0, dist.range[2], by = by.knots), seq(0, dist.range[1], by = -by.knots))</code>.
The sequence of knots is sorted and multiple entries are removed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.knots</code></td>
<td>

<p>The distance between the two knots used when building a vector of knots if these
are not given by <code>knots</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma_0^2</code> of the basis
G-spline (here it appeares only in the variance constraint).
If not given it is determined as 2/3 times the maximal distance between the two knots. If 
<code>sdspline</code> &gt;= 1 it is changed to 0.9 to be able to satisfy the constraints.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>difforder</code></td>
<td>

<p>The order of the finite difference used in the penalty term.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.c</code></td>
<td>

<p>Optional vector of the initial values for the G-spline
coefficients c, all values must lie between 0 and 1
and must sum up to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>Maximum number of Newton-Raphson iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tolerance</code></td>
<td>

<p>(Relative) tolerance to declare the convergence. For this
function, the convergence is declared if absolute value of the
penalty is lower than <code>rel.tolerance</code> and if both
constraints are satisfied up to <code>rel.tolerance</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toler.chol</code></td>
<td>

<p>Tolerance to declare Cholesky decomposition singular.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toler.eigen</code></td>
<td>

<p>Tolerance to declare an eigen value of a matrix to be zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxhalf</code></td>
<td>

<p>Maximum number of step-halving steps if updated estimate leads to a decrease
of the objective function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>

<p>If non-zero print debugging information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>

<p>If TRUE information concerning the iteration process is printed
during the computation to the standard output.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the components “spline”, “penalty”, “warning”,
“fail”.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>spline</code></td>
<td>
<p>A data frame with columns named “Knot”, “SD basis”,
“c coef.” and “a coef.” which gives the optimal values of
<code class="reqn">c_1,\dots, c_g</code> and 
<code class="reqn">a_1,\dots, a_g</code> in the latter two columns. This
data.frame can be further worked out using the function <code>eval.Gspline</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>The value of the penalty term when declaring
convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warning</code></td>
<td>
<p>Possible warnings concerning the convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fail</code></td>
<td>
<p>Failure indicator. It is zero if everything went OK.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">optimum &lt;- minPenalty(knots=seq(-4.2, 4.2, by = 0.3), sdspline=0.2, difforder=3)
where &lt;- optimum$spline
print(where)
show &lt;- eval.Gspline(where, seq(-4.2, 4.2, by=0.05))
plot(show, type="l", bty="n", lwd=2)
</code></pre>


</div>