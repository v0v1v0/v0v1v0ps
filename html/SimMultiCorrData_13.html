<div class="container">

<table style="width: 100%;"><tr>
<td>findintercorr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate Intermediate MVN Correlation for Ordinal, Continuous, Poisson, or Negative Binomial Variables: Correlation Method 1</h2>

<h3>Description</h3>

<p>This function calculates a <code>k x k</code> intermediate matrix of correlations, where <code>k = k_cat + k_cont + k_pois + k_nb</code>,
to be used in simulating variables with <code>rcorrvar</code>.  The ordering of the variables must be
ordinal, continuous, Poisson, and Negative Binomial (note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_pois</code>,
and/or <code>k_nb</code> to be 0).
The function first checks that the target correlation matrix <code>rho</code> is positive-definite and the marginal distributions for the
ordinal variables are cumulative probabilities with r - 1 values (for r categories).  There is a warning given at the end of simulation
if the calculated intermediate correlation matrix <code>Sigma</code> is not positive-definite.  This function is called by the simulation function
<code>rcorrvar</code>, and would only be used separately if the user wants to find the intermediate correlation matrix
only.  The simulation functions also return the intermediate correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findintercorr(n, k_cont = 0, k_cat = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), constants, marginal = list(),
  support = list(), nrand = 100000, lam = NULL, size = NULL,
  prob = NULL, mu = NULL, rho = NULL, seed = 1234, epsilon = 0.001,
  maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cont</code></td>
<td>
<p>the number of continuous variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_pois</code></td>
<td>
<p>the number of Poisson variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_nb</code></td>
<td>
<p>the number of Negative Binomial variables (default = 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  "Fleishman" uses a third-order polynomial transformation
and "Polynomial" uses Headrick's fifth-order transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = "Fleishman") or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = "Polynomial") like that returned by
<code>find_constants</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1; default = list())</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of containing the r
ordered support values; if not provided (i.e. <code>support</code> = list()), the default is for the i-th element to be the vector 1, ..., r</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>a vector of lambda (&gt; 0) constants for the Poisson variables (see <code>Poisson</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>NegBinomial</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>a vector of success probability parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of mean parameters (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the target correlation matrix (<em>must be ordered ordinal, continuous, Poisson, Negative Binomial</em>; default = NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target correlation matrices (default = 0.001)
in the calculation of ordinal intermediate correlations with <code>ordnorm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code>ordnorm</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>the intermediate MVN correlation matrix
</p>


<h3>Overview of Correlation Method 1</h3>

<p>The intermediate correlations used in correlation method 1 are more simulation based than those in correlation method 2, which means that accuracy
increases with sample size and the number of repetitions.  In addition, specifying the seed allows for reproducibility.  In
addition, method 1 differs from method 2 in the following ways:
</p>
<p>1) The intermediate correlation for <b>count variables</b> is based on the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>), which uses a
simulation based, logarithmic transformation of the target correlation.  This method becomes less accurate as the variable mean
gets closer to zero.
</p>
<p>2) The <b>ordinal - count variable</b> correlations are based on an extension of the method of Amatya &amp; Demirtas (2015,
doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>), in which
the correlation correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between the count
variable and the normal variable used to generate it and a simulated upper bound on the correlation between an ordinal variable
and the normal variable used to generate it (see Demirtas &amp; Hedeker, 2011, doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>).
</p>
<p>3) The <b>continuous - count variable</b> correlations are based on an extension of the methods of Amatya &amp; Demirtas (2015) and
Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>), in which the correlation correction factor is the product of the upper Frechet-Hoeffding bound
on the correlation between the count variable and the normal variable used to generate it and the power method correlation
between the continuous variable and the normal variable used to generate it (see Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>).  The
intermediate correlations are the ratio of the target correlations to the correction factor.
</p>
<p>The processes used to find the intermediate correlations for each variable type are described below.  Please see the
corresponding function help page for more information:
</p>


<h3>Ordinal Variables</h3>

<p>Correlations are computed pairwise.  If both variables are binary, the method of Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>) is used to find the
tetrachoric correlation (code adapted from <code>Tetra.Corr.BB</code>).  This method is based on Emrich and Piedmonte's
(1991, doi: <a href="http://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>) work, in which the joint binary distribution is determined from the third and higher moments of a multivariate normal
distribution: Let <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code> be binary variables with <code class="reqn">E[Y_{1}] = Pr(Y_{1} = 1) = p_{1}</code>,
<code class="reqn">E[Y_{2}] = Pr(Y_{2} = 1) = p_{2}</code>, and correlation <code class="reqn">\rho_{y1y2}</code>.  Let <code class="reqn">\Phi[x_{1}, x_{2}, \rho_{x1x2}]</code> be the
standard bivariate normal cumulative distribution function, given by:
</p>
<p style="text-align: center;"><code class="reqn">\Phi[x_{1}, x_{2}, \rho_{x1x2}] = \int_{-\infty}^{x_{1}} \int_{-\infty}^{x_{2}} f(z_{1}, z_{2}, \rho_{x1x2}) dz_{1} dz_{2}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">f(z_{1}, z_{2}, \rho_{x1x2}) = [2\pi\sqrt{1 - \rho_{x1x2}^2}]^{-1} * exp[-0.5(z_{1}^2 - 2\rho_{x1x2}z_{1}z_{2} + z_{2}^2)/(1 - \rho_{x1x2}^2)]</code>
</p>

<p>Then solving the equation
</p>
<p style="text-align: center;"><code class="reqn">\Phi[z(p_{1}), z(p_{2}), \rho_{x1x2}] = \rho_{y1y2}\sqrt{p_{1}(1 - p_{1})p_{2}(1 - p_{2})} + p_{1}p_{2}</code>
</p>

<p>for <code class="reqn">\rho_{x1x2}</code> gives the intermediate correlation of the standard normal variables needed to generate binary variables with
correlation <code class="reqn">\rho_{y1y2}</code>.  Here <code class="reqn">z(p)</code> indicates the <code class="reqn">pth</code> quantile of the standard normal distribution.
</p>
<p>Otherwise, <code>ordnorm</code> is called for each pair.  If the resulting
intermediate matrix is not positive-definite, there is a warning given because it may not be possible to find a MVN correlation
matrix that will produce the desired marginal distributions after discretization.  Any problems with positive-definiteness are
corrected later.
</p>


<h3>Continuous Variables</h3>

<p>Correlations are computed pairwise.  <code>findintercorr_cont</code> is called for each pair.
</p>


<h3>Poisson Variables</h3>

<p><code>findintercorr_pois</code> is called to calculate the intermediate MVN correlation for all Poisson variables.
</p>


<h3>Negative Binomial Variables</h3>

<p><code>findintercorr_nb</code> is called to calculate the intermediate MVN correlation for all Negative
Binomial variables.
</p>


<h3>Continuous - Ordinal Pairs</h3>

<p><code>findintercorr_cont_cat</code> is called to calculate the intermediate MVN correlation for all
Continuous and Ordinal combinations.
</p>


<h3>Ordinal - Poisson Pairs</h3>

<p><code>findintercorr_cat_pois</code> is called to calculate the intermediate MVN correlation for all
Ordinal and Poisson combinations.
</p>


<h3>Ordinal - Negative Binomial Pairs</h3>

<p><code>findintercorr_cat_nb</code> is called to calculate the intermediate MVN correlation for all
Ordinal and Negative Binomial combinations.
</p>


<h3>Continuous - Poisson Pairs</h3>

<p><code>findintercorr_cont_pois</code> is called to calculate the intermediate MVN correlation for all
Continuous and Poisson combinations.
</p>


<h3>Continuous - Negative Binomial Pairs</h3>

<p><code>findintercorr_cont_nb</code> is called to calculate the intermediate MVN correlation for all
Continuous and Negative Binomial combinations.
</p>


<h3>Poisson - Negative Binomial Pairs</h3>

<p><code>findintercorr_pois_nb</code> is called to calculate the intermediate MVN correlation for all
Poisson and Negative Binomial combinations.
</p>


<h3>References</h3>

<p>Please see <code>rcorrvar</code> for additional references.
</p>
<p>Emrich LJ &amp; Piedmonte MR (1991). A Method for Generating High-Dimensional Multivariate Binary Variables. The American Statistician, 45(4): 302-4.
doi: <a href="http://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>.
</p>
<p>Inan G &amp; Demirtas H (2016). BinNonNor: Data Generation with Binary and Continuous Non-Normal Components.
R package version 1.3. <a href="https://CRAN.R-project.org/package=BinNonNor">https://CRAN.R-project.org/package=BinNonNor</a>
</p>
<p>Vale CD &amp; Maurelli VA (1983). Simulating Multivariate Nonnormal Distributions. Psychometrika, 48, 465-471. doi: <a href="http://doi.org/10.1007/BF02293687">10.1007/BF02293687</a>.
</p>


<h3>See Also</h3>

<p><code>find_constants</code>, <code>rcorrvar</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# Binary, Ordinal, Continuous, Poisson, and Negative Binomial Variables

options(scipen = 999)
seed &lt;- 1234
n &lt;- 10000

# Continuous Distributions: Normal, t (df = 10), Chisq (df = 4),
# Beta (a = 4, b = 2), Gamma (a = 4, b = 4)
Dist &lt;- c("Gaussian", "t", "Chisq", "Beta", "Gamma")

# calculate standardized cumulants
# those for the normal and t distributions are rounded to ensure the
# correct values (i.e. skew = 0)

M1 &lt;- round(calc_theory(Dist = "Gaussian", params = c(0, 1)), 8)
M2 &lt;- round(calc_theory(Dist = "t", params = 10), 8)
M3 &lt;- calc_theory(Dist = "Chisq", params = 4)
M4 &lt;- calc_theory(Dist = "Beta", params = c(4, 2))
M5 &lt;- calc_theory(Dist = "Gamma", params = c(4, 4))
M &lt;- cbind(M1, M2, M3, M4, M5)
M &lt;- round(M[-c(1:2),], digits = 6)
colnames(M) &lt;- Dist
rownames(M) &lt;- c("skew", "skurtosis", "fifth", "sixth")
means &lt;- rep(0, length(Dist))
vars &lt;- rep(1, length(Dist))

# calculate constants
con &lt;- matrix(1, nrow = ncol(M), ncol = 6)
for (i in 1:ncol(M)) {
 con[i, ] &lt;- find_constants(method = "Polynomial", skews = M[1, i],
                            skurts = M[2, i], fifths = M[3, i],
                            sixths = M[4, i])
}

# Binary and Ordinal Distributions
marginal &lt;- list(0.3, 0.4, c(0.1, 0.5), c(0.3, 0.6, 0.9),
                 c(0.2, 0.4, 0.7, 0.8))
support &lt;- list()

# Poisson Distributions
lam &lt;- c(1, 5, 10)

# Negative Binomial Distributions
size &lt;- c(3, 6)
prob &lt;- c(0.2, 0.8)

ncat &lt;- length(marginal)
ncont &lt;- ncol(M)
npois &lt;- length(lam)
nnb &lt;- length(size)

# Create correlation matrix from a uniform distribution (-0.8, 0.8)
set.seed(seed)
Rey &lt;- diag(1, nrow = (ncat + ncont + npois + nnb))
for (i in 1:nrow(Rey)) {
  for (j in 1:ncol(Rey)) {
    if (i &gt; j) Rey[i, j] &lt;- runif(1, -0.8, 0.8)
    Rey[j, i] &lt;- Rey[i, j]
  }
}

# Test for positive-definiteness
library(Matrix)
if(min(eigen(Rey, symmetric = TRUE)$values) &lt; 0) {
  Rey &lt;- as.matrix(nearPD(Rey, corr = T, keepDiag = T)$mat)
}

# Make sure Rey is within upper and lower correlation limits
valid &lt;- valid_corr(k_cat = ncat, k_cont = ncont, k_pois = npois,
                    k_nb = nnb, method = "Polynomial", means = means,
                    vars = vars, skews = M[1, ], skurts = M[2, ],
                    fifths = M[3, ], sixths = M[4, ], marginal = marginal,
                    lam = lam, size = size, prob = prob, rho = Rey,
                    seed = seed)

# Find intermediate correlation
Sigma1 &lt;- findintercorr(n = n, k_cont = ncont, k_cat = ncat, k_pois = npois,
                        k_nb = nnb, method = "Polynomial", constants = con,
                        marginal = marginal, lam = lam, size = size,
                        prob = prob, rho = Rey, seed = seed)
Sigma1


## End(Not run)
</code></pre>


</div>