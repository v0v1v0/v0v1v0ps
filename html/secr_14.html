<div class="container">

<table style="width: 100%;"><tr>
<td>rbind.capthist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Combine capthist Objects </h2>

<h3>Description</h3>

<p>Form a single <code>capthist</code> object from two or more compatible <code>capthist</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
  MS.capthist(...)
  append.capthist(..., synchronous = TRUE)
  
  ## S3 method for class 'capthist'
rbind(..., renumber = TRUE, pool = NULL, verify = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> one or more <code>capthist</code> objects or lists of
<code>capthist</code> objects </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>synchronous</code></td>
<td>
<p>logical; if TRUE occasions are assumed to coincide</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>renumber</code></td>
<td>
<p> logical, if TRUE assigns new composite individual ID </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool</code></td>
<td>
<p> list of vectors of session indices or names </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verify</code></td>
<td>
<p> logical, if TRUE the output is checked with <code>verify</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MS.capthist</code> concatenates the sessions in the input objects as
one multi-session capthist object. Each session may use a different
detector array (traps) and a different number of sampling
occasions. Session names are derived implicitly from the inputs, or
may be given explicitly (see Examples); if any name is duplicated, all
will be replaced with sequential integers. The ... argument may include
lists of single-session capthist objects.
</p>
<p><code>append.capthist</code> constructs a single-session capthist assuming the inputs 
are independent capthist objects. Individuals and detectors are renumbered. Occasions are assumed to be synchronous by default. This is an alternative to rbind when the detector array varies.
</p>
<p>The <code>rbind</code> method for capthist objects is used to pool capture data 
from more than one
session into a single session. The number of rows in the output
session is the sum of the number of rows in the input sessions
(i.e. each animal appears in only one session). Sessions to be pooled with 
<code>rbind</code> must have the same number of capture occasions and use the 
same detectors (traps). At present there is no function to pool capthist 
data from different detector arrays. For this it is recommended that you 
merge the input files and rebuild the capthist object from scratch.
</p>
<p>For <code>rbind.capthist</code>, the ... argument may be </p>

<ol>
<li>
<p> A series of single-session capthist objects, which are
pooled to form one new single-session object, or
</p>
</li>
<li>
<p> One multi-session capthist object, when the components of
‘pool’ are used to define combinations of old sessions; e.g. <code>pool =
    list(A=1:3, B=4:5)</code> produces an object with two sessions (named ‘A’
and ‘B’) from 5 old ones. If <code>pool = NULL</code> (the default) then all the
sessions are pooled to form one single-session capthist object.
</p>
</li>
</ol>
<p>The names of arguments other than ... should be given in full. If
<code>renumber = TRUE</code> (the default), the session name will be prepended
to the animal ID before pooling: animals 1, 2 and 3 in Session A will
become A.1, A.2 and A.3, while those in Session B become B.1, B.2 and
B.3. This ensures that each animal has a unique ID. If <code>renumber =
FALSE</code>, the animal IDs will not change.
</p>
<p>Other attributes (xy, signal) are handled appropriately. If the signal
threshold (attribute ‘cutval’) differs among sessions, the maximum is
used and detections of lower signal strength are discarded.
</p>
<p>The use of <code>rbind.capthist</code> to concatenate sessions is now deprecated: 
use <code>MS.capthist</code>. 
</p>
<p>Although <code>MS.capthist</code> looks like an S3 method, it isn't. The full function name must be used. <code>rbind.capthist</code> became an S3 method in <span class="pkg">secr</span> 3.1, so it is called as <code>rbind</code> alone.
</p>


<h3>Value</h3>

<p>For <code>MS.capthist</code>, a multi-session object of class ‘capthist’ with
number of sessions equal to the number of sessions in the objects in
....
</p>
<p>For <code>append.capthist</code>, a single-session of class ‘capthist’. When ‘synchronous’ the dimensions are (<code class="reqn">\sum n_i, \mbox{max}~ S_i, \sum K_i</code>) where (<code class="reqn">n_i, S_i, K_i</code>) are the numbers of individuals, occasions and detectors in the i-th input. Otherwise the dimensions are (<code class="reqn">\sum n_i, \sum S_i, \sum K_i</code>). An index to the original component is saved in the traps covariate ‘sub’.
</p>
<p>For <code>rbind.capthist</code>, either an object of class ‘capthist’ with one 
session formed by pooling the sessions in the input objects, or a 
capthist object with more than one session, each formed by pooling 
groups of sessions defined by the ‘pool’ argument. Covariate columns that appear in
all input sessions are retained in the output. 
</p>


<h3>See Also</h3>

 <p><code>capthist</code>, <code>subset.capthist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
## extend a multi-session object
## we fake the 2010 data by copying from 2005
## note how we name the appended session
fakeCH &lt;- ovenCH[["2005"]]
MS.capthist(ovenCH, "2010" = fakeCH)

## simulate sessions for 2-part mixture
temptrap &lt;- make.grid(nx = 8, ny = 8)
temp1 &lt;- sim.capthist(temptrap,
    detectpar = list(g0 = 0.1, sigma = 40))
temp2 &lt;- sim.capthist(temptrap,
    detectpar = list(g0 = 0.2, sigma = 20))

## concatenate sessions
temp3 &lt;- MS.capthist(large.range = temp1, small.range = temp2)
summary(temp3)
## session-specific movement statistic
RPSV(temp3)

## pool sessions
temp4 &lt;- rbind(temp1, temp2)
summary(temp4)
RPSV(temp4)

## compare mixture to sum of components
## note `detectors visited' is not additive for 'multi' detector
## nor is `detectors used'
(summary(temp1)$counts +  summary(temp2)$counts) -
    summary(temp4)$counts

## Not run: 

## compare two different model fits 
tempfit3 &lt;- secr.fit(temp3, CL = TRUE, buffer = 150, model = list
    (g0 ~ session, sigma ~ session), trace = FALSE)
predict(tempfit3)

## if we can tell which animals had large ranges...
covariates(temp4) &lt;- data.frame(range.size = rep(c("large",
    "small"), c(nrow(temp1), nrow(temp2))))
tempfit4 &lt;- secr.fit(temp4, CL = TRUE, buffer = 150, model = list
    (g0 ~ range.size, sigma ~ range.size), trace = FALSE)
predict(tempfit4, newdata = data.frame(range.size = c("large",
    "small")))

## polygon data
pol1 &lt;- make.poly()
pol2 &lt;- make.poly(x = c(50,50,150,150))
ch1 &lt;- sim.capthist(pol1, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
ch2 &lt;- sim.capthist(pol2, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(ch1); plot(pol2, add = TRUE); plot(ch2, add = TRUE)


## End(Not run)

</code></pre>


</div>