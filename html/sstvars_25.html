<div class="container">

<table style="width: 100%;"><tr>
<td>fitSTVAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two-phase maximum likelihood estimation of a reduced form smooth transition VAR model</h2>

<h3>Description</h3>

<p><code>fitSTVAR</code> estimates a reduced form smooth transition VAR model in two phases:
in the first phase, it uses a genetic algorithm to find starting values for a gradient based
variable metric algorithm, which it then uses to finalize the estimation in the second phase.
Parallel computing is utilized to perform multiple rounds of estimations in parallel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitSTVAR(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  nrounds = (M + 1)^5,
  ncores = 2,
  maxit = 1000,
  seeds = NULL,
  print_res = TRUE,
  use_parallel = TRUE,
  filter_estimates = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt>
<code>"relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt>
<code>"logistic"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt>
<code>"exponential"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt>
<code>"exogenous"</code>:</dt>
<dd>
<p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>
<p>See the vignette for more details about the weight functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt>
<dd>
<p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt>
<dd>
<p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt>
<dd>
<p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt>
<dd>
<p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt>
<dd>
<p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, or <code>"ind_Student"</code>,
where the latest is the Student's <code class="reqn">t</code> distribution with independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 x 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> in order to constrain the
the weight parameter to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrounds</code></td>
<td>
<p>the number of estimation rounds that should be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>a length <code>nrounds</code> vector containing the random number generator seed
for each call to the genetic algorithm, or <code>NULL</code> for not initializing the seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>use_parallel=FALSE &amp;&amp; print_res=FALSE</code>,
nothing is printed during the estimation process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter_estimates</code></td>
<td>
<p>should the likely inappropriate estimates be filtered? See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you wish to estimate a structural model, estimate first the reduced form model and then use the
use the function <code>fitSSTVAR</code> to create (and estimate if necessary) the structural model
based on the estimated reduced form model.
</p>
<p>Because of complexity and high multimodality of the log-likelihood function, it is <strong>not certain</strong>
that the estimation algorithm will end up in the global maximum point. It is expected that many of the
estimation rounds will end up in some local maximum or a saddle point instead. Therefore, a (sometimes very large)
number of estimation rounds is required for reliable results. Due to identification problems and high complexity of
the surface of the log-likelihood function, the estimation may fail especially in the cases where the number of
regimes is chosen too large.
</p>
<p>The estimation process is computationally heavy and it might take considerably long time for large models to
estimate. Note that estimation of model with <code>cond_dist == "ind_Student"</code> is computationally substantially
more demanding than standard Gaussian and Student's t models due to the different structure of the log-likelihood
function (parametrized directly via impact matrices rather than covariance matrices of the regimes).
</p>
<p>If the iteration limit <code>maxit</code> in the variable metric algorithm is reached, one can continue the estimation by
iterating more with the function <code>iterate_more</code>. Alternatively, one may use the found estimates as starting values
for the genetic algorithm and employ another round of estimation (see <code>??GAfit</code> how to set up an initial population
with the dot parameters).
</p>
<p><strong>If the estimation algorithm performs poorly</strong>, it usually helps to scale the individual series so that they
vary roughly in the same scale. This makes it is easier to draw reasonable AR coefficients and (with some weight functions)
weight parameter values in the genetic algorithm. Even if the estimation algorithm somewhat works, it should be preferred
to scale the data so that most of the AR coefficients will not be very large, as the estimation algorithm works better with
relatively small AR coefficients. If needed, another package can be used to fit linear VARs to the series to see which scaling
of the series results in relatively small AR coefficients. You should avoid very small (or very high) variance in the data as
well so that the eigenvalues of the covariance matrices are in a reasonable range.
</p>
<p><strong>weight_constraints:</strong> If you are using weight constraints other than restricting some of the weight parameters to known
constants, make sure the constraints are sensible. Otherwise, the estimation may fail due to the estimation algorithm not being
able to generate reasonable random guesses for the values of the constrained weight parameters.
</p>
<p><strong>Filtering inappropriate estimates:</strong> If <code>filter_estimates == TRUE</code>, the code will automatically filter
through estimates that it deems "inappropriate". That is, estimates that are not likely solutions of interest.
Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
any modulus of the eigenvalues of the companion form AR matrices larger than $0.9985$ (indicating the necessary condition for
stationarity is close to break), or transition weights such that they are close to zero for almost all <code class="reqn">t</code> for at least
one regime. You can also set <code>filter_estimates=FALSE</code> and find the solutions of interest yourself by using the
function <code>alt_stvar</code> (which can used with <code>filter_estimates=TRUE</code> as well since results from all estimation rounds
are saved).
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td>
</tr>
</table>
<h3>S3 methods</h3>

<p>The following S3 methods are supported for class <code>'stvar'</code>: <code>logLik</code>, <code>residuals</code>, <code>print</code>, <code>summary</code>,
<code>predict</code>, <code>simulate</code>, and <code>plot</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li>
<p> Hubrich K., Ter√§svirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li>
<p> Lanne M., Virolainen S. 2024. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li>
<p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li>
<p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li>
<p> Virolainen S. 2024. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>fitSSTVAR</code>, <code>STVAR</code>, <code>GAfit</code>, <code>iterate_more</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## These are long running examples. Running all the below examples will take
## approximately three minutes.
# When estimating the models in empirical applications, typically a large number
# of estimation rounds (set by the argument 'nrounds') should be used. These examples
# use only a small number of rounds to make the running time of the examples reasonable.

# The below examples make use of the two-variate dataset 'gdpdef' containing
# the the quarterly U.S. GDP and GDP deflator from 1947Q1 to 2019Q4.

# Estimate Gaussian STVAR model of autoregressive order p=3 and two regimes (M=2),
# with the weighted relative stationary densities of the regimes as the transition
# weight function. The estimation is performed with 2 rounds and 2 CPU cores, with
# the random number generator seeds set for reproducibility.
fit32 &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="relative_dens",
 cond_dist="Gaussian", nrounds=2, ncores=2, seeds=1:2)

# Examine the results:
fit32 # Printout of the estimates
summary(fit32) # A more detailed summary printout
plot(fit32) # Plot the fitted transition weights
get_foc(fit32) # Gradient of the log-likelihood function about the estimate
get_soc(fit32) # Eigenvalues of the Hessian of the log-lik. fn. about the estimate
profile_logliks(fit32) # Profile log-likelihood functions about the estimate

# Estimate a two-regime Student's t STVAR p=3 model with logistic transition weights
# and the first lag of the second variable as the switching variable, only two
# estimation rounds using two CPU cores:
fitlogistict32 &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 cond_dist="Student", nrounds=2, ncores=2, seeds=1:2)
summary(fitlogistict32) # Summary printout of the estimates

# Estimate a two-regime threshold VAR p=3 model with independent Student's t shocks.
# The first lag of the the second variable is specified as the switching variable,
# and the threshold parameter constrained to the fixed value 1.
fitthres32wit &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="threshold", weightfun_pars=c(2, 1),
  cond_dist="ind_Student", weight_constraints=list(R=0, r=1), nrounds=2, ncores=2, seeds=1:2)
plot(fitthres32wit) # Plot the fitted transition weights

# Estimate a two-regime STVAR p=1 model with exogenous transition weights defined as the indicator
# of NBER based U.S. recessions (source: St. Louis Fed database). Moreover, restrict the AR matrices
# to be identical across the regimes (i.e., allowing for time-variation in the intercepts and the
# covariance matrix only):

# Step 1: Define transition weights of Regime 1 as the indicator of NBER based U.S. recessions
# (the start date of weights is start of data + p, since the first p values are used as the initial
# values):
tw1 &lt;- c(0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

# Step 2: Define the transition weights of Regime 2 as one minus the weights of Regime 1, and
# combine the weights to matrix of transition weights:
twmat &lt;- cbind(tw1, 1 - tw1)

# Step 3: Create the appropriate constraint matrix:
C_122 &lt;- rbind(diag(1*2^2), diag(1*2^2))

# Step 4: Estimate the model by specifying the weights in the argument 'weightfun_pars'
# and the constraint matrix in the argument 'AR_constraints':
fitexo12cit &lt;- fitSTVAR(gdpdef, p=1, M=2, weight_function="exogenous", weightfun_pars=twmat,
  cond_dist="ind_Student", AR_constraints=C_122, nrounds=2, ncores=2, seeds=1:2)
plot(fitexo12cit) # Plot the transition weights
summary(fitexo12cit) # Summary printout of the estimates

# Estimate a two-regime Gaussian STVAR p=1 model with the weighted relative stationary densities
# of the regimes as the transition weight function, and the means of the regimes
# and AR matrices constrained to be identical across the regimes (i.e., allowing for time-varying
# conditional covariance matrix only):
fit12cm &lt;- fitSTVAR(gdpdef, p=1, M=2, weight_function="relative_dens", cond_dist="Gaussian",
 AR_constraints=C_122, mean_constraints=list(1:2), parametrization="mean", nrounds=2, seeds=1:2)
fit12cm # Print the estimates

# Estimate a two-regime Gaussian STVAR p=1 model with the weighted relative stationary densities
# of the regimes as the transition weight function; constrain AR matrices to be identical
# across the regimes and also constrain the off-diagonal elements of the AR matrices to be zero.
mat0 &lt;- matrix(c(1, rep(0, 10), 1, rep(0, 8), 1, rep(0, 10), 1), nrow=2*2^2, byrow=FALSE)
C_222 &lt;- rbind(mat0, mat0) # The constraint matrix
fit22c &lt;- fitSTVAR(gdpdef, p=2, M=2, weight_function="relative_dens", cond_dist="Gaussian",
 AR_constraints=C_222, nrounds=2, seeds=1:2)
fit22c # Print the estimates

# Estimate a two-regime Student's t STVAR p=3 model with logistic transition weights
# and the first lag of the second variable as the switching variable. Constraint the location
# parameter to the fixed value 1 and leave the scale parameter unconstrained.
fitlogistic32w &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(1, 0)), nrounds=2, seeds=1:2)
plot(fitlogistic32w) # Plot the fitted transition weights

# Estimate a two-regime Gaussian STVAR p=3 model with multinomial logit transition weights
# using the second variable is the switching variable with two lags. Constrain the AR matrices
# identical across the regimes (allowing for time-variation in the intercepts and covariance
# matrix).
C_322 &lt;- rbind(diag(3*2^2), diag(3*2^2)) # The constraint matrix
fitmlogit32c &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="mlogit", cond_dist="Gaussian",
 weightfun_pars=list(vars=2, lags=2), AR_constraints=C_322, nrounds=1, seeds=3, ncores=1)
plot(fitmlogit32c) # Plot the fitted transition weights

# Estimate a two-regime Gaussian STVAR p=3 model with exponential transition weights and the first
# lag of the second variable as switching variable, and AR parameter constrained identical across
# the regimes, means constrained identical across the regimes, and the location parameter
# constrained to 0.5 (but scale parameter unconstrained).
fitexp32cmw &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="exponential", weightfun_pars=c(2, 1),
 cond_dist="Student", AR_constraints=C_322, mean_constraints=list(1:2),
 weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(0.5, 0)), nrounds=1, seeds=1, ncores=1)
summary(fitexp32cmw) # Summary printout of the estimates

</code></pre>


</div>