<div class="container">

<table style="width: 100%;"><tr>
<td>glmsmurf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Multi-Type Regularized GLM Using the SMuRF Algorithm</h2>

<h3>Description</h3>

<p>SMuRF algorithm to fit a generalized linear model (GLM) with multiple types of predictors via regularized maximum likelihood.
<code>glmsmurf.fit</code> contains the fitting function for a given design matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmsmurf(
  formula,
  family,
  data,
  weights,
  start,
  offset,
  lambda,
  lambda1 = 0,
  lambda2 = 0,
  pen.weights,
  adj.matrix,
  standardize = TRUE,
  control = list(),
  x.return = FALSE,
  y.return = TRUE,
  pen.weights.return = FALSE
)

glmsmurf.fit(
  X,
  y,
  weights,
  start,
  offset,
  family,
  pen.cov,
  n.par.cov,
  group.cov,
  refcat.cov,
  lambda,
  lambda1 = 0,
  lambda2 = 0,
  pen.weights,
  adj.matrix,
  standardize = TRUE,
  control = list(),
  formula = NULL,
  data = NULL,
  x.return = FALSE,
  y.return = FALSE,
  pen.weights.return = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A <code>formula</code> object describing the model to be fitted. 
Penalties are specified using the <code>p</code> function. For <code>glmsmurf.fit</code> this is an optional argument which is only used when penalty weights are computed using a generalized additive model (GAM).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A <code>family</code> object specifying the error distribution and link function for the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the model response and predictors for <code>n</code> observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of prior weights to use in the likelihood. It should be a numeric vector of length <code>n</code> (the number of observations),
or <code>NULL</code>. When <code>NULL</code> or nothing is given, equal prior weights (all ones) will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A vector containing the starting values for the coefficients. It should either be a numeric vector 
of length <code>p+1</code> (with <code>p</code> the number of parameters excluding the intercept) or <code>NULL</code>. In the latter case, the link function applied to the weighted average of the response vector is used 
as starting value for the intercept and zero for the other coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector containing the offset for the model. It should be a vector of size <code>n</code> or NULL (no offset). 
Offset(s) specified using the <code>formula</code> object will be ignored!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Either the penalty parameter, a positive number; or a string describing the method and measure used to select the penalty parameter:
</p>

<ul>
<li> <p><code>"is.aic"</code> (in-sample; Akaike Information Criterion (AIC)),
</p>
</li>
<li> <p><code>"is.bic"</code> (in-sample; Bayesian Information Criterion (BIC)),
</p>
</li>
<li> <p><code>"is.gcv"</code> (in-sample; Generalized Cross-Validation (GCV) score),
</p>
</li>
<li> <p><code>"oos.dev"</code> (out-of-sample; deviance), 
</p>
</li>
<li> <p><code>"oos.mse"</code> (out-of-sample; Mean Squared Error (MSE)),
</p>
</li>
<li> <p><code>"oos.dss"</code> (out-of-sample; Dawid-Sebastiani Score (DSS)),
</p>
</li>
<li> <p><code>"cv.dev"</code> (cross-validation (CV); deviance),
</p>
</li>
<li> <p><code>"cv.mse"</code> (CV; MSE),
</p>
</li>
<li> <p><code>"cv.dss"</code> (CV; DSS),
</p>
</li>
<li> <p><code>"cv1se.dev"</code> (CV with one standard error (SE) rule; deviance),
</p>
</li>
<li> <p><code>"cv1se.mse"</code> (CV with one SE rule; MSE),
</p>
</li>
<li> <p><code>"cv1se.dss"</code> (CV with one SE rule; DSS).
</p>
</li>
</ul>
<p>E.g. <code>"is.aic"</code> indicates in-sample selection of lambda with the AIC as measure.
When <code>lambda</code> is missing or <code>NULL</code>, it will be selected using cross-validation with the one standard error rule and the deviance as measure (<code>"cv1se.dev"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>The penalty parameter for the <code class="reqn">L_1</code>-penalty in Sparse (Generalized) Fused Lasso or Sparse Graph-Guided Fused Lasso is <code class="reqn">\lambda \times \lambda_1</code>. 
A positive numeric with default 0 (no extra  <code class="reqn">L_1</code>-penalty).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>The penalty parameter for the <code class="reqn">L_2</code>-penalty in Group (Generalized) Fused Lasso or Group Graph-Guided Fused Lasso is <code class="reqn">\lambda \times \lambda_2</code>. A positive numeric with default 0 (no extra <code class="reqn">L_2</code>-penalty).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.weights</code></td>
<td>
<p>Either a string describing the method to compute the penalty weights: 
</p>

<ul>
<li> <p><code>"eq"</code> (default; equal penalty weights),
</p>
</li>
<li> <p><code>"stand"</code> (standardization penalty weights),
</p>
</li>
<li> <p><code>"glm"</code> (adaptive GLM penalty weights),
</p>
</li>
<li> <p><code>"glm.stand"</code> (stand. ad. GLM penalty weights), 
</p>
</li>
<li> <p><code>"gam"</code> (ad. GAM penalty weights),
</p>
</li>
<li> <p><code>"gam.stand"</code> (stand. ad. GAM penalty weights);
</p>
</li>
</ul>
<p>or a list with the penalty weight vector per predictor. This list should have length equal to the number of predictors and predictor names as element names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.matrix</code></td>
<td>
<p>A named list containing the adjacency matrices (a.k.a. neighbor matrices) for each of the predictors with a Graph-Guided Fused Lasso penalty. 
The list elements should have the names of the corresponding predictors. If only one predictor has a Graph-Guided Fused Lasso penalty, 
it is also possible to only give the adjacency matrix itself (not in a list).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical indicating if predictors with a Lasso or Group Lasso penalty are standardized, default is <code>TRUE</code>.
The returned coefficients are always on the original (i.e. non-standardized) scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of parameters used in the fitting process. This is passed to <code>glmsmurf.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.return</code></td>
<td>
<p>Logical indicating if the used model matrix should be returned in the output object, default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.return</code></td>
<td>
<p>Logical indicating if the used response vector should be returned in the output object, default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.weights.return</code></td>
<td>
<p>Logical indicating if the list of the used penalty weight vector per predictor should be returned in the output object, default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: the design matrix including ones for the intercept. A <code>n</code> by <code>(p+1)</code> matrix which can
be of numeric matrix class (<code>matrix-class</code>) or of class Matrix (<code>Matrix-class</code>) including sparse matrix class (<code>dgCMatrix-class</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: the response vector, a numeric vector of size <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.cov</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: a list with the penalty type per predictor (covariate). A named list of strings with predictor names as element names. 
Possible types: <code>"none"</code> (no penalty, e.g. for intercept), <code>"lasso"</code> (Lasso), <code>"grouplasso"</code> (Group Lasso), 
<code>"flasso"</code> (Fused Lasso), <code>"gflasso"</code> (Generalized Fused Lasso), 
<code>"2dflasso"</code> (2D Fused Lasso) or <code>"ggflasso"</code> (Graph-Guided Fused Lasso).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.par.cov</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: a list with the number of parameters to estimate per predictor (covariate). A named list of strictly positive integers with predictor names as element names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.cov</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: a list with the group of each predictor (covariate) which is only used for the Group Lasso penalty. 
A named list of positive integers with predictor names as element names where 0 means no group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refcat.cov</code></td>
<td>
<p>Only for <code>glmsmurf.fit</code>: a list with the number of the reference category in the original order of the levels of each predictor (covariate).
When the predictor is not a factor or no reference category is present, it is equal to 0. This number will only be taken into account for a Fused Lasso, Generalized Fused Lasso or Graph-Guided Fused Lasso penalty 
when a reference category is present.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the package vignette for more details and a complete description of a use case.
</p>
<p>As a user, it is important to take the following into acocunt:
</p>

<ul>
<li>
<p> The estimated coefficients are rounded to 7 digits.
</p>
</li>
<li>
<p> The cross-validation folds are not deterministic. The validation sample for selecting lambda out-of-sample is determined at random when no indices are provided 
in 'validation.index' in the control object argument. In these cases, the selected value of lambda is hence not deterministic. 
When selecting lambda in-sample, or out-of-sample when indices are provided in 'validation.index' in the control object argument, the selected value of lambda is deterministic.
</p>
</li>
<li>
<p> The <code>glmsmurf</code> function can handle many use cases and is preferred for general use.
The <code>glmsmurf.fit</code> function requires a more thorough understanding of the package internals and should hence be used with care!
</p>
</li>
</ul>
<h3>Value</h3>

<p>An object of class '<code>glmsmurf</code>' is returned. See <code>glmsmurf-class</code> for more details about this class and its generic functions.
</p>


<h3>References</h3>

<p>Devriendt, S., Antonio, K., Reynkens, T. and Verbelen, R. (2021). "Sparse Regression with Multi-type Regularized Feature Modeling", Insurance: Mathematics and Economics, 96, 248–261. &lt;doi:10.1016/j.insmatheco.2020.11.010&gt;.
</p>
<p>Hastie, T., Tibshirani, R., and Wainwright, M. (2015). <em>Statistical Learning with Sparsity: The Lasso and Generalizations</em>. CRC Press.
</p>


<h3>See Also</h3>

<p><code>glmsmurf-class</code>, <code>glmsmurf.control</code>, <code>p</code>, <code>glm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Munich rent data from catdata package
data("rent", package = "catdata")

# The considered predictors are the same as in 
# Gertheiss and Tutz (Ann. Appl. Stat., 2010).
# Response is monthly rent per square meter in Euro

# Urban district in Munich
rent$area &lt;- as.factor(rent$area)

# Decade of construction
rent$year &lt;- as.factor(floor(rent$year / 10) * 10)

# Number of rooms
rent$rooms &lt;- as.factor(rent$rooms)

# Quality of the house with levels "fair", "good" and "excellent"
rent$quality &lt;- as.factor(rent$good + 2 * rent$best)
levels(rent$quality) &lt;- c("fair", "good", "excellent")

# Floor space divided in categories (0, 30), [30, 40), ...,  [130, 140)
sizeClasses &lt;- c(0, seq(30, 140, 10))
rent$size &lt;- as.factor(sizeClasses[findInterval(rent$size, sizeClasses)])

# Is warm water present?
rent$warm &lt;- factor(rent$warm, labels = c("yes", "no"))

# Is central heating present?
rent$central &lt;- factor(rent$central, labels = c("yes", "no"))

# Does the bathroom have tiles?
rent$tiles &lt;- factor(rent$tiles, labels = c("yes", "no"))

# Is there special furniture in the bathroom?
rent$bathextra &lt;- factor(rent$bathextra, labels = c("no", "yes"))

# Is the kitchen well-equipped?
rent$kitchen &lt;- factor(rent$kitchen, labels = c("no", "yes"))



# Create formula with 'rentm' as response variable,
# 'area' with a Generalized Fused Lasso penalty,
# 'year', 'rooms', 'quality' and 'size' with Fused Lasso penalties,
# and the other predictors with Lasso penalties.
formu &lt;- rentm ~ p(area, pen = "gflasso") + 
 p(year, pen = "flasso") + p(rooms, pen = "flasso") + 
 p(quality, pen = "flasso") + p(size, pen = "flasso") +
 p(warm, pen = "lasso") + p(central, pen = "lasso") + 
 p(tiles, pen = "lasso") + p(bathextra, pen = "lasso") + 
 p(kitchen, pen = "lasso") 


# Fit a multi-type regularized GLM using the SMuRF algorithm.
# We use standardization adaptive penalty weights based on an initial GLM fit.
# The value for lambda is selected using cross-validation 
# (with the deviance as loss measure and the one standard error rule), see example(plot_lambda) 
munich.fit &lt;- glmsmurf(formula = formu, family = gaussian(), data = rent, 
                       pen.weights = "glm.stand", lambda = 0.02)


####
# S3 methods for glmsmurf objects


# Model summary
summary(munich.fit) 


# Get coefficients of estimated model
coef(munich.fit) 
# Get coefficients of re-estimated model
coef_reest(munich.fit)
 

# Plot coefficients of estimated model
plot(munich.fit)
# Plot coefficients of re-estimated model
plot_reest(munich.fit)


# Get deviance of estimated model
deviance(munich.fit) 
# Get deviance of re-estimated model
deviance_reest(munich.fit)


# Get fitted values of estimated model
fitted(munich.fit) 
# Get fitted values of re-estimated model
fitted_reest(munich.fit)


# Get predicted values of estimated model on scale of linear predictors
predict(munich.fit, type = "link") 
# Get predicted values of re-estimated model on scale of linear predictors
predict_reest(munich.fit, type = "link")


# Get deviance residuals of estimated model
residuals(munich.fit, type = "deviance") 
# Get deviance residuals of re-estimated model
residuals_reest(munich.fit, type = "deviance")
</code></pre>


</div>