<div class="container">

<table style="width: 100%;"><tr>
<td>opt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimum Sample Allocation in Stratified Sampling</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>A classical problem in survey methodology in stratified sampling is optimum
sample allocation. This problem is formulated as determination of strata
sample sizes that minimize the variance of the
<em>stratified <code class="reqn">\pi</code> estimator</em> of the population total (or mean) of a
given study variable, under certain constraints on sample sizes in strata.
</p>
<p>The <code>opt()</code> user function solves the following optimum sample allocation
problem, formulated below in the language of mathematical optimization.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">f(x_1,\ldots,x_H) = \sum_{h=1}^H \frac{A^2_h}{x_h}</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H x_h = n</code>
</p>

<p style="text-align: center;"><code class="reqn">m_h \leq x_h \leq M_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">n &gt; 0,\, A_h &gt; 0,\, m_h &gt; 0,\, M_h &gt; 0</code>, such that
<code class="reqn">m_h &lt; M_h,\, h = 1,\ldots,H</code>, and
<code class="reqn">\sum_{h=1}^H m_h \leq n \leq \sum_{h=1}^H M_h</code>, are given numbers.
The minimization is on <code class="reqn">\mathbb R_+^H</code>.
</p>
<p>The inequality constraints are optional and user can choose whether and how
they are to be added to the optimization problem. This is achieved by the
proper use of <code>m</code> and <code>M</code> arguments of this function, according to the
following rules:
</p>

<ul>
<li>
<p> no inequality constraints imposed: both <code>m</code> and <code>M</code> must be both set to
<code>NULL</code> (default).
</p>
</li>
<li>
<p> one-sided lower bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>, imposed:
lower bounds are specified with <code>m</code>, while <code>M</code> is set to <code>NULL</code>.
</p>
</li>
<li>
<p> one-sided upper bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>, imposed:
upper bounds are specified with <code>M</code>, while <code>m</code> is set to <code>NULL</code>.
</p>
</li>
<li>
<p> box-constraints imposed: lower and upper bounds must be specified with <code>m</code>
and <code>M</code>, respectively.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">opt(n, A, m = NULL, M = NULL, M_algorithm = "rna")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>(<code>number</code>)<br> total sample size. A strictly positive scalar.
If <code>bounds1</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as lower bounds) or <code>n &lt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as upper bounds).
If <code>bounds2</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as lower bounds) or <code>n &lt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as upper bounds).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(<code>numeric</code>)<br> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br> lower bounds <code class="reqn">m_1,\ldots,m_H</code>,
optionally imposed on sample sizes in strata. If no lower bounds should be
imposed, then <code>m</code> must be set to <code>NULL</code>. If <code>M</code> is not <code>NULL</code>, it is then
required that <code>m &lt; M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata. If no upper bounds should be
imposed, then <code>M</code> must be set to <code>NULL</code>. If <code>m</code> is not <code>NULL</code>, it is then
required that <code>m &lt; M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M_algorithm</code></td>
<td>
<p>(<code>string</code>)<br> the name of the underlying algorithm to be
used for computing sample allocation under one-sided upper-bounds
constraints.
It must be one of the following: <code>rna</code> (default), <code>sga</code>, <code>sgaplus</code>, <code>coma</code>.
This parameter is used only in case when <code>m</code> argument is <code>NULL</code> and <code>M</code> is
not <code>NULL</code> and number of strata <code class="reqn">H &gt; 1</code> and <code>n &lt; sum(M)</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>opt()</code> function makes use of several allocation algorithms, depending
on which of the inequality constraints should be taken into account in the
optimization problem. Each algorithm is implemented in a separate R
function that in general should not be used directly by the end user.
The following is the list with the algorithms that are used along with the
name of the function that implements a given algorithm. See the description
of a specific function to find out more about the corresponding algorithm.
</p>

<ul>
<li>
<p> one-sided lower-bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>:
</p>

<ul><li> <p><code>LRNA</code> - <code>rna()</code>
</p>
</li></ul>
</li>
<li>
<p> one-sided upper-bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>:
</p>

<ul>
<li> <p><code>RNA</code> - <code>rna()</code>
</p>
</li>
<li> <p><code>SGA</code> - <code>sga()</code>
</p>
</li>
<li> <p><code>SGAPLUS</code> - <code>sgaplus()</code>
</p>
</li>
<li> <p><code>COMA</code> - <code>coma()</code>
</p>
</li>
</ul>
</li>
<li>
<p> box constraints <code class="reqn">m_h, M_h,\, h = 1,\ldots,H</code>:
</p>

<ul><li> <p><code>RNABOX</code> - <code>rnabox()</code>
</p>
</li></ul>
</li>
</ul>
<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata.
</p>


<h3>Note</h3>

<p>If no inequality constraints are added, the allocation is given by the
Neyman allocation as:
</p>
<p style="text-align: center;"><code class="reqn">x_h = A_h \frac{n}{\sum_{i=1}^H A_i}, \quad h = 1,\ldots,H.</code>
</p>

<p>For <em>stratified <code class="reqn">\pi</code> estimator</em> of the population total with
<em>stratified simple random sampling without replacement</em> design in use,
the parameters of the objective function <code class="reqn">f</code> are:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code> and <code class="reqn">S_h</code> denotes
standard deviation of a given study variable in stratum <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>SÃ¤rndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>optcost()</code>, <code>rna()</code>, <code>sga()</code>, <code>sgaplus()</code>, <code>coma()</code>, <code>rnabox()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">A &lt;- c(3000, 4000, 5000, 2000)
m &lt;- c(100, 90, 70, 50)
M &lt;- c(300, 400, 200, 90)

# One-sided lower bounds.
opt(n = 340, A = A, m = m)
opt(n = 400, A = A, m = m)
opt(n = 700, A = A, m = m)

# One-sided upper bounds.
opt(n = 190, A = A, M = M)
opt(n = 700, A = A, M = M)

# Box-constraints.
opt(n = 340, A = A, m = m, M = M)
opt(n = 500, A = A, m = m, M = M)
xopt &lt;- opt(n = 800, A = A, m = m, M = M)
xopt
var_st(x = xopt, A = A, A0 = 45000) # Value of the variance for allocation xopt.

# Execution-time comparisons of different algorithms with microbenchmark R package.
## Not run: 
N &lt;- pop969[, "N"]
S &lt;- pop969[, "S"]
A &lt;- N * S
nfrac &lt;- c(0.005, seq(0.05, 0.95, 0.05))
n &lt;- setNames(as.integer(nfrac * sum(N)), nfrac)
lapply(
  n,
  function(ni) {
    microbenchmark::microbenchmark(
      RNA = opt(ni, A, M = N, M_algorithm = "rna"),
      SGA = opt(ni, A, M = N, M_algorithm = "sga"),
      SGAPLUS = opt(ni, A, M = N, M_algorithm = "sgaplus"),
      COMA = opt(ni, A, M = N, M_algorithm = "coma"),
      times = 200,
      unit = "us"
    )
  }
)

## End(Not run)
</code></pre>


</div>