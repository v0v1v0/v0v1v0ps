<div class="container">

<table style="width: 100%;"><tr>
<td>PLS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partial Least Squares 'a la carte'</h2>

<h3>Description</h3>

<p>Runs a Partial Least Squares (PLS) model in regression mode using algorithm
implemented in <code>pls</code>. This function allows for the
construction of components based on different sets of predictor and/or
outcome variables. This function is not using stability.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PLS(
  xdata,
  ydata,
  selectedX = NULL,
  selectedY = NULL,
  family = "gaussian",
  ncomp = NULL,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>matrix of predictors with observations as rows and variables as
columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydata</code></td>
<td>
<p>optional vector or matrix of outcome(s). If <code>family</code> is set
to <code>"binomial"</code> or <code>"multinomial"</code>, <code>ydata</code> can be a vector
with character/numeric values or a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectedX</code></td>
<td>
<p>binary matrix of size <code>(ncol(xdata) * ncomp)</code>. The
binary entries indicate which predictors (in rows) contribute to the
definition of each component (in columns). If <code>selectedX=NULL</code>, all
predictors are selected for all components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectedY</code></td>
<td>
<p>binary matrix of size <code>(ncol(ydata) * ncomp)</code>. The
binary entries indicate which outcomes (in rows) contribute to the
definition of each component (in columns). If <code>selectedY=NULL</code>, all
outcomes are selected for all components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>type of PLS model. Only <code>family="gaussian"</code> is supported.
This corresponds to a PLS model as defined in <code>pls</code>
(for continuous outcomes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>number of components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical indicating if the data should be scaled (i.e.
transformed so that all variables have a standard deviation of one).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All matrices are defined as in (Wold et al. 2001). The weight matrix
<code>Wmat</code> is the equivalent of <code>loadings$X</code> in
<code>pls</code>. The loadings matrix <code>Pmat</code> is the
equivalent of <code>mat.c</code> in <code>pls</code>. The score
matrices <code>Tmat</code> and <code>Qmat</code> are the equivalent of
<code>variates$X</code> and <code>variates$Y</code> in <code>pls</code>.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table>
<tr style="vertical-align: top;">
<td><code>Wmat</code></td>
<td>
<p>matrix of X-weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wstar</code></td>
<td>
<p>matrix of
transformed X-weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pmat</code></td>
<td>
<p>matrix of X-loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cmat</code></td>
<td>
<p>matrix of Y-weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tmat</code></td>
<td>
<p>matrix of X-scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Umat</code></td>
<td>
<p>matrix of Y-scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmat</code></td>
<td>
<p>matrix needed for
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rmat</code></td>
<td>
<p>matrix needed for predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meansX</code></td>
<td>
<p>vector used for centering of predictors, needed for
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaX</code></td>
<td>
<p>vector used for scaling of predictors, needed
for predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meansY</code></td>
<td>
<p>vector used for centering of outcomes,
needed for predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaY</code></td>
<td>
<p>vector used for scaling of outcomes,
needed for predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>a list with <code>family</code> and
<code>scale</code> values used for the run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a list with
<code>selectedX</code> and <code>selectedY</code> values used for the run.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wold S, Sjöström M, Eriksson L (2001).
“PLS-regression: a basic tool of chemometrics.”
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>58</b>(2), 109-130.
ISSN 0169-7439, <a href="https://doi.org/10.1016/S0169-7439%2801%2900155-1">doi:10.1016/S0169-7439(01)00155-1</a>, PLS Methods.
</p>


<h3>See Also</h3>

<p><code>VariableSelection</code>, <code>BiSelection</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if (requireNamespace("mixOmics", quietly = TRUE)) {
  oldpar &lt;- par(no.readonly = TRUE)

  # Data simulation
  set.seed(1)
  simul &lt;- SimulateRegression(n = 200, pk = 15, q = 3, family = "gaussian")
  x &lt;- simul$xdata
  y &lt;- simul$ydata

  # PLS
  mypls &lt;- PLS(xdata = x, ydata = y, ncomp = 3)

  if (requireNamespace("sgPLS", quietly = TRUE)) {
    # Sparse PLS to identify relevant variables
    stab &lt;- BiSelection(
      xdata = x, ydata = y,
      family = "gaussian", ncomp = 3,
      LambdaX = seq_len(ncol(x) - 1),
      LambdaY = seq_len(ncol(y) - 1),
      implementation = SparsePLS,
      n_cat = 2
    )
    plot(stab)

    # Refitting of PLS model
    mypls &lt;- PLS(
      xdata = x, ydata = y,
      selectedX = stab$selectedX,
      selectedY = stab$selectedY
    )

    # Nonzero entries in weights are the same as in selectedX
    par(mfrow = c(2, 2))
    Heatmap(stab$selectedX,
      legend = FALSE
    )
    title("Selected in X")
    Heatmap(ifelse(mypls$Wmat != 0, yes = 1, no = 0),
      legend = FALSE
    )
    title("Nonzero entries in Wmat")
    Heatmap(stab$selectedY,
      legend = FALSE
    )
    title("Selected in Y")
    Heatmap(ifelse(mypls$Cmat != 0, yes = 1, no = 0),
      legend = FALSE
    )
    title("Nonzero entries in Cmat")
  }

  # Multilevel PLS
  # Generating random design
  z &lt;- rep(seq_len(50), each = 4)

  # Extracting the within-variability
  x_within &lt;- mixOmics::withinVariation(X = x, design = cbind(z))

  # Running PLS on within-variability
  mypls &lt;- PLS(xdata = x_within, ydata = y, ncomp = 3)

  par(oldpar)
}

</code></pre>


</div>