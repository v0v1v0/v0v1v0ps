<div class="container">

<table style="width: 100%;"><tr>
<td>makeFormulae</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make all possible formula</h2>

<h3>Description</h3>

<p>This functions creates a list of formulae that contain all possible linear, quadratic, and two-way interaction terms from individual terms in an object of class <code>formula</code>. The formulae respect marginality conditions (i.e., they will always include lower-order terms if higher-order terms are included in a formula). Note that if there are more than several terms (i.e., &gt;=3) and interactions and/or quadratic terms are desired, then formula generation may take a long time.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeFormulae(
  formula,
  intercept = TRUE,
  interceptOnly = TRUE,
  linearOnly = TRUE,
  quad = TRUE,
  ia = TRUE,
  verboten = NULL,
  verbotenCombos = NULL,
  minTerms = NULL,
  maxTerms = NULL,
  returnFx = stats::as.formula,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A <code>formula</code> object with <em>just</em> linear terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then all models include an intercept.  If <code>FALSE</code> then then formula will specify that regression occurs through the origin (e.g., <code>y ~ -1 + etc.</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interceptOnly</code></td>
<td>
<p>Logical, if <code>TRUE</code> then an intercept-only model is included in final set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linearOnly</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then models with only linear terms are included in final set (plus other kinds of models if desired).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then include quadratic terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ia</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), then include 2-way interaction terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verboten</code></td>
<td>
<p>Character vector of terms that should not appear in the models. Ignored if <code>NULL</code> (default). Note that using this argument only makes sense if interaction or quadratic terms are specified (if you don't a particular term to appear anywhere in the model it will be faster to remove it from <code>formula</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbotenCombos</code></td>
<td>
<p>List of lists, used to specify specific combinations of terms that should not occur together. See section <em>Details</em> below. Ignored if <code>NULL</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minTerms</code></td>
<td>
<p>Either a positive integer representing the minimum number of terms required to be in a model, <em>or</em> <code>NULL</code> (default) in which case the smallest model can have just one term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxTerms</code></td>
<td>
<p>Either a positive integer representing the maximum number of terms allowed to be in a model, <em>or</em> <code>NULL</code> (default) in which case there is no practical limit on the number of terms in a model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnFx</code></td>
<td>
<p>Function used to generate the class of the output objects. Sensible functions in include <code>as.formula</code> (default) or <code>as.character</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> then display progress. Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>verbotenCombos</code> can be used to specify variables or terms that should not occur in the same formula. The argument <code>verbotenCombos</code> is composed of a list of lists. Each sublist comprises names of two variables or terms stated as characters followed by two logical values (<code>TRUE</code>/<code>FALSE</code>). The second variable/term is removed from the model if the first is in the model. If the first logical value is <code>TRUE</code> then the second variable/term is removed if the first variable appears alone in the formula (e.g., not in an interaction with another variable). If the first logical value is <code>FALSE</code> then the second variable/term is removed if the first variable/term appears in any term (e.g., as an interaction with another term).
Examples: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, TRUE))</code>: Removes <code>x2</code> if <code>x1</code> occurs in the model as a linear term.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, TRUE))</code>: Removes the linear term <code>x2</code> if <code>x1</code> occurrs in <em>any</em> term in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', TRUE, FALSE))</code>: Removes <em>any</em> term with <code>x2</code> if the linear term <code>x1</code> occurrs in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'x2', FALSE, FALSE))</code>: Removes any term with <code>x2</code> if any term has <code>x1</code>.
</p>
</li>
</ul>
<p>Quadratic terms and interaction terms can also be used, so: </p>

<ul>
<li> <p><code>verbotenCombos=list(list('x1', 'x1:x2', TRUE, TRUE))</code>: Removes <code>x1:x2</code> if <code>x1</code> were in the model.
</p>
</li>
<li> <p><code>verbotenCombos=list(list('x1', 'I(x2^2)', TRUE, TRUE))</code>: Removes <code>I(x2^2)</code> if <code>x1</code> occurs in the model.
</p>
</li>
</ul>
<p>Note that inexact matching can remove terms incorrectly if inexact matches exist between names of terms or variables.  For example, if using an inexact match, then <code>verbotenCombos(list('x1', 'x2', FALSE, FALSE))</code> will find any term that has an <code>x1</code> (e.g., <code>x11</code>) and if it exists, remove any term with an <code>x2</code> (e.g., <code>x25</code>). Note that reciprocally removing predictors makes little sense since, for example <code>list(list('x1', 'x2', FALSE, FALSE), list('x2', 'x1', FALSE, FALSE))</code> removes all formulae with <code>x2</code> if <code>x1</code> appears then tries to find any models with <code>x2</code> that have <code>x1</code> (of which there will be none after the first set is removed).
</p>


<h3>Value</h3>

<p>A vector of formulae.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
makeFormulae(y ~ x1 + x2 + x3, maxTerms=3)
makeFormulae(y ~ x1 + x2 + x3, ia=FALSE, maxTerms=3)
verboten &lt;- c('x1:x2', 'I(x1^2)')
makeFormulae(y ~ x1 + x2 + x3, verboten=verboten, maxTerms=3)

makeFormulae(y ~ x1 + x2 + x3, maxTerms=3)
verbotenCombos &lt;- list(list('x1', 'x2', TRUE, TRUE))
makeFormulae(y ~ x1 + x2 + x3, verbotenCombos=verbotenCombos, maxTerms=3)

</code></pre>


</div>