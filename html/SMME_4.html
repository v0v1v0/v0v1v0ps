<div class="container">

<table style="width: 100%;"><tr>
<td>predict.SMME</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make Prediction From a SMME Object</h2>

<h3>Description</h3>

<p>Given new covariate data this function computes the linear predictors
based on the estimated model coefficients in an object produced by the function
<code>softmaximin</code>. Note that the data can be supplied in three different
formats: i) for general models as a <code class="reqn">n' \times p</code> matrix (<code class="reqn">p</code> is the
number of model coefficients and <code class="reqn">n'</code> is the number of new data points),
ii) for array models with custom design as a list of one, two or three Kronecker component
matrices each of size <code class="reqn">n_i' \times p_i, i = 1, 2, 3</code>
(<code class="reqn">n_i'</code> is the number of new marginal data points in the <code class="reqn">i</code>th dimension),
iii) for wavelet based models a string indicating the wavelet used to produce
the model object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'SMME'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class SMME, produced with <code>softmaximin</code> with
<code class="reqn">m_\zeta</code> fitted models for each value of <code>zeta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object that should be like the input to the <code>softmaximin</code> call
that produced <code>object</code>. For general  models a matrix with column
dimension equal to that of  the original input.For array models with custom
design a list like the one supplied to <code>softmaximin</code> to produce <code>object</code>
and for a wavelet design the name of the wavelet used to produce <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of length <code>length(zeta)</code>. If <code>x</code> is a <code class="reqn">n' \times p</code>
matrix each list item is a <code class="reqn">n'\times m_\zeta</code> matrix containing the linear
predictors computed for each <code>lambda</code>. If <code>x</code> is a string or a list of
tensor component matrices and <code>fit$dim = d</code>, each list item is a <code class="reqn">d + 1</code>
array  containing predictions computed for each <code>lambda</code>.
</p>


<h3>Author(s)</h3>

<p>Adam Lund
</p>


<h3>Examples</h3>

<pre><code class="language-R">##size of example
n1 &lt;- 65; n2 &lt;- 26; n3 &lt;- 13; p1 &lt;- 13; p2 &lt;- 5; p3 &lt;- 4

##marginal design matrices (Kronecker components)
X1 &lt;- matrix(rnorm(n1 * p1, 0, 0.5), n1, p1)
X2 &lt;- matrix(rnorm(n2 * p2, 0, 0.5), n2, p2)
X3 &lt;- matrix(rnorm(n3 * p3, 0, 0.5), n3, p3)
X &lt;- list(X1, X2, X3)

component &lt;- rbinom(p1 * p2 * p3, 1, 0.1)
Beta1 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
Beta2 &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) + component, c(p1 , p2, p3))
mu1 &lt;- RH(X3, RH(X2, RH(X1, Beta1)))
mu2 &lt;- RH(X3, RH(X2, RH(X1, Beta2)))
Y1 &lt;- array(rnorm(n1 * n2 * n3, mu1), dim = c(n1, n2, n3))
Y2 &lt;- array(rnorm(n1 * n2 * n3, mu2), dim = c(n1, n2, n3))

Y &lt;- array(NA, c(dim(Y1), 2))
Y[,,, 1] &lt;- Y1; Y[,,, 2] &lt;- Y2;

fit &lt;- softmaximin(X, Y, zeta = c(1, 10), penalty = "lasso", alg = "npg")

##new data in tensor component form
X1 &lt;- matrix(rnorm(2 * p1), nrow = 2)
X2 &lt;- matrix(rnorm(3 * p2), nrow = 3)
X3 &lt;- matrix(rnorm(4 * p3), nrow = 4)
Yhat &lt;- predict(fit, x = list(X1, X2, X3))

</code></pre>


</div>