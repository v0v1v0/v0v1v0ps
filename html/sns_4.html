<div class="container">

<table style="width: 100%;"><tr>
<td>sns.check.logdensity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Utility function for validating log-density
</h2>

<h3>Description</h3>

<p>Utility function for validating log-density: 1) dimensional consistency of function argument, gradient and Hessian, 2) finiteness of function, gradient and Hessian, 3) closeness of analytical and numerical derivatives, and 4) negative definiteness of Hessian.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sns.check.logdensity(x, fghEval
  , numderiv.method = c("Richardson", "complex")
  , numderiv.args = list()
  , blocks = append(list(1:length(x)), as.list(1:length(x)))
  , dx = rep(1, length(x)), nevals = 100, negdef.tol = 1e-08, ...)
## S3 method for class 'sns.check.logdensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For <code>sns.check.logdensity</code>, initial point, around which a random collection of points are generated to perform validation tests. For <code>print.sns.check.logdensity</code>, an object of class <code>sns.check.logdensity</code>, typically the output of <code>sns.check.logdensity</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fghEval</code></td>
<td>
<p>Log-density to be validated. A valid log-density can have one of 3 forms: 1) return log-density, but no gradient or Hessian, 2) return a list of <code>f</code> and <code>g</code> for log-density and its gradient vector, respectively, 3) return a list of <code>f</code>, <code>g</code>, and <code>h</code> for log-density, gradient vector, and Hessian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv.method</code></td>
<td>
<p>Method used for numeric differentiation. This is passed to the <code>grad</code> and <code>hessian</code> functions in <span class="pkg">numDeriv</span> package. See the package documentation for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv.args</code></td>
<td>
<p>Arguments to the numeric differentiation method chosen in <code>numderiv.method</code>, passed to <code>grad</code> and <code>hessian</code> functions in <span class="pkg">numDeriv</span>. See package documentation for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>
<p>A list of state space subsets (identified by their positional indexes), for which negative-definiteness of Hessian blocks are to be tested. The default is to test for 1) entire state space, and 2) each dimension individually.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p>A vector of same length as <code>x</code>. For <code>i</code>'th dimension, <code>nevals</code> values are sampled from a uniform distribution with min/max values equal to <code>x[i]-0.5*dx[i]</code> and <code>x[i]+0.5*dx[i]</code>, respectively. Vectors smaller than <code>length(x)</code> are extended as needed by recycling the provided values for <code>dx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nevals</code></td>
<td>
<p>Number of points in state space, for which validation tests will be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negdef.tol</code></td>
<td>
<p>Lower bound for absolute value of (negative) eigenvalues of Hessian, evaluated at each of the <code>nevals</code> points in the state space. If one or more eigenvalues have absolute values smaller than <code>ngdef.tol</code>, log-density is declared non-log-concave at that point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to <code>fghEval</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>sns.check.logdensity</code> returns a list of class <code>sns.check.logdensity</code>, with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>check.ld.struct</code></td>
<td>
<p>Boolean flag, indicating whether log-density <code>fghEval</code> has one of the 3 forms of output, described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv</code></td>
<td>
<p>Integer with values of <code>0,1,2</code>. A value of <code>0</code> means analytical gradient and Hessian have been provided, and thus there is no need for numerical differentiation. <code>1</code> means analytical gradient is provided, but Hessian must be calculated numerically. <code>2</code> means both gradient and Hessian must be numerically calculated. Users can pass this value to subsequent <code>sns</code> or <code>sns.run</code> calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.length.g</code></td>
<td>
<p>Boolean flag, indicating whether length of gradient vector (element <code>g</code>) returned by <code>fghEval</code> equals <code>length(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.dim.h</code></td>
<td>
<p>Boolean flag, indicating whether number of rows and columns of the Hessian matrix (element <code>h</code>) returned by <code>fghEval</code> equal <code>length(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.mat</code></td>
<td>
<p>Collection of state space vectors (one per row), for which validation tests are performed. It has <code>nevals</code> rows and <code>length(x)</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.evals</code></td>
<td>
<p>Time spent on evaluating <code>fghEval</code> on <code>nevals</code> points chosen randomly in the neighborhood of <code>x</code>, as specified by <code>dx</code>. This includes log-density and, if provided, analytical evaluations of gradient and Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.num.evals</code></td>
<td>
<p>Time spent on evaluating the numeric version of <code>fghEval</code>, in which gradient and Hessian are computed numerically, using <code>grad</code> and <code>hessian</code> functions in the <span class="pkg">numDeriv</span> package. Comparison of this number with <code>t.evals</code> provides the user with insight into the relative speed of numerical differentiation compared to analytical versions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.vec</code></td>
<td>
<p>Vector of log-density values for state space vectors listed in <code>x.mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.mat.num</code></td>
<td>
<p>Collection of numerically-computed gradient vectors for state space values listed in <code>x.mat</code>, with the same dimension conventions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.g.num.finite</code></td>
<td>
<p>Boolean flag, indicating whether all numerically-computed gradient vectors have finite values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.array.num</code></td>
<td>
<p>Collection of numerically-computed Hessian matrices at points listed in <code>x.mat</code>. First dimension is of length <code>nevals</code>, and the remaining two dimensions equal <code>length(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.h.num.finite</code></td>
<td>
<p>Boolean flag, indicating whether all numerically-computed Hessian matrices have finite values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.mat</code></td>
<td>
<p>Collection of analytically-computed gradient vectors for state space values listed in <code>x.mat</code>, with the same dimension conventions. This is only available if <code>fghEval</code> has a <code>g</code> field; otherwise <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.g.finite</code></td>
<td>
<p>Boolean flag (if available), indicating whether all analytically-computed gradient vectors have finite values (if available).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.diff.max</code></td>
<td>
<p>If available, maximum relative difference between analytical and numerical gradient vectors, over all <code>nevals</code> points in <code>x.mat</code>. Relative diference is defined as L2 norm of difference between the two gradient vectors, divided by the L2 norm of the analytical gradient vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.array</code></td>
<td>
<p>If available, collection of analytically-computed Hessian matrices at points listed in <code>x.mat</code>. Dimensional conventions are the same as <code>h.array.num</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.h.finite</code></td>
<td>
<p>Boolean flag (if available), indicating whether all analytically-computed Hessian matrices have finite values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.diff.max</code></td>
<td>
<p>If available, maximum relative difference between analytical and numerical Hessian matrices, over all <code>nevals</code> points in <code>x.mat</code>. Relative difference is defined as the Frobenius norm of difference of analytical and numerical Hessian matrices, divided by the Frobenius norm of analytical Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.negdef.num</code></td>
<td>
<p>Boolean flag, indicating whether numerical Hessian is negative-definite at all state space points indicated in <code>x.mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.negdef</code></td>
<td>
<p>Boolean flag, indicating whether analytical Hessian is negative-definite at all state space points indicated in <code>x.mat</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>1. Validation tests performed in <code>sns.check.logdensity</code> cannot prove that a log-density is twice-differentiable, or globally concave. However, when e.g. log-density Hessian is seen to be non-negative-definite at one of the points tested, we can definitively say that the Hessian is not globally negative-definite, and therefore <code>sns</code> should not be used for sampling from this distribution. Users must generally consider this function as a supplement to analytical work.
</p>
<p>2. See package vignette for more details on SNS theory, software, examples, and performance.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Asad Hasan, Marshall Jiang, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Mahani A.S., Hasan A., Jiang M. &amp;  Sharabiani M.T.A. (2016). Stochastic Newton Sampler: The R Package sns. Journal of Statistical Software, Code Snippets, 74(2), 1-33. doi:10.18637/jss.v074.c02
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# using RegressionFactory for generating log-likelihood and its derivatives
library(RegressionFactory)

loglike.poisson &lt;- function(beta, X, y) {
  regfac.expand.1par(beta, X = X, y = y,
                     fbase1 = fbase1.poisson.log)
}

# simulating data
K &lt;- 5
N &lt;- 1000
X &lt;- matrix(runif(N * K, -0.5, +0.5), ncol = K)
beta &lt;- runif(K, -0.5, +0.5)
y &lt;- rpois(N, exp(X %*% beta))

beta.init &lt;- rep(0.0, K)

my.check &lt;- sns.check.logdensity(beta.init, loglike.poisson
  , X = X, y = y, blocks = list(1:K))
my.check

# mistake in log-likelihood gradient
loglike.poisson.wrong &lt;- function(beta, X, y) {
  ret &lt;- regfac.expand.1par(beta, X = X, y = y,
                            fbase1 = fbase1.poisson.log)
  ret$g &lt;- 1.2 * ret$g
  return (ret)
}
# maximum relative diff in gradient is now much larger
my.check.wrong &lt;- sns.check.logdensity(beta.init
  , loglike.poisson.wrong, X = X, y = y, blocks = list(1:K))
my.check.wrong

# mistake in log-likelihood Hessian
loglike.poisson.wrong.2 &lt;- function(beta, X, y) {
  ret &lt;- regfac.expand.1par(beta, X = X, y = y,
                            fbase1 = fbase1.poisson.log)
  ret$h &lt;- 1.2 * ret$h
  return (ret)
}
# maximum relative diff in Hessian is now much larger
my.check.wrong.2 &lt;- sns.check.logdensity(beta.init
  , loglike.poisson.wrong.2, X = X, y = y, blocks = list(1:K))
my.check.wrong.2


## End(Not run)
</code></pre>


</div>