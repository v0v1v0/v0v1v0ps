<div class="container">

<table style="width: 100%;"><tr>
<td>markcorr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Mark Correlation Function
</h2>

<h3>Description</h3>

<p>Estimate the marked correlation function
of a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">markcorr(X, f = function(m1, m2) { m1 * m2}, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., weights=NULL,
         f1=NULL, normalise=TRUE, fargs=NULL, internal=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Optional. Test function <code class="reqn">f</code> used in the definition of the
mark correlation function. An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function with at least two
arguments. There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark correlation function 
<code class="reqn">k_f(r)</code> should be evaluated.
There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to the density estimation routine
(<code>density</code>, <code>loess</code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional. Numeric weights for each data point in <code>X</code>.
A numeric vector, a pixel image, or a <code>function(x,y)</code>.
Alternatively, an <code>expression</code> to be evaluated to yield the
weights; the expression may involve the variables
<code>x,y,marks</code> representing the coordinates and marks of<code>X</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f1</code></td>
<td>

<p>An alternative to <code>f</code>. If this argument is given,
then <code class="reqn">f</code> is assumed to take the form
<code class="reqn">f(u,v)=f_1(u)f_1(v)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>

<p>If <code>normalise=FALSE</code>,
compute only the numerator of the expression for the
mark correlation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fargs</code></td>
<td>

<p>Optional. A list of extra arguments to be passed to the function
<code>f</code> or <code>f1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>internal</code></td>
<td>
<p>Do not use this argument.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, this command calculates an estimate of
Stoyan's mark correlation <code class="reqn">k_{mm}(r)</code>
for the point pattern.
</p>
<p>Alternatively if the argument <code>f</code> or <code>f1</code> is given, then it
calculates Stoyan's generalised mark correlation <code class="reqn">k_f(r)</code>
with test function <code class="reqn">f</code>.
</p>
<p>Theoretical definitions are as follows
(see Stoyan and Stoyan (1994, p. 262)):
</p>

<ul>
<li>
<p>For a point process <code class="reqn">X</code> with numeric marks,
Stoyan's mark correlation function <code class="reqn">k_{mm}(r)</code>,
is
</p>
<p style="text-align: center;"><code class="reqn">
      k_{mm}(r) = \frac{E_{0u}[M(0) M(u)]}{E[M,M']}
    </code>
</p>

<p>where <code class="reqn">E_{0u}</code> denotes the conditional expectation
given that there are points of the process at the locations
<code class="reqn">0</code> and <code class="reqn">u</code> separated by a distance <code class="reqn">r</code>,
and where <code class="reqn">M(0),M(u)</code> denote the marks attached to these
two points. On the denominator, <code class="reqn">M,M'</code> are random marks
drawn independently from the marginal distribution of marks,
and <code class="reqn">E</code> is the usual expectation.
</p>
</li>
<li>
<p>For a multitype point process <code class="reqn">X</code>, the mark correlation is 
</p>
<p style="text-align: center;"><code class="reqn">
      k_{mm}(r) = \frac{P_{0u}[M(0) M(u)]}{P[M = M']}
    </code>
</p>

<p>where <code class="reqn">P</code> and <code class="reqn">P_{0u}</code> denote the
probability and conditional probability.
</p>
</li>
<li> 
<p>The <em>generalised</em> mark correlation function <code class="reqn">k_f(r)</code>
of a marked point process <code class="reqn">X</code>, with test function <code class="reqn">f</code>,
is
</p>
<p style="text-align: center;"><code class="reqn">
      k_f(r) = \frac{E_{0u}[f(M(0),M(u))]}{E[f(M,M')]}
    </code>
</p>

</li>
</ul>
<p>The test function <code class="reqn">f</code> is any function
<code class="reqn">f(m_1,m_2)</code>
with two arguments which are possible marks of the pattern,
and which returns a nonnegative real value.
Common choices of <code class="reqn">f</code> are:
for continuous nonnegative real-valued marks,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = m_1 m_2</code>
</p>

<p>for discrete marks (multitype point patterns),
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = 1(m_1 = m_2)</code>
</p>

<p>and for marks taking values in <code class="reqn">[0,2\pi)</code>,
</p>
<p style="text-align: center;"><code class="reqn">f(m_1,m_2) = \sin(m_1 - m_2)</code>
</p>
<p>.
</p>
<p>Note that <code class="reqn">k_f(r)</code> is not a “correlation”
in the usual statistical sense. It can take any 
nonnegative real value. The value 1 suggests “lack of correlation”:
if the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<code class="reqn">k_f(r) \equiv 1</code>.
The interpretation of values larger or smaller than 1 depends
on the choice of function <code class="reqn">f</code>.
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern.
</p>
<p>The argument <code>f</code> determines the function to be applied to
pairs of marks. It has a sensible default, which depends on the
kind of marks in <code>X</code>. If the marks
are numeric values, then <code>f &lt;- function(m1, m2) { m1 * m2}</code>
computes the product of two marks.
If the marks are a factor (i.e. if <code>X</code> is a multitype point
pattern) then <code>f &lt;- function(m1, m2) { m1 == m2}</code> yields
the value 1 when the two marks are equal, and 0 when they are unequal.
These are the conventional definitions for numerical
marks and multitype points respectively.
</p>
<p>The argument <code>f</code> may be specified by the user.
It must be an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, accepting two arguments <code>m1</code>
and <code>m2</code> which are vectors of equal length containing mark
values (of the same type as the marks of <code>X</code>).
(It may also take additional arguments, passed through <code>fargs</code>).
It must return a vector of numeric
values of the same length as <code>m1</code> and <code>m2</code>.
The values must be non-negative, and <code>NA</code> values are not permitted.
</p>
<p>Alternatively the user may specify the argument <code>f1</code>
instead of <code>f</code>. This indicates that the test function <code class="reqn">f</code>
should take the form <code class="reqn">f(u,v)=f_1(u)f_1(v)</code>
where <code class="reqn">f_1(u)</code> is given by the argument <code>f1</code>.
The argument <code>f1</code> should be an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function with at least one
argument.
(It may also take additional arguments, passed through <code>fargs</code>).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">k_f(r)</code> is estimated.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code>Kest</code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt>
<dd>
<p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks).
</p>
</dd>
<dt>translate</dt>
<dd>
<p>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
</dl>
<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The numerator and denominator of the mark correlation function
(in the expression above) are estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt>
<dd>
<p>which uses the standard kernel
density estimation routine <code>density</code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt>
<dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>
<p>If <code>normalise=FALSE</code> then the algorithm will compute
only the numerator
</p>
<p style="text-align: center;"><code class="reqn">
    c_f(r) = E_{0u} f(M(0),M(u))
  </code>
</p>

<p>of the expression for the mark correlation function.
In this case, negative values of <code>f</code> are permitted.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
or a list of function value tables, one for each column of marks.
</p>
<p>An object of class <code>"fv"</code> (see <code>fv.object</code>)
is essentially a data frame containing numeric columns 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark correlation function <code class="reqn">k_f(r)</code>
has been  estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">k_f(r)</code>
when the marks attached to different points are independent,
namely 1
</p>
</td>
</tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the mark correlation function <code class="reqn">k_f(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>Mark variogram <code>markvario</code> for numeric marks.
</p>
<p>Mark connection function <code>markconnect</code> and 
multitype K-functions <code>Kcross</code>, <code>Kdot</code>
for factor-valued marks.
</p>
<p>Mark cross-correlation function <code>markcrosscorr</code>
for point patterns with several columns of marks.
</p>
<p><code>Kmark</code> to estimate a cumulative function
related to the mark correlation function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # CONTINUOUS-VALUED MARKS:
    # (1) Spruces
    # marks represent tree diameter
    # mark correlation function
    ms &lt;- markcorr(spruces)
    plot(ms)

    # (2) simulated data with independent marks
    
      X &lt;- rpoispp(100)
      X &lt;- X %mark% runif(npoints(X))
      Xc &lt;- markcorr(X)
      plot(Xc)
    
    
    # MULTITYPE DATA:
    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    X &lt;- if(interactive()) amacrine else amacrine[c(FALSE, TRUE)]
    # (3) Kernel density estimate with Epanecnikov kernel
    # (as proposed by Stoyan &amp; Stoyan)
    M &lt;- markcorr(X, function(m1,m2) {m1==m2},
                  correction="translate", method="density",
                  kernel="epanechnikov")
    # Note: kernel="epanechnikov" comes from help(density)

    # (4) Same again with explicit control over bandwidth
    
      M &lt;- markcorr(X, 
                  correction="translate", method="density",
                  kernel="epanechnikov", bw=0.02)
      # see help(density) for correct interpretation of 'bw'
   
   

   # weighted mark correlation
   X &lt;- if(interactive()) betacells else betacells[c(TRUE,FALSE)]
   Y &lt;- subset(X, select=type)
   a &lt;- marks(X)$area
   v &lt;- markcorr(Y, weights=a)
</code></pre>


</div>