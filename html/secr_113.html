<div class="container">

<table style="width: 100%;"><tr>
<td>esaPlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Mask Buffer Diagnostic Plot
</h2>

<h3>Description</h3>

<p>Plot effective sampling area (Borchers and Efford 2008) as a function of increasing buffer width.
</p>
<p><code>esaPlot</code> was previously called <code>esa.plot</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
esaPlot (object, max.buffer = NULL, spacing = NULL, max.mask = NULL,
    detectfn, detectpar, noccasions, binomN = NULL, thin = 0.1,
    poly = NULL, poly.habitat = TRUE, session = 1, plt = TRUE, 
    type = c('density', 'esa', 'meanpdot', 'CVpdot'), n = 1, add = FALSE, 
    overlay = TRUE, conditional = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>traps</code> object or <code>secr</code> object output from <code>secr.fit</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.buffer</code></td>
<td>
<p> maximum width of buffer in metres </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacing</code></td>
<td>
<p> distance between mask points </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.mask</code></td>
<td>
 <p><code>mask</code> object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectfn</code></td>
<td>
<p> integer code or character string for shape of
detection function 0 = halfnormal etc. – see detectfn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectpar</code></td>
<td>
<p> list of values for named parameters of detection function </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p> number of sampling occasions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binomN</code></td>
<td>
<p> integer code for discrete distribution (see
<code>secr.fit</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p> proportion of mask points to retain in plot and output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p> matrix of two columns interpreted as the x and y
coordinates of a bounding polygon (optional) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly.habitat</code></td>
<td>
<p>logical as in <code>make.mask</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>vector of session indices (used if <code>object</code> spans multiple sessions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plt</code></td>
<td>
<p> logical to plot results </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> character, what to plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> integer number of distinct individuals detected </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p> logical to add line to an existing plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlay</code></td>
<td>
<p> logical; if TRUE then automatically <code>add = TRUE</code>
for plots after the first </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>logical; if TRUE the reported mean and CV are conditional on detection 
(see <code>CVpdot</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> graphical arguments passed to plot() and lines()</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Effective sampling area (esa) is defined as the integral of net
capture probability (<code class="reqn">p.(\mathbf{X})</code>) over a
region. <code>esaPlot</code> shows the effect of increasing region size on
the value of esa for fixed values of the detection parameters. The
<code>max.buffer</code> or <code>max.mask</code> arguments establish the maximum
extent of the region; points (cells) within this mask are sorted by
their distance <code class="reqn">d_k</code> from the nearest detector. esa(buffer) is
defined as the cumulative sum of <code class="reqn">cp.(\mathbf{X})</code> for
<code class="reqn">d_k(\mathbf{X}) &lt;= \mbox{buffer}</code>, where <code class="reqn">c</code>
is the area associated with each cell.
</p>
<p>The default (<code>type = 'density'</code>) is to plot the reciprocal of esa
multiplied by <code>n</code>; this is on a more familiar scale (the density
scale) and hence is easier to interpret.
</p>
<p>Because <code>esaPlot</code> uses the criterion 'distance to nearest
detector', <code>max.mask</code> should be constructed to include all
habitable cells within the desired maximum buffer and no others. This
is achieved with <code>type = "trapbuffer"</code> in <code>make.mask</code>. It is
a good idea to set the <code>spacing</code> argument of <code>make.mask</code>
rather than relying on the default based on <code>nx</code>. Spacing may be
small (e.g. sigma/10) and the buffer of <code>max.mask</code> may be quite
large (e.g. 10 sigma), as computation is fast.
</p>
<p>Thinning serves to reduce redundancy in the plotted points, and (if
the result is saved and printed) to generate more legible numerical
output. Use <code>thin=1</code> to include all points.
</p>
<p><code>esaPlot</code> calls the internal function <code>esaPlotsecr</code> when
<code>object</code> is a fitted model. In this case <code>detectfn</code>,
<code>detectpar</code> and <code>noccasions</code> are inferred from
<code>object</code>. 
</p>


<h3>Value</h3>

<p>A dataframe with columns
</p>
<table>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p> buffer width </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>esa</code></td>
<td>
<p> computed effective sampling area </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p> n/esa </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdot</code></td>
<td>
 <p><code class="reqn">p.(\mathbf{X})</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdotmin</code></td>
<td>
<p> cumulative minimum  (<code class="reqn">p.(\mathbf{X})</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanpdot</code></td>
<td>
<p> expected pdot across mask (see <code>CVpdot</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CVpdot</code></td>
<td>
<p> CV of pdot across mask (see <code>CVpdot</code>)</p>
</td>
</tr>
</table>
<p>If <code>plt = TRUE</code> the dataframe is returned invisibly.
</p>


<h3>Note</h3>

<p>The response of effective sampling area to buffer width is just one
possible mask diagnostic; it's fast, graphic, and often
sufficient. <code>mask.check</code> performs more intensive checks,
usually for a smaller number of buffer widths.
</p>
<p>The old argument 'as.density' was superceded by 'type' in 3.1.7.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture–recapture studies. <em>Biometrics</em>
<b>64</b>, 377–385.
</p>


<h3>See Also</h3>

 <p><code>mask</code>, <code>pdot</code>, <code>CVpdot</code>,
<code>make.mask</code>, <code>mask.check</code>,
<code>Detection functions</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

## with previously fitted model
esaPlot(secrdemo.0)

## from scratch
trps &lt;- make.grid()
msk &lt;- make.mask(trps, buffer = 200, spacing = 5, type = "trapbuffer")
detectpar &lt;- list(g0 = 0.2, sigma = 25)
esaPlot(trps,,, msk, 0, detectpar, nocc = 10, col = "blue")
esaPlot(trps,,, msk, 0, detectpar, nocc = 5, col = "green",
    add = TRUE)

esaPlot(trps,,, msk, 0, detectpar, nocc = 5, thin = 0.002, plt = FALSE)


## End(Not run)

</code></pre>


</div>