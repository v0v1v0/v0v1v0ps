<div class="container">

<table style="width: 100%;"><tr>
<td>localK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Neighbourhood density function</h2>

<h3>Description</h3>

<p>Computes the neighbourhood density function, a local version of
the <code class="reqn">K</code>-function or <code class="reqn">L</code>-function,
defined by Getis and Franklin (1987).
</p>


<h3>Usage</h3>

<pre><code class="language-R">  localK(X, ..., rmax = NULL, correction = "Ripley", verbose = TRUE, rvalue=NULL)
  localL(X, ..., rmax = NULL, correction = "Ripley", verbose = TRUE, rvalue=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p>String specifying the edge correction to be applied.
Options are <code>"none"</code>, <code>"translate"</code>, <code>"translation"</code>,
<code>"Ripley"</code>,
<code>"isotropic"</code> or <code>"best"</code>.
Only one correction may be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress
reports during the calculation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rvalue</code></td>
<td>
<p>Optional. A <em>single</em> value of the distance argument
<code class="reqn">r</code> at which the function L or K should be computed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The command <code>localL</code> computes the <em>neighbourhood density function</em>,
a local version of the <code class="reqn">L</code>-function (Besag's transformation of Ripley's
<code class="reqn">K</code>-function) that was proposed by Getis and Franklin (1987).
The command <code>localK</code> computes the corresponding
local analogue of the K-function.
</p>
<p>Given a spatial point pattern <code>X</code>, the neighbourhood density function
<code class="reqn">L_i(r)</code> associated with the <code class="reqn">i</code>th point
in <code>X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">
    L_i(r) = \sqrt{\frac a {(n-1) \pi} \sum_j e_{ij}}
  </code>
</p>

<p>where the sum is over all points <code class="reqn">j \neq i</code> that lie
within a distance <code class="reqn">r</code> of the <code class="reqn">i</code>th point, 
<code class="reqn">a</code> is the area of the observation window, <code class="reqn">n</code> is the number
of points in <code>X</code>, and <code class="reqn">e_{ij}</code> is an edge correction
term (as described in <code>Kest</code>).
The value of <code class="reqn">L_i(r)</code> can also be interpreted as one
of the summands that contributes to the global estimate of the L
function.
</p>
<p>By default, the function <code class="reqn">L_i(r)</code> or
<code class="reqn">K_i(r)</code> is computed for a range of <code class="reqn">r</code> values
for each point <code class="reqn">i</code>. The results are stored as a function value
table (object of class <code>"fv"</code>) with a column of the table
containing the function estimates for each point of the pattern
<code>X</code>.
</p>
<p>Alternatively, if the argument <code>rvalue</code> is given, and it is a
single number, then the function will only be computed for this value
of <code class="reqn">r</code>, and the results will be returned as a numeric vector,
with one entry of the vector for each point of the pattern <code>X</code>.
</p>
<p>Inhomogeneous counterparts of <code>localK</code> and <code>localL</code>
are computed by <code>localKinhom</code> and <code>localLinhom</code>.
</p>


<h3>Value</h3>

<p>If <code>rvalue</code> is given, the result is a numeric vector
of length equal to the number of points in the point pattern.
</p>
<p>If <code>rvalue</code> is absent, the result is 
an object of class <code>"fv"</code>, see <code>fv.object</code>,
which can be plotted directly using <code>plot.fv</code>.
Essentially a data frame containing columns
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">K</code> has been  estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>the theoretical value <code class="reqn">K(r) = \pi r^2</code>
or <code class="reqn">L(r)=r</code> for a stationary Poisson process
</p>
</td>
</tr>
</table>
<p>together with columns containing the values of the
neighbourhood density function for each point in the pattern.
Column <code>i</code> corresponds to the <code>i</code>th point.
The last two columns contain the <code>r</code> and <code>theo</code> values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Getis, A. and Franklin, J. (1987)
Second-order neighbourhood analysis of mapped point patterns.
<em>Ecology</em> <b>68</b>, 473â€“477.
</p>


<h3>See Also</h3>

<p><code>Kest</code>,
<code>Lest</code>,
<code>localKinhom</code>,
<code>localLinhom</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  X &lt;- ponderosa

  # compute all the local L functions
  L &lt;- localL(X)

  # plot all the local L functions against r
  plot(L, main="local L functions for ponderosa", legend=FALSE)

  # plot only the local L function for point number 7
  plot(L, iso007 ~ r)
  
  # compute the values of L(r) for r = 12 metres
  L12 &lt;- localL(X, rvalue=12)

  # Spatially interpolate the values of L12
  # Compare Figure 5(b) of Getis and Franklin (1987)
  X12 &lt;- X %mark% L12
  Z &lt;- Smooth(X12, sigma=5, dimyx=128)

  plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  contour(Z, add=TRUE)
  points(X, pch=16, cex=0.5)
</code></pre>


</div>