<div class="container">

<table style="width: 100%;"><tr>
<td>FilterModel1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filtering algorithm for the type one model.</h2>

<h3>Description</h3>

<p>This function implements the filtering algorithm for the type one model.
See Details part below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FilterModel1(mY, mX, mZ, beta, mB = NULL, Omega, vD, U0,
  method = "max_1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mY</code></td>
<td>
<p>the matrix containing Y_t with dimension <code class="reqn">T \times p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mX</code></td>
<td>
<p>the matrix containing X_t with dimension <code class="reqn">T \times q_1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mZ</code></td>
<td>
<p>the matrix containing Z_t with dimension <code class="reqn">T \times q_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the <code class="reqn">\beta</code> matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mB</code></td>
<td>
<p>the coefficient matrix <code class="reqn">\boldsymbol{B}</code> before <code>mZ</code> with dimension <code class="reqn">p \times q_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>covariance matrix of the errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vD</code></td>
<td>
<p>vector of the diagonals of <code class="reqn">D</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U0</code></td>
<td>
<p>initial value of the alpha sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string representing the optimization method from c('max_1','max_2','max_3','min_1','min_2').</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The type one model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha}_t \boldsymbol{\beta} ' \boldsymbol{x}_t + \boldsymbol{B} \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\alpha}_{t+1} | \boldsymbol{\alpha}_{t} \quad \sim \quad ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\alpha}_t</code> is time-varying while <code class="reqn">\boldsymbol{\beta}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\alpha}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\alpha}_t' \boldsymbol{\alpha}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\alpha_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\alpha}_{t}' \boldsymbol{\alpha_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>


<h3>Value</h3>

<p>an array <code>aAlpha</code> containing the modal orientations of alpha in the prediction step.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
iT = 50
ip = 2
ir = 1
iqx = 4
iqz=0
ik = 0
Omega = diag(ip)*.1

if(iqx==0) mX=NULL else mX = matrix(rnorm(iT*iqx),iT, iqx)
if(iqz==0) mZ=NULL else mZ = matrix(rnorm(iT*iqz),iT, iqz)
if(ik==0) mY=NULL else mY = matrix(0, ik, ip)

alpha_0 = matrix(c(runif_sm(num=1,ip=ip,ir=ir)), ip, ir)
beta = matrix(c(runif_sm(num=1,ip=ip*ik+iqx,ir=ir)), ip*ik+iqx, ir)
mB=NULL
vD = 100

ret = SimModel1(iT=iT, mX=mX, mZ=mZ, mY=mY, alpha_0=alpha_0, beta=beta, mB=mB, vD=vD, Omega=Omega)
mYY=as.matrix(ret$dData[,1:ip])
fil = FilterModel1(mY=mYY, mX=mX, mZ=mZ, beta=beta, mB=mB, Omega=Omega, vD=vD, U0=alpha_0)

</code></pre>


</div>