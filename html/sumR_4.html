<div class="container">

<table style="width: 100%;"><tr>
<td>infiniteSum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximates the sum of a positive discrete infinite series with a single
maximum</h2>

<h3>Description</h3>

<p>For series that pass the ratio test, the approximation is analytically
guaranteed to have an error that is smaller than epsilon. This can
occasionally not happen due to floating point arithmetic.
</p>


<h3>Usage</h3>

<pre><code class="language-R">infiniteSum(
  logFunction,
  parameters = numeric(),
  logL = NULL,
  alternate = FALSE,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0,
  forceAlgorithm = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>logFunction</code></td>
<td>
<p>The function that returns the series absolute value
|a<sub>n</sub>| in
the log scale. If it is an alternating series, this is defined in
argument <code>alternate</code>. Can either be an <code>R</code> function or a string
indicating one of the precompiled functions. See <code>precompiled()</code>
for a list of available functions. If defined in <code>R</code>, the function's
definition must have two arguments. The first argument must be the integer
argument equivalent to <code class="reqn">n</code> in
a<sub>n</sub> and the second must be a vector
of numeric parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A numeric vector with parameters used in <code>logFunction</code>.
Vectorized summation over various parameter values sets is not implemented.
Use <code>apply()</code> or their variants to achieve this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logL</code></td>
<td>
<p>The log of the limit value of
a<sub>n+1</sub>/a<sub>n</sub> which
must be smaller than 1, or smaller than 0 in the log scale. Ignored if the
series is alternating, defined with argument <code>alternate</code>. If left as
<code>NULL</code> and <code>logFunction</code> is defined in <code>R</code>, the
<code>batches</code> algorithm with default settings is used. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternate</code></td>
<td>
<p>Either -1, 0 or 1. If 0 (or <code>FALSE</code>), the series is not
alternating and positive. Otherwise, the series is alternating where the
first element's sign is either 1 or -1, as entered in this parameter. If not
0, arguments <code>logL</code> and <code>forceAlgorithm</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>The desired error margin for the approximation. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>The maximum number of iterations for the approximation. In
most cases, this number will not be reached unless it is very small. A value
too high is not recommended as an array of this size is reserved in memory
during the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n0</code></td>
<td>
<p>The sum will be approximated for the series starting at this value
for the first parameter of <code>logFunction</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceAlgorithm</code></td>
<td>
<p>A value to control which summation algorithm to use.
Ignored if the series is alternating, defined with argument <code>alternate</code>.
See 'details'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The approximated sum is based on some theoretical results which,
analytically, guarantee that the approximation will be within <code>epsilon</code>
distance to the true value. It is possible that the numerical result fails
to fall in this distance due to floating point arithmetic. The <code>C</code> code
under the hood is being continuously reviewed to minimize this problem. They
seem to occur more often when the series decays very fast to zero or when the
total is a large number.
</p>
<p>For these theoretical results to work, the series must pass the ratio test,
which means that the ratio
a<sub>n+1</sub>/a<sub>n</sub> must
converge to a number <code class="reqn">L &lt; 1</code> when <code class="reqn">n</code> goes to infinity. The log of
<code class="reqn">L</code> should be provided to the function for a better approximation.
This is not necessary in case a precompiled function is used. In this case
the value of <code class="reqn">L</code> is coded into the package.
</p>
<p>Another requirement in the current installment of this function is that the
series must have only a single maximum. This is the case for most discrete
probability distributions and marginalization problems. This limitation
will be addressed in the future.
</p>
<p>There are currently two implemented algorithms that perform the calculations.
The first, called Sum-To-Threshold, sums the series values until the series
values are smaller than <code>epsilon</code>. This is the fastest algorithm, but
it is only guaranteed to provide an approximation within the desired error
margin when <code class="reqn">L &lt; 0.5</code>.
</p>
<p>The second algorithm, called Error bounding pairs is based on a more general
result which works for any <code class="reqn">0 \le L &lt; 1</code>. This algorithm sums the series
until
</p>
|a<sub>n+1</sub>/(1-L) - a<sub>n+1</sub> a<sub>n</sub>/(a<sub>n</sub> - a<sub>n+1</sub>)| &lt; 2 Îµ.
<p>Then the approximation is the added values of the sum plus
</p>
 0.5 (a<sub>n+1</sub>/(1-L) + a<sub>n+1</sub> a<sub>n</sub>/(a<sub>n</sub> - a<sub>n+1</sub>))
<p>The Error bounding pairs method usually requires less function evaluations
than the Sum-To-Threshold one, however the convergence checking is more
demanding, which means that it is typically slower, albeit slightly. If
<code class="reqn">L = 0</code>, the convergence checking can be reduced and the Error bounding
pairs becomes almost as fast as the Sum-To-Threshold method.
</p>
<p>The third algorithm is called batches method and is used when <code class="reqn">L</code> is
left at <code>NULL</code>. Its use requires some fine tuning, so there is a
standalone function for it called <code>infiniteSum_batches()</code>. Its use
and functionality can be seen in its own documentation. When called as a
result of this function, default settings are used.
</p>
<p>The <code>forceAlgorithm</code> parameter can be used to
control which algorithm to use. When it is 0, the program automatically
selects the Sum-to-threshold when <code class="reqn">L &lt; 0.5</code> and the Error bounding pairs
when <code class="reqn">0.5 \le L &lt; 1</code>. Method batches is selected when <code class="reqn">L</code> is left
<code>NULL</code>. If <code>forceAlgorithm</code> is set to 1, the Sum-To-Threshold
algorithm is forced. If it is 2, then the Error bounding pairs is forced. A
small note, the Error bounding pairs algorithm can go up to <code>maxIter</code> +
1 function evaluations. This is due to its convergence checking dependence on
a<sub>n+1</sub>. Finally, if the
parameter is set as 3, the batches algorithm is used with default settings.
</p>
<p>If the series is alternating, the Sum-To-Threshold convergence condition on
the series absolute value guarantees the result, regardless of the ratio
limit.
</p>
<p>The function to be summed can be an R function or a string naming the
precompiled function in the package. The list of precompiled functions can
be found in <code>precompiled()</code>, and more functions will be added in
time. As is intuitive, using a precompiled function is much faster than using
an <code>R</code> function. In fact, it has been observed to be dozens times faster.
</p>
<p>The advanced user can program their own precompiled functions and use the
package's summation algorithms by linking the appropriate header file. See
the <a href="https://github.com/GuidoAMoreira/sumR">GitHub</a> readme for the a
quick tutorial.
</p>


<h3>Value</h3>

<p>A <code>summed-objects()</code> object.
</p>


<h3>See Also</h3>

<p><code>precompiled()</code> provides a list with precompiled functions
that can be used for the summation. <code>infiniteSum_batches()</code> is
an alternate method which does not require knowledge of the <code>logL</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Define some function that is known to pass the ratio test.
param &lt;- 0.1
funfun &lt;- function(k, p) return(k * log1p(-p[1]))
result &lt;- infiniteSum(funfun, parameters = param, logL = log1p(-param))

## This series is easy to verify analytically
TrueSum &lt;- -log(param)
TrueSum - result$sum
# Since exp(logL) = 0.9, the Error bounding pairs
# algorithm is used. Notice that it only required
# 2 function evaluations for the approximation, that is
result$n

## A common problem is finding the normalizing constant for the
## Conway-Maxwell-Poisson distribution. It has already been included
## in the precompiled list of functions.
comp_params &lt;- c(lambda = 5, nu = 3)
result &lt;- infiniteSum("COMP", comp_params)
result
</code></pre>


</div>