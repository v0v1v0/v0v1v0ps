<div class="container">

<table style="width: 100%;"><tr>
<td>jsmurf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reconstruct filtered piecewise constant functions with noise</h2>

<h3>Description</h3>

<p>Reconstructs a piecewise constant function to which white noise was added and the sum filtered afterwards.
</p>
<p><b>Deprecation warning:</b> This function is mainly used for patchlamp recordings and may be transferred to a specialised package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">jsmurf(y, x = 1:length(y), x0 = 2 * x[1] - x[2], q, alpha = 0.05, r = 4e3,
  lengths = 2^(floor(log2(length(y))):floor(log2(max(length(param$kern) + 1,
    1 / param$param$cutoff)))), param, rm.out = FALSE,
    jumpint = confband, confband = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>threshold value, by default chosen automatically</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level; if set to a value in (0,1), <code>q</code> is chosen as the corresponding quantile of the asymptotic (if <code>r</code> is not given) null distribution (and any value specified for <code>q</code> is silently ignored)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>numer of simulations; if specified along <code>alpha</code>, <code>q</code> is chosen as the corresponding quantile of the simulated null distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lengths</code></td>
<td>
<p>length of intervals considered; by default up to a sample size of 1000 all lengths, otherwise only dyadic lengths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a <code>dfilter</code> object specifiying the filter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.out</code></td>
<td>
<p>a <code>logical</code> specifying whether outliers should be removed prior to the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jumpint</code></td>
<td>
<p><code>logical</code> (<code>FALSE</code> by default), indicates if confidence sets for jumps should be computed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confband</code></td>
<td>
<p><code>logical</code>, indicates if a confidence band for the piecewise-continuous function should be computed</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object object of class <code>stepfit</code> that contains the fit; if <code>jumpint == TRUE</code> function <code>jumpint</code> allows to extract the <code>1 - alpha</code> confidence interval for the jumps, if <code>confband == TRUE</code> function <code>confband</code> allows to extract the <code>1 - alpha</code> confidence band.
</p>


<h3>References</h3>

<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing ion channel recordings by a jump segmentation multiresolution filter. <em>IEEE Transactions on NanoBioscience</em> <b>12</b>(4), 376–386.
</p>


<h3>See Also</h3>

<p><code>stepbound</code>, <code>bounds</code>, family, <code>MRC.asymptotic</code>, <code>sdrobnorm</code>, <code>stepfit</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate filtered ion channel recording with two states
set.seed(9)
# sampling rate 10 kHz
sampling &lt;- 1e4
# tenfold oversampling
over &lt;- 10
# 1 kHz 4-pole Bessel-filter, adjusted for oversampling
cutoff &lt;- 1e3
df.over &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling / over))
# two states, leaving state 1 at 10 Hz, state 2 at 20 Hz
rates &lt;- rbind(c(0, 10), c(20, 0))
# simulate 0.5 s, level 0 corresponds to state 1, level 1 to state 2
# noise level is 0.3 after filtering
sim &lt;- contMC(0.5 * sampling, 0:1, rates, sampling=sampling, family="gaussKern",
  param = list(df=df.over, over=over, sd=0.3))
plot(sim$data, pch = ".")
lines(sim$discr, col = "red")
# fit using filter corresponding to sample rate
df &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling))
fit &lt;- jsmurf(sim$data$y, sim$data$x, param=df, r=1e2)
lines(fit, col = "blue")
# fitted values take filter into account
lines(sim$data$x, fitted(fit), col = "green3", lty = 2)
</code></pre>


</div>