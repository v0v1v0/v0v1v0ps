<div class="container">

<table style="width: 100%;"><tr>
<td>rmh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate point patterns using the Metropolis-Hastings algorithm.</h2>

<h3>Description</h3>

<p>Generic function for running the Metropolis-Hastings algorithm
to produce simulated realisations of a point process model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rmh(model, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The point process model to be simulated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments controlling the simulation.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Metropolis-Hastings algorithm can be used to
generate simulated realisations from a wide range of
spatial point processes. For caveats, see below.
</p>
<p>The function <code>rmh</code> is generic; it has methods
<code>rmh.ppm</code> (for objects of class <code>"ppm"</code>)
and  <code>rmh.default</code> (the default).
The actual implementation of the Metropolis-Hastings algorithm is
contained in <code>rmh.default</code>.
For details of its use, see 
<code>rmh.ppm</code> or <code>rmh.default</code>.
</p>
<p>[If the model is a Poisson process, then Metropolis-Hastings
is not used; the Poisson model is generated directly
using <code>rpoispp</code> or <code>rmpoispp</code>.]
</p>
<p>In brief, the Metropolis-Hastings algorithm is a Markov Chain,
whose states are spatial point patterns, and whose limiting
distribution is the desired point process. After
running the algorithm for a very large number of iterations,
we may regard the state of the algorithm as a realisation
from the desired point process.
</p>
<p>However, there are difficulties in deciding whether the
algorithm has run for “long enough”. The convergence of the
algorithm may indeed be extremely slow. No guarantees of
convergence are given!
</p>
<p>While it is fashionable to decry the Metropolis-Hastings algorithm
for its poor convergence and other properties, it has the advantage
of being easy to implement for a wide range of models.
</p>


<h3>Value</h3>

<p>A point pattern, in the form of an object of class <code>"ppp"</code>.
See <code>rmh.default</code> for details.
</p>


<h3>Warning</h3>

<p>As of version 1.22-1 of <code>spatstat</code> a subtle change was
made to <code>rmh.default()</code>.  We had noticed that the results
produced were sometimes not “scalable” in that two models,
differing in effect only by the units in which distances are
measured and starting from the same seed, gave different results.
This was traced to an idiosyncracy of floating point arithmetic.
The code of <code>rmh.default()</code> has been changed so that the
results produced by <code>rmh</code> are now scalable.  The downside of
this is that code which users previously ran may now give results
which are different from what they formerly were.
</p>
<p>In order to recover former behaviour (so that previous results
can be reproduced) set <code>spatstat.options(scalable=FALSE)</code>.
See the last example in the help for <code>rmh.default</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>rmh.default</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # See examples in rmh.default and rmh.ppm
</code></pre>


</div>