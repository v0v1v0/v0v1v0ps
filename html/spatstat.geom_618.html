<div class="container">

<table style="width: 100%;"><tr>
<td>nnmark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Mark of Nearest Neighbour 
</h2>

<h3>Description</h3>

<p>Given a marked point pattern dataset <code>X</code>
this function computes, for each desired location <code>y</code>,
the mark attached to the nearest neighbour of <code>y</code> in <code>X</code>.
The desired locations <code>y</code> can be either a pixel grid
or the point pattern <code>X</code> itself.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nnmark(X, ..., k = 1, at=c("pixels", "points"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A marked point pattern (object of class <code>"ppp"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to <code>as.mask</code> to determine the
pixel resolution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>Single integer. The <code>k</code>th nearest data point will be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>

<p>String specifying whether to compute the values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a marked point pattern dataset <code>X</code>
this function computes, for each desired location <code>y</code>,
the mark attached to the point of <code>X</code> that is nearest
to <code>y</code>. The desired locations <code>y</code> can be either a pixel grid
or the point pattern <code>X</code> itself.
</p>
<p>The argument <code>X</code> must be a marked point pattern (object
of class <code>"ppp"</code>, see <code>ppp.object</code>).
The marks are allowed to be a vector or a data frame.
</p>

<ul>
<li>
<p>If <code>at="points"</code>, then for each point in <code>X</code>,
the algorithm finds the nearest <em>other</em> point in <code>X</code>,
and extracts the mark attached to it.
The result is a vector or data frame containing the marks
of the neighbours of each point.
</p>
</li>
<li>
<p>If <code>at="pixels"</code> (the default), then for each pixel
in a rectangular grid, the algorithm finds the nearest point in <code>X</code>,
and extracts the mark attached to it.
The result is an image or a list of images containing the marks
of the neighbours of each pixel.
The pixel resolution is controlled by the arguments <code>...</code>
passed to <code>as.mask</code>.
</p>
</li>
</ul>
<p>If the argument <code>k</code> is given, then the <code>k</code>-th nearest
neighbour will be used.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
The value at each pixel is the mark attached
to the nearest point of <code>X</code>.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a vector or factor
of length equal to the number of points in <code>X</code>.
Entries are the mark values of the
nearest neighbours of each point of <code>X</code>.
</p>
</li>
</ul>
<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
Entries are the mark values of the
nearest neighbours of each point of <code>X</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>Smooth.ppp</code>,
<code>marktable</code>,
<code>nnwhich</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  plot(nnmark(ants))
  v &lt;- nnmark(ants, at="points")
  v[1:10]
  plot(nnmark(finpines))
  vf &lt;- nnmark(finpines, at="points")
  vf[1:5,]
</code></pre>


</div>