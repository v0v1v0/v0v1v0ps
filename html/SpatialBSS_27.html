<div class="container">

<table style="width: 100%;"><tr>
<td>snss_jd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spatial Non-Stationary Source Separation Joint Diagonalization
</h2>

<h3>Description</h3>

<p><code>snss_jd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant covariance by jointly diagonalizing at least two covariance matrices computed for corresponding different sub-domains.
</p>


<h3>Usage</h3>

<pre><code class="language-R">snss_jd(x, ...)

## Default S3 method:
snss_jd(x, coords, n_block, ordered = TRUE, ...)
## S3 method for class 'list'
snss_jd(x, coords, ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_jd(x, ...)
## S3 method for class 'sf'
snss_jd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length <code>K</code> defining the subdivision of the domain, an object of class <code>sf</code> or an object of class <code>SpatialPointsDataFrame</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length <code>K</code> if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_block</code></td>
<td>

<p>an integer defining the subdivision of the domain. See details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared pseudo-eigenvalues of the diagonalized sub-domain covariance matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the sub-domain covariance matrices. See details and <code>frjd</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant variances. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain into <code>n_block^2</code> equally sized rectangular sub-domains and jointly diagonalizing the corresponding covariance matrices for all sub-domains.
</p>
<p>Alternatively the domain subdivision can be defined by providing lists of length <code>K</code> for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain, etc..
</p>
<p><code>snss_jd</code> jointly diagonalizes the covariance matrices for each sub-domain with the function <code>frjd</code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Similarly as <code>sbss</code> the function <code>snss_jd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized sub-domain covariance matrices with dimension <code>c(n_block^2*p,p)</code> or <code>c(K*p,p)</code> if <code>x</code> and <code>coords</code> are lists of length <code>K</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>sp</code>, <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                                data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_jd with 4 sub-domains 
res_4 &lt;- snss_jd(observed_field, coords, n_block = 2)
JADE::MD(W.hat = coef(res_4), A = mixing_matrix)

# apply snss_jd with 9 sub-domains
res_9 &lt;- snss_jd(observed_field, coords, n_block = 3)
JADE::MD(W.hat = coef(res_9), A = mixing_matrix)
cor(res_9$s, latent_field)

# print object
print(res_4)

# plot latent field
plot(res_4, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_4, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_4)

# apply snss_jd with SpatialPointsDataFrame object 
res_4_sp &lt;- snss_jd(observed_field_sp, n_block = 2)

# apply with list arguments
# first axis split by 5
# second axis split by 10
# results in 4 sub-domains
flag_x &lt;- coords[, 1] &lt; 5
flag_y &lt;- coords[, 2] &lt; 10
coords_list &lt;- list(coords[flag_x &amp; flag_y, ],
                    coords[!flag_x &amp; flag_y, ],
                    coords[flag_x &amp; !flag_y, ],
                    coords[!flag_x &amp; !flag_y, ])
field_list &lt;- list(observed_field[flag_x &amp; flag_y, ],
                   observed_field[!flag_x &amp; flag_y, ],
                   observed_field[flag_x &amp; !flag_y, ],
                   observed_field[!flag_x &amp; !flag_y, ])
plot(coords, col = 1)
points(coords_list[[2]], col = 2)
points(coords_list[[3]], col = 3)
points(coords_list[[4]], col = 4)

res_list &lt;- snss_jd(x = field_list,
                    coords = coords_list)
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>


</div>