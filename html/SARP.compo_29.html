<div class="container">

<table style="width: 100%;"><tr>
<td>puissance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate the power and the type-I error of the disjoint-subgraphs method
</h2>

<h3>Description</h3>

<p> Estimate the power and the type-I error of the
disjoint-graph method to detect a change in compositions between
different conditions </p>


<h3>Usage</h3>

<pre><code class="language-R">estimer.puissance( composition, cv.composition,
                   taille.groupes = 10, masque,
                   f.p, v.X = 'Condition',
                   seuil.candidats = ( 5:30 ) / 100,
                   f.correct = groupes.identiques,
                   groupes.attendus = composition$Graphes[[ 1 ]]$Connexe,
                   avec.classique = length( attr( composition, "reference" ) ) &gt; 0,
                   f.correct.classique = genes.trouves,
                   genes.attendus,
                   B = 3000, n.coeurs = 1,
                   ... )

estimer.alpha( composition, cv.composition,
               taille.groupes = 10, masque,
               f.p, v.X = 'Condition',
               seuil.candidats = ( 5:30 ) / 100,
               avec.classique = length( attr( composition, "reference" ) ) &gt; 0,
               B = 3000, n.coeurs = 1,
               ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>composition</code></td>
<td>
<p> A composition model, as obtained by
<code>modele_compo</code>.  For simulations under the null
hypothesis (<code>estimer.alpha</code>), the first condition is
duplicated to other conditions (but not the cv.composition, if
provided as a matrix, allowing to explore some kinds of
pseudo-null hypothesis).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.composition</code></td>
<td>
<p>The expected coefficient of variation of the
quantified amounts. Should be either a single value, that will be
used for all components and all conditions, or a matrix with the
same structure than <code>composition$Absolue</code>: one row for each
condition, one column for each component, in the same order and with
the same names.  Coefficients of variations are expected in the
amount scale, in raw form (that is, give 0.2 for a 20% coefficient
of variation)</p>
</td>
</tr>
</table>
<p>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>taille.groupes</code></td>
<td>
<p>The sample size for each condition. Unused if
<code>masque</code> is given.  If a single value, it will be used for all
conditions.  Otherwise, should have the same length that the number
of conditions in the provided model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>masque</code></td>
<td>
<p>A data.frame that will give the dataset design for a
given experiment. Should contain at least one column containing the
names of the conditions, with values being in the conditions names
in  <code>composition</code>.  If not provided, it is generated from
<code>taille.groupes</code> as a single column named ‘Condition’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.p</code></td>
<td>
<p>The function used to analyse the dataset. See
<code>creer.Mp</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.X</code></td>
<td>
<p>The name of the column identifying the different conditions
in <code>masque</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seuil.candidats</code></td>
<td>
<p>A vector of p-value cut-offs to be tested. All
values should be between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.correct</code></td>
<td>
<p>A function to determine if the result of the analysis
is the expected one. Defaults to a function that compares the
disjoint sub-graphs of a reference graph and the obtained one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupes.attendus</code></td>
<td>
<p>The reference graph for the above
function. Defaults to the theoretical graph of the model, for the
comparison between the first and the second conditions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avec.classique</code></td>
<td>
<p>If <code>TRUE</code>, analysis is also done using an
additive log-ratio (alr)-like method, using the geometric mean of
the reference components as the “normalisation factor”.  This
correspond to the Delta-Delta-Ct method, or similar methods, in
qRT-PCR. With this method, each non-reference component is tested in
turn after division by the normalisation factor.
</p>
<p>If requested, the analysis is done with and without multiple testing
correction (with Holm's method). The “cut-off p-value” is
used as the nominal type~I error level for the individual tests.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.correct.classique</code></td>
<td>
<p>A function to determine if the alr-like
method finds the correct answer. Defaults to a function that
compares the set of significant tests with the set of expected
components.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genes.attendus</code></td>
<td>
<p>A character vector giving the names of
components expected to behave differently than the reference set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>The number of simulations to be done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additionnal parameters for helper functions, including <code>f.p</code>,
<code>f.correct</code> and <code>f.correct.classique</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Use this function to simulate experiments and explore the properties
of the disjoint graph method in a specified experimental context.
Simulations are done using a log-normal model, so analysis is always
done on the log scale. Coefficients of variation in the original scale
hence directly translate into standard deviations in the log-scale.
</p>
<p>For power analysis, care should be taken that any rejection of the
null hypothesis “nothing is different between conditions” is
counted as a success, even if the result does not respect the original
changes.  This is the reason for the additional correct-finding
probability estimation.  However, defining what is a correct, or at
least acceptable, result may be not straightforward, especially for
comparison with other analysis methods.
</p>
<p>Note also that fair power comparisons can be done only for the same
type I error level. Hence, for instance, power of the corrected
alr-like method at p = 0.05 should be compared to the power of the
disjoint-graph method at its “optimal” cut-off.
</p>


<h3>Value</h3>

<p> An object of class <code>SARPcompo.simulation</code>, with a plot
method. It is a data.frame with the following columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Seuil</code></td>
<td>
<p>The cut-offs used to build the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Disjoint</code></td>
<td>
<p>The number of simulations that led to disjoint
graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Correct</code></td>
<td>
<p>The number of simulations that led to the correct graph
(as defined by the <code>f.correct</code> function).</p>
</td>
</tr>
</table>
<p>If <code>avec.classique</code> is <code>TRUE</code>, it has additionnal columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>DDCt</code></td>
<td>
<p>The number of simulations that led at least one
significant test using the alr-like method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DDCt.H</code></td>
<td>
<p>The number of simulations that led at least one
significant test using the alr-like method, after multiple testing
correction using Holm's method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DDCt.correct</code></td>
<td>
<p>The number of simulations that detected the
correct components (as defined by the <code>f.correct.classique</code>
function) using the alr-like method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DDCt.H.correct</code></td>
<td>
<p>As above, but after multiple testing correction
using Holm's method.</p>
</td>
</tr>
</table>
<p>It also stores a few informations as attributes, including the total
number of simulations (attribute <code>n.simulations</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code>modele_compo</code> to create a compositional model for two or
more conditions.
</p>
<p><code>creer.Mp</code>, which is used internally, for details about
analysis functions. 
</p>
<p><code>choisir.seuil</code> for a simpler interface to estimate the
optimal cut-off.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## Create a toy example: four components, two conditions
  ##  components 1 and 2 do not change between conditions
  ##  components 3 and 4 are doubled
  ##  component  1 is a reference component
  me &lt;- rbind( 'A' = c( 1, 1, 1, 1 ),
               'B' = c( 1, 1, 2, 2 ) )
  colnames( me ) &lt;- paste0( "C-", 1:4 )

  md &lt;- modele_compo( me, reference = 'C-1' )

  ## How many simulations?
  ##  50 is for speed; increase for useful results...
  B &lt;- 50

  ## What is the optimal cut-off for this situation?
  ## (only a few simulations for speed, should be increased)
  ## (B = 3000 suggests a cut-off between 0.104 and 0.122)
  seuil &lt;- choisir.seuil( 4, B = B )

  ## What is approximately the type I error
  ## between conditions A and B using a Student test
  ## with a CV of around 50 % ?
  ##  (only a few simulations for speed, should be increased)
  alpha &lt;- estimer.alpha( md, cv = 0.50, B = B,
                          f.p = student.fpc )

  # Plot it : darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( alpha )

  ## What is approximately the power to detect that something changes
  ## between conditions A and B using a Student test
  ## with a CV of around 50 % ?
  ##  (only a few simulations for speed, should be increased)
  puissance &lt;- estimer.puissance( md, cv = 0.50, B = B,
                                  f.p = student.fpc,
                                  genes.attendus = c( 'C-3', 'C-4' )  )

  # Plot it : darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( puissance )

  ## Do we detect the correct situation in general?
  ##  (that is, exactly two sets: one with C-1 and C-2, the second with
  ##   C-3 and C-4 --- for the alr-like method, that only C-3 and C-4
  ##   are significant)
  #           darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( puissance, correct = TRUE )
  
</code></pre>


</div>