<div class="container">

<table style="width: 100%;"><tr>
<td>atos</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive three operator splitting (ATOS).</h2>

<h3>Description</h3>

<p>Function for fitting adaptive three operator splitting (ATOS) with general convex penalties. Supports both linear and logistic regression, both with dense and sparse matrix implementations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">atos(
  X,
  y,
  type = "linear",
  prox_1,
  prox_2,
  pen_prox_1 = 0.5,
  pen_prox_2 = 0.5,
  max_iter = 5000,
  backtracking = 0.7,
  max_iter_backtracking = 100,
  tol = 1e-05,
  prox_1_opts = NULL,
  prox_2_opts = NULL,
  standardise = "l2",
  intercept = TRUE,
  x0 = NULL,
  u = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Input matrix of dimensions <code class="reqn">n \times p</code>. Can be a sparse matrix (using class <code>"sparseMatrix"</code> from the <code>Matrix</code> package)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Output vector of dimension <code class="reqn">n</code>. For <code>type="linear"</code> needs to be continuous and for <code>type="logistic"</code> needs to be a binary variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of regression to perform. Supported values are: <code>"linear"</code> and <code>"logistic"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prox_1</code></td>
<td>
<p>The proximal operator for the first function, <code class="reqn">h(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prox_2</code></td>
<td>
<p>The proximal operator for the second function, <code class="reqn">g(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen_prox_1</code></td>
<td>
<p>The penalty for the first proximal operator. For the lasso, this would be the sparsity parameter, <code class="reqn">\lambda</code>. If operator does not include a penalty, set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen_prox_2</code></td>
<td>
<p>The penalty for the second proximal operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>Maximum number of ATOS iterations to perform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtracking</code></td>
<td>
<p>The backtracking parameter, <code class="reqn">\tau</code>, as defined in Pedregosa and Gidel (2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_backtracking</code></td>
<td>
<p>Maximum number of backtracking line search iterations to perform per global iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Convergence tolerance for the stopping criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prox_1_opts</code></td>
<td>
<p>Optional argument for first proximal operator. For the group lasso, this would be the group IDs. Note: this must be inserted as a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prox_2_opts</code></td>
<td>
<p>Optional argument for second proximal operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardise</code></td>
<td>
<p>Type of standardisation to perform on <code>X</code>:
</p>

<ul>
<li> <p><code>"l2"</code> standardises the input data to have <code class="reqn">\ell_2</code> norms of one.
</p>
</li>
<li> <p><code>"l1"</code> standardises the input data to have <code class="reqn">\ell_1</code> norms of one.
</p>
</li>
<li> <p><code>"sd"</code> standardises the input data to have standard deviation of one.
</p>
</li>
<li> <p><code>"none"</code> no standardisation applied.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical flag for whether to fit an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>Optional initial vector for <code class="reqn">x_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Optional initial vector for <code class="reqn">u</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag for whether to print fitting information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>atos()</code> solves convex minimization problems of the form
</p>
<p style="text-align: center;"><code class="reqn">
  f(x) + g(x) + h(x),
</code>
</p>

<p>where <code class="reqn">f</code> is convex and differentiable with <code class="reqn">L_f</code>-Lipschitz gradient, and <code class="reqn">g</code> and <code class="reqn">h</code> are both convex.
The algorithm is not symmetrical, but usually the difference between variations are only small numerical values, which are filtered out.
However, both variations should be checked regardless, by looking at <code>x</code> and <code>u</code>. An example for the sparse-group lasso (SGL) is given.
</p>


<h3>Value</h3>

<p>An object of class <code>"atos"</code> containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The fitted values from the regression. Taken to be the more stable fit between <code>x</code> and <code>u</code>, which is usually the former.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The solution to the original problem (see Pedregosa and Gidel (2018)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>The solution to the dual problem (see Pedregosa and Gidel (2018)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>The updated values from applying the first proximal operator (see Pedregosa and Gidel (2018)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Indicates which type of regression was performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>success</code></td>
<td>
<p>Logical flag indicating whether ATOS converged, according to <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_it</code></td>
<td>
<p>Number of iterations performed. If convergence is not reached, this will be <code>max_iter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>certificate</code></td>
<td>
<p>Final value of convergence criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical flag indicating whether an intercept was fit.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Pedregosa, F., Gidel, G. (2018). <em>Adaptive Three Operator Splitting</em>, <a href="https://proceedings.mlr.press/v80/pedregosa18a.html">https://proceedings.mlr.press/v80/pedregosa18a.html</a>
</p>


</div>