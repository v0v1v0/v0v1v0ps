<div class="container">

<table style="width: 100%;"><tr>
<td>hop_index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hop relative to an index</h2>

<h3>Description</h3>

<p><code>hop_index()</code> is the lower level engine that powers <code>slide_index()</code>. It
has slightly different invariants than <code>slide_index()</code>, and is useful when
you either need to hand craft boundary values, or want to compute a result
with a size that is different from <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hop_index(.x, .i, .starts, .stops, .f, ...)

hop_index_vec(.x, .i, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.i</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li>
<p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li>
<p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li>
<p> The index cannot have missing values.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.starts, .stops</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>Vectors of boundary values that make up the windows to bucket <code>.i</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
the same type as <code>.i</code>. These boundaries are both <em>inclusive</em>, meaning
that the slice of <code>.x</code> that will be used in each call to <code>.f</code> is where
<code>.i &gt;= start &amp; .i &lt;= stop</code> returns <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p><code style="white-space: pre;">⁠[function / formula]⁠</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ptype</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(0) / NULL]⁠</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop_index()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index(.x, .starts, .stops)) == list()</code>
</p>
</li>
</ul>
<h4><code>hop_index_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index_vec(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop_index_vec(.x, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index_vec(.x, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>slide()</code>, <code>slide_index()</code>, <code>hop_index2()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(vctrs)
library(lubridate, warn.conflicts = FALSE)

# ---------------------------------------------------------------------------
# Returning a size smaller than `.x`

i &lt;- as.Date("2019-01-25") + c(0, 1, 2, 3, 10, 20, 35, 42, 45)

# slide_index() allows you to slide relative to `i`
slide_index(i, i, ~.x, .before = weeks(1))

# But you might be more interested in coarser summaries. This groups
# by year-month and computes 2 `.f` on 2 month windows.
i_yearmonth &lt;- year(i) + (month(i) - 1) / 12
slide_index(i, i_yearmonth, ~.x, .before = 1)

# ^ This works nicely when working with dplyr if you are trying to create
# a new column in a data frame, but you'll notice that there are really only
# 3 months, so only 3 values are being calculated. If you only want to return
# a vector of those 3 values, you can use `hop_index()`. You'll have to
# hand craft the boundaries, but this is a general strategy
# I've found useful:
first_start &lt;- floor_date(i[1], "months")
last_stop &lt;- ceiling_date(i[length(i)], "months")
dates &lt;- seq(first_start, last_stop, "1 month")
inner &lt;- dates[2:(length(dates) - 1L)]
starts &lt;- vec_c(first_start, inner)
stops &lt;- vec_c(inner - 1, last_stop)

hop_index(i, i, starts, stops, ~.x)

# ---------------------------------------------------------------------------
# Non-existant dates with `lubridate::months()`

# Imagine you want to compute a 1 month rolling average on this
# irregular daily data.
i &lt;- vec_c(as.Date("2019-02-27") + 0:3, as.Date("2019-03-27") + 0:5)
x &lt;- rnorm(vec_seq_along(i))

# You might try `slide_index()` like this, but you'd run into this error
library(rlang)

with_options(
  catch_cnd(
    slide_index(x, i, mean, .before = months(1))
  ),
  rlang_backtrace_on_error = current_env()
)

# This is because when you actually compute the `.i - .before` sequence,
# you hit non-existant dates. i.e. `"2019-03-29" - months(1)` doesn't exist.
i - months(1)

# To get around this, lubridate provides `add_with_rollback()`,
# and the shortcut operation `%m-%`, which subtracts the month, then rolls
# forward/backward if it hits an `NA`. You can manually generate boundaries,
# then provide them to `hop_index()`.
starts &lt;- i %m-% months(1)
stops &lt;- i

hop_index(x, i, starts, stops, mean)

hop_index(i, i, starts, stops, ~.x)

</code></pre>


</div>