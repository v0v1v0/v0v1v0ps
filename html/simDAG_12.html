<div class="container">

<table style="width: 100%;"><tr>
<td>matrix2dag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Obtain a <code>DAG</code> object from a Adjacency Matrix and a List of Node Types
</h2>

<h3>Description</h3>

<p>The <code>sim_from_dag</code> function requires the user to specify the causal relationships inside a <code>DAG</code> object containing node information. This function creates such an object using a adjacency matrix and a list of node types. The resulting <code>DAG</code> will be only partially specified, which may be useful for the <code>dag_from_data</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">matrix2dag(mat, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>

<p>A p x p adjacency matrix where p is the number of variables. The matrix should be filled with zeros. Only places where the variable specified by the row has a direct causal effect on the variable specified by the column should be 1. Both the columns and the rows should be named with the corresponding variable names.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>A named list with one entry for each variable in <code>mat</code>, specifying the <code>type</code> of the corresponding node. See <code>node</code> for available node types.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An adjacency matrix is simply a square matrix in which each node has one column and one row associated with it. For example, if the node A has a causal effect on node B, the matrix will contain <code>1</code> in the spot <code>matrix["A", "B"]</code>. This function uses this kind of matrix and additional information about the node type to create a <code>DAG</code> object. The resulting <code>DAG</code> cannot be used in the <code>sim_from_dag</code> function directly, because it will not contain the necessary parameters such as beta-coefficients or intercepts etc. It may, however, be passed directly to the <code>dag_from_data</code> function. This is pretty much it's only valid use-case. If the goal is to to specify a full <code>DAG</code> manually, the user should use the <code>empty_dag</code> function in conjunction with <code>node</code> calls instead, as described in the respective documentation pages and the vignettes.
</p>
<p>The output will never contain time-dependent nodes. If this is necessary, the user needs to manually define the DAG.
</p>


<h3>Value</h3>

<p>Returns a partially specified <code>DAG</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin Denz
</p>


<h3>See Also</h3>

<p><code>empty_dag</code>, <code>node</code>, <code>node_td</code>, <code>dag_from_data</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(simDAG)

# simple example adjacency matrix
mat &lt;- matrix(c(0, 0, 1, 0, 0, 1, 0, 0, 0), ncol=3, byrow=TRUE)
colnames(mat) &lt;- c("age", "sex", "death")
rownames(mat) &lt;- c("age", "sex", "death")

type &lt;- list(age="rnorm", sex="rbernoulli", death="binomial")

matrix2dag(mat=mat, type=type)
</code></pre>


</div>