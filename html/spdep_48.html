<div class="container">

<table style="width: 100%;"><tr>
<td>dnearneigh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Neighbourhood contiguity by distance</h2>

<h3>Description</h3>

<p>The function identifies neighbours of region points by Euclidean distance in the metric of the points between lower (greater than or equal to (changed from version 1.1-7)) and upper (less than or equal to) bounds, or with longlat = TRUE, by Great Circle distance in kilometers. If <code>x</code> is an <code>"sf"</code> object and <code>use_s2=</code> is <code>TRUE</code>, spherical distances in km are used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c("GE", "LE"),
 use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion("s2") &gt; "1.0.7", k=200,
 dwithin=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix of point coordinates, an object inheriting from SpatialPoints or an <code>"sf"</code> or <code>"sfc"</code> object; if the <code>"sf"</code> or <code>"sfc"</code> object geometries are in geographical coordinates (<code>use_s2=FALSE</code>, <code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>), <span class="pkg">s2</span> will be used to find the neighbours because it will (we hope) use spatial indexing <a href="https://github.com/r-spatial/s2/issues/125">https://github.com/r-spatial/s2/issues/125</a> as opposed to the legacy method which uses brute-force (at present <span class="pkg">s2</span> also uses brute-force)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d1</code></td>
<td>
<p>lower distance bound in the metric of the points if planar coordinates, in km if in geographical coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2</code></td>
<td>
<p>upper distance boundd in the metric of the points if planar coordinates, in km if in geographical coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>character vector of region ids to be added to the neighbours list as attribute <code>region.id</code>, default <code>seq(1, nrow(x))</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>TRUE if point coordinates are geographical longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself, and overrides this argument if not NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>character vector of length 2, default <code>c("GE", "LE")</code>, (GE: greater than or equal to, LE: less than or equal to) that is the finite and closed interval <code>[d1, d2]</code>, <code>d1 &lt;= x &lt;= d2</code>. The first element may also be <code>"GT"</code> (GT: greater than), the second <code>"LT"</code> (LT: less than) for finite, open intervals excluding the bounds; the first bound default was changed from <code>"GT"</code> to <code>"GE"</code> in release 1.1-7. When creating multiple distance bands, finite, half-open right-closed intervals may be used until the final interval to avoid overlapping on bounds: <code>"GE", "LT"</code>, that is <code>[d1, d2)</code>, <code>d1 &lt;= x &lt; d2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_kd_tree</code></td>
<td>
<p>default TRUE, if TRUE, use <span class="pkg">dbscan</span> <code>frNN</code> if available (permitting 3D distances).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symtest</code></td>
<td>
<p>Default FALSE; before release 1.1-7, TRUE - run symmetry check on output object, costly with large numbers of points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_s2</code></td>
<td>
<p>default=<code>packageVersion("s2") &gt; "1.0.7"</code>, as of <span class="pkg">s2</span> &gt; 1.0-7, distance bound computations use spatial indexing so when <code>sf::sf_use_s2()</code> is TRUE, <code>s2::s2_dwithin_matrix()</code> will be used for distances on the sphere for <code>"sf"</code> or <code>"sfc"</code> objects if <span class="pkg">s2</span> &gt; 1.0-7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>default 200, the number of closest points to consider when searching when using  <code>s2::s2_closest_edges()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dwithin</code></td>
<td>
<p>default TRUE, if FALSE, use <code>s2::s2_closest_edges()</code>, both if <code>use_s2=TRUE</code>, <code>sf::st_is_longlat(x) == TRUE</code> and <code>sf::sf_use_s2() == TRUE</code>; <code>s2::s2_dwithin_matrix()</code> yields the same lists of neighbours as <code>s2::s2_closest_edges()</code> is <code>k=</code> is set correctly.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list of integer vectors giving the region id numbers
for neighbours satisfying the distance criteria. See <code>card</code> for details of “nb” objects.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>See Also</h3>

<p><code>knearneigh</code>, <code>card</code></p>


<h3>Examples</h3>

<pre><code class="language-R">columbus &lt;- st_read(system.file("shapes/columbus.gpkg", package="spData")[1], quiet=TRUE)
coords &lt;- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE)
rn &lt;- row.names(columbus)
k1 &lt;- knn2nb(knearneigh(coords))
all.linked &lt;- max(unlist(nbdists(k1, coords)))
col.nb.0.all &lt;- dnearneigh(coords, 0, all.linked, row.names=rn)
summary(col.nb.0.all, coords)
opar &lt;- par(no.readonly=TRUE)
plot(st_geometry(columbus), border="grey", reset=FALSE,
 main=paste("Distance based neighbours 0-",  format(all.linked), sep=""))
plot(col.nb.0.all, coords, add=TRUE)
par(opar)
(sfc_obj &lt;- st_centroid(st_geometry(columbus)))
col.nb.0.all_sf &lt;- dnearneigh(sfc_obj, 0, all.linked, row.names=rn)
all.equal(col.nb.0.all, col.nb.0.all_sf, check.attributes=FALSE)
data(state)
us48.fipsno &lt;- read.geoda(system.file("etc/weights/us48.txt",
 package="spdep")[1])
if (as.numeric(paste(version$major, version$minor, sep="")) &lt; 19) {
 m50.48 &lt;- match(us48.fipsno$"State.name", state.name)
} else {
 m50.48 &lt;- match(us48.fipsno$"State_name", state.name)
}
xy &lt;- as.matrix(as.data.frame(state.center))[m50.48,]
llk1 &lt;- knn2nb(knearneigh(xy, k=1, longlat=FALSE))
(all.linked &lt;- max(unlist(nbdists(llk1, xy, longlat=FALSE))))
ll.nb &lt;- dnearneigh(xy, 0, all.linked, longlat=FALSE)
summary(ll.nb, xy, longlat=TRUE, scale=0.5)
gck1 &lt;- knn2nb(knearneigh(xy, k=1, longlat=TRUE))
(all.linked &lt;- max(unlist(nbdists(gck1, xy, longlat=TRUE))))
gc.nb &lt;- dnearneigh(xy, 0, all.linked, longlat=TRUE)
summary(gc.nb, xy, longlat=TRUE, scale=0.5)
plot(ll.nb, xy)
plot(diffnb(ll.nb, gc.nb), xy, add=TRUE, col="red", lty=2)
title(main="Differences Euclidean/Great Circle")

#xy1 &lt;- SpatialPoints((as.data.frame(state.center))[m50.48,],
#  proj4string=CRS("+proj=longlat +ellps=GRS80"))
#gck1a &lt;- knn2nb(knearneigh(xy1, k=1))
#(all.linked &lt;- max(unlist(nbdists(gck1a, xy1))))
#gc.nb &lt;- dnearneigh(xy1, 0, all.linked)
#summary(gc.nb, xy1, scale=0.5)

xy1 &lt;- st_as_sf((as.data.frame(state.center))[m50.48,], coords=1:2,
  crs=st_crs("OGC:CRS84"))
old_use_s2 &lt;- sf_use_s2()
sf_use_s2(TRUE)
gck1b &lt;- knn2nb(knearneigh(xy1, k=1))
system.time(o &lt;- nbdists(gck1b, xy1))
(all.linked &lt;- max(unlist(o)))
# use s2 brute-force dwithin_matrix approach for s2 &lt;= 1.0.7
system.time(gc.nb.dwithin &lt;- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE))
summary(gc.nb, xy1, scale=0.5)
# use s2 closest_edges approach s2 &gt; 1.0.7
if (packageVersion("s2") &gt; "1.0.7") {
(system.time(gc.nb.closest &lt;- dnearneigh(xy1, 0, all.linked, dwithin=FALSE)))
}
if (packageVersion("s2") &gt; "1.0.7") {
system.time(gc.nb.dwithin &lt;- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE))
}
if (packageVersion("s2") &gt; "1.0.7") {
summary(gc.nb.dwithin, xy1, scale=0.5)
}
if (packageVersion("s2") &gt; "1.0.7") {
summary(gc.nb.closest, xy1, scale=0.5)
}
# use legacy symmetric brute-force approach
system.time(gc.nb.legacy &lt;- dnearneigh(xy1, 0, all.linked, use_s2=FALSE))
summary(gc.nb, xy1, scale=0.5)
if (packageVersion("s2") &gt; "1.0.7") all.equal(gc.nb.closest, gc.nb.dwithin, check.attributes=FALSE)
# legacy is ellipsoidal, s2 spherical, so minor differences expected
if (packageVersion("s2") &gt; "1.0.7") all.equal(gc.nb, gc.nb.closest, check.attributes=FALSE)
all.equal(gc.nb, gc.nb.dwithin, check.attributes=FALSE)
sf_use_s2(old_use_s2)
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
k1 &lt;- knn2nb(knearneigh(coords, k=1))
all.linked &lt;- max(unlist(nbdists(k1, coords)))
dnearneigh(coords, 0, all.linked)
</code></pre>


</div>