<div class="container">

<table style="width: 100%;"><tr>
<td>plotSoilRelationGraph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot a component relation graph</h2>

<h3>Description</h3>

<p>Plot a component relation graph based on an adjacency or similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotSoilRelationGraph(
  m,
  s = "",
  plot.style = c("network", "dendrogram", "none"),
  graph.mode = "upper",
  spanning.tree = NULL,
  del.edges = NULL,
  vertex.scaling.method = "degree",
  vertex.scaling.factor = 2,
  edge.scaling.factor = 1,
  vertex.alpha = 0.65,
  edge.transparency = 1,
  edge.col = grey(0.5),
  edge.highlight.col = "royalblue",
  g.layout = igraph::layout_with_fr,
  vertex.label.color = "black",
  delete.singletons = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>central component; an empty character string is interpreted as no central component</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.style</code></td>
<td>
<p>plot style ('network', or 'dendrogram'), or 'none' for no graphical output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.mode</code></td>
<td>
<p>interpretation of adjacency matrix: 'upper' or 'directed', see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spanning.tree</code></td>
<td>
<p>plot the minimum or maximum spanning tree ('min', 'max'), or, max spanning tree plus edges with weight greater than the n-th quantile specified in <code>spanning.tree</code>. See details and examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>del.edges</code></td>
<td>
<p>optionally delete edges with weights less than the specified quantile (0-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.scaling.method</code></td>
<td>
<p>'degree' (default) or 'distance', see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.scaling.factor</code></td>
<td>
<p>scaling factor applied to vertex size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.scaling.factor</code></td>
<td>
<p>optional scaling factor applied to edge width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.alpha</code></td>
<td>
<p>optional transparency setting for vertices (0-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.transparency</code></td>
<td>
<p>optional transparency setting for edges (0-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.col</code></td>
<td>
<p>edge color, applied to all edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.highlight.col</code></td>
<td>
<p>edge color applied to all edges connecting to component named in <code>s</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.layout</code></td>
<td>
<p>an igraph layout function, defaults to <code>igraph::layout_with_fr</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.label.color</code></td>
<td>
<p>vertex label color</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delete.singletons</code></td>
<td>
<p>optionally delete vertices with no edges (<code>degree == 0</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to plotting function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Vertex size is based on a normalized index of connectivity:
</p>

<ul>
<li>
<p> "degree" size = <code>sqrt(igraph::degree(g) / max(igraph::degree(g))) * scaling.factor</code>
</p>
</li>
<li>
<p> "distance" size = <code>sqrt(igraph::distance(V -&gt; s) / max(igraph::distance(V -&gt; s))) * scaling.factor</code>, where distance(V-&gt;s) is the distance from all nodes to the named series, <code>s</code>.
</p>
</li>
</ul>
<p>Edge width can be optionally scaled by edge weight by specifying an <code>edge.scaling.factor</code> value. The maximum spanning tree represents a sub-graph where the sum of edge weights are maximized. The minimum spanning tree represents a sub-graph where the sum of edge weights are minimized. The maximum spanning tree is likely a more useful simplification of the full graph, in which only the strongest relationships (e.g. most common co-occurrences) are preserved.
</p>
<p>The maximum spanning tree + edges with weights &gt; n-th quantile is an experimental hybrid. The 'backbone' of the graph is created by the maximum spanning tree, and augmented by 'strong' auxiliary edgesâ€“defined by a value between 0 and 1.
</p>
<p>The <code>graph.mode</code> argument is passed to <code>igraph::graph_from_adjacency_matrix()</code> and determines how vertex relationships are coded in the adjacency matrix <code>m</code>. Typically, the default value of 'upper' (the upper triangle of <code>m</code> contains adjacency information) is the desired mode. If <code>m</code> contains directional information, set <code>graph.mode</code> to 'directed'. This has the side-effect of altering the default community detection algorithm from <code>igraph::cluster_fast_greedy</code> to <code>igraph::cluster_walktrap</code>.
</p>


<h3>Value</h3>

<p>an igraph <code>graph</code> object is invisibly returned
</p>


<h3>Note</h3>

<p>This function is a work in progress, ideas welcome.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("igraph")) {
  # load sample data set
  data(amador)

  # create weighted adjacency matrix (see ?component.adj.matrix for details)
  m &lt;- component.adj.matrix(amador)

  # plot network diagram, with Amador soil highlighted
  plotSoilRelationGraph(m, s='amador')

  # dendrogram representation
  plotSoilRelationGraph(m, s='amador', plot.style='dendrogram')

  # compare methods
  m.o &lt;- component.adj.matrix(amador, method='occurrence')

  op &lt;- par(no.readonly = TRUE)

  par(mfcol=c(1,2))
  plotSoilRelationGraph(m, s='amador', plot.style='dendrogram')
  title('community matrix')
  plotSoilRelationGraph(m.o, s='amador', plot.style='dendrogram')
  title('occurence')

  # investigate max spanning tree
  plotSoilRelationGraph(m, spanning.tree='max')

  # investigate max spanning tree + edges with weights &gt; 75-th pctile
  plotSoilRelationGraph(m, spanning.tree=0.75)

  par(op)

  
  
    if(requireNamespace("curl") &amp;
       curl::has_internet() &amp;
       require(soilDB)) {
    
      # get similar data from soilweb, for the Pardee series
      s &lt;- 'pardee'
      d &lt;- siblings(s, component.data = TRUE)
    
      # normalize component names
      d$sib.data$compname &lt;- tolower(d$sib.data$compname)
    
      # keep only major components
      d$sib.data &lt;- subset(d$sib.data, subset=compkind == 'Series')
    
      # build adj. matrix and plot
      m &lt;- component.adj.matrix(d$sib.data)
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram')
    
      # alter plotting style, see ?plot.phylo
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram', type='fan')
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram', 
                            type='unrooted', use.edge.length=FALSE) 
    
    }
  
}
</code></pre>


</div>