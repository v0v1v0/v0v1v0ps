<div class="container">

<table style="width: 100%;"><tr>
<td>scores_sample_univ_weighted</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted Scoring Rules for Simulated Forecast Distributions</h2>

<h3>Description</h3>

<p>Calculate weighted scores given observations and draws from univariate predictive distributions.
The weighted scoring rules that are available are the threshold-weighted CRPS, outcome-weighted CRPS, 
and conditional and censored likelihood scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">twcrps_sample(
  y,
  dat,
  a = -Inf,
  b = Inf,
  chain_func = NULL,
  w = NULL,
  show_messages = TRUE
)

owcrps_sample(
  y,
  dat,
  a = -Inf,
  b = Inf,
  weight_func = NULL,
  w = NULL,
  show_messages = TRUE
)

clogs_sample(
  y,
  dat,
  a = -Inf,
  b = Inf,
  bw = NULL,
  show_messages = FALSE,
  cens = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>vector of realized values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>vector or matrix (depending on <code>y</code>; see details)
of simulation draws from forecast distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>numeric lower bound for the indicator weight function <code>w(z) = 1{a &lt; z &lt; b}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric upper bound for the indicator weight function <code>w(z) = 1{a &lt; z &lt; b}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain_func</code></td>
<td>
<p>function used to target particular outcomes in the threshold-weighted CRPS; 
the default corresponds to the weight function <code>w(z) = 1{a &lt; z &lt; b}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>optional; vector or matrix (matching <code>dat</code>) of ensemble weights. 
Note that these weights are not used in the weighted scoring rules; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_messages</code></td>
<td>
<p>logical; display of messages (does not affect
warnings and errors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_func</code></td>
<td>
<p>function used to target particular outcomes in the outcome-weighted CRPS; 
the default corresponds to the weight function <code>w(z) = 1{a &lt; z &lt; b}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>optional; vector (matching <code>y</code>) of bandwidths for kernel density
estimation for <code>clogs_sample</code>; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens</code></td>
<td>
<p>logical; if TRUE, <code>clogs_sample</code> returns the censored
likelihood score; if FALSE, <code>clogs_sample</code> returns the conditional
likelihood score.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a vector <code>y</code> of length n, <code>dat</code> should be given as a matrix
with n rows. If <code>y</code> has length 1, then <code>dat</code> may be a vector.
</p>
<p><code>twcrps_sample</code> transforms <code>y</code> and <code>dat</code> using the chaining
function <code>chain_func</code> and then calls <code>crps_sample</code>. 
<code>owcrps_sample</code> weights <code>y</code> and <code>dat</code> using the weight function
<code>weight_func</code> and then calls <code>crps_sample</code>. 
See the documentation for <code>crps_sample</code> for further details.
</p>
<p>The default weight function used in the weighted scores is <code>w(z) = 1{a &lt; z &lt; b}</code>, 
which is equal to one if <code>z</code> is between <code>a</code> and <code>b</code>, and zero otherwise.
This weight function emphasises outcomes between <code>a</code> and <code>b</code>, and is 
commonly used in practical applications when interest is on values above a threshold
(set <code>b = Inf</code> and <code>a</code> equal to the threshold) or below a threshold 
(set <code>a = -Inf</code> and <code>b</code> equal to the threshold). 
</p>
<p>Alternative weight functions can also be employed using the <code>chain_func</code> 
and <code>weight_func</code> arguments to <code>twcrps_sample</code> and <code>owcrps_sample</code>,
respectively. Computation of the threshold-weighted CRPS for samples from a predictive distribution 
requires a chaining function rather than a weight function. This is why a chaining 
function is an input for <code>twcrps_sample</code> whereas a weight function is an 
input for <code>owcrps_sample</code>. Since <code>clogs_sample</code> requires 
kernel density estimation to approximate the forecast density, it cannot readily
be calculated for arbitrary weight functions, and is thus only available for 
the canonical weight function <code>w(z) = 1{a &lt; z &lt; b}</code>.
</p>
<p>The <code>chain_func</code> and <code>weight_func</code> arguments are functions that will 
be applied to the vector <code>y</code> and the columns of <code>dat</code>. It is assumed
that these functions are vectorised. Both functions must take a vector as an input
and output a vector of the same length, containing the weight (for <code>weight_func</code>) 
or transformed value (for <code>chain_func</code>) corresponding to each element in the 
input vector. An error will be returned if <code>weight_func</code> returns
negative values, and a warning message will appear if <code>chain_func</code> is 
not increasing. 
</p>
<p>If no custom argument is given for <code>a</code>, <code>b</code>, <code>chain_func</code> or 
<code>weight_func</code>, then both <code>twcrps_sample</code> and <code>owcrps_sample</code> 
are equivalent to the standard unweighted <code>crps_sample</code>, and 
<code>clogs_sample</code> is equivalent to <code>logs_sample</code>. 
</p>
<p>The <code>w</code> argument is also present in the unweighted scores (e.g. <code>crps_sample</code>).
<code>w</code> is used to weight the draws from the predictive distribution, and does 
not weight particular outcomes within the weighted scoring rules. This should not be
confused with the <code>weight_func</code> argument, which is used within the weighted scores.
</p>


<h3>Value</h3>

<p>Value of the score. <em>A lower score indicates a better forecast.</em>
</p>


<h3>Author(s)</h3>

<p>Sam Allen
</p>


<h3>References</h3>

<p>Allen, S. (2024): 
‘Weighted scoringRules: Emphasising Particular Outcomes when Evaluating Probabilistic Forecasts’, 
<em>Journal of Statistical Software</em>.
<a href="https://doi.org/10.18637/jss.v110.i08">doi:10.18637/jss.v110.i08</a>
</p>
<p><em>Threshold-weighted CRPS:</em>
</p>
<p>Gneiting, T. and R. Ranjan (2011): 
‘Comparing density forecasts using threshold-and quantile-weighted scoring rules’, 
<em>Journal of Business &amp; Economic Statistics</em> 29, 411-422. 
<a href="https://doi.org/10.1198/jbes.2010.08110">doi:10.1198/jbes.2010.08110</a>
</p>
<p>Allen, S., Ginsbourger, D. and J. Ziegel (2023): 
‘Evaluating forecasts for high-impact events using transformed kernel scores’, 
<em>SIAM/ASA Journal on Uncertainty Quantification</em> 11, 906-940.
<a href="https://doi.org/10.1137/22M1532184">doi:10.1137/22M1532184</a>
</p>
<p><em>Outcome-weighted CRPS:</em>
</p>
<p>Holzmann, H. and B. Klar (2017):
‘Focusing on regions of interest in forecast evaluation’,
<em>Annals of Applied Statistics</em> 11, 2404-2431. 
<a href="https://doi.org/10.1214/17-AOAS1088">doi:10.1214/17-AOAS1088</a>
</p>
<p><em>Conditional and censored likelihood scores:</em>
</p>
<p>Diks, C., Panchenko, V. and D. Van Dijk (2011):
‘Likelihood-based scoring rules for comparing density forecasts in tails’,
<em>Journal of Econometrics</em> 163, 215-230.
<a href="https://doi.org/10.1016/j.jeconom.2011.04.001">doi:10.1016/j.jeconom.2011.04.001</a>
</p>


<h3>See Also</h3>

<p>scores_sample_univ for standard (unweighted) scores based on simulated forecast distributions. scores_sample_multiv_weighted for weighted scores based on simulated multivariate forecast distributions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

y &lt;- rnorm(10)
sample_fc &lt;- matrix(rnorm(100), nrow = 10)

crps_sample(y = y, dat = sample_fc)
twcrps_sample(y = y, dat = sample_fc)
owcrps_sample(y = y, dat = sample_fc)

logs_sample(y = y, dat = sample_fc)
clogs_sample(y = y, dat = sample_fc)
clogs_sample(y = y, dat = sample_fc, cens = FALSE)

# emphasise outcomes above 0
twcrps_sample(y = y, dat = sample_fc, a = 0)
owcrps_sample(y = y, dat = sample_fc, a = 0)
clogs_sample(y = y, dat = sample_fc, a = 0)
clogs_sample(y = y, dat = sample_fc, a = 0, cens = FALSE)

# emphasise outcomes below 0
twcrps_sample(y = y, dat = sample_fc, b = 0)
owcrps_sample(y = y, dat = sample_fc, b = 0)
clogs_sample(y = y, dat = sample_fc, b = 0) 

# emphasise outcomes between -1 and 1
twcrps_sample(y = y, dat = sample_fc, a = -1, b = 1)
owcrps_sample(y = y, dat = sample_fc, a = -1, b = 1)
clogs_sample(y = y, dat = sample_fc, a = -1, b = 1)


# a must be smaller than b 
twcrps_sample(y = y, dat = sample_fc, a = 1, b = -1) # error
owcrps_sample(y = y, dat = sample_fc, a = 0, b = 0) # error
clogs_sample(y = y, dat = sample_fc, a = 10, b = 9) # error

# a and b must be single numeric values (not vectors)
twcrps_sample(y = y, dat = sample_fc, a = rnorm(10)) # error


# the owCRPS is not well-defined if none of dat are between a and b
y &lt;- rnorm(10)
sample_fc &lt;- matrix(runif(100, -5, 1), nrow = 10)
owcrps_sample(y = y, dat = sample_fc, a = 1)
# the twCRPS is zero if none of y and dat are between a and b
twcrps_sample(y = y, dat = sample_fc, a = 1) 


# alternative custom weight and chaining functions can also be used

# Example 1: a Gaussian weight function with location mu and scale sigma
mu &lt;- 0
sigma &lt;- 0.5
weight_func &lt;- function(x) pnorm(x, mu, sigma)
# or weight_func &lt;- get_weight_func("norm_cdf", mu, sigma)
# a corresponding chaining function is
chain_func &lt;- function(x) (x - mu)*pnorm(x, mu, sigma) + (sigma^2)*dnorm(x, mu, sigma)
# or chain_func &lt;- get_weight_func("norm_cdf", mu, sigma, weight = FALSE)

x &lt;- seq(-2, 2, 0.01)
plot(x, weight_func(x), type = "l") # positive outcomes are given higher weight
plot(x, chain_func(x), type = "l") 

owcrps_sample(y = y, dat = sample_fc, a = mu)
owcrps_sample(y = y, dat = sample_fc, weight_func = weight_func)
twcrps_sample(y = y, dat = sample_fc, a = mu)
twcrps_sample(y = y, dat = sample_fc, chain_func = chain_func)


# Example 2: a sigmoid (or logistic) weight function with location mu and scale sigma
weight_func &lt;- function(x) plogis(x, mu, sigma)
# or weight_func &lt;- get_weight_func("logis_cdf", mu, sigma)
chain_func &lt;- function(x) sigma*log(exp((x - mu)/sigma) + 1)
# or chain_func &lt;- get_weight_func("logis_cdf", mu, sigma, weight = FALSE)

x &lt;- seq(-2, 2, 0.01)
plot(x, weight_func(x), type = "l") # positive outcomes are given higher weight
plot(x, chain_func(x), type = "l") 

owcrps_sample(y = y, dat = sample_fc, a = mu)
owcrps_sample(y = y, dat = sample_fc, weight_func = weight_func)
twcrps_sample(y = y, dat = sample_fc, a = mu)
twcrps_sample(y = y, dat = sample_fc, chain_func = chain_func)


# Example 3: the weight function w(z) = 1{z &lt; a or z &gt; b}
a &lt;- -1
b &lt;- 1
weight_func &lt;- function(x) as.numeric(x &lt; a | x &gt; b)
chain_func &lt;- function(x) (x &lt; a)*(x - a) + (x &gt; b)*(x - b) + a

x &lt;- seq(-2, 2, 0.01)
plot(x, weight_func(x), type = "l")
plot(x, chain_func(x), type = "l")

owcrps_sample(y = y, dat = sample_fc, weight_func = weight_func)
twcrps_sample(y = y, dat = sample_fc, chain_func = chain_func)
twcrps_sample(y = y, dat = sample_fc, b = -1) + twcrps_sample(y = y, dat = sample_fc, a = 1)
crps_sample(y = y, dat = sample_fc) - twcrps_sample(y = y, dat = sample_fc, a = -1, b = 1)

## End(Not run)

</code></pre>


</div>