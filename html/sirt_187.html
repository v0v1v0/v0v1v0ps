<div class="container">

<table style="width: 100%;"><tr>
<td>linking.haebara</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Haebara Linking of the 2PL Model for Multiple Studies
</h2>

<h3>Description</h3>

<p>The function <code>linking.haebara</code> is a generalization of Haebara linking
of the 2PL model to multiple groups (or multiple studies; see Battauz, 2017,
for a similar approach). The optimization estimates transformation parameters for
means and standard deviations of the groups and joint item parameters.
The function allows two different distance functions <code>dist="L2"</code> and
<code>dist="L1"</code> where the latter is a robustified version of
Haebara linking (see Details; He, Cui, &amp; Osterlind, 2015; He &amp; Cui, 2020;
Hu, Rogers, &amp; Vukmirovic, 2008).
</p>


<h3>Usage</h3>

<pre><code class="language-R">linking.haebara(itempars, dist="L2", theta=seq(-4,4, length=61),
        optimizer="optim", center=FALSE, eps=1e-3, par_init=NULL, use_rcpp=TRUE,
        pow=2, use_der=TRUE, ...)

## S3 method for class 'linking.haebara'
summary(object, digits=3, file=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>itempars</code></td>
<td>

<p>A data frame with four or five columns. The first four columns contain
in the order: study name, item name, <code class="reqn">a</code> parameter, <code class="reqn">b</code> parameter.
The fifth column is an optional weight for every item and every study. See
<code>linking.haberman</code> for a function which uses the same argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Distance function. Options are <code>"L2"</code> for squared loss and
<code>"L1"</code> for absolute value loss.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Grid of theta points for 2PL item response functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>Name of the optimizer chosen for alignment. Options are
<code>"optim"</code> (using <code>stats::optim</code>)
or <code>"nlminb"</code> (using <code>stats::nlminb</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Logical indicating whether means and standard deviations should
be centered after estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Small value for smooth approximation of the absolute value function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_init</code></td>
<td>
<p>Optional vector of initial parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_rcpp</code></td>
<td>
<p>Logical indicating whether <span class="pkg">Rcpp</span> is used for computation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pow</code></td>
<td>
<p>Power for method <code>dist="Lq"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_der</code></td>
<td>
<p>Logical indicating whether analytical derivative should be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>linking.haabara</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits after decimals for rounding in <code>summary</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name if <code>summary</code> should be sunk into a file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code class="reqn">t=1,\ldots,T</code> studies, item difficulties <code class="reqn">b_{it}</code> and
item slopes <code class="reqn">a_{it}</code> are available. The 2PL item response functions are given by
</p>
<p style="text-align: center;"><code class="reqn"> logit P(X_{pi}=1| \theta_p )=a_i ( \theta_p - b_i ) </code>
</p>

<p>Haebara linking compares the observed item response functions <code class="reqn">P_{it}</code>
based on the equation for the logits <code class="reqn">a_{it}(\theta - b_{it})</code> and the expected
item response functions <code class="reqn">P_{it}^\ast</code> based on the equation for the logits
<code class="reqn">a_i^\ast \sigma_t ( \theta - ( b_i - \mu_t)/\sigma_t )</code> where the joint
item parameters <code class="reqn">a_i</code> and <code class="reqn">b_i</code> and means <code class="reqn">\mu_t</code> and standard
deviations <code class="reqn">\sigma_t</code> are estimated.
</p>
<p>Two loss functions are implemented. The quadratic loss of Haebara linking
(<code>dist="L2"</code>) minimizes
</p>
<p style="text-align: center;"><code class="reqn">f_{opt, L2}=\sum_t \sum_i \int ( P_{it} (\theta ) - P_{it}^\ast (\theta ) )^2 w(\theta)</code>
</p>

<p>was originally proposed by Haebara. A robustified version (<code>dist="L1"</code>)
uses the optimization function (He et al., 2015)
</p>
<p style="text-align: center;"><code class="reqn">f_{opt, L1}=\sum_t \sum_i \int | P_{it} (\theta ) - P_{it}^\ast (\theta ) |  w(\theta)</code>
</p>

<p>As a further generalization, the follwing distance function (<code>dist="Lp"</code>)
can be minimized:
</p>
<p style="text-align: center;"><code class="reqn">f_{opt, Lp}=\sum_t \sum_i \int | P_{it} (\theta ) - P_{it}^\ast (\theta ) |^p  w(\theta)</code>
</p>



<h3>Value</h3>

<p>A list with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>Estimated means and standard deviations (transformation parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Estimated joint item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.orig</code></td>
<td>
<p>Original <code class="reqn">a_{it}</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.orig</code></td>
<td>
<p>Original <code class="reqn">b_{it}</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.resid</code></td>
<td>
<p>Residual <code class="reqn">a_{it}</code> parameters (DIF parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.resid</code></td>
<td>
<p>Residual <code class="reqn">b_{it}</code> parameters (DIF parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res_optim</code></td>
<td>
<p>Value of optimization routine</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Battauz, M. (2017). Multiple equating of separate IRT calibrations.
<em>Psychometrika, 82</em>, 610-636.
<a href="https://doi.org/10.1007/s11336-016-9517-x">doi:10.1007/s11336-016-9517-x</a>
</p>
<p>He, Y., Cui, Z., &amp; Osterlind, S. J. (2015). New robust scale transformation methods
in the presence of outlying common items. <em>Applied Psychological Measurement, 39</em>(8),
613-626.
<a href="https://doi.org/10.1177/0146621615587003">doi:10.1177/0146621615587003</a>
</p>
<p>He, Y., &amp; Cui, Z. (2020). Evaluating robust scale transformation methods with multiple
outlying common items under IRT true score equating.
<em>Applied Psychological Measurement, 44</em>(4), 296-310.
<a href="https://doi.org/10.1177/0146621619886050">doi:10.1177/0146621619886050</a>
</p>
<p>Hu, H., Rogers, W. T., &amp; Vukmirovic, Z. (2008). Investigation of IRT-based equating
methods in the presence of outlier common items. <em>Applied Psychological Measurement,
32</em>(4), 311-333.
<a href="https://doi.org/10.1177/0146621606292215">doi:10.1177/0146621606292215</a>
</p>


<h3>See Also</h3>

<p>See <code>invariance.alignment</code> and <code>linking.haberman</code>
for alternative linking methods in the <span class="pkg">sirt</span> package. See also
<code>TAM::tam.linking</code> in the <span class="pkg">TAM</span> package for more linking functionality
and the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages <span class="pkg">plink</span>, <span class="pkg">equateIRT</span>, <span class="pkg">equateMultiple</span> and
<span class="pkg">SNSequate</span>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: Robust linking methods in the presence of outliers
#############################################################################

#** simulate data
I &lt;- 10
a &lt;- seq(.9, 1.1, len=I)
b &lt;- seq(-2, 2, len=I)

#- define item parameters
item_names &lt;- paste0("I",100+1:I)
# th=SIG*TH+MU=&gt; logit(p)=a*(SIG*TH+MU-b)=a*SIG*(TH-(-MU)/SIG-b/SIG)
d1 &lt;- data.frame( study="S1", item=item_names, a=a, b=b )
mu &lt;- .5; sigma &lt;- 1.3
d2 &lt;- data.frame( study="S2", item=item_names, a=a*sigma, b=(b-mu)/sigma )
mu &lt;- -.3; sigma &lt;- .7
d3 &lt;- data.frame( study="S3", item=item_names, a=a*sigma, b=(b-mu)/sigma )

#- define DIF effect
# dif &lt;- 0  # no DIF effects
dif &lt;- 1
d2[4,"a"] &lt;- d2[4,"a"] * (1-.8*dif)
d3[5,"b"] &lt;- d3[5,"b"] - 2*dif
itempars &lt;- rbind(d1, d2, d3)

#* Haebara linking non-robust
mod1 &lt;- sirt::linking.haebara( itempars, dist="L2", control=list(trace=2) )
summary(mod1)

#* Haebara linking robust
mod2 &lt;- sirt::linking.haebara( itempars, dist="L1", control=list(trace=2) )
summary(mod2)

#* using initial parameter estimates
par_init &lt;- mod1$res_optim$par
mod2b &lt;- sirt::linking.haebara( itempars, dist="L1", par_init=par_init)
summary(mod2b)

#* power p=.25
mod2c &lt;- sirt::linking.haebara( itempars, dist="Lp", pow=.25, par_init=par_init)
summary(mod2c)

#* Haberman linking non-robust
mod3 &lt;- sirt::linking.haberman(itempars)
summary(mod3)

#* Haberman linking robust
mod4 &lt;- sirt::linking.haberman(itempars, estimation="BSQ", a_trim=.25, b_trim=.5)
summary(mod4)

#* compare transformation parameters (means and standard deviations)
mod1$pars
mod2$pars
mod3$transf.personpars
mod4$transf.personpars

## End(Not run)
</code></pre>


</div>