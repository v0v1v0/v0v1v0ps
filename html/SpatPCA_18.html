<div class="container">

<table style="width: 100%;"><tr>
<td>spatpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized PCA for spatial data</h2>

<h3>Description</h3>

<p>Produce spatial dominant patterns and spatial predictions at the designated locations according to the specified tuning parameters or the selected tuning parameters by the M-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatpca(
  x,
  Y,
  M = 5,
  K = NULL,
  is_K_selected = ifelse(is.null(K), TRUE, FALSE),
  tau1 = NULL,
  tau2 = NULL,
  gamma = NULL,
  is_Y_detrended = FALSE,
  maxit = 100,
  thr = 1e-04,
  num_cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Location matrix (<code class="reqn">p \times d</code>). Each row is a location. <code class="reqn">d</code> is the dimension of locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Data matrix (<code class="reqn">n \times p</code>) stores the values at <code class="reqn">p</code> locations with sample size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Optional number of folds for cross validation; default is 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Optional user-supplied number of eigenfunctions; default is NULL. If K is NULL or is_K_selected is TRUE, K is selected automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_K_selected</code></td>
<td>
<p>If TRUE, K is selected automatically; otherwise, is_K_selected is set to be user-supplied K. Default depends on user-supplied K.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative smoothness parameter sequence. If NULL, 10 tau1 values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative sparseness parameter sequence. If NULL, none of tau2 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Optional user-supplied numeric vector of a non-negative tuning parameter sequence. If NULL, 10 values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_Y_detrended</code></td>
<td>
<p>If TRUE, center the columns of Y. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations. Default value is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr</code></td>
<td>
<p>Threshold for convergence. Default value is <code class="reqn">10^{-4}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_cores</code></td>
<td>
<p>Number of cores used to parallel computing. Default value is NULL (See <code>RcppParallel::defaultNumThreads()</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An ADMM form of the proposed objective function is written as
</p>
<p style="text-align: center;"><code class="reqn">\min_{\mathbf{\Phi}} \|\mathbf{Y}-\mathbf{Y}\mathbf{\Phi}\mathbf{\Phi}'\|^2_F +\tau_1\mbox{tr}(\mathbf{\Phi}^T\mathbf{\Omega}\mathbf{\Phi})+\tau_2\sum_{k=1}^K\sum_{j=1}^p |\phi_{jk}|,</code>
</p>

<p><code class="reqn">\mbox{subject to $ \mathbf{\Phi}^T\mathbf{\Phi}=\mathbf{I}_K$,}</code> where <code class="reqn">\mathbf{Y}</code> is a data matrix, <code class="reqn">{\mathbf{\Omega}}</code> is a smoothness matrix, and <code class="reqn">\mathbf{\Phi}=\{\phi_{jk}\}</code>.
</p>


<h3>Value</h3>

<p>A list of objects including
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eigenfn</code></td>
<td>
<p>Estimated eigenfunctions at the new locations, x_new.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected_K</code></td>
<td>
<p>Selected K based on CV. Execute the algorithm when <code>is_K_selected</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected_tau1</code></td>
<td>
<p>Selected tau1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected_tau2</code></td>
<td>
<p>Selected tau2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected_gamma</code></td>
<td>
<p>Selected gamma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_score_tau1</code></td>
<td>
<p>cv scores for tau1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_score_tau2</code></td>
<td>
<p>cv scores for tau2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_score_gamma</code></td>
<td>
<p>cv scores for gamma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1</code></td>
<td>
<p>Sequence of tau1-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>
<p>Sequence of tau2-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Sequence of gamma-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detrended_Y</code></td>
<td>
<p>If is_Y_detrended is TRUE, detrended_Y means Y is detrended; else, detrended_Y is equal to Y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaled_x</code></td>
<td>
<p>Input location matrix. Only scale when it is one-dimensional</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Wen-Ting Wang and Hsin-Cheng Huang
</p>


<h3>References</h3>

<p>Wang, W.-T. and Huang, H.-C. (2017). Regularized principal component analysis for spatial data. <em>Journal of Computational and Graphical Statistics</em> <b>26</b> 14-25.
</p>


<h3>See Also</h3>

<p>predict
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The following examples only use two threads for parallel computing.
## 1D: regular locations
x_1D &lt;- as.matrix(seq(-5, 5, length = 50))
Phi_1D &lt;- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_1D) + matrix(rnorm(n = 100 * 50), 100, 50)
cv_1D &lt;- spatpca(x = x_1D, Y = Y_1D, num_cores = 2)
plot(x_1D, cv_1D$eigenfn[, 1], type = "l", main = "1st eigenfunction")
lines(x_1D, svd(Y_1D)$v[, 1], col = "red")
legend("topleft", c("SpatPCA", "PCA"), lty = 1:1, col = 1:2)


## 2D: Daily 8-hour ozone averages for sites in the Midwest (USA)
library(fields)
library(pracma)
library(maps)
data(ozone2)
x &lt;- ozone2$lon.lat
Y &lt;- ozone2$y
date &lt;- as.Date(ozone2$date, format = "%y%m%d")
rmna &lt;- !colSums(is.na(Y))
YY &lt;- matrix(Y[, rmna], nrow = nrow(Y))
YY &lt;- detrend(YY, "linear")
xx &lt;- x[rmna, ]
cv &lt;- spatpca(x = xx, Y = YY)
quilt.plot(xx, cv$eigenfn[, 1])
map("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), add = TRUE)
map.text("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), cex = 2, add = TRUE)
plot(date, YY %*% cv$eigenfn[, 1], type = "l", ylab = "1st Principal Component")
### new loactions
new_p &lt;- 200
x_lon &lt;- seq(min(xx[, 1]), max(xx[, 1]), length = new_p)
x_lat &lt;- seq(min(xx[, 2]), max(xx[, 2]), length = new_p)
xx_new &lt;- as.matrix(expand.grid(x = x_lon, y = x_lat))
eof &lt;- spatpca(x = xx,
               Y = YY,
               K = cv$selected_K,
               tau1 = cv$selected_tau1,
               tau2 = cv$selected_tau2)
predicted_eof &lt;- predictEigenfunction(eof, xx_new)
quilt.plot(xx_new,
           predicted_eof[,1],
           nx = new_p,
           ny = new_p,
           xlab = "lon.",
           ylab = "lat.")
map("state", xlim = range(x_lon), ylim = range(x_lat), add = TRUE)
map.text("state", xlim = range(x_lon), ylim = range(x_lat), cex = 2, add = TRUE)
## 3D: regular locations
p &lt;- 10
x &lt;- y &lt;- z &lt;- as.matrix(seq(-5, 5, length = p))
d &lt;- expand.grid(x, y, z)
Phi_3D &lt;- rowSums(exp(-d^2)) / norm(as.matrix(rowSums(exp(-d^2))), "F")
Y_3D &lt;- rnorm(n = 100, sd = 3) %*% t(Phi_3D) + matrix(rnorm(n = 100 * p^3), 100, p^3)
cv_3D &lt;- spatpca(x = d, Y = Y_3D, tau2 = seq(0, 1000, length = 10))
library(plot3D)
library(RColorBrewer)
cols &lt;- colorRampPalette(brewer.pal(9, "Blues"))(p)
isosurf3D(x, y, z,
         colvar = array(cv_3D$eigenfn[, 1], c(p, p, p)),
         level= seq(min(cv_3D$eigenfn[, 1]), max(cv_3D$eigenfn[, 1]), length = p),
         ticktype = "detailed",
         colkey = list(side = 1),
         col = cols)

</code></pre>


</div>