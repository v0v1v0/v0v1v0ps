<div class="container">

<table style="width: 100%;"><tr>
<td>Clustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Consensus clustering</h2>

<h3>Description</h3>

<p>Performs consensus (weighted) clustering. The underlying algorithm (e.g.
hierarchical clustering) is run with different number of clusters <code>nc</code>.
In consensus weighed clustering, weighted distances are calculated using the
<code>cosa2</code> algorithm with different penalty parameters
<code>Lambda</code>. The hyper-parameters are calibrated by maximisation of the
consensus score.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Clustering(
  xdata,
  nc = NULL,
  eps = NULL,
  Lambda = NULL,
  K = 100,
  tau = 0.5,
  seed = 1,
  n_cat = 3,
  implementation = HierarchicalClustering,
  scale = TRUE,
  linkage = "complete",
  row = TRUE,
  optimisation = c("grid_search", "nloptr"),
  n_cores = 1,
  output_data = FALSE,
  verbose = TRUE,
  beep = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>data matrix with observations as rows and variables as columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>matrix of parameters controlling the number of clusters in the
underlying algorithm specified in <code>implementation</code>. If <code>nc</code> is
not provided, it is set to <code>seq(1, tau*nrow(xdata))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>radius in density-based clustering, see
<code>dbscan</code>. Only used if
<code>implementation=DBSCANClustering</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>vector of penalty parameters for weighted distance calculation.
Only used for distance-based clustering, including for example
<code>implementation=HierarchicalClustering</code>,
<code>implementation=PAMClustering</code>, or
<code>implementation=DBSCANClustering</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of resampling iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>subsample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>value of the seed to initialise the random number generator and
ensure reproducibility of the results (see <code>set.seed</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cat</code></td>
<td>
<p>computation options for the stability score. Default is
<code>NULL</code> to use the score based on a z test. Other possible values are 2
or 3 to use the score based on the negative log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implementation</code></td>
<td>
<p>function to use for clustering. Possible functions
include <code>HierarchicalClustering</code> (hierarchical clustering),
<code>PAMClustering</code> (Partitioning Around Medoids),
<code>KMeansClustering</code> (k-means) and <code>GMMClustering</code>
(Gaussian Mixture Models). Alternatively, a user-defined function taking
<code>xdata</code> and <code>Lambda</code> as arguments and returning a binary and
symmetric matrix for which diagonal elements are equal to zero can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical indicating if the data should be scaled to ensure that
all variables contribute equally to the clustering of the observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linkage</code></td>
<td>
<p>character string indicating the type of linkage used in
hierarchical clustering to define the stable clusters. Possible values
include <code>"complete"</code>, <code>"single"</code> and <code>"average"</code> (see
argument <code>"method"</code> in <code>hclust</code> for a full list).
Only used if <code>implementation=HierarchicalClustering</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row</code></td>
<td>
<p>logical indicating if rows (if <code>row=TRUE</code>) or columns (if
<code>row=FALSE</code>) contain the items to cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimisation</code></td>
<td>
<p>character string indicating the type of optimisation
method to calibrate the regularisation parameter (only used if
<code>Lambda</code> is not <code>NULL</code>). With <code>optimisation="grid_search"</code>
(the default), all values in <code>Lambda</code> are visited.
Alternatively, optimisation algorithms implemented in
<code>nloptr</code> can be used with <code>optimisation="nloptr"</code>.
By default, we use <code>"algorithm"="NLOPT_GN_DIRECT_L"</code>,
<code>"xtol_abs"=0.1</code>, <code>"ftol_abs"=0.1</code> and
<code>"maxeval"</code> defined as <code>length(Lambda)</code>. These values can be
changed by providing the argument <code>opts</code> (see
<code>nloptr</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>number of cores to use for parallel computing (see argument
<code>workers</code> in <code>multisession</code>). Using
<code>n_cores&gt;1</code> is only supported with <code>optimisation="grid_search"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_data</code></td>
<td>
<p>logical indicating if the input datasets <code>xdata</code> and
<code>ydata</code> should be included in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical indicating if a loading bar and messages should be
printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beep</code></td>
<td>
<p>sound indicating the end of the run. Possible values are:
<code>NULL</code> (no sound) or an integer between 1 and 11 (see argument
<code>sound</code> in <code>beep</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to the functions provided in
<code>implementation</code> or <code>resampling</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In consensus clustering, a clustering algorithm is applied on
<code>K</code> subsamples of the observations with different numbers of clusters
provided in <code>nc</code>. If <code>row=TRUE</code> (the default), the observations
(rows) are the items to cluster. If <code>row=FALSE</code>, the variables
(columns) are the items to cluster. For a given number of clusters, the
consensus matrix <code>coprop</code> stores the proportion of iterations where
two items were in the same estimated cluster, out of all iterations where
both items were drawn in the subsample.
</p>
<p>Stable cluster membership is obtained by applying a distance-based
clustering method using <code>(1-coprop)</code> as distance (see
Clusters).
</p>
<p>These parameters can be calibrated by maximisation of a stability score
(see <code>ConsensusScore</code>) calculated under the null hypothesis of
equiprobability of co-membership.
</p>
<p>It is strongly recommended to examine the calibration plot (see
<code>CalibrationPlot</code>) to check that there is a clear maximum. The
absence of a clear maximum suggests that the clustering is not stable,
consensus clustering outputs should not be trusted in that case.
</p>
<p>To ensure reproducibility of the results, the starting number of the random
number generator is set to <code>seed</code>.
</p>
<p>For parallelisation, stability selection with different sets of parameters
can be run on <code>n_cores</code> cores. Using <code>n_cores &gt; 1</code> creates a
<code>multisession</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>clustering</code>. A list with: </p>
<table>
<tr style="vertical-align: top;">
<td><code>Sc</code></td>
<td>
<p>a matrix
of the best stability scores for different (sets of) parameters controlling
the number of clusters and penalisation of attribute weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>a
matrix of numbers of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>a matrix of regularisation
parameters for attribute weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>a matrix of the average number
of selected attributes by the underlying algorithm with different
regularisation parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coprop</code></td>
<td>
<p>an array of consensus matrices.
Rows and columns correspond to items. Indices along the third dimension
correspond to different parameters controlling the number of clusters and
penalisation of attribute weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selprop</code></td>
<td>
<p>an array of selection
proportions. Columns correspond to attributes. Rows correspond to different
parameters controlling the number of clusters and penalisation of attribute
weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a list with <code>type="clustering"</code> and values
used for arguments <code>implementation</code>, <code>linkage</code>, and
<code>resampling</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a list with values used for arguments
<code>K</code>, <code>tau</code>, <code>pk</code>, <code>n</code> (number of observations in
<code>xdata</code>), and <code>seed</code>.</p>
</td>
</tr>
</table>
<p> The rows of <code>Sc</code>, <code>nc</code>,
<code>Lambda</code>, <code>Q</code>, <code>selprop</code> and indices along the third
dimension of <code>coprop</code> are ordered in the same way and correspond to
parameter values stored in <code>nc</code> and <code>Lambda</code>.
</p>


<h3>References</h3>

<p>Bodinier B, Vuckovic D, Rodrigues S, Filippi S, Chiquet J, Chadeau-Hyam M (2023).
“Automated calibration of consensus weighted distance-based clustering approaches using sharp.”
<em>Bioinformatics</em>, btad635.
ISSN 1367-4811, <a href="https://doi.org/10.1093/bioinformatics/btad635">doi:10.1093/bioinformatics/btad635</a>, https://academic.oup.com/bioinformatics/advance-article-pdf/doi/10.1093/bioinformatics/btad635/52191190/btad635.pdf.
</p>
<p>Kampert MM, Meulman JJ, Friedman JH (2017).
“rCOSA: A Software Package for Clustering Objects on Subsets of Attributes.”
<em>Journal of Classification</em>, <b>34</b>(3), 514–547.
<a href="https://doi.org/10.1007/s00357-017-9240-z">doi:10.1007/s00357-017-9240-z</a>.
</p>
<p>Friedman JH, Meulman JJ (2004).
“Clustering objects on subsets of attributes (with discussion).”
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>66</b>(4), 815-849.
<a href="https://doi.org/10.1111/j.1467-9868.2004.02059.x">doi:10.1111/j.1467-9868.2004.02059.x</a>, https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/j.1467-9868.2004.02059.x, <a href="https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-9868.2004.02059.x">https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-9868.2004.02059.x</a>.
</p>
<p>Monti S, Tamayo P, Mesirov J, Golub T (2003).
“Consensus Clustering: A Resampling-Based Method for Class Discovery and Visualization of Gene Expression Microarray Data.”
<em>Machine Learning</em>, <b>52</b>(1), 91–118.
<a href="https://doi.org/10.1023/A%3A1023949509487">doi:10.1023/A:1023949509487</a>.
</p>


<h3>See Also</h3>

<p><code>Resample</code>, <code>ConsensusScore</code>,
<code>HierarchicalClustering</code>, <code>PAMClustering</code>,
<code>KMeansClustering</code>, <code>GMMClustering</code>
</p>
<p>Other stability functions: 
<code>BiSelection()</code>,
<code>GraphicalModel()</code>,
<code>StructuralModel()</code>,
<code>VariableSelection()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Consensus clustering
set.seed(1)
simul &lt;- SimulateClustering(
  n = c(30, 30, 30), nu_xc = 1, ev_xc = 0.5
)
stab &lt;- Clustering(xdata = simul$data)
print(stab)
CalibrationPlot(stab)
summary(stab)
Clusters(stab)
plot(stab)

# Consensus weighted clustering
if (requireNamespace("rCOSA", quietly = TRUE)) {
  set.seed(1)
  simul &lt;- SimulateClustering(
    n = c(30, 30, 30), pk = 20,
    theta_xc = c(rep(1, 10), rep(0, 10)),
    ev_xc = 0.9
  )
  stab &lt;- Clustering(
    xdata = simul$data,
    Lambda = LambdaSequence(lmin = 0.1, lmax = 10, cardinal = 10),
    noit = 20, niter = 10
  )
  print(stab)
  CalibrationPlot(stab)
  summary(stab)
  Clusters(stab)
  plot(stab)
  WeightBoxplot(stab)
}

</code></pre>


</div>