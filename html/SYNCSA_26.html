<div class="container">

<table style="width: 100%;"><tr>
<td>cor.matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to obtain the correlation between two matrices and partial matrix
correlation between three matrices.</h2>

<h3>Description</h3>

<p>The functions cor.matrix and cor.matrix.partial are similar the function
<code>mantel</code> and <code>mantel.partial</code>, although the significance
of the statistics is evaluated differently from Mantel. The functions pro.matrix
and pro.matrix.partial use symmetric Procrustes as a measure of concordance between
data sets. The function cor.mantel is similar to the function <code>mantel</code>, but
allows the use of a set of predefined permutation. For more details, see
<code>syncsa</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cor.matrix(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  permute.my2 = FALSE,
  method = "pearson",
  dist = "euclidean",
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.mantel(
  dist.x,
  dist.y,
  method = "pearson",
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.matrix.partial(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  mz1 = NULL,
  mz2 = NULL,
  z,
  method = "pearson",
  dist = "euclidean",
  permute.my2 = FALSE,
  permute.mz2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  norm.z = FALSE,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.matrix2(
  mx1,
  mx2,
  x,
  y,
  method = "pearson",
  dist = "euclidean",
  put.together = NULL,
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.procrustes(
  x,
  y,
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  permute.my2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix.partial(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  mz1 = NULL,
  mz2 = NULL,
  z,
  permute.my2 = FALSE,
  permute.mz2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  norm.z = FALSE,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix2(
  mx1,
  mx2,
  x,
  y,
  put.together = NULL,
  permutations = 999,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mx1</code></td>
<td>
<p>Matrix that multiplied by mx2 results in the matrix x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mx2</code></td>
<td>
<p>Matrix that when multiplied by mx1 results in the matrix x. See
'details' below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix that will be correlated with the matrix y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my1</code></td>
<td>
<p>Matrix that multiplied by my2 results in the matrix y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my2</code></td>
<td>
<p>Matrix that when multiplied by my1 results in the matrix y. See
'details' below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Matrix that will be correlated with the matrix x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute.my2</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if realize
parallel permutation in matrix my2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Correlation method, as accepted by cor: "pearson", "spearman"
or "kendall".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Dissimilarity index, as accepted by vegdist: "manhattan",
"euclidean", "canberra", "bray", "kulczynski", "jaccard", "gower",
"altGower", "morisita", "horn", "mountford", "raup" , "binomial" or "chao".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permutations</code></td>
<td>
<p>Number of permutations in assessing significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if x is standardized
within variables (Default norm = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.y</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if y is standardized
within variables (Default norm = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>Argument to specify restricting permutations within species
groups (Default strata = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if pairwise
deletion of missing observations when computing dissimilarities (Default
na.rm = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seqpermutation</code></td>
<td>
<p>A set of predefined permutation, with the same dimensions of
permutations (Default seqpermutation = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Number of parallel processes.  Tip: use parallel::detectCores() (Default parallel = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newClusters</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if make new parallel
processes or use predefined socket cluster. Only if parallel is different of NULL (Default newClusters = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CL</code></td>
<td>
<p>A predefined socket cluster done with parallel package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.x</code></td>
<td>
<p>Dissimilarity matrices of class dist.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.y</code></td>
<td>
<p>Dissimilarity matrices of class dist.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mz1</code></td>
<td>
<p>Matrix that multiplied by mz2 results in the matrix z.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mz2</code></td>
<td>
<p>Matrix that when multiplied by mz1 results in the matrix z. See
'details' below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Matrix whose effect will be removed from the correlation between x
and y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute.mz2</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if realize
parallel permutation in matrix mz2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.z</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if z is standardized
within variables (Default norm = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>put.together</code></td>
<td>
<p>List to specify group of traits. Each group specify receive the
same weight that one trait outside any group, in the way each group is considered
as unique trait (Default put.together = NULL). This argument must be a list, see
examples in <code>syncsa</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The null model is based on permutations in the matrix mx2, typically the
matrices B, U and Q, except in the function cor.mantel when the permutations
are done in one of distance matrix.
</p>
<p>Null model described by Pillar et al. (2009) and Pillar &amp; Duarte (2010). For
more details on the matrices and the null model, see <code>syncsa</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Obs</code></td>
<td>
<p>Correlation between matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Significance
level based on permutations.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code>syncsa</code>, <code>organize.syncsa</code>, <code>mantel</code>,
<code>procrustes</code>
</p>


</div>