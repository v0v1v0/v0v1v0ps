<div class="container">

<table style="width: 100%;"><tr>
<td>CV</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Coefficient of Variation </h2>

<h3>Description</h3>

<p>The coefficient of variation of effective sampling area predicts the
bias in estimated density (Efford and Mowat 2014). These functions
assist its calculation from fitted finite mixture models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
CV(x, p, na.rm = FALSE)
CVa0(object, ...)
CVa(object, sessnum = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of numeric values </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of class probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical; if TRUE missing values are dropped from x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>fitted secr finite mixture model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sessnum</code></td>
<td>
<p>integer sequence number of session to analyse </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to predict.secr (e.g.,
<code>newdata</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>CV</code> computes the coefficient of variation of <code>x</code>. If
<code>p</code> is provided then the distribution is assumed to be
discrete, with support <code>x</code> and class membership probabilities
<code>p</code> (scaled automatically to sum to 1.0).
</p>
<p><code>CVa</code> computes CV(<code class="reqn">a</code>) where <code class="reqn">a</code> is the effective
sampling area of Borchers and Efford (2008).
</p>
<p><code>CVa0</code> computes CV(a0) where a0 is the single-detector sampling
area defined as <code class="reqn">a_0 = 2 \pi \lambda_0 \sigma^2</code> (Efford and Mowat 2014); a0 is a convenient
surrogate for <em>a</em>, the effective sampling area. CV(a0) uses
either the fitted MLE of a0 (if the a0 parameterization has been
used), or a0 computed from the estimates of lambda0 and sigma.
</p>
<p><code>CVa</code> and <code>CVa0</code> do not work for models with individual
covariates.
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Note</h3>

<p>Do not confuse the function CVa with the estimated relative standard
error of the estimate of a from <code>derived</code>, also labelled CVa
in the output. The relative standard error RSE is often labelled CV
in the literature on capture–recapture, but this can cause unnecessary 
confusion. See also <code>RSE</code>.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture–recapture studies. <em>Biometrics</em>
<b>64</b>, 377–385.
</p>
<p>Efford, M. G. and Mowat, G. (2014) Compensatory heterogeneity in
capture–recapture data. <em>Ecology</em> <b>95</b>, 1341–1348.  
</p>


<h3>See Also</h3>

<p><code>CVpdot</code>, 
<code>derived</code>, 
<code>details</code>, 
<code>RSE</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

## housemouse model
morning &lt;- subset(housemouse, occ = c(1,3,5,7,9))
msk &lt;- make.mask((traps(morning)), nx = 32) 
morning.h2   &lt;- secr.fit(morning, buffer = 20, model = list(g0~h2), mask = msk, 
    trace = FALSE)
CVa0(morning.h2 )


## End(Not run)

</code></pre>


</div>