<div class="container">

<table style="width: 100%;"><tr>
<td>shypEstFun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapper function for the Estimation of Soil Hydrologic Property Model Parameters</h2>

<h3>Description</h3>

<p>Estimates model parameters of implemented soil hydraulic property functions. 
This function sets up the parameter estimation, given a set of arguments, and enables minimisation of (weighted) 
sum of squared residuals, assuming independent and identically distributed model residuals.
More information on the options is given in the <em>Details</em>
</p>


<h3>Usage</h3>

<pre><code class="language-R">shypEstFun(
  shpmodel = "01110",
  parL,
  retdata,
  condata,
  ivap = NULL,
  hclip = FALSE,
  weightmethod = "none",
  LikModel = "rss",
  ALG = "DE",
  set.itermax = 200,
  ALGoptions = NULL,
  lhs.query = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>shpmodel</code></td>
<td>

<table>
<tr>
<td style="text-align: left;">Character specifying the soil hydraulic property model. Currently valid models as documented in shypFun and are:</td>
</tr>
<tr>
<td style="text-align: left;">
<code>01110</code> constrained unimodal van Genuchten-Mualem.</td>
</tr>
<tr>
<td style="text-align: left;"> 
<code>01210</code> constrained bimodal van Genuchten-Mualem.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>01310</code> constrained trimodal van Genuchten-Mualem.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>02110</code> unimodel Kosugi 2 parametric-Mualem model (Kosugi, 1996)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>03110</code> unimodel Fredlund-Xing-Mualem model, with the contraint of m = 1-1/n (Fredlund D.G., and A. Xing, 1994)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parL</code></td>
<td>
<p><code>list</code> of 4 vectors with named vectors, the order in the list is sensitive.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>p</code>
</td>
<td style="text-align: left;">vector with length <code>l</code> of model specific initial parameters, has to coincide with the chosen soil hydraulic property model.</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>psel</code>
</td>
<td style="text-align: left;">vector with length <code>l</code> identifying which parameters are to be estimated</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plo</code>
</td>
<td style="text-align: left;">vector of lower bounds (non-transformed parameter boundaries)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>pup</code>
</td>
<td style="text-align: left;">vector of upper bounds (non-transformed parameters boundaries)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retdata</code></td>
<td>
<p>A dataframe or matrix with 2 columns. The first with log10 values of pressure head values in [cm] and the second with volumetric water contents in [cm cm-3].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condata</code></td>
<td>
<p>A dataframe or matrix with 2 columns. The first with log10 values of pressure head values in [cm] and the second with hydraulic conductivity values log10[cm d-1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ivap</code></td>
<td>
<p>Specification if isothermal vapour conductivity after Saito et al. (2006) is accounted, defaults to <code>NULL</code> and no isothermal vapour conducitvity is considered. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hclip</code></td>
<td>
<p>Implemented for future development reasons and is not yet functional. Specification if the hydraulic conductivity model should be 'clipped', i.e. constrained to a maxium pore diamater as introduced by Iden et al. (2015), defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightmethod</code></td>
<td>
<p>Specification of weight method. The implemented methods are
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>none</code>
</td>
<td style="text-align: left;">no weights are considered, i.e. no measurement error assumed</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>range</code>
</td>
<td style="text-align: left;">normalization of observations to the intervall [0,1]</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>fix1</code>
</td>
<td style="text-align: left;">fixed scalar weight for THETA is 0.05^2 and weight for log10K is 1 </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>est1</code>
</td>
<td style="text-align: left;">Two scalar model weights (\$1/sigma^2) are treated as free parameters to be estimated by inversion, one for <code>THETA</code> and one for <code>log10K</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
      </td>
</tr>
</table>
<p>Alternatively, a list of vectors can be provided specifying the user given model weights (\$1/sigma^2). Either as skalar for each data class, or a vector with the same length as the number of data points given for each of the measurements in the respective data class.
The length of the list has to coincide with the data groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LikModel</code></td>
<td>
<p>Specification of inverse modelling type. Has to be specified but implemented for future compatability)
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>rss</code>
</td>
<td style="text-align: left;">Default for the optimisation algorithm <code>DEoptim</code>. <code>resFun</code> returns skalar sum of squared (weighted) residuals</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>-2loglik</code>
</td>
<td style="text-align: left;">Specified if <code>ALG == -2*log-likelihood</code> value, which is minimised assuming Gaussian and i.i.d (weighted) residuals</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ALG</code></td>
<td>
<p>Select global optimisation algorithm or a Markov chain Monte Carlos (MCMC) sampler.
</p>

<table>
<tr>
<td style="text-align: left;">
   <code>DE</code>
</td>
<td style="text-align: left;">Default for the optimisation algortihm DEoptim. resFun returns a skalar sum of squared (weighted) residuals if <code>LikModel == "rss"</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>modMCMC</code>
</td>
<td style="text-align: left;">Default for the DRAM (Delayed Rejection Adaption Metropolis) algrothim implemented in <code>modMCMC</code> of the FME package. 
resFun returns a skalar -2loglik and <code>LikModel = "-2logLik"</code> has to be specified.</td>
</tr>
<tr>
<td style="text-align: left;">
   </td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set.itermax</code></td>
<td>
<p>Integer specifying the maximum number of iterations <code>default = 200</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ALGoptions</code></td>
<td>
<p>A list with named entries setting the algorithm options. Each list element name is required to be identical with the names
as documented in the respective algortihm help DEoptim.control and modMCMC. <br><code>set.itermax</code> overrides the maximum iterations argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lhs.query</code></td>
<td>
<p>default <code>FALSE</code>, <code>TRUE</code> will produce a Latin Hypercube Sample for the initial population when using <code>DEoptim</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Several in-built methods for weighting the (multi-) objective function residuals are available, they may be specified, or estimated as nuisance parameters for the two data groups. More details see <code>weightFun</code>.
Weights are the inverse of the squared standard deviation of the residuals (variance).
</p>
<p>Generally, soil hydraulic property model parameters are estimated as transformed parameters: log10 for alpha_i, Ks, and log10 for n_i-1, Kc, Knc
</p>
<p>For model codes in <em>ivap</em> please refer to KvapFun.
</p>
<p>Parallel computing for package <code>DEoptim</code> is not supported. And the optional arguments in <code>modMCMC</code> are not supported.
</p>


<h3>Value</h3>

<p><code>list</code> returns the result of the optimisation algrorithm or MCMC sampler and all settings.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>a <code>list</code> with output of the optimisation and summary of settings:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>weigth</code>
</td>
<td style="text-align: left;">the <code>list</code> with weights for the retention and conductivity data. </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>parL</code>
</td>
<td style="text-align: left;"> the <code>list</code> of initial and selected model parameters, and upper and lower bounds.</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>transL</code>
</td>
<td style="text-align: left;">list of parameter transformation rules used</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shpmodel</code>
</td>
<td style="text-align: left;">the used soil hydraulic property model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>ivap</code>
</td>
<td style="text-align: left;">isothermal vapour conductivity model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>hclip</code>
</td>
<td style="text-align: left;">for future compatability</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>LikModel</code>
</td>
<td style="text-align: left;">the adopted method to calculate the objective function value</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>data</code>
</td>
<td style="text-align: left;"> a <code>list</code> of 2 objects with a) retention data and b) conductivity data used for the parameter estimation.
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out</code></td>
<td>
<p>result of algorithm function <code>DEoptim</code> or <code>modMCMC</code></p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("shpdata1")
retdata &lt;- shpdata1$TS1$wrc
condata &lt;- shpdata1$TS1$hcc
condata &lt;- condata[!is.na(condata[,1]),]

weightmethod &lt;- "range"
ivap         &lt;- NULL
set.itermax  &lt;- 1
LikModel     &lt;- "rss" # ALTERNATIVE OPTION: LikModel = "-2logLik"
ALG          &lt;- "DE"       # ALTERNATIVE OPTION: ALG = "modMCMC"

parL&lt;-list("p"=c("thr"=0.05,"ths"=0.45,"alf1"=0.01,"n"=2,"Ks"=100,"tau"=.5),
          "psel" = c(1, 1, 1, 1, 1, 1),
          "plo"= c(0.001 , 0.2 , 0.001 , 1.1, 1, -2),
          "pup"= c(0.3 , 0.8 , .1, 11 , 1e4, 10))

out &lt;- shypEstFun(shpmodel = "01110", 
                 parL = parL, 
                 retdata = retdata, condata = condata, 
                 ivap = ivap, 
                 hclip = FALSE, 
                 weightmethod = weightmethod,
                 LikModel = LikModel, 
                 ALG = ALG, 
                 set.itermax = set.itermax,
                 lhs.query = FALSE)
\dontshow{
}
\donttest{
data("shpdata1")
retdata &lt;- ret &lt;- shpdata1$TS1$wrc
condata &lt;- con &lt;- shpdata1$TS1$hcc
condata &lt;- condata[!is.na(condata[,1]),]

---
     
#  1 SET VARIABLES --------------------
#  VARIABLES FOR PLOTTING
{pF &lt;- seq(-3, 6.8, length = 201)
h &lt;- 10^pF
ticksatmin &lt;- -2
tcllen &lt;- 0.4
ticksat &lt;- seq(ticksatmin,5,1)
pow &lt;- ticksatmin:6

#  VARIABLES FOR THE FITTING ALGORITHM
weightmethod = "range"
ivap = NULL
set.itermax = 3e1
LikModel = "rss" # ALTERNATIVE OPTION: LikModel = "-2logLik"
ALG = "DE"       # ALTERNATIVE OPTION: ALG = "modMCMC"
shpmodel.v &lt;- c("01110", "01110FM") 

plot.query = FALSE
no.shps &lt;- length(shpmodel.v)

#  initialising lists
out.L &lt;- vector("list", no.shps)
gof.L &lt;- vector("list", no.shps)
}
# Run comparison
for (i in 1:2) {
     shpmodel = shpmodel.v[i]
     # INITIAL PARAMETERS, BOUNDS, and SELECTED PARAMETERS FOR FITTING
     switch(shpmodel,
    "01110" = {
          
          # van Genuchten-Mualem Model parameters
          parL&lt;-list("p"=c("thr"=0.05,"ths"=0.45,"alf1"=0.01,"n"=2,"Ks"=100,"tau"=.5),
                     "psel" = c(1, 1, 1, 1, 1, 1),
                     "plo"= c(0.001 , 0.2 , 0.001 , 1.1, 1, -2),
                     "pup"= c(0.3 , 0.8 , .1, 11 , 1e4, 10)
          )
    },
    
    "01110FM" = {
          
          # van Genuchten-Mualem Model parameters + BRUNSWICK MODEL
          parL&lt;-list("p"=c("thr"=0.05,"ths"=0.45,"alf1"=0.01,"n"=2,"Ksc"=100,
                           "tau"=.5,"Ksnc"=1e-4,"a"=1.5,"h0"=6.8),
                     "psel" = c( 1,1, 1 ,1 , 1,1,1, 0, 0),
                     "plo"= c(0.001 , 0.1 , 0.001 , 1.1, 1,0,1e-6 , 1, 6.5),
                     "pup"= c(0.35, 0.7 , .1, 11 , 1e4,10 ,1e0, 2, 6.9)
          )
    },
    stop("Enter a meaningful shpmodel")
     )
     
     out &lt;- shypEstFun(shpmodel = shpmodel, 
                parL = parL, 
                retdata = retdata, condata = condata, 
                ivap = ivap, 
                hclip = FALSE, 
                weightmethod = weightmethod,
                LikModel = LikModel, 
                ALG = ALG, 
                set.itermax = set.itermax
                ,lhs.query = FALSE)
     
     out$model &lt;- shpmodel.v[i]
     out.L[[i]] &lt;- out
     
     
     #  Calculate the soil hydraulic properties for the plot
     if(ALG == "DE"){
           p &lt;- out$out$optim$phattrans
     }
     
     if(ALG == "modMCMC"){
           p &lt;- out$out$bestpartrans
     }
     
     if(weightmethod =="est1"){
           np &lt;- length(p)
           p &lt;- p[-c(np-1, np)]
           if(ALG =="modMCMC"){
                 parL$p[which(parL$psel==1)] &lt;- p
                 p &lt;- parL$p
           }
     }
     
     if(plot.query==TRUE){
           
           shyp.L&lt;-shypFun(p,h,shpmodel=shpmodel.v[i],ivap.query=ivap)
           
           if(shpmodel == c("01110")){
                 
                 wrc&lt;-shyp.L$theta
                 hcc&lt;-log10(shyp.L$Kh)
                 
                 # PLOT THE WATER RETENTION CURVE
                 par(mfrow=c(1,2),tcl=tcllen)
                 plot(retdata,ylim=c(.0,.50),xlim=c(0,6.8),ylab="",xlab="",
                      col="darkgrey",axes=FALSE,main="WaterRetentionCurve",cex=2)
                 lines(log10(abs(h)),wrc,col="darkblue",lwd=2)
                 legend("topright",c("observed","simulated"),pch=c(1,NA),
                        lty=c(NA,1),lwd=2,bty="n",cex=1.3,col=c("darkgrey","darkblue"))
                 axis(1,at=pow,labels=parse(text=paste('10^',(pow),sep="")),tcl=tcllen)
                 axis(2,tcl=tcllen)
                 axis(4,labels=NA)
                 axis(3,labels=NA)
                 mtext("pressurehead|h|[cm]",1,cex=1.2,line=2.8)
                 mtext("vol.watercontent[-]",2,cex=1.2,line=2.8)
                 box()
                 
                 # PLOT THE MEASURED HYDRAULIC CONDUCTIVITY CURVE
                 plot(condata,ylim=c(-8,2),xlim=c(0,6.8),ylab="",xlab="",col="darkgrey",
                      axes=FALSE,main="HydraulicConductivityCurve",cex=2)
                 lines(log10(abs(h)),hcc,col="darkblue",lwd=2)
                 legend("topright",c("observed","simulated"),pch=c(1,NA),
                        lty=c(NA,1),lwd=2,bty="n",cex=1.3,col=c("darkgrey","darkblue"))
                 axis(1,at=pow,labels=parse(text=paste('10^',(pow),sep="")),tcl=tcllen)
                 axis(2)
                 axis(4,labels=NA)
                 axis(3,labels=NA)
                 mtext("log10K[cm/d]",2,cex=1.2,line=2.8)
                 mtext("pressurehead|h|[cm]",1,cex=1.2,line=2.8)
                 box()
                 par(mfrow=c(1,1))
                 
           }
           
           if(shpmodel == "01110FM"){
                 
                 wrc&lt;-shyp.L$theta
                 wrccap&lt;-shyp.L$thetacap
                 wrcnc&lt;-shyp.L$thetanc
                 
                 hcc&lt;-log10(shyp.L$Kh)
                 hcccap&lt;-log10(shyp.L$Kcap)
                 hccnc&lt;-log10(shyp.L$Knc)
                 hcvap&lt;-log10(shyp.L$Kvap)
                 
                 par(mfrow=c(1,2),tcl=tcllen)
                 plot(retdata,ylim=c(.0,.50),xlim=c(0,6.8),ylab="",xlab="",
                      col="darkgrey",axes=FALSE,main="WaterRetentionCurve",cex=2)
                 lines(log10(h),wrccap,col="brown",lwd=2)
                 lines(log10(h),wrcnc,col="brown",lwd=2,lty=2)
                 lines(log10(h),wrc,col="darkblue",lwd=2)
                 
                 legend("topright",c("observed","simulated"),pch=c(1,NA),
                        lty=c(NA,1),lwd=2,bty="n",cex=1.3,col=c("darkgrey","darkblue"))
                 axis(1,at=pow,labels=parse(text=paste('10^',(pow),sep="")),tcl=tcllen)
                 axis(2,tcl=tcllen)
                 axis(4,labels=NA)
                 axis(3,labels=NA)
                 mtext("pressurehead|h|[cm]",1,cex=1.2,line=2.8)
                 mtext("vol.watercontent[-]",2,cex=1.2,line=2.8)
                 box()
                 
                 #  PLOT THE HYDRAULIC CONDUCTIVITY CURVE
                 plot(condata,ylim=c(-8,max(max(condata[,1]),max(hcc)))
                      ,xlim=c(0,6.8),ylab="",xlab="",col="darkgrey",
                      axes=FALSE,main="HydraulicConductivityCurve",cex=2)
                 lines(log10(h),hcccap,col="brown",lwd=2)
                 lines(log10(h),hccnc,col="brown",lwd=2,lty=2)
                 lines(log10(h),hcc,col="darkblue",lwd=2)
                 lines(log10(h),hcvap,col="darkblue",lwd=2)
                 legend("topright",c("observed","simulated"),pch=c(1,NA),
                        lty=c(NA,1),lwd=2,bty="n",cex=1.3,col=c("darkgrey","darkblue"))
                 axis(1,at=pow,labels=parse(text=paste('10^',(pow),sep="")),tcl=tcllen)
                 axis(2)
                 axis(4,labels=NA)
                 axis(3,labels=NA)
                 mtext("log10K[cm/d]",2,cex=1.2,line=2.8)
                 mtext("pressurehead|h|[cm]",1,cex=1.2,line=2.8)
                 box()
                 par(mfrow=c(1,1))
           }
     }
     phattrans.m &lt;- out$out$optim$phattrans
     gof.L[[i]]&lt;-gofFun(phattrans.m,shpmodel=shpmodel.v[i],retdata=retdata,condata=condata,
                        out.L[[i]]$settings$weight,parL$psel,ivap.query=NULL,hclip.query=FALSE)
}

statstab3 &lt;- cbind("th_rmse" = unlist(lapply(lapply(gof.L, `[[`, "th"), '[[', "rmse")),
                  "log10Kh_rmse" = unlist(lapply(lapply(gof.L, `[[`, "log10Kh"), '[[', "rmse"))
)
}

## End(Not run) 
</code></pre>


</div>