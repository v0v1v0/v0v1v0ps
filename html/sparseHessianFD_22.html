<div class="container">

<table style="width: 100%;"><tr>
<td>sparseHessianFD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sparseHessianFD</h2>

<h3>Description</h3>

<p>A reference class for computing sparse Hessians
</p>


<h3>Details</h3>

<p>The sparseHessianFD function calls the initializer for the
sparseHessianFD class, and returns a sparseHessianFD object.
</p>
<pre>sparseHessianFD(x, fn, gr, rows, cols, delta, index1, complex, ...)</pre>
<p>The function, gradient and sparsity pattern are
declared as part of the initialization.
</p>
<p>Once initialized, the $hessian method will evaluate the Hessian at x.
</p>
<pre>
obj &lt;- sparseHessian(x, fn, gr, rows, cols, ...)
obj$hessian(x)
</pre>
<p>For convenience, the class provides wrapper methods to the <code>fn</code> and <code>gr</code> functions that were specified in the initializer.
</p>
<pre>
obj$fn(P) ## wrapper to objective function
obj$gr(P) ## wrapper to gradient
obj$fngr(P) ## list of obj function and gradient
obj$fngrhs(P) ## list of obj function, gradient and Hessian.
</pre>


<h4>Arguments to initializer</h4>


<dl>
<dt>x</dt>
<dd>
<p>an vector at which the function, gradient and Hessian are initialized and tested.</p>
</dd>
<dt>fn, gr</dt>
<dd>
<p>R functions that return the function value and
gradient, evaluated at x.</p>
</dd>
<dt>rows, cols</dt>
<dd>
<p>Numeric vectors with row and column indices of
the non-zero elements in the lower triangle (including diagonal) of
the Hessian.</p>
</dd>
<dt>delta</dt>
<dd>
<p>The perturbation amount for finite difference (or
complex step) of the gradient to compute the Hessian.  Defaults to 1e-07.</p>
</dd>
<dt>index1</dt>
<dd>
<p>TRUE if rows and cols use 1-based (R format)
indexing (FALSE for 0-based (C format) indexing.</p>
</dd>
<dt>complex</dt>
<dd>
<p>TRUE if Hessian will be computed using the complex
step method, and FALSE (default) if using finite differences. If
TRUE, both fn and gr must accept complex arguments and return complex values.</p>
</dd>
<dt>...</dt>
<dd>
<p>other arguments to be passed to fn and gr.</p>
</dd>
</dl>
<p>Other methods are described below.  Do not access any of the
fields directly.  The internal structure is subject to change in future versions.
</p>


<h3>Fields</h3>


<dl>
<dt><code>fn1</code></dt>
<dd>
<p>A closure for calling fn(x, ...).</p>
</dd>
<dt><code>gr1</code></dt>
<dd>
<p>A closure for calling gr(x, ...).</p>
</dd>
<dt><code>iRow,jCol</code></dt>
<dd>
<p>Numeric vectors with row and column indices of
the non-zero elements in the lower triangle (including diagonal) of
the Hessian.</p>
</dd>
<dt><code>delta</code></dt>
<dd>
<p>The perturbation amount for finite differencing of
the gradient to compute the Hessian. Defaults to 1e-07.</p>
</dd>
<dt><code>index1</code></dt>
<dd>
<p>TRUE if rows and cols use 1-based (R format)
indexing (FALSE for 0-based (C format) indexing.</p>
</dd>
<dt><code>complex</code></dt>
<dd>
<p>TRUE if Hessian will be computed using the complex
step method, and FALSE (default) if using finite differences.</p>
</dd>
<dt><code>D</code></dt>
<dd>
<p>raw finite differences (internal use only)</p>
</dd>
<dt><code>nvars</code></dt>
<dd>
<p>Number of variables (length of x)</p>
</dd>
<dt><code>nnz</code></dt>
<dd>
<p>Number of non-zero elements in the lower triangle of the Hessian.</p>
</dd>
<dt><code>ready</code></dt>
<dd>
<p>TRUE if object has been initialized, and Hessian has
been partitioned.</p>
</dd>
<dt><code>idx,pntr</code></dt>
<dd>
<p>Column indices and row pointers for non-zero
elements in lower triangle of the permuted Hessian.  Row-oriented
compressed storage.</p>
</dd>
<dt><code>colors</code></dt>
<dd>
<p>A vector representation of the partitioning of the columns.
There are nvars elements, one for each column of the permuted
Hessian.  The value corresponds to the "color" for that column.</p>
</dd>
<dt><code>perm,invperm</code></dt>
<dd>
<p>Permutation vector and its inverse</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt><code>fn(x)</code></dt>
<dd>
<p>Return function value, evaluated at x: fn(x, ...)</p>
</dd>
<dt><code>fngr(x)</code></dt>
<dd>
<p>Return list of function value and gradient, evaluated at x</p>
</dd>
<dt><code>fngrhs(x)</code></dt>
<dd>
<p>Return list of function value, gradient, and Hessian, evaluated at x</p>
</dd>
<dt><code>get_invperm()</code></dt>
<dd>
<p>Return integer vector of inverse of permutation used for computing Hessian</p>
</dd>
<dt><code>get_nnz()</code></dt>
<dd>
<p>Return number of non-zero elements in lower triangle of Hessian</p>
</dd>
<dt><code>get_nvars()</code></dt>
<dd>
<p>Return dimension (number of rows or columns) of Hessian</p>
</dd>
<dt><code>get_pattern()</code></dt>
<dd>
<p>Return pattern matrix of lower triangle of Hessian</p>
</dd>
<dt><code>get_perm()</code></dt>
<dd>
<p>Return integer vector of permutation used for computing Hessian</p>
</dd>
<dt><code>get_perm_pattern()</code></dt>
<dd>
<p>Return pattern matrix of lower triangle of *permuted* Hessian</p>
</dd>
<dt><code>gr(x)</code></dt>
<dd>
<p>Return gradient, evaluated at x:  gr(x,...)</p>
</dd>
<dt><code>hessian(x)</code></dt>
<dd>
<p>Return sparse Hessian, evaluated at x, as a dgCMatrix object.</p>
</dd>
<dt><code>initialize(
  x,
  fn,
  gr,
  rows,
  cols,
  delta = 1e-07,
  index1 = TRUE,
  complex = FALSE,
  ...
)</code></dt>
<dd>
<p>Initialize object with functions to compute the objective function and gradient (fn and gr), row and column indices of non-zero elements (rows and cols), an initial variable vector x at which fn and gr can be evaluated, a finite differencing parameter delta, flags for 0 or 1-based indexing (index1), whether the complex step method will be used, and other arguments (...) to be passed to fn and gr.</p>
</dd>
<dt><code>partition()</code></dt>
<dd>
<p>Return the partitioning used to compute finite differences</p>
</dd>
<dt><code>pointers(out.index1 = index1)</code></dt>
<dd>
<p>Return list with indices (idx) and pointers (pntr) for sparsity pattern of the compressed sparse Hessian.  Since the Hessian is symmetric, the indices and pointers for row-oriented and column-oriented storage patterns are the same.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">## Log posterior density of hierarchical binary choice model. See vignette.
set.seed(123)
data("binary_small")
N &lt;- length(binary[["Y"]])
k &lt;- NROW(binary[["X"]])
T &lt;- binary[["T"]]
P &lt;- rnorm((N+1)*k)
priors &lt;- list(inv.Sigma = rWishart(1,k+5,diag(k))[,,1],
               inv.Omega = diag(k))
true.hess &lt;- binary.hess(P, binary, priors)
pattern &lt;- Matrix.to.Coord(Matrix::tril(true.hess))
str(pattern)
obj &lt;- sparseHessianFD(P, fn=binary.f, gr=binary.grad,
       rows=pattern[["rows"]], cols=pattern[["cols"]],
                      data=binary, priors=priors)
hs &lt;- obj$hessian(P)
all.equal(hs, true.hess)

f &lt;- obj$fn(P) ## obj function
df &lt;- obj$gr(P) ## gradient
fdf &lt;- obj$fngr(P) ## list of obj function and gradient
fdfhs &lt;- obj$fngrhs(P) ## list of obj function, gradient and Hessian.
</code></pre>


</div>