<div class="container">

<table style="width: 100%;"><tr>
<td>NND.hotdeck</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance Hot Deck method.</h2>

<h3>Description</h3>

<p>This function implements the distance hot deck method to match the records of two data sources that share some variables. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">NND.hotdeck(data.rec, data.don, match.vars, 
             don.class=NULL, dist.fun="Manhattan",
             constrained=FALSE, constr.alg="Hungarian", 
             k=1, keep.t=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.rec</code></td>
<td>

<p>A matrix or data frame that plays the role of <em>recipient</em>.  This data frame must contain the variables (columns) that should be used, directly or indirectly, in the matching application (specified via <code>match.vars</code> and eventually <code>don.class</code>). 
</p>
<p>Missing values (<code>NA</code>) are allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.don</code></td>
<td>

<p>A matrix or data frame that plays the role of <em>donor</em>.  The variables (columns) involved, directly or indirectly, in the computation of distance must be the same and of the same type as those in <code>data.rec</code> (specified via <code>match.vars</code> and eventually <code>don.class</code>).   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.vars</code></td>
<td>

<p>A character vector with the names of the matching variables (the columns in both the data frames) that have to be used to compute distances between records (rows) in <code>data.rec</code> and those in <code>data.don</code>.
The variables used in computing distances may contain missing values but only a limited number of distance functions can handle them (see Details for clarifications). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>don.class</code></td>
<td>

<p>A character vector with the names of the variables (columns in both the data frames) that have to be used to identify the donation classes.  In this case the computation of distances is limited to those units of <code>data.rec</code> and <code>data.doc</code> that belong to the same donation class.  The case of empty donation classes should be avoided.  It would be preferable that variables used to form donation classes are defined as <code>factor</code>.
</p>
<p>The variables chosen for the creation of the donation classes should NOT contain missing values (NAs).
</p>
<p>When not specified (default), no donation classes are used.  This choice may require more memory to store a larger distance matrix and a higher computational effort.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.fun</code></td>
<td>

<p>A string with the name of the distance function that has to be used.  The following distances are allowed: “Manhattan” (aka “City block”; default), “Euclidean”, “Mahalanobis”,“exact” or “exact matching”, “Gower”, “minimax” or one of the distance functions available in the package <span class="pkg">proxy</span>.  Note that the distance is computed using the function  <code>dist</code> of the package <span class="pkg">proxy</span> with the exception of the “Gower” (see function <code>gower.dist</code> for details), “Mahalanobis” (function <code>mahalanobis.dist</code>) and “minimax” (see <code>maximum.dist</code>) cases.
</p>
<p>When <code>dist.fun="Manhattan"</code>, <code>"Euclidean"</code>, <code>"Mahalanobis"</code> or <code>"minimax"</code> all the matching variables in <code>data.rec</code> and <code>data.don</code> must be numeric.  When <code>dist.fun="exact"</code> or <code>dist.fun="exact matching"</code>, all the variables in <code>data.rec</code> and <code>data.don</code> will be converted to character and, as far as the distance computation is concerned, they will be treated as categorical nominal variables, i.e. distance is 0 if a couple of units presents the same response category and 1 otherwise. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrained</code></td>
<td>

<p>Logical.  When <code>constrained=FALSE</code> (default) each record in <code>data.don</code> can be used as a donor more than once.  On the contrary, when <br><code>constrained=TRUE</code> each record in <code>data.don</code> can be used as a donor only  <code>k</code> times. In this case, the set of donors is selected by solving an optimization problem, whose goal is to minimize the overall matching distance.  See description of the argument <code>constr.alg</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr.alg</code></td>
<td>

<p>A string that has to be specified when <code>constrained=TRUE</code>.  Two choices are available: “lpSolve” and “hungarian”.  In the first case, <code>constr.alg="lpSolve"</code>, the optimization problem is solved by means of the function <code>lp.transport</code> available in the package <span class="pkg">lpSolve</span>.  When <code>constr.alg="hungarian"</code> (default) the problem is solved using the Hungarian method, implemented in function <code>solve_LSAP</code> available in the package <span class="pkg">clue</span>.  Note that Hungarian algorithm is faster and more efficient if compared to <code>constr.alg="lpSolve"</code>  but it allows selecting a donor just once, i.e.  <code>k = 1</code> .
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>The number of times that a unit in <code>data.don</code> can be selected as a donor when  <code>constrained=TRUE</code>  (default <code>k = 1</code> ). When <code>k&gt;1</code> then optimization problem can be solved by setting <code>constr.alg="lpSolve"</code>. Hungarian algorithm <br> (<code>constr.alg="hungarian"</code>) can be used only when  <code>k = 1</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.t</code></td>
<td>

<p>Logical, when donation classes are used by setting  <code>keep.t=TRUE</code> prints information on the donation classes being processed (by default <code>keep.t=FALSE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
 
<p>Additional arguments that may be required by <code>gower.dist</code>, <br><code>maximum.dist</code>, or <code>dist</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function finds a donor record in <code>data.don</code> for each record in <code>data.rec</code>.  In the unconstrained case, it searches for the closest donor record according to the chosen distance function.  When for a given recipient record there are more donors available at the minimum distance, one of them is picked at random.
</p>
<p>In the constrained case a donor can be used just a fixed number of times, as specified by the <code>k</code> argument, but the whole set of donors is chosen in order to minimize the overall matching distance.  When <code>k=1</code>  the number of units (rows) in the donor data set has to be larger or equal to the number of units of the recipient data set; when the donation classes are used, this condition must be satisfied in each donation class.  For further details on nearest neighbor distance hot deck refer to Chapter 2 in D'Orazio <em>et al.</em> (2006).
</p>
<p>This function can also be used to impute missing values in a data set using the nearest neighbor distance hot deck.  In this case <code>data.rec</code> is the part of the initial data set that contains missing values on the target variable; on the contrary, <code>data.don</code> is the part of the data set without missing values on it.  See <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> code in the Examples for details.
</p>
<p>Please note that only  “Gower” and “minimax” distance functions allow for the presence of missing values (<code>NA</code>s) in the variables used in computing distances.  In both the cases when one of the of the observations presents a variable showing an NA, then this variable is excluded from the computation of distance between them. 
</p>


<h3>Value</h3>

<p>A <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mtc.ids</code></td>
<td>

<p>A matrix with the same number of rows of <code>data.rec</code> and two columns.  The first column contains the row names of the <code>data.rec</code> and the second column contains the row names of the corresponding donors selected from the <code>data.don</code>.  When the input matrices do not contain row names, a numeric matrix with the indexes of the rows is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.rd</code></td>
<td>

<p>A vector with the distances between each recipient unit and the corresponding donor. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noad</code></td>
<td>

<p>When <code>constrained=FALSE</code>, it reports the number of available donors at the minimum distance for each recipient unit. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>How the function has been called.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marcello D'Orazio <a href="mailto:mdo.statmatch@gmail.com">mdo.statmatch@gmail.com</a> 
</p>


<h3>References</h3>

<p>D'Orazio, M., Di Zio, M. and Scanu, M. (2006). <em>Statistical Matching: Theory and Practice.</em> Wiley, Chichester.
</p>
<p>Hornik K. (2012).  clue: Cluster ensembles.  R package version 0.3-45.  <a href="https://CRAN.R-project.org/package=clue">https://CRAN.R-project.org/package=clue</a>.
</p>
<p>Rodgers, W.L. (1984). “An evaluation of statistical matching”. <em>Journal of Business and Economic Statistics</em>, <b>2</b>, 91–102.
</p>
<p>Singh, A.C., Mantel, H., Kinack, M. and Rowe, G. (1993). “Statistical matching: use of auxiliary information as an alternative to the conditional independence assumption”. <em>Survey Methodology</em>, <b>19</b>, 59–79.
</p>


<h3>See Also</h3>

 
<p><code>RANDwNND.hotdeck</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# create the classical matching framework
lab &lt;- c(1:15, 51:65, 101:115)
iris.rec &lt;- iris[lab, c(1:3,5)]  # recipient data.frame 
iris.don &lt;- iris[-lab, c(1:2,4:5)] #donor data.frame

# Now iris.rec and iris.don have the variables
# "Sepal.Length", "Sepal.Width"  and "Species"
# in common.
#  "Petal.Length" is available only in iris.rec
#  "Petal.Width"  is available only in iris.don

# Find the closest donors donors computing distance
# on "Sepal.Length" and "Sepal.Width"
# unconstrained case, Euclidean distance

out.NND.1 &lt;- NND.hotdeck(data.rec=iris.rec, data.don=iris.don,
                         match.vars=c("Sepal.Length", "Sepal.Width") )

# create the synthetic data.set:
# fill in "Petal.Width" in iris.rec

fused.1 &lt;- create.fused(data.rec=iris.rec, data.don=iris.don, 
                        mtc.ids=out.NND.1$mtc.ids, z.vars="Petal.Width") 
head(fused.1)

# Find the closest donors computing distance
# on "Sepal.Length", "Sepal.Width" and Species;
# unconstrained case, Gower's distance

out.NND.2 &lt;- NND.hotdeck(data.rec=iris.rec, data.don=iris.don,
                         match.vars=c("Sepal.Length", "Sepal.Width", "Species"), 
                         dist.fun="Gower")


# find the closest donors using "Species" to form donation classes
# and "Sepal.Length" and "Sepal.Width" to compute distance;
# unconstrained case.

out.NND.3 &lt;- NND.hotdeck(data.rec=iris.rec, data.don=iris.don,
                         match.vars=c("Sepal.Length", "Sepal.Width"),
                         don.class="Species")


# find the donors using "Species" to form donation classes
# and "Sepal.Length" and "Sepal.Width" to compute distance;
# constrained case, "Hungarian" algorithm

library(clue)
out.NND.4 &lt;- NND.hotdeck(data.rec=iris.rec, data.don=iris.don,
                         match.vars=c("Sepal.Length", "Sepal.Width"),
                         don.class="Species", constrained=TRUE, 
                         constr.alg="Hungarian")

# Example of Imputation of missing values.
# Introducing missing values in iris
ir.mat &lt;- iris
miss &lt;- rbinom(nrow(iris), 1, 0.3)
ir.mat[miss==1,"Sepal.Length"] &lt;- NA
iris.rec &lt;- ir.mat[miss==1,-1]
iris.don &lt;- ir.mat[miss==0,]

#search for NND donors
imp.NND &lt;- NND.hotdeck(data.rec=iris.rec, data.don=iris.don,
                       match.vars=c("Sepal.Width","Petal.Length", "Petal.Width"),
                       don.class="Species")

# imputing missing values
iris.rec.imp &lt;- create.fused(data.rec=iris.rec, data.don=iris.don, 
                             mtc.ids=imp.NND$mtc.ids, z.vars="Sepal.Length") 

# rebuild the imputed data.frame
final &lt;- rbind(iris.rec.imp, iris.don)
head(final)


</code></pre>


</div>