<div class="container">

<table style="width: 100%;"><tr>
<td>mkseas</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make a date into a seasonal factor</h2>

<h3>Description</h3>

<p>Discretizes a date within a year into a bin (or <code>factor</code>)
for analysis, such as 11-day groups or by month.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mkseas(x, width = 11, start.day = 1, calendar, year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>data.frame</code> with a <code>date</code> column
(of <code>Date</code> or <code>POSIXct</code> class)
</p>
<p>It can also be an integer specifying the Julian day (specify
<code>year</code> to determine the leap year)
</p>
<p>If it is omitted, the full number of days will be calculated for the
year, determined by either <code>year</code> or <code>calendar</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>either <code>numeric</code> or other <code>character</code> value; if
it is numeric, it specifies the number of days in each bin (default
is 11 days); if character it specifies a common calendar usage, such as
<code>"mon"</code> for months; see details below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.day</code></td>
<td>
<p>this is the start of the season, specified as either a
as a <code>Date</code> to specify a month and day (year is ignored; day of
month is ignored if <code>width</code> relates to a month), or as a
<code>numeric</code> day of year, between 1 and the number of days
for the calendarter a leap day</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calendar</code></td>
<td>
<p>used to determine the number of days per year and per
bin; if not specified, a proleptic Gregorian calendar is assumed;
see <code>year.length</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>year</code></td>
<td>
<p>required if <code>x</code> is omitted, or if <code>x</code> is a
Julian day integer and <code>width</code> is non-numeric; used to
calculate leap year</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This useful date function groups <em>days</em> of a year into discrete
bins (or into a <code>factor</code>).  Statistical and plotting
functions can be applied to a variable contained within each bin. An
example of this would be to find the monthly temperature averages,
where <em>month</em> is the bin.
</p>
<p>If <code>width</code> is <code>integer</code>, the width of each bin
(except for the last) will be exactly <code>width</code> days. Since the
number of days in a year are not consistent, nor are always perfectly
divisible by <code>width</code>, the numbers of days in the last bin will
vary. <code>mkseas</code> determines that last bin must have at least 20% of
the number of observations for a leap year, otherwise it is merged
into the second to last bin (which will have extra numbers of
days). If <code>width</code> is <code>numeric</code> (i.e. <code>366/12</code>),
the width of each bin varies slightly. Using <code>width = 366/12</code> is
slightly different than <code>width = "mon"</code>. Leap years only affect
the <em>last</em> bin.
</p>
<p>Other common classifications based on the Gregorian calendar can be
used if <code>width</code> is given a <code>character</code> array. All of
these systems are arbitrary: having different numbers of days in each
bin, and leap years affecting the number of days in February. The most
common, of course, is by <em>month</em> (<code>"mon"</code>). Meteorological
quarterly seasons (<code>"DJF"</code>) are based on grouping three months,
starting with December.  This style of grouping is commonly used in
climate literature, and is preferred over the season names
‘winter’, ‘spring’, ‘summer’, and
‘autumn’, which apply to only one hemisphere.  The less common
annual quarterly divisions (<code>"JFM"</code>) are similar, except that
grouping begins with January. Zodiac divisions (<code>"zod"</code>) are
included for demonstrative purposes, and are based on the Tropical
birth dates (common in Western-culture horoscopes) starting with Aries
(March 21).
</p>
<p>Here are the complete list of options for the <code>width</code> argument:
</p>

<ul>
<li> <p><code>numeric</code>: the width of each bin (or group) in days
</p>
</li>
<li> <p><code>366/n</code>: divide the year into <code>n</code> sections
</p>
</li>
<li> <p><code>"mon"</code>: month intervals (abbreviated month names)
</p>
</li>
<li> <p><code>"month"</code>: month intervals (full month names)
</p>
</li>
<li> <p><code>"DJF"</code>: meteorological quarterly divisions: DJF, MAM, JJA, SON
</p>
</li>
<li> <p><code>"JFM"</code>: annual quarterly divisions: JFM, AMJ, JAS, OND
</p>
</li>
<li> <p><code>"JF"</code>: annual six divisions: JF, MA, AJ, JA, SO, ND
</p>
</li>
<li> <p><code>"zod"</code>: zodiac intervals (abbreviated symbol names)
</p>
</li>
<li> <p><code>"zodiac"</code>: zodiac intervals (full zodiac names)

</p>
</li>
</ul>
<p>If a non-Gregorian calendar is used (see <code>year.length</code>),
the number of days in a year can be set using <code>calendar</code>
attribute in the <code>date</code> column (using <code>attr</code>).
For example, <code>attr(x$date,"calendar") &lt;- "365_day"</code> will set the
dates using a 365-day per year calendar, where February is always
28-days in length. If this attribute is not set, it is assumed a
normal Gregorian calendar is used. Calendars with 360-days per year
(or 30-days per month) are incorrectly handled, since February cannot
have 30 days, however this can be forced by including a duplicate
February date in <code>x</code> for each year.
</p>


<h3>Value</h3>

<p>Returns an array of <code>factor</code>s for each date given in <code>x</code>.
The factor also has four attributes: <code>width</code>, <code>start.day</code>,
<code>calendar</code> (assumed to be 366, unless from attribute set in
<code>Date</code>), and an array <code>days</code> showing the maximum
number of days in each bin.
</p>
<p>See examples for its application.
</p>


<h3>Locale warning</h3>

<p>Month names generated using <code>"mon"</code> or <code>"months"</code> are locale
specific, and depend on your operating system and system language
settings. Normally, abbreviated month names should have exactly three
characters or less, with no trailing decimals. However,
Microsoft-based operating systems have an inconsistent set of
abbreviated month names between locales. For example, abbreviated
month names in English locales have three letters with no period at
the end, while French locales have 3–4 letters with a decimal at the
end. If your OS is POSIX, you should have consistent month names in
any locale. This can be fixed by setting
<code>options("seas.month.len") &lt;- 3</code>, which forces the length of the
months to be three-characters in length.
</p>
<p>To avoid any issues supporting locales, or to use English month names,
simply revert to a C locale: <code>Sys.setlocale(loc="C")</code>.
</p>


<h3>Note</h3>

<p>The phase of the Gregorian solar year (begins Julian day 1, or January
1st) is not in sync with the phase of <code>"DJF"</code> (begins Julian day
335/336) or <code>"zod"</code> (begins Julian day 80/81). If either of these
systems are to be used, ensure that there are <em>several</em> years of
data, or that the phase of the data is the same as the beginning
Julian day.
</p>
<p>For instance, if one years worth of data beginning on Julian day 1 is
factored into <code>"DJF"</code> bins, the first bin will mix data from the
first three months, and from the last month. The last three bins will
have a continuous set of data. If the values are not perfectly
periodic, the first bin will have higher variance, due to the mixing
of data separated by nearly a year.
</p>


<h3>Author(s)</h3>

<p>Mike Toews</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Solar_calendar">https://en.wikipedia.org/wiki/Solar_calendar</a></p>


<h3>See Also</h3>

<p><code>mkann</code>, <code>seas.sum</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Demonstrate the number of days in each category
ylab &lt;- "Number of days"

barplot(table(mkseas(width="mon", year=2005)),
        main="Number of days in each month",
        ylab=ylab)

barplot(table(mkseas(width="zod", year=2005)),
        main="Number of days in each zodiac sign",
        ylab=ylab)

barplot(table(mkseas(width="DJF", year=2005)),
        main="Number of days in each meteorological season",
        ylab=ylab)

barplot(table(mkseas(width=5, year=2004)),
        main="5-day categories", ylab=ylab)

barplot(table(mkseas(width=11, year=2005)),
        main="11-day categories", ylab=ylab)

barplot(table(mkseas(width=366 / 12, year=2005)),
        main="Number of days in 12-section year",
        sub="Note: not exactly the same as months")

# Application using synthetic data
dat &lt;- data.frame(date=as.Date(paste(2005, 1:365), "%Y %j"),
  value=(-cos(1:365 * 2 * pi / 365) * 10 + rnorm(365) * 3 + 10))
attr(dat$date, "calendar") &lt;- "365_day"

dat$d5 &lt;- mkseas(dat, 5)
dat$d11 &lt;- mkseas(dat, 11)
dat$month &lt;- mkseas(dat, "mon")
dat$DJF &lt;- mkseas(dat, "DJF")

plot(value ~ date, dat)
plot(value ~ d5, dat)
plot(value ~ d11, dat)
plot(value ~ month, dat)
plot(value ~ DJF, dat)

head(dat)

tapply(dat$value, dat$month, mean, na.rm=TRUE)
tapply(dat$value, dat$DJF, mean, na.rm=TRUE)

dat[which.max(dat$value),]
dat[which.min(dat$value),]

# start on a different day
st.day &lt;- as.Date("2000-06-01")

dat$month &lt;- mkseas(dat, "mon", start.day=st.day)
dat$d11 &lt;- mkseas(dat, 11, start.day=st.day)
dat$DJF &lt;- mkseas(dat, "DJF", start.day=st.day)

plot(value ~ d11, dat,
     main=.seasxlab(11, start.day=st.day))
plot(value ~ month, dat,
     main=.seasxlab("mon", start.day=st.day))
plot(value ~ DJF, dat,
     main=.seasxlab("DJF", start.day=st.day))
</code></pre>


</div>