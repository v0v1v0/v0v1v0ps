<div class="container">

<table style="width: 100%;"><tr>
<td>LPSScores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LP* Ranking</h2>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{p^*}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPSScores(powerRelation, elements = powerRelation$elements)

LPSRanking(powerRelation)

lexcelPSScores(powerRelation, elements = powerRelation$elements)

lexcelPSRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>For <code class="reqn">i, j \in N</code>, the social ranking solution <code class="reqn">L^{p^*}</code> then ranks <code class="reqn">i</code> strictly above <code class="reqn">j</code> if one of the following conditions hold:
</p>

<ol>
<li> <p><code class="reqn">\lbrace i \rbrace \succ \lbrace j \rbrace</code>;
</p>
</li>
<li> <p><code class="reqn">\lbrace i \rbrace, \lbrace j \rbrace \in \Sigma_k</code> and there exists a row <code class="reqn">p_0 \in \lbrace 2, \dots, |N|\rbrace</code> and column <code class="reqn">q_0 \in \lbrace 1, \dots, k-1\rbrace</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = (M^\succsim_j)_{p,q}\quad \forall p &lt; p_0, q &lt; k,</code>
</p>

<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p_0,q} = (M^\succsim_j)_{p_0,q}\quad \forall q &lt; q_0,\text{ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p_0,q_0} &gt; (M^\succsim_j)_{p_0,q_0}.</code>
</p>

</li>
</ol>
<h3>Value</h3>

<p>Score function returns a list of type <code>LP*Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a matrix with <code>length(powerRelation$elements)</code> rows and a variable number of columns, depending on the equivalence class index containing the singleton coalition of that element (matrix can have 0 columns).
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 12 \sim 2) \succ (13 \sim 23) \succ (1 \sim 3 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
0 &amp; 2 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p><code class="reqn">(M^\succsim_2)_{2,3}</code> in this context refers to the value in the second row and third column of element 2, in this case <code class="reqn">1</code>.
</p>
<p>In the example, <code class="reqn">2</code> will be immediately put above <code class="reqn">1</code> and <code class="reqn">3</code> because <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 1 \rbrace</code> and <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 3 \rbrace</code>.
Since <code class="reqn">\lbrace 1 \rbrace \sim \lbrace 3 \rbrace</code>, we next consider the coalitions of size 2. Here, it turns out that <code class="reqn">(M^\succsim_1)_{2,1} = 1 &gt; 0 = (M^\succsim_3)_{2,1}</code>,
setting <code class="reqn">3</code> to be the least preferred option (this is opposed to the <code class="reqn">L^p</code> relation, which has no strict preference of <code class="reqn">1</code> over <code class="reqn">3</code>).
</p>
<p>As alluded to, <code class="reqn">L^{p^*}</code> is similar to <code class="reqn">L^p</code>, <code>LPRanking()</code>, in that it first considers the singleton coalitions, then sequentially every coalition of size 2 and above that ranks better than the corresponding singleton.
It can be assumed, however, that <code class="reqn">L^{p^*}</code> is more granular, as it doesn't throw away any information about <em>which</em> equivalence class these bigger coalitions belong to.
</p>


<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
“Lexicographic solutions for coalitional rankings based on individual and collective performances.”
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code>L1Scores()</code> function.
</p>
<p><code>LPSScores()</code> discards some redundant information, most notably all columns from each element's singleton class and the ones thereafter.
The first row is also removed, as all values there are guaranteed to be 0.
</p>
<p>For the example above, this would actually result in the matrices
</p>
<pre>
matrix(c(1,1, 1,0), nrow=2)
matrix(numeric(), nrow=2)
matrix(c(0,1, 2,0), nrow=2)
</pre>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcelPSScores()</code> and <code>lexcelPSRanking()</code> serve as aliases for <code>LPSScores()</code> and <code>LPSRanking()</code>, respectively.
</p>


<h3>References</h3>

<p>Béal S, Rémila E, Solal P (2022).
“Lexicographic solutions for coalitional rankings based on individual and collective performances.”
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code>L1Scores()</code>,
<code>L2Scores()</code>,
<code>LPScores()</code>,
<code>copelandScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>lexcelScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("(123 ~ 12 ~ 2) &gt; (13 ~ 23) &gt; (1 ~ 3 ~ {})")
scores &lt;- LPSScores(pr)
scores$`1`
#      [,1] [,2]
# [1,]    1    1
# [2,]    1    0

scores$`2`
#
# [1,]
# [2,]

LPSRanking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>


</div>