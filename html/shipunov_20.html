<div class="container">

<table style="width: 100%;"><tr>
<td>Classproj</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class projection</h2>

<h3>Description</h3>

<p>Class projection which preserves distances between class centers</p>


<h3>Usage</h3>

<pre><code class="language-R">Classproj(data, classes, method="DMS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data: must be numeric and convertible into matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>Class labels (correspond to data rows), NAs are allowed (sic!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Either "DMS" for Dhillon et al., 2002 or "QJ" for Qiu and Joe, 2006</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>'Classproj' is the leveraged (supervised) or educated (semi-supervised)
manifold learning (dimension reduction). See examples for the variety of
its uses.
</p>
<p>It uses classes to determine centers and then tries to preserve distances
between centers; two methods are possible: "DMS" which is slightly
faster, and "QJ" which frequently finds a better projection.
</p>
<p>The code is based on the functions from 'clusterGeneration' package from
Weiliang Qiu.
</p>


<h3>Value</h3>

<p>Returns list with 'proj' coordinates of projected data points and
'centers' coordinates of class centers.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Dhillon I.S., Modha D.S., Spangler W.S. 2002. Class visualization of
high-dimensional data with applications. Computational Statistics and
Data Analysis. 41: 59–90.
</p>
<p>Qiu W.-L., Joe H. 2006. Separation index and partial membership for
clustering. Computational Statistics and Data Analysis. 50: 585–603.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Leveraged approach (all classes are known)
iris.dms &lt;- Classproj(iris[, -5], iris$Species, method="DMS")
plot(iris.dms$proj, col=iris$Species)
text(iris.dms$centers, levels(iris$Species), col=1:3)

iris.qj &lt;- Classproj(iris[, -5], iris$Species, method="QJ")
plot(iris.qj$proj, col=iris$Species)
text(iris.qj$centers, levels(iris$Species), col=1:3)

## Educated approach (classes are known only for 10 data points per class)
sam &lt;- Class.sample(iris$Species, 10)
newclasses &lt;- iris$Species
newclasses[!sam] &lt;- NA

iris.dms &lt;- Classproj(iris[, -5], newclasses)
plot(iris.dms$proj, col=iris$Species, pch=ifelse(sam, 19, 1))
text(iris.dms$centers, levels(iris$Species), col=1:3)

iris.qj &lt;- Classproj(iris[, -5], newclasses, method="QJ")
plot(iris.qj$proj, col=iris$Species, pch=ifelse(sam, 19, 1))
text(iris.qj$centers, levels(iris$Species), col=1:3)

## Automated approach (classes calculated automatically)
## Good to visualize _any_ clustering or learning
iris.km &lt;- kmeans(iris[, -5], 3)

iris.dms &lt;- Classproj(iris[, -5], iris.km$cluster)
plot(iris.dms$proj, col=iris.km$cluster)
text(iris.dms$centers, labels=1:3, col=1:3, cex=2)

iris.qj &lt;- Classproj(iris[, -5], iris.km$cluster, method="QJ")
plot(iris.qj$proj, col=iris.km$cluster)
text(iris.qj$centers, labels=1:3, col=1:3, cex=2)
</code></pre>


</div>