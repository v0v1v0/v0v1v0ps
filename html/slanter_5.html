<div class="container">

<table style="width: 100%;"><tr>
<td>sheatmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot a heatmap with values as close to the diagonal as possible.</h2>

<h3>Description</h3>

<p>Given a matrix expressing the cross-similarity between two (possibly different) sets of entities,
this will reorder it to move the high values close to the diagonal, for a better visualization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sheatmap(
  data,
  ...,
  order_data = NULL,
  annotation_col = NULL,
  annotation_row = NULL,
  order_rows = TRUE,
  order_cols = TRUE,
  squared_order = TRUE,
  same_order = FALSE,
  patch_cols_order = NULL,
  patch_rows_order = NULL,
  discount_outliers = TRUE,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  oclust_rows = TRUE,
  oclust_cols = TRUE,
  clustering_distance_rows = "euclidian",
  clustering_distance_cols = "euclidian",
  clustering_method = "ward.D2",
  clustering_callback = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A rectangular matrix to plot, of non-negative values (unless <code>order_data</code> is specified).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional flags to pass to <code>pheatmap</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_data</code></td>
<td>
<p>An optional matrix of non-negative values of the same size to use for computing the orders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annotation_col</code></td>
<td>
<p>Optional data frame describing each column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annotation_row</code></td>
<td>
<p>Optional data frame describing each row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_rows</code></td>
<td>
<p>Whether to reorder the rows. Otherwise, use the current order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_cols</code></td>
<td>
<p>Whether to reorder the columns. Otherwise, use the current order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squared_order</code></td>
<td>
<p>Whether to reorder to minimize the l2 norm (otherwise minimizes the l1 norm).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same_order</code></td>
<td>
<p>Whether to apply the same order to both rows and columns (if reordering both).
For a square matrix, may also contain 'row' or 'column' to force the order of one axis to
apply to both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patch_cols_order</code></td>
<td>
<p>Optional function that may be applied to the columns order, returning a
better order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patch_rows_order</code></td>
<td>
<p>Optional function that may be applied to the rows order, returning a
better order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discount_outliers</code></td>
<td>
<p>Whether to do a final order phase discounting outlier values far from the diagonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_rows</code></td>
<td>
<p>Whether to cluster the rows, or the clustering to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_cols</code></td>
<td>
<p>Whether to cluster the columns, or the clustering to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oclust_rows</code></td>
<td>
<p>Whether to use <code>oclust</code> instead of <code>hclust</code> for the rows (if
clustering them).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oclust_cols</code></td>
<td>
<p>Whether to use <code>oclust</code> instead of <code>hclust</code> for the columns (if
clustering them).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering_distance_rows</code></td>
<td>
<p>The default method for computing row distances (by default,
<code>euclidian</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering_distance_cols</code></td>
<td>
<p>The default method for computing column distances (by default,
<code>euclidian</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering_method</code></td>
<td>
<p>The default method to use for hierarchical clustering (by default,
<code>ward.D2</code> and *not* <code>complete</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering_callback</code></td>
<td>
<p>Is not supported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you have an a-priori order for the rows and/or columns, you can prevent reordering either or
both by specifying <code>order_rows=FALSE</code> and/or <code>order_cols=FALSE</code>. Otherwise,
<code>slanted_orders</code> is used to compute the "ideal" slanted order for the data.
</p>
<p>By default, the rows and columns are ordered independently from each other. If the matrix is
asymmetric but square (e.g., a matrix of weights of a directed graph such as a
K-nearest-neighbors graph), then you can can specify <code>same_order=TRUE</code> to force both rows
and columns to the same order. You can also specify <code>same_order='row'</code> to force the columns
to use the same order as the rows, or <code>same_order='column'</code> to force the rows to use the
same order as the columns.
</p>
<p>You can also specify a <code>patch_cols_order</code> and/or a '<code>patch_rows_order</code>' function that
takes the computed "ideal" order and returns a patched order. For example, this can be used to
force special values (such as "outliers") to the side of the heatmap.
</p>
<p>There are four options for controlling clustering:
</p>
<p>* By default, <code>sheatmap</code> will generate a clustering tree using <code>oclust</code>, to generate
the "best" clustering that is also compatible with the slanted order.
</p>
<p>* Request that <code>sheatmap</code> will use the same <code>hclust</code> as
<code>pheatmap</code> (e.g., <code>oclust_rows=FALSE</code>). In this case, the tree is reordered to
be the "most compatible" with the target slanted order. That is, <code>sheatmap</code> will invoke
<code>reorder_hclust</code> so that, for each node of the tree, the order of the two sub-trees will
be chosen to best match the target slanted order. The end result need not be identical to the
slanted order, but is as close as possible given the <code>hclust</code> clustering tree.
</p>
<p>* Specify an explicit clustering (e.g., <code>cluster_rows=hclust(...)</code>). In this case,
<code>sheatmap</code> will again merely reorder the tree but will not modify it.
</p>
<p>In addition, you can give this function any of the <code>pheatmap</code> flags, and it will just pass
them on. This allows full control over the diagram's features.
</p>
<p>Note that <code>clustering_callback</code> is not supported. In addition, the default
<code>clustering_method</code> here is <code>ward.D2</code> instead of <code>complete</code>, since the only
methods supported by <code>oclust</code> are <code>ward.D</code> and <code>ward.D2</code>.
</p>


<h3>Value</h3>

<p>Whatever <code>pheatmap</code> returns.
</p>


<h3>Examples</h3>

<pre><code class="language-R">slanter::sheatmap(cor(t(mtcars)))
slanter::sheatmap(cor(t(mtcars)), oclust_rows=FALSE, oclust_cols=FALSE)
pheatmap::pheatmap(cor(t(mtcars)))
</code></pre>


</div>