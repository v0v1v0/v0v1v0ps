<div class="container">

<table style="width: 100%;"><tr>
<td>SolrClient</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solr connection client</h2>

<h3>Description</h3>

<p>Solr connection client
</p>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>host</code></td>
<td>
<p>(character) Host url. Deafault: 127.0.0.1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>(character) url path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>port</code></td>
<td>
<p>(character/numeric) Port. Default: 8389</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheme</code></td>
<td>
<p>(character) http scheme, one of http or https. Default: http</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proxy</code></td>
<td>
<p>List of arguments for a proxy connection, including one or
more of: url, port, username, password, and auth. See
crul::proxy for  help, which is used to construct the
proxy connection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errors</code></td>
<td>
<p>(character) One of <code>"simple"</code> or <code>"complete"</code>. Simple gives
http code and  error message on an error, while complete gives both http
code and error message, and stack trace, if available.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>SolrClient</code> creates a R6 class object. The object is
not cloneable and is portable, so it can be inherited across packages
without complication.
</p>
<p><code>SolrClient</code> is used to initialize a client that knows about your
Solr instance, with options for setting host, port, http scheme,
and simple vs. complete error reporting
</p>


<h3>Value</h3>

<p>Various output, see help files for each grouping of methods.
</p>


<h3>SolrClient methods</h3>

<p>Each of these methods also has a matching standalone exported
function that you can use by passing in the connection object made
by calling <code>SolrClient$new()</code>. Also, see the docs for each method for
parameter definitions and their default values.
</p>

<ul>
<li> <p><code>ping(name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>schema(name, what = '', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>commit(name, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>optimize(name, max_segments = 1, wait_searcher = TRUE, soft_commit = FALSE, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_get(name, what = NULL, wt = "json", raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_params(name, param = NULL, set = NULL, unset = NULL, update = NULL, ...)</code>
</p>
</li>
<li> <p><code>config_overlay(name, omitHeader = FALSE, ...)</code>
</p>
</li>
<li> <p><code>config_set(name, set = NULL, unset = NULL, ...)</code>
</p>
</li>
<li> <p><code>collection_exists(name, ...)</code>
</p>
</li>
<li> <p><code>collection_list(raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_create(name, numShards = 1, maxShardsPerNode = 1, createNodeSet = NULL, collection.configName = NULL, replicationFactor = 1, router.name = NULL, shards = NULL, createNodeSet.shuffle = TRUE, router.field = NULL, autoAddReplicas = FALSE, async = NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_addreplica(name, shard = NULL, route = NULL, node = NULL, instanceDir = NULL, dataDir = NULL, async = NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_addreplicaprop(name, shard, replica, property, property.value, shardUnique = FALSE, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_addrole(role = "overseer", node, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_balanceshardunique(name, property, onlyactivenodes = TRUE, shardUnique = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_clusterprop(name, val, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_clusterstatus(name = NULL, shard = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_createalias(alias, collections, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_createshard(name, shard, createNodeSet = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_delete(name, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_deletealias(alias, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_deletereplica(name, shard = NULL, replica = NULL, onlyIfDown = FALSE, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>collection_deletereplicaprop(name, shard, replica, property, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>collection_deleteshard(name, shard, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_migrate(name, target.collection, split.key, forward.timeout = NULL, async = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_overseerstatus(raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_rebalanceleaders(name, maxAtOnce = NULL, maxWaitSeconds = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_reload(name, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_removerole(role = "overseer", node, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_requeststatus(requestid, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>collection_splitshard(name, shard, ranges = NULL, split.key = NULL, async = NULL, raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>core_status(name = NULL, indexInfo = TRUE, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_exists(name, callopts = list())</code>
</p>
</li>
<li> <p><code>core_create(name, instanceDir = NULL, config = NULL, schema = NULL, dataDir = NULL, configSet = NULL, collection = NULL, shard = NULL, async=NULL, raw = FALSE, callopts=list(), ...)</code>
</p>
</li>
<li> <p><code>core_unload(name, deleteIndex = FALSE, deleteDataDir = FALSE, deleteInstanceDir = FALSE, async = NULL, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_rename(name, other, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_reload(name, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_swap(name, other, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>core_mergeindexes(name, indexDir = NULL, srcCore = NULL, async = NULL, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_requeststatus(requestid, raw = FALSE, callopts = list())</code>
</p>
</li>
<li> <p><code>core_split(name, path = NULL, targetCore = NULL, ranges = NULL, split.key = NULL, async = NULL, raw = FALSE, callopts=list())</code>
</p>
</li>
<li> <p><code>search(name = NULL, params = NULL, body = NULL, callopts = list(), raw = FALSE,  parsetype = 'df', concat = ',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>facet(name = NULL, params = NULL, body = NULL, callopts = list(), raw = FALSE,  parsetype = 'df', concat = ',', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>stats(name = NULL, params = list(q = '*:*', stats.field = NULL, stats.facet = NULL), body = NULL, callopts=list(), raw = FALSE, parsetype = 'df', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>highlight(name = NULL, params = NULL, body = NULL, callopts=list(), raw = FALSE, parsetype = 'df', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>group(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>mlt(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>all(name = NULL, params = NULL, body = NULL, callopts=list(), raw=FALSE, parsetype='df', concat=',', optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL, ...)</code>
</p>
</li>
<li> <p><code>json_request(name = NULL, body = NULL, callopts=list(),  progress = NULL)</code>
</p>
</li>
<li> <p><code>get(ids, name, fl = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>add(x, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>delete_by_id(ids, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>delete_by_query(query, name, commit = TRUE, commit_within = NULL, overwrite = TRUE, boost = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_json(files, name, commit = TRUE, optimize = FALSE, max_segments = 1, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, prepare_commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_xml(files, name, commit = TRUE, optimize = FALSE, max_segments = 1, expunge_deletes = FALSE, wait_searcher = TRUE, soft_commit = FALSE, prepare_commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_csv(files, name, separator = ',', header = TRUE, fieldnames = NULL, skip = NULL, skipLines = 0, trim = FALSE, encapsulator = NULL, escape = NULL, keepEmpty = FALSE, literal = NULL, map = NULL, split = NULL, rowid = NULL, rowidOffset = NULL, overwrite = NULL, commit = NULL, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_atomic_json(body, name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
<li> <p><code>update_atomic_xml(body, name, wt = 'json', raw = FALSE, ...)</code>
</p>
</li>
</ul>
<h3>number of results</h3>

<p>When the <code style="white-space: pre;">⁠$search()⁠</code> method returns a data.frame, metadata doesn't fit
into the output data.frame itself. You can access number of results
(<code>numFound</code>) in the attributes of the results. For example,
<code>attr(x, "numFound")</code> for number of results, and <code>attr(x, "start")</code>
for the offset value (if one was given). Or you can get all
attributes like <code>attributes(x)</code>. These metadata are not in the
attributes when requesting raw xml or json though as those metadata
are in the payload (unless <code>wt="csv"</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# make a client
(cli &lt;- SolrClient$new())

# variables
cli$host
cli$port
cli$path
cli$scheme

# ping
## ping to make sure it's up
cli$ping("gettingstarted")

# version
## get Solr version information
cli$schema("gettingstarted")
cli$schema("gettingstarted", "fields")
cli$schema("gettingstarted", "name")
cli$schema("gettingstarted", "version")$version

# Search
cli$search("gettingstarted", params = list(q = "*:*"))
cli$search("gettingstarted", body = list(query = "*:*"))

# set a different host
SolrClient$new(host = 'stuff.com')

# set a different port
SolrClient$new(host = 3456)

# set a different http scheme
SolrClient$new(scheme = 'https')

# set a proxy
SolrClient$new(proxy = list(url = "187.62.207.130:3128"))

prox &lt;- list(url = "187.62.207.130:3128", user = "foo", pwd = "bar")
cli &lt;- SolrClient$new(proxy = prox)
cli$proxy

# A remote Solr instance to which you don't have admin access
(cli &lt;- SolrClient$new(host = "api.plos.org", path = "search", port = NULL))
res &lt;- cli$search(params = list(q = "memory"))
res
attr(res, "numFound")
attr(res, "start")
attr(res, "maxScore")

## End(Not run)
</code></pre>


</div>