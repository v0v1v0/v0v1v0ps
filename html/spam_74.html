<div class="container">

<table style="width: 100%;"><tr>
<td>allequal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test if Two Sparse Matrices are (Nearly) Equal</h2>

<h3>Description</h3>

<p>Utility to compare two <code>spam</code> objects
testing 'near equality'.  Depending on the type of difference, comparison is
still made to some extent, and a report of the differences is
returned.</p>


<h3>Usage</h3>

<pre><code class="language-R">
## S3 method for class 'spam'
all.equal(target, current, tolerance = .Machine$double.eps^0.5,
    scale = NULL, check.attributes = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>a <code>spam</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>current</code></td>
<td>
<p>another <code>spam</code> object to be compared with <code>target</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>numeric &gt;= 0.  Differences smaller than
<code>tolerance</code> are not considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>numeric scalar &gt; 0 (or <code>NULL</code>). See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.attributes</code></td>
<td>
<p>currently not yet implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments for different methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Numerical comparisons for <code>scale = NULL</code> (the default) are
typically on a <em>relative difference</em> scale unless the
<code>target</code> values are close to zero or infinite. Specifically,
the scale is computed as the average absolute value of <code>target</code>.
If this scale is finite and exceeds <code>tolerance</code>, differences
are expressed relative to it; otherwise, absolute differences are used.
</p>
<p>If <code>scale</code> is numeric (and positive), absolute comparisons are
made after scaling (dividing) by <code>scale</code>. Note that if all of
scale is sufficiently close to 1 (specifically, within <code>tolerance</code>),
the difference is still reported as being on an absolute scale.
</p>
<p>Do not use <code>all.equal.spam</code> directly in <code>if</code>
expressions: either use <code>isTRUE( all.equal.spam(...))</code> or
<code>identical</code> if appropriate.
</p>
<p>Cholesky decomposition routines use this function to test for
symmetry.
</p>
<p>A method for <code>matrix-spam</code> objects is defined as well.
</p>
<p>There is the additional catch of a zero matrix being represented by
one zero element, see ‘Examples’ below.
</p>


<h3>Value</h3>

<p>Either <code>TRUE</code> or a vector of 'mode' <code>"character"</code> describing the
differences between <code>target</code> and <code>current</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code>isSymmetric.spam</code> and <code>cleanup</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">obj &lt;- diag.spam(2)
obj[1,2] &lt;- .Machine$double.eps

all.equal( diag.spam(2), obj)

all.equal( t(obj), obj)

all.equal( t(obj), obj*1.1)

# We can compare a spam to a matrix
all.equal(diag(2),diag.spam(2))

# the opposite does often not make sense,
# hence, it is not implemented.
all.equal(diag.spam(2),diag(2))


# A zero matrix contains one element:
str(spam(0))
# hence
all.equal.spam(spam(0,3,3), diag.spam(0,3) )
norm(spam(0,3,3) - diag.spam(0,3) )
</code></pre>


</div>