<div class="container">

<table style="width: 100%;"><tr>
<td>seqXtend</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sequence Covering the Range of X, including X</h2>

<h3>Description</h3>

<p>Produce a sequence of unique values (sorted increasingly),
<em>containing</em> the initial set of values <code>x</code>.
This can be useful for setting prediction e.g. ranges in nonparametric
regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seqXtend(x, length., method = c("simple", "aim", "interpolate"),
        from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.</code></td>
<td>
<p>integer specifying <em>approximately</em> the desired
<code>length()</code> of the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string specifying the method to be used.  The default,
<code>"simple"</code> uses <code>seq(*, length.out = length.)</code> where
<code>"aim"</code> aims a bit better towards the desired final length,
and <code>"interpolate"</code> interpolates evenly <em>inside</em>
each interval <code class="reqn">[x_i, x_{i+1}]</code> in a way to
make all the new intervalls of approximately the same length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from, to</code></td>
<td>
<p>numbers to be passed to (the default method for)
<code>seq()</code>, defaulting to the minimal and maximal <code>x</code>
value, respectively.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>numeric vector of increasing values, of approximate length
<code>length.</code>
(unless <code>length. &lt; length(unique(x))</code> in which case, the result
is simply <code>sort(unique(x))</code>),
containing the original values of <code>x</code>.
</p>
<p>From, <code>r &lt;- seqXtend(x, *)</code>, the original values are at
indices <code>ix &lt;- match(x,r)</code>, i.e., <code>identical(x, r[ix])</code>.
</p>


<h3>Note</h3>

<p><code>method = "interpolate"</code> typically gives the best results. Calling
<code>roundfixS</code>, it also need more computational resources
than the other methods.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code>seq</code>; <code>plotDS</code> can make particularly
good use of <code>seqXtend()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">a &lt;- c(1,2,10,12)
seqXtend(a, 12)# --&gt; simply 1:12
seqXtend(a, 12, "interp")# ditto
seqXtend(a, 12, "aim")# really worse
stopifnot(all.equal(seqXtend(a, 12, "interp"), 1:12))

## for a "general" x, however, "aim" aims better than default
x &lt;- c(1.2, 2.4, 4.6, 9.9)
length(print(seqXtend(x, 12)))        # 14
length(print(seqXtend(x, 12, "aim"))) # 12
length(print(seqXtend(x, 12, "int"))) # 12

## "interpolate" is really nice:
xt &lt;- seqXtend(x, 100, "interp")
plot(xt, main="seqXtend(*, 100, \"interpol\")")
points(match(x,xt), x, col = 2, pch = 20)
# .... you don't even see that it's not equidistant
# whereas the cheap method shows ...
xt2 &lt;- seqXtend(x, 100)
plot(xt2, col="blue")
points(match(x,xt2), x, col = 2, pch = 20)

## with "Date" objects
Drng &lt;- as.Date(c("2007-11-10", "2012-07-12"))
(px &lt;- pretty(Drng, n = 16)) # say, for the main labels
## say, a finer grid, for ticks -- should be almost equidistant
n3 &lt;- 3*length(px)
summary(as.numeric(diff(seqXtend(px, n3))))        # wildly varying
summary(as.numeric(diff(seqXtend(px, n3, "aim")))) #   (ditto)
summary(as.numeric(diff(seqXtend(px, n3, "int")))) # around 30
</code></pre>


</div>