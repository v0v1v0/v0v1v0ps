<div class="container">

<table style="width: 100%;"><tr>
<td>2. Phenomenological models</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Descriptive models of artificial-selection responses: auto-regressive models </h2>

<h3>Description</h3>

<p>The <code>sraAutoreg</code> functions are wrappers for the maximum-likelihood optimization function <code>mle</code>. They propose descriptive models for the dynamics of genetic architectures of different complexities based on an auto-regressive framework, additional parameters corresponding to different generation lags. The model can also be fit considering logatithmic, "heritability" and "evolvability" scales.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sraAutoreg(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregLog(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregHerit(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
sraAutoregEvolv(sradata, active = c(FALSE, TRUE, FALSE, FALSE), 
	start = NULL, fixed = NULL, negative.k = FALSE, 
	rand = 0, rep = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sradata</code></td>
<td>
<p> A data object generated by <code>sraData</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active</code></td>
<td>
<p> A vector of four booleans, corresponding to the active lags for both genetic and environmental variances (see Details). By default, only lag 1 is active, corresponding to an exponential change of the variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p> A named list of starting values for the convergence algorithm. <code>NULL</code> is allowed and lets the function <code>sraStartingvalues</code> calculating a (hopefully) educated guess on the starting values. See Details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p> A named list of the parameters that have to be kept constant. <code>NULL</code> is allowed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negative.k</code></td>
<td>
<p> Whether or not the k parameters can take negative values. Negtive values for k lead to more complex likelihood functions, and the resulting dynamics may display cyclic patterns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p> Amount of randomness for the starting values. Useful in case of convergence issues. Although this variable can take any positive value, reasonable figures should not exceed 0.2. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep</code></td>
<td>
<p> Number of convergence attempts. When the likelihood function is complex, which is often the case when the number of parameters exceeds 6 to 8, convergence may often fail or end up on a local maximum. When <code>rep</code> &gt; 1, several attempts are made from different starting values (the amount of randomness for the starting values being set by the <code>rand</code> parameter), and the best fit (highest likelihood) is returned. Setting high values of <code>rep</code> may slow down significantly the convergence process. In practice, 10 to 30 repetitions with <code>rand</code> = 0.1  are generally enough to ensure convergence. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional parameters to be passed to <code>mle</code>, and thus to <code>optim</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Model</strong>
</p>
<p>The following summarizes the models developed in Le Rouzic et al. 2010. 
</p>
<p>The mean of the population <code class="reqn">\mu</code> changes according to the Lande equation (Lande and Arnold 1983):
</p>
<p style="text-align: center;"><code class="reqn">\mu(t+1) = \mu(t) + VarA(t)*\beta(t),</code>
</p>

<p>where <code class="reqn">\beta(t)</code> is the selection gradient at generation t.
</p>
<p>The genetic architecture models predict the dynamics of a parameter P as:
</p>
<p style="text-align: center;"><code class="reqn">P(t+1) = k0 + k1*P(t) + k2*P(t-1) + k3*P(t-2)</code>
</p>

<p>Models with time lags &gt; 3 could be easily implemented, but convergence issues increase with the number of parameters. The first time points are calculated as if <code class="reqn">P(t&lt;1)=P(1)</code>, e.g. <code class="reqn">P(3) = k0 + k1*P(2) + k2*P(1) + k3*P(1)</code>. 
</p>
<p>Each model considers the dynamics of two independent parameters, one related to the additive genetic variance (<code class="reqn">VarA</code>), one related to the residual (environmental) variance <code class="reqn">VarE</code> (which actually also accounts for all non-additive genetic variance). 
</p>
<p>The default model <code>sraAutoreg</code> considers directly the dynamics of <code class="reqn">VarA</code> (parameters: <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>) and the dynamics of <code class="reqn">VarE</code> (parameters <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code>).
</p>
<p>The log scale turns a multiplicative trait into an additive one, and is particularly relevant for ratio-scale traits (i.e. most quantitative traits such as size, fertility, etc). The original data is transformed assuming log-normality, and the likelihood is computed based on the log-normal density function. 
</p>
<p>The "heritability" model <code>sraAutoregHerit</code> focuses on the dynamics of <code class="reqn">h^2=VarA/(VarA+VarE)</code>, described by the parameters <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>, and considers that <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code> describe the dynamics of the phenotypic variance <code class="reqn">VarP=VarA+VarE</code>. Therefore, <code class="reqn">VarE</code> is constrained both by the dynamics of <code class="reqn">VarP</code> and the independent dynamics of <code class="reqn">h^2</code>. 
</p>
<p>The "evolvability" model considers that <code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code> describe the dynamics of <code class="reqn">IA(t) = VarA(t)/(\mu(t)^2)</code>, and <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code> the dynamics of <code class="reqn">IE(t) = VarE(t)/(\mu(t)^2)</code>. 
</p>
<p><strong>Shortcut for active and inactive parameters</strong>
</p>
<p>The user will often have to fit models of different complexity. This can be achieve by manipulating the <code>active</code> vector. <code>c(FALSE,FALSE,FALSE,FALSE)</code> corresponds to a constant-variance model (no dynamic parameter), <code>c(TRUE,FALSE,FALSE,FALSE)</code> to a case in which only <code>kA0</code> and <code>kE0</code> are active, <code>c(TRUE,TRUE,FALSE,FALSE)</code> to active parameters for lags 0 and 1 only, etc. The total number of parameters in the model will be <code class="reqn">3+2*x</code>, where <code class="reqn">x</code> is the number of <code>TRUE</code> in the vector <code>active</code>.
</p>
<p>To bypass the constrains of this shortcut, it is possible to specify the active and inactive parameters through the list of starting values. A combination such as <code>active=c(TRUE,FALSE,TRUE,</code><code>FALSE)</code>, <code>start=list(kA1=0,kE3=NA)</code>, <code>fixed=list(kE2=1)</code> will lead to a model with 8 active parameters (<code>mu0</code>, <code>varA0</code>, <code>varE0</code>, <code>kA0</code>, <code>kE0</code>, <code>kA1</code> (which starting value will be 0), <code>kA2</code>, and <code>kE3</code> (which starting value, specified as <code>NA</code>, will be determined via the function <code>sraStartingvalues</code>. All other parameters are fixed. 
</p>
<p><strong>Parameterization</strong>
</p>
<p>The models thus involve up to 11 parameters: three initial values (<code class="reqn">\mu(1)</code>, <code class="reqn">VarA(1)</code> and <code class="reqn">VarE(1)</code>), four parameters to describe the dynamics of the additive variance (or relative variable such as <code class="reqn">IA</code> or <code class="reqn">h^2</code>) (<code>kA0</code>, <code>kA1</code>, <code>kA2</code>, and <code>kA3</code>), and four parameters for the environmental variance (or <code class="reqn">IE</code>, or <code class="reqn">h^2</code>): <code>kE0</code>, <code>kE1</code>, <code>kE2</code>, and <code>kE3</code>. To make numerical convergence more efficient, the following parameterization was implemented: parameters <code>mu0</code>, <code>logvarA0</code> and <code>logvarE0</code> correspond to the estimates of the initial values of, respectively, the population mean, the logarithm of the additive variance, and the logarithm of the environmental variance. The parameters <code>kA0</code> and <code>kE0</code> are calculated as relative to the initial values of the dynamic variable, e.g. <code>relativekA0</code> = <code class="reqn">k0A/VarA(1)</code> (so that <code>relativekA0</code> has the same unit and the same order of magnitude as <code>kA1</code>, <code>kA2</code> and <code>kA3</code>).
</p>


<h3>Value</h3>

<p>The functions return objects of class <code>srafit</code>, a list containing information about the model, the data, and the parameter estimates. Some standard <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions can be applied to the object, including <code>AIC</code> (<code>AIC.srafit</code>), <code>logLik</code> (<code>logLik.srafit</code>), <code>vcov</code> (<code>vcov.srafit</code>), <code>coef</code> (<code>coef.srafit</code>) <code>confint</code> (<code>confint.srafit</code>), and <code>plot</code> (<code>plot.srafit</code>).
</p>


<h3>Author(s)</h3>

<p> Arnaud Le Rouzic </p>


<h3>References</h3>

 
<p>Le Rouzic, A., Houle, D., and Hansen, T.F. (2011) A modelling framework for the analysis of artificial selection-response time series. Genetics Research. 
</p>
<p>Lande, R., and Arnold, S. (1983) The measurement of selection on correlated characters. Evolution 37:1210-1226.
</p>


<h3>See Also</h3>

 <p><code>sraCstvar</code>, <code>sraDrift</code> and all other mechanistic models, <code>sraAutoregTsMinuslogL</code> and <code>sraAutoregTimeseries</code> for some details about the internal functions, <code>AIC.srafit</code>, <code>logLik.srafit</code>, <code>vcov.srafit</code>, <code>coef.srafit</code>, <code>confint.srafit</code>, <code>plot.srafit</code> for the analysis of the results. </p>


<h3>Examples</h3>

<pre><code class="language-R"># Making the example reproducible
########### Generating a dummy dataset ################

m &lt;- c(12,11,12,14,18,17,19,22,20,19)
v &lt;- c(53,47,97,155,150,102,65,144,179,126)
s &lt;- c(15,14,14,17,21,20,22,25,24,NA)
n &lt;- c(100,80,120,60,100,90,110,80,60,100)

########## Making a sra data set #######################
data &lt;- sraData(phen.mean=m, phen.var=v, phen.sel=s, N=n)

#################### Data Analysis ####################

# Autoregressive models
autor &lt;- sraAutoreg(data)

# Details of the model:
AIC(autor)
coef(autor)
plot(autor)
plot(autor, var=TRUE)

# Alternative scales
autor.log &lt;- sraAutoregLog(data)
autor.herit &lt;- sraAutoregHerit(data)
autor.evolv &lt;- sraAutoregEvolv(data)


# Changes in the complexity of the model:
autor0 &lt;- sraAutoreg(data, active=c(TRUE,TRUE,FALSE,FALSE))
                         
# In case of convergence issues
autor1 &lt;- sraAutoreg(data, active=c(TRUE,TRUE,TRUE,TRUE), rep=2, rand=0.1)

</code></pre>


</div>