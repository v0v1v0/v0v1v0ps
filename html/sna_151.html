<div class="container">

<table style="width: 100%;"><tr>
<td>kpath.census</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Compute Path or Cycle Census Information </h2>

<h3>Description</h3>

<p><code>kpath.census</code> and <code>kcycle.census</code> compute <code class="reqn">k</code>-path or <code class="reqn">k</code>-cycle census statistics (respectively) on one or more input graphs.  In addition to aggregate counts of paths or cycles, results may be disaggregated by vertex and co-membership information may be computed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kcycle.census(dat, maxlen = 3, mode = "digraph", 
    tabulate.by.vertex = TRUE, cycle.comembership = c("none", "sum",
    "bylength"))

kpath.census(dat, maxlen = 3, mode = "digraph", 
    tabulate.by.vertex = TRUE, path.comembership = c("none", "sum",
    "bylength"), dyadic.tabulation = c("none", "sum", "bylength"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cycle.comembership</code></td>
<td>
<p> the type of cycle co-membership information to be tabulated, if any.  <code>"sum"</code> returns a vertex by vertex matrix of cycle co-membership counts; these are disaggregated by cycle length if <code>"bylength"</code> is used.  If <code>"none"</code> is given, no co-membership information is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> one or more input graphs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxlen</code></td>
<td>
<p> the maximum path/cycle length to evaluate. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
 <p><code>"digraph"</code> for directed graphs, or <code>"graph"</code> for undirected graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tabulate.by.vertex</code></td>
<td>
<p> logical; should path or cycle incidence counts be tabulated by vertex? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path.comembership</code></td>
<td>
<p> as per <code>cycle.comembership</code>, for paths rather than cycles.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dyadic.tabulation</code></td>
<td>
<p> the type of dyadic path count information to be tabulated, if any.  <code>"sum"</code> returns a vertex by vertex matrix of source/destination path counts, while <code>"bylength"</code> disaggregates these counts by path length.  Selecting <code>"none"</code> disables this computation. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are several equivalent characterizations of paths and cycles, of which the following is one example.  For an arbitrary graph <code class="reqn">G</code>, a <em>path</em> is a sequence of distinct vertices <code class="reqn">v_1, v_2, \ldots, v_n</code> and included edges such that <code class="reqn">v_i</code> is adjacent to <code class="reqn">v_{i+1}</code> for all <code class="reqn">i \in 1, 2, \ldots, n-1</code> via the pair's included edge. (Contrast this with a <em>walk</em>, in which edges and/or vertices may be repeated.)  A <em>cycle</em> is the union of a path and an edge making <code class="reqn">v_n</code> adjacent to <code class="reqn">v_i</code>.  <code class="reqn">k</code>-paths and <code class="reqn">k</code>-cycles are respective paths and cycles having <code class="reqn">k</code> edges (in the former case) or <code class="reqn">k</code> vertices (in the latter).  The above definitions may be applied in both directed and undirected contexts, by substituting the appropriate notion of adjacency.  (Note that authors do not always employ the same terminology for these concepts, especially in older texts – it is wise to verify the definitions being used in any particular context.)
</p>
<p>A <em>subgraph census statistic</em> is a function which, for any given graph and subgraph, gives the number of copies of the latter contained in the former.  A collection of subgraph census statistics is referred to as a <em>subgraph census</em>; widely used examples include the dyad and triad censuses, implemented in <code>sna</code> by the <code>dyad.census</code> and <code>triad.census</code> functions (respectively).  <code>kpath.census</code> and <code>kcycle.census</code> compute a range of census statistics related to <code class="reqn">k</code>-paths and <code class="reqn">k</code>-cycles, including:
</p>

<ul>
<li>
<p> Aggregate counts of paths/cycles by length (i.e., <code class="reqn">k</code>). 
</p>
</li>
<li>
<p> Counts of paths/cycles to which each vertex belongs (when <code>tabulate.byvertex==TRUE</code>). 
</p>
</li>
<li>
<p> Counts of path/cycle co-memberships, potentially disaggregated by length (when the appropriate co-membership argument is set to <code>bylength</code>). 
</p>
</li>
<li>
<p> For <code>path.census</code>, counts of the total number of paths from each vertex to each other vertex, possibly disaggregated by length (if <code>dyadic.tabulation=="bylength"</code>).
</p>
</li>
</ul>
<p>The length of the maximum-length path/cycle to compute is given by <code>maxlen</code>.  These calculations are intrinsically expensive (path/cycle computation is NP complete in the general case), and users should hence be wary when increasing <code>maxlen</code>.  On the other hand, it may be possible to enumerate even long paths or cycles on a very sparse graph; scaling is approximately <code class="reqn">c^k</code>, where <code class="reqn">k</code> is given by <code>maxlen</code> and <code class="reqn">c</code> is the size of the largest dense cluster.  
</p>
<p>The paths or cycles computed by this function are directed if <code>mode=="digraph"</code>, or undirected if <code>mode=="graph"</code>.  Failing to set <code>mode</code> correctly may result in problematic behavior.
</p>


<h3>Value</h3>

<p>For <code>kpath.census</code>, a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>path.count </code></td>
<td>
<p>If <code>tabulate.byvertex==FALSE</code>, a vector of aggregate counts by path length.  Otherwise, a matrix whose first column is a vector of aggregate path counts, and whose succeeding columns contain vectors of path counts for each vertex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path.comemb </code></td>
<td>
<p>If <code>path.comembership!="none"</code>, a matrix or array containing co-membership in paths by vertex pairs.  If <code>path.comembership=="sum"</code>, only a matrix of co-memberships is returned; if <code>bylength</code> is used, however, co-memberships are returned in a <code>maxlen</code> by <code class="reqn">n</code> by <code class="reqn">n</code> array whose <code class="reqn">i,j,k</code>th cell is the number of paths of length <code class="reqn">i</code> containing <code>j</code> and <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths.bydyad </code></td>
<td>
<p>If <code>dyadic.tabulation!="none"</code>, a matrix or array containing the number of paths originating at a particular vertex and terminating.  If <code>bylength</code> is used, dyadic path counts are supplied via a <code>maxlen</code> by <code class="reqn">n</code> by <code class="reqn">n</code> array whose <code class="reqn">i,j,k</code>th cell is the number of paths of length <code class="reqn">i</code> starting at <code>j</code> and ending with <code>k</code>.  If <code>sum</code> is used instead, only a matrix whose <code class="reqn">i,j</code> cell contains the total number of paths from <code class="reqn">i</code> to <code class="reqn">j</code> is returned.</p>
</td>
</tr>
</table>
<p>For <code>kcycle.census</code>, a similar list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cycle.count </code></td>
<td>
<p>If <code>tabulate.byvertex==FALSE</code>, a vector of aggregate counts by cycle length.  Otherwise, a matrix whose first column is a vector of aggregate cycle counts, and whose succeeding columns contain vectors of cycle counts for each vertex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle.comemb </code></td>
<td>
<p>If <code>cycle.comembership!="none"</code>, a matrix or array containing co-membership in cycles by vertex pairs.  If <code>cycle.comembership=="sum"</code>, only a matrix of co-memberships is returned; if <code>bylength</code> is used, however, co-memberships are returned in a <code>maxlen</code> by <code class="reqn">n</code> by <code class="reqn">n</code> array whose <code class="reqn">i,j,k</code>th cell is the number of cycles of length <code class="reqn">i</code> containing <code>j</code> and <code>k</code>.</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p> The computational cost of calculating paths and cycles grows very sharply in both <code>maxlen</code> and network density.  Be wary of setting <code>maxlen</code> greater than 5-6, unless you know what you are doing.  Otherwise, the expected completion time for your calculation may exceed your life expectancy (and those of subsequent generations). </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

 
<p>Butts, C.T.  (2006).  “Cycle Census Statistics for Exponential Random Graph Models.”  IMBS Technical Report MBS 06-05, University of California, Irvine.
</p>
<p>West, D.B.  (1996).  <em>Introduction to Graph Theory.</em>  Upper Saddle River, N.J.: Prentice Hall.
</p>


<h3>See Also</h3>

 <p><code>dyad.census</code>, <code>triad.census</code>, <code>clique.census</code>, <code>geodist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">g&lt;-rgraph(20,tp=1.5/19)

#Obtain paths by vertex, with dyadic path counts
pc&lt;-kpath.census(g,maxlen=5,dyadic.tabulation="sum")
pc$path.count                                 #Examine path counts
pc$paths.bydyad                               #Examine dyadic paths

#Obtain aggregate cycle counts, with co-membership by length
cc&lt;-kcycle.census(g,maxlen=5,tabulate.by.vertex=FALSE,
    cycle.comembership="bylength")
cc$cycle.count                             #Examine cycle counts
cc$cycle.comemb[1,,]                       #Co-membership for 2-cycles
cc$cycle.comemb[2,,]                       #Co-membership for 3-cycles
cc$cycle.comemb[3,,]                       #Co-membership for 4-cycles
</code></pre>


</div>