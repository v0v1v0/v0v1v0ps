<div class="container">

<table style="width: 100%;"><tr>
<td>adiag1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Binds arrays corner-to-corner</h2>

<h3>Description</h3>

<p>Array generalization of blockdiag()
</p>


<h3>Usage</h3>

<pre><code class="language-R">adiag1(... , pad=as.integer(0), do.dimnames=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arrays to be binded together</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pad</code></td>
<td>
<p>Value to pad array with; note default keeps integer status
of arrays</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.dimnames</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
dimnames if possible.  Set to <code>FALSE</code> if performance is an
issue</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Binds any number of arrays together, corner-to-corner.  Because the
function is associative provided pad is of length 1, this page
discusses the two array case.
</p>
<p>If <code>x=adiag1(a,b)</code> and <code>dim(a)=c(a_1,...,a_d)</code>,
<code>dim(b)=c(b_1,...,b_d)</code>; then <code>all(dim(x)==dim(a)+dim(b))</code> and
<code>x[1:a_1,...,1:a_d]=a</code> and
<code>x[(a_1+1):(a_1+b_1),...,(a_d+1):(a_d+b_d)]=b</code>.
</p>
<p>Dimnames are preserved, if both arrays have non-null dimnames, and
<code>do.dimnames</code> is <code>TRUE</code>.
</p>
<p>Argument pad is usually a length-one vector, but any vector is
acceptable; standard recycling is used.  Be aware that the output array
(of dimension <code>dim(a)+dim(b)</code>) is filled with (copies of)
<code>pad</code> <em>before</em> <code>a</code> and <code>b</code> are copied.  This can be
confusing.
</p>


<h3>Value</h3>

<p>Returns an array of dimensions <code>dim(a)+dim(b)</code> as described above.
</p>


<h3>Note</h3>

<p>In <code>adiag1(a,b)</code>, if <code>a</code> is a length-one vector, it is coerced
to an array of dimensions <code>rep(1,length(dim(b)))</code>; likewise
<code>b</code>.  If both <code>a</code> and <code>b</code> are length-one vectors, return
<code>diag(c(a,b))</code>.
</p>
<p>If <code>a</code> and <code>b</code> are arrays, function <code>adiag1()</code> requires
<code>length(dim(a))==length(dim(b))</code> (the function does not guess which
dimensions have been dropped; see examples section).  In particular,
note that vectors are not coerced except if of length one.
</p>
<p><code>adiag1()</code> is used when padding magic hypercubes in the context
of evaluating subarray sums.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf with some additions by Robin Hankin</p>


<h3>See Also</h3>

<p><code>mmer</code> â€“ the core function of the package </p>


<h3>Examples</h3>

<pre><code class="language-R"> a &lt;- array( 1,c(2,2))
 b &lt;- array(-1,c(2,2))
 adiag1(a,b)

 ## dropped dimensions can count:

 b2 &lt;- b1 &lt;- b
 dim(a) &lt;- c(2,1,2)
 dim(b1) &lt;- c(2,2,1)
 dim(b2) &lt;- c(1,2,2)

 dim(adiag1(a,b1))
 dim(adiag1(a,b2))

## dimnames are preserved if not null:

a &lt;- matrix(1,2,2,dimnames=list(col=c("red","blue"),size=c("big","small"))) 
b &lt;- 8
dim(b) &lt;- c(1,1)
dimnames(b) &lt;- list(col=c("green"),size=c("tiny"))
adiag1(a,b)   #dimnames preserved
adiag1(a,8)   #dimnames lost because second argument has none.

## non scalar values for pad can be confusing:
q &lt;- matrix(0,3,3)
adiag1(q,q,pad=1:4)

## following example should make the pattern clear:
adiag1(q,q,pad=1:36)


# Now, a use for arrays with dimensions of zero extent:
z &lt;- array(dim=c(0,3))
colnames(z) &lt;- c("foo","bar","baz")

adiag1(a,z)        # Observe how this has
                  # added no (ie zero) rows to "a" but
                  # three extra columns filled with the pad value

adiag1(a,t(z))
adiag1(z,t(z))     # just the pad value

</code></pre>


</div>