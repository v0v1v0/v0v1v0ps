<div class="container">

<table style="width: 100%;"><tr>
<td>bregman3_sf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Bregman scoring function (type 3, QLIKE scoring function)
</h2>

<h3>Description</h3>

<p>The function bregman3_sf computes the Bregman scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The Bregman scoring function is defined by eq. (18) in Gneiting (2011) and the
form implemented here for <code class="reqn">\phi(x) = -\log(x)</code> is defined by eq. (20) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bregman3_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Bregman scoring function (type 3) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := (y/x) - \log(y/x) - 1</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of Bregman losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 3 since it corresponds to a specific
type of <code class="reqn">\phi(x)</code> of the general form of the Bregman scoring function
defined by eq. (18) in Gneiting (2011).
</p>
<p>For details on the Bregman scoring function, see Savage 1971, Banerjee et al.
(2005) and Gneiting (2011). For details on the specific form implemented here,
see the QLIKE scoring function in Patton (2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The Bregman scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The herein implemented Bregman scoring function is strictly consistent for the
mean functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code> and
<code class="reqn">E_F[\log(Y)]</code> exist and are finite (Savage 1971, Gneiting 2011).
</p>


<h3>References</h3>

<p>Banerjee A, Guo X, Wang H (2005) On the optimality of conditional expectation as
a Bregman predictor. <em>IEEE Transactions on Information Theory</em>
<b>51(7)</b>:2664–2669. <a href="https://doi.org/10.1109/TIT.2005.850145">doi:10.1109/TIT.2005.850145</a>.
</p>
<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746–762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246–256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783–810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute the Bregman scoring function (type 3, QLIKE scoring function).

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$bregman3_penalty &lt;- bregman3_sf(x = df$x, y = df$y)

print(df)
</code></pre>


</div>