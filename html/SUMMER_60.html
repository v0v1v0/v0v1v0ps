<div class="container">

<table style="width: 100%;"><tr>
<td>simPopInternal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal functions for population simulation</h2>

<h3>Description</h3>

<p>Functions for calculating valuable quantities and for drawing from important 
distributions for population simulation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getExpectedNperEA(easpa, popMat, level = c("grid", "EA"), pixelIndexMat = NULL)

getSortIndices(
  i,
  urban = TRUE,
  popMat,
  stratifyByUrban = TRUE,
  validationPixelI = NULL
)

rStratifiedMultnomial(n, popMat, easpa, stratifyByUrban = TRUE)

rStratifiedMultnomialBySubarea(
  n,
  popMat,
  easpa,
  stratifyByUrban = TRUE,
  poppsub = NULL,
  min1PerSubarea = TRUE,
  minSample = 1
)

rMyMultinomial(
  n,
  i,
  stratifyByUrban = TRUE,
  urban = TRUE,
  popMat = NULL,
  easpa = NULL,
  min1PerSubarea = FALSE,
  method = c("mult1", "mult", "indepMH"),
  minSample = 1
)

rMyMultinomialSubarea(
  n,
  i,
  easpsub,
  stratifyByUrban = TRUE,
  urban = TRUE,
  popMat = NULL
)

rmultinom1(
  n = 1,
  size,
  prob,
  maxSize = 8000 * 8000,
  method = c("mult1", "mult", "indepMH"),
  verbose = FALSE,
  minSample = 100,
  maxExpectedSizeBeforeSwitch = 1000 * 1e+07,
  init = NULL,
  burnIn = floor(n/4),
  filterEvery = 10,
  zeroProbZeroSamples = TRUE,
  allowSizeLessThanK = FALSE
)

sampleNMultilevelMultinomial(
  nDraws = ncol(pixelIndexMat),
  pixelIndexMat = NULL,
  urbanMat = NULL,
  areaMat = NULL,
  easpaList,
  popMat,
  stratifyByUrban = TRUE,
  verbose = TRUE,
  returnEAinfo = FALSE,
  minHHPerEA = 25,
  fixHHPerEA = NULL,
  fixPopPerHH = NULL
)

sampleNMultilevelMultinomialFixed(
  clustersPerPixel,
  nDraws = ncol(pixelIndices),
  pixelIndices = NULL,
  urbanVals = NULL,
  areaVals = NULL,
  easpa,
  popMat,
  stratifyByUrban = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>easpa</code></td>
<td>
<p>Census frame. See <code>simPopCustom</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popMat</code></td>
<td>
<p>data.frame of pixellated grid of population densities. See <code>simPopCustom</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Whether to calculate results at the integration grid or EA level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixelIndexMat</code></td>
<td>
<p>Matrix of pixel indices associated with each EA and draw. Not 
required by getExpectedNperEA unless level == "EA"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>Index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>urban</code></td>
<td>
<p>If TRUE, calculate only for urban part of the area. If FALSE, for only rural part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stratifyByUrban</code></td>
<td>
<p>whether or not to stratify calculations by urban/rural classification</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validationPixelI</code></td>
<td>
<p>CURRENTLY FOR TESTING PURPOSES ONLY a set of indices of pixels for which we want to simulate populations (used for pixel level validation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poppsub</code></td>
<td>
<p>Population per subarea. See <code>simPopCustom</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min1PerSubarea</code></td>
<td>
<p>Whether or not to ensure there is at least 1 EA per subarea. See <code>simPopCustom</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minSample</code></td>
<td>
<p>The minimum number of samples per 'chunk' of samples for truncated multinomial sampling. Defaults to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>If min1PerSubarea is TRUE, the sampling method for the truncated multinomial to use with rmulitnom1. rmultinom1 automatically 
switches between them depending on the number of expected samples. The methods are:
</p>

<dl>
<dt>mult1</dt>
<dd>
<p>rejection sampling from multinomial plus 1 in each category</p>
</dd>
<dt>mult</dt>
<dd>
<p>rejection sampling from multinomial if any category has zero count</p>
</dd>
<dt>indepMH</dt>
<dd>
<p>independent Metropolis-Hastings using multinomial plus 1 distribution as proposal</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>easpsub</code></td>
<td>
<p>This could either be total EAs per subarea, or subarea crossed with urban or 
rural if stratifyByUrban is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Multinomial size parameter. See <code>rmultinom</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>Multinomial probability vector parameter. See <code>rmultinom</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxSize</code></td>
<td>
<p>The maximum number of elements in a matrix drawn from the proposal distribution per sample chunk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print progress as the function proceeds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxExpectedSizeBeforeSwitch</code></td>
<td>
<p>Max expected number of samples / k, the number of categories, before switching method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Initial sample if method is 'indepMH'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnIn</code></td>
<td>
<p>Number of initial samples before samples are collected if method is 'indepMH'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filterEvery</code></td>
<td>
<p>Store only every filterEvery samples if method is i'indepMH'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeroProbZeroSamples</code></td>
<td>
<p>If TRUE, set samples for parts of prob vector that are zero to zero. Otherwise they are set to one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowSizeLessThanK</code></td>
<td>
<p>If TRUE, then if size &lt; the number of categories (k), returns matrix where each 
column is vector of size ones and k - size zeros. If FALSE, throws an error if size &lt; k</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nDraws</code></td>
<td>
<p>Number of draws</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>urbanMat</code></td>
<td>
<p>Matrix of urbanicities associated with each EA and draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areaMat</code></td>
<td>
<p>Matrix of areas associated with each EA and draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>easpaList</code></td>
<td>
<p>A list of length n with each element being of the format of easpa 
giving the number of households and EAs 
per stratum. It is assumed that the number of EAs per stratum is 
the same in each list element. If easpaList is a data frame, 
number of households per stratum is assumed constant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnEAinfo</code></td>
<td>
<p>Whether a data frame at the EA level is desired</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minHHPerEA</code></td>
<td>
<p>The minimum number of households per EA (defaults to 25, since 
that is the number of households sampled per DHS cluster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixHHPerEA</code></td>
<td>
<p>If not NULL, the fixed number of households per EA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixPopPerHH</code></td>
<td>
<p>If not NULL, the fixed target population per household</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustersPerPixel</code></td>
<td>
<p>CURRENTLY FOR TESTING PURPOSES ONLY a vector of length nIntegrationPoints specifying the number of clusters per pixel if they are fixed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixelIndices</code></td>
<td>
<p>A nEA x n matrix of pixel indices associated with each EA per simulation/draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>urbanVals</code></td>
<td>
<p>A nEA x n matrix of urbanicities associated with each EA per simulation/draw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>areaVals</code></td>
<td>
<p>A nEA x n matrix of area names associated with each EA per simulation/draw</p>
</td>
</tr>
</table>
<h3>Functions</h3>


<ul>
<li> <p><code>getExpectedNperEA()</code>: Calculates expected denominator per enumeration area.
</p>
</li>
<li> <p><code>getSortIndices()</code>: For recombining separate multinomials into the draws over all grid points
</p>
</li>
<li> <p><code>rStratifiedMultnomial()</code>: Gives nIntegrationPoints x n matrix of draws from the stratified multinomial with values 
corresponding to the value of |C^g| for each pixel, g (the number of EAs/pixel)
</p>
</li>
<li> <p><code>rStratifiedMultnomialBySubarea()</code>: Gives nIntegrationPoints x n matrix of draws from the stratified multinomial with values
</p>
</li>
<li> <p><code>rMyMultinomial()</code>: 
</p>
</li>
<li> <p><code>rMyMultinomialSubarea()</code>: 
</p>
</li>
<li> <p><code>rmultinom1()</code>: Random (truncated) multinomial draws conditional on the number of each type being at least one
</p>
</li>
<li> <p><code>sampleNMultilevelMultinomial()</code>: Take multilevel multinomial draws first from joint distribution of 
number of households per EA given the total per stratum, and then from the joint 
distribution of the total target population per household given 
the total per stratum
</p>
</li>
<li> <p><code>sampleNMultilevelMultinomialFixed()</code>: Same as sampleNMultilevelMultinomial, except the number of EAs per pixel is fixed
</p>
</li>
</ul>
</div>