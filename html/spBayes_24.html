<div class="container">

<table style="width: 100%;"><tr>
<td>spPredict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for new locations given a model object
</h2>

<h3>Description</h3>

<p>The function <code>spPredict</code> collects posterior predictive samples
for a set of new locations given a <code>spLM</code>, <code>spMvLM</code>,
<code>spGLM</code>, <code>spMvGLM</code>,
<code>spMisalignLM</code>, <code>spMisalignGLM</code>,
<code>bayesGeostatExact</code>, <code>bayesLMConjugate</code> <code>bayesLMRef</code> or <code>spSVC</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spPredict(sp.obj, pred.coords, pred.covars, joint=FALSE, start=1, end, thin=1,
          verbose=TRUE, n.report=100, n.omp.threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sp.obj</code></td>
<td>
<p>an object returned by <code>spLM</code>, <code>spMvLM</code>,
<code>spGLM</code>, <code>spMvGLM</code>,
<code>spMisalignLM</code>, <code>spMisalignGLM</code>,
<code>bayesGeostatExact</code>, <code>bayesLMConjugate</code> or
<code>bayesLMRef</code>. For <code>spSVC</code>, <code>sp.obj</code> is an object from <code>spRecover</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.coords</code></td>
<td>
<p>for <code>spLM</code>, <code>spMvLM</code>,
<code>spGLM</code>, <code>spMvGLM</code>, and <code>bayesGeostatExact</code> <code>pred.coords</code> is a <code class="reqn">n^{\ast} \times 2</code> matrix of <code class="reqn">n^{\ast}</code> prediction
location coordinates in <code class="reqn">R^2</code> (e.g., easting and northing).
For <code>spMisalignLM</code> and
<code>spMisalignGLM</code> <code>pred.coords</code> is a list of <code class="reqn">q</code> <code class="reqn">n^{\ast}_i \times 2</code>
matrices of prediction location coordinates where
<code class="reqn">i=(1,2,\ldots,q)</code>. For <code>spSVC</code>
<code>pred.coords</code> is an <code class="reqn">n^{\ast} \times m</code> matrix of <code class="reqn">n^{\ast}</code> prediction
location coordinates in <code class="reqn">R^m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.covars</code></td>
<td>
<p>for <code>spLM</code>, <code>spMvLM</code>,
<code>spGLM</code>, <code>spMvGLM</code>,
<code>bayesGeostatExact</code>, <code>bayesLMConjugate</code>,
<code>bayesLMRef</code>, and <code>spSVC</code> <code>pred.covars</code> is a <code class="reqn">n^{\ast} \times p</code> design matrix associated
with the new locations (including the intercept if one is specified
in <code>sp.obj</code>'s formula argument).  If this is a multivariate prediction defined
by <code class="reqn">q</code> models, i.e., for <code>spMvLM</code> or <code>spMvGLM</code>, the multivariate design matrix can be created
by passing a list of the <code class="reqn">q</code> univariate design matrices to
the <code>mkMvX</code> function.  For <code>spMisalignLM</code> and
<code>spMisalignGLM</code> <code>pred.covars</code> is a list of <code class="reqn">q</code> <code class="reqn">n^{\ast}_i \times p_i</code>
design matrices where <code class="reqn">i=(1,2,\ldots,q)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>specifies whether posterior samples should be drawn
from the joint or point-wise predictive distribution. This argument is only
implemented for <code>spSVC</code>. Prediction for all other models
uses the point-wise posterior predictive distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>specifies the first sample included in the composition sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>specifies the last sample included in the composition.
The default is to use all posterior samples in <code>sp.obj</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>a sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report sampling progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. This argument is only
implemented for <code>spSVC</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p.y.predictive.samples</code></td>
<td>
<p>a matrix that holds the response variable(s) posterior
predictive samples. For multivariate models <code>spMvLM</code> or
<code>spMvGLM</code> the rows of this matrix
correspond to the predicted locations and the columns are the posterior
predictive samples.  If prediction is for <code class="reqn">q</code> response
variables the <code>p.y.predictive.samples</code> matrix has
<code class="reqn">qn^{\ast}</code> rows, where <code class="reqn">n^{\ast}</code> is the number of
prediction locations.  The predictions for locations are held in rows
<code class="reqn">1:q, (q+1):2q, \ldots, ((n^{\ast}-1)q+1):qn^{\ast}</code> (i.e., the samples for the first location's <code class="reqn">q</code>
response variables are in rows <code class="reqn">1:q</code>, second location in rows <code class="reqn">(q+1):2q</code>,
etc.).
</p>
<p>For <code>spMisalignLM</code> and <code>spMisalignGLM</code>
the posterior predictive samples are organized differently in
<code>p.y.predictive.samples</code> with the first response variable
<code class="reqn">n^{\ast}_1</code> locations held in rows <code class="reqn">1\ldots,n^{\ast}_1</code> rows, then the
next response variable samples held in the
<code class="reqn">(n^{\ast}_1+1),\ldots,(n^{\ast}_1+n^{\ast}_2)</code>, etc.
</p>
<p>For <code>spSVC</code> given the <code class="reqn">r</code> space-varying
coefficients, <code>p.y.predictive.samples</code> has
<code class="reqn">rn^{\ast}</code> rows and the columns are the posterior
predictive samples. The predictions for coefficient are held in rows
<code class="reqn">1:r, (r+1):2r, \ldots, ((n^{\ast}-1)r+1):rn^{\ast}</code> (i.e., the samples for the first location's
<code class="reqn">r</code> regression coefficients are in rows 1:r, second location in rows <code class="reqn">(r+1):2r</code>,
etc.).
</p>
<p>For <code>spGLM</code> and <code>spMisalignGLM</code> the <code>p.y.predictive.samples</code> matrix holds
posterior predictive samples <code class="reqn">\frac{1}{1+\exp(-x(s)'\beta-w(s))}</code> and
<code class="reqn">\exp(x(s)'\beta+w(s))</code> for
<code>family</code> binomial and poisson, respectively. Here <code class="reqn">s</code> indexes
the prediction location, <code class="reqn">\beta</code> is the vector of regression
coefficients, and <code class="reqn">w</code> is the associated spatial random
spatial effect. These values can be fed directly into <code>rbinom</code>
or <code>rpois</code> to generate the realization from the respective
distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.predictive.samples</code></td>
<td>
<p>a matrix organized the same as
<code>p.y.predictive.samples</code>, that holds the spatial random effects posterior
predictive samples. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.predictive.samples.list</code></td>
<td>
<p>only returned for
<code>spSVC</code>. This provides <code>p.w.predictive.samples</code> in a
different (more convenient form). Elements in this list hold
samples for each of the <code class="reqn">r</code> coefficients. List element names
indicate either the coefficient index or name specified in
<code>spSVC</code>'s <code>svc.cols</code> argument. The sample matrices
are <code class="reqn">n^{\ast}</code> rows and predictive samples along the columns. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.tilde.beta.predictive.samples.list</code></td>
<td>
<p>only returned for
<code>spSVC</code>. Like <code>p.w.predictive.samples.list</code> but with
the addition of the corresponding <code class="reqn">\beta</code> posterior
samples (i.e., <code class="reqn">\beta+w(s)</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.scale.pred.covars</code></td>
<td>
<p>only returned for the
<code>spSVC</code> when its <code>center.scale</code> argument is <code>TRUE</code>. This is the
prediction design matrix centered and scaled with respect to column means and variances of the design matrix used to estimate model
parameters, i.e., the one defined in <code>spSVC</code>'s formula argument.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton, FL.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>,
63:1â€“28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Bayesian spatially varying
coefficient models in the spBayes R package. <a href="https://arxiv.org/abs/1903.03028">https://arxiv.org/abs/1903.03028</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 200
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)
sigma.sq &lt;- 10
tau.sq &lt;- 0.01
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

##partition the data for out of sample prediction
mod &lt;- 1:100
y.mod &lt;- y[mod]
X.mod &lt;- X[mod,]
coords.mod &lt;- coords[mod,]

n.samples &lt;- 1000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)
tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)
priors &lt;- list("beta.Flat", "phi.Unif"=c(3/1, 3/0.1),
               "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 0.01))
cov.model &lt;- "exponential"

m.1 &lt;- spLM(y.mod~X.mod-1, coords=coords.mod, starting=starting, tuning=tuning,
priors=priors, cov.model=cov.model, n.samples=n.samples)

m.1.pred &lt;- spPredict(m.1, pred.covars=X, pred.coords=coords,
start=0.5*n.samples)

y.hat &lt;- apply(m.1.pred$p.y.predictive.samples, 1, mean)

quant &lt;- function(x){quantile(x, prob=c(0.025, 0.5, 0.975))}

y.hat &lt;- apply(m.1.pred$p.y.predictive.samples, 1, quant)

plot(y, y.hat[2,], pch=19, cex=0.5, xlab="observed y", ylab="predicted y")
arrows(y[-mod], y.hat[2,-mod], y[-mod], y.hat[1,-mod], angle=90, length=0.05)
arrows(y[-mod], y.hat[2,-mod], y[-mod], y.hat[3,-mod], angle=90, length=0.05)

## End(Not run)
</code></pre>


</div>