<div class="container">

<table style="width: 100%;"><tr>
<td>sdmTMBcontrol</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimization control options</h2>

<h3>Description</h3>

<p><code>sdmTMB()</code> and <code>stats::nlminb()</code> control options.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sdmTMBcontrol(
  eval.max = 2000L,
  iter.max = 1000L,
  normalize = FALSE,
  nlminb_loops = 1L,
  newton_loops = 1L,
  mgcv = deprecated(),
  quadratic_roots = FALSE,
  start = NULL,
  map_rf = deprecated(),
  map = NULL,
  lower = NULL,
  upper = NULL,
  censored_upper = NULL,
  multiphase = TRUE,
  profile = FALSE,
  get_joint_precision = TRUE,
  parallel = getOption("sdmTMB.cores", 1L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eval.max</code></td>
<td>
<p>Maximum number of evaluations of the objective function
allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>Logical: use <code>TMB::normalize()</code> to normalize the process
likelihood using the Laplace approximation? Can result in a substantial
speed boost in some cases. This used to default to <code>FALSE</code> prior to
May 2021. Currently not working for models fit with REML or random intercepts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb_loops</code></td>
<td>
<p>How many times to run <code>stats::nlminb()</code> optimization.
Sometimes restarting the optimizer at the previous best values aids
convergence. If the maximum gradient is still too large,
try increasing this to <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newton_loops</code></td>
<td>
<p>How many Newton optimization steps to try after running
<code>stats::nlminb()</code>. This sometimes aids convergence by further reducing the
log-likelihood gradient with respect to the fixed effects. This calculates
the Hessian at the current MLE with <code>stats::optimHess()</code> using a
finite-difference approach and uses this to update the fixed effect
estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mgcv</code></td>
<td>
<p><strong>Deprecated</strong> Parse the formula with <code>mgcv::gam()</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadratic_roots</code></td>
<td>
<p>Experimental feature for internal use right now; may
be moved to a branch. Logical: should quadratic roots be calculated? Note:
on the sdmTMB side, the first two coefficients are used to generate the
quadratic parameters. This means that if you want to generate a quadratic
profile for depth, and depth and depth^2 are part of your formula, you need
to make sure these are listed first and that an intercept isn't included.
For example, <code>formula = cpue ~ 0 + depth + depth2 + as.factor(year)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A named list specifying the starting values for parameters. You
can see the necessary structure by fitting the model once and inspecting
<code>your_model$tmb_obj$env$parList()</code>. Elements of <code>start</code> that are specified
will replace the default starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map_rf</code></td>
<td>
<p><strong>Deprecated</strong> use <code style="white-space: pre;">⁠spatial = 'off', spatiotemporal = 'off'⁠</code> in
<code>sdmTMB()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>A named list with factor <code>NA</code>s specifying parameter values that
should be fixed at a constant value. See the documentation in
<code>TMB::MakeADFun()</code>. This should usually be used with <code>start</code> to specify the
fixed value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>An optional named list of lower bounds within the optimization.
Parameter vectors with the same name (e.g., <code>b_j</code> or <code>ln_kappa</code> in some
cases) can be specified as a numeric vector. E.g.
<code>lower = list(b_j = c(-5, -5))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>An optional named list of upper bounds within the optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censored_upper</code></td>
<td>
<p>An optional vector of upper bounds for
<code>sdmTMBcontrol()</code>. Values of <code>NA</code> indicate an unbounded right-censored to
distribution, values greater that the observation indicate and upper bound,
and values equal to the observation indicate no censoring.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiphase</code></td>
<td>
<p>Logical: estimate the fixed and random effects in phases?
Phases are usually faster and more stable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profile</code></td>
<td>
<p>Logical: should population-level/fixed effects be profiled
out of the likelihood? These are then appended to the random effects
vector without the Laplace approximation. See <code>TMB::MakeADFun()</code>. <em>This
can dramatically speed up model fit if there are many fixed effects but is
experimental at this stage.</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_joint_precision</code></td>
<td>
<p>Logical. Passed to <code>getJointPrecision</code> in
<code>TMB::sdreport()</code>. Must be <code>TRUE</code> to use simulation-based methods in
<code>predict.sdmTMB()</code> or <code style="white-space: pre;">⁠[get_index_sims()]⁠</code>. If not needed, setting this
<code>FALSE</code> will reduce object size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Argument currently ignored. For parallel processing with 3
cores, as an example, use <code>TMB::openmp(n = 3, DLL = "sdmTMB")</code>. But be
careful, because it's not always faster with more cores and there is
definitely an upper limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Anything else. See the 'Control parameters' section of
<code>stats::nlminb()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Usually used within <code>sdmTMB()</code>. For example:
</p>
<div class="sourceCode"><pre>sdmTMB(..., control = sdmTMBcontrol(newton_loops = 2))
</pre></div>


<h3>Value</h3>

<p>A list of control arguments
</p>


<h3>Examples</h3>

<pre><code class="language-R">sdmTMBcontrol()
</code></pre>


</div>