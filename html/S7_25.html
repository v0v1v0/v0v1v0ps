<div class="container">

<table style="width: 100%;"><tr>
<td>convert</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert an object from one type to another</h2>

<h3>Description</h3>

<p><code>convert(from, to)</code> is a built-in generic for converting an object from
one type to another. It is special in three ways:
</p>

<ul>
<li>
<p> It uses double-dispatch, because conversion depends on both <code>from</code> and
<code>to</code>.
</p>
</li>
<li>
<p> It uses non-standard dispatch because <code>to</code> is a class, not an object.
</p>
</li>
<li>
<p> It doesn't use inheritance for the <code>to</code> argument. To understand
why, imagine you have written methods to objects of various types to
<code>classParent</code>. If you then create a new <code>classChild</code> that inherits from
<code>classParent</code>, you can't expect the methods written for <code>classParent</code>
to work because those methods will return <code>classParent</code> objects, not
<code>classChild</code> objects.
</p>
</li>
</ul>
<p><code>convert()</code> provides a default implementation when <code>from</code> inherits from
<code>to</code>. This default strips any properties that <code>from</code> possesses that <code>to</code>
does not.
</p>
<p>If you are converting an object solely for the purposes of accessing a method
on a superclass, you probably want <code>super()</code> instead. See its docs for more
details.
</p>


<h4>S3 &amp; S4</h4>

<p><code>convert()</code> plays a similar role to the convention of defining <code>as.foo()</code>
functions/generics in S3, and to <code>as()</code>/<code>setAs()</code> in S4.
</p>



<h3>Usage</h3>

<pre><code class="language-R">convert(from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>An S7 object to convert.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>An S7 class specification, passed to <code>as_class()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed to custom <code>convert()</code> methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Either <code>from</code> coerced to class <code>to</code>, or an error if the coercion
is not possible.
</p>


<h3>Examples</h3>

<pre><code class="language-R">foo1 &lt;- new_class("foo1", properties = list(x = class_integer))
foo2 &lt;- new_class("foo2", foo1, properties = list(y = class_double))

# S7 provides a default implementation for coercing an object to one of
# its parent classes:
convert(foo2(x = 1L, y = 2), to = foo1)

# For all other cases, you'll need to provide your own.
try(convert(foo1(x = 1L), to = class_integer))

method(convert, list(foo1, class_integer)) &lt;- function(from, to) {
  from@x
}
convert(foo1(x = 1L), to = class_integer)

# Note that conversion does not respect inheritance so if we define a
# convert method for integer to foo1
method(convert, list(class_integer, foo1)) &lt;- function(from, to) {
  foo1(x = from)
}
convert(1L, to = foo1)

# Converting to foo2 will still error
try(convert(1L, to = foo2))
# This is probably not surprising because foo2 also needs some value
# for `@y`, but it definitely makes dispatch for convert() special
</code></pre>


</div>