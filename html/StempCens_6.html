<div class="container">

<table style="width: 100%;"><tr>
<td>EstStempCens</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ML estimation in spatio-temporal model with censored/missing responses</h2>

<h3>Description</h3>

<p>Return the maximum likelihood estimates of the unknown parameters of spatio-temporal model with censored/missing responses.
The estimates are obtained using SAEM algorithm.
The function also computes the observed information matrix using the method developed by Louis (1982).
The types of censoring considered are left, right, interval or missing values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EstStempCens(
  y,
  x,
  cc,
  time,
  coord,
  LI,
  LS,
  init.phi,
  init.rho,
  init.tau2,
  tau2.fixo = FALSE,
  type.Data = "balanced",
  method = "nlminb",
  kappa = 0,
  type.S = "exponential",
  IMatrix = TRUE,
  lower.lim = c(0.01, -0.99, 0.01),
  upper.lim = c(30, 0.99, 20),
  M = 20,
  perc = 0.25,
  MaxIter = 300,
  pc = 0.2,
  error = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or vector of covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cc</code></td>
<td>
<p>a vector of censoring indicators. For each observation: <code>1</code> if censored/missing and <code>0</code> if non-censored/non-missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>a vector of time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord</code></td>
<td>
<p>a matrix of coordinates of the spatial locations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LI</code></td>
<td>
<p>lower limit of detection. For each observation: if non-censored/non-missing <code>=y</code>, if left-censored/missing <code>=-Inf</code> or <code>=LOD</code> if right/interval-censored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LS</code></td>
<td>
<p>upper limit of detection. For each observation: if non-censored/non-missing <code>=y</code>, if right-censored/missing <code>=Inf</code> or <code>=LOD</code> if left/interval-censored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.phi</code></td>
<td>
<p>initial value of the spatial scaling parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.rho</code></td>
<td>
<p>initial value of the time scaling parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.tau2</code></td>
<td>
<p>initial value of the the nugget effect parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2.fixo</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Indicate if the nugget effect (<code class="reqn">\tau^2</code>) parameter must be fixed.
By default = <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.Data</code></td>
<td>
<p>type of the data: '<code>balanced</code>' for balanced data and '<code>unbalanced</code>' for unbalanced data. By default = <code>balanced</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>optimization method used to estimate (<code class="reqn">\phi</code>, <code class="reqn">\rho</code> and <code class="reqn">\tau^2</code>):
'<code>optim</code>' for the function <code>optim</code> and '<code>nlminb</code>' for the function <code>nlminb</code>.
By default = <code>nlminb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>parameter for all spatial covariance functions. In the case of exponential, gaussian and spherical function <code class="reqn">\kappa</code> is equal to zero.
For the power exponential function <code class="reqn">\kappa</code> is a number between 0 and 2. For the matern correlation function is upper than 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.S</code></td>
<td>
<p>type of spatial correlation function: '<code>exponential</code>' for exponential, '<code>gaussian</code>' for gaussian,
'<code>matern</code>' for matern, '<code>pow.exp</code>' for power exponential and '<code>spherical</code>' for spherical function, respectively.
Default is <code>exponential</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IMatrix</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Indicate if the observed information matrix will be computed. By default = <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.lim, upper.lim</code></td>
<td>
<p>vectors of lower and upper bounds for the optimization method.
If unspecified, the default is <code>c(0.01,-0.99,0.01)</code> for the lower bound and <code>c(30,0.99,20)</code> for the upper bound if tau2.fixo=<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of Monte Carlo samples for stochastic approximation. By default = <code>20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perc</code></td>
<td>
<p>percentage of burn-in on the Monte Carlo sample. By default = <code>0.25</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxIter</code></td>
<td>
<p>the maximum number of iterations of the SAEM algorithm. By default = <code>300</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc</code></td>
<td>
<p>percentage of iterations of the SAEM algorithm with no memory. By default = <code>0.20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>the convergence maximum error. By default = <code>1e-6</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The spatio-temporal Gaussian model is giving by:
</p>
<p><code class="reqn"> Y(s_i,t_j)= \mu(s_i,t_j)+ Z(s_i,t_j) +  \epsilon(s_i,t_j),</code>
</p>
<p>where the deterministic term <code class="reqn">\mu(s_i,t_j)</code> and the stochastic terms <code class="reqn">Z(s_i,t_j)</code>,
<code class="reqn">\epsilon(s_i,t_j)</code> can depend on the observed spatio-temporal indexes for <code class="reqn">Y(s_i,t_j)</code>.
We assume <code class="reqn">Z</code> is normally distributed with zero-mean and covariance matrix <code class="reqn">\Sigma_z = \sigma^2 \Omega_{\phi\rho}</code>,
where <code class="reqn">\sigma^2</code> is the partial sill, <code class="reqn">\Omega_{\phi\rho}</code> is the spatio-temporal correlation matrix,<code class="reqn">\phi</code>
and <code class="reqn">\rho</code> are the spatial and time scaling parameters; <code class="reqn">\epsilon(s_i,t_j)</code> is an independent and
identically distributed measurement error with <code class="reqn">E[\epsilon(s_i,t_j)]=0</code>, variance
<code class="reqn">Var[\epsilon(s_i,t_j)]=\tau^2</code> (the nugget effect) and <code class="reqn">Cov[\epsilon(s_i,t_j), \epsilon(s_k,t_l)]=0</code>
for all <code class="reqn">s_i =! s_k</code> or <code class="reqn">t_j =! t_l</code>.
</p>
<p>In particular, we define <code class="reqn">\mu(s_i,t_j)</code>, the mean of the stochastic process as
</p>
<p><code class="reqn">\mu(s_i,t_j)=\sum_{k=1}^{p} x_k(s_i,t_j)\beta_k,</code>
</p>
<p>where <code class="reqn">x_1(s_i,t_j),..., x_p(s_i,t_j)</code> are known functions of <code class="reqn">(s_i,t_j)</code>, and <code class="reqn">\beta_1,...,\beta_p</code>
are unknown parameters to be estimated. Equivalently, in matrix notation, we have the spatio-temporal linear model as follows:
</p>
<p><code class="reqn">Y = X \beta + Z + \epsilon,</code>
</p>
<p><code class="reqn">Z ~ N(0,\sigma^2 \Omega_{\phi\rho}),</code>
</p>
<p><code class="reqn">\epsilon ~ N(0,\tau^2 I_m).</code>
</p>
<p>Therefore the spatio-temporal process, <code class="reqn">Y</code>, has normal distribution with mean <code class="reqn">E[Y]=X\beta</code> and
variance <code class="reqn">\Sigma=\sigma^2\Omega_{\phi\rho}+\tau^2 I_m</code>. We assume that <code class="reqn">\Sigma</code> is non-singular
and <code class="reqn">X</code> has full rank.
</p>
<p>The estimation process was computed via SAEM algorithm initially proposed by Delyon et al. (1999).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>Est.StempCens</code> which is a list given by:
</p>

<dl>
<dt><code>m.data</code></dt>
<dd>
<p>Returns a list with all data components given in input.</p>
</dd>
<dt><code>m.results</code></dt>
<dd>
<p>A list given by:</p>
</dd>
</dl>
<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>final estimation of <code class="reqn">\theta = (\beta, \sigma^2, \tau^2, \phi, \rho)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>estimated parameters in all iterations, <code class="reqn">\theta = (\beta, \sigma^2, \tau^2, \phi, \rho)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>estimated <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>estimated <code class="reqn">\sigma^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>
<p>estimated <code class="reqn">\tau^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>estimated <code class="reqn">\phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>estimated <code class="reqn">\rho</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Eff.range</code></td>
<td>
<p>estimated effective range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PsiInv</code></td>
<td>
<p>estimated <code class="reqn">\Psi^-1</code>, where <code class="reqn">\Psi=\Sigma/\sigma^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cov</code></td>
<td>
<p>estimated <code class="reqn">\Sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAEMy</code></td>
<td>
<p>stochastic approximation of the first moment for the truncated normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAEMyy</code></td>
<td>
<p>stochastic approximation of the second moment for the truncated normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hessian</code></td>
<td>
<p>Hessian matrix, the negative of the conditional expected second derivative matrix given the observed values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Louis</code></td>
<td>
<p>the observed information matrix using the Louis' method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>log likelihood for SAEM method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC</code></td>
<td>
<p>Akaike information criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>Bayesian information criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AICcorr</code></td>
<td>
<p>corrected AIC by the number of parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>number of iterations needed to convergence.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Simulating data
# Initial parameter values
beta &lt;- c(-1,1.50)
phi &lt;- 5;     rho &lt;- 0.45
tau2 &lt;- 0.80; sigma2 &lt;- 1.5
n1 &lt;- 5    # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(1000)
x.coord &lt;- round(runif(n1,0,10),9)    # X coordinate
y.coord &lt;- round(runif(n1,0,10),9)    # Y coordinate
coord  &lt;- cbind(x.coord,y.coord)      # Cartesian coordinates without repetitions
coord2 &lt;- cbind(rep(x.coord,each=n2),rep(y.coord,each=n2)) # Cartesian coordinates with repetitions
time &lt;- as.matrix(seq(1,n2))          # Time index without repetitions
time2 &lt;- as.matrix(rep(time,n1))      # Time index with repetitions
x1 &lt;- rexp(n1*n2,2)
x2 &lt;- rnorm(n1*n2,2,1)
x  &lt;- cbind(x1,x2)
media &lt;- x%*%beta
# Covariance matrix
Ms  &lt;- as.matrix(dist(coord))   # Spatial distances
Mt  &lt;- as.matrix(dist(time))    # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,Ms,Mt,1.5,"matern")
# Data
require(mvtnorm)
y &lt;- as.vector(rmvnorm(1,mean=as.vector(media),sigma=Cov))
perc &lt;- 0.20
aa &lt;- sort(y); bb &lt;- aa[1:(perc*n1*n2)]; cutof &lt;- bb[perc*n1*n2]
cc &lt;- matrix(1,(n1*n2),1)*(y&lt;=cutof)
y[cc==1] &lt;- cutof
LI &lt;- y; LI[cc==1] &lt;- -Inf    # Left-censored
LS &lt;- y

# Estimation
est_teste &lt;- EstStempCens(y, x, cc, time2, coord2, LI, LS, init.phi=3.5,
                 init.rho=0.5, init.tau2=0.7,tau2.fixo=FALSE, kappa=1.5,
                 type.S="matern", IMatrix=TRUE, M=20, perc=0.25,
                 MaxIter=300, pc=0.2)
## End(Not run)

</code></pre>


</div>