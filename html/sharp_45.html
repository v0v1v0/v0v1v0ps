<div class="container">

<table style="width: 100%;"><tr>
<td>LambdaGridGraphical</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Grid of penalty parameters (graphical model)</h2>

<h3>Description</h3>

<p>Generates a relevant grid of penalty parameter values for penalised graphical
models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LambdaGridGraphical(
  xdata,
  pk = NULL,
  lambda_other_blocks = 0.1,
  K = 100,
  tau = 0.5,
  n_cat = 3,
  implementation = PenalisedGraphical,
  start = "cold",
  scale = TRUE,
  resampling = "subsampling",
  PFER_method = "MB",
  PFER_thr = Inf,
  FDP_thr = Inf,
  Lambda_cardinal = 50,
  lambda_max = NULL,
  lambda_path_factor = 0.001,
  max_density = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>data matrix with observations as rows and variables as columns.
For multi-block stability selection, the variables in data have to be
ordered by group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pk</code></td>
<td>
<p>optional vector encoding the grouping structure. Only used for
multi-block stability selection where <code>pk</code> indicates the number of
variables in each group. If <code>pk=NULL</code>, single-block stability
selection is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_other_blocks</code></td>
<td>
<p>optional vector of parameters controlling the
level of sparsity in neighbour blocks for the multi-block procedure. To use
jointly a specific set of parameters for each block,
<code>lambda_other_blocks</code> must be set to <code>NULL</code> (not recommended).
Only used for multi-block stability selection, i.e. if <code>length(pk)&gt;1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of resampling iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>subsample size. Only used if <code>resampling="subsampling"</code> and
<code>cpss=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cat</code></td>
<td>
<p>computation options for the stability score. Default is
<code>NULL</code> to use the score based on a z test. Other possible values are 2
or 3 to use the score based on the negative log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implementation</code></td>
<td>
<p>function to use for graphical modelling. If
<code>implementation=PenalisedGraphical</code>, the algorithm implemented in
<code>glassoFast</code> is used for regularised estimation of
a conditional independence graph. Alternatively, a user-defined function
can be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>character string indicating if the algorithm should be
initialised at the estimated (inverse) covariance with previous penalty
parameters (<code>start="warm"</code>) or not (<code>start="cold"</code>). Using
<code>start="warm"</code> can speed-up the computations, but could lead to
convergence issues (in particular with small <code>Lambda_cardinal</code>). Only
used for <code>implementation=PenalisedGraphical</code> (see argument
<code>"start"</code> in <code>glassoFast</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical indicating if the correlation (<code>scale=TRUE</code>) or
covariance (<code>scale=FALSE</code>) matrix should be used as input of
<code>glassoFast</code> if
<code>implementation=PenalisedGraphical</code>. Otherwise, this argument must be
used in the function provided in <code>implementation</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>resampling approach. Possible values are:
<code>"subsampling"</code> for sampling without replacement of a proportion
<code>tau</code> of the observations, or <code>"bootstrap"</code> for sampling with
replacement generating a resampled dataset with as many observations as in
the full sample. Alternatively, this argument can be a function to use for
resampling. This function must use arguments named <code>data</code> and
<code>tau</code> and return the IDs of observations to be included in the
resampled dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFER_method</code></td>
<td>
<p>method used to compute the upper-bound of the expected
number of False Positives (or Per Family Error Rate, PFER). If
<code>PFER_method="MB"</code>, the method proposed by Meinshausen and BÃ¼hlmann
(2010) is used. If <code>PFER_method="SS"</code>, the method proposed by Shah and
Samworth (2013) under the assumption of unimodality is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFER_thr</code></td>
<td>
<p>threshold in PFER for constrained calibration by error
control. If <code>PFER_thr=Inf</code> and <code>FDP_thr=Inf</code>, unconstrained
calibration is used (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FDP_thr</code></td>
<td>
<p>threshold in the expected proportion of falsely selected
features (or False Discovery Proportion) for constrained calibration by
error control. If <code>PFER_thr=Inf</code> and <code>FDP_thr=Inf</code>, unconstrained
calibration is used (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda_cardinal</code></td>
<td>
<p>number of values in the grid of parameters controlling
the level of sparsity in the underlying algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_max</code></td>
<td>
<p>optional maximum value for the grid in penalty parameters.
If <code>lambda_max=NULL</code>, the maximum value is set to the maximum
covariance in absolute value. Only used if
<code>implementation=PenalisedGraphical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_path_factor</code></td>
<td>
<p>multiplicative factor used to define the minimum
value in the grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_density</code></td>
<td>
<p>threshold on the density. The grid is defined such that
the density of the estimated graph does not exceed max_density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to the functions provided in
<code>implementation</code> or <code>resampling</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix of lambda values with <code>length(pk)</code> columns and
<code>Lambda_cardinal</code> rows.
</p>


<h3>See Also</h3>

<p>Other lambda grid functions: 
<code>LambdaGridRegression()</code>,
<code>LambdaSequence()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Single-block simulation
set.seed(1)
simul &lt;- SimulateGraphical()

# Generating grid of 10 values
Lambda &lt;- LambdaGridGraphical(xdata = simul$data, Lambda_cardinal = 10)

# Ensuring PFER &lt; 5
Lambda &lt;- LambdaGridGraphical(xdata = simul$data, Lambda_cardinal = 10, PFER_thr = 5)

# Multi-block simulation
set.seed(1)
simul &lt;- SimulateGraphical(pk = c(10, 10))

# Multi-block grid
Lambda &lt;- LambdaGridGraphical(xdata = simul$data, pk = c(10, 10), Lambda_cardinal = 10)

# Denser neighbouring blocks
Lambda &lt;- LambdaGridGraphical(
  xdata = simul$data, pk = c(10, 10),
  Lambda_cardinal = 10, lambda_other_blocks = 0
)

# Using different neighbour penalties
Lambda &lt;- LambdaGridGraphical(
  xdata = simul$data, pk = c(10, 10),
  Lambda_cardinal = 10, lambda_other_blocks = c(0.1, 0, 0.1)
)
stab &lt;- GraphicalModel(
  xdata = simul$data, pk = c(10, 10),
  Lambda = Lambda, lambda_other_blocks = c(0.1, 0, 0.1)
)
stab$Lambda

# Visiting from empty to full graphs with max_density=1
Lambda &lt;- LambdaGridGraphical(
  xdata = simul$data, pk = c(10, 10),
  Lambda_cardinal = 10, max_density = 1
)
bigblocks &lt;- BlockMatrix(pk = c(10, 10))
bigblocks_vect &lt;- bigblocks[upper.tri(bigblocks)]
N_blocks &lt;- unname(table(bigblocks_vect))
N_blocks # max number of edges per block
stab &lt;- GraphicalModel(xdata = simul$data, pk = c(10, 10), Lambda = Lambda)
apply(stab$Q, 2, max, na.rm = TRUE) # max average number of edges from underlying algo

</code></pre>


</div>