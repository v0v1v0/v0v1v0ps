<div class="container">

<table style="width: 100%;"><tr>
<td>svsim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulating a Stochastic Volatility Process</h2>

<h3>Description</h3>

<p><code>svsim</code> is used to produce realizations of a stochastic volatility (SV)
process.
</p>


<h3>Usage</h3>

<pre><code class="language-R">svsim(len, mu = -10, phi = 0.98, sigma = 0.2, nu = Inf, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>length of the simulated time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>level of the latent log-volatility AR(1) process. The defaults
value is <code>-10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>persistence of the latent log-volatility AR(1) process. The
default value is <code>0.98</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>volatility of the latent log-volatility AR(1) process. The
default value is <code>0.2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>degrees-of-freedom for the conditional innovations distribution.
The default value is <code>Inf</code>, corresponding to standard normal
conditional innovations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>correlation between the observation and the increment of the
log-volatility. The default value is <code>0</code>, corresponding to the basic
SV model with symmetric “log-returns”.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function draws an initial log-volatility <code>h_0</code> from the stationary
distribution of the AR(1) process defined by <code>phi</code>, <code>sigma</code>, and <code>mu</code>.
Then the function jointly simulates the log-volatility series
<code>h_1,...,h_n</code> with the given AR(1) structure, and the “log-return” series
<code>y_1,...,y_n</code> with mean 0 and standard deviation <code>exp(h/2)</code>.
Additionally, for each index <code>i</code>, <code>y_i</code> can be set to have a conditionally heavy-tailed
residual (through <code>nu</code>) and/or to be correlated with <code>(h_{i+1}-h_i)</code>
(through <code>rho</code>, the so-called leverage effect, resulting in asymmetric “log-returns”).
</p>


<h3>Value</h3>

<p>The output is a list object of class <code>svsim</code> containing
</p>

<dl>
<dt>y</dt>
<dd>
<p>vector of length <code>len</code> containing the simulated data,
usually interpreted as “log-returns”.</p>
</dd>
<dt>vol</dt>
<dd>
<p>vector of length
<code>len</code> containing the simulated instantaneous volatilities.
These are <code class="reqn">e^{h_t/2}</code> if <code>nu == Inf</code>, and they are
<code class="reqn">e^{h_t/2} \sqrt{\tau_t}</code> for finite <code>nu</code>.</p>
</dd>
<dt>vol0</dt>
<dd>
<p>The initial volatility <code>exp(h_0/2)</code>,
drawn from the stationary distribution of the latent AR(1) process.</p>
</dd>
<dt>para</dt>
<dd>
<p>a named list with five elements <code>mu</code>, <code>phi</code>,
<code>sigma</code>, <code>nu</code>, and <code>rho</code>, containing
the corresponding arguments.</p>
</dd>
<dt>latent</dt>
<dd>
<p>vector of the latent state space <code class="reqn">h_t</code> for <code class="reqn">t &gt; 0</code>.</p>
</dd>
<dt>latent0</dt>
<dd>
<p>initial element of the latent state space <code class="reqn">h_0</code>.</p>
</dd>
<dt>tau</dt>
<dd>
<p>vector of length <code>len</code> containing the simulated auxiliary
variables for the Student-t residuals when <code>nu</code> is finite. More precisely,
<code class="reqn">\tau_t\sim\text{Gamma}^{-1}(\text{shape}=\nu/2, \text{rate}=\nu/2-1)</code>.</p>
</dd>
</dl>
<h3>Note</h3>

<p>The function generates the “log-returns” by
<code>y &lt;- exp(-h/2)*rt(h, df=nu)</code>. That means that in the case of <code>nu &lt; Inf</code>
the (conditional) volatility is <code>sqrt(nu/(nu-2))*exp(h/2)</code>, and that corrected value
is shown in the <code>print</code>, <code>summary</code> and <code>plot</code> methods.
</p>
<p>To display the output use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the content of the object in a moderately
formatted manner. The <code>summary</code> method provides some summary statistics
(in %), and the <code>plot</code> method plots the the simulated 'log-returns'
<code>y</code> along with the corresponding volatilities <code>vol</code>.
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>
</p>


<h3>See Also</h3>

<p><code>svsample</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulate a highly persistent SV process of length 500
sim &lt;- svsim(500, phi = 0.99, sigma = 0.1)

print(sim)
summary(sim)
plot(sim)

## Simulate an SV process with leverage
sim &lt;- svsim(200, phi = 0.94, sigma = 0.15, rho = -0.6)

print(sim)
summary(sim)
plot(sim)

## Simulate an SV process with conditionally heavy-tails
sim &lt;- svsim(250, phi = 0.91, sigma = 0.05, nu = 5)

print(sim)
summary(sim)
plot(sim)

</code></pre>


</div>