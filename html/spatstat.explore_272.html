<div class="container">

<table style="width: 100%;"><tr>
<td>Kmark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mark-Weighted K Function</h2>

<h3>Description</h3>

<p>Estimates the mark-weighted <code class="reqn">K</code> function
of a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  Kmark(X, f = NULL, r = NULL,
        correction = c("isotropic", "Ripley", "translate"), ...,
        f1 = NULL, normalise = TRUE, returnL = FALSE, fargs = NULL)

  markcorrint(X, f = NULL, r = NULL,
              correction = c("isotropic", "Ripley", "translate"), ...,
              f1 = NULL, normalise = TRUE, returnL = FALSE, fargs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Optional. Test function <code class="reqn">f</code> used in the definition of the
mark correlation function. An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function with at least two
arguments. There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the mark correlation function 
<code class="reqn">k_f(r)</code> should be evaluated.
There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f1</code></td>
<td>

<p>An alternative to <code>f</code>. If this argument is given,
then <code class="reqn">f</code> is assumed to take the form
<code class="reqn">f(u,v)=f_1(u)f_1(v)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>

<p>If <code>normalise=FALSE</code>,
compute only the numerator of the expression for the
mark correlation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnL</code></td>
<td>

<p>Compute the analogue of the K-function if <code>returnL=FALSE</code>
or the analogue of the L-function if <code>returnL=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fargs</code></td>
<td>

<p>Optional. A list of extra arguments to be passed to the function
<code>f</code> or <code>f1</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functions <code>Kmark</code> and <code>markcorrint</code> are identical.
(Eventually <code>markcorrint</code> will be deprecated.)
</p>
<p>The <em>mark-weighted <code class="reqn">K</code> function</em> <code class="reqn">K_f(r)</code>
of a marked point process (Penttinen et al, 1992)
is a generalisation of Ripley's <code class="reqn">K</code> function, in which the contribution
from each pair of points is weighted by a function of their marks.
If the marks of the two points are <code class="reqn">m_1, m_2</code> then
the weight is proportional to <code class="reqn">f(m_1, m_2)</code> where
<code class="reqn">f</code> is a specified <em>test function</em>.
</p>
<p>The mark-weighted <code class="reqn">K</code> function is defined so that
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda K_f(r) = \frac{C_f(r)}{E[ f(M_1, M_2) ]}
  </code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">
    C_f(r) = 
    E \left[
    \sum_{x \in X}
    f(m(u), m(x))
    1{0 &lt; ||u - x|| \le r}
    \;  \big| \;
    u \in X
    \right]
  </code>
</p>

<p>for any spatial location <code class="reqn">u</code> taken to be a typical point of
the point process <code class="reqn">X</code>. Here <code class="reqn">||u-x||</code> is the
euclidean distance between <code class="reqn">u</code> and <code class="reqn">x</code>, so that the sum
is taken over all random points <code class="reqn">x</code> that lie within a distance
<code class="reqn">r</code> of the point <code class="reqn">u</code>. The function <code class="reqn">C_f(r)</code> is
the <em>unnormalised</em> mark-weighted <code class="reqn">K</code> function.
To obtain <code class="reqn">K_f(r)</code> we standardise <code class="reqn">C_f(r)</code>
by dividing by <code class="reqn">E[f(M_1,M_2)]</code>, the expected value of
<code class="reqn">f(M_1,M_2)</code> when <code class="reqn">M_1</code> and <code class="reqn">M_2</code> are
independent random marks with the same distribution as the marks in
the point process. 
</p>
<p>Under the hypothesis of random labelling, the
mark-weighted <code class="reqn">K</code> function 
is equal to Ripley's <code class="reqn">K</code> function,
<code class="reqn">K_f(r) = K(r)</code>.
</p>
<p>The mark-weighted <code class="reqn">K</code> function is sometimes called the 
<em>mark correlation integral</em> because it is related to the
mark correlation function <code class="reqn">k_f(r)</code>
and the pair correlation function <code class="reqn">g(r)</code> by
</p>
<p style="text-align: center;"><code class="reqn">
    K_f(r) = 2 \pi \int_0^r s k_f(s) \, g(s) \, {\rm d}s
  </code>
</p>

<p>See <code>markcorr</code> for a definition of the
mark correlation function.
</p>
<p>Given a marked point pattern <code>X</code>,
this command computes edge-corrected estimates
of the mark-weighted <code class="reqn">K</code> function.
If <code>returnL=FALSE</code> then the estimated
function <code class="reqn">K_f(r)</code> is returned;
otherwise the function
</p>
<p style="text-align: center;"><code class="reqn">
    L_f(r) = \sqrt{K_f(r)/\pi}
  </code>
</p>

<p>is returned.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code>fv.object</code>).
</p>
<p>Essentially a data frame containing numeric columns 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the mark correlation integral <code class="reqn">K_f(r)</code>
has been  estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>the theoretical value of <code class="reqn">K_f(r)</code>
when the marks attached to different points are independent,
namely <code class="reqn">\pi r^2</code>
</p>
</td>
</tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the mark-weighted <code class="reqn">K</code> function <code class="reqn">K_f(r)</code>
obtained by the edge corrections named (if <code>returnL=FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Penttinen, A., Stoyan, D. and Henttonen, H. M. (1992)
Marked point processes in forest statistics.
<em>Forest Science</em> <b>38</b> (1992) 806-824.
</p>
<p>Illian, J., Penttinen, A., Stoyan, H. and Stoyan, D. (2008)
<em>Statistical analysis and modelling of spatial point patterns</em>.
Chichester: John Wiley.
</p>


<h3>See Also</h3>

<p><code>markcorr</code> to estimate the mark correlation function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # CONTINUOUS-VALUED MARKS:
    # (1) Spruces
    # marks represent tree diameter
    # mark correlation function
    ms &lt;- Kmark(spruces)
    plot(ms)

    # (2) simulated data with independent marks
    X &lt;- rpoispp(100)
    X &lt;- X %mark% runif(npoints(X))
    Xc &lt;- Kmark(X)
    plot(Xc)
    
    # MULTITYPE DATA:
    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    M &lt;- Kmark(amacrine, function(m1,m2) {m1==m2},
                         correction="translate")
    plot(M)
</code></pre>


</div>