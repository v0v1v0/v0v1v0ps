<div class="container">

<table style="width: 100%;"><tr>
<td>rasch.pml3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pairwise Marginal Likelihood Estimation for the Probit Rasch Model
</h2>

<h3>Description</h3>

<p>This function estimates unidimensional 1PL and 2PL models with
the probit link using pairwise marginal maximum likelihood
estimation (PMML; Renard, Molenberghs &amp; Geys, 2004).
Item pairs within an itemcluster can be excluded from the
pairwise likelihood (argument <code>itemcluster</code>).
The other alternative is to model a residual
error structure with itemclusters (argument <code>error.corr</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">rasch.pml3(dat, est.b=seq(1, ncol(dat)), est.a=rep(0,ncol(dat)),
    est.sigma=TRUE, itemcluster=NULL, weight=rep(1, nrow(dat)), numdiff.parm=0.001,
    b.init=NULL, a.init=NULL,  sigma.init=NULL, error.corr=0*diag( 1, ncol(dat) ),
    err.constraintM=NULL, err.constraintV=NULL, glob.conv=10^(-6), conv1=10^(-4),
    pmliter=300, progress=TRUE, use.maxincrement=TRUE )

## S3 method for class 'rasch.pml'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>An <code class="reqn">N \times I</code> data frame of dichotomous item responses
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.b</code></td>
<td>

<p>Vector of integers of length <code class="reqn">I</code>. Same integers mean that the
corresponding items do have the same item difficulty <code>b</code>.
Entries of <code>0</code> mean fixing item parameters to values
specified in <code>b.init</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.a</code></td>
<td>

<p>Vector of integers of length <code class="reqn">I</code>. Same integers mean that the
corresponding items do have the same item slope <code>a</code>.
Entries of <code>0</code> mean fixing item parameters to values
specified in <code>a.init</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.sigma</code></td>
<td>

<p>Should sigma (the trait standard deviation) be estimated?
The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemcluster</code></td>
<td>

<p>Optional vector of length <code class="reqn">I</code> of integers which indicates itemclusters.
Same integers correspond to the same itemcluster. An entry of <code>0</code>
correspond to an item which is not included in any itemcluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>Optional vector of person weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.parm</code></td>
<td>

<p>Step parameter for numerical differentiation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.init</code></td>
<td>

<p>Initial or fixed item difficulty
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.init</code></td>
<td>

<p>Initial or fixed item slopes
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.init</code></td>
<td>

<p>Initial or fixed trait standard deviation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.corr</code></td>
<td>

<p>An optional <code class="reqn">I \times I</code> integer matrix
which defines the estimation of residual correlations.
Entries of zero indicate that the corresponding
residual correlation should not be estimated.
Integers which differ from zero indicate correlations to be estimated.
All entries with an equal integer are estimated by the same residual
correlation. The default of <code>error.corr</code> is a diagonal matrix
which means that no residual correlation is estimated. If <code>error.corr</code>
deviates from this default, then the argument <code>itemcluster</code> is set
to <code>NULL</code>.<br>
If some error correlations are estimated, then no itempairs in
<code>itemcluster</code> can be excluded from the pairwise modeling.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>err.constraintM</code></td>
<td>

<p>An optional <code class="reqn">P \times L</code> matrix where <code class="reqn">P</code> denotes
the number of item pairs in pseudolikelihood estimation
and <code class="reqn">L</code> is the number of linear constraints for residual
correlations (see Details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.constraintV</code></td>
<td>

<p>An optional <code class="reqn">L \times 1</code> matrix with specified values
for linear constraints on residual correlations (see Details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.conv</code></td>
<td>

<p>Global convergence criterion
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv1</code></td>
<td>

<p>Convergence criterion for model parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmliter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>Display progress?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.maxincrement</code></td>
<td>
<p>Optional logical whether increments in
slope parameters should be controlled in size in iterations.
The default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>rasch.pml</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The probit item response model can be estimated with this function:
</p>
<p style="text-align: center;"><code class="reqn">P(X_{pi}=1|\theta_p )=\Phi( a_i  \theta_p - b_i ) \quad, \quad
    \theta_p \sim N ( 0, \sigma^2 )</code>
</p>

<p>where <code class="reqn">\Phi</code> denotes the normal distribution function. This model can
also be expressed as a latent variable model which assumes
a latent response tendency <code class="reqn">X_{pi}^\ast</code> which is equal to
1 if <code class="reqn">X_{pi}&gt; - b_i</code> and otherwise zero. If <code class="reqn">\epsilon_{pi}</code> is
standard normally distributed, then
</p>
<p style="text-align: center;"><code class="reqn">X_{pi}^{\ast}=a_i \theta_p - b_i + \epsilon_{pi} </code>
</p>

<p>An arbitrary pattern of residual correlations between
<code class="reqn">\epsilon_{pi}</code> and <code class="reqn">\epsilon_{pj}</code> for item pairs <code class="reqn">i</code>
and <code class="reqn">j</code> can be imposed using the <code>error.corr</code> argument.
</p>
<p>Linear constraints <code class="reqn">Me=v</code> on residual correlations
<code class="reqn">e=Cov( \epsilon_{pi}, \epsilon_{pj})_{ij}</code> (in a vectorized form) can be
specified using the arguments <code>err.constraintM</code> (matrix <code class="reqn">M</code>)
and <code>err.constraintV</code> (vector <code class="reqn">v</code>). The estimation
is described in Neuhaus (1996).
</p>
<p>For the pseudo likelihood information criterion (PLIC)
see Stanford and Raftery (2002).
</p>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Data frame with estimated item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Pseudolikelihood multiplied by minus 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Estimated item difficulties</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Estimated standard deviation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>Original dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Data frame with information criteria (sample size,
number of estimated parameters, pseudolikelihood
information criterion <code>PLIC</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>Used link function (only probit is permitted)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itempairs</code></td>
<td>
<p>Estimated statistics of item pairs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.corr</code></td>
<td>
<p>Estimated error correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.corr</code></td>
<td>

<p>Vectorized error correlation matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega.rel</code></td>
<td>

<p>Reliability of the sum score according to Green and Yang (2009).
If some item pairs are excluded in the estimation, the residual
correlation for these item pairs is assumed to be zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function needs the <span class="pkg">combinat</span> library.
</p>


<h3>References</h3>

<p>Green, S. B., &amp; Yang, Y. (2009). Reliability of summed item
scores using structural equation modeling: An alternative to
coefficient alpha. <em>Psychometrika, 74</em>, 155-167.
</p>
<p>Neuhaus, W. (1996). Optimal estimation under
linear constraints. <em>Astin Bulletin, 26</em>, 233-245.
</p>
<p>Renard, D., Molenberghs, G., &amp; Geys, H. (2004). A pairwise likelihood
approach to estimation in multilevel probit models. <em>Computational Statistics
&amp; Data Analysis, 44</em>, 649-667.
</p>
<p>Stanford, D. C., &amp; Raftery, A. E. (2002).
Approximate Bayes factors for image segmentation:
The pseudolikelihood information criterion (PLIC).
<em>IEEE Transactions on Pattern Analysis and
Machine Intelligence, 24</em>, 1517-1520.
</p>


<h3>See Also</h3>

<p>Get a summary of <code>rasch.pml3</code> with <code>summary.rasch.pml</code>.
</p>
<p>For simulation of locally dependent items see <code>sim.rasch.dep</code>.
</p>
<p>For pairwise conditional likelihood estimation see <code>rasch.pairwise</code>
or <code>rasch.pairwise.itemcluster</code>.
</p>
<p>For an assessment of global model fit see <code>modelfit.sirt</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Reading data set
#############################################################################

data(data.read)
dat &lt;- data.read

#******
# Model 1: Rasch model with PML estimation
mod1 &lt;- sirt::rasch.pml3( dat )
summary(mod1)

#******
# Model 2: Excluding item pairs with local dependence
#          from bivariate composite likelihood
itemcluster &lt;- rep( 1:3, each=4)
mod2 &lt;- sirt::rasch.pml3( dat, itemcluster=itemcluster )
summary(mod2)

## Not run: 
#*****
# Model 3: Modelling error correlations:
#          joint residual correlations for each itemcluster
error.corr &lt;- diag(1,ncol(dat))
for ( ii in 1:3){
    ind.ii &lt;- which( itemcluster==ii )
    error.corr[ ind.ii, ind.ii ] &lt;- ii
        }
# estimate the model with error correlations
mod3 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )
summary(mod3)

#****
# Model 4: model separate residual correlations
I &lt;- ncol(error.corr)
error.corr1 &lt;- matrix( 1:(I*I), ncol=I )
error.corr &lt;- error.corr1 * ( error.corr &gt; 0 )
# estimate the model with error correlations
mod4 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )
summary(mod4)

#****
# Model 5:  assume equal item difficulties:
# b_1=b_7 and b_2=b_12
# fix item difficulty of the 6th item to .1
est.b &lt;- 1:I
est.b[7] &lt;- 1; est.b[12] &lt;- 2 ; est.b[6] &lt;- 0
b.init &lt;- rep( 0, I ) ; b.init[6] &lt;- .1
mod5 &lt;- sirt::rasch.pml3( dat, est.b=est.b, b.init=b.init)
summary(mod5)

#****
# Model 6: estimate three item slope groups
est.a &lt;- rep(1:3, each=4 )
mod6 &lt;- sirt::rasch.pml3( dat, est.a=est.a, est.sigma=0)
summary(mod6)

#############################################################################
# EXAMPLE 2: PISA reading
#############################################################################

data(data.pisaRead)
dat &lt;- data.pisaRead$data

# select items
dat &lt;- dat[, substring(colnames(dat),1,1)=="R" ]

#******
# Model 1: Rasch model with PML estimation
mod1 &lt;- sirt::rasch.pml3( as.matrix(dat) )
  ## Trait SD (Logit Link) : 1.419

#******
# Model 2: Model correlations within testlets
error.corr &lt;- diag(1,ncol(dat))
testlets &lt;- paste( data.pisaRead$item$testlet )
itemcluster &lt;- match( testlets, unique(testlets ) )
for ( ii in 1:(length(unique(testlets))) ){
    ind.ii &lt;- which( itemcluster==ii )
    error.corr[ ind.ii, ind.ii ] &lt;- ii
        }
# estimate the model with error correlations
mod2 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )
  ## Trait SD (Logit Link) : 1.384

#****
# Model 3: model separate residual correlations
I &lt;- ncol(error.corr)
error.corr1 &lt;- matrix( 1:(I*I), ncol=I )
error.corr &lt;- error.corr1 * ( error.corr &gt; 0 )
# estimate the model with error correlations
mod3 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )
  ## Trait SD (Logit Link) : 1.384

#############################################################################
# EXAMPLE 3: 10 locally independent items
#############################################################################

#**********
# simulate some data
set.seed(554)
N &lt;- 500    # persons
I &lt;- 10        # items
theta &lt;- stats::rnorm(N,sd=1.3 )    # trait SD of 1.3
b &lt;- seq(-2, 2, length=I) # item difficulties

# simulate data from the Rasch model
dat &lt;- sirt::sim.raschtype( theta=theta, b=b )

# estimation with rasch.pml and probit link
mod1 &lt;- sirt::rasch.pml3( dat )
summary(mod1)

# estimation with rasch.mml2 function
mod2 &lt;- sirt::rasch.mml2( dat )

# estimate item parameters for groups with five item parameters each
est.b &lt;- rep( 1:(I/2), each=2 )
mod3 &lt;- sirt::rasch.pml3( dat, est.b=est.b )
summary(mod3)

# compare parameter estimates
summary(mod1)
summary(mod2)
summary(mod3)

#############################################################################
# EXAMPLE 4: 11 items and 2 item clusters with 2 and 3 items
#############################################################################

set.seed(5698)
I &lt;- 11                             # number of items
n &lt;- 5000                           # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
theta &lt;- stats::rnorm( n, sd=1 ) # person abilities
# itemcluster
itemcluster &lt;- rep(0,I)
itemcluster[c(3,5)] &lt;- 1
itemcluster[c(2,4,9)] &lt;- 2
# residual correlations
rho &lt;- c( .7, .5 )

# simulate data (under the logit link)
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("I", seq(1,ncol(dat)), sep="")

#***
# Model 1: estimation using the Rasch model (with probit link)
mod1 &lt;- sirt::rasch.pml3( dat )
#***
# Model 2: estimation when pairs of locally dependent items are eliminated
mod2 &lt;- sirt::rasch.pml3( dat, itemcluster=itemcluster)

#***
# Model 3: Positive correlations within testlets
est.corrs &lt;- diag( 1, I )
est.corrs[ c(3,5), c(3,5) ] &lt;- 2
est.corrs[ c(2,4,9), c(2,4,9) ] &lt;- 3
mod3 &lt;- sirt::rasch.pml3( dat, error.corr=est.corrs )

#***
# Model 4: Negative correlations between testlets
est.corrs &lt;- diag( 1, I )
est.corrs[ c(3,5), c(2,4,9) ] &lt;- 2
est.corrs[ c(2,4,9), c(3,5) ] &lt;- 2
mod4 &lt;- sirt::rasch.pml3( dat, error.corr=est.corrs )

#***
# Model 5: sum constraint of zero within and between testlets
est.corrs &lt;- matrix( 1:(I*I),  I, I )
cluster2 &lt;- c(2,4,9)
est.corrs[ setdiff( 1:I, c(cluster2)),  ] &lt;- 0
est.corrs[, setdiff( 1:I, c(cluster2))  ] &lt;- 0
# define an error constraint matrix
itempairs0 &lt;- mod4$itempairs
IP &lt;- nrow(itempairs0)
err.constraint &lt;- matrix( 0, IP, 1 )
err.constraint[ ( itempairs0$item1 %in% cluster2 )
       &amp; ( itempairs0$item2 %in% cluster2 ), 1 ] &lt;- 1
# set sum of error covariances to 1.2
err.constraintV &lt;- matrix(3*.4,1,1)

mod5 &lt;- sirt::rasch.pml3( dat, error.corr=est.corrs,
         err.constraintM=err.constraint, err.constraintV=err.constraintV)

#****
# Model 6: Constraint on sum of all correlations
est.corrs &lt;- matrix( 1:(I*I),  I, I )
# define an error constraint matrix
itempairs0 &lt;- mod4$itempairs
IP &lt;- nrow(itempairs0)
# define two side conditions
err.constraint &lt;- matrix( 0, IP, 2 )
err.constraintV &lt;- matrix( 0, 2, 1)
# sum of all correlations is zero
err.constraint[, 1 ] &lt;- 1
err.constraintV[1,1] &lt;- 0
# sum of items cluster c(1,2,3) is 0
cluster2 &lt;- c(1,2,3)
err.constraint[ ( itempairs0$item1 %in%  cluster2 )
       &amp; ( itempairs0$item2 %in% cluster2 ), 2 ] &lt;- 1
err.constraintV[2,1] &lt;- 0

mod6 &lt;- sirt::rasch.pml3( dat, error.corr=est.corrs,
    err.constraintM=err.constraint,  err.constraintV=err.constraintV)
summary(mod6)

#############################################################################
# EXAMPLE 5: 10 Items: Cluster 1 -&gt; Items 1,2
#         Cluster 2 -&gt; Items 3,4,5;   Cluster 3 -&gt; Items 7,8,9
#############################################################################

set.seed(7650)
I &lt;- 10                             # number of items
n &lt;- 5000                           # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
bsamp &lt;- b &lt;- sample(b)             # sample item difficulties
theta &lt;- stats::rnorm( n, sd=1 ) # person abilities
# define itemcluster
itemcluster &lt;- rep(0,I)
itemcluster[ 1:2 ] &lt;- 1
itemcluster[ 3:5 ] &lt;- 2
itemcluster[ 7:9 ] &lt;- 3
# define residual correlations
rho &lt;- c( .55, .35, .45)

# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("I", seq(1,ncol(dat)), sep="")

#***
# Model 1: residual correlation (equal within item clusters)
# define a matrix of integers for estimating error correlations
error.corr &lt;- diag(1,ncol(dat))
for ( ii in 1:3){
    ind.ii &lt;- which( itemcluster==ii )
    error.corr[ ind.ii, ind.ii ] &lt;- ii
        }
# estimate the model
mod1 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )

#***
# Model 2: residual correlation (different within item clusters)
# define again a matrix of integers for estimating error correlations
error.corr &lt;- diag(1,ncol(dat))
for ( ii in 1:3){
    ind.ii &lt;- which( itemcluster==ii )
    error.corr[ ind.ii, ind.ii ] &lt;- ii
        }
I &lt;- ncol(error.corr)
error.corr1 &lt;- matrix( 1:(I*I), ncol=I )
error.corr &lt;- error.corr1 * ( error.corr &gt; 0 )
# estimate the model
mod2 &lt;- sirt::rasch.pml3( dat, error.corr=error.corr )

#***
# Model 3: eliminate item pairs within itemclusters for PML estimation
mod3 &lt;- sirt::rasch.pml3( dat, itemcluster=itemcluster )

#***
# Model 4: Rasch model ignoring dependency
mod4 &lt;- sirt::rasch.pml3( dat )

# compare different models
summary(mod1)
summary(mod2)
summary(mod3)
summary(mod4)

## End(Not run)
</code></pre>


</div>