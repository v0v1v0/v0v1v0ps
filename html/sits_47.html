<div class="container">

<table style="width: 100%;"><tr>
<td>sits_apply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a function on a set of time series</h2>

<h3>Description</h3>

<p>Apply a named expression to a sits cube or a sits tibble
to be evaluated and generate new bands (indices). In the case of sits
cubes, it materializes a new band in <code>output_dir</code> using
<code>gdalcubes</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sits_apply(data, ...)

## S3 method for class 'sits'
sits_apply(data, ...)

## S3 method for class 'raster_cube'
sits_apply(
  data,
  ...,
  window_size = 3L,
  memsize = 4L,
  multicores = 2L,
  normalized = TRUE,
  output_dir,
  progress = FALSE
)

## S3 method for class 'derived_cube'
sits_apply(data, ...)

## Default S3 method:
sits_apply(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Valid sits tibble or cube</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Named expressions to be evaluated (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window_size</code></td>
<td>
<p>An odd number representing the size of the
sliding window of sits kernel functions
used in expressions (for a list of supported
kernel functions, please see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memsize</code></td>
<td>
<p>Memory available for classification (in GB).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multicores</code></td>
<td>
<p>Number of cores to be used for classification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalized</code></td>
<td>
<p>Produce normalized band?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_dir</code></td>
<td>
<p>Directory where files will be saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Show progress bar?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sits_apply()</code> allow any valid R expression to compute new bands.
Use R syntax to pass an expression to this function.
Besides arithmetic operators, you can use virtually any R function
that can be applied to elements of a matrix (functions that are
unaware of matrix sizes, e.g. <code>sqrt()</code>, <code>sin()</code>,
<code>log()</code>).
</p>
<p>Also, <code>sits_apply()</code> accepts a predefined set of kernel functions
(see below) that can be applied to pixels considering its
neighborhood. <code>sits_apply()</code> considers a neighborhood of a
pixel as a set of pixels equidistant to it (including itself)
according the Chebyshev distance. This neighborhood form a
square window (also known as kernel) around the central pixel
(Moore neighborhood). Users can set the <code>window_size</code>
parameter to adjust the size of the kernel window.
The image is conceptually mirrored at the edges so that neighborhood
including a pixel outside the image is equivalent to take the
'mirrored' pixel inside the edge.
</p>
<p><code>sits_apply()</code> applies a function to the kernel and its result
is assigned to a corresponding central pixel on a new matrix.
The kernel slides throughout the input image and this process
generates an entire new matrix, which is returned as a new band
to the cube. The kernel functions ignores any <code>NA</code> values
inside the kernel window. Central pixel is <code>NA</code> just only
all pixels in the window are <code>NA</code>.
</p>
<p>By default, the indexes generated by the <code>sits_apply()</code> function are
normalized between -1 and 1, scaled by a factor of 0.0001.
Normalized indexes are saved as INT2S (Integer with sign).
If the <code>normalized</code> parameter is FALSE, no scaling factor will be
applied and the index will be saved as FLT4S (Float with sign).
</p>


<h3>Value</h3>

<p>A sits tibble or a sits cube with new bands, produced
according to the requested expression.
</p>


<h3>Summarizing kernel functions</h3>


<ul>
<li>
<p><code>w_median()</code>: returns the median of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_sum()</code>: returns the sum of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_mean()</code>: returns the mean of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_sd()</code>: returns the standard deviation of the neighborhood's
values.
</p>
</li>
<li>
<p><code>w_min()</code>: returns the minimum of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_max()</code>: returns the maximum of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_var()</code>: returns the variance of the neighborhood's values.
</p>
</li>
<li>
<p><code>w_modal()</code>: returns the modal of the neighborhood's values.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Rolf Simoes, <a href="mailto:rolf.simoes@inpe.br">rolf.simoes@inpe.br</a>
</p>
<p>Felipe Carvalho, <a href="mailto:felipe.carvalho@inpe.br">felipe.carvalho@inpe.br</a>
</p>
<p>Gilberto Camara, <a href="mailto:gilberto.camara@inpe.br">gilberto.camara@inpe.br</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (sits_run_examples()) {
    # Get a time series
    # Apply a normalization function

    point2 &lt;-
        sits_select(point_mt_6bands, "NDVI") |&gt;
        sits_apply(NDVI_norm = (NDVI - min(NDVI)) / (max(NDVI) - min(NDVI)))

    # Example of generation texture band with variance
    # Create a data cube from local files
    data_dir &lt;- system.file("extdata/raster/mod13q1", package = "sits")
    cube &lt;- sits_cube(
        source = "BDC",
        collection = "MOD13Q1-6.1",
        data_dir = data_dir
    )

    # Generate a texture images with variance in NDVI images
    cube_texture &lt;- sits_apply(
        data = cube,
        NDVITEXTURE = w_median(NDVI),
        window_size = 5,
        output_dir = tempdir()
    )
}
</code></pre>


</div>