<div class="container">

<table style="width: 100%;"><tr>
<td>scaleboot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiscale Bootstrap Resampling</h2>

<h3>Description</h3>

<p>Performs multiscale bootstrap resampling for a specified statistic.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
scaleboot(dat,nb,sa,fun,parm=NULL,count=TRUE,weight=TRUE,
          cluster=NULL,onlyboot=FALSE,seed=NULL,...)

countw.assmax(x,w,ass)

countw.shtest(x,w,obs)

countw.shtestass(x,w,assobs)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>data matrix or data-frame. Row vectors are to be resampled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>vector of the numbers of bootstrap replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sa</code></td>
<td>
<p>vector of scales in sigma squared (<code class="reqn">\sigma^2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>function for a statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>parameter to be passed to <code>fun</code> above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>logical. Should only the accumulative counts be returned?
Otherwise, raw statistic vectors are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>logical. In <code>fun</code> above, resampling is specified by
a weight vector. Otherwise, resampling is specified by a vector of indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyboot</code></td>
<td>
<p>logical. Should only bootstrap resampling be
performed? Otherwise, <code>sbfit</code> or <code>sbconf</code>
is called internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>If non NULL, random seed is set. Specifying a seed is
particularly important when <code>cluster</code> is non NULL, in which
case <code>seed + seq(along=cluster)</code> are set to cluster nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data matrix or data-frame passed from <code>scaleboot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weight vector for resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ass</code></td>
<td>
<p>a list of association vectors. An example of <code>parm</code> above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p>a vector of observed test statistics. An example of <code>parm</code> above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assobs</code></td>
<td>
<p>a list of ass and obs above. An example of <code>parm</code> above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are used internally by <code>relltest</code>
for computing raw bootstrap probabilities of phylogenetic inference.
Alternatively, we used <code>pvclust</code> to get raw bootstrap probabilities
of hierarchical clustering. In other cases, users may utilize
<code>scaleboot</code> function or prepare their own functions.
</p>
<p><code>scaleboot</code> performs multiscale bootstrap resampling for a
statistic defined by <code>fun</code>, which should be one of the two
possible forms <code>fun(x,w,parm)</code> and <code>fun(x,i,parm)</code>. The former
is used when <code>weight=TRUE</code>, and the weight
vector <code>w</code> is generated by a multinomial distribution. The latter
is used when <code>weight=FALSE</code>, and the index
vector <code>i</code> is generated by resampling <code class="reqn">n'</code> elements from
<code class="reqn">\{1,...,n\}</code>. When <code>count=TRUE</code>, <code>fun</code> should return
a logical, or a vector of logicals.
</p>
<p>Examples of <code>fun(x,w,parm)</code> are <code>countw.assmax</code> for AU p-values,
<code>countw.shtest</code> for SH-test of trees, and <code>countw.shtestass</code>
for SH-test of both trees and edges. The definitions are given below.
</p>
<pre>
countw.assmax &lt;- function(x,w,ass) {
  y &lt;- maxdif(wsumrow(x,w)) &lt;= 0 # countw.max
  if(is.null(ass)) y
  else {
    z &lt;- vector("logical",length(ass))
    for(i in seq(along=ass)) z[i] &lt;- any(y[ass[[i]]])
    z
  }
}

countw.shtest &lt;- function(x,w,obs)  maxdif(wsumrow(x,w)) &gt;= obs

countw.shtestass &lt;- function(x,w,assobs)
  unlist(assmaxdif(wsumrow(x,w),assobs$ass)) &gt;= assobs$obs
    
### weighted sum of row vectors
##
## x = matrix (array of row vectors)
## w = weight vector (for rows)
##
wsumrow &lt;- function(x,w) {
  apply(w*x,2,sum)*nrow(x)/sum(w)
}

### calc max diff
##
## y[i] := max_{j neq i} x[j] - x[i]
##
maxdif &lt;- function(x) {
  i1 &lt;- which.max(x)  # the largest element
  x &lt;- -x + x[i1]
  x[i1] &lt;- -min(x[-i1])  # the second largest value
  x
}

### calc assmaxdif
##
## y[[i]][j] := max_{k neq ass[[i]]} x[k] - x[ass[[i]][j]]
##
assmaxdif &lt;-  function(x,a) {
  y &lt;- vector("list",length(a))
  names(y) &lt;- names(a)
  for(i in seq(along=a))  y[[i]] &lt;- max(x[-a[[i]]]) - x[a[[i]]]
  y
}
</pre>
<p>When <code>count=TRUE</code>, the summation of outputs from <code>fun</code> is
calculated. This gives the frequencies for how many times the
hypotheses are supported by the bootstrap replicates.
</p>


<h3>Value</h3>

<p>If <code>onlyboot=TRUE</code>, then a list of raw results from the multiscale bootstrap
resampling is returned. The components are "stat" for list vectors of
outputs from <code>fun</code> (only when <code>count=FALSE</code>), "bps" for a
matrix of multiscale bootstrap probabilities (only when
<code>count=FALSE</code>), "nb" for the number of bootstrap replicates used,
and "sa" for the scales used. Note that scales are redefined by
<code>sa &lt;- nsize/round(nsize/sa)</code>, where <code>nsize</code> is the sample size.
</p>
<p>If <code>onlyboot=FALSE</code>, then the result of a call to 
<code>sbfit</code> is returned when  <code>count=TRUE</code>, otherwise
the result of <code>sbconf</code> is returned when  <code>count=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code>sbfit</code>, <code>sbconf</code>, <code>relltest</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## An example to calculate AU p-values for phylogenetic trees
## See also the Examples of "sbconf"
data(mam15) # load mam15.mt
sa &lt;- 9^seq(-1,1,length=13) # parameter for multiscale bootstrap
nb &lt;- 1000 # nb=10000 is better but slower
# Now compute bootstrap probabilities and fit models to them
sim &lt;- scaleboot(mam15.mt,nb,sa,countw.assmax) # takes some time (&lt; 1 min)
sim # show bootstrap probabilities and model fitting
summary(sim) # show AU p-vaslues

## End(Not run)

## Not run: 
## The following lines are only for illustration purpose
## a line from the definition of relltest
scaleboot(dat,nb,sa,countw.assmax,ass,cluster=cluster,
                 names.hp=na,nofit=nofit,models=models,seed=seed)

## two lines from rell.shtest (internal function)
scaleboot(z,nb,1,countw.shtest,tobs,cluster=cluster,
                 onlyboot=TRUE,seed=seed)
scaleboot(z,nb,1,countw.shtestass,pa,cluster=cluster,
                 onlyboot=TRUE,seed=seed)

## End(Not run)
</code></pre>


</div>