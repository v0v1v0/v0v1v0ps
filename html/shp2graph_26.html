<div class="container">

<table style="width: 100%;"><tr>
<td>points2network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Integrate a point data set into a network</h2>

<h3>Description</h3>

<p>A function to integrate an individual point data set into a network under different
rules (see details below).
</p>


<h3>Usage</h3>

<pre><code class="language-R">points2network(ntdata,pointsxy,approach=1,ELComputed=FALSE,longlat=F,
               Detailed=F, ea.prop=NULL)
</code></pre>


<h3>Arguments</h3>

                                                                   
<table>
<tr style="vertical-align: top;">
<td><code>ntdata</code></td>
<td>
<p>A “SpatialLinesDataFrame” or “SpatialLines” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointsxy</code></td>
<td>
<p>A two-column matrix of point coordinates (X, Y)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p>specified by an integer ranging from 1 to 4 to define the approach
for integration:
</p>
<p>1: Mapping each point to the nearest node in the network/graph
</p>
<p>2: Mapping each point to the nearest point (add them as nodes if they are not)
on the network
</p>
<p>3: Add a new edge(virtual edge) between each point and the nearest node
</p>
<p>4: Add a new edge(virtual edge) between each point and the nearest point 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ELComputed</code></td>
<td>
<p>If TRUE, the length of each edge will be calculated and returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>If TRUE, distances on an ellipse with WGS84 parameters will be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Detailed</code></td>
<td>
<p>If TRUE, all the vertices within the polylines of a spatial network
will be recognised as nodes; if FALSE, only two endpoints of each polyline are treated 
as nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
in the network “ntdata”) with values of 1 or 0:
</p>
<p>1: the corresponding column in the data frame will be kept for 
the new network;
</p>
<p>0: the corresponding column in the data frame will not be kept.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list consisted of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nodelist</code></td>
<td>
<p>A “nodelist” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgelist</code></td>
<td>
<p>An “edgelist” object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CoorespondIDs</code></td>
<td>
<p>A vector of the cooresponding node ID for each point in “pointsxy”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodexlist</code></td>
<td>
<p>A vector contains X-coordinates of all the nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodeylist</code></td>
<td>
<p>A vector contains Y-coordinates of all the nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Eadf</code></td>
<td>
<p>A data frame of attributes of the returned edges, of which the structure is
a data frame with [EdgeID,(attributes inherited from the input network data)]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VElist</code></td>
<td>
<p>A list of virtual edges if added, i.e. approaches 3 and 4 are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Edgelength</code></td>
<td>
<p>If “ELComputed” is TRUE, lengths of all the edges will be 
returned as a numeric vector; otherwise it will be NULL.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code>ptsinnt.view</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(ORN)
pts&lt;-spsample(ORN.nt, 100, type="random")
ptsxy&lt;-coordinates(pts)[,1:2]
ptsxy&lt;-cbind(ptsxy[,1]+0.008,ptsxy[,2]+0.008)
#Mapping each point to the nearest node in the network/graph
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=1)
ptsinnt.view(ntdata=rn, nodelist=res[[1]], pointsxy=ptsxy,
             CoorespondIDs=res[[3]])
#Mapping each point to the nearest point (add them as nodes if they are not) on 
#the network
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=2,ea.prop=rep(0,37))
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]]) 
#Add a new edge(Virtual edge) between each point and the nearest node
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=3,ea.prop=rep(0,37))
VElist&lt;-res[[7]]
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]], 
             VElist=VElist)
#Add a new edge(Virtual edge) between each point and the nearest point
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=4,ea.prop=rep(0,37))
VElist&lt;-res[[7]]
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]],
             VElist=VElist) 

## End(Not run)
</code></pre>


</div>