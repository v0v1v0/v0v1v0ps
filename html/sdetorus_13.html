<div class="container">

<table style="width: 100%;"><tr>
<td>crankNicolson2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crank–Nicolson finite difference scheme for the 2D Fokker–Planck equation with periodic boundaries</h2>

<h3>Description</h3>

<p>Implementation of the Crank–Nicolson scheme for solving the Fokker–Planck equation
</p>
<p style="text-align: center;"><code class="reqn">p(x, y, t)_t = -(p(x, y, t) b_1(x, y))_x -(p(x, y, t) b_2(x, y))_y+</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \frac{1}{2}(\sigma_1^2(x, y) p(x, y, t))_{xx} + \frac{1}{2}(\sigma_2^2(x, y) p(x, y, t))_{yy} + (\sigma_{12}(x, y) p(x, y, t))_{xy},</code>
</p>

<p>where <code class="reqn">p(x, y, t)</code> is the transition probability density of the toroidal diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=b_1(X_t,Y_t)dt+\sigma_1(X_t,Y_t)dW^1_t+\sigma_{12}(X_t,Y_t)dW^2_t,</code>
</p>

<p style="text-align: center;"><code class="reqn">dY_t=b_2(X_t,Y_t)dt+\sigma_{12}(X_t,Y_t)dW^1_t+\sigma_2(X_t,Y_t)dW^2_t.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">crankNicolson2D(u0, bx, by, sigma2x, sigma2y, sigmaxy, N, deltat, Mx, deltax,
  My, deltay, imposePositive = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u0</code></td>
<td>
<p>matrix of size <code>c(Mx * My, 1)</code> giving the initial condition matrix column-wise stored. Typically, the evaluation of a density highly concentrated at a given point. If <code>nt == 1</code>, then <code>u0</code> can be a matrix <code>c(Mx * My, nu0)</code> containing different starting values in the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bx, by</code></td>
<td>
<p>matrices of size <code>c(Mx, My)</code> containing the evaluation of the drift in the first and second space coordinates, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2x, sigma2y, sigmaxy</code></td>
<td>
<p>matrices of size <code>c(Mx, My)</code> containing the evaluation of the entries of the diffusion matrix (it has to be positive definite)<br><code>rbind(c(sigma2x, sigmaxy),
            c(sigmaxy, sigma2y))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>increasing integer vector of length <code>nt</code> giving the indexes of the times at which the solution is desired. The times of the solution are <code>delta * c(0:max(N))[N + 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltat</code></td>
<td>
<p>time step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mx, My</code></td>
<td>
<p>sizes of the equispaced spatial grids in <code class="reqn">[-\pi,\pi)</code> for each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltax, deltay</code></td>
<td>
<p>space grid discretizations for each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imposePositive</code></td>
<td>
<p>flag to indicate whether the solution should be transformed in order to be always larger than a given tolerance. This prevents spurious negative values. The tolerance will be taken as <code>imposePositiveTol</code> if this is different from <code>FALSE</code> or <code>0</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function makes use of <code>solvePeriodicTridiag</code> for obtaining implicitly the next step in time of the solution.
</p>
<p>If <code>imposePositive = TRUE</code>, the code implicitly assumes that the solution integrates to one at any step. This might b unrealistic if the initial condition is not properly represented in the grid (for example, highly concentrated density in a sparse grid).
</p>


<h3>Value</h3>


<ul>
<li>
<p> If <code>nt &gt; 1</code>, a matrix of size <code>c(Mx * My, nt)</code> containing the discretized solution at the required times with the <code>c(Mx, My)</code> matrix stored column-wise.
</p>
</li>
<li>
<p> If <code>nt == 1</code>, a matrix of size <code>c(Mx * My, nu0)</code> containing the discretized solution at a fixed time for different starting values.
</p>
</li>
</ul>
<h3>References</h3>

<p>Thomas, J. W. (1995). <em>Numerical Partial Differential Equations: Finite Difference Methods</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4899-7278-1">doi:10.1007/978-1-4899-7278-1</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Parameters
Mx &lt;- 100
My &lt;- 100
N &lt;- 200
x &lt;- seq(-pi, pi, l = Mx + 1)[-c(Mx + 1)]
y &lt;- seq(-pi, pi, l = My + 1)[-c(My + 1)]
m &lt;- c(pi / 2, pi)
p &lt;- c(0, 1)
u0 &lt;- c(outer(dWn1D(x, p[1], 0.5), dWn1D(y, p[2], 0.5)))
bx &lt;- outer(x, y, function(x, y) 5 * sin(m[1] - x))
by &lt;- outer(x, y, function(x, y) 5 * sin(m[2] - y))
sigma2 &lt;- matrix(1, nrow = Mx, ncol = My)
sigmaxy &lt;- matrix(0.5, nrow = Mx, ncol = My)

# Full trajectory of the solution (including initial condition)
u &lt;- crankNicolson2D(u0 = cbind(u0), bx = bx, by = by, sigma2x = sigma2,
                     sigma2y = sigma2, sigmaxy = sigmaxy,
                     N = 0:N, deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx,
                     My = My, deltay = 2 * pi / My)

# Mass conservation
colMeans(u) * 4 * pi^2

# Only final time
v &lt;- crankNicolson2D(u0 = cbind(u0), bx = bx, by = by, sigma2x = sigma2,
                     sigma2y = sigma2, sigmaxy = sigmaxy,
                     N = N, deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx,
                     My = My, deltay = 2 * pi / My)
sum(abs(u[, N + 1] - v))

## Not run: 
# Visualization of tpd
library(manipulate)
manipulate({
  plotSurface2D(x, y, z = matrix(u[, j + 1], Mx, My),
                main = round(mean(u[, j + 1]) * 4 * pi^2, 4),
                levels = seq(0, 2, l = 21))
  points(p[1], p[2], pch = 16)
  points(m[1], m[2], pch = 16)
}, j = slider(0, N))

## End(Not run)
</code></pre>


</div>