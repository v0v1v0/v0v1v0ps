<div class="container">

<table style="width: 100%;"><tr>
<td>creer_data.frame</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create p-values data-frame from pairwise tests of all possible
ratios of a compositional vector
</h2>

<h3>Description</h3>

<p>This function performs hypothesis testing on all possible pairwise
ratios or differences of a set of variables in a given data frame, and
store their results in a data.frame
</p>


<h3>Usage</h3>

<pre><code class="language-R">creer.DFp( d, noms, f.p = student.fpc,
           log = FALSE, en.log = !log,
           nom.var = 'R',
           noms.colonnes = c( "Cmp.1", "Cmp.2", "p" ),
           add.col = "delta", n.coeurs = 1,
           ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The data frame that contains the compositional variables. Other
objects will be coerced as data frames using
<code>as.data.frame</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.p</code></td>
<td>

<p>An R function that will perform the hypothesis test on a single
ratio (or log ratio, depending on <code>log</code> and <code>en.log</code>
values).
</p>
<p>This function should return a numeric vector, of which the first one
will typically be the p-value from the test â€” see
<code>creer.Mp</code> for details. 
</p>
<p>Such functions are provided for several common situations, see
references at the end of this manual page.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>en.log</code></td>
<td>
<p> If <code>TRUE</code>, the ratio will be log-transformed
before applying the hypothesis test computed by <code>f.p</code>. Don't
change the default unless you really know what you are doing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nom.var</code></td>
<td>
<p> A length-one character vector giving the name of the
variable containing a single ratio (or log-ratio). No sanity check
is performed on it: if you experience strange behaviour, check you
gave a valid column name, for instance using
<code>make.names</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noms.colonnes</code></td>
<td>
<p> A length-three character vector giving the names
of, respectively, the two columns of the data frame that will contain
the components identifiers and of the column that will contain the
p-value from the test (the first value returned by <code>f.p</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.col</code></td>
<td>
<p>A character vector giving the names of additional
columns of the data.frame, used for storing additional return values
of <code>f.p</code> (all but the first one).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to <code>f.p</code>, passed unchanged to
it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> This function constructs a data.frame with <code class="reqn">n\times
  (n-1)/2</code> rows, where <code>n = length( noms )</code> (after eventually
removing names in <code>noms</code> that do not correspond to numeric
variables). Each line of the data.frame  is the result of the
<code>f.p</code> function when applied on the ratio of variables whose names
are given in the first two columns (or on its log, if either <code>(log ==
  TRUE) &amp;&amp; (en.log == FALSE)</code> or <code>(log == FALSE) &amp;&amp; (en.log ==
  TRUE)</code>).
</p>


<h3>Value</h3>

<p> These function returns the data.frame obtained as described above.
</p>


<h3>Note</h3>

<p>Creating a data.frame seems slightly less efficient (in terms of
speed) than creating a dense matrix, so for compositionnal data with
only a few components and simple stastitical analysis were only a
single p-value is needed, consider using <code>creer.Mp</code>
instead.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p>Predefined <code>f.p</code> functions: <code>anva1.fpc</code> for one-way
analysis of variance; <code>kw.fpc</code> for the non-parametric
equivalent (Kruskal-Wallis test).
</p>
<p><code>grf.DFp to create a graphe from the obtained matrix.</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   # load the Circadian Genes Expression dataset, at day 4
   data( "BpLi_J4" )
   ng &lt;- names( BpLi_J4 )[ -c( 1:3 ) ] # Name of the genes
   
   # analysis function (complex design)
   #   1. the formula to be used
   frm &lt;- R ~  (1 | Patient) + Phenotype + Li + Phenotype:Li

   #   2. the function itself
   #    needs the lme4 package
   if ( TRUE == require( "lme4" ) ) {
     f.p &lt;- function( d, variable, ... ) {
          # Fit the model
          md &lt;- lmer( frm, data = d )

          # Get coefficients and standard errors
          cf &lt;- fixef( md )
          se &lt;- sqrt( diag( vcov( md ) ) )

          # Wald tests on these coefficients
          p &lt;- 2 * pnorm( -abs( cf ) / se )

          # Sending back the 4 p-values
          p
     }
 
     # CRAN does not like 'long' computations
     # =&gt; analyse only the first 6 genes
     #  (remove for real exemple!)
     ng &lt;- ng[ 1:6 ]

     # Create the data.frame with all results
     DF.p &lt;- creer.DFp( d = BpLi_J4, noms = ng,
                        f.p = f.p, add.col = c( 'p.NR', 'p.Li', 'p.I' ) )

     # Make a graphe from it and plot it
     #  for the interaction term, at the p = 0.2 threshold
     plot( grf.DFp( DF.p, p = 0.20, col.p = 'p.I' ) )
  }
</code></pre>


</div>