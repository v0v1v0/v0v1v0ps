<div class="container">

<table style="width: 100%;"><tr>
<td>string_clean_alias</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cleans a character vector from multiple patterns</h2>

<h3>Description</h3>

<p>Recursively cleans a character vector from several patterns. Quickly handle the
tedious task of data cleaning by taking advantage of the syntax.
You can also apply all sorts of cleaning operations by summoning <code>string_ops()</code> operations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_clean_alias(
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  namespace = NULL
)

string_clean(
  x,
  ...,
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame(),
  namespace = NULL
)

string_replace(
  x,
  pattern,
  replacement = "",
  pipe = " =&gt; ",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame()
)

stclean(
  x,
  ...,
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame(),
  namespace = NULL
)

streplace(
  x,
  pattern,
  replacement = "",
  pipe = " =&gt; ",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>replacement</code></td>
<td>
<p>Character scalar, default is the empty string. It represents the default
value by which the patterns found in the character strings will be replaced. For example
<code>string_clean(x, "e", replacement = "a")</code> turn all letters "e" in <code>x</code> into "a".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pipe</code></td>
<td>
<p>Character scalar, default is <code>" =&gt; "</code>. If thevalue of <code>pipe</code> is found in a pattern,
then the string is split w.r.t. the pipe and anything after the pipe becomes the replacement.
</p>
<p>For example in <code>string_clean(x, "e =&gt; a")</code> the default pipe is found in "e =&gt; a", so the pattern
"e" will be replaced with "a". In other terms, this is equivalent to <code>string_clean(x, "e", replacement = "a")</code>.
Example changing the pipe: you can obtain the previous result with <code>string_clean(x, "e|&gt;a", pipe = "|&gt;")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>Character scalar, default is <code>",[ \t\n]+"</code> (which means a comma followed with spaces
and/or new lines). By default the patterns to be replaced are comma separated, that is
the pattern is split w.r.t. the argument <code>split</code> and a replacement is done for each sub-pattern.
</p>
<p>Use <code>NULL</code> or the empty string to disable pattern separation.
</p>
<p>For example: let's look at <code>string_clean(x, "w/one, two =&gt; three")</code>. First the flag "word" is extracted from
the pattern (see arg. <code>...</code>) as well as the replacement (see arg. <code>pipe</code>), leading to "one, two" the
pattern to be replaced. Then the pattern is split w.r.t. <code>split</code>, leading
to two patterns "one" and "two". Hence the words (thanks to the flag "w") "one" and "two" from
the string <code>x</code> will be replaced with "three".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then when a pattern is found
in a string, the full string is replaced (instead of just the pattern). Note, <em>importantly</em>,
that when <code>total = TRUE</code> you can use logical operators in the patterns.
</p>
<p>Example: <code>string_clean(x, "wi/ &amp; two, three &amp; !four =&gt; ", total = TRUE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>single</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether, in substitutions, to stop at
the first match found. Ex: <code>string_clean("abc", "[[:alpha:]] =&gt; _", single = TRUE)</code> leads
to <code>"_bc"</code>, while <code>string_clean("abc", "[[:alpha:]] =&gt; _")</code> leads to <code>"___"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code>string_magic_register_fun()</code> or <code>string_magic_register_ops()</code>.
</p>
<p>If so pass the name of your package in this argument so that your function can access
the new <code>string_magic</code> operations defined within your package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Character scalars representing patterns. A pattern is of the form
"flags/pat1, pat2 =&gt; replacement". This means that patterns 'pat1' and 'pat2' will be replaced
with the string 'replacement'. By default patterns are comma separated and the replacement comes
after a ' =&gt; ' (see args <code>split</code> and <code>pipe</code> to change this). By default the replacement is the empty string
(so "pat1, pat2" <em>removes</em> the patterns).
</p>
<p>Available regex flags are: 'word' (add word boundaries), 'ignore' (the case), 'fixed' (no regex),
'total', 'single' and 'magic'.
The flag <code>total</code> leads to a <em>total replacement</em> of the string if the pattern is found.
The flag 'magic' allows to interpolate variables within the pattern.  Use flags
with comma separation ("word, total/pat") or use only their initials ("wt/pat").
</p>
<p>Starting with an '@' leads to operations in <code>string_ops()</code>. Ex: "@ascii, lower, ws" turns
the string into ASCII, lowers the case and normalizes white spaces (see help of <code>string_ops()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>A character scalar containing a regular expression pattern to be replaced.
You can write the replacement directly in the string after a pipe: ' =&gt; ' (see arg. <code>pipe</code> to change this).
By default the replacement is the empty string (so "pat1" <em>removes</em> the pattern).
</p>
<p>Available regex flags are: 'word' (add word boundaries), 'ignore' (the case), 'fixed' (no regex),
'total', 'single' and 'magic'.
The flag <code>total</code> leads to a <em>total replacement</em> of the string if the pattern is found.
The flag 'magic' allows to interpolate variables within the pattern.  Use flags
with comma separation ("word, total/pat") or use only their initials ("wt/pat").</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The main usage returns a character vector of the same length as the vector in input.
Note, however, that since you can apply arbitrary <code>string_ops()</code> operations, the length and type
of the final vector may depend on those (if they are used).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_clean_alias()</code>: Create a <code>string_clean</code> alias with custom defaults
</p>
</li>
<li> <p><code>string_replace()</code>: Simplified version of <code>string_clean</code>
</p>
</li>
<li> <p><code>stclean()</code>: Alias to <code>string_clean</code>
</p>
</li>
<li> <p><code>streplace()</code>: Alias to <code>string_replace</code>
</p>
</li>
</ul>
<h3>Regular expression flags specific to replacement</h3>

<p>This function benefits from two specific regex flags: "total" and "single".
</p>

<ul>
<li>
<p> "total" replaces the <em>complete string</em> if the pattern is found (remember that the
default behavior is to replace just the pattern).
</p>
</li>
<li>
<p> "single" performs a single substitution for each string element and stops there.
Only the first match of each string is replaced. Technically we use <code>base::sub()</code>
internally instead of <code>base::gsub()</code>.
</p>
</li>
</ul>
<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant <em>"any character"</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".
</p>
<p>The four flags always available are: "ignore", "fixed", "word" and "magic".
</p>

<ul>
<li>
<p> "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)"
at the beginning of the pattern.
</p>
</li>
<li>
<p> "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li>
<p> "word" adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, "word/one, two" is treated as "\b(one|two)\b". Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to " I ambushed?" thanks to the flags "ignore" and "word".
</p>
</li>
<li>
<p> "magic" allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code>string_is()</code>, <code>string_get()</code>, <code>string_clean()</code>, <code>string_split2df()</code>.
Chain basic operations with <code>string_ops()</code>. Clean character vectors efficiently
with <code>string_clean()</code>.
</p>
<p>Use <code>string_vec()</code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code>string_magic()</code>. You can change <code>string_magic</code>
default values with <code>string_magic_alias()</code> and add custom operations with <code>string_magic_register_fun()</code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code>cat_magic()</code> and <code>message_magic()</code>.
</p>
<p>Other tools with aliases: 
<code>cat_magic_alias()</code>,
<code>string_magic()</code>,
<code>string_magic_alias()</code>,
<code>string_ops_alias()</code>,
<code>string_vec_alias()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = c("hello world  ", "it's 5 am....")

# we clean the o's and the points (we use 'fixed' to trigger fixed-search)
string_clean(x, "o", "f/.")
# equivalently
string_clean(x, "fixed/o, .")
# equivalently
string_clean(x, "o, .", fixed = TRUE)
# equivalently
string_clean(x, "o", ".", fixed = TRUE)

#
# chaining operations: example using cars
#

cars = row.names(mtcars)
new = string_clean(cars, 
           # replace strings containing "Maz" with Mazda
           "total/Maz =&gt; Mazda", 
           # replace the word 'Merc' with Mercedes
           "wi/merc =&gt; Mercedes",
           # replace strings containing "Merc" and a digit followed with an 'S'
           "t/Merc &amp; \\dS =&gt; Mercedes S!",
           # put to lower case, remove isolated characters and normalize white spaces
           "@lower, ws.isolated")

cbind(cars, new)


</code></pre>


</div>