<div class="container">

<table style="width: 100%;"><tr>
<td>update_snapshot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update a historical table</h2>

<h3>Description</h3>

<p><code>update_snapshots</code> makes it easy to create and update a historical data table on a remote (SQL) server.
The function takes the data (<code>.data</code>) as it looks on a given point in time (<code>timestamp</code>) and then updates
(or creates) an remote table identified by <code>db_table</code>.
This update only stores the changes between the new data (<code>.data</code>) and the data currently stored on the remote.
This way, the data can be reconstructed as it looked at any point in time while taking as little space as possible.
</p>
<p>See <code>vignette("basic-principles")</code> for further introduction to the function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">update_snapshot(
  .data,
  conn,
  db_table,
  timestamp,
  filters = NULL,
  message = NULL,
  tic = Sys.time(),
  logger = NULL,
  enforce_chronological_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br>
Data object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conn</code></td>
<td>
<p>(<code>DBIConnection(1)</code>)<br>
Connection object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>db_table</code></td>
<td>
<p>(<code style="white-space: pre;">⁠id-like object(1)⁠</code>)<br>
A table specification (coercible by <code>id()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timestamp</code></td>
<td>
<p>(<code>POSIXct(1)</code>, <code>Date(1)</code>, or <code>character(1)</code>)<br>
The timestamp describing the data being processed (not the current time).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filters</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br>
A object subset data by.
If filters is <code>NULL</code>, no filtering occurs.
Otherwise, an <code>inner_join()</code> is performed using all columns of the filter object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>(<code>character(1)</code>)<br>
A message to add to the log-file (useful for supplying metadata to the log).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tic</code></td>
<td>
<p>(<code>POSIXct(1)</code>)<br>
A timestamp when computation began. If not supplied, it will be created at call-time
(used to more accurately convey the runtime of the update process).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logger</code></td>
<td>
<p>(<code>Logger(1)</code>)<br>
A configured logging object. If none is given, one is initialized with default arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enforce_chronological_order</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Are updates allowed if they are chronologically earlier than latest update?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p>filter_keys
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  conn &lt;- get_connection()

  data &lt;- dplyr::copy_to(conn, mtcars)

  # Copy the first 3 records
  update_snapshot(
    head(data, 3),
    conn = conn,
    db_table = "test.mtcars",
    timestamp = Sys.time()
  )

  # Update with the first 5 records
  update_snapshot(
    head(data, 5),
    conn = conn,
    db_table = "test.mtcars",
    timestamp = Sys.time()
  )

  dplyr::tbl(conn, "test.mtcars")

  close_connection(conn)

</code></pre>


</div>