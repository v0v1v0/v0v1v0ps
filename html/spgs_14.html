<div class="container">

<table style="width: 100%;"><tr>
<td>cylinder.counts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Count Cylinders (Fixed-Offset Patterns) in Character Vectors
</h2>

<h3>Description</h3>

<p>Count fixed tuples of not necessarily adjacent symbols/elements in a character vector.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cylinder.counts(x, cylinder, case=c("lower", "upper", "as is"), circular=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a character vector or an object that can be coersed to a character vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cylinder</code></td>
<td>

<p>A vector of indices specifying the form of cylinders to count.  See ‘Details’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case</code></td>
<td>

<p>determines how labels for the array should be generated: in
lowercase, in uppercase or left as is, in which case labels such as “b”
and “B” will be seen as distinct symbols and counted separately.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circular</code></td>
<td>

<p>Determines if the vector should be treated as circular or not.  The default is 
<code>TRUE</code>, meaning that the start and end of the sequence will be joined 
together for the purpose of counting.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>cylinder</code> represents a set of symbol patterns that one wishes to count in 
the sequence <code>x</code>. For example, if <code>cylinder</code> is <code>c(1,3,5)</code>, then 
this function will count occurrences of all patterns of the form ‘<span class="samp">⁠u.v.w⁠</span>’, 
where ‘<span class="samp">⁠u⁠</span>’, ‘<span class="samp">⁠v⁠</span>’ and ‘<span class="samp">⁠w⁠</span>’ can be any symbol present in <code>x</code> and 
<code>.</code> stands for a symbol whose value is not relevant to the pattern.    
</p>
<p>Suppose that <code>x</code> is a sequence of the nucleotides <code>a</code>, <code>c</code>, 
<code>g</code> and <code>t</code>.  Then, <code>cylinder=1:2</code> will count the occurrences of 
all 16 dinucleotides: <code>aa</code>, <code>ac</code>, <code>ag</code>, <code>at</code>, <code>ca</code>, 
<code>cc</code>, ....  In contrast, <code>cylinder=c(1,3)</code> will counts 16 sets of 
trinucleotides:  <code>a.a</code>, <code>a.c</code>, <code>a.g</code>, <code>a.t</code>, <code>c.a</code>, 
<code>c.c</code>, <code>c.g</code>, ....  the dot “<code>.</code>” stands for any 
nucleotide, so that <code>a.c</code> represents the set <code>aac</code>, <code>acc</code>, 
<code>agc</code>, <code>atg</code>.  In both of these examples, a <code class="reqn">4\times 4</code> 
array of counts will be produced, but in the first case the array will 
represent counts of dinucleotides, while in the second case it will represent 
counts of groups of trinucleotides.
</p>
<p>If <code>circular</code> is <code>TRUE</code>, the vector <code>x</code> is treated as circular so that the 
some of all the counts in the resulting array is equal to the length of the 
vector and the sums across all dimentions of the array are equivalent, that is: 
writing<br><code>counts &lt;- cylinder.counts(x, cylinder=c(1,3,5))</code> <br>
for some character sequence x, then <br><code>apply(counts,1,sum)</code>, <code>apply(counts,2,sum)</code> and <code>apply(counts,3,sum)</code><br>
will all be identical.
</p>
<p>On the other hand, if <code>circular</code> is <code>FALSE</code>, the sum of all the 
entries in the counts array will be less than the length of the vector and 
there will be a discrepancy between the sums over the various dimensions.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n</code>-dimensional array of counts, where <code class="reqn">n</code> is the length of 
<code>cylinder</code>.
</p>


<h3>Note</h3>

<p><code>table</code>is more efficient (by almost a factor of 2) at computing the 
counts of cylinders of length 1, whereas <code>cylinder.counts</code> is faster and 
uses less memory than  for cylinders of length greater than 1.  
</p>


<h3>Author(s)</h3>

<p>Andrew Hart and Servet Martínez
</p>


<h3>See Also</h3>

<p><code>pair.counts</code>, <code>triple.counts</code>, 
<code>quadruple.counts</code>, 
<code>array2vector</code>, <code>table2vector</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate an IID uniform DNA sequence
seq &lt;- simulateMarkovChain(5000, matrix(0.25, 4, 4), states=c("a","c","g","t"))
cylinder.counts(seq, 1) #essentially the same as unclass(table(seq))
cylinder.counts(seq, 1:5) #counts of all 5-mers in the sequence

 #counts of all patterns of the form a.b where a and b represent
 #specific symbols and . denotes an arbitrary symbol.
 pat &lt;- cylinder.counts(seq, c(1, 3))
#For example, pat["a","c"] gives the number of times that any of 
#the following 4 words appears in the sequence:  aac, acc, agc, atc.
identical(cylinder.counts(seq, c(1,3)), apply(cylinder.counts(seq, 1:3), c(1, 3), sum))

##some relationships between cylinder.counts and other functionns
identical(cylinder.counts(seq, 1:2), pair.counts(seq))
identical(cylinder.counts(seq, 1:3), triple.counts(seq))
identical(cylinder.counts(seq, 1:4), quadruple.counts(seq))

#The following relationship means that counts on circular sequences are 
#invariant under translationn
identical(cylinder.counts(seq, 1:6), cylinder.counts(seq, 10:15))

#Treating seq as non circular, most of the preceding relationships continue to hold
identical(cylinder.counts(seq, 1:2, circular=FALSE), 
  pair.counts(seq, circular=FALSE))
identical(cylinder.counts(seq, 1:3, circular=FALSE), 
triple.counts(seq, circular=FALSE))
identical(cylinder.counts(seq, 1:4, circular=FALSE), 
  quadruple.counts(seq, circular=FALSE))
#The following relationship no longer holds; that is, non-circular counts
#are not invariant under translation.
identical(cylinder.counts(seq, 1:6, circular=FALSE), 
  cylinder.counts(seq, 10:15, circular=FALSE))
</code></pre>


</div>