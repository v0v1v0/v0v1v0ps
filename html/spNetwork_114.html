<div class="container">

<table style="width: 100%;"><tr>
<td>network_listw.mc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Network distance listw (multicore)</h2>

<h3>Description</h3>

<p>Generate listw object (spdep like) based on network distances with multicore support.
</p>


<h3>Usage</h3>

<pre><code class="language-R">network_listw.mc(
  origins,
  lines,
  maxdistance,
  method = "centroid",
  point_dist = NULL,
  snap_dist = Inf,
  line_weight = "length",
  mindist = 10,
  direction = NULL,
  dist_func = "inverse",
  matrice_type = "B",
  grid_shape = c(1, 1),
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>origins</code></td>
<td>
<p>A feature collection of linestrings, points or polygons for
which the spatial neighbouring list will be built.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdistance</code></td>
<td>
<p>The maximum distance between two observations to consider
them as neighbours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating how the starting points will be built. If
'centroid' is used, then the centre of lines or polygons is used. If
'pointsalong' is used, then points will be placed along polygons' borders
or along lines as starting and end points. If 'ends' is used (only for
lines) the first and last vertices of lines are used as starting and ending
points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point_dist</code></td>
<td>
<p>A float, defining the distance between points when the
method pointsalong is selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snap_dist</code></td>
<td>
<p>the maximum distance to snap the start and end points on the
network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_weight</code></td>
<td>
<p>The weights to use for lines. Default is "length" (the
geographical length), but can be the name of a column. The value is
considered proportional with the geographical length of the lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mindist</code></td>
<td>
<p>The minimum distance between two different observations. It is
important for it to be different from 0 when a W style is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Indicates a field giving information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be "FT" (From - To), "TF" (To - From) or "Both".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_func</code></td>
<td>
<p>Indicates the function to use to convert the distance
between observation in spatial weights. Can be 'identity', 'inverse',
'squared inverse' or a function with one parameter x that will be
vectorized internally</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrice_type</code></td>
<td>
<p>The type of the weighting scheme. Can be 'B' for Binary,
'W' for row weighted, or 'I' (identity) see the documentation of
spdep::nb2listw for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its progress</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>The number of digits to retain in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are added as
vertices to lines.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A listw object (spdep like) if matrice_type is "B" or "W". If
matrice_type is I, then a list with a nblist object and a list of weights
is returned.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(mtl_network)
future::plan(future::multisession(workers=1))
listw &lt;- network_listw.mc(mtl_network,mtl_network,maxdistance=500,
        method = "centroid", line_weight = "length",
        dist_func = 'squared inverse', matrice_type='B', grid_shape = c(2,2))
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>


</div>