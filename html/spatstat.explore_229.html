<div class="container">

<table style="width: 100%;"><tr>
<td>Kinhom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inhomogeneous K-function</h2>

<h3>Description</h3>

<p>Estimates the inhomogeneous <code class="reqn">K</code> function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  Kinhom(X, lambda=NULL, ..., r = NULL, breaks = NULL,
    correction=c("border", "bord.modif", "isotropic", "translate"),
    renormalise=TRUE,
    normpower=1,
    update=TRUE,
    leaveoneout=TRUE,
    nlarge = 1000,
    lambda2=NULL, reciplambda=NULL, reciplambda2=NULL,
    diagonal=TRUE,
    sigma=NULL, varcov=NULL,
    ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">K</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Extra arguments. Ignored if <code>lambda</code> is present.
Passed to <code>density.ppp</code> if <code>lambda</code> is omitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>,
<code>"none"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>renormalise</code></td>
<td>

<p>Logical. Whether to renormalise the estimate. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code>update.ppm</code> or <code>update.kppm</code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaveoneout</code></td>
<td>

<p>Logical value (passed to <code>density.ppp</code> or
<code>fitted.ppm</code>) specifying whether to use a
leave-one-out rule when calculating the intensity.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlarge</code></td>
<td>

<p>Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed, using a fast algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>

<p>Advanced use only.
Matrix containing estimates of the products
<code class="reqn">\lambda(x_i)\lambda(x_j)</code>
of the intensities at each pair of data points 
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reciplambda</code></td>
<td>

<p>Alternative to <code>lambda</code>.
Values of the estimated <em>reciprocal</em> <code class="reqn">1/\lambda</code>
of the intensity function.
Either a vector giving the reciprocal intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
reciprocal intensity values at all locations,
or a <code>function(x,y)</code> which can be evaluated to give the
reciprocal intensity value at any location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reciplambda2</code></td>
<td>

<p>Advanced use only. Alternative to <code>lambda2</code>.
A matrix giving values of the estimated <em>reciprocal products</em>
<code class="reqn">1/\lambda(x_i)\lambda(x_j)</code>
of the intensities at each pair of data points 
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagonal</code></td>
<td>

<p>Do not use this argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma,varcov</code></td>
<td>

<p>Optional arguments passed to  <code>density.ppp</code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This computes a generalisation of the <code class="reqn">K</code> function
for inhomogeneous point patterns, proposed by
Baddeley, Moller and Waagepetersen (2000).
</p>
<p>The “ordinary” <code class="reqn">K</code> function
(variously known as the reduced second order moment function
and Ripley's <code class="reqn">K</code> function), is
described under <code>Kest</code>. It is defined only
for stationary point processes.
</p>
<p>The inhomogeneous <code class="reqn">K</code> function
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
is a direct generalisation to nonstationary point processes.
Suppose <code class="reqn">x</code> is a point process with non-constant intensity
<code class="reqn">\lambda(u)</code> at each location <code class="reqn">u</code>.
Define <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> to be the expected
value, given that <code class="reqn">u</code> is a point of <code class="reqn">x</code>,
of the sum of all terms
<code class="reqn">1/\lambda(x_j)</code>
over all points <code class="reqn">x_j</code>
in the process separated from <code class="reqn">u</code> by a distance less than <code class="reqn">r</code>.
This reduces to the ordinary <code class="reqn">K</code> function if
<code class="reqn">\lambda()</code> is constant.
If <code class="reqn">x</code> is an inhomogeneous Poisson process with intensity
function <code class="reqn">\lambda(u)</code>, then
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r) = \pi r^2</code>.
</p>
<p>Given a point pattern dataset, the 
inhomogeneous <code class="reqn">K</code> function can be estimated
essentially by summing the values
<code class="reqn">1/(\lambda(x_i)\lambda(x_j))</code>
for all pairs of points <code class="reqn">x_i, x_j</code>
separated by a distance less than <code class="reqn">r</code>.
</p>
<p>This allows us to inspect a point pattern for evidence of 
interpoint interactions after allowing for spatial inhomogeneity
of the pattern. Values 
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r) &gt; \pi r^2</code>
are suggestive of clustering.
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>.
It may be either
</p>

<dl>
<dt>a numeric vector</dt>
<dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt>
<dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt>
<dd>
<p>(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt>
<dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt>
<dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother.
</p>
</dd>
</dl>
<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code>blur</code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother,
as described in Baddeley, Moller
and Waagepetersen (2000).  The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code>density.ppp</code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code>density.ppp</code> along with any extra arguments.
</p>
<p>Edge corrections are used to correct bias in the estimation
of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}</code>.
Each edge-corrected estimate of
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> is
of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \widehat K_{\mbox{\scriptsize\rm inhom}}(r) = (1/A)
    \sum_i \sum_j \frac{1\{d_{ij} \le r\}
      e(x_i,x_j,r)}{\lambda(x_i)\lambda(x_j)}
  </code>
</p>

<p>where <code>A</code> is a constant denominator, 
<code class="reqn">d_{ij}</code> is the distance between points
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>, and
<code class="reqn">e(x_i,x_j,r)</code> is
an edge correction factor. For the ‘border’ correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac{1(b_i &gt; r)}{\sum_j 1(b_j &gt; r)/\lambda(x_j)}
  </code>
</p>

<p>where <code class="reqn">b_i</code> is the distance from <code class="reqn">x_i</code>
to the boundary of the window. For the ‘modified border’
correction, 
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac{1(b_i &gt; r)}{\mbox{area}(W \ominus r)}
  </code>
</p>

<p>where <code class="reqn">W \ominus r</code> is the eroded window obtained
by trimming a margin of width <code class="reqn">r</code> from the border of the original
window.
For the ‘translation’ correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac 1 {\mbox{area}(W \cap (W + (x_j - x_i)))}
  </code>
</p>

<p>and for the ‘isotropic’ correction,
</p>
<p style="text-align: center;"><code class="reqn">
    e(x_i,x_j,r) =
    \frac 1 {\mbox{area}(W) g(x_i,x_j)}
  </code>
</p>

<p>where <code class="reqn">g(x_i,x_j)</code> is the fraction of the
circumference of the circle with centre <code class="reqn">x_i</code> and radius
<code class="reqn">||x_i - x_j||</code> which lies inside the window.
</p>
<p>If <code>renormalise=TRUE</code> (the default), then the estimates
described above 
are multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{area}(W)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1 (for consistency with
previous versions of <span class="pkg">spatstat</span>)
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>
<p>If the point pattern <code>X</code> contains more than about 1000 points,
the isotropic and translation edge corrections can be computationally
prohibitive. The computations for the border method are much faster,
and are statistically efficient when there are large numbers of
points. Accordingly, if the number of points in <code>X</code> exceeds
the threshold <code>nlarge</code>, then only the border correction will be
computed. Setting <code>nlarge=Inf</code> or <code>correction="best"</code>
will prevent this from happening.
Setting <code>nlarge=0</code> is equivalent to selecting only the border
correction with <code>correction="border"</code>.
</p>
<p>The pair correlation function can also be applied to the
result of <code>Kinhom</code>; see <code>pcf</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code>fv.object</code>).
</p>
<p>Essentially a data frame containing at least the following columns,
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code> has been estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>vector of values of <code class="reqn">\pi r^2</code>,
the theoretical value of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
for an inhomogeneous Poisson process
</p>
</td>
</tr>
</table>
<p>and containing additional columns
according to the choice specified in the <code>correction</code>
argument. The additional columns are named
<code>border</code>, <code>trans</code> and <code>iso</code>
and give the estimated values of 
<code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>
using the border correction, translation correction,
and Ripley isotropic correction, respectively.
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">K_{\mbox{\scriptsize\rm inhom}}(r)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.,
Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<em>Statistica Neerlandica</em> <b>54</b>, 329–350.
</p>


<h3>See Also</h3>

<p><code>Kest</code>,
<code>pcf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # inhomogeneous pattern of maples
  X &lt;- unmark(split(lansing)$maple)
  

  if(require("spatstat.model")) {
    # (1) intensity function estimated by model-fitting
    # Fit spatial trend: polynomial in x and y coordinates
    fit &lt;- ppm(X, ~ polynom(x,y,2), Poisson())
    # (a) predict intensity values at points themselves,
    #     obtaining a vector of lambda values
    lambda &lt;- predict(fit, locations=X, type="trend")
    # inhomogeneous K function
    Ki &lt;- Kinhom(X, lambda)
    plot(Ki)
    # (b) predict intensity at all locations,
    #     obtaining a pixel image
    lambda &lt;- predict(fit, type="trend")
    Ki &lt;- Kinhom(X, lambda)
    plot(Ki)
  }

  # (2) intensity function estimated by heavy smoothing
  Ki &lt;- Kinhom(X, sigma=0.1)
  plot(Ki)

  # (3) simulated data: known intensity function
  lamfun &lt;- function(x,y) { 50 + 100 * x }
  # inhomogeneous Poisson process
  Y &lt;- rpoispp(lamfun, 150, owin())
  # inhomogeneous K function
  Ki &lt;- Kinhom(Y, lamfun)
  plot(Ki)

  # How to make simulation envelopes:
  #      Example shows method (2)
  if(interactive()) {
    smo &lt;- density.ppp(X, sigma=0.1)
    Ken &lt;- envelope(X, Kinhom, nsim=99,
                    simulate=expression(rpoispp(smo)),
                    sigma=0.1, correction="trans")
    plot(Ken)
  }
</code></pre>


</div>