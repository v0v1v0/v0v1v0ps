<div class="container">

<table style="width: 100%;"><tr>
<td>sm.regression</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nonparametric regression with one or two covariates.</h2>

<h3>Description</h3>

<p>This function creates a nonparametric regression estimate from data 
consisting of a single response variable and one or two covariates.
In two dimensions a perspective, image (<code>image</code>), contour (<code>slice</code>) 
or <code>rgl</code> plot of the estimated regression surface is produced.  
A number of other features of the construction of the estimate, and of 
its display, can be controlled.
</p>
<p>If the <code>rpanel</code> package is available, an interactive panel can be activated
to control various features of the plot.  
</p>


<h3>Usage</h3>

<pre><code class="language-R"> sm.regression(x, y, h, design.mat = NA, model = "none", weights = NA,
                 group = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector, or two-column matrix, of covariate values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>a vector of length 1 or 2 giving the smoothing parameter.  A normal kernel
function is used and <code>h</code> is its standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design.mat</code></td>
<td>
<p>the design matrix used to produce <code>y</code> when these are assumed to be the 
residuals from a linear model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a character variable which defines a reference model.  The settings
<code>"none"</code>, <code>"no effect"</code> and <code>"linear"</code> and all valid.  Note that
when a <code>group</code> argument is used then <code>model</code> should be set to 
<code>"equal"</code> or <code>"parallel"</code>, as befits an analysis of covariance model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a vector  which allows the kernel functions associated with the observations 
to take different weights.  This is useful, in particular, when different
observations have different precisions.
The normal usage of this parameter is to associate observations with
frequencies; if the  <code>weights</code> are not integers, they are converted
to  integers, but in this case the standard errors and tests which are
computed cannot be considered.
This argument applies only to the case of one covariate.
Use of this parameter is incompatible with <code>binning</code>; hence
<code>nbins</code> must then be set to 0 or left at its default value <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>a vector of groups indicators (numeric or character values) or
a factor.  If this argument is used then the data are passed to the <code>sm.ancova</code>
function.  See the details of the <code>model</code> argument above in that case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other optional parameters are passed to the <code>sm.options</code>
function, through a mechanism which limits their effect only to this
call of the function; those relevant for this function are the following:
<code>display</code>,
<code>hmult</code>,
<code>h.weights</code>,
<code>poly.index</code>,
<code>band</code>,
<code>add</code>,
<code>ngrid</code>,
<code>eval.points</code>,
<code>se</code>,
<code>se.breaks</code>,
<code>period</code>,
<code>xlab</code>,
<code>ylab</code>,
<code>zlab</code>,
<code>hull</code>,
<code>panel</code>,
<code>panel.plot</code>,
<code>lty</code>,
<code>col</code>,
<code>col.band</code>,
<code>col.mesh</code>,
<code>col.points</code>,
<code>col.palette</code>;
see the documentation of <code>sm.options</code> for their description.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>display</code> is set to <code>"persp"</code> or <code>"rgl"</code>, a number of 
graphical options are available.  By setting the <code>col</code> parameter to
<code>"height"</code> or <code>"se"</code>, the surface will be painted by colours to
reinforce the perception of height or indicate the relative sizes of the
standard errors respectively.  When <code>model</code> is not <code>"none"</code>, 
the colour coding refers to the number of standard errors which separate
the smooth regression surface and the nominated model at each position.
The parameter <code>"se.breaks"</code>, whose default value is <code>c(-3, -2, 3, 3)</code> 
can then be used to set the colour ranges.  In this case, <code>col.palette</code>
must be set to a list of colours whose length is one greater than the length
of the cut-points in <code>"se.breaks"</code>.  If this is not the case, the
default colour palette 
<code>rev(rainbow(length(opt$se.breaks) + 1, start = 0/6, end = 4/6))</code>.
</p>
<p>If the argument <code>col</code> is not set then surface painting will be determined
by the setting of <code>se</code>.  If neither is set then colour painting will be
activated by default if <code>model != "none"</code>. (In this latter case, the
argument <code>band</code>, retained from earlier versions for compatibility, will
also be examined.)
</p>
<p>When <code>display</code> is set to <code>"rgl"</code>, some additional parameters
can be used to control details of the plot.  Transparency can be set by
<code>alpha</code>, which lies between <code>0</code> and <code>1</code>.  When <code>alpha</code>
is set to a vector of length two, the first component refers to the surface
panels and the second to the surface mesh.  Setting a component of <code>alpha</code>
to <code>0</code> will remove the corresponding feature from the plot.  <code>col.mesh</code>,
whose valid values match those of <code>col</code>, controls the colour of the surface
mesh.  The logical parameter <code>lit</code> has the same meaning as in the <code>rgl</code>
package; see <code>material3d</code>.
</p>
<p>When <code>panel</code> is set to <code>"TRUE"</code>, an interactive control panel is
created if the <code>rpanel</code> package is available.
</p>
<p>If a covariate is on a cyclical scale, this can be incorporated by setting
the <code>period</code> argument to a vector (of length 1 or 2) whose components give 
the values of the periods, or NA if the covariate is not periodic.
</p>
<p>See Chapters 3, 4 and 5 of the first reference below for the details of the
construction of the estimate and its standard error.  The second reference
gives further details and examples of surface painting.
</p>


<h3>Value</h3>

<p>a list containing the values of the estimate at the evaluation points,
the smoothing parameter and the smoothing parameter weights.
If a reference model has been specified and <code>test</code> set to
<code>TRUE</code>, then the p-value of the test
is also returned.  When there is only one covariate, the weights associated
with different observations, an estimate of the error standard deviation and 
the standard error of the estimate are also returned.  If a reference model 
has been specified, this standard error refers to the comparison between 
the estimate and the reference model, and the values defining the reference 
model are also returned.
If an <code>rgl</code> display is used, then the indices of the surface and lines
used to create the display are returned.
</p>


<h3>Side Effects</h3>

<p>a plot on the current graphical device is produced, unless the option 
<code>display="none"</code> is set.  
</p>


<h3>References</h3>

<p>Bowman, A.W. and Azzalini, A. (1997). 
<em>Applied Smoothing Techniques for Data Analysis:</em>
<em>the Kernel Approach with S-Plus Illustrations.</em>
Oxford University Press, Oxford.
</p>
<p>Bowman, A.W. (2006).
Comparing nonparametric surfaces.
<em>Statistical Modelling</em>, 6, 279-299.
</p>


<h3>See Also</h3>

<p><code>hcv</code>, <code>sm</code>, <code>sm.ancova</code>,
<code>sm.binomial</code>, <code>sm.poisson</code>,
<code>sm.regression.autocor</code>, <code>sm.survival</code>,
<code>sm.options</code>, <code>sm.surface3d</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">with(trawl, {
   Zone92   &lt;- (Year == 0 &amp; Zone == 1)
   Position &lt;- cbind(Longitude - 143, Latitude)
   dimnames(Position)[[2]][1] &lt;- "Longitude - 143"

   par(mfrow = c(2, 2))
   sm.regression(Longitude, Score1, method = "aicc", col = "red",
       model = "linear")
   sm.regression(Position[Zone92, ], Score1[Zone92], display = "image", 
       theta = 120)
   sm.regression(Position[Zone92, ], Score1[Zone92], df = 12, col = "se",
       theta = 120)
   sm.regression(Position[Zone92, ], Score1[Zone92], df = 12, col = "se", 
       model = "linear", theta = 120)
   par(mfrow = c(1, 1))
})

# sm.regression(Position[Zone92, 2:1], Score1[Zone92], display = "rgl", df = 12)
# sm.regression(Position[Zone92, 2:1], Score1[Zone92], display = "rgl", df = 12,
#       alpha = c(0.9, 1), col = "se", model = "linear")

# sm.regression(Position[Zone92, 1], Score1[Zone92], panel = TRUE)
# sm.regression(Position[Zone92,  ], Score1[Zone92], panel = TRUE)
# sm.regression(Position[Zone92,  ], Score1[Zone92], panel = TRUE, display = "rgl")

</code></pre>


</div>