<div class="container">

<table style="width: 100%;"><tr>
<td>adj</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast <code>adjacent</code> function, and Just In Time compiled version</h2>

<h3>Description</h3>

<p>Faster function for determining the cells of the 4, 8 or bishop
neighbours of the <code>cells</code>. This is a hybrid function that uses
matrix for small numbers of loci (&lt;1e4) and data.table for larger numbers of loci
</p>


<h3>Usage</h3>

<pre><code class="language-R">adj(
  x = NULL,
  cells,
  directions = 8,
  sort = FALSE,
  pairs = TRUE,
  include = FALSE,
  target = NULL,
  numCol = NULL,
  numCell = NULL,
  match.adjacent = FALSE,
  cutoff.for.data.table = 2000,
  torus = FALSE,
  id = NULL,
  numNeighs = NULL,
  returnDT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>SpatRaster</code> object for which adjacency will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cells</code></td>
<td>
<p>vector of cell numbers for which adjacent cells should be found.
Cell numbers start with 1 in the upper-left corner and increase
from left to right and from top to bottom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directions</code></td>
<td>
<p>the number of directions in which cells should be connected:
4 (rook's case), 8 (queen's case), or <code>"bishop"</code> to connect
cells with one-cell diagonal moves.
Or a neighbourhood matrix (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>logical. Whether the outputs should be sorted or not, using cell ids
of the <code>from</code> cells (and <code>to</code> cells, if <code>match.adjacent</code>
is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairs</code></td>
<td>
<p>logical. If <code>TRUE</code>, a matrix of pairs of adjacent cells is returned.
If <code>FALSE</code>, a vector of cells adjacent to cells is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>
<p>logical. Should the focal cells be included in the result?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>a vector of cells that can be spread to. This is the inverse of a mask.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numCol</code></td>
<td>
<p>numeric indicating number of columns in the raster.
Using this with <code>numCell</code> is a bit faster execution time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numCell</code></td>
<td>
<p>numeric indicating number of cells in the raster.
Using this with <code>numCol</code> is a bit faster execution time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.adjacent</code></td>
<td>
<p>logical. Should the returned object be the same as
<code>raster::adjacent</code>.
Default <code>FALSE</code>, which is faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff.for.data.table</code></td>
<td>
<p>numeric. If the number of cells is above this value,
the function uses data.table which is faster with
large numbers of cells. Default is 5000, which appears
to be the turning point where data.table becomes faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>torus</code></td>
<td>
<p>Logical. Should the spread event wrap around to the other side of the raster?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>numeric If not <code>NULL</code> (default), then function will return <code>"id"</code> column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNeighs</code></td>
<td>
<p>A numeric scalar, indicating how many neighbours to return. Must be
less than or equal to <code>directions</code>; which neighbours are random
with equal probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDT</code></td>
<td>
<p>A logical. If TRUE, then the function will return the result
as a <code>data.table</code>, if the internals used <code>data.table</code>,
i.e., if number of cells is greater than <code>cutoff.for.data.table</code>.
User should be warned that this will therefore cause the output
format to change depending <code>cutoff.for.data.table</code>.
This will be faster for situations where <code>cutoff.for.data.table = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Between 4x (large number loci) to 200x (small number loci) speed gains over
<code>adjacent</code> in raster package. There is some extra speed gain if
<code>NumCol</code> and <code>NumCells</code> are passed rather than a raster.
Efficiency gains come from:
</p>

<ol>
<li>
<p> use <code>data.table</code> internally
</p>

<ul>
<li>
<p> no need to remove NAs because wrapped or outside points are
just removed directly with data.table
</p>
</li>
<li>
<p> use data.table to sort and fast select (though not fastest possible)
</p>
</li>
</ul>
</li>
<li>
<p> don't make intermediate objects; just put calculation into return statement
</p>
</li>
</ol>
<p>The steps used in the algorithm are:
</p>

<ol>
<li>
<p> Calculate indices of neighbouring cells
</p>
</li>
<li>
<p> Remove "to" cells that are
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠&lt; 1⁠</code> or <code style="white-space: pre;">⁠&gt; numCells⁠</code> (i.e., they are above or below raster), using a single modulo
calculation
</p>
</li>
<li>
<p> where the modulo of "to" cells is equal to 1 if "from" cells are 0 (wrapped right
to left)
</p>
</li>
<li>
<p> or where the modulo of the "to" cells is equal to 0 if "from" cells are 1 (wrapped
left to right)
</p>
</li>
</ul>
</li>
</ol>
<h3>Value</h3>

<p>Either a matrix (if more than 1 column, i.e., <code>pairs = TRUE</code>,
and/or <code>id</code> is provided), a vector (if only one column), or a <code>data.table</code>
(if <code>cutoff.for.data.table</code> is less than <code>length(cells)</code> <em>and</em>
<code>returnDT</code> is <code>TRUE</code>.
To get a consistent output, say a matrix, it would be wise to test the output
for its class.
The variable output is done to minimize coercion to maintain speed.
The columns will be one or more of <code>id</code>, <code>from</code>, <code>to</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code>terra::adjacent()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

a &lt;- rast(ext(0, 1000, 0, 1000), res = 1)
sam &lt;- sample(1:ncell(a), 1e4)
numCol &lt;- ncol(a)
numCell &lt;- ncell(a)
adj.new &lt;- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8)
adj.new &lt;- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8,
               include = TRUE)

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>


</div>