<div class="container">

<table style="width: 100%;"><tr>
<td>Hierarchies2ModelMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model matrix representing crossed hierarchies</h2>

<h3>Description</h3>

<p>Make a model matrix, x, that corresponds to data and represents all hierarchies crossed.
This means that aggregates corresponding to numerical variables can be computed as
<code>t(x) %*% y</code>, where  <code>y</code> is a matrix with one column for each numerical variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Hierarchies2ModelMatrix(
  data,
  hierarchies,
  inputInOutput = TRUE,
  crossTable = FALSE,
  total = "Total",
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  unionComplement = FALSE,
  reOrder = TRUE,
  select = NULL,
  removeEmpty = FALSE,
  selectionByMultiplicationLimit = 10^7,
  makeColnames = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.
Also see note.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>See <code>AutoHierarchies</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code>HierarchyFix</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reOrder</code></td>
<td>
<p>When TRUE (default) output codes are ordered in a way similar to a usual model matrix ordering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>Data frame specifying variable combinations for output
or a named list specifying code selections for each variable (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeEmpty</code></td>
<td>
<p>When TRUE and when <code>select</code> is not a data frame, empty columns (only zeros) are not included in output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>select</code> and when the number of elements in the model matrix exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>makeColnames</code></td>
<td>
<p>Colnames included when TRUE (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra unused parameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function makes use of <code>AutoHierarchies</code>
and <code>HierarchyCompute</code>  via  <code>HierarchyComputeDummy</code>.
Since the dummy matrix is transposed in comparison to <code>HierarchyCompute</code>, the parameter <code>rowSelect</code> is renamed to <code>select</code>
and  <code>makeRownames</code> is renamed to <code>makeColnames</code>.
</p>
<p>The select parameter as a list can be partially specified in the sense that not all hierarchy names have to be included.
The parameter <code>inputInOutput</code> will only apply to hierarchies that are not in the <code>select</code> list (see note).
</p>


<h3>Value</h3>

<p>A sparse model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Note</h3>

<p>The <code>select</code> as a list is run via a special coding of the <code>inputInOutput</code> parameter.
This parameter is converted into a list (<code>as.list</code>) and <code>select</code> elements are inserted into this list.
This is also an additional option for users of the function.
</p>


<h3>Author(s)</h3>

<p>Ã˜yvind Langsrud
</p>


<h3>See Also</h3>

<p><code>ModelMatrix</code>, <code>HierarchiesAndFormula2ModelMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create some input
z &lt;- SSBtoolsData("sprt_emp_withEU")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]


# First example has list output
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE, 
                        crossTable = TRUE)


m1 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE)
m2 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList))
m3 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = ""),
                              inputInOutput = FALSE)
m4 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = "allYears"), 
                              inputInOutput = c(FALSE, FALSE, TRUE))

# Illustrate the effect of unionComplement, geoHier2 as in the examples of HierarchyCompute
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  SSBtoolsData("sprt_emp_geoHier")[, -4])
m5 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE)  # Spain is counted twice
m6 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE, unionComplement = TRUE)


# Compute aggregates
ths_per &lt;- as.matrix(z[, "ths_per", drop = FALSE])  # matrix with the values to be aggregated
t(m1) %*% ths_per  # crossprod(m1, ths_per) is equivalent and faster
t(m2) %*% ths_per
t(m3) %*% ths_per
t(m4) %*% ths_per
t(m5) %*% ths_per
t(m6) %*% ths_per


# Example using the select parameter as a data frame
select &lt;- data.frame(age = c("Y15-64", "Y15-29", "Y30-64"), geo = c("EU", "nonEU", "Spain"))
m2a &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), select = select)

# Same result by slower alternative
m2B &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), crossTable = TRUE)
m2b &lt;- m2B$modelMatrix[, Match(select, m2B$crossTable), drop = FALSE]
t(m2b) %*% ths_per

# Examples using the select parameter as a list
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       inputInOutput = FALSE, 
       select = list(geo = c("nonEU", "Portugal")))
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       select = list(geo = c("nonEU", "Portugal"), age = c("Y15-64", "Y15-29")))

</code></pre>


</div>