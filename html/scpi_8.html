<div class="container">

<table style="width: 100%;"><tr>
<td>scdata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data Preparation for <code>scest</code> or <code>scpi</code> for Point Estimation and Inference Procedures Using Synthetic Control Methods.</h2>

<h3>Description</h3>

<p>The command prepares the data to be used by <code>scest</code> or <code>scpi</code> to implement estimation and
inference procedures for Synthetic Control (SC) methods.
It allows the user to specify the outcome variable, the features of the treated unit to be
matched, and covariate-adjustment feature by feature. The names of the output matrices
follow the terminology proposed in <a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, Feng, and Titiunik (2021)</a>.
</p>
<p>Companion <a href="https://www.stata.com/">Stata</a> and <a href="https://www.python.org/">Python</a> packages are described in
<a href="https://arxiv.org/abs/2202.05984">Cattaneo, Feng, Palomba, and Titiunik (2022)</a>.
</p>
<p>Companion commands are: scdataMulti for data preparation in the multiple treated units case with staggered adoption,
scest for point estimation, scpi for inference procedures, scplot and scplotMulti for plots in
the single and multiple treated unit(s) cases, respectively.
</p>
<p>Related Stata, R, and Python packages useful for inference in SC designs are described in the following website:
</p>
<p><a href="https://nppackages.github.io/scpi/"> https://nppackages.github.io/scpi/</a>
</p>
<p>For an introduction to synthetic control methods, see <a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie (2021)</a> and references therein.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scdata(
  df,
  id.var,
  time.var,
  outcome.var,
  period.pre,
  period.post,
  unit.tr,
  unit.co,
  features = NULL,
  cov.adj = NULL,
  cointegrated.data = FALSE,
  anticipation = 0,
  constant = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>a dataframe object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.var</code></td>
<td>
<p>a character or numeric scalar with the name of the variable containing units' IDs. The ID variable can be numeric or character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.var</code></td>
<td>
<p>a character with the name of the time variable. The time variable has to be numeric, integer, or Date. In
case <code>time.var</code> is Date it should be the output of <code>as.Date()</code> function. An integer or
numeric time variable is suggested when working with yearly data, whereas for all other formats a Date type
time variable is preferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome.var</code></td>
<td>
<p>a character with the name of the outcome variable. The outcome variable has to be numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period.pre</code></td>
<td>
<p>a numeric vector that identifies the pre-treatment period in time.var.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period.post</code></td>
<td>
<p>a numeric vector that identifies the post-treatment period in time.var.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.tr</code></td>
<td>
<p>a character or numeric scalar that identifies the treated unit in <code>id.var</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.co</code></td>
<td>
<p>a character or numeric vector that identifies the donor pool in <code>id.var</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>features</code></td>
<td>
<p>a character vector containing the name of the feature variables used for estimation.
If this option is not specified the default is <code>features = outcome.var</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.adj</code></td>
<td>
<p>a list specifying the names of the covariates to be used for adjustment for each feature. If <code>outcome.var</code> is
not in the variables specified in <code>features</code>, we force <code>cov.adj&lt;-NULL</code>. See the <strong>Details</strong> section for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cointegrated.data</code></td>
<td>
<p>a logical that indicates if there is a belief that the data is cointegrated or not.
The default value is <code>FALSE</code>.  See the <strong>Details</strong> section for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anticipation</code></td>
<td>
<p>a scalar that indicates the number of periods of potential anticipation effects. Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>a logical which controls the inclusion of a constant term across features. The default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> prints additional information in the console.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p><code>cov.adj</code> can be used in two ways. First, if only one feature is specified through the option <code>features</code>,
<code>cov.adj</code> has to be a list with one (even unnamed) element (eg. <code>cov.adj = list(c("constant","trend"))</code>).
Alternatively, if multiple features are specified, then the user has two possibilities:
</p>

<ul>
<li>
<p>provide a list with one element, then the same covariates are used for
adjustment for each feature. For example, if there are two features specified and the user inputs
<code>cov.adj = list(c("constant","trend"))</code>, then a constant term and a linear trend are for adjustment for both features.
</p>
</li>
<li>
<p>provide a list with as many elements as the number of features specified, then
feature-specific covariate adjustment is implemented. For example,
<code>cov.adj = list('f1' = c("constant","trend"), 'f2' = c("trend"))</code>. In this case the name of each element
of the list should be one (and only one) of the features specified. Note that if two (or more) features are
specified and covariates adjustment has to be specified just for one of them, the user must still provide a list
of the same length of the number of features, e.g., <code>cov.adj = list('f1' = c("constant","trend"), 'f2' = NULL</code>.
</p>
</li>
</ul>
<p>This option allows the user to include feature-specific constant terms
or time trends by simply including "constant" or "trend" in the corresponding
element of the list.
</p>
<p>When <code>outcome.var</code> is not included in <code>features</code>, we automatically set <code class="reqn">\mathcal{R}=\emptyset</code>, that is
we do not perform covariate adjustment. This is because, in this setting it is natural to create the out-of-sample
prediction matrix <code class="reqn">\mathbf{P}</code> using the post-treatment outcomes of the donor units only.

</p>
</li>
<li>
<p><code>cointegrated.data</code> allows the user to model the belief that <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> form a
cointegrated system. In practice, this implies that when dealing with the pseudo-true
residuals <code class="reqn">\mathbf{u}</code>, the first-difference of <code class="reqn">\mathbf{B}</code> are used rather than the levels.
</p>
</li>
</ul>
<h3>Value</h3>

<p>The command returns an object of class 'scdata' containing the following
</p>
<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix containing pre-treatment features of the treated unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a matrix containing pre-treatment features of the control units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>a matrix containing covariates for adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>a matrix whose rows are the vectors used to predict the out-of-sample series for the synthetic unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.pre</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the treated unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.post</code></td>
<td>
<p>a matrix containing the post-treatment outcome of the treated unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.donors</code></td>
<td>
<p>a matrix containing the pre-treatment outcome of the control units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specs</code></td>
<td>
<p>a list containing some specifics of the data:
</p>

<ul>
<li>
<p><code>J</code>, the number of control units
</p>
</li>
<li>
<p><code>K</code>, a numeric vector with the number of covariates used for adjustment for each feature
</p>
</li>
<li>
<p><code>KM</code>, the total number of covariates used for adjustment
</p>
</li>
<li>
<p><code>M</code>, number of features
</p>
</li>
<li>
<p><code>period.pre</code>, a numeric vector with the pre-treatment period
</p>
</li>
<li>
<p><code>period.post</code>, a numeric vector with the post-treatment period
</p>
</li>
<li>
<p><code>T0.features</code>, a numeric vector with the number of periods used in estimation for each feature
</p>
</li>
<li>
<p><code>T1.outcome</code>, the number of post-treatment periods
</p>
</li>
<li>
<p><code>outcome.var</code>, a character with the name of the outcome variable
</p>
</li>
<li>
<p><code>features</code>, a character vector with the name of the features
</p>
</li>
<li>
<p><code>constant</code>, for internal use only
</p>
</li>
<li>
<p><code>out.in.features</code>, for internal use only
</p>
</li>
<li>
<p><code>effect</code>, for internal use only
</p>
</li>
<li>
<p><code>sparse.matrices</code>, for internal use only
</p>
</li>
<li>
<p><code>treated.units</code>, list containing the IDs of all treated units</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matias Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Yingjie Feng, Tsinghua University. <a href="mailto:fengyj@sem.tsinghua.edu.cn">fengyj@sem.tsinghua.edu.cn</a>.
</p>
<p>Filippo Palomba, Princeton University (maintainer). <a href="mailto:fpalomba@princeton.edu">fpalomba@princeton.edu</a>.
</p>
<p>Rocio Titiunik, Princeton University. <a href="mailto:titiunik@princeton.edu">titiunik@princeton.edu</a>.
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://www.aeaweb.org/articles?id=10.1257/jel.20191450">Abadie, A. (2021)</a>.
Using synthetic controls: Feasibility, data requirements, and methodological aspects.
<em>Journal of Economic Literature</em>, 59(2), 391-425.
</p>
</li>
<li>
<p><a href="https://nppackages.github.io/references/Cattaneo-Feng-Titiunik_2021_JASA.pdf">Cattaneo, M. D., Feng, Y., and Titiunik, R.
(2021)</a>. Prediction intervals for synthetic control methods. <em>Journal of the American Statistical Association</em>, 116(536), 1865-1880.
</p>
</li>
<li>
<p><a href="https://arxiv.org/abs/2202.05984">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
scpi: Uncertainty Quantification for Synthetic Control Methods, <em>arXiv</em>:2202.05984.
</p>
</li>
<li>
<p><a href="https://arxiv.org/abs/2210.05026">Cattaneo, M. D., Feng, Y., Palomba F., and Titiunik, R. (2022).</a>
Uncertainty Quantification in Synthetic Controls with Staggered Treatment Adoption, <em>arXiv</em>:2210.05026.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>scdataMulti</code>, <code>scest</code>, <code>scpi</code>, <code>scplot</code>, <code>scplotMulti</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data &lt;- scpi_germany

df &lt;- scdata(df = data, id.var = "country", time.var = "year",
             outcome.var = "gdp", period.pre = (1960:1990),
             period.post = (1991:2003), unit.tr = "West Germany",
             unit.co = setdiff(unique(data$country), "West Germany"),
             constant = TRUE, cointegrated.data = TRUE)

</code></pre>


</div>