<div class="container">

<table style="width: 100%;"><tr>
<td>phi_optimize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>function to optimize the phi_p value of an array by level permutation</h2>

<h3>Description</h3>

<p>takes an n x m array and returns an n x m array with improved phi_p value (if possible)
</p>


<h3>Usage</h3>

<pre><code class="language-R">phi_optimize(
  D,
  noptim.rounds = 1,
  noptim.repeats = 1,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>numeric matrix or data.frame with numeric columns, n x m. A symmetric array (e.g. an OA) with <code>nl</code> levels for each columns. Levels must be coded as 0 to <code>nl - 1</code> or as 1 to <code>nl</code>. levels from</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.rounds</code></td>
<td>
<p>number of rounds in the Weng algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.repeats</code></td>
<td>
<p>number of independent repeats of the Weng algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmethod</code></td>
<td>
<p>distance method for <code>phi_p</code>, "manhattan" (default) or "euclidean"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>p for <code>phi_p</code> (the larger, the closer to maximin distance)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses the algorithm proposed by Weng (2014) for SOA optimization:
</p>
<p>It starts with a random permutation of column levels.
</p>
<p>Initially, individual columns are randomly permuted (m permuted matrices, called one-neighbours), and the best permutation w.r.t. the <code>phi_p</code> value (manhattan distance) is
is made the current optimum. This continues, until the current optimum is not improved by a set of randomly drawn one-neighbours.<br>
Subsequently, pairs of columns are randomly permuted (<code>choose(m,2)</code> permuted matrices, called two-neighbours). If the current optimum can be improved or the number of optimization rounds has not yet been exhausted,
a new round with one-neighbours is started with the current optimum. Otherwise, the current optimum is returned, or an independent repeat is initiated (if requested).
</p>
<p>Limited experience suggests that an increase of <code>noptim.rounds</code> from the default 1 is often helpful, whereas an increase of <code>noptim.repeats</code> did not yield as much improvement.
</p>


<h3>Value</h3>

<p>an n x m matrix
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code>SOAs-package</code>.
</p>
<p>Weng (2014)
</p>


<h3>Examples</h3>

<pre><code class="language-R">oa &lt;- lhs::createBoseBush(8,16)
print(phi_p(oa, dmethod="manhattan"))
oa_optimized &lt;- phi_optimize(oa)
print(phi_p(oa_optimized, dmethod="manhattan"))
</code></pre>


</div>