<div class="container">

<table style="width: 100%;"><tr>
<td>u.log</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Anti)Symmetric Log High-Transform</h2>

<h3>Description</h3>

<p>Compute <code class="reqn">log()</code> only for high values and keep low ones –
antisymmetrically such that <code>u.log(x)</code> is (once) continuously
differentiable, it computes




<code class="reqn">f(x) = x</code> for <code class="reqn">|x| \le c</code>  and
<code class="reqn">sign(x)  c\cdot(1 + log(|x|/c))</code>
for <code class="reqn">|x| \ge c</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">u.log(x, c = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector to be transformed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>scalar, &gt; 0</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Alternatively, the ‘IHS’ (inverse hyperbolic sine)
transform has been proposed, first in more generality as <code class="reqn">S_U()</code>
curves by Johnson(1949); in its simplest form,
<code class="reqn">f(x) = arsinh(x) = \log(x + \sqrt{x^2 + 1})</code>,
which is also antisymmetric, continous and once differentiable as our <code>u.log(.)</code>.
</p>


<h3>Value</h3>

<p>numeric vector of same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, 24 Jan 1995</p>


<h3>References</h3>

<p>N. L. Johnson (1949).
Systems of Frequency Curves Generated by Methods of Translation,
<em>Biometrika</em> <b>36</b>, pp 149–176.
<a href="https://doi.org/10.2307/2332539">doi:10.2307/2332539</a>
</p>


<h3>See Also</h3>

<p>Werner Stahel's sophisticated version of John Tukey's “started log” (which was <code class="reqn">\log(x
    + c)</code>), with concave extension to negative values and adaptive default choice of <code class="reqn">c</code>;
<code>logst</code> in his CRAN package <a href="https://CRAN.R-project.org/package=relevance"><span class="pkg">relevance</span></a>, or
<code>LogSt</code> in package <a href="https://CRAN.R-project.org/package=DescTools"><span class="pkg">DescTools</span></a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">curve(u.log, -3, 10); abline(h=0, v=0, col = "gray20", lty = 3)
curve(1 + log(x), .01,  add = TRUE, col= "brown") # simple log
curve(u.log(x,    2),   add = TRUE, col=2)
curve(u.log(x, c= 0.4), add = TRUE, col=4)

## Compare with  IHS = inverse hyperbolic sine == asinh 
ihs &lt;- function(x) log(x+sqrt(x^2+1)) # == asinh(x) {aka "arsinh(x)" or "sinh^{-1} (x)"}
xI &lt;- c(-Inf, Inf, NA, NaN)
stopifnot(all.equal(xI, asinh(xI))) # but not for ihs():
cbind(xI, asinh=asinh(xI), ihs=ihs(xI)) # differs for -Inf
x &lt;- runif(500, 0, 4); x[100+0:3] &lt;- xI
all.equal(ihs(x), asinh(x)) #==&gt;  is.NA value mismatch:  asinh() is correct {i.e. better!}

curve(u.log, -2, 20, n=1000); abline(h=0, v=0, col = "gray20", lty = 3)
curve(ihs(x)+1-log(2), add=TRUE, col=adjustcolor(2, 1/2), lwd=2)
curve(ihs(x),          add=TRUE, col=adjustcolor(4, 1/2), lwd=2)
## for x &gt;= 0, u.log(x) is nicely between IHS(x) and shifted IHS

## a  log10-scale version of asinh()  {aka "IHS" }: ihs10(x) :=  asinh(x/2) / ln(10)
ihs10 &lt;- function(x) asinh(x/2)/log(10)
xyaxis &lt;- function() abline(h=0, v=0, col = "gray20", lty = 3)
leg3 &lt;- function(x = "right")
    legend(x, legend = c(quote(ihs10(x) == asinh(x/2)/log(10)),
                         quote(log[10](1+x)), quote(log[10](x))),
           col=c(1,2,5), bty="n", lwd=2)
curve(asinh(x/2)/log(10), -5, 20, n=1000, lwd=2); xyaxis()
curve(log10(1+x), col=2, lwd=2, add=TRUE)
curve(log10( x ), col=5, lwd=2, add=TRUE); leg3()

## zoom out  and  x-log-scale
curve(asinh(x/2)/log(10), .1, 100, log="x", n=1000); xyaxis()
curve(log10(1+x), col=2, add=TRUE)
curve(log10( x ), col=5, add=TRUE) ; leg3("center")

curve(log10(1+x) - ihs10(x), .1, 1000, col=2, n=1000, log="x", ylim = c(-1,1)*0.10,
      main = "absolute difference", xaxt="n"); xyaxis(); eaxis(1, sub10=1)
curve(log10( x ) - ihs10(x), col=4, n=1000, add = TRUE)

curve(abs(1 - ihs10(x) / log10(1+x)), .1, 5000, col=2, log = "xy", ylim = c(6e-9, 2),
      main="|relative error| of approx. ihs10(x) :=  asinh(x/2)/log(10)", n=1000, axes=FALSE)
eaxis(1, sub10=1); eaxis(2, sub10=TRUE)
curve(abs(1 - ihs10(x) / log10(x)), col=4, n=1000, add = TRUE)
legend("left", legend = c(quote(log[10](1+x)), quote(log[10](x))),
       col=c(2,4), bty="n", lwd=1)

## Compare with Stahel's version of "started log"
## (here, for *vectors* only, and 'base', as Desctools::LogSt();

## by MM: "modularized" by providing a threshold-computer function separately:
logst_thrWS &lt;- function(x, mult = 1) {
    lq &lt;- quantile(x[x &gt; 0], probs = c(0.25, 0.75), na.rm = TRUE, names = FALSE)
    if (lq[1] == lq[2])
        lq[1] &lt;- lq[2]/2
    lq[1]^(1 + mult)/lq[2]^mult
}
logst0L &lt;- function(x, calib = x, threshold = thrFUN(calib, mult=mult),
                   thrFUN = logst_thrWS, mult = 1, base = 10)
{
    ## logical index sub-assignment instead of ifelse(): { already in DescTools::LogSt }
    res &lt;- x # incl NA's
    notNA &lt;- !is.na(sml &lt;- (x &lt; (th &lt;- threshold)))
    i1 &lt;-  sml &amp; notNA; res[i1] &lt;- log(th, base) + ((x[i1] - th)/(th * log(base)))
    i2 &lt;- !sml &amp; notNA; res[i2] &lt;- log(x[i2], base)
    attr(res, "threshold") &lt;- th
    attr(res, "base") &lt;- base
    res
}
logst0 &lt;- function(x, calib = x, threshold = thrFUN(calib, mult=mult),
                   thrFUN = logst_thrWS, mult = 1, base = 10)
{
    ## Using pmax.int() instead of logical indexing -- NA's work automatically - even faster
    xm &lt;- pmax.int(threshold, x)
    res &lt;- log(xm, base) + (x - xm)/(threshold * log(base))
    attr(res, "threshold") &lt;- threshold
    attr(res, "base") &lt;- base
    res
}

## u.log() is really using natural log() -- whereas logst() defaults to base=10

curve(u.log, -4, 10, n=1000); abline(h=0, v=0, col = "gray20", lty = 3); points(-1:1, -1:1, pch=3)
curve(log10(x) + 1,  add=TRUE, col=adjustcolor("midnightblue", 1/2), lwd=4, lty=6)
curve(log10(x),      add=TRUE, col=adjustcolor("skyblue3",     1/2), lwd=4, lty=7)
curve(logst0(x, threshold= 2  ), add=TRUE, col=adjustcolor("orange",1/2), lwd=2)
curve(logst0(x, threshold= 1  ), add=TRUE, col=adjustcolor(2, 1/2), lwd=2)
curve(logst0(x, threshold= 1/4), add=TRUE, col=adjustcolor(3, 1/2), lwd=2, lty=2)
curve(logst0(x, threshold= 1/8), add=TRUE, col=adjustcolor(4, 1/2), lwd=2, lty=2)
</code></pre>


</div>