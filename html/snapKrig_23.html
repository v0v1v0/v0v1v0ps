<div class="container">

<table style="width: 100%;"><tr>
<td>sk_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a covariance model to an sk grid by maximum likelihood</h2>

<h3>Description</h3>

<p>This uses <code>stats::optim</code> to minimize the log-likelihood function for a grid dataset
<code>g</code> over the space of unknown parameters for the covariance function specified in <code>pars</code>.
If only one parameter is unknown, the function instead uses <code>stats::optimize</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_fit(
  g,
  pars = NULL,
  X = NA,
  iso = TRUE,
  n_max = 1000,
  quiet = FALSE,
  lower = NULL,
  initial = NULL,
  upper = NULL,
  log_scale = TRUE,
  method = "L-BFGS-B",
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>an sk grid (or list with entries 'gdim', 'gres', 'gval')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>covariance parameter list, with <code>NA</code>s indicating parameters to fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>numeric (or NA), matrix, or sk grid of linear predictors, passed to <code>sk_LL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iso</code></td>
<td>
<p>logical, indicating to constrain the y and x kernel parameters to be the same</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_max</code></td>
<td>
<p>integer, the maximum number of observations allowed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical, indicating to suppress console output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>numeric vector, lower bounds for parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>numeric vector, initial values for parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>numeric vector, upper bounds for parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_scale</code></td>
<td>
<p>logical, indicating to log-transform parameters for optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character, passed to <code>stats::optim</code> (default is 'L-BFGS-B')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list, passed to <code>stats::optim</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>NA</code> entries in <code>pars</code> are treated as unknown parameters and fitted by the
function, whereas non-<code>NA</code> entries are treated as fixed parameters (and not fitted).
If none of the parameters in <code>pars</code> are <code>NA</code>, the function copies everything as initial
values, then treats all parameters as unknown. <code>pars</code> can also be a character vector
defining a pair of correlograms (see <code>?sk_pars</code>) in which case all covariance parameters
are treated as unknown.
</p>
<p>Bounds and initial values are set automatically using <code>sk_bds</code>, unless they are otherwise
specified in arguments <code>lower</code>, <code>initial</code>, <code>upper</code>. These should be vectors containing only
the unknown parameters, <em>ie.</em> they must exclude fixed parameters. Call
<code>sk_update_pars(pars, iso=iso)</code> to get a template with the expected names and order.
</p>
<p>All parameters in the covariance models supported by <code>snapKrig</code> are strictly positive.
Optimization is (by default) done on the parameter log-scale, and users can select a
non-constrained <code>method</code> if they wish (<code>?stats::optim</code>). As the default method 'L-BFGS-B'
is the only one that accepts bounds (<code>lower</code>, <code>initial</code>, <code>upper</code> are otherwise ignored)
<code>method</code> is ignored when <code>log_scale=FALSE</code>.
</p>
<p>Note that the 'gxp' and 'mat' correlograms behave strangely with very small or very large
shape parameters, so for them we recommended 'L-BFGS-B' only.
</p>
<p>When there is only one unknown parameter, the function uses <code>stats::optimize</code> instead of
<code>stats::optim</code>. In this case all entries of <code>control</code> with the exception of 'tol' are
ignored, as are bounds and initial values, and arguments to <code>method</code>.
</p>
<p>As a sanity check <code>n_max</code> sets a maximum for the number of observed grid points. This
is to avoid accidental calls with very large datasets that would cause R to hang or crash.
Set <code>n_max=Inf</code> (with caution) to bypass this check. Similarly the maximum number of
iterations is set to <code>1e3</code> but this can be changed by manually setting 'maxit' in
<code>control</code>.
</p>


<h3>Value</h3>

<p>A parameter list in the form returned by <code>sk_pars</code> containing both fixed and
fitted parameters. The data-frame of bounds and initial values is also included in the
attribute 'bds'
</p>


<h3>See Also</h3>

<p>sk sk_LL sk_nLL stats::optim stats::optimize
</p>
<p>Other parameter managers: 
<code>sk_bds()</code>,
<code>sk_kp()</code>,
<code>sk_pars_make()</code>,
<code>sk_pars_update()</code>,
<code>sk_pars()</code>,
<code>sk_to_string()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# define a grid
gdim = c(50, 51)
g_empty = sk(gdim)
pars_src = sk_pars(g_empty)
pars_src = utils::modifyList(pars_src, list(eps=runif(1, 0, 1e1), psill=runif(1, 0, 1e2)))
pars_src[['y']][['kp']] = pars_src[['x']][['kp']] = runif(1, 1, 50)

# generate example data
g_obs = sk_sim(g_empty, pars_src)
sk_plot(g_obs)

# fit (set maxit low to keep check time short)
fit_result = sk_fit(g_obs, pars='gau', control=list(maxit=25), quiet=TRUE)

# compare estimates with true values
rbind(true=sk_pars_update(pars_src), fitted=sk_pars_update(fit_result))

# extract bounds data frame
attr(fit_result, 'bds')

# non-essential examples skipped to stay below 5s exec time on slower machines

# check a sequence of other psill values
pars_out = fit_result
psill_test = ( 2^(seq(5) - 3) ) * pars_out[['psill']]
LL_test = sapply(psill_test, function(s) sk_LL(utils::modifyList(pars_out, list(psill=s)), g_obs) )
plot(psill_test, LL_test)
lines(psill_test, LL_test)
print(data.frame(psill=psill_test, likelihood=LL_test))

# repeat with most data missing
n = prod(gdim)
n_obs = 25
g_obs = sk_sim(g_empty, pars_src)
idx_miss = sample.int(length(g_empty), length(g_empty) - n_obs)
g_miss = g_obs
g_miss[idx_miss] = NA
sk_plot(g_miss)

# fit (set maxit low to keep check time short) and compare
fit_result = sk_fit(g_miss, pars='gau', control=list(maxit=25), quiet=TRUE)
rbind(true=sk_pars_update(pars_src), fitted=sk_pars_update(fit_result))


</code></pre>


</div>