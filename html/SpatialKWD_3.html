<div class="container">

<table style="width: 100%;"><tr>
<td>CompareOneToMany-function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compare a reference spatial histogram to other histograms
</h2>

<h3>Description</h3>

<p>This function computes the Kantorovich-Wasserstein among a single reference histogram and a given list of other spatial histograms. All the histograms are defined over the same grid map.
</p>
<p>The grid map is described by the two lists of <code>N</code> coordinates <code>Xs</code> and <code>Ys</code>, which specify the coordinates of the centroid of each tile of the map.
For each tile <code>i</code> with coordinates <code>Xs[i], Ys[i]</code>, we have a positive weight for each histogram.
</p>
<p>The two lists of coordinates are passed to <code>compareOneToMany</code> as a matrix with <code>N</code> rows and two columns.
The weights of the histograms are passed as a single matrix with <code>N</code> rows and <code>M</code> columns, where the first column is the reference histogram.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compareOneToMany(Coordinates, Weights, L = 3, recode = TRUE,
           method = "approx",    algorithm = "colgen",
           model="mincostflow",  verbosity = "silent",
           timelimit = 14400,    opt_tolerance = 1e-06,
           unbalanced = FALSE, unbal_cost = 1e+09, convex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Coordinates</code></td>
<td>
<p>A <code>Matrix</code> with <code>N</code> rows and two columns:
</p>

<ul>
<li>
<p><code>Coordinates[,1]</code>: <em>(First Column)</em> Vector of horizontal coordinates of the centroids of each tile of the map (<code>Xs</code>). Data type: vector of positive integers.
</p>
</li>
<li>
<p><code>Coordinates[,2]</code>: <em>(Second Column)</em> Vector of vertical coordinates of the centroids of each tile of the map (<code>Ys</code>). Data type: vector of positive integers.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Weights</code></td>
<td>
<p>A <code>Matrix</code> of positive weights of the tiles specified by <code>Coordinates</code>.
</p>

<ul>
<li>
<p><code>Weights[,1]</code>: <em>(First Column)</em> Weights of the reference spatial histogram, a weight for each tile located at position <code>Xs[i], Ys[i]</code> for <code>i=1,...N</code>. Data type: vector of positive doubles.
</p>
</li>
<li>
<p><code>Weights[,2:M]</code>: <em>(Remaining Columns)</em> Weights of the spatial histograms to be compared with the reference histogram. Data type: vector of positive doubles.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Approximation parameter.
Higher values of <em>L</em> give a more accurate solution, but they require a longer running time. Data type: positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recode</code></td>
<td>
<p>If equal to <code>True</code>, recode the input coordinates as consecutive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for computing the KW distances: <code>exact</code> or <code>approx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Algorithm for computing the KW distances: <code>fullmodel</code> or <code>colgen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model for building the underlying network: <code>bipartite</code> or <code>mincostflow</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>Level of verbosity of the log: <code>silent</code>, <code>info</code>, or <code>debug</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timelimit</code></td>
<td>
<p>Time limit in second for running the solver.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_tolerance</code></td>
<td>
<p>Numerical tolerance on the negative reduced cost for the optimal solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unbalanced</code></td>
<td>
<p>If equal to <code>True</code>, solve the problem with unbalanced masses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unbal_cost</code></td>
<td>
<p>Cost for the arcs going from each point to the extra artificial bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>If equal to <code>True</code>, compute the convex hull of the input points.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>compareOneToMany(Coordinates, Weights, ...)</code> computes the distances among a reference spatial histogram and a given set of other histograms.
All the histograms are specified by the <code>M</code> columns of matrix <code>Weights</code>, and where the support points (i.e., centroids of each tile of the map)
are defined by the coordinates given in <code>Xs</code> and <code>Ys</code> in the two columns of matrix <code>Coordinates</code>.
The algorithm used to compute such distance depends on the parameters specified as optional arguments of the function.
</p>
<p>The most important is the parameter <code>L</code>, which by default is equal to 3 (see <code>compareOneToOne</code>).
</p>


<h3>Value</h3>

<p>Return an R List with the following named attributes:
</p>

<ul>
<li>
<p><code>distances</code>: An array of <code>M-1</code> KW-distances among the input histograms.
</p>
</li>
<li>
<p><code>status</code>: Status of the solver used to compute the distances.
</p>
</li>
<li>
<p><code>runtime</code>: Overall runtime in seconds to compute all the distances.
</p>
</li>
<li>
<p><code>iterations</code>: Overall number of iterations of the Network Simplex algorithm.
</p>
</li>
<li>
<p><code>nodes</code>: Number of nodes in the network model used to compute the distances.
</p>
</li>
<li>
<p><code>arcs</code>: Number of arcs in the network model used to compute the distances.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>See also <code>compareOneToOne</code>, <code>compareAll</code>, <code>focusArea</code>, <code>Histogram2D</code>, and <code>Solver</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a simple example
library(SpatialKWD)

# Random coordinates
N = 90
Xs &lt;- as.integer(runif(N, 0, 31))
Ys &lt;- as.integer(runif(N, 0, 31))
coordinates &lt;- matrix(c(Xs, Ys), ncol=2, nrow=N)

# Random weights
m &lt;- 3
test2 &lt;- matrix(runif((m+1)*N, 0, 1), ncol=(m+1))

# Compute distance
print("Compare one-to-many with approximate algorithm:")
d &lt;- compareOneToMany(coordinates, Weights=test2, L=3, method="approx")
cat("L: 3, runtime:", d$runtime, " distances:", d$distance, "\n")
</code></pre>


</div>