<div class="container">

<table style="width: 100%;"><tr>
<td>areal_spatial_bisquare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Areal Spatial Bisquare Basis</h2>

<h3>Description</h3>

<p>Spatial bisquare basis on areal data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">areal_spatial_bisquare(dom, knots, w, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dom</code></td>
<td>
<p>An <code>sf</code> or <code>sfc</code> object with areas
<code class="reqn">A_1, \ldots, A_n</code> to evaluate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>Knots <code class="reqn">\bm{c}_1, \ldots, \bm{c}_r</code> for the basis.
See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Radius for the basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A <code>list</code> of control arguments. See "Details".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li> <p><code>knots</code> may be provided as either an <code>sf</code> or <code>sfc</code> object, or as a
matrix of points.
</p>
</li>
<li>
<p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 2</code> numeric matrix.
</p>
</li>
<li>
<p> If <code>knots</code> is an <code>sf</code> or <code>sfc</code> object, it is checked
to ensure the coordinate system matches <code>dom</code>.
</p>
</li>
</ul>
<p>For each area <code class="reqn">A</code> in the given domain, compute an the basis functions
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) = \frac{1}{|A|} \int_A \varphi_j(\bm{u}) d\bm{u}
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>. Here, <code class="reqn">\varphi_j(\bm{u})</code> represent
spatial_bisquare basis functions defined at the point level
using <code class="reqn">\bm{c}_j</code> and <code class="reqn">w</code>.
</p>
<p>The basis requires an integration which may be computed using one
of two methods. The <code>mc</code> method uses
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) \approx
\frac{1}{Q} \sum_{q=1}^Q \varphi_j(\bm{u}_q),
</code>
</p>

<p>based on a random sample of locations <code class="reqn">\bm{u}_1, \ldots, \bm{u}_Q</code> from
a uniform distribution on area <code class="reqn">A</code>. The <code>rect</code> method uses
a simple quadrature approximation
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) \approx
\frac{1}{|A|}  \sum_{a=1}^{n_x} \sum_{b=1}^{n_y} \varphi_j(\bm{u}_{ab})
I(\bm{u}_{ab} \in A) \Delta_x \Delta_y.
</code>
</p>

<p>Here, the bounding box <code>st_bbox(A)</code> is divided evenly into a grid of
<code class="reqn">n_x \times n_y</code> rectangles, each of size <code class="reqn">\Delta_x \times \Delta_y</code>.
Each <code class="reqn">\bm{u}_{ab} = (u_a, u_b)</code> is a point from the <code class="reqn">(a,b)</code>th
rectangle, for <code class="reqn">a = 1, \ldots, n_x</code> and <code class="reqn">b = 1, \ldots, n_y</code>.
</p>
<p>Due to the treatment of <code class="reqn">A_i</code> and <code class="reqn">\bm{c}_j</code> as objects in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>
<p>The <code>control</code> argument is a list which may provide any of the following:
</p>

<ul>
<li> <p><code>method</code> specifies computation method: <code>mc</code> or <code>rect</code>.
Default is <code>mc</code>.
</p>
</li>
<li> <p><code>mc_reps</code> is number of repetitions to use for <code>mc</code>.
Default is 1000.
</p>
</li>
<li> <p><code>nx</code> is number of x-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>ny</code> is number of y-axis oints to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>report_period</code> is an integer; print a message with progress each
time this many areas are processed. Default is <code>Inf</code> so that message
is suppressed.
</p>
</li>
<li> <p><code>verbose</code> is a logical; if <code>TRUE</code> print descriptive
messages about the computation. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>mc_sampling_factor</code> is a positive number; an oversampling factor
used to compute <code>blocksize</code> in the rdomain function. I.e.,
<code>blocksize = ceiling(mc_sampling_factor * mc_reps)</code>. Default
is 1.2.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\bar{\varphi}_1(A_i), \ldots, \bar{\varphi}_r(A_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code>areal_spacetime_bisquare()</code>,
<code>spacetime_bisquare()</code>,
<code>spatial_bisquare()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y)
knots_sf = st_as_sf(knots, coords = c("x","y"), crs = NA, agr = "constant")

# Create a simple domain (of rectangles) to evaluate
shape1 = matrix(c(0.0,0.0, 0.5,0.0, 0.5,0.5, 0.0,0.5, 0.0,0.0), ncol=2, byrow=TRUE)
shape2 = shape1 + cbind(rep(0.5,5), rep(0.0,5))
shape3 = shape1 + cbind(rep(0.0,5), rep(0.5,5))
shape4 = shape1 + cbind(rep(0.5,5), rep(0.5,5))
sfc = st_sfc(
   st_polygon(list(shape1)),
   st_polygon(list(shape2)),
   st_polygon(list(shape3)),
   st_polygon(list(shape4))
)
dom = st_sf(data.frame(geoid = 1:length(sfc), geom = sfc))

rad = 0.5
areal_spatial_bisquare(dom, knots, rad)
areal_spatial_bisquare(dom, knots_sf, rad)

# Plot the knots and the points at which we evaluated the basis
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
plot(dom[,1], col = NA, add = TRUE)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>


</div>