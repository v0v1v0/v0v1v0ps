<div class="container">

<table style="width: 100%;"><tr>
<td>mseFH.ns.mprop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</h2>

<h3>Description</h3>

<p>This function gives the MSE of transformed EBLUP based on a multivariate Fay-Herriot model. For sampled domains, MSE is estimated using modified parametric bootstrap approach proposed by Gonzalez-Manteiga. For non-sampled domains, MSE is estimated using modified approach by using average sampling variance of sampled domain in each cluster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mseFH.ns.mprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  cluster = "auto",
  B = 400,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code> that describe the fitted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vardir</code></td>
<td>
<p>sampling variances of direct estimations. If data is defined, it is a vector containing names of sampling variance columns. If data is not defined, it should be a data frame of sampling variances of direct estimators. The order is <code class="reqn">var1, var2, \dots, var(q-1), cov12, \dots, cov1(q-1), cov23, \dots, cov(q-2)(q-1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Default: <code>"auto"</code>. If <code>cluster = "auto"</code>, then the clustering will be performed by the function by finding optimal number of cluster. If cluster is a vector containing numbers of cluster for each category, then clustering will be performed based on the chosen number of cluster. If cluster is a data frame or matrix containing cluster information, then the vector will be used directly to find average of random effects. Clustering is performed with k-medoids algorithms using the function <code>pamk</code>. If <code>"auto"</code> is chosen, <code>krange</code> are set to <code>2:(nrow(data)-1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>number of Bootstrap iterations in calculating MSE, Default: <code>400</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table><tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td>
</tr></table>
<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr for each categoory.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li>
</ul>
<table><tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td>
</tr></table>
<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated covariance matrix of random effects.
</p>
</li>
<li> <p><code>cluster</code> : cluster of each category.
</p>
</li>
<li> <p><code>cluster.information</code> : a list containing data frames with average random effects of sampled domain in each cluster.
</p>
</li>
</ul>
<table><tr style="vertical-align: top;">
<td><code>components</code></td>
<td>
<p>a list containing the following objects:</p>
</td>
</tr></table>
<ul>
<li> <p><code>random.effects</code> : data frame containing estimated random effect values of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li>
<li> <p><code>residuals</code> : data frame containing residuals of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li>
</ul>
<table><tr style="vertical-align: top;">
<td><code>mse</code></td>
<td>
<p>data frame containing estimated MSE of the estimators.</p>
</td>
</tr></table>
<ul>
<li> <p><code>PC</code> : estimated MSE of plugin (PC) estimators for each category.
</p>
</li>
<li> <p><code>status</code> : status of domain, whether sampled or non-sampled.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Load dataset
data(datasaem.ns)

## If data is defined
Fo = list(Y1 ~ X1,
          Y2 ~ X2,
          Y3 ~ X3)
vardir = c("v1", "v2", "v3", "v12", "v13", "v23")
MSE.ns &lt;- mseFH.ns.mprop(Fo, vardir, data = datasaem.ns, B = 10)

## If data is undefined (and option for cluster arguments)
Fo = list(datasaem.ns$Y1 ~ datasaem.ns$X1,
          datasaem.ns$Y2 ~ datasaem.ns$X2,
          datasaem.ns$Y3 ~ datasaem.ns$X3)
vardir = datasaem.ns[, c("v1", "v2", "v3", "v12", "v13", "v23")]

### "auto"
MSE.ns1 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = "auto", B = 10)

### number of clusters
MSE.ns2 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = c(3, 2, 2), B = 10)

### data frame or matrix containing cluster for each domain
MSE.ns3 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = datasaem.ns[, c("c1", "c2", "c3")], B = 10)

## See the estimators
MSE.ns$mse

## NOTE:
## B = 10 is just for examples.
## Please choose a proper number for Bootstrap iterations in real calculation.

## End(Not run)

</code></pre>


</div>