<div class="container">

<table style="width: 100%;"><tr>
<td>sk_corr_mat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct 1D stationary correlation matrices for regularly spaced data</h2>

<h3>Description</h3>

<p>The i,jth value of the returned correlation matrix is the marginal correlation between
the ith and jth points in a regularly spaced sequence of <code>n</code> 1-dimensional (1D) points,
given the correlation model with parameters defined in list <code>pars</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_corr_mat(pars, n, gres = 1, i = seq(n), j = seq(n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>list of kernel parameters 'k' and 'kp' (see <code>sk_corr</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>positive integer, the number of points on the 1D line</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gres</code></td>
<td>
<p>positive numeric, the distance between adjacent grid lines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>vector, a subset of <code>seq(n)</code> indicating rows to return</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>vector, a subset of <code>seq(n)</code> indicating columns to return</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This matrix is symmetric and Toeplitz as a result of the assumption of stationarity
of the random field and regularity of the grid.
</p>
<p>The distance between adjacent points is specified by <code>gres</code>. Subsets of
the correlation matrix can be requested by specifying <code>i</code> and/or <code>j</code> (default
behaviour is to include all).
</p>
<p>Like <code>sk_corr</code>, this function is for computing 1D components of a 2D process.
The product of two matrices returned by <code>sk_corr_mat</code> is the correlation
matrix for a spatially separable process (see examples).
</p>


<h3>Value</h3>

<p>the n x n correlation matrix, or its subset as specified in <code>i</code>, <code>j</code>
</p>


<h3>See Also</h3>

<p>Other internal variance-related functions: 
<code>sk_corr()</code>,
<code>sk_toep_mult()</code>,
<code>sk_var_mult()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# define test distances, grid, and example kernel
n_test = 10
g_example = sk(n_test)
pars = sk_pars(g_example, c('mat', 'gau'))

# compute the correlation matrices and their kronecker product
cx = sk_corr_mat(pars[['x']], n=n_test)
cy = sk_corr_mat(pars[['y']], n=n_test)
cxy = kronecker(cx, cy)

# sk_var can return these two matrices in a list
cxy_list = sk_var(g_example, pars, sep=TRUE)
max(abs( cxy_list[['y']] - cy ))
max(abs( cxy_list[['x']] - cx ))

# ... or it can compute the full covariance matrix for model pars (default)
var_matrix = sk_var(g_example, pars, sep=FALSE)
var_matrix_compare = (pars$psill*cxy) + diag(pars$eps, n_test^2)
max(abs( var_matrix - var_matrix_compare ))

# extract a subgrid without computing the whole thing
cx_sub = sk_corr_mat(pars[['x']], n=n_test, i=2:4, j=2:4)
cx_sub - cx[2:4, 2:4]

# gres scales distances. Increasing gres causes correlations to decrease
cx_long = sk_corr_mat(pars[['x']], n=n_test, gres=2*g_example$gres)
cx_long &lt; cx

</code></pre>


</div>