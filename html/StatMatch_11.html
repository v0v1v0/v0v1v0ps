<div class="container">

<table style="width: 100%;"><tr>
<td>harmonize.x</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Harmonizes the marginal (joint) distribution of a set of variables observed independently in two sample surveys referred to the same target population</h2>

<h3>Description</h3>

<p>This function permits to harmonize the marginal or the joint distribution of a set of variables observed independently in two sample surveys carried out on the same target population.  This harmonization is carried out by using the calibration of the survey weights of the sample units in both the surveys according to the procedure suggested by Renssen (1998).
</p>


<h3>Usage</h3>

<pre><code class="language-R">harmonize.x(svy.A, svy.B, form.x, x.tot=NULL, 
                      cal.method="linear", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>svy.A</code></td>
<td>

<p>A <code>svydesign</code> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object that stores the data collected in the the survey A and all the information concerning the corresponding sampling design.  This object can be created by using the function <code>svydesign</code> in the package <span class="pkg">survey</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>svy.B</code></td>
<td>

<p>A <code>svydesign</code> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object that stores the data collected in the the survey B and all the information concerning the corresponding sampling design.  This object can be created by using the function <code>svydesign</code> in the package <span class="pkg">survey</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form.x</code></td>
<td>

<p>A <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> formula specifying which of the variables, common to both the surveys, have to be considered, and how have to be considered.  For instance <br><code>form.x=~x1+x2</code> means that the marginal distribution of the variables x1 and x2 have to be harmonized and there is also an ‘Intercept’.  In order to skip the intercept the formula has to be written in the following manner <br><code>form.x=~x1+x2-1</code>.
</p>
<p>When dealing with categorical variables, the formula <code>form.x=~x1:x2-1</code> means that the harmonization has to be carried out by considering the joint distribution of the two variables (x1 vs. x2).  To better understand how <code>form.x</code> works see <code>model.matrix</code> (see also <code>formula</code>).
</p>
<p>Due to weights calibration features, it is preferable to work with categorical <b>X</b> variables.  In some cases, the procedure may be successful when a single continuous variable is considered jointly with one or more categorical variables.  When dealing with several continuous variable it may be preferable to categorize them.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.tot</code></td>
<td>

<p>A vector or table with known population totals for the <b>X</b> variables.  A vector is required when <code>cal.method="linear"</code> or <code>cal.method="raking"</code>.  The names and the length of the vector depends on the way it is specified the argument <code>form.x</code> (see <code>model.matrix</code>).  A contingency table is required when <br><code>cal.method="poststratify"</code> (for details see <code>postStratify</code>).
</p>
<p>When <code>x.tot</code> is not provided (i.e. <code>x.tot=NULL</code>) then the vector of totals is estimated as a weighted average of the totals estimated on the two surveys.  The weight assigned to the totals estimated from A is <code class="reqn">\lambda = n_A/(n_A+n_B)</code>;  <code class="reqn">1-\lambda</code> is the weight assigned to <b>X</b> totals estimated from survey B (<code class="reqn">n_A</code> and <code class="reqn">n_B</code> are the number of units in A and B respectively).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cal.method</code></td>
<td>

<p>A string that specifies how the calibration of the weights in <code>svy.A</code> and <code>svy.B</code> has to be carried out.  By default linear calibration is performed ( <code>cal.method="linear"</code>).  In particular, the calibration is carried out by mean of the function <code>calibrate</code> in the package <span class="pkg">survey</span>.
</p>
<p>Alternatively, it is possible to rake the origin survey weights by specifying <code>cal.method="raking"</code>.  Finally, it is possible to perform a simple post-stratification by setting <code>cal.method="poststratify"</code>.  Note that in this case the weights adjustments are carried out by considering the function <br><code>postStratify</code> in the package <span class="pkg">survey</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments that may be necessary for calibration or post-stratification.  The number of iterations used in calibration can be modified too by using the argument <code>maxit</code> (by default <code>maxit=50</code>).
</p>
<p>See <code>calibrate</code> for further details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function harmonizes the totals of the <b>X</b> variables, observed in both survey A and survey B, to be equal to given known totals specified via <code>x.tot</code>.  When these totals are not known (<code>x.tot=NULL</code>)  they are estimated by combining the estimates derived from the two separate surveys.  The harmonization is carried out according to a procedure suggested by Renssen (1998) based on calibration of survey weights (for major details on calibration see Sarndal and Lundstrom, 2005).  The procedure is particularly suited to deal with categorical <b>X</b> variables, in this case it permits to harmonize the joint or the marginal distribution of the categorical variables being considered. Note that an incomplete crossing of the <b>X</b> variables can be considered: i.e. harmonisation wrt to the joint distribution of <code class="reqn">X_1 \times X_2</code> and the marginal distribution of <code class="reqn">X_3</code>).
</p>
<p>The calibration procedure may not produce the final result due to convergence problems.  In this case an error message appears.  In order to reach convergence it may be necessary to launch the procedure with less constraints (i.e a reduced number of population totals) by joining adjacent categories or by discarding some variables.  
</p>
<p>In some limited cases, it could be possible to consider both categorical and continuous variables.  In this situation it may happen that calibration is not successful.  In order to reach convergence it may be necessary to categorize the continuous <b>X</b> variables.
</p>
<p>Post-stratification is a special case of calibration; all the weights of the units in a given post-stratum are modified so as to reproduce the known total for that post-stratum.  Post-stratification avoids problems of convergence but, on the other hand, it may produce final weights with a higher variability than those derived from the calibration.
</p>


<h3>Value</h3>

<p>A <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> with list the results of calibration procedures carried out on survey A and survey B, respectively.  In particular the following components will be provided:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cal.A</code></td>
<td>

<p>The survey object <code>svy.A</code> after the calibration; in particular, the weights now are calibrated with respect to the totals of the <b>X</b> variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cal.B</code></td>
<td>

<p>The survey object <code>svy.B</code> after the calibration; in particular, the weights now are calibrated with respect to the totals of the <b>X</b> variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.A</code></td>
<td>

<p>The new calibrated weights associated to the the units in <code>svy.A</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.B</code></td>
<td>

<p>The new calibrated weights associated to the the units in <code>svy.B</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>Stores the call to this function  with all the values specified for the various arguments (<code>call=match.call()</code>).
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marcello D'Orazio <a href="mailto:mdo.statmatch@gmail.com">mdo.statmatch@gmail.com</a> 
</p>


<h3>References</h3>

<p>D'Orazio, M., Di Zio, M. and Scanu, M. (2006). <em>Statistical Matching: Theory and Practice</em>. Wiley, Chichester.
</p>
<p>Renssen, R.H. (1998) “Use of Statistical Matching Techniques in Calibration Estimation”. <em>Survey Methodology</em>, N. <b>24</b>, pp. 171–183.
</p>
<p>Sarndal, C.E. and Lundstrom, S. (2005) <em>Estimation in Surveys with Nonresponse</em>. Wiley, Chichester.
</p>


<h3>See Also</h3>

 
<p><code>comb.samples</code>, <code>calibrate</code>, <code>svydesign</code>, <code>postStratify</code>, 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(quine, package="MASS") #loads quine from MASS
str(quine)

# split quine in two subsets
suppressWarnings(RNGversion("3.5.0"))
set.seed(7654)
lab.A &lt;- sample(nrow(quine), 70, replace=TRUE)
quine.A &lt;- quine[lab.A, c("Eth","Sex","Age","Lrn")]
quine.B &lt;- quine[-lab.A, c("Eth","Sex","Age","Days")]

# create svydesign objects
require(survey)
quine.A$f &lt;- 70/nrow(quine) # sampling fraction
quine.B$f &lt;- (nrow(quine)-70)/nrow(quine)
svy.qA &lt;- svydesign(~1, fpc=~f, data=quine.A)
svy.qB &lt;- svydesign(~1, fpc=~f, data=quine.B)

#------------------------------------------------------
# example (1)
# Harmonizazion of the distr. of Sex vs. Age
# usign poststratification

# (1.a) known population totals
# the population toatal are computed on the full data frame
tot.sex.age &lt;- xtabs(~Sex+Age, data=quine)
tot.sex.age

out.hz &lt;- harmonize.x(svy.A=svy.qA, svy.B=svy.qB, form.x=~Sex+Age,
          x.tot=tot.sex.age, cal.method="poststratify")

tot.A &lt;- xtabs(out.hz$weights.A~Sex+Age, data=quine.A)
tot.B &lt;- xtabs(out.hz$weights.B~Sex+Age, data=quine.B)

tot.sex.age-tot.A
tot.sex.age-tot.B

# (1.b) unknown population totals (x.tot=NULL)
# the population total is estimated by combining totals from the
 # two surveys

out.hz &lt;- harmonize.x(svy.A=svy.qA, svy.B=svy.qB, form.x=~Sex+Age,
          x.tot=NULL, cal.method="poststratify")

tot.A &lt;- xtabs(out.hz$weights.A~Sex+Age, data=quine.A)
tot.B &lt;- xtabs(out.hz$weights.B~Sex+Age, data=quine.B)

tot.A
tot.A-tot.B

#-----------------------------------------------------
# example (2)
# Harmonizazion wrt the maginal distribution
# of 'Eth', 'Sex' and 'Age'
# using linear calibration

# (2.a) vector of population total known
# estimated from the full data set
# note the formula! only marginal distribution of the
# variables are considered
tot.m &lt;- colSums(model.matrix(~Eth+Sex+Age-1, data=quine))
tot.m

out.hz &lt;- harmonize.x(svy.A=svy.qA, svy.B=svy.qB, x.tot=tot.m,
            form.x=~Eth+Sex+Age-1, cal.method="linear")

summary(out.hz$weights.A) #check for negative weights
summary(out.hz$weights.B) #check for negative weights

tot.m
svytable(formula=~Eth, design=out.hz$cal.A)
svytable(formula=~Eth, design=out.hz$cal.B)

svytable(formula=~Sex, design=out.hz$cal.A)
svytable(formula=~Sex, design=out.hz$cal.B)

# Note: margins are equal but joint distributions are not!
svytable(formula=~Sex+Age, design=out.hz$cal.A)
svytable(formula=~Sex+Age, design=out.hz$cal.B)

# (2.b) vector of population total unknown
out.hz &lt;- harmonize.x(svy.A=svy.qA, svy.B=svy.qB, x.tot=NULL,
            form.x=~Eth+Sex+Age-1, cal.method="linear")
svytable(formula=~Eth, design=out.hz$cal.A)
svytable(formula=~Eth, design=out.hz$cal.B)

svytable(formula=~Sex, design=out.hz$cal.A)
svytable(formula=~Sex, design=out.hz$cal.B)

#-----------------------------------------------------
# example (3)
# Harmonizazion wrt the joint distribution of 'Sex' vs. 'Age'
# and the marginal distribution of 'Eth'
# using raking

# vector of population total known
# estimated from the full data set
# note the formula!
tot.m &lt;- colSums(model.matrix(~Eth+(Sex:Age-1)-1, data=quine))
tot.m

out.hz &lt;- harmonize.x(svy.A=svy.qA, svy.B=svy.qB, x.tot=tot.m,
            form.x=~Eth+(Sex:Age)-1, cal.method="raking")

summary(out.hz$weights.A) #check for negative weights
summary(out.hz$weights.B) #check for negative weights

tot.m
svytable(formula=~Eth, design=out.hz$cal.A)
svytable(formula=~Eth, design=out.hz$cal.B)

svytable(formula=~Sex+Age, design=out.hz$cal.A)
svytable(formula=~Sex+Age, design=out.hz$cal.B)


</code></pre>


</div>