<div class="container">

<table style="width: 100%;"><tr>
<td>licd_multi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local Indicators for Categorical Data</h2>

<h3>Description</h3>

<p>Local indicators for categorical data combine a measure of local composition in a window given by the per-observation set of neighbouring observations, with a local multi-category joincount test simplified to neighbours with the same or different categories compared to the focal observation</p>


<h3>Usage</h3>

<pre><code class="language-R">licd_multi(fx, listw, zero.policy = attr(listw, "zero.policy"), adjust.n = TRUE,
 nsim = 0L, iseed = NULL, no_repeat_in_row = FALSE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fx</code></td>
<td>
<p>a factor with two or more categories, of the same length as the neighbours and weights objects in listw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>default 0, number of conditonal permutation simulations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>default NULL, used to set the seed; the output will only be reproducible if the count of CPU cores across which computation is distributed is the same</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>comp_binary=TRUE, binomial_punif_alternative="greater",
jcm_same_punif_alternative="less", jcm_diff_punif_alternative="greater"</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The original code may be found at <a href="https://doi.org/10.5281/zenodo.4283766">doi:10.5281/zenodo.4283766</a></p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>local_comp</code></td>
<td>
<p>data.frame object with LICD local composition columns: ID,
category_i, count_like_i, prop_i, count_nbs_i, pbinom_like_BW,
pbinom_unlike_BW, pbinom_unlike_BW_alt, chi_BW_i, chi_K_i, anscombe_BW</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local_config</code></td>
<td>
<p>data.frame object with LICD local configuration columns: ID, jcm_chi_obs, jcm_count_BB_obs, jcm_count_BW_obs, jcm_count_WW_obs, pval_jcm_obs_BB, pval_jcm_obs_WW, pval_jcm_obs_BW</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local_comp_sim</code></td>
<td>
<p>data.frame object with permutation-based LICD local composition columns: ID, pbinom_like_BW, pbinom_unlike_BW, pbinom_unlike_BW_alt, rank_sim_chi_BW, rank_sim_chi_K, rank_sim_anscombe</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local_config_sim</code></td>
<td>
<p>data.frame object with permutation-based LICD local configuration columns: ID, jcm_chi_sim_rank, pval_jcm_obs_BB_sim, pval_jcm_obs_BW_sim, pval_jcm_obs_WW_sim</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In order to increase the numbers of neighbours using <code>nblag</code> and <code>nblag_cumul</code> is advisable; use of binary weights is advised and are in any case used for the composition measure</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> based on earlier code by Tomasz M. Kossowski, Justyna Wilk and Michał B. Pietrzak</p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 20; 
</p>
<p>Upton, G., Fingleton, B. 1985 Spatial data analysis by example: point pattern and qualitative data, Wiley, pp. 158–170; 
</p>
<p>Boots, B., 2003. Developing local measures of spatial association for categorical data. Journal of Geographical Systems 5, 139–160; 
</p>
<p>Boots, B., 2006. Local configuration measures for categorical spatial data: binary regular lattices. Journal of Geographical Systems 8 (1), 1–24; 
</p>
<p>Pietrzak, M.B., Wilk, J., Kossowski, T., Bivand, R.S., 2014. The application of local indicators for categorical data (LICD) in the spatial analysis of economic development. Comparative Economic Research 17 (4), 203–220 <a href="https://doi.org/10.2478/cer-2014-0041">doi:10.2478/cer-2014-0041</a>; 
</p>
<p>Bivand, R.S., Wilk, J., Kossowski, T., 2017. Spatial association of population pyramids across Europe: The application of symbolic data, cluster analysis and join-count tests. Spatial Statistics 21 (B), 339–361 <a href="https://doi.org/10.1016/j.spasta.2017.03.003">doi:10.1016/j.spasta.2017.03.003</a>; 
</p>
<p>Francesco Carrer, Tomasz M. Kossowski, Justyna Wilk, Michał B. Pietrzak, Roger S. Bivand, The application of Local Indicators for Categorical Data (LICD) to explore spatial dependence in archaeological spaces, Journal of Archaeological Science, 126, 2021, <a href="https://doi.org/10.1016/j.jas.2020.105306">doi:10.1016/j.jas.2020.105306</a>
</p>


<h3>See Also</h3>

<p><code>joincount.multi</code></p>


<h3>Examples</h3>

<pre><code class="language-R">columbus &lt;- st_read(system.file("shapes/columbus.gpkg", package="spData")[1], quiet=TRUE)
HICRIME &lt;- cut(columbus$CRIME, breaks=c(0,35,80), labels=c("low","high"))
(nb &lt;- poly2nb(columbus))
lw &lt;- nb2listw(nblag_cumul(nblag(nb, 2)), style="B")
obj &lt;- licd_multi(HICRIME, lw)
str(obj)
h_obj &lt;- hotspot(obj)
str(h_obj)
table(h_obj$both_recode)
columbus$both &lt;- h_obj$both_recode
plot(columbus[, "both"])
GDAL37 &lt;- as.numeric_version(unname(sf_extSoftVersion()["GDAL"])) &gt;= "3.7.0"
file &lt;- "etc/shapes/GB_2024_southcoast_50m.gpkg.zip"
zipfile &lt;- system.file(file, package="spdep")
if (GDAL37) {
    sc50m &lt;- st_read(zipfile)
} else {
    td &lt;- tempdir()
    bn &lt;- sub(".zip", "", basename(file), fixed=TRUE)
    target &lt;- unzip(zipfile, files=bn, exdir=td)
    sc50m &lt;- st_read(target)
}
sc50m$Winner &lt;- factor(sc50m$Winner, levels=c("Con", "Green", "Lab", "LD"))
plot(sc50m[,"Winner"], pal=c("#2297E6", "#61D04F", "#DF536B", "#F5C710"))
nb_sc_50m &lt;- poly2nb(sc50m, row.names=as.character(sc50m$Constituency))
sub2 &lt;- attr(nb_sc_50m, "region.id")[attr(nb_sc_50m, "ncomp")$comp.id == 2L]
iowe &lt;- match(sub2[1], attr(nb_sc_50m, "region.id"))
diowe &lt;- c(st_distance(sc50m[iowe,], sc50m))
meet_criterion &lt;- sum(diowe &lt;= units::set_units(5000, "m"))
cands &lt;- attr(nb_sc_50m, "region.id")[order(diowe)[1:meet_criterion]]
nb_sc_50m_iowe &lt;- addlinks1(nb_sc_50m, from = cands[1],
 to = cands[3:meet_criterion])
ioww &lt;- match(sub2[2], attr(nb_sc_50m, "region.id"))
dioww &lt;- c(st_distance(sc50m[ioww,], sc50m))
meet_criterion &lt;- sum(dioww &lt;= units::set_units(5000, "m"))
cands &lt;- attr(nb_sc_50m, "region.id")[order(dioww)[1:meet_criterion]]
nb_sc_50m_iow &lt;- addlinks1(nb_sc_50m_iowe, from = cands[2], to = cands[3:meet_criterion])
nb_sc_1_2 &lt;- nblag_cumul(nblag(nb_sc_50m_iow, 2))
lw &lt;- nb2listw(nb_sc_1_2, style="B")
licd_obj &lt;- licd_multi(sc50m$Winner, lw)
h_obj &lt;- hotspot(licd_obj)
sc50m$both &lt;- h_obj$both_recode
plot(sc50m[, "both"])
ljc &lt;- local_joincount_uni(factor(sc50m$Winner == "LD"), chosen="TRUE", lw)
sc50m$LD_pv &lt;- ljc[, 2]
plot(sc50m[, "LD_pv"], breaks=c(0, 0.025, 0.05, 0.1, 0.5, 1))
</code></pre>


</div>