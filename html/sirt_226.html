<div class="container">

<table style="width: 100%;"><tr>
<td>mgsem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimation of Multiple-Group Structural Equation Models
</h2>

<h3>Description</h3>

<p>Estimates a multiple-group structural equation model. The function allows arbitrary
prior distributions on model parameters and regularized estimation with the SCAD and
the LASSO penalty. Moreover, it can also conduct robust moment estimation using
the <code class="reqn">L_p</code> loss function <code class="reqn">\rho(x)=|x|^p</code> for <code class="reqn">p \ge 0</code>.
See Robitzsch (2023) for more details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mgsem(suffstat, model, data=NULL, group=NULL, weights=NULL, estimator="ML",
     p_me=2, p_pen=1, pen_type="scad", diffpar_pen=NULL, pen_sample_size=TRUE,
     a_scad=3.7, eps_approx=0.001, comp_se=TRUE, se_delta_formula=FALSE,
     prior_list=NULL, hessian=TRUE, fixed_parms=FALSE, cd=FALSE,
     cd_control=list(maxiter=20, tol=5*1e-04, interval_length=0.05, method="exact"),
     partable_start=NULL, num_approx=FALSE, technical=NULL, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>suffstat</code></td>
<td>

<p>List containing sufficient statistics
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Model specification, see examples. Can have entries <code>est</code>, <code>index</code>,
<code>lower</code>, <code>upper</code>, <code>prior</code>, <code>pen_l2</code>, <code>pen_lp</code>,
<code>pen_difflp</code>. Each entry can be defined for model matrices <code>ALPHA</code>,
<code>NU</code>, <code>LAM</code>, <code>PHI</code>, and <code>PSI</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Optional data frame
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>

<p>Optional vector of group identifiers
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>

<p>Character. Can be either <code>"ML"</code> for maximum likelihood fitting function or
<code>"ME"</code> for robust moment estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_me</code></td>
<td>

<p>Power in $L_p$ loss function for robust moment estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_pen</code></td>
<td>

<p>Power for penalty in regularized estimation. For regular LASSO and SCAD penalty
functions, it is $p=1$.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen_type</code></td>
<td>

<p>Penalty type. Can be either <code>"scad"</code> or <code>"lasso"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diffpar_pen</code></td>
<td>

<p>List containing values of regularization parameters in fused lasso estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen_sample_size</code></td>
<td>

<p>List containing values for sample sizes for regularized estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a_scad</code></td>
<td>

<p>Parameter $a$ used in SCAD penalty
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_approx</code></td>
<td>

<p>Approximation value for nondifferentiable robust moment fitting function or
penalty function
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp_se</code></td>
<td>

<p>Logical indicating whether standard errors should be computed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se_delta_formula</code></td>
<td>

<p>Logical indicating whether standard errors should be computed according to the
delta formula
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_list</code></td>
<td>

<p>List containing specifications of the prior distributions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>

<p>Logical indicating whether the Hessian matrix should be computed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_parms</code></td>
<td>

<p>Logical indicating whether all model parameters should be fixed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd</code></td>
<td>

<p>Logical indicating whether coordinate descent should be used for estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd_control</code></td>
<td>

<p>Control parameters for coordinate descent estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable_start</code></td>
<td>

<p>Starting values for parameter estimation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_approx</code></td>
<td>

<p>Logical indicating whether derivatives should be computed based on numerical
differentiation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>technical</code></td>
<td>

<p>Parameters used for optimization in <code>sirt_optimizer</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>Control paramaters for optimization
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>[MORE INFORMATION TO BE ADDED]
</p>


<h3>Value</h3>

<p>A list with following values
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>Coeffients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Variance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Vector of standard errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>
<p>Parameter table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Specified model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_res</code></td>
<td>
<p>Result from optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_value</code></td>
<td>
<p>Value of fitting function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>Residuals of sufficient statistics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>technical</code></td>
<td>
<p>Specifications of optimizer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffstat_vcov</code></td>
<td>
<p>Variance matrix of sufficient statistics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>me_delta_method</code></td>
<td>
<p>Input and output matrices for delta method if
<code>estimator="ME"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_proc</code></td>
<td>
<p>Processed data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_ll</code></td>
<td>
<p>Casewise log-likelihood function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further values</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Robitzsch, A. (2023). Model-robust estimation of multiple-group structural
equation models. <em>Algorithms, 16</em>(4), 210. <a href="https://doi.org/10.3390/a16040210">doi:10.3390/a16040210</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: Noninvariant item intercepts in a multiple-group SEM
#############################################################################

#---- simulate data
set.seed(65)
G &lt;- 3  # number of groups
I &lt;- 5  # number of items
# define lambda and nu parameters
lambda &lt;- matrix(1, nrow=G, ncol=I)
nu &lt;- matrix(0, nrow=G, ncol=I)
err_var &lt;- matrix(1, nrow=G, ncol=I)

# define extent of noninvariance
dif_int &lt;- .5

#- 1st group: N(0,1)
nu[1,4] &lt;- dif_int
#- 2nd group: N(0.3,1.5)
gg &lt;- 2 ;
nu[gg,1] &lt;- -dif_int
#- 3nd group: N(.8,1.2)
gg &lt;- 3
nu[gg,2] &lt;- -dif_int
#- define distributions of groups
mu &lt;- c(0,.3,.8)
sigma &lt;- sqrt(c(1,1.5,1.2))
N &lt;- rep(1000,3) # sample sizes per group

exact &lt;- FALSE
suffstat &lt;- sirt::invariance_alignment_simulate(nu, lambda, err_var, mu, sigma, N,
                output="suffstat", groupwise=TRUE, exact=exact)

#---- model specification

# model specifications joint group
est &lt;- list(
        ALPHA=matrix( c(0), ncol=1),
        NU=matrix( 0, nrow=I, ncol=1),
        LAM=matrix(1, nrow=I, ncol=1),
        PHI=matrix(0,nrow=1,ncol=1),
        PSI=diag(rep(1,I))
        )

# parameter index
index &lt;- list(
        ALPHA=0*est$ALPHA,
        NU=1+0*est$NU,
        LAM=1+0*est$LAM,
        PHI=0*est$PHI,
        PSI=diag(1,I)
        )

# lower bounds
lower &lt;- list(
        PSI=diag(rep(0.01,I)), PHI=matrix(0.01,1,1)
        )

#*** joint parameters
group0 &lt;- list(est=est, index=index, lower=lower)

#*** group1
est &lt;- list(
        ALPHA=matrix( c(0), ncol=1),
        NU=matrix( 0, nrow=I, ncol=1),
        LAM=matrix(0, nrow=I, ncol=1),
        PHI=matrix(1,nrow=1,ncol=1)
            )

# parameter index
index &lt;- list(
        ALPHA=0*est$ALPHA,
        NU=0*est$NU,
        LAM=1*est$LAM,
        PHI=0*est$PHI
        )

group1 &lt;- list(est=est, index=index, lower=lower)

#*** group 2 and group 3

# modify parameter index
index$ALPHA &lt;- 1+0*est$ALPHA
index$PHI &lt;- 1+0*est$PHI
group3 &lt;- group2 &lt;- list(est=est, index=index, lower=lower)

#*** define model
model &lt;- list(group0=group0, group1=group1, group2=group2, group3=group3)

#-- estimate model with ML
res1 &lt;- sirt::mgsem( suffstat=suffstat, model=model2, eps_approx=1e-4, estimator="ML",
                    technical=list(maxiter=500, optimizer="optim"),
                    hessian=FALSE, comp_se=FALSE, control=list(trace=1) )
str(res1)

#-- robust moment estimation with p=0.5

optimizer &lt;- "optim"
technical &lt;- list(maxiter=500, optimizer=optimizer)
eps_approx &lt;- 1e-3

res2 &lt;- sirt::mgsem( suffstat=suffstat, model=res1$model, p_me=0.5,
                    eps_approx=eps_approx, estimator="ME", technical=technical,
                    hessian=FALSE, comp_se=FALSE, control=list(trace=1) )

#---- regularized estimation

nu_lam &lt;- 0.1    # regularization parameter

# redefine model
define_model &lt;- function(model, nu_lam)
{
    pen_lp &lt;- list( NU=nu_lam+0*model$group1$est$NU)
    ee &lt;- "group1"
    for (ee in c("group1","group2","group3"))
    {
        model[[ee]]$index$NU &lt;- 1+0*index$NU
        model[[ee]]$pen_lp &lt;- pen_lp
    }
    return(model)
}

model3 &lt;- define_model(model=model, nu_lam=nu_lam)
pen_type &lt;- "scad"

res3 &lt;- sirt::mgsem( suffstat=suffstat, model=model3, p_pen=1, pen_type=pen_type,
                    eps_approx=eps_approx, estimator="ML",
                    technical=list(maxiter=500, optimizer="optim"),
                    hessian=FALSE, comp_se=FALSE, control=list(trace=1) )
str(res3)

## End(Not run)
</code></pre>


</div>