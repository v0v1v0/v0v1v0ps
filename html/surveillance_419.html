<div class="container">

<table style="width: 100%;"><tr>
<td>hhh4_W</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Power-Law and Nonparametric Neighbourhood Weights for <code>hhh4</code>-Models
</h2>

<h3>Description</h3>

<p>Set up power-law or nonparametric weights for the neighbourhood
component of <code>hhh4</code>-models as proposed by Meyer and Held (2014).
Without normalization, power-law weights are
<code class="reqn">w_{ji} = o_{ji}^{-d}</code>
(if <code class="reqn">o_{ji} &gt; 0</code>, otherwise <code class="reqn">w_{ji} = 0</code>),
where <code class="reqn">o_{ji}</code> (<code class="reqn">=o_{ij}</code>) is the adjacency order
between regions <code class="reqn">i</code> and <code class="reqn">j</code>,
and the decay parameter <code class="reqn">d</code> is to be estimated.
In the nonparametric formulation, unconstrained log-weights will be
estimated for each of the adjacency orders <code>2:maxlag</code> (the
first-order weight is fixed to 1 for identifiability).
Both weight functions can be modified to include a 0-distance weight,
which enables <code>hhh4</code> models without a separate autoregressive component.
</p>


<h3>Usage</h3>

<pre><code class="language-R">W_powerlaw(maxlag, normalize = TRUE, log = FALSE,
           initial = if (log) 0 else 1, from0 = FALSE)

W_np(maxlag, truncate = TRUE, normalize = TRUE,
     initial = log(zetaweights(2:(maxlag+from0))),
     from0 = FALSE, to0 = truncate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>maxlag</code></td>
<td>
<p>a single integer specifying a limiting order of
adjacency. If spatial dependence is not to be truncated at some
high order, <code>maxlag</code> should be set to the maximum adjacency
order in the network of regions. The smallest possible value for
<code>maxlag</code> is 2 if <code>from0=FALSE</code> and 1 otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truncate,to0</code></td>
<td>
<p><code>W_np</code> represents order-specific log-weights up to
order <code>maxlag</code>. Higher orders are by default (<code>truncate=TRUE</code>)
assumed to have zero weight (similar to <code>W_powerlaw</code>).
Alternatively, <code>truncate=FALSE</code> requests that the weight at
order <code>maxlag</code> should be carried forward to higher orders.
<code>truncate</code> has previously been called <code>to0</code> (deprecated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>logical indicating if the weights should be normalized
such that the rows of the weight matrix sum to 1 (default).
Note that normalization does not work with islands, i.e., regions
without neighbours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical indicating if the decay parameter <code class="reqn">d</code> should be
estimated on the log-scale to ensure positivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>initial value of the parameter vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from0</code></td>
<td>
<p>logical indicating if these parametric weights should
include the 0-distance (autoregressive) case. In the default setting
(<code>from0 = FALSE</code>), adjacency order 0 has zero weight, which is
suitable for <code>hhh4</code> models with a separate autoregressive
component. With <code>from0 = TRUE</code> (Meyer and Held, 2017), the
power law is based on <code class="reqn">(o_{ji} + 1)</code>, and
nonparametric weights are estimated for adjacency orders
<code>1:maxlag</code>, respectively, where the 0-distance weight is
<code class="reqn">w_{jj} = 1</code> (without normalization). Note that
the corresponding <code>hhh4</code> model should then exclude a separate
autoregressive component (<code>control$ar$f = ~ -1</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>hhh4</code> will take adjacency orders from the <code>neighbourhood</code>
slot of the <code>"sts"</code> object, so these must be prepared before
fitting a model with parametric neighbourhood weights. The function
<code>nbOrder</code> can be used to derive adjacency orders from a
binary adjacency matrix.
</p>


<h3>Value</h3>

<p>a list which can be passed as a specification of parametric
neighbourhood weights in the <code>control$ne$weights</code> argument of
<code>hhh4</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>References</h3>

<p>Meyer, S. and Held, L. (2014):
Power-law models for infectious disease spread.
<em>The Annals of Applied Statistics</em>, <b>8</b> (3), 1612-1639.
<a href="https://doi.org/10.1214/14-AOAS743">doi:10.1214/14-AOAS743</a>
</p>
<p>Meyer, S. and Held, L. (2017):
Incorporating social contact data in spatio-temporal models for
infectious disease spread.
<em>Biostatistics</em>, <b>18</b> (2), 338-351.
<a href="https://doi.org/10.1093/biostatistics/kxw051">doi:10.1093/biostatistics/kxw051</a>
</p>


<h3>See Also</h3>

  
<p><code>nbOrder</code> to determine adjacency orders from a binary
adjacency matrix.
</p>
<p><code>getNEweights</code> and <code>coefW</code> to extract the
estimated neighbourhood weight matrix and coefficients from an
<code>hhh4</code> model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("measlesWeserEms")

## data contains adjaceny orders as required for parametric weights
plot(measlesWeserEms, type = observed ~ unit, labels = TRUE)
neighbourhood(measlesWeserEms)[1:6,1:6]
max(neighbourhood(measlesWeserEms))  # max order is 5

## fit a power-law decay of spatial interaction
## in a hhh4 model with seasonality and random intercepts in the endemic part
measlesModel &lt;- list(
    ar = list(f = ~ 1),
    ne = list(f = ~ 1, weights = W_powerlaw(maxlag=5)),
    end = list(f = addSeason2formula(~-1 + ri(), S=1, period=52)),
    family = "NegBin1")

## fit the model
set.seed(1)  # random intercepts are initialized randomly
measlesFit &lt;- hhh4(measlesWeserEms, measlesModel)
summary(measlesFit)  # "neweights.d" is the decay parameter d
coefW(measlesFit)

## plot the spatio-temporal weights o_ji^-d / sum_k o_jk^-d
## as a function of adjacency order
plot(measlesFit, type = "neweights", xlab = "adjacency order")
## normalization =&gt; same distance does not necessarily mean same weight.
## to extract the whole weight matrix W: getNEweights(measlesFit)

## visualize contributions of the three model components
## to the overall number of infections (aggregated over all districts)
plot(measlesFit, total = TRUE)
## little contribution from neighbouring districts


if (surveillance.options("allExamples")) {

## simpler model with autoregressive effects captured by the ne component
measlesModel2 &lt;- list(
    ne = list(f = ~ 1, weights = W_powerlaw(maxlag=5, from0=TRUE)),
    end = list(f = addSeason2formula(~-1 + ri(), S=1, period=52)),
    family = "NegBin1")
measlesFit2 &lt;- hhh4(measlesWeserEms, measlesModel2)
## omitting the separate AR component simplifies model extensions/selection
## and interpretation of covariate effects (only two predictors left)

plot(measlesFit2, type = "neweights", exclude = NULL, xlab = "adjacency order")
## strong decay, again mostly within-district transmission
## (one could also try a purely autoregressive model)
plot(measlesFit2, total = TRUE,
     legend.args = list(legend = c("epidemic", "endemic")))
## almost the same RMSE as with separate AR and NE effects
c(rmse1 = sqrt(mean(residuals(measlesFit, "response")^2)),
  rmse2 = sqrt(mean(residuals(measlesFit2, "response")^2)))

}
</code></pre>


</div>