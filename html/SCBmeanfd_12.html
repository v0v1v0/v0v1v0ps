<div class="container">

<table style="width: 100%;"><tr>
<td>scb.model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Goodness-Of-Fit of a Model for the Mean Function</h2>

<h3>Description</h3>

<p>This is the goodness-of-fit test for parametric models of the mean function described in Degras (2011). The candidate model must be a finite-dimensional function space (curvilinear regression). The test is based on the sup-norm distance between a smoothed parametric estimate and a local linear estimate. Graphically, the candidate model is retained whenever one of the estimates lies within the SCB built around the other.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">scb.model(x, y, model, bandwidth, level = .05, degree = 1, 
	scbtype = c("normal","bootstrap","both","no"), gridsize = length(x), 
	keep.y = TRUE, nrep = 2e4, nboot = 5e3, parallel = c("no", "multicore", "snow"), 
	ncpus = getOption("boot.ncpus",1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector of x data. <code>x</code> must be a uniform grid; missing values are not accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an integer specifying the degree of a polynomial basis, or a data frame/matrix containing the basis functions stored in columns. In the latter case, the basis functions must be evaluated on a uniform grid of size <code>gridsize</code> spanning the range of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the significance level of the test (default = .05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>the degree of the local polynomial fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scbtype</code></td>
<td>
<p>the type of simultaneous confidence bands to build: "normal", "bootstrap", "both", or "no".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridsize</code></td>
<td>
<p>the size of the grid over which the mean function is to be estimated. Defaults to <code>length(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, keep <code>y</code> in the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>the number of replicates for the normal SCB method (default = 20,000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>the number of replicates for the bootstrap SCB method (default = 5,000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>the computation method for the bootstrap SCB. By default, computations are sequential (<code>"no"</code>).<br> The function <code>boot</code> is used and can be run in parallel using the package <code>parallel</code>.<br> Both options <code>"multicore"</code> and <code>"snow"</code> are available for parallel computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>the number of cores to use for parallel computing when <code>parallel = "multicore"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>the name of the cluster to use for parallel computing when <code>parallel = "snow"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"SCBand"</code>. To accommodate the different functions creating objects of this class (<code>scb.mean</code>, <code>scb.model</code>, and <code>scb.equal</code>), some components of the object are set to <code>NULL</code>. The component list is:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the argument <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the argument <code>y</code> if <code>keep.y</code> is <code>TRUE</code>, else <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the argument <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>a smoothed parametric estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonpar</code></td>
<td>
<p>a local linear estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>the argument <code>bandwidth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>the degree of the local polynomial. 
Currently, only local linear estimation is supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the argument <code>level</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scbtype</code></td>
<td>
<p>the argument <code>type</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teststat</code></td>
<td>
<p>the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnorm</code></td>
<td>
<p>the <em>p</em> value for the normal-based statistical test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pboot</code></td>
<td>
<p>the <em>p</em> value for the boostrap-based statistical test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qnorm</code></td>
<td>
<p>the quantile used to build the normal SCB.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qboot</code></td>
<td>
<p>the quantile used to build the bootstrap SCB.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normscb</code></td>
<td>
<p>a matrix containing the normal SCB stored in columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootscb</code></td>
<td>
<p>a matrix containing the bootstrap SCB stored in columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridsize</code></td>
<td>
<p>the argument <code>gridsize</code>, or <em>length(x)</em> if no argument was specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>the argument <code>nrep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>the argument <code>nboot</code>.</p>
</td>
</tr>
</table>
<p>Depending on the value of <code>scbtype</code>, some or all of  
the fields <code>pnorm</code>, <code>qnorm</code>, <code>normscb</code>, <code>nrep</code>,  <code>pboot</code>, <code>qboot</code>, <code>normboot</code> and <code>nboot</code> may be   <code>NULL</code>.
</p>


<h3>References</h3>

<p>Degras, D. (2011). Simultaneous confidence bands for nonparametric regression with functional data.<br><em>Statistica Sinica</em>, <b>21</b>, 1735â€“1765.
</p>


<h3>See Also</h3>

<p><code>scb.equal</code>, <code>scb.mean</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example from Degras (2011)
## Gaussian process with polynomial mean function 
## and Ornstein-Uhlenbeck covariance function
## The SCB and PLRT tests are compared

set.seed(100)
p    &lt;- 100  	# number of observation points
x 	  &lt;- seq(0, 1, len = p)
mu	  &lt;- 10 * x^3 - 15 * x^4 + 6 * x^5	# mean 
R 	  &lt;- (.25)^2 * exp(20 * log(.9) * abs(outer(x,x,"-"))) # covariance 
eigR &lt;- eigen(R, symmetric = TRUE)  	
simR &lt;- eigR$vectors %*% diag(sqrt(eigR$values)) 	 

# Candidate model for mu: polynomial of degree &lt;= 3
# This model, although incorrect, closely approximates mu.
# With n = 50 curves, the SCB and PLRT incorrectly retain the model.
# With n = 70 curves, both tests reject it. 
n &lt;- 50  
y &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 	# simulate data  
y &lt;- t(y) 	# arrange the trajectories in rows
h &lt;- cv.select(x, y, 1)	
scb.model(x, y, 3, bandwidth = h)		  # p value: .652
plrt.model(x, y, 3, verbose = TRUE)	# p value: .450 
n &lt;- 70  	
y &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 		
y &lt;- t(y) 										
h &lt;- cv.select(x, y, 1)	
scb.model(x, y, 3, bandwidth = h)		  # p value: .004
plrt.model(x, y, 3, verbose = TRUE)	# p value: .001

# Correct model: polynomials of degree &lt;= 5
scb.model(x, y, 5, bandwidth = h)  	# p value: .696
plrt.model(x, y, 5, verbose = TRUE)	# p value: .628

</code></pre>


</div>