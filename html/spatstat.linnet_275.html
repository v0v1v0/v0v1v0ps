<div class="container">

<table style="width: 100%;"><tr>
<td>spatstat.linnet-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The spatstat.linnet Package</h2>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.linnet</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the functionality
for analysing spatial data on a linear network.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.linnet</span> contains the
user-level functions from <span class="pkg">spatstat</span> 
that are concerned with spatial data on a linear network.
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.univar</span> containing functions for estimating
probability distributions of random variables
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the main functionality
for exploratory and non-parametric analysis of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for statistical modelling and inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li>
</ul>
<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
For an overview of all the functions available in these sub-packages,
see the help file for <span class="pkg">spatstat</span> in the <span class="pkg">spatstat</span> package,
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li>
</ul>
<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Overview of <span class="pkg">spatstat.linnet</span>
</h3>

<p>A linear network is a subset of the two-dimensional plane
composed of straight line segments. It could represent a road network, for
example. Our code requires that, if two segments intersect each other,
then the intersection is a single point, and the intersection point is
treated as a vertex of the network.
</p>
<p>The <span class="pkg">spatstat.linnet</span> package supports spatial data analysis on
a linear network. The primary aim is to analyse spatial patterns of
points on a network. The points could represent road accidents on a
road network, for example.
</p>
<p>The <span class="pkg">spatstat.linnet</span> package provides code for handling
</p>

<ul>
<li> <p><code>linear networks</code>
</p>
</li>
<li> <p><code>point patterns on a linear network</code>
</p>
</li>
<li> <p><code>pixel images on a linear network</code> (where the network is
divided into small segments and a numerical value is assigned to each segment)
</p>
</li>
<li> <p><code>functions on a linear network</code> (i.e. functions that are
defined at every location along the network)
</p>
</li>
<li> <p><code>tessellations of a linear network</code> (where the network is
subdivided into disjoint subsets with different labels)
</p>
</li>
<li> <p><code>point process models on a linear network</code>
</p>
</li>
</ul>
<p>Here is a list of the main functionality
provided in <span class="pkg">spatstat.linnet</span>.
</p>
<p><b>Linear networks</b>
</p>
<p>An object of class <code>"linnet"</code> represents a linear network.
Examples of such objects include the dataset
<code>simplenet</code> provided in the package.
</p>
<p>Linear network objects can be created by the following functions:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>linnet</code> </td>
<td style="text-align: left;"> create a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.linnet</code> </td>
<td style="text-align: left;"> convert other data to a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>delaunayNetwork</code> </td>
<td style="text-align: left;"> network of Delaunay triangulation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>dirichletNetwork</code> </td>
<td style="text-align: left;"> network of Dirichlet edges </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>Utilities for manipulating networks include:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>[.linnet</code>
</td>
<td style="text-align: left;">  extract subset of linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clickjoin</code> </td>
<td style="text-align: left;"> interactively join vertices in network </td>
</tr>
<tr>
<td style="text-align: left;">         <code>joinVertices</code> </td>
<td style="text-align: left;"> join existing vertices in a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>insertVertices</code> </td>
<td style="text-align: left;"> insert new vertices at positions
    along network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>addVertices</code> </td>
<td style="text-align: left;"> add new vertices, extending a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>thinNetwork</code> </td>
<td style="text-align: left;"> remove vertices or lines from a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>repairNetwork</code> </td>
<td style="text-align: left;"> repair internal format </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vertices.linnet</code> </td>
<td style="text-align: left;"> extract the vertices of network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>terminalvertices</code> </td>
<td style="text-align: left;"> find terminal vertices of
    network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>affine.linnet</code> </td>
<td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>shift.linnet</code> </td>
<td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rotate.linnet</code> </td>
<td style="text-align: left;"> apply rotation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rescale.linnet</code> </td>
<td style="text-align: left;"> rescale the unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>scalardilate.linnet</code> </td>
<td style="text-align: left;"> physically rescale the
    network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>diameter.linnet</code> </td>
<td style="text-align: left;"> diameter of linear  network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.connected.linnet</code> </td>
<td style="text-align: left;">  determine whether network
    is connected </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lineardisc</code> </td>
<td style="text-align: left;"> compute disc of given radius in
    network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>marks.linnet</code> </td>
<td style="text-align: left;"> extract marks of a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>marks&lt;-.linnet</code> </td>
<td style="text-align: left;"> assign marks to a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.linnet</code> </td>
<td style="text-align: left;"> plot a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.owin.linnet</code> </td>
<td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.psp.linnet</code> </td>
<td style="text-align: left;"> extract line segments comprising
    network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nsegments.linnet</code> </td>
<td style="text-align: left;"> number of segments in network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nvertices.linnet</code> </td>
<td style="text-align: left;"> number of vertices in network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pixellate.linnet</code> </td>
<td style="text-align: left;"> convert network to 2D pixel
    image </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>print.linnet</code> </td>
<td style="text-align: left;"> print basic information </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary.linnet</code> </td>
<td style="text-align: left;"> print summary information </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>unitname.linnet</code> </td>
<td style="text-align: left;"> extract name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>unitname&lt;-.linnet</code> </td>
<td style="text-align: left;"> assign name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vertexdegree</code> </td>
<td style="text-align: left;"> number of segments meeting
    each vertex </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>volume.linnet</code> </td>
<td style="text-align: left;"> total length of network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Window.linnet</code> </td>
<td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>density.linnet</code> </td>
<td style="text-align: left;"> smoothed 2D spatial density of lines </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>A network is called a tree if it has no closed loops.
The following functions support the creation and manipulation of
trees:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>begins</code>
</td>
<td style="text-align: left;"> check start of character string</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>branchlabelfun</code>
</td>
<td style="text-align: left;"> tree branch membership labelling
    function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>deletebranch</code>
</td>
<td style="text-align: left;"> delete a branch of a tree </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>extractbranch</code>
</td>
<td style="text-align: left;"> extract a branch of a tree </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>treebranchlabels</code>
</td>
<td style="text-align: left;"> label vertices of a tree by
    branch membership </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>treeprune</code>
</td>
<td style="text-align: left;"> prune tree to given level</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p><b>Point patterns on a linear network</b>
</p>
<p>An object of class <code>"lpp"</code> represents a 
point pattern on a linear network (for example,
road accidents on a road network). 
</p>
<p>Examples of such objects include the following datasets
provided in the <span class="pkg">spatstat.data</span> package:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>chicago</code> </td>
<td style="text-align: left;"> Chicago crime data </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dendrite</code> </td>
<td style="text-align: left;"> Dendritic spines data </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>spiders</code> </td>
<td style="text-align: left;"> Spider webs on mortar lines of brick wall 
    </td>
</tr>
</table>
<p>There is also a dataset provided in the extension package
<span class="pkg">spatstat.Knet</span>:
</p>

<table><tr>
<td style="text-align: left;">
      <code>wacrashes</code> </td>
<td style="text-align: left;"> Road accidents in Western Australia
    </td>
</tr></table>
<p>Point patterns on a network can be created by the following
functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>lpp</code> </td>
<td style="text-align: left;"> create a point pattern on a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.lpp</code> </td>
<td style="text-align: left;"> convert other data to point pattern on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>clicklpp</code>
</td>
<td style="text-align: left;"> interactively add points on a linear
      Network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>crossing.linnet</code>
</td>
<td style="text-align: left;"> crossing points between network and other lines
    </td>
</tr>
</table>
<p>Point patterns on a network can be generated randomly
using the following functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>rpoislpp</code> </td>
<td style="text-align: left;"> Poisson points on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>runiflpp</code> </td>
<td style="text-align: left;"> uniform random points on a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rlpp</code>
</td>
<td style="text-align: left;"> random points on a linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rSwitzerlpp</code>
</td>
<td style="text-align: left;"> simulate Switzer-type point process on linear
      network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rThomaslpp</code>
</td>
<td style="text-align: left;"> simulate Thomas process on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rcelllpp</code>
</td>
<td style="text-align: left;">  simulate cell process on linear
      network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rjitter.lpp</code>
</td>
<td style="text-align: left;"> randomly perturb a point pattern on
      a network </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p>Functions for manipulating a point pattern on a network include
the following. An object of class <code>"lpp"</code> also belongs to the
class <code>"ppx"</code>, for which additional support is available.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>as.ppp.lpp</code> </td>
<td style="text-align: left;"> convert to 2D point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.psp.lpp</code> </td>
<td style="text-align: left;"> extract line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks.ppx</code> </td>
<td style="text-align: left;"> extract marks associated with points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks&lt;-.ppx</code> </td>
<td style="text-align: left;"> assign marks to points on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nsegments.lpp</code> </td>
<td style="text-align: left;"> count number of segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>print.lpp</code> </td>
<td style="text-align: left;"> print basic information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>summary.lpp</code> </td>
<td style="text-align: left;"> print summary information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unitname.lpp</code> </td>
<td style="text-align: left;"> extract name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unitname&lt;-.lpp</code> </td>
<td style="text-align: left;"> assign name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unmark.lpp</code> </td>
<td style="text-align: left;"> remove marks </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.lpp</code> </td>
<td style="text-align: left;"> subset of points satisfying a
      condition </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[.lpp</code> </td>
<td style="text-align: left;"> extract subset of point pattern</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>Window.lpp</code> </td>
<td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.owin.lpp</code> </td>
<td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>affine.lpp</code> </td>
<td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shift.lpp</code> </td>
<td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rotate.lpp</code> </td>
<td style="text-align: left;"> apply rotation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rescale.lpp</code> </td>
<td style="text-align: left;"> rescale the unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>scalardilate.lpp</code> </td>
<td style="text-align: left;"> physically rescale the
      network and points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>connected.lpp</code>
</td>
<td style="text-align: left;"> find connected components of point
      pattern on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>cut.lpp</code>
</td>
<td style="text-align: left;"> classify points in a Point Pattern on a
      Network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>distfun.lpp</code>
</td>
<td style="text-align: left;"> distance map (function) </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>distmap.lpp</code>
</td>
<td style="text-align: left;"> distance map (image) </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>domain.lpp</code>
</td>
<td style="text-align: left;">  extract the linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>identify.lpp</code>
</td>
<td style="text-align: left;"> interactively identify points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>is.multitype.lpp</code>
</td>
<td style="text-align: left;"> recognize whether point pattern is
      multitype</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nncross.lpp</code>
</td>
<td style="text-align: left;"> nearest neighbours</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nndist.lpp</code>
</td>
<td style="text-align: left;">  nearest neighbour distances </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nnfromvertex</code>
</td>
<td style="text-align: left;"> nearest data point from each vertex</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nnfun.lpp</code>
</td>
<td style="text-align: left;">  nearest neighbour map </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nnwhich.lpp</code>
</td>
<td style="text-align: left;">  identify nearest neighbours </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>pairdist.lpp</code>
</td>
<td style="text-align: left;"> pairwise shortest-path distances </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.lpp</code>
</td>
<td style="text-align: left;"> plot point pattern on linear Network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>points.lpp</code>
</td>
<td style="text-align: left;"> draw points on existing plot </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>superimpose.lpp</code>
</td>
<td style="text-align: left;">  superimpose several point
      patterns </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>text.lpp</code> </td>
<td style="text-align: left;"> add text labels  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unstack.lpp</code>
</td>
<td style="text-align: left;"> separate multiple columns of marks </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p><b>Pixel images on a network</b>
</p>
<p>An object of class <code>"linim"</code> represents a pixel image
on a linear network. Effectively, the network is divided into small
segments (lixels) and each small segment is assigned a value,
which could be numeric, factor, logical or complex values.
</p>
<p>Pixel images on a network can be created using the following
functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>linim</code>
</td>
<td style="text-align: left;"> create pixel image on linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.linim</code>
</td>
<td style="text-align: left;"> convert other data to pixel image on network</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p>Functions for manipulating a pixel image on a network include:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>[.linim</code> </td>
<td style="text-align: left;"> extract subset of pixel image on linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[&lt;-.linim</code> </td>
<td style="text-align: left;"> reset values in subset of image on linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>Math.linim</code>
</td>
<td style="text-align: left;"> S3 group generic methods for images on a linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>eval.linim</code>
</td>
<td style="text-align: left;"> evaluate expression involving pixel images on
      linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.linnet.linim</code> </td>
<td style="text-align: left;"> extract linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>integral.linim</code>
</td>
<td style="text-align: left;"> integral of pixel image on a linear network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>mean.linim</code> </td>
<td style="text-align: left;"> mean of pixel values </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>median.linim</code> </td>
<td style="text-align: left;"> median of pixel values </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>quantile.linim</code> </td>
<td style="text-align: left;"> quantiles of pixel values </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.data.frame.linim</code> </td>
<td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>print.linim</code> </td>
<td style="text-align: left;"> print basic information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>summary.linim</code> </td>
<td style="text-align: left;"> print summary information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>affine.linim</code> </td>
<td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>scalardilate.linim</code> </td>
<td style="text-align: left;"> apply scalar dilation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shift.linim</code> </td>
<td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>pairs.linim</code> </td>
<td style="text-align: left;"> scatterplot matrix for images </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>persp.linim</code>
</td>
<td style="text-align: left;"> perspective view of pixel image on network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.linim</code>
</td>
<td style="text-align: left;"> plot pixel image on linear network</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p><b>Functions on a linear network</b>
</p>
<p>An object of class <code>"linfun"</code> represents a function defined
at any location along the network. Objects of this class are created
by the following functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>linfun</code>
</td>
<td style="text-align: left;"> create function on a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.linfun</code>
</td>
<td style="text-align: left;"> convert other data to function on network </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p>The following supporting code is available:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>print.linfun</code> </td>
<td style="text-align: left;"> print basic information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>summary.linfun</code> </td>
<td style="text-align: left;"> print summary information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.linfun</code> </td>
<td style="text-align: left;"> plot function on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>persp.linfun</code>
</td>
<td style="text-align: left;"> perspective view of function on network</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.data.frame.linfun</code> </td>
<td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.owin.linfun</code> </td>
<td style="text-align: left;"> extract window containing
      network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.function.linfun</code> </td>
<td style="text-align: left;"> convert to ordinary <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
      function </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p><b>Tessellations of a linear network</b>
</p>
<p>An object of class <code>"lintess"</code> represents a tessellation of the
network, that is, a subdivision of the network into disjoint subsets
called ‘tiles’. Objects of this class are created
by the following functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>lintess</code>
</td>
<td style="text-align: left;"> create tessellation of network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>chop.linnet</code> </td>
<td style="text-align: left;"> divide a linear network into tiles using
      infinite lines </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>divide.linnet</code>
</td>
<td style="text-align: left;">  divide linear network at cut
      points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>lineardirichlet</code>
</td>
<td style="text-align: left;"> Dirichlet tessellation on a linear network</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p>The following functions are provided for manipulating a tessellation
on a network:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>as.data.frame.lintess</code>
</td>
<td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>intersect.lintess</code>
</td>
<td style="text-align: left;"> intersection of two
      tessellations on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>lineartileindex</code>
</td>
<td style="text-align: left;"> determine which tile contains each
      given point on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks.lintess</code>
</td>
<td style="text-align: left;"> extract marks of each tile </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks&lt;-.lintess</code>
</td>
<td style="text-align: left;"> assign marks to each tile </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.lintess</code>
</td>
<td style="text-align: left;"> plot tessellation on network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tile.lengths</code>
</td>
<td style="text-align: left;"> compute lengths of tiles </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tilenames.lintess</code>
</td>
<td style="text-align: left;">  names of tiles </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.linfun.lintess</code>
</td>
<td style="text-align: left;"> convert tessellation to a
      function </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<p><b>Smoothing a point pattern on a linear network:</b>
</p>
<p>Given a point pattern dataset on a linear network, it is often
desired to estimate the spatially-varying density or intensity
of points along the network. For example if the points represent
road accidents, then we may wish to estimate the spatially-varying
density of accidents per unit length (over a given period of time).
</p>
<p>Related tasks include estimation of relative risk, and smoothing of
of values observed at the data points.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>density.lpp</code>
</td>
<td style="text-align: left;"> kernel estimate of intensity</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityEqualSplit</code>
</td>
<td style="text-align: left;"> kernel estimate of intensity
    using equal-split algorithm </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityHeat.lpp</code>
</td>
<td style="text-align: left;"> kernel estimate of intensity using heat equation</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityQuick.lpp</code>
</td>
<td style="text-align: left;"> kernel estimate of intensity using a 2D kernel</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityVoronoi.lpp</code>
</td>
<td style="text-align: left;"> intensity estimate using
    Voronoi-Dirichlet Tessellation</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityfun.lpp</code>
</td>
<td style="text-align: left;"> kernel estimate of intensity as a
    function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.lppl</code>
</td>
<td style="text-align: left;"> Bandwidth selection for kernel estimate of
    intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.voronoi</code>
</td>
<td style="text-align: left;"> bandwidth selection for Voronoi estimator </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>relrisk.lpp</code>
</td>
<td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.relrisk.lpp</code>
</td>
<td style="text-align: left;">  Bandwidth selection for relative
    risk </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Smooth.lpp</code>
</td>
<td style="text-align: left;"> spatial smoothing of observations at
    points </td>
</tr>
<tr>
<td style="text-align: left;">

  </td>
</tr>
</table>
<p><b>Exploration of dependence on a covariate:</b>
</p>
<p>Another task is to investigate how the spatially-varying intensity
of points depends on an explanatory variable (covariate). The
covariate may be given as a pixel image on the network
(class <code>"linim"</code>) or
as a function on the network (class <code>"linfun"</code>).
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>rhohat.lpp</code>
</td>
<td style="text-align: left;"> nonparametric estimate of intensity as function
    of a covariate</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>roc.lpp</code>
</td>
<td style="text-align: left;"> Receiver Operating Characteristic for data on a
    network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>auc.lpp</code>
</td>
<td style="text-align: left;">  Area Under ROC Curve for data on a network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>cdf.test.lpp</code>
</td>
<td style="text-align: left;"> spatial distribution test for points on a
    linear network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>berman.test.lpp</code>
</td>
<td style="text-align: left;"> Berman's tests for point pattern
    on a network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>sdr.lpp</code>
</td>
<td style="text-align: left;"> Sufficient Dimension Reduction for a point
    pattern on a linear network</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p><b>Summary statistics for a point pattern on a linear network:</b>
</p>
<p>These are for point patterns on a linear network (class <code>lpp</code>).
For unmarked patterns:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>linearK</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKinhom</code> </td>
<td style="text-align: left;">
    inhomogeneous <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcf</code> </td>
<td style="text-align: left;">
    pair correlation function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfinhom</code> </td>
<td style="text-align: left;">
    inhomogeneous pair correlation on linear network</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearJinhom</code> </td>
<td style="text-align: left;">
    inhomogeneous <code class="reqn">J</code> function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKEuclid</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function on linear network using Euclidean distance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKEuclidInhom</code> </td>
<td style="text-align: left;">
    inhomogeneous <code class="reqn">K</code> function on linear network using Euclidean distance</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfEuclid</code> </td>
<td style="text-align: left;">
    pair correlation function on linear network using Euclidean distance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfEuclidInhom</code> </td>
<td style="text-align: left;">
    inhomogeneous pair correlation on linear network using Euclidean
    distance </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>For multitype patterns:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>linearKcross</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function between two types of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKdot</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function from one type to any type </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKcross.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearKcross</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKdot.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearKdot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearmarkconnect</code> </td>
<td style="text-align: left;">
    Mark connection function  on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearmarkequal</code> </td>
<td style="text-align: left;">
    Mark equality function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfcross</code> </td>
<td style="text-align: left;">
    Pair correlation between two types of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfdot</code> </td>
<td style="text-align: left;">
    Pair correlation from one type to any type </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfcross.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearpcfcross</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfdot.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearpcfdot</code> 
  </td>
</tr>
</table>
<p>Related facilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>pairdist.lpp</code> </td>
<td style="text-align: left;"> distances between pairs  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>crossdist.lpp</code> </td>
<td style="text-align: left;"> distances between pairs </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nndist.lpp</code> </td>
<td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nncross.lpp</code> </td>
<td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnwhich.lpp</code> </td>
<td style="text-align: left;"> find nearest neighbours  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnfun.lpp</code> </td>
<td style="text-align: left;"> find nearest data point  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>density.lpp</code> </td>
<td style="text-align: left;"> kernel smoothing estimator of intensity  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>distfun.lpp</code> </td>
<td style="text-align: left;"> distance transform  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope.lpp</code> </td>
<td style="text-align: left;"> simulation envelopes  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rpoislpp</code> </td>
<td style="text-align: left;"> simulate Poisson points on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>runiflpp</code> </td>
<td style="text-align: left;"> simulate random points on a linear network 
  </td>
</tr>
</table>
<p>It is also possible to fit point process models to <code>lpp</code> objects.
</p>
<p><b>Point process models on a linear network:</b>
</p>
<p>An object of class <code>"lpp"</code> represents a pattern of points on
a linear network. Point process models can also be fitted to these
objects. Currently only Poisson models can be fitted.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>lppm</code> </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>anova.lppm</code> </td>
<td style="text-align: left;"> analysis of deviance for </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope.lppm</code> </td>
<td style="text-align: left;"> simulation envelopes for </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.lppm</code> </td>
<td style="text-align: left;"> fitted intensity values </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.lppm</code> </td>
<td style="text-align: left;"> model prediction on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>data.lppm</code> </td>
<td style="text-align: left;"> extract original data </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>berman.test.lppm</code> </td>
<td style="text-align: left;"> Berman's tests of
    goodness-of-fit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.marked.lppm</code>
</td>
<td style="text-align: left;"> Recognise whether model is marked</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.multitype.lppm</code>
</td>
<td style="text-align: left;"> Recognise whether model is multitype</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.stationary.lppm</code>
</td>
<td style="text-align: left;"> Recognise whether model is
    stationary </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.frame.lppm</code>
</td>
<td style="text-align: left;"> Extract the variables in model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.images.lppm</code>
</td>
<td style="text-align: left;"> Compute images of constructed covariates </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.matrix.lppm</code>
</td>
<td style="text-align: left;"> Extract design matrix </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.lppm</code>
</td>
<td style="text-align: left;"> Plot fitted point process model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pseudoR2.lppm</code>
</td>
<td style="text-align: left;"> Calculate Pseudo-R-Squared for model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.lppm</code>
</td>
<td style="text-align: left;"> simulate fitted point process model </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the "GNU 
General Public License", a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Ottmar Cronie,
Tilman Davies,
Greg McSwiggan and
Suman Rakshit
made substantial contributions of code.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


</div>