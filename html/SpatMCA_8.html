<div class="container">

<table style="width: 100%;"><tr>
<td>spatmca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized spatial MCA</h2>

<h3>Description</h3>

<p>Produce spatial coupled patterns at the designated locations according to the specified tuning parameters or the tuning parameters selected by M-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatmca(
  x1,
  x2,
  Y1,
  Y2,
  M = 5,
  K = NULL,
  is_K_selected = ifelse(is.null(K), TRUE, FALSE),
  tau1u = NULL,
  tau2u = NULL,
  tau1v = NULL,
  tau2v = NULL,
  x1New = NULL,
  x2New = NULL,
  center = TRUE,
  maxit = 100,
  thr = 1e-04,
  are_all_tuning_parameters_selected = FALSE,
  num_cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>Location matrix (<code class="reqn">p \times d</code>) corresponding to Y1. Each row is a location. <code class="reqn">d=1,2</code> is the dimension of locations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>Location matrix (<code class="reqn">q \times d</code>) corresponding to Y2. Each row is a location.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y1</code></td>
<td>
<p>Data matrix (<code class="reqn">n \times p</code>) of the first variable stores the values at <code class="reqn">p</code> locations with sample size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y2</code></td>
<td>
<p>Data matrix (<code class="reqn">n \times q</code>) of the second variable stores the values at <code class="reqn">q</code> locations with sample size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Optional number of folds; default is 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Optional user-supplied number of coupled patterns; default is NULL. If K is NULL or is_K_selected is TRUE, K is selected automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_K_selected</code></td>
<td>
<p>If TRUE, K is selected automatically; otherwise, is_K_selected is set to be user-supplied K. Default depends on user-supplied K.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1u</code></td>
<td>
<p>Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence corresponding to Y1. If NULL, 10 tau1u values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2u</code></td>
<td>
<p>Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence corresponding to Y1. If NULL, 10 tau2u values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1v</code></td>
<td>
<p>Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence corresponding to Y2. If NULL, 10 tau1v values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2v</code></td>
<td>
<p>Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence corresponding to Y2. If NULL, 10 tau2v values in a range are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1New</code></td>
<td>
<p>New location matrix corresponding to Y1. If NULL, it is x1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2New</code></td>
<td>
<p>New location matrix corresponding to Y2. If NULL, it is x2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>If TRUE, center the columns of Y. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations. Default value is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr</code></td>
<td>
<p>Threshold for convergence. Default value is <code class="reqn">10^{-4}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>are_all_tuning_parameters_selected</code></td>
<td>
<p>If TRUE, the K-fold CV performs to select 4 tuning parameters simultaneously. Default value is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_cores</code></td>
<td>
<p>Number of cores used to parallel computing. Default value is NULL (See <code>RcppParallel::defaultNumThreads()</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The optimization problem is
</p>
<p style="text-align: center;"><code class="reqn">\max_{\mathbf{U}, \mathbf{V}} \frac{1}{n}\mbox{tr}(\mathbf{U}'\mathbf{Y}'_1\mathbf{Y}_2\mathbf{V}) - \tau_{1u}\mbox{tr}(\mathbf{U}'\mathbf{\Omega}_1\mathbf{U}) - \tau_{2u}\sum_{k=1}^K\sum_{j=1}^{p} |u_{jk}|- \tau_{1v}\mbox{tr}(\mathbf{V}'\mathbf{\Omega}_2\mathbf{V})-\tau_{2v}\sum_{k=1}^K\sum_{j=1}^{q} |v_{jk}|,</code>
</p>

<p><code class="reqn">\mbox{subject to $ \mathbf{U}'\mathbf{U}=\mathbf{V}'\mathbf{V}=\mathbf{I}_K$,}</code> where <code class="reqn">\mathbf{Y}_1</code> and <code class="reqn">\mathbf{Y}_2</code> are two data matrices, <code class="reqn">{\mathbf{\Omega}}_1</code> and <code class="reqn">{\mathbf{\Omega}}_2</code> are two smoothness matrix, <code class="reqn">\mathbf{V}=\{v_{jk}\}</code>, and <code class="reqn">\mathbf{U}=\{u_{jk}\}</code>.
</p>


<h3>Value</h3>

<p>A list of objects including
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Uestfn</code></td>
<td>
<p>Estimated patterns for Y1 at the new locations, x1New.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vestfn</code></td>
<td>
<p>Estimated patterns for Y2 at the new locations, x2New.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dest</code></td>
<td>
<p>Estimated singular values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crosscov</code></td>
<td>
<p>Estimated cross-covariance matrix between Y1 and Y2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stau1u</code></td>
<td>
<p>Selected tau1u.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stau2u</code></td>
<td>
<p>Selected tau2u.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stau1v</code></td>
<td>
<p>Selected tau1v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stau2v</code></td>
<td>
<p>Selected tau2v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv1</code></td>
<td>
<p>cv scores for tau1u and tau1v when are_all_tuning_parameters_selected is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv2</code></td>
<td>
<p>cv scores for tau2u and tau2v when are_all_tuning_parameters_selected is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvall</code></td>
<td>
<p>cv scores for tau1u, tau2u, tau1v and tau2v when are_all_tuning_parameters_selected is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1u</code></td>
<td>
<p>Sequence of tau1u-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2u</code></td>
<td>
<p>Sequence of tau2u-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau1v</code></td>
<td>
<p>Sequence of tau1v-values used in the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2v</code></td>
<td>
<p>Sequence of tau2v-values used in the process.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Wen-Ting Wang and Hsin-Cheng Huang
</p>


<h3>References</h3>

<p>Wang, W.-T. and Huang, H.-C. (2017). Regularized principal component analysis for spatial data. <em>Journal of Computational and Graphical Statistics</em> <b>26</b> 14-25.
</p>


<h3>Examples</h3>

<pre><code class="language-R">originalPar &lt;- par(no.readonly = TRUE)
# The following examples only use two threads for parallel computing.
## 1D: regular locations
p &lt;- q &lt;- 10
n &lt;- 100
x1 &lt;- matrix(seq(-7, 7, length = p), nrow = p, ncol = 1)
x2 &lt;- matrix(seq(-7, 7, length = q), nrow = q, ncol = 1)
u &lt;- exp(-x1^2) / norm(exp(-x1^2), "F")
v &lt;- exp(-(x2 - 2)^2) / norm(exp(-(x2 - 2)^2), "F")
Sigma &lt;- array(0, c(p + q, p + q))
Sigma[1:p, 1:p] &lt;- diag(p)
Sigma[(p + 1):(p + q), (p + 1):(p + q)] &lt;- diag(p)
Sigma[1:p, (p + 1):(p + q)] &lt;- u %*% t(v)
Sigma[(p + 1):(p + q), 1:p] &lt;- t(Sigma[1:p, (p + 1):(p + q)])
noise &lt;- MASS::mvrnorm(n, mu = rep(0, p + q), Sigma = 0.001 * diag(p + q))
Y &lt;- MASS::mvrnorm(n, mu = rep(0, p + q), Sigma = Sigma) + noise
Y1 &lt;- Y[, 1:p]
Y2 &lt;- Y[, -(1:p)]
cv1 &lt;- spatmca(x1, x2, Y1, Y2, num_cores = 2)

par(mfrow = c(2, 1))
plot(x1, cv1$Uestfn[, 1], type='l', main = "1st pattern for Y1")
plot(x1, cv1$Vestfn[, 1], type='l', main = "1st pattern for Y2")
## Avoid changing the global enviroment
par(originalPar)


# The following examples will be executed more than 5 secs or including other libraries.
## 1D: artificial irregular locations
rmLoc1 &lt;- sample(1:p, 3)
rmLoc2 &lt;- sample(1:q, 4)
x1Rm &lt;- x1[-rmLoc1]
x2Rm &lt;- x2[-rmLoc2]
Y1Rm &lt;- Y1[, -rmLoc1]
Y2Rm &lt;- Y2[, -rmLoc2]
x1New &lt;- as.matrix(seq(-7, 7, length = 100))
x2New &lt;- as.matrix(seq(-7, 7, length = 50))
cv2 &lt;- spatmca(x1 = x1Rm,
               x2 = x2Rm,
               Y1 = Y1Rm,
               Y2 = Y2Rm,
               x1New = x1New,
               x2New = x2New)
par(mfrow = c(2, 1))
plot(x1New, cv2$Uestfn[,1], type='l', main = "1st pattern for Y1")
plot(x2New, cv2$Vestfn[,1], type='l', main = "1st pattern for Y2")
par(originalPar)

## 2D real data
##  Daily 8-hour ozone averages and maximum temperature obtained from 28 monitoring
##  sites of NewYork, USA. It is of interest to see the relationship between the ozone
##  and the temperature through the coupled patterns.

library(spTimer)
library(pracma)
library(fields)
library(maps)
data(NYdata)
NYsite &lt;- unique(cbind(NYdata[, 1:3]))
date &lt;- as.POSIXct(seq(as.Date("2006-07-01"), as.Date("2006-08-31"), by = 1))
cMAXTMP&lt;- matrix(NYdata[,8], 62, 28)
oz &lt;- matrix(NYdata[,7], 62, 28)
rmNa &lt;- !colSums(is.na(oz))
temp &lt;- detrend(matrix(cMAXTMP[, rmNa], nrow = nrow(cMAXTMP)), "linear")
ozone &lt;- detrend(matrix(oz[, rmNa], nrow = nrow(oz)), "linear")
x1 &lt;- NYsite[rmNa, 2:3]
cv &lt;- spatmca(x1, x1, temp, ozone)
par(mfrow = c(2, 1))
quilt.plot(x1, cv$Uestfn[, 1],
           xlab = "longitude",
           ylab = "latitude",
           main = "1st spatial pattern for temperature")
map(database = "state", regions = "new york", add = TRUE)
quilt.plot(x1, cv$Vestfn[, 1],
           xlab = "longitude",
           ylab = "latitude",
           main = "1st spatial pattern for ozone")
map(database = "state", regions = "new york", add = TRUE)
par(originalPar)

### Time series for the coupled patterns
tstemp &lt;- temp %*% cv$Uestfn[,1]
tsozone &lt;- ozone %*% cv$Vestfn[,1]
corr &lt;- cor(tstemp, tsozone)
plot(date, tstemp / sd(tstemp), type='l', main = "Time series", ylab = "", xlab = "month")
lines(date, tsozone/sd(tsozone),col=2)
legend("bottomleft", c("Temperature (standardized)", "Ozone (standardized)"), col = 1:2, lty = 1:1)
mtext(paste("Pearson's correlation = ", round(corr, 3)), 3)

newP &lt;- 50
xLon &lt;- seq(-80, -72, length = newP)
xLat &lt;- seq(41, 45, length = newP)
xxNew &lt;- as.matrix(expand.grid(x = xLon, y = xLat))
cvNew &lt;- spatmca(x1 = x1,
                 x2 = x1,
                 Y1 = temp,
                 Y2 = ozone,
                 K = cv$Khat,
                 tau1u = cv$stau1u,
                 tau1v = cv$stau1v,
                 tau2u = cv$stau2u,
                 tau2v = cv$stau2v,
                 x1New = xxNew,
                 x2New = xxNew)
par(mfrow = c(2, 1))
quilt.plot(xxNew, cvNew$Uestfn[, 1],
           nx = newP,
           ny = newP,
           xlab = "longitude",
           ylab = "latitude",
           main = "1st spatial pattern for temperature")
map(database = "county", regions = "new york", add = TRUE)
map.text("state", regions = "new york", cex = 2, add = TRUE)
quilt.plot(xxNew, cvNew$Vestfn[, 1],
           nx = newP,
           ny = newP,
           xlab = "longitude",
           ylab = "latitude",
           main = "2nd spatial pattern for ozone")
map(database = "county", regions = "new york", add = TRUE)
map.text("state", regions = "new york", cex = 2, add = TRUE)
par(originalPar)

## 3D: regular locations
n &lt;- 200
x &lt;- y &lt;- z &lt;- as.matrix(seq(-7, 7, length = 8))
d &lt;- expand.grid(x, y, z)
u3D &lt;- v3D &lt;- exp(-d[, 1]^2 - d[, 2]^2 -d[, 3]^2)
p &lt;- q &lt;- 8^3
Sigma3D &lt;- array(0, c(p + q, p + q))
Sigma3D[1:p, 1:p] &lt;- diag(p)
Sigma3D[(p + 1):(p + q), (p + 1):(p + q)] &lt;- diag(p)
Sigma3D[1:p, (p + 1):(p + q)] &lt;- u3D %*% t(v3D)
Sigma3D[(p + 1):(p + q), 1:p] &lt;- t(Sigma3D[1:p, (p + 1):(p + q)])

noise3D &lt;- MASS::mvrnorm(n, mu = rep(0, p + q), Sigma = 0.001 * diag(p + q))
Y3D &lt;- MASS::mvrnorm(n, mu = rep(0, p + q), Sigma = Sigma3D) + noise3D
Y13D &lt;- Y3D[, 1:p]
Y23D &lt;- Y3D[, -(1:p)]
cv3D &lt;- spatmca(d, d, Y13D, Y23D)

library(plot3D)
library(RColorBrewer)
cols &lt;- colorRampPalette(brewer.pal(9, 'Blues'))(10)
isosurf3D(x, y, z,
          colvar = array(cv3D$Uestfn[, 1], c(8, 8, 8)),
          level = seq(min(cv3D$Uestfn[, 1]), max(cv3D$Uestfn[, 1]), length = 10),
          ticktype = "detailed",
          colkey = list(side = 1),
          col = cols,
          main = "1st estimated pattern for Y1")

isosurf3D(x, y, z,
          colvar = array(cv3D$Vestfn[, 1], c(8, 8, 8)),
          level = seq(min(cv3D$Vestfn[, 1]), max(cv3D$Vestfn[,1]), length = 10),
          ticktype = "detailed",
          colkey = list(side = 1),
          col = cols,
          main = "1st estimated pattern for Y2")

</code></pre>


</div>