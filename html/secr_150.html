<div class="container">

<table style="width: 100%;"><tr>
<td>join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Combine or Split Sessions of capthist Object </h2>

<h3>Description</h3>

<p> Make a single-session capthist object from a list of
single-session objects, or a multi-session capthist object.  </p>


<h3>Usage</h3>

<pre><code class="language-R"> 

join(object, remove.dupl.sites = TRUE, tol = 0.001, sites.by.name = FALSE,
    drop.sites = FALSE, intervals = NULL, sessionlabels = NULL, 
    timevaryingcov = NULL) 
    
unjoin(object, intervals, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>list of single-session objects, or a multi-session
capthist object [<code>join</code>], or a single-session capthist object [<code>unjoin</code>]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.dupl.sites</code></td>
<td>
<p> logical; if TRUE then a single record is
retained for each trap site used in multiple input sessions </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> absolute distance in metres within which sites are
considered identical </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sites.by.name</code></td>
<td>
<p> logical; if TRUE and <code>remove.dupl.sites</code> then duplicate sites are inferred from row names rather than x-y coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.sites</code></td>
<td>
<p>logical; if TRUE then site information is discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intervals</code></td>
<td>
<p> vector of times between sessions (join) or occasions (unjoin; zero indicates same session) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sessionlabels</code></td>
<td>
<p> vector of session names </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timevaryingcov</code></td>
<td>
<p> character vector of covariate names </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> other arguments passed to <code>subset.capthist</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt><code>join</code></dt>
<dd>
<p>The input sessions are assumed to be of the same detector type and to
have the same attributes (e.g., covariates should be present for all
or none).
</p>
<p>The number of occasions (columns) in the output is equal to the sum of
the number of occasions in each input.
</p>
<p>Duplicates may be defined either as sites within a given distance (<code>tol</code>) or sites with the same name (<code>sites.by.name = TRUE</code>). Using site names is faster.
</p>
<p>For non-spatial analyses it is efficient to drop the third dimension and discard the traps attribute (<code>drop.sites = TRUE</code>).
</p>
<p>A new dataframe of individual covariates is formed using the covariates
for the first occurrence of each animal. 
</p>
<p>If <code>timevaryingcov</code> is given then for each name a new covariate is generated for each session and populated with values observed in that session, or NA if the animal was not detected. A ‘timevaryingcov’ (list) attribute is created that associates each set of new session-specific columns with the corresponding old name, so that it may be used in formulae (see <code>timevaryingcov</code>).
</p>
<p>Attributes xy and signal are handled appropriately, as is trap usage.
</p>
</dd>
<dt><code>unjoin</code></dt>
<dd>
<p>The input grouping of occasions (columns) into sessions is specified via
<code>intervals</code>. This is a vector of length one less than the number of
occasions (columns) in <code>object</code>. Elements greater than zero
indicate a new session.
</p>
<p>The <code>intervals</code> argument may be omitted if <code>object</code> has a
valid ‘intervals’ attribute, as in the output from <code>join</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>For <code>join</code>, a single-session capthist object. The vector attribute ‘intervals’ records the
distinction between occasions that are adjacent in the input (interval =
0) and those that are in consecutive sessions (e.g., interval = 1); ‘intervals’
has length one less than the number of occasions.
</p>
<p>For <code>unjoin</code>, a multi-session capthist object. Sessions are named
with integers.
</p>


<h3>Note</h3>

<p>Do not confuse <code>unjoin</code> with <code>split.capthist</code> which
splits by row (animal) rather than by column (occasion).
</p>
<p>Occasions survive intact; to pool occasions use
<code>reduce.capthist</code>.
</p>
<p><code>join</code> was modified in version 2.9.5 to check whether the
components of ‘object’ all used the same detectors (‘traps’) (putting
aside differences in usage). If the traps are identical and
remove.dupl.sites = TRUE then the resulting ‘capthist’ uses the common list of
detectors, with a usage attribute formed by concatenating the usage
columns of the input. This is faster than the previous filtering
algorithm using ‘tol’; the older algorithm is still used if the traps differ. 
</p>
<p>Problems may be encountered with large datasets. These may be alleviated by setting sites.by.name = TRUE (if matching sites have matching names, avoiding the need for coordinate matching) or drop.sites = TRUE (if only non-spatial data are required for openCR).
</p>


<h3>See Also</h3>

<p><code>MS.capthist</code>, <code>rbind.capthist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
joined.ovenCH &lt;- join (ovenCH)
summary(joined.ovenCH)
attr(joined.ovenCH, "intervals")

summary(unjoin(joined.ovenCH))

## Not run: 

## suppose the 5-year ovenbird covariates include a column for weight
## (here generated as random numbers)
for (i in 1:5) covariates(ovenCH[[i]])$wt &lt;- runif(nrow(ovenCH[[i]]))
## construct single-session version of data for openCR
## identify 'wt' as varying across years
ovenCHj &lt;- join(ovenCH, timevaryingcov = 'wt')
head(covariates(ovenCHj))
timevaryingcov(ovenCHj)
## Use example: openCR.fit(ovenCHj, model = p~wt)


## End(Not run)


</code></pre>


</div>