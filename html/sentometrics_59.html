<div class="container">

<table style="width: 100%;"><tr>
<td>sento_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimized and automated sentiment-based sparse regression</h2>

<h3>Description</h3>

<p>Linear or nonlinear penalized regression of any dependent variable on the wide number of sentiment measures and
potentially other explanatory variables. Either performs a regression given the provided variables at once, or computes
regressions sequentially for a given sample size over a longer time horizon, with associated prediction performance metrics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sento_model(sento_measures, y, x = NULL, ctr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sento_measures</code></td>
<td>
<p>a <code>sento_measures</code> object created using <code>sento_measures</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a one-column <code>data.frame</code> or a <code>numeric</code> vector capturing the dependent (response) variable. In case of
a logistic regression, the response variable is either a <code>factor</code> or a <code>matrix</code> with the factors represented by
the columns as binary indicators, with the second factor level or column as the reference class in case of a binomial
regression. No <code>NA</code> values are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a named <code>data.table</code>, <code>data.frame</code> or <code>matrix</code> with other explanatory variables as <code>numeric</code>, by
default set to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctr</code></td>
<td>
<p>output from a <code>ctr_model</code> call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Models are computed using the elastic net regularization as implemented in the <span class="pkg">glmnet</span> package, to account for
the multidimensionality of the sentiment measures. Independent variables are normalized in the regression process, but
coefficients are returned in their original space. For a helpful introduction to <span class="pkg">glmnet</span>, we refer to their
<a href="https://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html#lin">vignette</a>. The optimal elastic net parameters
<code>lambda</code> and <code>alpha</code> are calibrated either through a to specify information criterion or through
cross-validation (based on the "rolling forecasting origin" principle, using the <code>train</code> function).
In the latter case, the training metric is automatically set to <code>"RMSE"</code> for a linear model and to <code>"Accuracy"</code>
for a logistic model. We suppress many of the details that can be supplied to the <code>glmnet</code> and
<code>train</code> functions we rely on, for the sake of user-friendliness.
</p>


<h3>Value</h3>

<p>If <code>ctr$do.iter = FALSE</code>, a <code>sento_model</code> object which is a <code>list</code> containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>
<p>optimized regression, i.e., a model-specific <span class="pkg">glmnet</span> object, including for example the estimated
coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the input argument <code>ctr$model</code>, to indicate the type of model estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>calibrated alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>calibrated lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trained</code></td>
<td>
<p>output from <code>train</code> call (if <code>ctr$type =</code> "<code>cv</code>"). There is no such
output if the control parameters <code>alphas</code> and <code>lambdas</code> both specify one value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>a <code>list</code> composed of two elements: under <code>"criterion"</code>, the type of information criterion used in the
calibration, and under <code>"matrix"</code>, a <code>matrix</code> of all information criterion values for <code>alphas</code> as rows
and the respective lambda values as columns (if <code>ctr$type != </code> "<code>cv</code>"). Any <code>NA</code> value in the latter
element means the specific information criterion could not be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dates</code></td>
<td>
<p>sample reference dates as a two-element <code>character</code> vector, being the earliest and most recent date from
the <code>sento_measures</code> object accounted for in the estimation window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nVar</code></td>
<td>
<p>a vector of size two, with respectively the number of sentiment measures, and the number of other explanatory
variables inputted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discarded</code></td>
<td>
<p>a named <code>logical</code> vector of length equal to the number of sentiment measures, in which <code>TRUE</code>
indicates that the particular sentiment measure has not been considered in the regression process. A sentiment measure is
not considered when it is a duplicate of another, or when at least 50% of the observations are equal to zero.</p>
</td>
</tr>
</table>
<p>If <code>ctr$do.iter = TRUE</code>, a <code>sento_modelIter</code> object which is a <code>list</code> containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>all sparse regressions, i.e., separate <code>sento_model</code> objects as above, as a <code>list</code> with as names the
dates from the perspective of the sentiment measures at which the out-of-sample predictions are carried out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>calibrated alphas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>calibrated lambdas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>performance</code></td>
<td>
<p>a <code>data.frame</code> with performance-related measures, being "<code>RMSFE</code>" (root mean squared
forecasting error), "<code>MAD</code>" (mean absolute deviation), "<code>MDA</code>" (mean directional accuracy, in which's calculation
zero is considered as a positive; in p.p.), "<code>accuracy</code>" (proportion of correctly predicted classes in case
of a logistic regression; in p.p.), and each's respective individual values in the sample. Directional accuracy
is measured by comparing the change in the realized response with the change in the prediction between two consecutive time
points (omitting the very first prediction as <code>NA</code>). Only the relevant performance statistics are given
depending on the type of regression. Dates are as in the <code>"models"</code> output element, i.e., from the perspective of the
sentiment measures.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Samuel Borms, Keven Bluteau
</p>


<h3>See Also</h3>

<p><code>ctr_model</code>, <code>glmnet</code>, <code>train</code>, <code>attributions</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("usnews", package = "sentometrics")
data("list_lexicons", package = "sentometrics")
data("list_valence_shifters", package = "sentometrics")
data("epu", package = "sentometrics")

set.seed(505)

# construct a sento_measures object to start with
corpusAll &lt;- sento_corpus(corpusdf = usnews)
corpus &lt;- quanteda::corpus_subset(corpusAll, date &gt;= "2004-01-01")
l &lt;- sento_lexicons(list_lexicons[c("LM_en", "HENRY_en")])
ctr &lt;- ctr_agg(howWithin = "counts", howDocs = "proportional",
               howTime = c("equal_weight", "linear"),
               by = "month", lag = 3)
sento_measures &lt;- sento_measures(corpus, l, ctr)

# prepare y and other x variables
y &lt;- epu[epu$date %in% get_dates(sento_measures), "index"]
length(y) == nobs(sento_measures) # TRUE
x &lt;- data.frame(runif(length(y)), rnorm(length(y))) # two other (random) x variables
colnames(x) &lt;- c("x1", "x2")

# a linear model based on the Akaike information criterion
ctrIC &lt;- ctr_model(model = "gaussian", type = "AIC", do.iter = FALSE, h = 4,
                   do.difference = TRUE)
out1 &lt;- sento_model(sento_measures, y, x = x, ctr = ctrIC)

# attribution and prediction as post-analysis
attributions1 &lt;- attributions(out1, sento_measures,
                              refDates = get_dates(sento_measures)[20:25])
plot(attributions1, "features")

nx &lt;- nmeasures(sento_measures) + ncol(x)
newx &lt;- runif(nx) * cbind(data.table::as.data.table(sento_measures)[, -1], x)[30:40, ]
preds &lt;- predict(out1, newx = as.matrix(newx), type = "link")

# an iterative out-of-sample analysis, parallelized
ctrIter &lt;- ctr_model(model = "gaussian", type = "BIC", do.iter = TRUE, h = 3,
                     oos = 2, alphas = c(0.25, 0.75), nSample = 75, nCore = 2)
out2 &lt;- sento_model(sento_measures, y, x = x, ctr = ctrIter)
summary(out2)

# plot predicted vs. realized values
p &lt;- plot(out2)
p

# a cross-validation based model, parallelized
cl &lt;- parallel::makeCluster(2)
doParallel::registerDoParallel(cl)
ctrCV &lt;- ctr_model(model = "gaussian", type = "cv", do.iter = FALSE,
                   h = 0, alphas = c(0.10, 0.50, 0.90), trainWindow = 70,
                   testWindow = 10, oos = 0, do.progress = TRUE)
out3 &lt;- sento_model(sento_measures, y, x = x, ctr = ctrCV)
parallel::stopCluster(cl)
foreach::registerDoSEQ()
summary(out3)

# a cross-validation based model for a binomial target
yb &lt;- epu[epu$date %in% get_dates(sento_measures), "above"]
ctrCVb &lt;- ctr_model(model = "binomial", type = "cv", do.iter = FALSE,
                    h = 0, alphas = c(0.10, 0.50, 0.90), trainWindow = 70,
                    testWindow = 10, oos = 0, do.progress = TRUE)
out4 &lt;- sento_model(sento_measures, yb, x = x, ctr = ctrCVb)
summary(out4)
## End(Not run)

</code></pre>


</div>