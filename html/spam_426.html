<div class="container">

<table style="width: 100%;"><tr>
<td>spam-solve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Linear Equation Solving for Sparse Matrices</h2>

<h3>Description</h3>

<p><code>backsolve</code> and <code>forwardsolve</code> solve a system
of linear equations where the coefficient matrix
is upper or lower triangular.
<br><code>solve</code> solves a linear system or computes the inverse
of a matrix if the right-hand-side is missing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'spam'
solve(a, b, Rstruct=NULL, ...)
## S4 method for signature 'spam'
backsolve(r, x, ...)
## S4 method for signature 'spam'
forwardsolve(l, x, ...)
## S4 method for signature 'spam'
chol2inv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>symmetric positive definite matrix of class <code>spam</code> or a Cholesky factor
as the result of a <code>chol</code> call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l,r</code></td>
<td>
<p>object of class <code>spam</code> or <code>spam.chol.</code><em>method</em> returned by the function
<code>chol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,b</code></td>
<td>
<p>vector or regular matrix of right-hand-side(s) of a system of linear equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rstruct</code></td>
<td>
<p>the Cholesky structure of <code>a</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods, see
‘Details’ below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We can solve <code>A %*% x = b</code> by first computing the Cholesky decomposition <code>A =
  t(R)%*%R)</code>, then solving <code>t(R)%*%y = b</code> for <code>y</code>, and
finally solving <code>R%*%x = y</code> for <code>x</code>.
<code>solve</code> combines <code>chol</code>, a Cholesky decomposition of a
symmetric positive definite sparse matrix, with <code>forwardsolve</code> and
then <code>backsolve</code>.<br></p>
<p>In case <code>a</code> is from a <code>chol</code> call, then <code>solve</code> is an
efficient way to calculate <code>backsolve(a, forwardsolve( t(a), b))</code>.
</p>
<p>However, for <code>a.spam</code> and <code>a.mat</code> from a <code>chol</code> call
with a sparse and ordinary matrix,  note that
<code>forwardsolve( a.mat, b, transpose=T, upper.tri=T)</code>
is equivalent to
<code>forwardsolve( t(a.mat), b)</code>
and <code>backsolve(a.spam, forwardsolve(a.spam, b, transpose=T, upper.tri=T))</code>
yields the desired result. But
<code>backsolve(a.spam,forwardsolve(t(a.spam), resid))</code> is
wrong because  <code>t(a.spam)</code> is a <code>spam</code> and not a
<code>spam.chol.NgPeyton</code> object.
</p>
<p><code>forwardsolve</code> and <code>backsolve</code> solve a system of linear
equations where the coefficient matrix is lower (<code>forwardsolve</code>) or
upper (<code>backsolve</code>) triangular.  Usually, the triangular matrix is
result from a <code>chol</code> call and it is not required to transpose it
for <code>forwardsolve</code>.  Note that arguments of the default
methods <code>k</code>, <code>upper.tri</code> and <code>transpose</code> do not have any
effects here.
</p>
<p>Notice that it is more efficient to solve successively the linear
equations (both triangular solves) than to implement these in the
Fortran code.
</p>
<p>If the right-hand-side in <code>solve</code> is missing it will compute
the inverse of a matrix. For details about the specific Cholsesky
decomposition, see <code>chol</code>.
</p>
<p>Recall that the Cholesky factors are from ordered matrices.
</p>
<p><code>chol2inv(x)</code> is a faster way to <code>solve(x)</code>.
</p>


<h3>Note</h3>

<p>There is intentionally no <abbr><span class="acronym">S3</span></abbr> distinction between the classes
<code>spam</code> and <code>spam.chol.</code><em>method</em>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, based on Ng and Peyton (1993) Fortran routines</p>


<h3>References</h3>

<p>See references in <code>chol</code>.
</p>


<h3>See Also</h3>

<p><code>chol.spam</code> and <code>ordering</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate multivariate form a covariance inverse:
# (usefull for GRMF)
set.seed(13)
n &lt;- 25    # dimension
N &lt;- 1000  # sample size
Sigmainv &lt;- .25^abs(outer(1:n,1:n,"-"))
Sigmainv &lt;- as.spam( Sigmainv, eps=1e-4)


Sigma &lt;- solve( Sigmainv)  # for verification
iidsample &lt;- array(rnorm(N*n),c(n,N))

mvsample &lt;- backsolve( chol(Sigmainv), iidsample)
norm( var(t(mvsample)) - Sigma)

# compare with:
mvsample &lt;- backsolve( chol(as.matrix( Sigmainv)), iidsample, n)
   #### ,n as patch
norm( var(t(mvsample)) - Sigma)



# 'solve' step by step:
b &lt;- rnorm( n)
R &lt;- chol(Sigmainv)
norm( backsolve( R, forwardsolve( R, b))-
      solve( Sigmainv, b) )
norm( backsolve( R, forwardsolve( R, diag(n)))- Sigma )


# 'update':
R1 &lt;- update( R, Sigmainv + diag.spam( n))



</code></pre>


</div>