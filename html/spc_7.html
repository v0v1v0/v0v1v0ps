<div class="container">

<table style="width: 100%;"><tr>
<td>imr.RuRl_alone</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute control limits of MR charts for normal data</h2>

<h3>Description</h3>

<p>Computation of control limits of standalone MR charts.</p>


<h3>Usage</h3>

<pre><code class="language-R">imr.RuRl_alone(L0, N=30, qm=30, M0=12, eps=1e-3)

imr.RuRl_alone_s3(L0, N=30, qm=30, M0=12)

imr.RuRl_alone_tail(L0, N=30, qm=30, M0=12)

imr.Ru_Rlgiven(Rl, L0, N=30, qm=30, M0=12)

imr.Rl_Rugiven(Ru, L0, N=30, qm=30, M0=12)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>pre-defined in-control ARL, that is, determine <code>Ru</code> and <code>Rl</code> so that the mean
number of observations until a false alarm is <code>L0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>controls the dimension of the linear equation system and consequently the accuracy of the result. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qm</code></td>
<td>
<p>number of quadrature nodes (and weights) to determine the definite collocation integrals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M0</code></td>
<td>
<p>mimics Inf â€” by setting <code>M0</code> to some large value (having a standard normal distribution in mind),
the algorithm for IMR charts could be used as well for the standalone MR chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>resolution parameter, which controls the approximation of the ARL slope at the in-control level of
the monitored standard deviation. It ensures the pattern that is called ARL unbiasedness. A small value is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rl</code></td>
<td>
<p>lower control limit multiple for moving range chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ru</code></td>
<td>
<p>upper control limit multiple for moving range chart.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Crowder (1987a) provided some math to determine the ARL of the so-called individual moving range (IMR) chart,
which consists of the mean X chart and the standard deviation MR chart. 
Making the alarm threshold, <code>M0</code>, huge (default value here is 12) for the X chart allows us to utilize Crowder's
setup for standalone MR charts. For details about the IMR numerics see <code>imr.arl</code>.
The three different versions of <code>imr.RuRl_alone</code> determine limits that form an ARL unbiased design, follow the restriction
<code>Rl</code> = <code>1/Ru^3</code> and feature equal probability tails for the MR's half-normal distribution,
respectively in the order given above).
The other two functions are helper routines for <code>imr.RuRl_alone</code>.
Note that the elegant approach given in Acosta-Mejia/Pignatiello (2000) is only an approximation,
because the MR series is not Markovian.
</p>


<h3>Value</h3>

<p>Returns control limit factors (alias multiples).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1987a)
Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 98-102.
</p>
<p>S. V. Crowder (1987b)
A Program for the Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 103-106.
</p>
<p>D. Radson, L. C. Alwan (1995)
Detecting Variance Reductions Using the Moving Range,
<em>Quality Engineering</em> 8(1), 165-178.
</p>
<p>C. A. Acosta-Mejia, J. J. Pignatiello (2000)
Monitoring process dispersion without subgrouping,
<em>Journal of Quality Technology</em> 32(2), 89-102.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Radson, Alwan (1995), Table 2 (Monte Carlo based), half-normal, known parameter case
## two-sided MR-alone chart, hence the ARL results has to be decreased by 1
## Here: a large M0=12 (default of the functions above) is deployed to mimic Inf
alpha &lt;- 0.00915
Ru &lt;- sqrt(2) * qnorm(1-alpha/4)
Rl &lt;- sqrt(2) * qnorm(0.5+alpha/4)
M0 &lt;- 12
## Not run: 
ARL0 &lt;- imr.arl(M0, Ru, 0, 1, vsided="two", Rl=Rl)
RRR1995 &lt;- imr.RuRl_alone_tail(ARL0)
RRRs &lt;- imr.RuRl_alone_s3(ARL0)
RRR &lt;- imr.RuRl_alone(ARL0)
results &lt;- rbind(c(Rl, Ru), RRR1995, RRRs, RRR)
results
## End(Not run)
</code></pre>


</div>