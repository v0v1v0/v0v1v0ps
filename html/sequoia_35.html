<div class="container">

<table style="width: 100%;"><tr>
<td>GetRelM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix with Pairwise Relationships</h2>

<h3>Description</h3>

<p>Generate a matrix or 3D array with all pairwise relationships
from a pedigree or dataframe with pairs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GetRelM(
  Pedigree = NULL,
  Pairs = NULL,
  GenBack = 1,
  patmat = FALSE,
  directed = TRUE,
  Return = "Matrix",
  Pairs_suffix = "?"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Pedigree</code></td>
<td>
<p>dataframe with columns id - dam - sire.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pairs</code></td>
<td>
<p>dataframe with columns ID1 - ID2 - Rel, e.g. as returned by
<code>GetMaybeRel</code>. Combining <code>Pedigree</code> and <code>Pairs</code> works
best if the relationships are coded as listed below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GenBack</code></td>
<td>
<p>number of generations back to consider; 1 returns
parent-offspring and sibling relationships, 2 also returns grand-parental,
avuncular and first cousins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patmat</code></td>
<td>
<p>logical, distinguish between paternal versus maternal relative
pairs? For avuncular pairs, the distinction is never made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>logical, distinguish between e.g. ID1=offspring, ID2=mother
('M') and ID1=mother, ID2=offspring ('O')? Defaults to TRUE; if FALSE both
are are scored as 'PO', as are father-offspring pairs, and all
grandparentâ€“ grand-offspring pairs are scored as 'GPO', and avuncular
pairs as 'FNA' and 'HNA'. Not (currently) compatible with <code>patmat</code>.
When <code>Return</code>='List', each pair is included twice (as ID1-ID2 &amp;
ID2-ID1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Return</code></td>
<td>
<p>'Matrix', 'Array', or 'List'. 'Matrix' returns an N x N matrix
with the closest relationship between each pair. 'Array' returns an N x N x
R array with for each of the R considered relationships whether it exists
between the pair (1) or not (0). See Details below. 'List' returns a list
with for each of the R considered relationships a 2-column matrix with the
IDs of the pairs having such a relationship. The size of the list (in Mb)
is much smaller than for the matrix or array, and this is therefore the
only format suitable for pedigrees with many thousands of individuals. If
<code>Pairs</code> is specified, the only possible return type is 'Matrix'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pairs_suffix</code></td>
<td>
<p>symbol added to the relationship abbreviations derived
from <code>Pairs</code>, when both <code>Pedigree</code> and <code>Pairs</code> are
provided. Can be an empty string.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Double relationships are ignored when <code>Return='Matrix'</code>, but
not when <code>Return='Array'</code>. For example, when A and B are both
mother-offspring and paternal siblings (A mated with her father to produce
B), only the mother-offspring relationship will be indicated when
<code>Return='Matrix'</code>.
</p>
<p>Note that full siblings are the exception to this rule: in the <code>Array</code>
they will be indicated as 'FS' only, and not as 'MHS' or 'PHS'. Similarly,
full avuncular pairs are not indicated as 'HA'. Double half-avuncular
relationships are indicated as both FA and HA.
</p>
<p>When <code>Pairs</code> is provided, <code>GenBack</code> and <code>patmat</code> are
ignored, and no check is performed if the abbreviations are compatible with
other functions.
</p>


<h3>Value</h3>

<p>If <code>Return='Matrix'</code>, an N x N square matrix, with N equal to
the number of rows in <code>Pedigree</code> (after running
<code>PedPolish</code>) or the number of unique individuals in
<code>Pairs</code>. If <code>Return='Array'</code>, an N x N x R array is returned,
with R, the number of different relationships, determined by <code>GenBack</code>
and <code>patmat</code>.
</p>
<p>The following abbreviations are used within the returned <code>Matrix</code>, or
as names of the 3rd dimension in the <code>Array</code> or of the <code>List</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Self</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Mother</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Father</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MP</code></td>
<td>
<p>Mother or Father (<code>patmat=FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>O</code></td>
<td>
<p>Offspring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FS</code></td>
<td>
<p>Full sibling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MHS</code></td>
<td>
<p>Maternal half-sibling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PHS</code></td>
<td>
<p>Paternal half-sibling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XHS</code></td>
<td>
<p>other half-sibling (hermaphrodites)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HS</code></td>
<td>
<p>half-sibling (<code>patmat=FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MGM</code></td>
<td>
<p>Maternal grandmother</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MGF</code></td>
<td>
<p>Maternal grandfather</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PGM</code></td>
<td>
<p>Paternal grandmother</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PGF</code></td>
<td>
<p>Paternal grandfather</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GP</code></td>
<td>
<p>Grandparent (<code>patmat=FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GO</code></td>
<td>
<p>Grand-offspring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FA</code></td>
<td>
<p>Full avuncular; maternal or paternal aunt or uncle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FN</code></td>
<td>
<p>Full nephew/niece</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HA</code></td>
<td>
<p>Half avuncular</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HN</code></td>
<td>
<p>Half nephew/niece</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DFC1</code></td>
<td>
<p>Double full first cousin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FC1</code></td>
<td>
<p>Full first cousin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Unrelated (or otherwise related)</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>ComparePairs</code> for comparing pairwise relationships
between two pedigrees; <code>PlotRelPairs</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">Rel.griffin &lt;- GetRelM(Ped_griffin, directed=FALSE)  # few categories
Rel.griffin &lt;- GetRelM(Ped_griffin, patmat=TRUE, GenBack=2)  # many cat.
table(as.vector(Rel.griffin))
# turning matrix into vector first makes table() much faster
PlotRelPairs(Rel.griffin)

</code></pre>


</div>