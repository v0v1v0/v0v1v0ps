<div class="container">

<table style="width: 100%;"><tr>
<td>rescale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transform or rescale between pc, pd and d-prime for sensory
discrimination protocols</h2>

<h3>Description</h3>

<p>Transforms or rescales estimates and optionally standard
errors between the three levels at which a sensory difference is
measured: pc (proportion of correct answers), pd (proportion of
discriminators) and d-prime. <code>rescale</code> is the main function and
only one of pc, pd or d-prime should be given as argument â€” values
for the remaining two scales will be computed.
</p>
<p>A number of auxiliary functions are also provided:
</p>

<dl>
<dt><code>psyfun</code></dt>
<dd>
<p>implements the psychometric functions and maps
from d-prime to pc</p>
</dd>
<dt><code>psyinv</code></dt>
<dd>
<p>implements the inverse psychometric functions
and maps from pc to d-prime</p>
</dd>
<dt><code>psyderiv</code></dt>
<dd>
<p>implements the derivative of the psychometric
functions</p>
</dd>
<dt><code>pc2pd</code></dt>
<dd>
<p>maps from pc to pd</p>
</dd>
<dt><code>pd2pc</code></dt>
<dd>
<p>maps from pd to pc</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">
rescale(pc, pd, d.prime, std.err,
        method = c("duotrio", "tetrad", "threeAFC", "twoAFC",
        "triangle", "hexad", "twofive", "twofiveF"),
        double = FALSE)

psyfun(d.prime, method = c("duotrio", "tetrad", "threeAFC", "twoAFC",
       "triangle", "hexad", "twofive", "twofiveF"),
        double = FALSE)

psyinv(pc, method = c("duotrio", "tetrad", "threeAFC", "twoAFC",
       "triangle", "hexad", "twofive", "twofiveF"),
        double = FALSE)

psyderiv(d.prime, method = c("duotrio", "tetrad", "threeAFC", "twoAFC",
         "triangle", "hexad", "twofive", "twofiveF"),
        double = FALSE)

pc2pd(pc, Pguess)

pd2pc(pd, Pguess)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pc</code></td>
<td>
<p>the proportion of correct answers; a numerical vector
between 0 and 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd</code></td>
<td>
<p>the proportion of discriminators; a numerical vector between
0 and 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.prime</code></td>
<td>
<p>the sensory difference on the d-prime scale; a
non-negative numerical vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.err</code></td>
<td>
<p>optional numerical vector of standard errors of the
same length as the either of <code>pc</code>, <code>pd</code> or
<code>d.prime</code>. Negative values are not allowed, but values may be
<code>NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the sensory discrimination protocol for which the
results should apply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double</code></td>
<td>
<p>should the 'double' variant of the discrimination protocol
be used? Logical scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pguess</code></td>
<td>
<p>the guessing probability implied by the protocol; a
numeric scalar between 0 and 1</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>rescale</code> function is based on the fact that once the
protocol and one of
pc, pd and d-prime is known, the other two can be computed. The same
applies to the standard errors of these parameters.
</p>
<p>Standard errors are optional, but if they are supplied, the length of
the <code>std.err</code> argument has to match the length of <code>pc</code>,
<code>pd</code> or <code>d.prime</code> whichever is given.
</p>
<p>A <code>print</code> method is implemented for <code>rescale</code> objects.
</p>


<h3>Value</h3>

<p>For <code>rescale</code> an object of class <code>rescale</code> with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a <code>data.frame</code> with values of <code>pc</code>,
<code>pd</code> and <code>d.prime</code> corresponding to the input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.err</code></td>
<td>
<p>if standard errors are given trough the <code>std.err</code>
argument a <code>data.frame</code> of the same size and shape as
<code>coefficients</code> with standard errors. Otherwise missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the sensory discrimination protocol for which the
results apply</p>
</td>
</tr>
</table>
<p>For <code>psyfun</code>, <code>psyinv</code>, <code>psyderiv</code>, <code>pc2pd</code> and
<code>pd2pc</code> a numerical vector of the same length as the first
argument with appropriate contents.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B Christensen</p>


<h3>Examples</h3>

<pre><code class="language-R">
## suppose 15 out of 20 are observed in a duo-trio experiment, then
## the estimated probability of correct a answer is
(pc &lt;- 15/20)
## The standard error of this estimate is
(se.pc &lt;- sqrt(pc * (1 - pc) / 20))
## The corresponding estimate of proportion of discriminators (pd) and
## d-prime with associated standard errors are:
rescale(pc = pc, std.err = se.pc, method = "duotrio")

## Can also do
rescale(pd = c(.6,.7), std.err = c(.2, NA))
psyfun(2, method = "triangle")
psyinv(0.8, method = "twoAFC")
psyderiv(2, method = "duotrio")
pc2pd(0.7, 1/2)
pd2pc(0.3, 1/3)

</code></pre>


</div>