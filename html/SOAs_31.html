<div class="container">

<table style="width: 100%;"><tr>
<td>MDLEs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to create maximin distance level expanded arrays</h2>

<h3>Description</h3>

<p>Maximin distance level expansion similar to Xiao and Xu is implemented,
using an optimization algorithm that is less demanding than the TA algorithm
of Xiao and Xu
</p>


<h3>Usage</h3>

<pre><code class="language-R">MDLEs(
  oa,
  ell,
  noptim.rounds = 1,
  optimize = TRUE,
  noptim.oa = 1,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ell</code></td>
<td>
<p>the multiplier for each number of levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.rounds</code></td>
<td>
<p>the number of optimization rounds; optimization may
take very long, therefore the default is 1, although more rounds are beneficial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>
<p>logical: if <code>FALSE</code>, suppress optimization of expansion levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.oa</code></td>
<td>
<p>integer: number of optimization rounds applied to initial oa itself before starting expansion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmethod</code></td>
<td>
<p>distance method for <code>phi_p</code>, "manhattan" (default) or "euclidean"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>p for <code>phi_p</code> (the larger, the closer to maximin distance)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ingoing oa is possibly optimized for space-filling, using function <code>phi_optimize</code>
with <code>noptim.oa</code> optimization rounds. The expansions themselves are again optimized for improving phi_p,
using an algorithm which is a variant of Weng (2014), instead of the more powerful but also much more demanding
algorithm proposed by Xiao and Xu.
</p>


<h3>Value</h3>

<p>A matrix of class <code>MDLE</code> with attributes
</p>

<dl>
<dt>phi_p</dt>
<dd>
<p>the phi_p value that was achieved</p>
</dd>
<dt>type</dt>
<dd>
<p>MDLE</p>
</dd>
<dt>optimized</dt>
<dd>
<p>logical: same as the input parameter</p>
</dd>
<dt>call</dt>
<dd>
<p>the call that produced the matrix</p>
</dd>
<dt>permpick</dt>
<dd>
<p>matrix of lists of length <code>s</code> with elements from 0 to <code>ell</code>-1;<br>
matrix element (i,j) contains the sequence of replacements used in function <code>DcFromDp</code> for constructing the level expansion of the ith level in the jth column</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code>SOAs-package</code>.
</p>
<p>Weng (2014)<br>
Xiao and Xu (2018)
</p>


<h3>Examples</h3>

<pre><code class="language-R">dim(aus &lt;- MDLEs(DoE.base::L16.4.5, 2, noptim.rounds = 1))
permpicks &lt;- attr(aus, "permpick")
## for people interested in internal workings:
## the code below produces the same matrix as MDLEs
SOAs:::DcFromDp(L16.4.5-1, 4,2, lapply(1:5, function(obj) permpicks[,obj]))
</code></pre>


</div>