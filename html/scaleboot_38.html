<div class="container">

<table style="width: 100%;"><tr>
<td>summary.scaleboot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>P-value Calculation for Multiscale Bootstrap</h2>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"scaleboot"</code> and <code>"scalebootv"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
## S3 method for class 'scaleboot'
summary(object,models=names(object$fi),k=3,sk=k,s=1,sp=-1,
              hypothesis=c("auto","null","alternative"),
              type=c("Frequentist","Bayesian"),...)

## S3 method for class 'scalebootv'
summary(object,models=attr(object,"models"),k=3,sk=k,
              hypothesis="auto",type="Frequentist", select="average",...)

## S3 method for class 'summary.scaleboot'
print(x,sort.by=c("aic","none"),verbose=FALSE,...)

## S3 method for class 'summary.scalebootv'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object used to select a method. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>character vector of model names. If numeric,
<code>names(object$fi)[models]</code> is used for each <code>"scaleboot"</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>numeric vector of <code class="reqn">k</code> for calculating p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sk</code></td>
<td>
<p>numeric vector of <code class="reqn">k</code> for calculating selective inference p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p><code class="reqn">\sigma_0^2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p><code class="reqn">\sigma_p^2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypothesis</code></td>
<td>
<p>specifies type of selective infernece.
"null" takes the region as null hypothesis, and "alternative" takes the region as alternative hypothesis.
"auto" determins it by the sign of beta0. The selectice pvalues (<code>sk.1</code>, <code>sk.2</code>, ...) are selective pvalues when "null", and they are one minus selective pvalues when "alternative".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>If numeric, it is passed to <code>sbpsi</code> functions as
<code>lambda</code> to specify p-value type. If "Frequentist" or
"Bayesian", then equivalent to specifying <code>lambda</code> = 1 or 0,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>character of model name (such as "poly.3") or one of
"average" and "best". If "average" or "best", then the averaging by
Akaike weights or the best model is used, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.by</code></td>
<td>
<p>sort key.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> For each model, a class of approximately unbiased p-values,
indexed by <code class="reqn">k=1,2,...</code>, is calculaed.  The p-values are named 
<code>k.1</code>, <code>k.2</code>, ..., where <code class="reqn">k=1</code> (<code>k.1</code>) corresponds to
the ordinary bootstrap probability, and <code class="reqn">k=2</code> (<code>k.2</code>)
corresponds to the third-order accurate p-value of Shimodaira (2002). As the
<code class="reqn">k</code> value increases, the bias of testing decreases, although the
p-value becomes less stable numerically and the monotonicity of rejection
regions becomes worse. Typically, <code class="reqn">k=3</code> provides a reasonable
compromise. The <code>sbpval</code> method is available to extract p-values from
the <code>"summary.scaleboot"</code> object.
</p>
<p>The p-value is defined as
</p>
<p style="text-align: center;"><code class="reqn"> p_k = 1 - \Phi\left( \sum_{j=0}^{k-1}
\frac{(\sigma_p^2-\sigma_0^2)^j}{j!}  \frac{d^j \psi(x|\beta)}{d
x^j}\Bigr|_{\sigma_0^2} \right),</code>
</p>
<p> where <code class="reqn">\psi(\sigma^2|\beta)</code> is the
model specification function, <code class="reqn">\sigma_0^2</code> is the evaluation point
for the Taylor series, and <code class="reqn">\sigma_p^2</code> is an additional
parameter. Typically, we do not change the default values
<code class="reqn">\sigma_0^2=1</code> and <code class="reqn">\sigma_p^2=-1</code>.
</p>
<p>The p-values are justified only for good fitting models. By default,
the model which minimizes the AIC value is selected. We can modify the
AIC value by using the <code>sbaic</code> function. We also diagnose the
fitting by using the <code>plot</code> method.
</p>
<p>Now includes selective inference p-values.
The method is described in Terada and Shimodaira (2017; arXiv:1711.00949)
"Selective inference for the problem of regions via multiscale bootstrap".
</p>


<h3>Value</h3>

<p><code>summary.scaleboot</code> returns
an object of the class <code>"summary.scaleboot"</code>, which is inherited
from the class <code>"scaleboot"</code>. It is a list containing all the components of class
<code>"scaleboot"</code> and the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pv</code></td>
<td>
<p>matrix of p-values of size <code>length(models)</code> *
<code>length(k)</code> with elements <code class="reqn">p_k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pe</code></td>
<td>
<p>matrix of standard errors of p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spv</code></td>
<td>
<p>matrix of selective inference p-values of size <code>length(models)</code> *
<code>length(sk)</code> with elements <code class="reqn">sp_k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spe</code></td>
<td>
<p>matrix of standard errors of selective inference p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betapar</code></td>
<td>
<p>list array containing (beta0, beta1) and its covariance matrix
for each model. They are obtained by linear extrapolation.
This will be used for interpreting the fitting in terms of signed distance and curvature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best</code></td>
<td>
<p> a list consisting of components <code>model</code> for the best
fitting model name, <code>aic</code> for its AIC value, <code>pv</code> and <code>spv</code> for 
vector of p-values, and <code>pe</code> and <code>spe</code> for vectors of standard errors.
Also includes <code>betapar</code> for the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>average</code></td>
<td>
<p> a list of results for the average model computed by Akaike weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parex</code></td>
<td>
<p>a list of components <code>k</code>, <code>s</code>, and <code>sp</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code>sbfit</code>, <code>sbpsi</code>, <code>sbpval</code>,
<code>sbaic</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(mam15)
## For a single hypothesis
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
summary(a) # calculate and print p-values (k=3)
summary(a,k=2) # calculate and print p-values (k=2)
summary(a,k=1:4) # up to "k.4" p-value.

## For multiple hypotheses
b &lt;- mam15.relltest[1:15] # an object of class "scalebootv"
summary(b) # calculate and print p-values (k=3)
summary(b,k=1:4) # up to "k.4" p-value.

</code></pre>


</div>