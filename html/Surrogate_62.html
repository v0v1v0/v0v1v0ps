<div class="container">

<table style="width: 100%;"><tr>
<td>MaxEntSPFBinBin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Use the maximum-entropy approach to compute SPF (surrogate predictive function) in the binary-binary setting
</h2>

<h3>Description</h3>

<p>In a surrogate evaluation setting where both <code class="reqn">S</code> and <code class="reqn">T</code> are binary
endpoints, a sensitivity-based approach where multiple 'plausible values' for vector <code class="reqn">\pi</code> (i.e., vectors <code class="reqn">\pi</code> that are compatible with the observable data at hand) can be used (for details, see <code>SPF.BinBin</code>). Alternatively, the maximum entropy distribution for vector <code class="reqn">\pi</code>
can be considered (Alonso et al., 2015). The use of the distribution that maximizes the entropy can be justified
based on the fact that any other distribution would necessarily 
(i) assume information that we do not have, or (ii) contradict information
that we do have. The function <code>MaxEntSPFBinBin</code> implements the latter approach.
</p>
<p>Based on vector <code class="reqn">\pi</code>, the surrogate predictive function (SPF) is computed, i.e., <code class="reqn">r(i,j)=P(\Delta T=i|\Delta S=j)</code>. For example, <code class="reqn">r(-1,1)</code> quantifies the probability that the treatment has a negative effect on the true endpoint (<code class="reqn">\Delta T=-1</code>) given that it has a positive effect on the surrogate (<code class="reqn">\Delta S=1</code>). </p>


<h3>Usage</h3>

<pre><code class="language-R">MaxEntSPFBinBin(pi1_1_, pi1_0_, pi_1_1,
pi_1_0, pi0_1_, pi_0_1, Method="BFGS", 
Fitted.ICA=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pi1_1_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=1|Z=0)</code>, i.e., the probability that <code class="reqn">S=T=1</code> when under treatment <code class="reqn">Z=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi1_0_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=0|Z=0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_1_1</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=1|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_1_0</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=0|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi0_1_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=0,S=1|Z=0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_0_1</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=0,S=1|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>
<p>The maximum entropy frequency vector <code class="reqn">p^{*}</code> is calculated based on the optimal solution to an unconstrained dual convex programming problem (for details, see Alonso et al., 2015). Two different optimization methods can be specified, i.e., <code>Method="BFGS"</code> and <code>Method="CG"</code>, which implement the quasi-Newton BFGS (Broyden, Fletcher, Goldfarb, and Shanno) and the conjugent gradient (CG) methods (for details on these methods, see the help files of the <code>optim()</code> function and the references theirin). 
Alternatively, the <code class="reqn">\pi</code> vector (obtained when the functions <code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Full</code>, or <code>ICA.BinBin.Grid.Sample</code> are executed) that is 'closest' to the vector <code class="reqn">\pi</code> can be retained. Here, the 'closest' vector is defined as the vector where the sum of the squared differences between
the components in the vectors <code class="reqn">\pi</code> and <code class="reqn">\pi</code> is smallest. The latter 'Minimum Difference' method can re requested by specifying the argument <code>Method="MD"</code> in the function call. Default <code>Method="BFGS"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fitted.ICA</code></td>
<td>
<p>A fitted object of class <code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Full</code>, or <code>ICA.BinBin.Grid.Sample</code>. Only required when <code>Method="MD"</code> is used. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Vector_p</code></td>
<td>
<p>The maximum entropy frequency vector <code class="reqn">p^{*}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_1_1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(1, 1)</code>, i.e., <code class="reqn">P(\Delta T=1|\Delta S=1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_min1_1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(-1, 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_0_1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(0, 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_1_0</code></td>
<td>
<p>The vector of values for <code class="reqn">r(1, 0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_min1_0</code></td>
<td>
<p>The vector of values for <code class="reqn">r(-1, 0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_0_0</code></td>
<td>
<p>The vector of values for <code class="reqn">r(0, 0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_1_min1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(1, -1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_min1_min1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(-1, -1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_0_min1</code></td>
<td>
<p>The vector of values for <code class="reqn">r(0, -1)</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Wim Van der Elst, Ariel Alonso, &amp; Geert Molenberghs
</p>


<h3>References</h3>

<p>Alonso, A., &amp; Van der Elst, W. (2015). A maximum-entropy approach for the evluation of surrogate endpoints based on causal inference.
</p>


<h3>See Also</h3>

<p><code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Sample</code>, <code>ICA.BinBin.Grid.Full</code>, <code>plot MaxEntSPF BinBin</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sensitivity-based ICA results using ICA.BinBin.Grid.Sample
ICA &lt;- ICA.BinBin.Grid.Sample(pi1_1_=0.341, pi0_1_=0.119, pi1_0_=0.254,
pi_1_1=0.686, pi_1_0=0.088, pi_0_1=0.078, Seed=1, 
Monotonicity=c("No"), M=5000)

# Sensitivity-based SPF
SPFSens &lt;- SPF.BinBin(ICA)

# Maximum-entropy based SPF
SPFMaxEnt &lt;- MaxEntSPFBinBin(pi1_1_=0.341, pi0_1_=0.119, pi1_0_=0.254,
pi_1_1=0.686, pi_1_0=0.088, pi_0_1=0.078)

# Explore maximum-entropy results
summary(SPFMaxEnt)

# Plot results
plot(x=SPFMaxEnt, SPF.Fit=SPFSens)
</code></pre>


</div>