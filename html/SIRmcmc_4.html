<div class="container">

<table style="width: 100%;"><tr>
<td>household_transmission</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate parameters from SIR model</h2>

<h3>Description</h3>

<p>Use the Metropolis algorithm to estimate parameters from
the SIR compartmental model</p>


<h3>Usage</h3>

<pre><code class="language-R">household_transmission(onset_date, household_index, covariate = NULL,
                       followup_time, iterations,
                       delta = c(0.1,0.3,0.4,0.1), plot_chain = TRUE,
                       index = 1, start_date = NULL, prior = unifprior,
                       constant_hazard = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>onset_date</code></td>
<td>

<p>A vector of onset dates. If onset_date is a character vector,
then it will be coerced to dates using
<code>as.Date</code>. <code>NA</code> values are interpretted as remaining
susceptible at the end of followup.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>household_index</code></td>
<td>

<p>A vector identifying households, which should be
the same length as the onset_date argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>

<p>A vector identifying covariate patterns. If given, then it is
interpretted as a factor. A value for epsilon will be given for each
level of covariate. If <code>NULL</code>, then epsilon is not estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>followup_time</code></td>
<td>

<p>An integer for the followup time in days.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>

<p>An integer for the number of iterations of the Metropolis algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>A vector of length 4 for tuning the acceptance rate of the
Metropolis algorithm. The order is (1) alpha, (2) beta, (3) gamma,
and (4) epsilon.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_chain</code></td>
<td>

<p>A boolean of whether to plot the value of the chain vs the iterate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>

<p>An integer for the index date. Probabilities are conditional on the
index date.  Any coordinates of onset_date equal
to index will have a likelihood of 1. If you want unconditional
probabilities, then index should be less than start_date.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_date</code></td>
<td>

<p>Should be the same format as onset_date. Specifies the start of the
followup period.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>A function to compute the prior probability of alpha, beta, gamma,
and epsilon. Any user written function must take the arguments
alpha, beta, gamma, epsilon, and esteps. Builtin functions are
unifprior and <code>prior</code>. unifprior is uniform on (0.01,1000).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant_hazard</code></td>
<td>

<p>If <code>FALSE</code>, then the algorithm computes a time dependent hazard
for the cohort and the hazard from the community is proportional to
the hazard in the cohort. If <code>TRUE</code>, then the algorithm assumes a
constant hazard from the community.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments to be passed to the function in the prior argument.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If no covariates are supplied, only the model parameters alpha, beta,
and gamma are estimated using a stepwise Metropolis algorithm. The
model parameters are drawn from a uniform distribution on (0.1,1). The
first step proposes a new alpha using <code>rnorm</code> and the mixing parameter
<code>delta[1]</code>. The second and third steps are similar for beta and
gamma. If covariates are supplied, the additional parameters,
collectively called epsilon, are also estimated.
</p>
<p>The algorithm assumes followup begins on start_date and lasts for
followup_time days. Any coordinate of onset_date equal to index does
not contribute to the likelihood.
</p>
<p>Two priors are builtin: <code>prior</code> and
<code>unifprior</code>. User defined prior functions must take the
arguments alpha, beta, gamma, epslion, and esteps.
</p>


<h3>Value</h3>

<p>An object of the class <code>SIRmcmc</code>.
</p>


<h3>See Also</h3>

<p><code>prior</code>
<code>unifprior</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##A trivial example-------------------------------------------------------
library(graphics)
onset&lt;-sample(c(seq(1,10),rep(Inf,20)),size=500,replace=TRUE)
hh&lt;-sample(seq(1,300),size=500,replace=TRUE)
chain&lt;-household_transmission(onset_date = onset, household_index = hh,
                              followup_time = 10, iterations = 100)
community_attack_rate(SIRmcmc=chain)
secondary_attack_rate(household_size=3,SIRmcmc=chain)

##An example with household transmission---------------------------------
library(graphics)
data(hh.transmission)
set.seed(1)
iterations&lt;-100
T&lt;-30
delta&lt;-c(0.1,0.6,0.8)
index&lt;-0
##Find the MCMC estimates of alpha, beta, and gamma
chain&lt;-household_transmission(
    onset_date=hh.transmission$onset,
    household_index=hh.transmission$household,
    covariate=NULL,
    followup_time=T,
    iterations=iterations,
    delta=delta,
    prior=unifprior,
    index=index
)
#Tabulate true type of transmission
hh_table&lt;-table(
    table(
        is.finite(MCMC_date(hh.transmission$onset)),
        hh.transmission$household)["TRUE",]
)
##Calculate the true SAR
truth_table&lt;-table(hh.transmission$transmission)
truth&lt;-unname(truth_table["Household"]/sum(hh_table[2:3]))
cat("\n\nTrue Value of SAR\n\n")
print(truth)
##Find point and 95% central creditable intervals for MCMC SAR
cat("\n\nMCMC Estimate of SAR\n\n")
secondary_attack_rate(household_size=2,SIRmcmc=chain)
days&lt;-NULL
for(d in c(seq(1:5))){
    days&lt;-c(days,as.character(d))
    a&lt;-sum(table(tapply(X=hh.transmission$onset,INDEX=hh.transmission$household,FUN=diff))[days])
    cat(
        paste0(
            "\n\n",
            d,
            " Day Counting Estimate of SAR\n\n"
        )
    )
    ##Find point and 95% confidence intervals for normal approx to SAR
    print(
        a/sum(hh_table[2:3])+c(p=0,LB=-1,UB=1) *
        qnorm(p=0.975) *
        sqrt(a*(hh_table[2]+hh_table[3]-a)/(hh_table[2]+hh_table[3])^3)
    )
}


##An example with rate ratios----------------------------------------
## Not run: 
    library(graphics)
    data(hh.transmission.epsilon)
    set.seed(1)
    iterations&lt;-100
    T&lt;-30
    delta&lt;-c(0.1,0.1,0.1,0.1)
    index&lt;-0
    ##Find the MCMC estimates of alpha, beta, gamma, and epsilon
    chain&lt;-household_transmission(
        onset_date=hh.transmission.epsilon$onset,
        household_index=hh.transmission.epsilon$household,
        covariate=hh.transmission.epsilon$epsilon,
        followup_time=T,
        iterations=iterations,
        delta=delta,
        prior=unifprior,
        index=index
    )

    ##Find point and 95% central creditable intervals for MCMC SAR
    cat("\n\nMCMC Estimate of SAR\n\n")
    print(secondary_attack_rate(household_size=2,SIRmcmc=chain))
    for(e in c(1,5)){
        hh_table&lt;-table(table(
            is.finite(MCMC_date(hh.transmission.epsilon$onset)),
            hh.transmission.epsilon$household,
            hh.transmission.epsilon$epsilon)["TRUE",,as.character(e)])
        ##Tabulate true type of transmission
        truth_table&lt;-table(
            hh.transmission.epsilon$transmission[which(
                hh.transmission.epsilon$epsilon==e
            )])
        ##Calculate the true SAR
        truth&lt;-unname(truth_table["Household"]/sum(hh_table[2:3]))
        cat("\n\nTrue Value of SAR\n\n")
        print(truth)
        days&lt;-NULL
        for(d in c(seq(1:5))){
            days&lt;-c(days,as.character(d))
            a&lt;-sum(table(tapply(
                X=hh.transmission.epsilon$onset[which(hh.transmission.epsilon$epsilon==e)],
                INDEX=hh.transmission.epsilon$household[which(hh.transmission.epsilon$epsilon==e)],
                FUN=diff))[days])
            ##Find point and 95% confidence intervals for normal approx to SAR
            cat(paste0(
                "\n\n",
                d,
                " Day Counting Estimate of SAR\n\n"
            ))
            print(
                a/sum(hh_table[2:3])+c(p=0,LB=-1,UB=1)
                * qnorm(p=0.975)
                * sqrt(a*(hh_table[2]+hh_table[3]-a)/(hh_table[2]+hh_table[3])^3)
            )
        }
    }

## End(Not run)

</code></pre>


</div>