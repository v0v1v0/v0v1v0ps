<div class="container">

<table style="width: 100%;"><tr>
<td>subsetContigs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select contigs</h2>

<h3>Description</h3>

<p>Create a SQM object containing only the requested contigs, the ORFs contained in them and the bins that contain them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">subsetContigs(
  SQM,
  contigs,
  trusted_functions_only = FALSE,
  ignore_unclassified_functions = FALSE,
  rescale_tpm = FALSE,
  rescale_copy_number = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SQM</code></td>
<td>
<p>SQM object to be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contigs</code></td>
<td>
<p>character. Vector of contigs to be selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trusted_functions_only</code></td>
<td>
<p>logical. If <code>TRUE</code>, only highly trusted functional annotations (best hit + best average) will be considered when generating aggregated function tables. If <code>FALSE</code>, best hit annotations will be used (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unclassified_functions</code></td>
<td>
<p>logical. If <code>FALSE</code>, ORFs with no functional classification will be aggregated together into an "Unclassified" category. If <code>TRUE</code>, they will be ignored (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_tpm</code></td>
<td>
<p>logical. If <code>TRUE</code>, TPMs for KEGGs, COGs, and PFAMs will be recalculated (so that the TPMs in the subset actually add up to 1 million). Otherwise, per-function TPMs will be calculated by aggregating the TPMs of the ORFs annotated with that function, and will thus keep the scaling present in the parent object (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_copy_number</code></td>
<td>
<p>logical. If <code>TRUE</code>, copy numbers with be recalculated using the RecA/RadA coverages in the subset. Otherwise, RecA/RadA coverages will be taken from the parent object. By default it is set to <code>FALSE</code>, which means that the returned copy numbers for each function will represent the average copy number of that function per genome in the parent object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>SQM object containing only the selected contigs.
</p>


<h3>See Also</h3>

<p><code>subsetORFs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Hadza)
# Which contigs have a GC content below 40?
lowGCcontigNames = rownames(Hadza$contigs$table[Hadza$contigs$table[,"GC perc"]&lt;40,])
lowGCcontigs = subsetContigs(Hadza, lowGCcontigNames)
hist(lowGCcontigs$contigs$table[,"GC perc"])
</code></pre>


</div>