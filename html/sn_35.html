<div class="container">

<table style="width: 100%;"><tr>
<td>fitdistr.grouped-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Methods for objects of class created by <code>fitdistr.grouped</code>
</h2>

<h3>Description</h3>

<p>A successful call to function <code>fitdistr.grouped</code> creates 
an object of class, also named <code>fitdistr.grouped</code>, for which a set 
of methods exist.
The structure of an object of this class is described in section 
‘Object components’.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'fitdistr.grouped'
logLik(object, ...)
  ## S3 method for class 'fitdistr.grouped'
coef(object, ...)
  ## S3 method for class 'fitdistr.grouped'
vcov(object, ...)
  ## S3 method for class 'fitdistr.grouped'
print(x, ...)
  ## S3 method for class 'fitdistr.grouped'
summary(object, cor=FALSE, ...)
  ## S3 method for class 'fitdistr.grouped'
fitted(object, full=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>an object of class <code>fitdistr.grouped</code> as created 
by a call to the function with this name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>logical (default=<code>FALSE</code>); is the correlation matrix required?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>logical (default=<code>FALSE</code>); must the vector of fitted 
frequencies include the boundary classes, when they are added to 
cover the full support of the fitted distribution?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Object components</h3>

<p>Components of an object of class <code>fitdistr.grouped</code>:
</p>

<dl>
<dt><code>call</code></dt>
<dd>
<p>the matched call</p>
</dd>
<dt><code>family</code></dt>
<dd>
<p>the selected <code>family</code> of distributions</p>
</dd>
<dt><code>logL</code></dt>
<dd>
<p>the achieved maximum log-likelihood</p>
</dd>
<dt><code>param</code></dt>
<dd>
<p>a vector of estimated parameters</p>
</dd>
<dt><code>vcov</code></dt>
<dd>
<p>the approximate variance-covariance matrix of the estimates</p>
</dd>
<dt><code>input</code></dt>
<dd>
<p>a list with the input quantities and some derived ones</p>
</dd>
<dt><code>opt</code></dt>
<dd>
<p>a list as returned by <code>optim</code></p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Possolo, A., Merkatas, C. and Bodnar, O. (2019).
Asymmetrical uncertainties.
<em>Metrologia</em> 56, 045009.
</p>


<h3>See Also</h3>

<p>the function <code>fitdistr.grouped</code>, 
the plotting method <code>plot.fitdistr.grouped</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75], 10) # as used in selm documentation; see its fitting
detach(barolo)
breaks &lt;- seq(1, 3, by=0.25)
f &lt;- cut(logPrice, breaks = breaks)
counts &lt;- tabulate(f, length(levels(f))) 
fit.logPrice.gr &lt;- fitdistr.grouped(breaks, counts, family='ST')
summary(fit.logPrice.gr) # compare this fit with the ungrouped data fitting 
print(fit.logPrice.gr)
coef(fit.logPrice.gr)
vcov(fit.logPrice.gr)
data.frame(intervals=levels(f), counts, fitted=format(fitted(fit.logPrice.gr)))
full.intervals &lt;- c("(-Inf, 1]", levels(f), "(3, Inf)")
data.frame("full-range intervals" = full.intervals,
       "full-range counts" = c(0, counts, 0), 
      "full-range fit" = fitted(fit.logPrice.gr, full=TRUE))
sum(counts) - sum(fitted(fit.logPrice.gr))  
sum(counts) - sum(fitted(fit.logPrice.gr, full=TRUE))  # must be "nearly 0" 
#---
# Use first entry in Table 3 of Possolo et al. (2019) and do similar fitting
# to the *probability* values, not observation counts
afcrc59 &lt;- 1.141
breaks &lt;- c(-Inf, afcrc59 - 0.033, afcrc59, afcrc59 + 0.037, Inf)
prob &lt;-  c(0.16, 0.50, 0.84) 
cum.percent &lt;- c(0, prob, 1)*100 
fitSN &lt;- fitdistr.grouped(breaks, counts=diff(cum.percent), family="SN") 
print(coef(fitSN))
print(rbind(target=c(prob, 1)*100, fitted=cumsum(fitted(fitSN))), digits=5)
# Note: given the nature of these data (i.e. probabilities, not counts), 
#       there is no point to use vcov, logLik and summary on the fitted object.
</code></pre>


</div>