<div class="container">

<table style="width: 100%;"><tr>
<td>MRC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Multiresolution Criterion</h2>

<h3>Description</h3>

<p>Computes multiresolution coefficients, the corresponding criterion, simulates these for Gaussian white or coloured noise, based on which p-values and quantiles are obtained.
</p>
<p><b>Deprecation warning:</b> The function <code>MRC.simul</code> is deprecated, but still working, however, may be defunct in a future version. Please use instead the function <code>monteCarloSimulation</code>. An example how to reproduce results is given below. Some other functions are help function and might be removed, too.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MRC(x, lengths = 2^(floor(log2(length(x))):0), norm = sqrt(lengths),
  penalty = c("none", "log", "sqrt"))
MRCoeff(x, lengths = 2^(floor(log2(length(x))):0), norm = sqrt(lengths), signed = FALSE)
MRC.simul(n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"))
MRC.pvalue(q, n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"),
  name = ".MRC.table", pos = .MCstepR, inherits = TRUE)
MRC.FFT(epsFFT, testFFT, K = matrix(TRUE, nrow(testFFT), ncol(testFFT)), lengths,
  penalty = c("none", "log", "sqrt"))
MRC.quant(p, n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"),
  name = ".MRC.table", pos = .MCstepR, inherits = TRUE, ...)
kMRC.simul(n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))))
kMRC.pvalue(q, n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))),
  name = ".MRC.ktable", pos = .MCstepR, inherits = TRUE)
kMRC.quant(p, n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))),
  name = ".MRC.ktable", pos = .MCstepR, inherits = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of numerical observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lengths</code></td>
<td>
<p>vector of interval lengths to use, dyadic intervals by default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signed</code></td>
<td>
<p>whether signed coefficients should be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantile</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>length of data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of simulations to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name,pos,inherits</code></td>
<td>
<p>under which name and where precomputed results are stored, or retrieved, see <code>assign</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>a <code>logical</code> matrix indicating the set of valid intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsFFT</code></td>
<td>
<p>a vector containg the FFT of the data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testFFT</code></td>
<td>
<p>a matrix containing the FFTs of the intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kern</code></td>
<td>
<p>a filter kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>penalty term in the multiresolution statistic: <code>"none"</code> for no penalty, <code>"log"</code> for penalizing the log-length of an interval, and <code>"sqrt"</code> for penalizing the square root of the MRC; or a <code>function</code> taking two arguments, the first being the multiresolution coefficients, the second the interval lenghts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>how the partial sums should be normalised, by default <code>sqrt(lengths)</code>, so they are normalised to equal variance across all interval lengths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>p-value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to function <code>quantile</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>MRC</code></td>
<td>
<p>a vector giving the maximum as well as the indices of the corresponding interval's start and length</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MRCoeff</code></td>
<td>
<p>a matrix giving the multiresolution coefficients for all test intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MRC.pvalue, MRC.quant, MRC.simul</code></td>
<td>
<p>the corresponding p-value / quantile / vector of simulated values under the assumption of standard Gaussian white noise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kMRC.pvalue, kMRC.simul, kMRC.simul</code></td>
<td>
<p>the corresponding p-value / quantile / vector of simulated values under the assumption of filtered Gaussian white noise</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Davies, P. L., Kovac, A. (2001) Local extremes, runs, strings and multiresolution. <em>The Annals of Statistics</em> <b>29</b>, 1–65.
</p>
<p>Dümbgen, L., Spokoiny, V. (2001) Multiscale testing of qualitative hypotheses. <em>The Annals of Statistics</em> <b>29</b>, 124–152.
</p>
<p>Siegmund, D. O., Venkatraman, E. S. (1995) Using the generalized likelihood ratio statistic for sequential detection of a change-point. <em>The Annals of Statistics</em> <b>23</b>, 255–271.
</p>
<p>Siegmund, D. O., Yakir, B. (2000) Tail probabilities for the null distribution of scanning statistics. <em>Bernoulli</em> <b>6</b>, 191–213.
</p>


<h3>See Also</h3>

<p><code>monteCarloSimulation</code>, <code>smuceR</code>, <code>jsmurf</code>, <code>stepbound</code>, <code>stepsel</code>, <code>quantile</code></p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(100)
all.equal(MRC.simul(100, r = 100),
          sort(monteCarloSimulation(n = 100, r = 100, output = "maximum",
                                    penalty = "none", intervalSystem = "dyaLen")),
          check.attributes = FALSE)

# simulate signal of 100 data points
set.seed(100)
f &lt;- rep(c(0, 2, 0), c(60, 10, 30))
# add gaussian noise
x &lt;- f + rnorm(100)
# compute multiresolution criterion
m &lt;- MRC(x)
# compute Monte-Carlo p-value based on 100 simulations
MRC.pvalue(m["max"], length(x), 100)
# compute multiresolution coefficients
M &lt;- MRCoeff(x)

# plot multiresolution coefficients, colours show p-values below 5% in 1% steps
op &lt;- par(mar = c(5, 4, 2, 4) + 0.1)
image(1:length(x), seq(min(x), max(x), length = ncol(M)), apply(M[,ncol(M):1], 1:2,
  MRC.pvalue, n = length(x), r = 100), breaks = (0:5) / 100,
  col = rgb(1, seq(0, 1, length = 5), 0, 0.75),
  xlab = "location / left end of interval", ylab ="measurement",
  main = "Multiresolution Coefficients",
  sub = paste("MRC p-value =", signif(MRC.pvalue(m["max"], length(x), 100), 3)))
axis(4, min(x) + diff(range(x)) * ( pretty(1:ncol(M) - 1) ) / dim(M)[2],
  2^pretty(1:ncol(M) - 1))
mtext("interval lengths", 4, 3)
# plot signal and its mean
points(x)
lines(f, lty = 2)
abline(h = mean(x))
par(op)

</code></pre>


</div>