<div class="container">

<table style="width: 100%;"><tr>
<td>gbmkrigeidwcv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross validation, n-fold and leave-one-out for the hybrid methods of
generalized boosted regression modeling ('gbm'), 'kriging' and
inverse distance weighted ('IDW').</h2>

<h3>Description</h3>

<p>This function is a cross validation function for 38 hybrid
methods of 'gbm', 'kriging' and 'IDW', including the average of 'gbmkrige'
and 'gbmidw' ('gbmkrigegbmidw') and  the average of 'gbm', 'gbmkrige' and 'gbmidw'
('gbmgbmkrigegbmidw'), where 'kriging' methods include ordinary kriging
('OK'), simple kriging ('SK'), block 'OK' ('BOK') and block 'SK'('BSK')
and 'IDW' also covers 'NN' and 'KNN'. The data splitting is based on a stratified
random sampling method (see the 'datasplit' function for details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gbmkrigeidwcv(
  longlat,
  trainx,
  trainy,
  var.monotone = rep(0, ncol(trainx)),
  family = "gaussian",
  n.trees = 3000,
  learning.rate = 0.001,
  interaction.depth = 2,
  bag.fraction = 0.5,
  train.fraction = 1,
  n.minobsinnode = 10,
  transformation = "none",
  weights = rep(1, nrow(trainx)),
  keep.data = FALSE,
  verbose = TRUE,
  delta = 1,
  formula = res1 ~ 1,
  vgm.args = "Sph",
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  nmaxkrige = 12,
  idp = 2,
  nmaxidw = 12,
  hybrid.parameter = 2,
  lambda = 1,
  validation = "CV",
  cv.fold = 10,
  predacc = "VEcv",
  n.cores = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainy</code></td>
<td>
<p>a vector of the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.monotone</code></td>
<td>
<p>an optional vector, the same length as the number of
predictors, indicating which variables have a monotone increasing (+1),
decreasing (-1), or arbitrary (0) relationship with the outcome. By default,
a vector of 0 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>either a character string specifying the name of the distribution to
use or a list with a component name specifying the distribution and any
additional parameters needed. See gbm for details. By default, "gaussian" is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>the total number of trees to fit. This is equivalent to the
number of iterations and the number of basis functions in the additive
expansion. By default, 3000 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learning.rate</code></td>
<td>
<p>a shrinkage parameter applied to each tree in the
expansion. Also known as step-size reduction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.depth</code></td>
<td>
<p>the maximum depth of variable interactions.
1 implies an additive model, 2 implies a model with up to 2-way
interactions, etc. By default, 2 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bag.fraction</code></td>
<td>
<p>the fraction of the training set observations randomly
selected to propose the next tree in the expansion. By default, 0.5 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train.fraction</code></td>
<td>
<p>The first train.fraction * nrows(data) observations
are used to fit the gbm and the remainder are used for computing
out-of-sample estimates of the loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.minobsinnode</code></td>
<td>
<p>minimum number of observations in the trees terminal
nodes. Note that this is the actual number of observations not the total
weight. By default, 10 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformation</code></td>
<td>
<p>transform the residuals of 'gbm' to normalize the data for 'krige';
can be "sqrt" for square root, "arcsine" for arcsine, "log" or "none"
for non transformation. By default, "none" is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Must be positive but do not need to be normalized.
If keep.data = FALSE in the initial call to gbm then it is the user's
responsibility to resupply the weights to gbm.more. By default, a vector of
1 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>a logical variable indicating whether to keep the data and
an index of the data stored with the object. Keeping the data and index
makes subsequent calls to gbm.more faster at the cost of storing an extra
copy of the dataset. By default, 'FALSE' is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If TRUE, gbm will print out progress and performance
indicators. By default, 'TRUE' is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>numeric; to avoid log(0) in the log transformation. The default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula defining the response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in 'gstat' for details. The default is
'formula = res1 ~ 1'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in 'gstat' for details.
By default, "Sph" is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in 'gstat' for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in 'gstat' for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>block size. see 'krige' in 'gstat' for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>for simple kriging. see 'krige' in 'gstat' for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmaxkrige</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.parameter</code></td>
<td>
<p>the default is 2 that is for 'gbmkrigegbmidw';
for 'gbmgbmkrigegbmidw', it needs to be 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda, </code></td>
<td>
<p>ranging from 0 to 2; the default is 1 for 'gbmkrigegbmidw'
and 'gbmgbmkrigegbmidw'; and if it is &lt; 1, more weight is placed on 'krige',
otherwise more weight is placed on 'idw'; and if it is 0, 'idw' is not
considered and the resultant methods is 'gbmkrige' when the default
'hybrid.parameter' is used; and if it is 2, then the resultant method is
'gbmidw' when the default 'hybrid.parameter' is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predacc</code></td>
<td>
<p>can be either "VEcv" for vecv or "ALL" for all measures
in function pred.acc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>The number of CPU cores to use. See gbm for details. By
default, 6 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to 'randomForest', 'krige' and 'gstat'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on 'gbmcv' in 'spm', and 'krigecv'
in 'spm2'.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J. (2022). Spatial Predictive Modeling with R. Boca Raton,
Chapman and Hall/CRC.
</p>
<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>Greg Ridgeway with contributions from others (2015). gbm: Generalized
Boosted Regression Models. R package version 2.1.1.
https://CRAN.R-project.org/package=gbm
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

library(spm)
# gbmgbmokgbmidw
data(sponge)
longlat &lt;- sponge[, 1:2]
set.seed(1234)
gbmgbmkrigegbmidwcv1 &lt;- gbmkrigeidwcv(longlat = longlat,
trainx = sponge[, -3], trainy = sponge[, 3], family = "poisson", interaction.depth = 3,
transformation = "none", formula = res1 ~ 1, vgm.args = "Sph",
nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 3, validation = "CV",
predacc = "ALL", n.cores = 2)
gbmgbmkrigegbmidwcv1

# gbmokgbmidw for count data
data(sponge)
longlat &lt;- sponge2[, 1:2]
y = sponge[, 3]
trainx = sponge[, -3]
set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
  gbmkrigegbmidwcv1 &lt;- gbmkrigeidwcv(longlat = longlat,
  trainx = trainx, trainy = y, family = "poisson", interaction.depth = 3,
  transformation = "none", formula = res1 ~ 1, vgm.args = ("Sph"),
  nmaxkrige = 12, idp = 2, nmaxidw = 12, hybrid.parameter = 2, validation = "CV",
  predacc = "VEcv", n.cores = 2)
  VEcv [i] &lt;- gbmkrigegbmidwcv1
 }
 plot(VEcv ~ c(1:n), xlab = "Iteration for gbmokgbmidw", ylab = "VEcv (%)")
 points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
 abline(h = mean(VEcv), col = 'blue', lwd = 2)


</code></pre>


</div>