<div class="container">

<table style="width: 100%;"><tr>
<td>posdefify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find a Close Positive Definite Matrix</h2>

<h3>Description</h3>

<p>From a matrix <code>m</code>, construct a <em>"close"</em> positive definite
one.
</p>


<h3>Usage</h3>

<pre><code class="language-R">posdefify(m, method = c("someEVadd", "allEVadd"),
          symmetric = TRUE, eigen.m = eigen(m, symmetric= symmetric),
          eps.ev = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a numeric (square) matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string specifying the method to apply; can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>logical, simply passed to <code>eigen</code> (unless
<code>eigen.m</code> is specified); currently, we do not see any reason
for <em>not</em> using <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigen.m</code></td>
<td>
<p>the <code>eigen</code> value decomposition of
<code>m</code>, can be specified in case it is already available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.ev</code></td>
<td>
<p>number specifying the tolerance to use, see Details
below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We form the eigen decomposition
</p>
<p style="text-align: center;"><code class="reqn">m = V \Lambda V'</code>
</p>
<p> where <code class="reqn">\Lambda</code> is the
diagonal matrix of eigenvalues, <code class="reqn">\Lambda_{j,j} = \lambda_j</code>, with <em>decreasing</em> eigenvalues <code class="reqn">\lambda_1 \ge
    \lambda_2 \ge \ldots \ge \lambda_n</code>.
</p>
<p>When the smallest eigenvalue <code class="reqn">\lambda_n</code> are less than
<code>Eps &lt;- eps.ev * abs(lambda[1])</code>, i.e., negative or “almost
zero”, some or all eigenvalues are replaced by <em>positive</em>
(<code>&gt;= Eps</code>) values,
<code class="reqn">\tilde\Lambda_{j,j} = \tilde\lambda_j</code>.
Then, <code class="reqn">\tilde m = V \tilde\Lambda V'</code> is computed
and rescaled in order to keep the original diagonal (where that is
<code>&gt;= Eps</code>).
</p>


<h3>Value</h3>

<p>a matrix of the same dimensions and the “same” diagonal
(i.e. <code>diag</code>) as <code>m</code> but with the property to
be positive definite.
</p>


<h3>Note</h3>

<p>As we found out, there are more sophisticated algorithms to solve
this and related problems.  See the references and the
<code>nearPD()</code> function in the <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package.
We consider <code>nearPD()</code> to also be the successor of this package's <code>nearcor()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, July 2004</p>


<h3>References</h3>

<p>Section 4.4.2 of
Gill, P.~E., Murray, W. and Wright, M.~H. (1981)
<em>Practical Optimization</em>, Academic Press.
</p>
<p>Cheng, Sheung Hun and Higham, Nick (1998)
A Modified Cholesky Algorithm Based on a Symmetric Indefinite Factorization;
<em>SIAM J. Matrix Anal.\ Appl.</em>, <b>19</b>, 1097–1110.
</p>
<p>Knol DL, ten Berge JMF (1989)
Least-squares approximation of an improper correlation matrix by a
proper one.
<em>Psychometrika</em> <b>54</b>, 53–61.
</p>
<p>Highham (2002)
Computing the nearest correlation matrix - a problem from finance;
<em>IMA Journal of Numerical Analysis</em> <b>22</b>, 329–343.
</p>
<p>Lucas (2001)
Computing nearest covariance and correlation matrices.  A thesis
submitted to the University of Manchester for the degree of Master of
Science in the Faculty of Science and Engeneering.
</p>


<h3>See Also</h3>

<p><code>eigen</code> on which the current methods rely.
<code>nearPD()</code> in the <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package.
(Further, the deprecated <code>nearcor()</code> from this package.)
</p>


<h3>Examples</h3>

<pre><code class="language-R"> set.seed(12)
 m &lt;- matrix(round(rnorm(25),2), 5, 5); m &lt;- 1+ m + t(m); diag(m) &lt;- diag(m) + 4
 m
 posdefify(m)
 1000 * zapsmall(m - posdefify(m))
</code></pre>


</div>