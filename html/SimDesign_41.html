<div class="container">

<table style="width: 100%;"><tr>
<td>SFA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surrogate Function Approximation via the Generalized Linear Model</h2>

<h3>Description</h3>

<p>Given a simulation that was executed with <code>runSimulation</code>,
potentially with the argument <code>store_results = TRUE</code> to store the
unsummarised analysis results, fit a surrogate function approximation (SFA)
model to the results and (optionally) perform a root-solving
step to solve a target quantity. See Schoemann et al. (2014) for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SFA(
  results,
  formula,
  family = "binomial",
  b = NULL,
  design = NULL,
  CI = 0.95,
  interval = NULL,
  ...
)

## S3 method for class 'SFA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>results</code></td>
<td>
<p>data returned from <code>runSimulation</code>. This can be
the original results object or the extracted results stored when using
<code>store_results = TRUE</code> included to store the analysis results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula to specify for the regression model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>character vector indicating the family of GLMs to use
(see <code>family</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>(optional) Target quantity to use for root solving given the fitted
surrogate function (e.g., find sample size associated with SFA implied power of .80)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>(optional) <code>data.frame</code> object containing all the information
relevant for the surrogate model (passed to <code>newdata</code> in
<code>predict</code>) with an <code>NA</code> value in the variable to be solved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI</code></td>
<td>
<p>advertised confidence interval of SFA prediction around solved target</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>interval to be passed to <code>uniroot</code> if not specified then
the lowest and highest values from <code>results</code> for the respective variable
will be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to pass to <code>glm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>SFA</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R. P., &amp; Adkins, M. C.  (2020). Writing Effective and Reliable Monte Carlo Simulations
with the SimDesign Package. <code>The Quantitative Methods for Psychology, 16</code>(4), 248-280.
<a href="https://doi.org/10.20982/tqmp.16.4.p248">doi:10.20982/tqmp.16.4.p248</a>
</p>
<p>Schoemann, A. M., Miller, P., Pornprasertmanit, S., and Wu, W. (2014).
Using Monte Carlo simulations to determine power and sample size for planned
missing designs. <em>International Journal of Behavioral Development,
SAGE Publications, 38</em>, 471-479.
</p>


<h3>See Also</h3>

<p><code>runSimulation</code>, <code>SimSolve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# create long Design object to fit surrogate over
Design &lt;- createDesign(N = 100:500,
                       d = .2)
Design

#~~~~~~~~~~~~~~~~~~~~~~~~
#### Step 2 --- Define generate, analyse, and summarise functions

Generate &lt;- function(condition, fixed_objects) {
    Attach(condition)
    group1 &lt;- rnorm(N)
    group2 &lt;- rnorm(N, mean=d)
    dat &lt;- data.frame(group = gl(2, N, labels=c('G1', 'G2')),
                      DV = c(group1, group2))
    dat
}

Analyse &lt;- function(condition, dat, fixed_objects) {
    p &lt;- c(p = t.test(DV ~ group, dat, var.equal=TRUE)$p.value)
    p
}

Summarise &lt;- function(condition, results, fixed_objects) {
    ret &lt;- EDR(results, alpha = .05)
    ret
}

#~~~~~~~~~~~~~~~~~~~~~~~~
#### Step 3 --- Estimate power over N

# Use small number of replications given range of sample sizes
## note that due to the lower replications disabling the
## RAM printing will help reduce overhead

sim &lt;- runSimulation(design=Design, replications=10,
                     generate=Generate, analyse=Analyse,
                     summarise=Summarise, store_results=TRUE, save=FALSE,
                     progress=FALSE, control=list(print_RAM=FALSE))
sim

# total of 4010 replication
sum(sim$REPLICATIONS)

# use the unsummarised results for the SFA, and include p.values &lt; alpha
sim_results &lt;- SimResults(sim)
sim_results &lt;- within(sim_results, sig &lt;- p &lt; .05)
sim_results

# fitted model
sfa &lt;- SFA(sim_results, formula = sig ~ N)
sfa
summary(sfa)

# plot the observed and SFA expected values
plot(p ~ N, sim, las=1, pch=16, main='Rejection rates with R=10')
pred &lt;- predict(sfa, type = 'response')
lines(sim_results$N, pred, col='red', lty=2)

# fitted model + root-solved solution given f(.) = b,
#   where b = target power of .8
design &lt;- data.frame(N=NA, d=.2)
sfa.root &lt;- SFA(sim_results, formula = sig ~ N,
                b=.8, design=design)
sfa.root

# true root
pwr::pwr.t.test(power=.8, d=.2)


################
# example with smaller range but higher precision
Design &lt;- createDesign(N = 375:425,
                       d = .2)
Design

sim2 &lt;- runSimulation(design=Design, replications=100,
                     generate=Generate, analyse=Analyse,
                     summarise=Summarise, store_results=TRUE, save=FALSE,
                     progress=FALSE, control=list(print_RAM=FALSE))
sim2
sum(sim2$REPLICATIONS) # more replications in total

# use the unsummarised results for the SFA, and include p.values &lt; alpha
sim_results &lt;- SimResults(sim2)
sim_results &lt;- within(sim_results, sig &lt;- p &lt; .05)
sim_results

# fitted model
sfa &lt;- SFA(sim_results, formula = sig ~ N)
sfa
summary(sfa)

# plot the observed and SFA expected values
plot(p ~ N, sim2, las=1, pch=16, main='Rejection rates with R=100')
pred &lt;- predict(sfa, type = 'response')
lines(sim_results$N, pred, col='red', lty=2)

# fitted model + root-solved solution given f(.) = b,
#   where b = target power of .8
design &lt;- data.frame(N=NA, d=.2)
sfa.root &lt;- SFA(sim_results, formula = sig ~ N,
                b=.8, design=design, interval=c(100, 500))
sfa.root

# true root
pwr::pwr.t.test(power=.8, d=.2)

###################
# vary multiple parameters (e.g., sample size + effect size) to fit
# multi-parameter surrogate

Design &lt;- createDesign(N = seq(from=10, to=500, by=10),
                       d = seq(from=.1, to=.5, by=.1))
Design

sim3 &lt;- runSimulation(design=Design, replications=50,
                      generate=Generate, analyse=Analyse,
                      summarise=Summarise, store_results=TRUE, save=FALSE,
                      progress=FALSE, control=list(print_RAM=FALSE))
sim3
sum(sim3$REPLICATIONS)

# use the unsummarised results for the SFA, and include p.values &lt; alpha
sim_results &lt;- SimResults(sim3)
sim_results &lt;- within(sim_results, sig &lt;- p &lt; .05)
sim_results

# additive effects (logit(sig) ~ N + d)
sfa0 &lt;- SFA(sim_results, formula = sig ~ N+d)
sfa0

# multiplicative effects (logit(sig) ~ N + d + N:d)
sfa &lt;- SFA(sim_results, formula = sig ~ N*d)
sfa

# multiplicative better fit (sample size interacts with effect size)
anova(sfa0, sfa, test = "LRT")
summary(sfa)

# plot the observed and SFA expected values
library(ggplot2)
sim3$pred &lt;- predict(sfa, type = 'response', newdata=sim3)
ggplot(sim3, aes(N, p, color = factor(d))) +
  geom_point() + geom_line(aes(y=pred)) +
  facet_wrap(~factor(d))

# fitted model + root-solved solution given f(.) = b,
#   where b = target power of .8
design &lt;- data.frame(N=NA, d=.2)
sfa.root &lt;- SFA(sim_results, formula = sig ~ N * d,
                b=.8, design=design, interval=c(100, 500))
sfa.root

# true root
pwr::pwr.t.test(power=.8, d=.2)

# root prediction where d *not* used in original data
design &lt;- data.frame(N=NA, d=.25)
sfa.root &lt;- SFA(sim_results, formula = sig ~ N * d,
                b=.8, design=design, interval=c(100, 500))
sfa.root

# true root
pwr::pwr.t.test(power=.8, d=.25)


## End(Not run)

</code></pre>


</div>