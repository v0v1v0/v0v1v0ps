<div class="container">

<table style="width: 100%;"><tr>
<td>spatial_kernel_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computation of Spatial Kernel Matrices
</h2>

<h3>Description</h3>

<p><code>spatial_kernel_matrix</code> computes spatial kernel matrices for a given kernel function with its parameters and a set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatial_kernel_matrix(coords, kernel_type = c('ring', 'ball', 'gauss'), 
                      kernel_parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>

<p>a character string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two versions of local covariance matrices can be defined:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li>
</ul>
<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The function <code>spatial_kernel_matrix</code> computes a list of <code>c(n,n)</code> matrices where each entry of these matrices correspond to the spatial kernel function evaluated at the distance between two points, mathematically the entry ij of each kernel matrix is <code class="reqn">f(d_{i,j})</code>. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_i, r_o) = I(r_i &lt; d \le r_o)</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2)</code>
</p>

</li>
</ul>
<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> spatial kernel matrices of type <code>kernel_type</code> are computed. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_i1, r_o1, r_i2, r_o2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> spatial kernel matrices of type <code>'ring'</code> are computed.
</p>
<p>The output of this function can be used with the function <code>sbss</code> to avoid unnecessary computation of kernel matrices when <code>sbss</code> is called multiple times with the same coordinate/kernel function setting. Additionally, the output can be used with the function <code>local_covariance_matrix</code> to actually compute local covariance matrices as defined above based on a given set of spatial kernel matrices.
</p>


<h3>Value</h3>

<p><code>spatial_kernel_matrix</code> returns a list with length of <code>length(kernel_parameters)</code> (for <code>'ball'</code> and <code>'gauss'</code> kernel functions) or <code>length(kernel_parameters) / 2</code> (for <code>'ring'</code> kernel function) containing numeric matrices of dimension <code>c(n,n)</code> corresponding to the spatial kernel matrices.
</p>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>local_covariance_matrix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate a set of coordinates
coords &lt;- rnorm(100 * 2)
dim(coords) &lt;- c(100, 2)

# computing two ring kernel matrices
kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
ring_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'ring', kernel_params_ring)

# computing three ball kernel matrices
kernel_params_ball &lt;- c(0.5, 1, 2)
ball_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'ball', kernel_params_ball)

# computing three gauss kernel matrices
kernel_params_gauss &lt;- c(0.5, 1, 2)
gauss_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)

</code></pre>


</div>