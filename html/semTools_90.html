<div class="container">

<table style="width: 100%;"><tr>
<td>partialInvariance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partial Measurement Invariance Testing Across Groups</h2>

<h3>Description</h3>

<p>This test will provide partial invariance testing by (a) freeing a parameter
one-by-one from nested model and compare with the original nested model or
(b) fixing (or constraining) a parameter one-by-one from the parent model
and compare with the original parent model. This function only works with
congeneric models. The <code>partialInvariance</code> is used for continuous
variable. The <code>partialInvarianceCat</code> is used for categorical variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">partialInvariance(fit, type, free = NULL, fix = NULL, refgroup = 1,
  poolvar = TRUE, p.adjust = "none", fbound = 2, return.fit = FALSE,
  method = "satorra.bentler.2001")

partialInvarianceCat(fit, type, free = NULL, fix = NULL, refgroup = 1,
  poolvar = TRUE, p.adjust = "none", return.fit = FALSE,
  method = "satorra.bentler.2001")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>A list of models for invariance testing. Each model should be
assigned by appropriate names (see details). The result from
<code>measurementInvariance</code> or
<code>measurementInvarianceCat</code> could be used in this argument
directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The types of invariance testing: "metric", "scalar", "strict",
or "means"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>free</code></td>
<td>
<p>A vector of variable names that are free across groups in
advance. If partial mean invariance is tested, this argument represents a
vector of factor names that are free across groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix</code></td>
<td>
<p>A vector of variable names that are constrained to be equal
across groups in advance. If partial mean invariance is tested, this
argument represents a vector of factor names that are fixed across groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refgroup</code></td>
<td>
<p>The reference group used to make the effect size comparison
with the other groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poolvar</code></td>
<td>
<p>If <code>TRUE</code>, the variances are pooled across group for
standardization. Otherwise, the variances of the reference group are used
for standardization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.adjust</code></td>
<td>
<p>The method used to adjust p values. See
<code>p.adjust</code> for the options for adjusting p values. The
default is to not use any corrections.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fbound</code></td>
<td>
<p>The z-scores of factor that is used to calculate the effect
size of the loading difference proposed by Millsap and Olivera-Aguilar
(2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.fit</code></td>
<td>
<p>Return the submodels fitted by this function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used to calculate likelihood ratio test. See
<code>lavTestLRT</code> for available options</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are four types of partial invariance testing:
</p>

<ul>
<li>
<p> Partial weak invariance. The model named 'fit.configural'
from the list of models is compared with the model named 'fit.loadings'.
Each loading will be freed or fixed from the metric and configural
invariance models respectively. The modified models are compared with the
original model. Note that the objects in the list of models must have the
names of "fit.configural" and "fit.loadings". Users may use "metric",
"weak", "loading", or "loadings" in the <code>type</code> argument. Note that, for
testing invariance on marker variables, other variables will be assigned as
marker variables automatically.
</p>
</li>
<li>
<p> Partial strong invariance. The model
named 'fit.loadings' from the list of models is compared with the model
named either 'fit.intercepts' or 'fit.thresholds'. Each intercept will be
freed or fixed from the scalar and metric invariance models respectively.
The modified models are compared with the original model. Note that the
objects in the list of models must have the names of "fit.loadings" and
either "fit.intercepts" or "fit.thresholds". Users may use "scalar",
"strong", "intercept", "intercepts", "threshold", or "thresholds" in the
<code>type</code> argument. Note that, for testing invariance on marker variables,
other variables will be assigned as marker variables automatically. Note
that if all variables are dichotomous, scalar invariance testing is not
available.
</p>
</li>
<li>
<p> Partial strict invariance. The model named either
'fit.intercepts' or 'fit.thresholds' (or 'fit.loadings') from the list of
models is compared with the model named 'fit.residuals'. Each residual
variance will be freed or fixed from the strict and scalar (or metric)
invariance models respectively. The modified models are compared with the
original model. Note that the objects in the list of models must have the
names of "fit.residuals" and either "fit.intercepts", "fit.thresholds", or
"fit.loadings". Users may use "strict", "residual", "residuals", "error", or
"errors" in the <code>type</code> argument.
</p>
</li>
<li>
<p> Partial mean invariance. The
model named either 'fit.intercepts' or 'fit.thresholds' (or 'fit.residuals'
or 'fit.loadings') from the list of models is compared with the model named
'fit.means'. Each factor mean will be freed or fixed from the means and
scalar (or strict or metric) invariance models respectively. The modified
models are compared with the original model. Note that the objects in the
list of models must have the names of "fit.means" and either
"fit.residuals", "fit.intercepts", "fit.thresholds", or "fit.loadings".
Users may use "means" or "mean" in the <code>type</code> argument. </p>
</li>
</ul>
<p>Two types of comparisons are used in this function:
</p>

<ol>
<li> <p><code>free</code>: The nested model is used as a template. Then, one
parameter indicating the differences between two models is free. The new
model is compared with the nested model. This process is repeated for all
differences between two models. The likelihood-ratio test and the difference
in CFI are provided.
</p>
</li>
<li> <p><code>fix</code>: The parent model is used as a template. Then, one parameter
indicating the differences between two models is fixed or constrained to be
equal to other parameters. The new model is then compared with the parent
model. This process is repeated for all differences between two models. The
likelihood-ratio test and the difference in CFI are provided.
</p>
</li>
<li> <p><code>wald</code>: This method is similar to the <code>fix</code> method. However,
instead of building a new model and compare them with likelihood-ratio test,
multivariate wald test is used to compare equality between parameter
estimates. See <code>lavTestWald</code> for further details. Note
that if any rows of the contrast cannot be summed to 0, the Wald test is not
provided, such as comparing two means where one of the means is fixed as 0.
This test statistic is not as accurate as likelihood-ratio test provided in
<code>fix</code>. I provide it here in case that likelihood-ratio test fails to
converge.
</p>
</li>
</ol>
<p>Note that this function does not adjust for the inflated Type I error rate
from multiple tests. The degree of freedom of all tests would be the number
of groups minus 1.
</p>
<p>The details of standardized estimates and the effect size used for each
parameters are provided in the vignettes by running
<code>vignette("partialInvariance")</code>.
</p>


<h3>Value</h3>

<p>A list of results are provided. The list will consists of at least
two elements:
</p>

<ol>
<li> <p><code>estimates</code>: The results of parameter estimates including pooled
estimates (<code>poolest</code>), the estimates for each group, standardized
estimates for each group (<code>std</code>), the difference in standardized
values, and the effect size statistic (<em>q</em> for factor loading
difference and <em>h</em> for error variance difference). See the details of
this effect size statistic by running <code>vignette("partialInvariance")</code>.
In the <code>partialInvariance</code> function, the additional effect statistics
proposed by Millsap and Olivera-Aguilar (2012) are provided. For factor
loading, the additional outputs are the observed mean difference
(<code>diff_mean</code>), the mean difference if factor scores are low
(<code>low_fscore</code>), and the mean difference if factor scores are high
(<code>high_fscore</code>). The low factor score is calculated by (a) finding the
factor scores that its <em>z</em> score equals -<code>bound</code> (the default is
<code class="reqn">-2</code>) from all groups and (b) picking the minimum value among the
factor scores. The high factor score is calculated by (a) finding the
factor scores that its <em>z</em> score equals <code>bound</code> (default = 2)
from all groups and (b) picking the maximum value among the factor scores.
For measurement intercepts, the additional outputs are the observed means
difference (<code>diff_mean</code>) and the proportion of the differences in the
intercepts over the observed means differences (<code>propdiff</code>). For error
variances, the additional outputs are the proportion of the difference in
error variances over the difference in observed variances (<code>propdiff</code>).
</p>
</li>
<li> <p><code>results</code>: Statistical tests as well as the change in CFI are
provided. <code class="reqn">\chi^2</code> and <em>p</em> value are provided for all methods.
</p>
</li>
<li> <p><code>models</code>: The submodels used in the <code>free</code> and <code>fix</code>
methods, as well as the nested and parent models. The nested and parent
models will be changed from the original models if <code>free</code> or
<code>fit</code> arguments are specified.
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Sunthud Pornprasertmanit (<a href="mailto:psunthud@gmail.com">psunthud@gmail.com</a>)
</p>


<h3>References</h3>

<p>Millsap, R. E., &amp; Olivera-Aguilar, M. (2012). Investigating
measurement invariance using confirmatory factor analysis. In R. H. Hoyle
(Ed.), <em>Handbook of structural equation modeling</em> (pp. 380â€“392). New
York, NY: Guilford.
</p>


<h3>See Also</h3>

<p><code>measurementInvariance</code> for measurement invariance for
continuous variables; <code>measurementInvarianceCat</code> for measurement
invariance for categorical variables; <code>lavTestWald</code> for
multivariate Wald test
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Conduct weak invariance testing manually by using fixed-factor
## method of scale identification

library(lavaan)

conf &lt;- "
f1 =~ NA*x1 + x2 + x3
f2 =~ NA*x4 + x5 + x6
f1 ~~ c(1, 1)*f1
f2 ~~ c(1, 1)*f2
"

weak &lt;- "
f1 =~ NA*x1 + x2 + x3
f2 =~ NA*x4 + x5 + x6
f1 ~~ c(1, NA)*f1
f2 ~~ c(1, NA)*f2
"

configural &lt;- cfa(conf, data = HolzingerSwineford1939, std.lv = TRUE, group="school")
weak &lt;- cfa(weak, data = HolzingerSwineford1939, group="school", group.equal="loadings")
models &lt;- list(fit.configural = configural, fit.loadings = weak)
partialInvariance(models, "metric")

## Not run: 
partialInvariance(models, "metric", free = "x5") # "x5" is free across groups in advance
partialInvariance(models, "metric", fix = "x4") # "x4" is fixed across groups in advance

## Use the result from the measurementInvariance function
HW.model &lt;- ' visual =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed =~ x7 + x8 + x9 '

models2 &lt;- measurementInvariance(model = HW.model, data=HolzingerSwineford1939,
                                 group="school")
partialInvariance(models2, "scalar")

## Conduct weak invariance testing manually by using fixed-factor
## method of scale identification for dichotomous variables

f &lt;- rnorm(1000, 0, 1)
u1 &lt;- 0.9*f + rnorm(1000, 1, sqrt(0.19))
u2 &lt;- 0.8*f + rnorm(1000, 1, sqrt(0.36))
u3 &lt;- 0.6*f + rnorm(1000, 1, sqrt(0.64))
u4 &lt;- 0.7*f + rnorm(1000, 1, sqrt(0.51))
u1 &lt;- as.numeric(cut(u1, breaks = c(-Inf, 0, Inf)))
u2 &lt;- as.numeric(cut(u2, breaks = c(-Inf, 0.5, Inf)))
u3 &lt;- as.numeric(cut(u3, breaks = c(-Inf, 0, Inf)))
u4 &lt;- as.numeric(cut(u4, breaks = c(-Inf, -0.5, Inf)))
g &lt;- rep(c(1, 2), 500)
dat2 &lt;- data.frame(u1, u2, u3, u4, g)

configural2 &lt;- "
f1 =~ NA*u1 + u2 + u3 + u4
u1 | c(t11, t11)*t1
u2 | c(t21, t21)*t1
u3 | c(t31, t31)*t1
u4 | c(t41, t41)*t1
f1 ~~ c(1, 1)*f1
f1 ~ c(0, NA)*1
u1 ~~ c(1, 1)*u1
u2 ~~ c(1, NA)*u2
u3 ~~ c(1, NA)*u3
u4 ~~ c(1, NA)*u4
"

outConfigural2 &lt;- cfa(configural2, data = dat2, group = "g",
                      parameterization = "theta", estimator = "wlsmv",
                      ordered = c("u1", "u2", "u3", "u4"))

weak2 &lt;- "
f1 =~ NA*u1 + c(f11, f11)*u1 + c(f21, f21)*u2 + c(f31, f31)*u3 + c(f41, f41)*u4
u1 | c(t11, t11)*t1
u2 | c(t21, t21)*t1
u3 | c(t31, t31)*t1
u4 | c(t41, t41)*t1
f1 ~~ c(1, NA)*f1
f1 ~ c(0, NA)*1
u1 ~~ c(1, 1)*u1
u2 ~~ c(1, NA)*u2
u3 ~~ c(1, NA)*u3
u4 ~~ c(1, NA)*u4
"

outWeak2 &lt;- cfa(weak2, data = dat2, group = "g", parameterization = "theta",
                estimator = "wlsmv", ordered = c("u1", "u2", "u3", "u4"))
modelsCat &lt;- list(fit.configural = outConfigural2, fit.loadings = outWeak2)

partialInvarianceCat(modelsCat, type = "metric")

partialInvarianceCat(modelsCat, type = "metric", free = "u2")
partialInvarianceCat(modelsCat, type = "metric", fix = "u3")

## Use the result from the measurementInvarianceCat function

model &lt;- ' f1 =~ u1 + u2 + u3 + u4
           f2 =~ u5 + u6 + u7 + u8'

modelsCat2 &lt;- measurementInvarianceCat(model = model, data = datCat, group = "g",
	                                      parameterization = "theta",
	                                      estimator = "wlsmv", strict = TRUE)

partialInvarianceCat(modelsCat2, type = "scalar")

## End(Not run)

</code></pre>


</div>