<div class="container">

<table style="width: 100%;"><tr>
<td>Stcp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stcp Class</h2>

<h3>Description</h3>

<p>Stcp class supports a unified framework for sequential tests and change
detection algorithms for streams of univariate (sub-)Gaussian, binary,
and bounded random variables.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Stcp-new"><code>Stcp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-print"><code>Stcp$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getWeights"><code>Stcp$getWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getLambdas"><code>Stcp$getLambdas()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getLogValue"><code>Stcp$getLogValue()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getThreshold"><code>Stcp$getThreshold()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-isStopped"><code>Stcp$isStopped()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getTime"><code>Stcp$getTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-getStoppedTime"><code>Stcp$getStoppedTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-reset"><code>Stcp$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValues"><code>Stcp$updateLogValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesUntilStop"><code>Stcp$updateLogValuesUntilStop()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateAndReturnHistories"><code>Stcp$updateAndReturnHistories()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesByAvgs"><code>Stcp$updateLogValuesByAvgs()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateLogValuesUntilStopByAvgs"><code>Stcp$updateLogValuesUntilStopByAvgs()</code></a>
</p>
</li>
<li> <p><a href="#method-Stcp-updateAndReturnHistoriesByAvgs"><code>Stcp$updateAndReturnHistoriesByAvgs()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Stcp-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new Stcp object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$new(
  method = c("ST", "SR", "CU", "GLRCU"),
  family = c("Normal", "Ber", "Bounded"),
  alternative = c("two.sided", "greater", "less"),
  threshold = log(1/0.05),
  m_pre = 0,
  delta_lower = 0.1,
  delta_upper = NULL,
  weights = NULL,
  lambdas = NULL,
  k_max = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>Method of the sequential procedure.
</p>

<ul>
<li>
<p> ST: Sequential test based on a mixture of E-values.
</p>
</li>
<li>
<p> SR: Sequential change detection based on e-SR procedure.
</p>
</li>
<li>
<p> CU: Sequential change detection based on e-CUSUM procedure.
</p>
</li>
<li>
<p> GLRCU: Sequential change detection based on GLR-CUSUM procedure.
</p>
</li>
</ul>
</dd>
<dt><code>family</code></dt>
<dd>
<p>Distribution of underlying univariate observations.
</p>

<ul>
<li>
<p> Normal: (sub-)Gaussian with sigma = 1.
</p>
</li>
<li>
<p> Ber: Bernoulli distribution on {0,1}.
</p>
</li>
<li>
<p> Bounded: General bounded distribution on [0,1]
</p>
</li>
</ul>
</dd>
<dt><code>alternative</code></dt>
<dd>
<p>Alternative / post-change mean space
</p>

<ul>
<li>
<p> two.sided: Two-sided test / change detection
</p>
</li>
<li>
<p> greater: Alternative /post-change mean is greater than null / pre-change one
</p>
</li>
<li>
<p> less:  Alternative /post-change mean is less than null / pre-change one
</p>
</li>
</ul>
</dd>
<dt><code>threshold</code></dt>
<dd>
<p>Stopping threshold. We recommend to use log(1/alpha)
for "ST" and "SR" methods where alpha is a testing level or 1/ARL.
for "CU" and "GRLCU", we recommend to tune the threshold by using
domain-specific sampler to hit the target ARL.</p>
</dd>
<dt><code>m_pre</code></dt>
<dd>
<p>The boundary of mean parameter in null / pre-change space</p>
</dd>
<dt><code>delta_lower</code></dt>
<dd>
<p>Minimum gap between null / pre-change space and
alternative / post-change one. It must be strictly positive for ST, SR and CU.
Currently, GLRCU does not support the minimum gap, and this param will be ignored.</p>
</dd>
<dt><code>delta_upper</code></dt>
<dd>
<p>Maximum gap between null / pre-change space and
alternative / post-change one. It must be strictly positive for ST, SR and CU.
Currently, GLRCU does not support the maximum gap, and this param will be ignored.</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>If not null, the input weights will be used to initialize Stcp object.</p>
</dd>
<dt><code>lambdas</code></dt>
<dd>
<p>If not null, the input lambdas will be used to initialize Stcp object.</p>
</dd>
<dt><code>k_max</code></dt>
<dd>
<p>Positive integer to determine the maximum number of baselines.
For GLRCU method, it is used as the lookup window size for GLRCU statistics.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>Stcp</code> object.
</p>


<hr>
<a id="method-Stcp-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print summary of Stcp object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$print()</pre></div>


<hr>
<a id="method-Stcp-getWeights"></a>



<h4>Method <code>getWeights()</code>
</h4>

<p>Return weights of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getWeights()</pre></div>


<hr>
<a id="method-Stcp-getLambdas"></a>



<h4>Method <code>getLambdas()</code>
</h4>

<p>Return lambda parameters of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getLambdas()</pre></div>


<hr>
<a id="method-Stcp-getLogValue"></a>



<h4>Method <code>getLogValue()</code>
</h4>

<p>Return the log value of mixture of e-values / e-detectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getLogValue()</pre></div>


<hr>
<a id="method-Stcp-getThreshold"></a>



<h4>Method <code>getThreshold()</code>
</h4>

<p>Return the threshold of the sequential test / change detection
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getThreshold()</pre></div>


<hr>
<a id="method-Stcp-isStopped"></a>



<h4>Method <code>isStopped()</code>
</h4>

<p>Return TRUE if the sequential test / change detection was stopped by crossing the threshold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$isStopped()</pre></div>


<hr>
<a id="method-Stcp-getTime"></a>



<h4>Method <code>getTime()</code>
</h4>

<p>Return the number of observations having been passed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getTime()</pre></div>


<hr>
<a id="method-Stcp-getStoppedTime"></a>



<h4>Method <code>getStoppedTime()</code>
</h4>

<p>Return the stopped time. If it has been never stopped, return zero.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$getStoppedTime()</pre></div>


<hr>
<a id="method-Stcp-reset"></a>



<h4>Method <code>reset()</code>
</h4>

<p>Reset the stcp object to the initial setup.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$reset()</pre></div>


<hr>
<a id="method-Stcp-updateLogValues"></a>



<h4>Method <code>updateLogValues()</code>
</h4>

<p>Update the log value and related fields by passing a vector of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValues(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt>
<dd>
<p>A numeric vector of observations.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Stcp-updateLogValuesUntilStop"></a>



<h4>Method <code>updateLogValuesUntilStop()</code>
</h4>

<p>Update the log value and related fields until the log value is crossing the boundary.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesUntilStop(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt>
<dd>
<p>A numeric vector of observations.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Stcp-updateAndReturnHistories"></a>



<h4>Method <code>updateAndReturnHistories()</code>
</h4>

<p>Update the log value and related fields then return updated log values by passing a vector of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateAndReturnHistories(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt>
<dd>
<p>A numeric vector of observations.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Stcp-updateLogValuesByAvgs"></a>



<h4>Method <code>updateLogValuesByAvgs()</code>
</h4>

<p>Update the log value and related fields by passing
a vector of averages and number of corresponding samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt>
<dd>
<p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt>
<dd>
<p>A numeric vector of sample sizes.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Stcp-updateLogValuesUntilStopByAvgs"></a>



<h4>Method <code>updateLogValuesUntilStopByAvgs()</code>
</h4>

<p>Update the log value and related fields by passing
a vector of averages and number of corresponding samples
until the log value is crossing the boundary.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateLogValuesUntilStopByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt>
<dd>
<p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt>
<dd>
<p>A numeric vector of sample sizes.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Stcp-updateAndReturnHistoriesByAvgs"></a>



<h4>Method <code>updateAndReturnHistoriesByAvgs()</code>
</h4>

<p>Update the log value and related fields then return updated log values
a vector of averages and number of corresponding samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stcp$updateAndReturnHistoriesByAvgs(x_bars, ns)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_bars</code></dt>
<dd>
<p>A numeric vector of averages.</p>
</dd>
<dt><code>ns</code></dt>
<dd>
<p>A numeric vector of sample sizes.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># Sequential Normal mean test H0: mu &lt;= 0
# Initialize stcp object for this test.
stcp &lt;- Stcp$new(method = "ST",
                 family = "Normal",
                 alternative = "greater",
                 threshold = log(1 / 0.05),
                 m_pre = 0)

# Update the observations
obs &lt;- c(1.0, 3.0, 2.0)
stcp$updateLogValuesUntilStop(obs)

# Check whether the sequential test is stopped
stcp$isStopped() # TRUE

# Check when the test was stopped
stcp$getStoppedTime() # 3

# Although the number of obervaions was 4, the test was stopped at 3.
stcp$getTime() # 3

# Get the log value of the mixutre of e-values at the current time (3)
stcp$getLogValue() # 4.425555

# ...which is higher than the threshold log(1 / 0.05) ~ 2.996
stcp$getThreshold() # 2.995732

# Reset the test object
stcp$reset()

# Rerun the test but, at this time, we track updated log values
log_values &lt;- stcp$updateAndReturnHistories(obs)
print(log_values) # 0.1159777 2.7002207 4.4255551 1.9746508

# Again, the test was stopped at 3rd observation
stcp$getStoppedTime() # 3

# But, at this time, log values were evaluated until the 4th observation.
stcp$getTime() # 4

# Print overall summary
stcp # or stcp$print() or print(stcp)
# stcp Model:
#   - Method:  ST
# - Family:  Normal
# - Alternative:  greater
# - Alpha:  0.05
# - m_pre:  0
# - Num. of mixing components:  55
# - Obs. have been passed:  4
# - Current log value:  1.974651
# - Is stopped before:  TRUE
# - Stopped time:  3

</code></pre>


</div>