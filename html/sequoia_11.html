<div class="container">

<table style="width: 100%;"><tr>
<td>ComparePairs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compare Pairwise Relationships</h2>

<h3>Description</h3>

<p>Compare, count and identify different types of relative pairs
between two pedigrees, or within one pedigree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ComparePairs(
  Ped1 = NULL,
  Ped2 = NULL,
  Pairs2 = NULL,
  GenBack = 1,
  patmat = FALSE,
  ExcludeDummies = TRUE,
  DumPrefix = c("F0", "M0"),
  Return = "Counts"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Ped1</code></td>
<td>
<p>first (e.g. original/reference) pedigree, dataframe with 3
columns: id-dam-sire.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ped2</code></td>
<td>
<p>optional second (e.g. inferred) pedigree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pairs2</code></td>
<td>
<p>optional dataframe with as first three columns: ID1-ID2-
relationship, e.g. as returned by <code>GetMaybeRel</code>. Column names
and any additional columns are ignored. May be provided in addition to, or
instead of <code>Ped2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GenBack</code></td>
<td>
<p>number of generations back to consider; 1 returns
parent-offspring and sibling relationships, 2 also returns grandparental,
avuncular and first cousins. GenBack &gt;2 is not implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patmat</code></td>
<td>
<p>logical, distinguish between paternal versus maternal relative
pairs?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ExcludeDummies</code></td>
<td>
<p>logical, exclude dummy IDs from output? Individuals
with e.g. the same dummy father will still be counted as paternal halfsibs.
No attempt is made to match dummies in one pedigree to individuals in the
other pedigree; for that use <code>PedCompare</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DumPrefix</code></td>
<td>
<p>character vector with the prefixes identifying dummy
individuals. Use 'F0' ('M0') to avoid matching to regular individuals with
IDs starting with 'F' ('M'), provided <code>Ped2</code> has fewer than 999 dummy
females (males).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Return</code></td>
<td>
<p>return a matrix with <code>Counts</code> or a <code>Summary</code> of the
number of identical relationships and mismatches per relationship, or
detailed results as a 2xNxN <code>Array</code> or as a <code>Dataframe</code>.
<code>All</code> returns a list with all four.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>Pairs2</code> is as returned by <code>GetMaybeRel</code>
(identified by the additional column names 'LLR' and 'OH'), these
relationship categories are appended with an '?' in the output, to
distinguish them from those derived from <code>Ped2</code>.
</p>
<p>When <code>Pairs2$TopRel</code> contains values other than the ones listed among
the return values for the combination of <code>patmat</code> and <code>GenBack</code>,
they are prioritised in decreasing order of factor levels, or in decreasing
alphabetical order, and before the default (<code>ped2</code> derived) levels.
</p>
<p>The matrix returned by <code>DyadCompare</code> [Deprecated] is a subset
of the matrix returned here using default settings.
</p>


<h3>Value</h3>

<p>Depending on <code>Return</code>, one of the following, or a list with all:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Counts</code></td>
<td>
<p>(the default), a matrix with counts, with the classification in
<code>Ped1</code> on rows and that in <code>Ped2</code> in columns. Counts for
'symmetrical' pairs ("FS", "HS", "MHS", "PHS", "FC1", "DFC1", "U","X") are
divided by two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Summary</code></td>
<td>
<p>a matrix with one row per relationship type and four columns
, named as if <code>Ped1</code> is the true pedigree:
</p>

<dl>
<dt>n</dt>
<dd>
<p>total number of pairs with that relationship in <code>Ped1</code>,
and occurring in <code>Ped2</code></p>
</dd>
<dt>OK</dt>
<dd>
<p>Number of pairs with same relationship in <code>Ped2</code> as in
<code>Ped1</code></p>
</dd>
<dt>hi</dt>
<dd>
<p>Number of pairs with 'higher' relationship in <code>Ped2</code> as
in <code>Ped1</code> (e.g. FS instead of HS; ranking is the order given
below)</p>
</dd>
<dt>lo</dt>
<dd>
<p>Number of pairs with 'lower' relationship in <code>Ped2</code> as in
<code>Ped1</code>, but not unrelated in <code>Ped2</code></p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Array</code></td>
<td>
<p>a 2xNxN array (if <code>Ped2</code> or <code>Pairs2</code> is specified)
or a NxN matrix , where N is the total number of individuals occurring in
<code>Ped1</code> and/or <code>Ped2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dataframe</code></td>
<td>
<p>a dataframe with <code class="reqn">N^2</code> rows and four columns:
</p>

<dl>
<dt>id.A</dt>
<dd>
<p>First individual of the pair</p>
</dd>
<dt>id.B</dt>
<dd>
<p>Second individual of the pair</p>
</dd>
<dt>RC1</dt>
<dd>
<p>the relationship category in <code>Ped1</code>, as a factor with all
considered categories as levels, including those with 0 count</p>
</dd>
<dt>RC2</dt>
<dd>
<p>the relationship category in <code>Ped2</code></p>
</dd>
</dl>
<p>Each pair is listed twice, e.g. once as P and once as O, or twice as FS.</p>
</td>
</tr>
</table>
<h3>Relationship abbreviations and ranking</h3>

<p>By default (<code>GenBack=1, patmat=FALSE</code>) the following 7 relationships are
distinguished:
</p>

<ul>
<li> <p><strong>S</strong>: Self (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>MP</strong>: Parent
</p>
</li>
<li> <p><strong>O</strong>: Offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FS</strong>: Full sibling
</p>
</li>
<li> <p><strong>HS</strong>: Half sibling
</p>
</li>
<li> <p><strong>U</strong>: Unrelated, or otherwise related
</p>
</li>
<li> <p><strong>X</strong>: Either or both individuals not occurring in both
pedigrees
</p>
</li>
</ul>
<p>In the array and dataframe, 'MP' indicates that the second (column)
individual is the parent of the first (row) individual, and 'O' indicates the
reverse.
</p>
<p>When <code>GenBack=1, patmat=TRUE</code> the categories are (S)-M-P-(O)-FS-MHS-PHS-
U-X.
</p>
<p>When <code>GenBack=2, patmat=TRUE</code>, the following relationships are
distinguished:
</p>

<ul>
<li> <p><strong>S</strong>: Self (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>M</strong>: Mother
</p>
</li>
<li> <p><strong>P</strong>: Father
</p>
</li>
<li> <p><strong>O</strong>: Offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FS</strong>: Full sibling
</p>
</li>
<li> <p><strong>MHS</strong>: Maternal half-sibling
</p>
</li>
<li> <p><strong>PHS</strong>: Paternal half-sibling
</p>
</li>
<li> <p><strong>MGM</strong>: Maternal grandmother
</p>
</li>
<li> <p><strong>MGF</strong>: Maternal grandfather
</p>
</li>
<li> <p><strong>PGM</strong>: Paternal grandmother
</p>
</li>
<li> <p><strong>PGF</strong>: Paternal grandfather
</p>
</li>
<li> <p><strong>GO</strong>: Grand-offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FA</strong>: Full avuncular; maternal or paternal aunt or uncle
</p>
</li>
<li> <p><strong>HA</strong>: Half avuncular
</p>
</li>
<li> <p><strong>FN</strong>: Full nephew/niece (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>HN</strong>: Half nephew/niece (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FC1</strong>: Full first cousin
</p>
</li>
<li> <p><strong>DFC1</strong>: Double full first cousin
</p>
</li>
<li> <p><strong>U</strong>: Unrelated, or otherwise related
</p>
</li>
<li> <p><strong>X</strong>: Either or both individuals not occurring in both pedigrees
</p>
</li>
</ul>
<p>Note that for avuncular and cousin relationships no distinction is made
between paternal versus maternal, as this may differ between the two
individuals and would generate a large number of sub-classes. When a pair is
related via multiple paths, the first-listed relationship is returned. To get
all the different paths between a pair, use <code>GetRelM</code> with
<code>Return='Array'</code>.
</p>
<p>When <code>GenBack=2, patmat=FALSE</code>, MGM, MGF, PGM and PGF are combined
into GP, with the rest of the categories analogous to the above.
</p>


<h3>See Also</h3>

<p><code>PedCompare</code> for individual-based comparison;
<code>GetRelM</code> for a pairwise relationships matrix of a single
pedigree; <code>PlotRelPairs</code> for visualisation of relationships
within each pedigree.
</p>
<p>To estimate P(actual relationship (Ped1) | inferred relationship (Ped2)),
see examples at <code>EstConf</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">PairsG &lt;- ComparePairs(Ped_griffin, SeqOUT_griffin[["Pedigree"]],
                       patmat = TRUE, ExcludeDummies = TRUE, Return = "All")
PairsG$Counts

# pairwise correct assignment rate:
PairsG$Summary[,"OK"] / PairsG$Summary[,"n"]

# check specific pair:
PairsG$Array[, "i190_2010_M", "i168_2009_F"]
# or
RelDF &lt;- PairsG$Dataframe   # for brevity
RelDF[RelDF$id.A=="i190_2010_M" &amp; RelDF$id.B=="i168_2009_F", ]

# Colony-style lists of full sib dyads &amp; half sib dyads:
FullSibDyads &lt;- with(RelDF, RelDF[Ped1 == "FS" &amp; id.A &lt; id.B, ])
HalfSibDyads &lt;- with(RelDF, RelDF[Ped1 == "HS" &amp; id.A &lt; id.B, ])
# Use 'id.A &lt; id.B' because each pair is listed 2x

</code></pre>


</div>