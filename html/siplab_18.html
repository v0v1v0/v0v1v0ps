<div class="container">

<table style="width: 100%;"><tr>
<td>pairwise</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Compute Pairwise Competition Indices 
</h2>

<h3>Description</h3>


<p>This function computes competition indices based on pairs of plants, ignoring higher-order interactions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pairwise(plants, maxN = NULL, maxR = NULL, select = NULL, selpar =
         NULL, kernel, kerpar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>plants</code></td>
<td>


<p>A <span class="pkg">spatstat</span> point pattern object (class <code>ppp</code>). It contains the plants coordinates, and marks with the plant size and possibly other attributes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxN</code></td>
<td>


<p>Maximum number of nearest neighbors to include as potential competitors. Default is NULL (no restriction).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxR</code></td>
<td>


<p>Maximum radius to search for potential competitors. Default is NULL (no restriction).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>


<p>Optional user-supplied selection function for choosing competitors. Must take arguments <code>(imarks, jmarks, dists, dranks)</code> or <code>(imarks, jmarks, dists, dranks, par)</code>, where <code>imarks</code> are the marks for the subject plant (a 1-row data frame), <code>jmarks</code> is a data frame with the marks of the potential competitors, <code>dists</code> is a vector distances between subject plant and the potential competitors, <code>dranks</code> are the distance ranks, and <code>par</code> receives the value of the <code>selpar</code> argument if not <code>NULL</code>. It must return a logical vector with the same length as <code>dists</code>. Examples are provided in the functions <code>powlinear_sel()</code>, etc. (see select). Default is NULL (no selection).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selpar</code></td>
<td>


<p>Parameter(s) for <code>select</code>, usually a list or vector. Default: NULL. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>


<p>Competition kernel function for computing the effect of competitor <code class="reqn">j</code> on the subject plant <code class="reqn">i</code>. Must yake arguments <code>(imarks, jmarks, dists, dranks)</code> or <code>(imarks, jmarks, dists, dranks, par)</code>, where <code>imarks</code> are the marks for the subject plant (a 1-row data frame), <code>jmarks</code> is a data frame with the marks of the potential competitors, <code>dists</code> is a vector of distances between subject plant and the potential competitors, <code>dranks</code> are the distance ranks, and <code>par</code> receives the value of the <code>kerpar</code> argument if not <code>NULL</code>. It must return a numeric vector with the same length as <code>dists</code>. Examples are provided in the functions <code>powers_ker()</code>, etc. (see kernel).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kerpar</code></td>
<td>


<p>Parameter(s) for <code>kernel</code>, usually a list or vector. Default: NULL. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>Traditionally, the competition index for a subject plant <code class="reqn">i</code> is obtained in two stages: (1) Choose a set of competitors of <code class="reqn">i</code> by some selection rule. (2) Compute a measure of the effect of each competitor <code class="reqn">j</code> on plant <code class="reqn">i</code>, and add over <code class="reqn">j</code>. This effect of <code class="reqn">j</code> on <code class="reqn">i</code> is normally a function of the sizes of both plants and of the distance between them, which we call a competition kernel. The kernel may depend on other plant attributes, like species, and in some rare instances on the distance ranks or on the number of competitors. Conceptually, the first stage is not strictly necessary, it could be replaced by specifying zero kernel values (the effect of the selection is usually to truncate the kernel function beyond some distance). However, a separate selection rule may be more transparent, and may reduce the computational effort in searching for neighbors.
</p>
<p>Some simple selection rules can be implemented by giving a value to <code>maxN</code> and/or <code>maxR</code>. In any case, reasonable limits on these variables may be advisable for reducing computation.
</p>
<p>More complex rules can be specified by the <code>select</code> function, with parameters in <code>selpar</code>. See <code>select</code> for examples.  If more than one of <code>maxN</code>,  <code>maxR</code> or <code>select</code> are given, the intersection of the selection criteria is used.
</p>
<p>Kernel computation is specified by the <code>kernel</code> function and the parameters in <code>kerpar</code>. See <code>kernel</code> for examples.
</p>


<h3>Value</h3>






<p>Returns the input point pattern <code>plants</code>, with the marks replaced by a data frame containing the original marks followed by the competition index in a column named <code>cindex</code>. 
</p>


<h3>Note</h3>


<p>Requires the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>


<p>Oscar García.
</p>


<h3>References</h3>


<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>
<p>García, O. “Siplab, a spatial individual-based plant modelling system”. Computational Ecology and Software 4(4), 215-222. 2014.
</p>


<h3>See Also</h3>


<p><code>select</code>, <code>kernel</code>, <code>edges</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Hegyi (1974) index (no distance offset, as usual)
summary(pairwise(finpines, maxR = 6, kernel=powers_ker))
</code></pre>


</div>