<div class="container">

<table style="width: 100%;"><tr>
<td>spsurml</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum likelihood estimation of spatial SUR model.</h2>

<h3>Description</h3>

<p>This function estimates spatial SUR models using 
maximum-likelihood methods.The number of equations, time periods 
and cross-sectional units is not restricted.The user can choose 
between different spatial specifications as described below.
The estimation procedure allows for the introduction of linear 
restrictions on the <code class="reqn">\beta</code> parameters associated to the 
regressors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spsurml(formula = NULL, data = NULL, na.action,
               listw = NULL, type = "sim", Durbin = NULL,
               method = "eigen", zero.policy = NULL, interval = NULL,
               trs = NULL, R = NULL, b = NULL, X = NULL, Y = NULL, 
               G = NULL, N = NULL, Tm = NULL,p = NULL, 
               control = list() )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object type <code>Formula</code> 
similar to objects created with the package <span class="pkg">Formula</span> 
describing the equations to be estimated in the model. 
This model may contain several responses (explained 
variables) and a varying number of regressors in each equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An object of class data.frame or a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function (default <code>options("na.action")</code>),
can also be <code>na.omit</code> or <code>na.exclude</code> with consequences 
for residuals and fitted values. It may be necessary to set 
<code>zero.policy</code> to <code>TRUE</code> because this subsetting may 
create no-neighbour observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>A <code>listw</code> object created for example by 
<code>nb2listw</code> from <span class="pkg">spatialreg</span> package; if 
<code>nb2listw</code> not given, set to 
the same spatial weights as the <code>listw</code> argument. It can
also be a spatial weighting matrix of order <em>(NxN)</em> instead of
a <code>listw</code> object. Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of spatial model specification: "sim",
"slx", "slm", "sem", "sdm", 
"sdem", "sarar" or "gnm". Default = "sim".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Durbin</code></td>
<td>
<p>If a formula object and model is type "sdm", "sdem" 
or "slx" the subset of explanatory variables to lag for each equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Similar to the corresponding parameter of 
<code>lagsarlm</code> function in <span class="pkg">spatialreg</span> package. 
"eigen" (default) - the Jacobian is computed as the product of 
(1 - rho*eigenvalue) using <code>eigenw</code>, and 
"spam" or "Matrix_J" for strictly symmetric weights lists of 
styles "B" and "C", or made symmetric by similarity 
(Ord, 1975, Appendix C) if possible for styles "W" and "S", 
using code from the spam or Matrix packages to calculate the 
determinant; "Matrix" and "spam_update" provide updating Cholesky 
decomposition methods; "LU" provides an alternative sparse matrix 
decomposition approach. In addition, there are "Chebyshev" and 
Monte Carlo "MC" approximate log-determinant methods; 
the Smirnov/Anselin (2009) trace approximation is available 
as "moments". Three methods: "SE_classic", "SE_whichMin", 
and "SE_interp" are provided experimentally, the first to 
attempt to emulate the behaviour of Spatial Econometrics 
toolbox ML fitting functions. All use grids of log determinant 
values, and the latter two attempt to ameliorate some features 
of "SE_classic".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>Similar to the corresponding parameter of 
<code>lagsarlm</code> function in <span class="pkg">spatialreg</span> package. 
If <code>TRUE</code> assign zero to the lagged value of zones without 
neighbours, if <code>FALSE</code> assign <code>NA</code> - causing 
<code>spsurml()</code> to terminate with an error. Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Search interval for autoregressive parameter.
Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trs</code></td>
<td>
<p>Similar to the corresponding parameter of 
<code>lagsarlm</code> function in <span class="pkg">spatialreg</span> package.
Default <code>NULL</code>, if given, a vector of powered spatial weights 
matrix traces output by <code>trW</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>A row vector of order <em>(1xpr)</em> with  the set of 
<em>r</em> linear constraints on the <em>beta</em> parameters. The 
<em>first</em> restriction appears in the first <em>p</em> terms,
the second restriction in the next <em>p</em> terms and so on. 
Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>A column vector of order <em>(rx1)</em> with the values of 
the linear restrictions on the <em>beta</em> parameters. 
Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A data matrix of order <em>(NTmGxp)</em> with the observations
of the regressors. The number of covariates in the SUR model is 
<em>p</em> = <code class="reqn">sum(p_{g})</code> where <em><code class="reqn">p_{g}</code></em> is the number 
of regressors (including the intercept) in the g-th equation, 
<em>g = 1,...,G</em>). The specification of "X" is only 
necessary if not available a <code>Formula</code> and a 
data frame. Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A column vector of order <em>(NTmGx1)</em>, with the 
observations of the explained variables. The ordering of the data 
must be (first) equation, (second) time dimension and (third) 
cross-sectional/spatial units. The specification of <em>Y</em> is 
only necessary if not available a <code>Formula</code>
and a data frame. Default = <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Number of equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of cross-section or spatial units</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tm</code></td>
<td>
<p>Number of time periods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of regressors by equation, including the intercept. 
<em>p</em> can be a row vector of order <em>(1xG)</em>, if the number 
of regressors is not the same for all the equations, or a scalar, 
if the <em>G</em> equations have the same number of regressors. The 
specification of <em>p</em> is only necessary if not available a 
<code>Formula</code> and a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The list of (spatial) models that can be estimated with the <em>spsurml</em> function are:
</p>

<ul>
<li>
<p> "sim": SUR model with no spatial effects
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = X_{tg} \beta_{g} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "slx": SUR model with spatial lags of the regressors
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = X_{tg} \beta_{g} + WX_{tg} \theta_{g} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "slm": SUR model with spatial lags of the explained variables
</p>
<p style="text-align: center;"><code class="reqn">y_{tg} = \rho_{g} Wy_{tg} + X_{tg} \beta_{g} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "sem": SUR model with spatial errors
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = X_{tg} \beta_{g} + u_{tg} </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_{tg} = \lambda_{g} Wu_{tg} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "sdm": SUR model of the Spatial Durbin type
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = \rho_{g} Wy_{tg} + X_{tt} \beta_{g} + WX_{tg} \theta_{g} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "sdem": SUR model with spatial lags of the regressors and spatial errors
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = X_{tg} \beta_{g} + WX_{tg} \theta_{g} + u_{tg} </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_{tg} = \lambda_{g} W u_{tg} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "sarar": SUR model with spatial lags of the explained variables and spatial
errors
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = \rho_{g} Wy_{tg} + X_{tg} \beta_{g} + u_{tg} </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_{tg} = \lambda_{g} W u_{tg} + \epsilon_{tg} </code>
</p>

</li>
<li>
<p> "gnm": SUR model with spatial lags of the explained variables, 
regressors and spatial errors
</p>
<p style="text-align: center;"><code class="reqn"> y_{tg} = \rho_{g} Wy_{tg} + X_{tg} \beta_{g} + 
                        WX_{tg} \theta_{g} + u_{tg} </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_{tg} = \lambda_{g} W u_{tg} + \epsilon_{tg} </code>
</p>

</li>
</ul>
<h3>Value</h3>

<p>Object of <code>spsur</code> class with the output of the  
maximum-likelihood estimation of the specified spatial SUR model. 
A list with:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>call</code> </td>
<td style="text-align: left;"> Matched call. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>type</code> </td>
<td style="text-align: left;">  Type of model specified. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>method</code> </td>
<td style="text-align: left;"> Value of <code>method</code> argument to compute the 
      Jacobian </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Durbin</code> </td>
<td style="text-align: left;"> Value of <code>Durbin</code> argument. </td>
</tr>
<tr>
<td style="text-align: left;">     
    <code>coefficients</code> </td>
<td style="text-align: left;"> Estimated coefficients for the regressors. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>deltas</code> </td>
<td style="text-align: left;"> Estimated spatial coefficients. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rest.se</code> </td>
<td style="text-align: left;"> Estimated standard errors for the 
      estimates of <em>beta</em>. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>deltas.se</code> </td>
<td style="text-align: left;"> Estimated standard errors for the estimates of 
      the spatial coefficients (<code>deltas</code>). </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>resvar</code> </td>
<td style="text-align: left;"> Estimated covariance matrix for the estimates of 
      <em>beta's</em> and spatial coefficients (<code>deltas</code>).</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>LL</code> </td>
<td style="text-align: left;"> Value of the likelihood function at the 
      maximum-likelihood estimates. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>R2</code> </td>
<td style="text-align: left;"> Coefficient of determination for each equation, 
      obtained as the squared of the correlation coefficient between the 
      corresponding explained variable and fitted values. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>R2 pooled</code> </td>
<td style="text-align: left;"> <em>Global</em> coefficient of determination 
      obtained for the set of the <em>G</em> equations. 
      It is computed in the same way than uniequational <code>R2</code> but 
      joining the dependent variable and fitted values in single vectors 
      instead of one vector for each equation. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Sigma</code> </td>
<td style="text-align: left;"> Estimated covariance matrix for the residuals of 
      the <em>G</em> equations. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fdHess</code> </td>
<td style="text-align: left;"> Logical value of <code>fdHess</code> argument when 
      computing numerical covariances.  </td>
</tr>
<tr>
<td style="text-align: left;">  
    <code>residuals</code> </td>
<td style="text-align: left;"> Residuals of the model. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>df.residuals</code> </td>
<td style="text-align: left;"> Degrees of freedom for the residuals. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.values</code> </td>
<td style="text-align: left;"> Estimated values for the dependent 
      variables. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>BP</code> </td>
<td style="text-align: left;"> Value of the Breusch-Pagan statistic to test the 
      null hypothesis of diagonality among the errors of the <em>G</em> 
      equations. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>LMM</code> </td>
<td style="text-align: left;"> Marginal Lagrange Multipliers, 
      LM(<code class="reqn">\rho</code>|<code class="reqn">\lambda</code>) and
      LM(<code class="reqn">\lambda</code>|<code class="reqn">\rho</code>), to test for omitted spatial effects 
      in the specification. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>G</code> </td>
<td style="text-align: left;"> Number of equations. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>N</code> </td>
<td style="text-align: left;"> Number of cross-sections or spatial units. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Tm</code> </td>
<td style="text-align: left;"> Number of time periods. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>p</code> </td>
<td style="text-align: left;"> Number of regressors by equation (including intercepts). </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Y</code> </td>
<td style="text-align: left;"> If <em>data</em> is <em>NULL</em>, vector <em>Y</em> of the explained variables of the 
      SUR model. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X</code> </td>
<td style="text-align: left;"> If <em>data</em> is <em>NULL</em>, matrix <em>X</em> of the regressors of the SUR model. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>W</code> </td>
<td style="text-align: left;"> Spatial weighting matrix. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>zero.policy</code> </td>
<td style="text-align: left;"> Logical value of <code>zero.policy</code> . </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>interval</code> </td>
<td style="text-align: left;">	Search interval for spatial parameter. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>listw_style</code> </td>
<td style="text-align: left;">	Style of neighborhood matrix <code>W</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>trs</code> </td>
<td style="text-align: left;"> Either <code>NULL</code> or vector of powered spatial weights 
      matrix traces output by <code>trW</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>insert</code> </td>
<td style="text-align: left;"> Logical value to check if <code>is.null(trs)</code>. </td>
</tr>
<tr>
<td style="text-align: left;"> 
 </td>
</tr>
</table>
<h3>Control arguments</h3>


<table>
<tr>
<td style="text-align: left;">
    <code>tol</code> </td>
<td style="text-align: left;"> Numerical value for the tolerance for the estimation 
      algorithm until convergence. Default = 1e-3. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>maxit</code> </td>
<td style="text-align: left;"> Maximum number of iterations until convergence; 
      it must be an integer value. Default = 200. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>trace</code> </td>
<td style="text-align: left;"> A logical value to show intermediate results during 
      the estimation process. Default = <code>TRUE</code>. </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fdHess</code> </td>
<td style="text-align: left;"> Compute variance-covariance matrix using the numerical 
      hessian. Suited for large samples. Default = <code>FALSE</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Imult</code> </td>
<td style="text-align: left;"> default 2; used for preparing the Cholesky 
      decompositions for updating in the Jacobian function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>super</code> </td>
<td style="text-align: left;">  if <code>NULL</code> (default), set to <code>FALSE</code> to use 
      a simplicial decomposition for the sparse Cholesky decomposition and 
      method "Matrix_J", set to as.logical(NA) for method "Matrix", if 
      <code>TRUE</code>, use a supernodal decomposition </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>cheb_q</code> </td>
<td style="text-align: left;"> default 5; highest power of the approximating 
      polynomial for the Chebyshev approximation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MC_p</code> </td>
<td style="text-align: left;"> default 16; number of random variates </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MC_m</code> </td>
<td style="text-align: left;"> default 30; number of products of random variates 
      matrix and spatial weights matrix </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>spamPivot</code> </td>
<td style="text-align: left;">  default "MMD", alternative "RCM" </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>in_coef</code> </td>
<td style="text-align: left;"> default 0.1, coefficient value for initial Cholesky 
      decomposition in "spam_update" </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>type</code> </td>
<td style="text-align: left;"> default "MC", used with method "moments"; alternatives 
      "mult" and "moments", for use if trs is missing </td>
</tr>
<tr>
<td style="text-align: left;"> 
    <code>correct</code> </td>
<td style="text-align: left;"> default <code>TRUE</code>, used with method "moments" to 
      compute the Smirnov/Anselin correction term </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>trunc</code> </td>
<td style="text-align: left;"> default <code>TRUE</code>, used with method "moments" to 
      truncate the Smirnov/Anselin correction term </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>SE_method</code> </td>
<td style="text-align: left;"> default "LU", may be "MC" </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nrho</code> </td>
<td style="text-align: left;"> default 200, as in SE toolbox; the size of the first 
      stage lndet grid; it may be reduced to for example 40 </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>interpn</code> </td>
<td style="text-align: left;"> default 2000, as in SE toolbox; the size of the 
      second stage lndet grid </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>SElndet</code> </td>
<td style="text-align: left;"> default <code>NULL</code>, may be used to pass a 
      pre-computed SE toolbox style matrix of coefficients and their lndet 
      values to the "SE_classic" and "SE_whichMin" methods </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>LU_order</code> </td>
<td style="text-align: left;"> default <code>FALSE</code>; used in "LU_prepermutate", 
      note warnings given for lu method </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pre_eig</code> </td>
<td style="text-align: left;"> default <code>NULL</code>; may be used to pass a 
      pre-computed vector of eigenvalues </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Author(s)</h3>


<table>
<tr>
<td style="text-align: left;">
  Fernando Lopez  </td>
<td style="text-align: left;"> <a href="mailto:fernando.lopez@upct.es">fernando.lopez@upct.es</a> </td>
</tr>
<tr>
<td style="text-align: left;">
  Roman Minguez  </td>
<td style="text-align: left;"> <a href="mailto:roman.minguez@uclm.es">roman.minguez@uclm.es</a> </td>
</tr>
<tr>
<td style="text-align: left;">
  Jesus Mur  </td>
<td style="text-align: left;"> <a href="mailto:jmur@unizar.es">jmur@unizar.es</a> </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<h3>References</h3>

   
<ul>
<li>
<p> Anselin, L. (1988). <em>Spatial econometrics: methods and models.</em> 
Dordrecht: Kluwer
</p>
</li>
<li>
<p> Bivand, R.S. and  Piras G. (2015). Comparing Implementations of 
Estimation Methods for Spatial Econometrics. <em>Journal of 
Statistical Software</em>, 63(18), 1-36. 
&lt;doi:	10.18637/jss.v063.i18&gt;
</p>
</li>
<li>
<p> Bivand, R. S., Hauke, J., and Kossowski, T. (2013). 
Computing the Jacobian in Gaussian spatial autoregressive models: An 
illustrated comparison of available methods. <em> Geographical 
Analysis</em>, 45(2), 150-179. &lt;doi:10.1111/gean.12008&gt;
</p>
</li>
<li>
<p> Breusch T., Pagan A. (1980). The Lagrange multiplier test and its
applications to model specification in econometrics. 
<em>Rev Econ Stud</em> 47: 239-254
</p>
</li>
<li>
<p> Cliff, A.D. and Ord, J.K. (1981). <em>Spatial processes: Models 
and applications</em>, Pion. 
</p>
</li>
<li>
<p> LeSage J and Pace, R.K. (2009). <em>Introduction to Spatial 
Econometrics.</em> CRC Press, Boca Raton.
</p>
</li>
<li>
<p> Lopez, F.A., Mur, J., and Angulo, A. (2014). Spatial model
selection strategies in a SUR framework. The case of regional
productivity in EU. <em>Annals of Regional Science</em>, 53(1), 197-220.
&lt;doi:10.1007/s00168-014-0624-2&gt;
</p>
</li>
<li>
<p> Minguez, R., Lopez, F.A. and Mur, J.  (2022).
spsur: An R Package for Dealing with Spatial 
Seemingly Unrelated Regression Models. 
<em>Journal of Statistical Software</em>, 
104(11), 1–43.
&lt;doi:10.18637/jss.v104.i11&gt;
</p>
</li>
<li>
<p> Mur, J., Lopez, F., and Herrera, M. (2010). Testing for spatial
effects in seemingly unrelated regressions.
<em>Spatial Economic Analysis</em>, 5(4), 399-440.
&lt;doi:10.1080/17421772.2010.516443&gt;
</p>
</li>
<li>
<p> Ord, J.K. (1975). Estimation methods for models of spatial 
interaction, <em>Journal of the American Statistical Association</em>, 
70, 120-126. 
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>spsur3sls</code>, <code>lagsarlm</code>, 
<code>lmtestspsur</code>, <code>wald_betas</code>, 
<code>lr_betas</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#################################################
######## CROSS SECTION DATA (G&gt;1; Tm=1) ########
#################################################

#### Example 1: Spatial Phillips-Curve. Anselin (1988, p. 203)
rm(list = ls()) # Clean memory
data(spc)
Tformula &lt;- WAGE83 | WAGE81 ~ UN83 + NMR83 + SMSA | UN80 + NMR80 + SMSA
spcsur.sim &lt;- spsurml(formula = Tformula, data = spc, type = "sim")
summary(spcsur.sim)
# All the coefficients in a single table.
print(spcsur.sim)
# Plot of the coefficients of each equation in different graphs
plot(spcsur.sim) 

## A SUR-SLX model 
## (listw argument can be either a matrix or a listw object )
spcsur.slx &lt;- spsurml(formula = Tformula, data = spc, type = "slx", 
  listw = Wspc, Durbin = TRUE)
summary(spcsur.slx)
# All the coefficients in a single table.
print(spcsur.slx)
# Plot of the coefficients in a single graph
if (require(gridExtra)) {
  pl &lt;- plot(spcsur.slx, viewplot = FALSE)
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], 
                        nrow = 2)
} 

## VIP: The output of the whole set of the examples can be examined 
## by executing demo(demo_spsurml, package="spsur")
  

### A SUR-SLM model
spcsur.slm &lt;- spsurml(formula = Tformula, data = spc, type = "slm", 
                     listw = Wspc)
summary(spcsur.slm)
if (require(gridExtra)) {
  pl &lt;- plot(spcsur.slm, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], 
               pl$pldeltas, nrow = 3)
}


### A SUR-SDM model
spcsur.sdm &lt;- spsurml(formula = Tformula, data = spc, type = "sdm", 
                     listw = Wspc)
summary(spcsur.sdm)
print(spcsur.sdm)
if (require(gridExtra)) {
  pl &lt;- plot(spcsur.sdm, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], 
               pl$pldeltas, nrow = 3)
}

## A SUR-SDM model with different spatial lags in each equation
TformulaD &lt;- ~ UN83 + NMR83 + SMSA | UN80
spcsur.sdm2 &lt;- spsurml(formula = Tformula, data = spc, type = "sdm", 
                      listw = Wspc, Durbin = TformulaD)
summary(spcsur.sdm2)
if (require(gridExtra)) {
  pl &lt;- plot(spcsur.sdm2, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], 
               pl$pldeltas, nrow = 3)
}


##################################################
#########  CLASSIC PANEL DATA G=1; Tm&gt;1   ########
##################################################
#
##### Example 2: Homicides + Socio-Economics (1960-90)
## Homicides and selected socio-economic characteristics for continental
## U.S. counties.
## Data for four decennial census years: 1960, 1970, 1980 and 1990.
## \url{https://geodacenter.github.io/data-and-lab/ncovr/}


### It usually requires 1-2 minutes maximum...
rm(list = ls()) # Clean memory
### Read NCOVR.sf object
data(NCOVR, package = "spsur")
nbncovr &lt;- spdep::poly2nb(NCOVR.sf, queen = TRUE)
### Some regions with no links...
lwncovr &lt;- spdep::nb2listw(nbncovr, style = "W", zero.policy = TRUE)
Tformula &lt;- HR80  | HR90 ~ PS80 + UE80 | PS90 + UE90
### A SUR-SIM model
NCOVRSUR.sim &lt;- spsurml(formula = Tformula, data = NCOVR.sf, type = "sim")
summary(NCOVRSUR.sim)
if (require(gridExtra)) {
  pl &lt;- plot(NCOVRSUR.sim, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], nrow = 3)
}
### A SUR-SLX model
NCOVRSUR.slx &lt;- spsurml(formula = Tformula, data = NCOVR.sf, type = "slx", 
                       listw = lwncovr, zero.policy = TRUE)
print(NCOVRSUR.slx)
if (require(gridExtra)) {
  pl &lt;- plot(NCOVRSUR.slx, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], nrow = 2)
}

### A SUR-SLM model
### method = "Matrix" (Cholesky) instead of "eigen"
### (fdHess = TRUE to compute numerical covariances )
NCOVRSUR.slm &lt;- spsurml(formula = Tformula, data = NCOVR.sf, 
                       type = "slm", listw = lwncovr, method = "Matrix", 
                       zero.policy = TRUE, control = list(fdHess = TRUE))
summary(NCOVRSUR.slm)

if (require(gridExtra)) {
  pl &lt;- plot(NCOVRSUR.slm, viewplot = FALSE) 
  grid.arrange(pl$lplbetas[[1]], pl$lplbetas[[2]], 
               pl$pldeltas, nrow = 3)
}
# LR test for nested models
anova(NCOVRSUR.sim, NCOVRSUR.slm)

</code></pre>


</div>