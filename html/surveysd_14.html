<div class="container">

<table style="width: 100%;"><tr>
<td>ipf_step</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform one step of iterative proportional updating</h2>

<h3>Description</h3>

<p>C++ routines to invoke a single iteration of the Iterative proportional updating (IPU) scheme. Targets and classes
are assumed to be one dimensional in the <code>ipf_step</code> functions. <code>combine_factors</code> aggregates several vectors of
type factor into a single one to allow multidimensional ipu-steps. See examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipf_step_ref(w, classes, targets)

ipf_step(w, classes, targets)

ipf_step_f(w, classes, targets)

combine_factors(dat, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a numeric vector of weights. All entries should be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>a factor variable. Must have the same length as <code>w</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p>key figure to target with the ipu scheme. A numeric verctor of the same length as <code>levels(classes)</code>.
This can also be a <code>table</code> produced by <code>xtabs</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>a <code>data.frame</code> containing the factor variables to be combined.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ipf_step</code> returns the adjusted weights. <code>ipf_step_ref</code> does the same, but updates <code>w</code> by reference rather than
returning. <code>ipf_step_f</code> returns a multiplicator: adjusted weights divided by unadjusted weights. <code>combine_factors</code> is
designed to make <code>ipf_step</code> work with contingency tables produced by xtabs.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
############# one-dimensional ipu ##############

## create random data
nobs &lt;- 10
classLabels &lt;- letters[1:3]
dat = data.frame(
  weight = exp(rnorm(nobs)),
  household = factor(sample(classLabels, nobs, replace = TRUE))
)
dat

## create targets (same lenght as classLabels!)
targets &lt;- 3:5

## calculate weights
new_weight &lt;- ipf_step(dat$weight, dat$household, targets)
cbind(dat, new_weight)

## check solution
xtabs(new_weight ~ dat$household)

## calculate weights "by reference"
ipf_step_ref(dat$weight, dat$household, targets)
dat

############# multidimensional ipu ##############

## load data
factors &lt;- c("time", "sex", "smoker", "day")
tips &lt;- data.frame(sex=c("Female","Male","Male"), day=c("Sun","Mon","Tue"),
time=c("Dinner","Lunch","Lunch"), smoker=c("No","Yes","No"))
tips &lt;- tips[factors]

## combine factors
con &lt;- xtabs(~., tips)
cf &lt;- combine_factors(tips, con)
cbind(tips, cf)[sample(nrow(tips), 10, replace = TRUE),]

## adjust weights
weight &lt;- rnorm(nrow(tips)) + 5
adjusted_weight &lt;- ipf_step(weight, cf, con)

## check outputs
con2 &lt;- xtabs(adjusted_weight ~ ., data = tips)
sum((con - con2)^2)

</code></pre>


</div>