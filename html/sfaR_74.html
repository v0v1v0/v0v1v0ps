<div class="container">

<table style="width: 100%;"><tr>
<td>sfaR-deprecated</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Deprecated functions of sfaR</h2>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
‘sfaR’ only, and could be defunct at a future release.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lcmcross(
  formula,
  uhet,
  vhet,
  thet,
  logDepVar = TRUE,
  data,
  subset,
  weights,
  wscale = TRUE,
  S = 1L,
  udist = "hnormal",
  start = NULL,
  whichStart = 2L,
  initAlg = "nm",
  initIter = 100,
  lcmClasses = 2,
  method = "bfgs",
  hessianType = 1,
  itermax = 2000L,
  printInfo = FALSE,
  tol = 1e-12,
  gradtol = 1e-06,
  stepmax = 0.1,
  qac = "marquardt"
)

## S3 method for class 'lcmcross'
print(x, ...)

## S3 method for class 'lcmcross'
bread(x, ...)

## S3 method for class 'lcmcross'
estfun(x, ...)

## S3 method for class 'lcmcross'
coef(object, extraPar = FALSE, ...)

## S3 method for class 'summary.lcmcross'
coef(object, ...)

## S3 method for class 'lcmcross'
fitted(object, ...)

## S3 method for class 'lcmcross'
ic(object, IC = "AIC", ...)

## S3 method for class 'lcmcross'
logLik(object, individual = FALSE, ...)

## S3 method for class 'lcmcross'
marginal(object, newData = NULL, ...)

## S3 method for class 'lcmcross'
nobs(object, ...)

## S3 method for class 'lcmcross'
residuals(object, ...)

## S3 method for class 'lcmcross'
summary(object, grad = FALSE, ci = FALSE, ...)

## S3 method for class 'summary.lcmcross'
print(x, digits = max(3, getOption("digits") - 2), ...)

## S3 method for class 'lcmcross'
efficiencies(object, level = 0.95, newData = NULL, ...)

## S3 method for class 'lcmcross'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A symbolic description of the model to be estimated based on
the generic function <code>formula</code> (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uhet</code></td>
<td>
<p>A one-part formula to account for heteroscedasticity in the
one-sided error variance (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vhet</code></td>
<td>
<p>A one-part formula to account for heteroscedasticity in the
two-sided error variance (see section ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thet</code></td>
<td>
<p>A one-part formula to account for technological heterogeneity in
the construction of the classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logDepVar</code></td>
<td>
<p>Logical. Informs whether the dependent variable is logged
(<code>TRUE</code>) or not (<code>FALSE</code>). Default = <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data frame containing the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the optimization process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of weights to be used for weighted
log-likelihood. Should be <code>NULL</code> or numeric vector with positive values.
When <code>NULL</code>, a numeric vector of 1 is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wscale</code></td>
<td>
<p>Logical. When <code>weights</code> is not <code>NULL</code>, a scaling
transformation is used such that the <code>weights</code> sums to the sample
size. Default <code>TRUE</code>. When <code>FALSE</code> no scaling is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>If <code>S = 1</code> (default), a production (profit) frontier is
estimated: <code class="reqn">\epsilon_i = v_i-u_i</code>. If <code>S = -1</code>, a cost frontier is
estimated: <code class="reqn">\epsilon_i = v_i+u_i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>udist</code></td>
<td>
<p>Character string. Distribution specification for the one-sided
error term. Only the half normal distribution <code>'hnormal'</code> (Aigner
<em>et al.</em>, 1977, Meeusen and Vandenbroeck, 1977) is currently
implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Numeric vector. Optional starting values for the maximum
likelihood (ML) estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whichStart</code></td>
<td>
<p>Integer. If <code>'whichStart = 1'</code>, the starting values
are obtained from the method of moments. When <code>'whichStart = 2'</code>
(Default), the model is initialized by solving the homoscedastic pooled
cross section SFA model. <code>'whichStart = 1'</code> can be fast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initAlg</code></td>
<td>
<p>Character string specifying the algorithm used for
initialization and obtain the starting values (when <code>'whichStart = 2'</code>).
Only <span class="pkg">maxLik</span> package algorithms are available:
</p>
 <ul>
<li> <p><code>'bfgs'</code>, for Broyden-Fletcher-Goldfarb-Shanno
(see <code>maxBFGS</code>)
</p>
</li>
<li> <p><code>'bhhh'</code>, for Berndt-Hall-Hall-Hausman
(see <code>maxBHHH</code>)
</p>
</li>
<li> <p><code>'nr'</code>, for Newton-Raphson (see <code>maxNR</code>)
</p>
</li>
<li> <p><code>'nm'</code>, for Nelder-Mead - Default -
(see <code>maxNM</code>)
</p>
</li>
<li> <p><code>'cg'</code>, for Conjugate Gradient
(see <code>maxCG</code>) </p>
</li>
<li> <p><code>'sann'</code>, for Simulated
Annealing (see <code>maxSANN</code>)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initIter</code></td>
<td>
<p>Maximum number of iterations for initialization algorithm.
Default <code>100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcmClasses</code></td>
<td>
<p>Number of classes to be estimated (default = <code>2</code>). A
maximum of five classes can be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization algorithm used for the estimation.  Default =
<code>'bfgs'</code>. 11 algorithms are available: </p>
 <ul>
<li> <p><code>'bfgs'</code>,
for Broyden-Fletcher-Goldfarb-Shanno (see
<code>maxBFGS</code>) </p>
</li>
<li> <p><code>'bhhh'</code>, for
Berndt-Hall-Hall-Hausman (see <code>maxBHHH</code>) </p>
</li>
<li>
<p><code>'nr'</code>, for Newton-Raphson (see <code>maxNR</code>)
</p>
</li>
<li> <p><code>'nm'</code>, for Nelder-Mead (see <code>maxNM</code>)
</p>
</li>
<li> <p><code>'cg'</code>, for Conjugate Gradient
(see <code>maxCG</code>) </p>
</li>
<li> <p><code>'sann'</code>, for Simulated
Annealing (see <code>maxSANN</code>)
</p>
</li>
<li> <p><code>'ucminf'</code>, for a quasi-Newton type optimization with BFGS updating of
the inverse Hessian and soft line search with a trust region type monitoring
of the input to the line search algorithm
(see <code>ucminf</code>)
</p>
</li>
<li> <p><code>'mla'</code>, for general-purpose optimization based on
Marquardt-Levenberg algorithm (see <code>mla</code>)
</p>
</li>
<li> <p><code>'sr1'</code>, for Symmetric Rank 1 (see
<code>trust.optim</code>) </p>
</li>
<li> <p><code>'sparse'</code>,
for trust regions and sparse Hessian
(see <code>trust.optim</code>) </p>
</li>
<li>
<p><code>'nlminb'</code>, for optimization using PORT routines (see
<code>nlminb</code>)</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessianType</code></td>
<td>
<p>Integer. If <code>1</code> (default), analytic Hessian is
returned. If <code>2</code>, bhhh Hessian is estimated (<code class="reqn">g'g</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>Maximum number of iterations allowed for optimization.
Default = <code>2000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printInfo</code></td>
<td>
<p>Logical. Print information during optimization. Default =
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric. Convergence tolerance. Default = <code>1e-12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol</code></td>
<td>
<p>Numeric. Convergence tolerance for gradient. Default =
<code>1e-06</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepmax</code></td>
<td>
<p>Numeric. Step max for <code>ucminf</code> algorithm. Default =
<code>0.1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qac</code></td>
<td>
<p>Character. Quadratic Approximation Correction for <code>'bhhh'</code>
and <code>'nr'</code> algorithms. If <code>'qac = stephalving'</code>, the step length
is decreased but the direction is kept. If <code>'qac = marquardt'</code>
(default), the step length is decreased while also moving closer to the pure
gradient direction. See <code>maxBHHH</code> and
<code>maxNR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class lcmcross (returned by the function
<code>lcmcross</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments of frontier are passed to lcmcross;
additional arguments of the print, bread, estfun, nobs methods are currently
ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class lcmcross (returned by the function
<code>lcmcross</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extraPar</code></td>
<td>
<p>Logical (default = <code>FALSE</code>). If <code>TRUE</code>, additional
parameters are returned (see <code>coef</code> or <code>vcov</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p>Character string. Information criterion measure. Three criteria
are available: </p>
 <ul>
<li> <p><code>'AIC'</code> for Akaike information criterion
(default) </p>
</li>
<li> <p><code>'BIC'</code> for Bayesian information criterion </p>
</li>
<li>
<p><code>'HQIC'</code> for Hannan-Quinn information criterion </p>
</li>
</ul>
<p>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individual</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the sum of all
observations' log-likelihood values is returned. If <code>TRUE</code>, a vector of
each observation's log-likelihood value is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newData</code></td>
<td>
<p>Optional data frame that is used to calculate the efficiency
estimates. If NULL (the default), the efficiency estimates are calculated
for the observations that were used in the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>
<p>Logical. Default = <code>FALSE</code>. If <code>TRUE</code>, the gradient
for the maximum likelihood (ML) estimates of the different parameters is
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Logical. Default = <code>FALSE</code>. If <code>TRUE</code>, the 95%
confidence interval for the different parameters (OLS or/and ML estimates) is
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Numeric. Number of digits displayed in values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>A number between between 0 and 0.9999 used for the computation
of (in-)efficiency confidence intervals (defaut = <code>0.95</code>). Not used in the
case of <code>lcmcross</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following functions are deprecated and could be removed from <span class="pkg">sfaR</span>
in a near future. Use the replacement indicated below:
</p>

<ul>
<li>
<p>lcmcross: <code>sfalcmcross</code>
</p>
</li>
<li>
<p>bread.lcmcross: <code>bread.sfalcmcross</code>
</p>
</li>
<li>
<p>coef.lcmcross: <code>coef.sfalcmcross</code>
</p>
</li>
<li>
<p>coef.summary.lcmcross: <code>coef.summary.sfalcmcross</code>
</p>
</li>
<li>
<p>efficiencies.lcmcross: <code>efficiencies.sfalcmcross</code>
</p>
</li>
<li>
<p>estfun.lcmcross: <code>estfun.sfalcmcross</code>
</p>
</li>
<li>
<p>fitted.lcmcross: <code>fitted.sfalcmcross</code>
</p>
</li>
<li>
<p>ic.lcmcross: <code>ic.sfalcmcross</code>
</p>
</li>
<li>
<p>logLik.lcmcross: <code>logLik.sfalcmcross</code>
</p>
</li>
<li>
<p>marginal.lcmcross: <code>marginal.sfalcmcross</code>
</p>
</li>
<li>
<p>nobs.lcmcross: <code>nobs.sfalcmcross</code>
</p>
</li>
<li>
<p>print.lcmcross: <code>print.sfalcmcross</code>
</p>
</li>
<li>
<p>print.summary.lcmcross: <code>print.summary.sfalcmcross</code>
</p>
</li>
<li>
<p>residuals.lcmcross: <code>residuals.sfalcmcross</code>
</p>
</li>
<li>
<p>summary.lcmcross: <code>summary.sfalcmcross</code>
</p>
</li>
<li>
<p>vcov.lcmcross: <code>vcov.sfalcmcross</code>
</p>
</li>
</ul>
</div>