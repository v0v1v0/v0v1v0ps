<div class="container">

<table style="width: 100%;"><tr>
<td>options</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Options Settings</h2>

<h3>Description</h3>

<p>Allow the user to set and examine a variety of <em>options</em>
which affect the way in which <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> computes and displays sparse
matrix results.
</p>


<h3>Details</h3>

<p>Invoking <code>options()</code> with no arguments returns a list with the
current values of the options. To access the value of a single option, one should
use <code>getOption("spam.eps")</code>, e.g., rather than
<code>options("spam.eps")</code> which is a <em>list</em> of length one.<br></p>
<p>Of course, printing is still subordinate to
<code>getOption("max.print")</code> or similar options.
</p>


<h3>Value</h3>

<p>For <code>getOption</code>, the current value set for option <code>x</code>, or
<code>NULL</code> if the option is unset.
</p>
<p>For <code>options()</code>, a list of all set options sorted by category.  For
<code>options(name)</code>, a list of length one containing the set value,
or <code>NULL</code> if it is unset.  For uses setting one or more options,
a list with the previous values of the options changed (returned
invisibly).
</p>


<h3>Options used for the package <code>spam</code>
</h3>

<p>A short description with the default values follows.
</p>

<dl>
<dt>
<code>spam.eps=.Machine$double.eps</code>:</dt>
<dd>
<p>values smaller than this are
considered as zero. This is only used when creating spam objects.</p>
</dd>
<dt>
<code>spam.drop=FALSE</code>:</dt>
<dd>
<p>default parameter for <code>drop</code> when subsetting</p>
</dd>
<dt>
<code>spam.printsize=100</code>:</dt>
<dd>
<p>the max number of elements of a matrix which we
display as regular matrix.</p>
</dd>
<dt>
<code>spam.imagesize=10000</code>:</dt>
<dd>
<p>the max number of elements of a matrix we display
as regular matrix with <code>image</code> or <code>display</code>. Larger matrices are represented
as dots only.</p>
</dd>
<dt>
<code>spam.cex=1200</code>:</dt>
<dd>
<p>default dot size for  <code>image</code> or <code>display</code>.</p>
</dd>
<dt>
<code>spam.structurebased=FALSE</code>:</dt>
<dd>
<p>should operations be carried out on
the nonzero entries (the structure) or including the zeros.</p>
</dd>
<dt>
<code>spam.inefficiencywarning=1e6</code>:</dt>
<dd>
<p>issue a warning when inefficient
operations are performed and the matrix exceeds the specified size.
Valid value is a postive integer or a logical. <code>TRUE</code> corresponds
to 1 (always), <code>FALSE</code> to <code>Inf</code>.</p>
</dd>
<dt>
<code>spam.trivalues=FALSE</code>:</dt>
<dd>
<p>a flag whether to return the structure
(<code>FALSE</code>) or the values themselves (<code>TRUE</code>) when returning the
upper and lower triangular part of a matrix.</p>
</dd>
<dt>
<code>spam.listmethod="PE"</code>:</dt>
<dd>
<p>algorithm for <code>spam.list</code>. Default
is suggestion by Paul Eilers (thanks). Any other specification uses a
bubble sort algorithm which is only slightly faster for very sparse matrices. </p>
</dd>
<dt>
<code>spam.dopivoting=TRUE</code>:</dt>
<dd>
<p>default parameter for "<code>solve</code>" routines. <code>FALSE</code>
would solve the system without using the permutation.</p>
</dd>
<dt>
<code>spam.NAOK=FALSE</code>:</dt>
<dd>
<p>logical determines if <code>NA</code>, <code>NaN</code> and <code>Inf</code> are
allowed to Fortan. Setting to <code>TRUE</code> allows to work with these but
full functionality has not been tested.</p>
</dd>
<dt>
<code>spam.safemodevalidity=TRUE</code>:</dt>
<dd>
<p>logical determines if sanity check
is peformed when constructing sparse matrices.
Default is safer but somewhat slower.</p>
</dd>
<dt>
<code>spam.cholsymmetrycheck=TRUE</code>:</dt>
<dd>
<p>for the Cholesky factorization,
verify if the matrix is symmetric.</p>
</dd>
<dt>
<code>spam.cholpivotcheck=TRUE</code>:</dt>
<dd>
<p>for the Cholesky factorization,
when passing a permutation, should a minimum set of checks be performed?</p>
</dd>
<dt>
<code>spam.cholupdatesingular="warning"</code>:</dt>
<dd>
<p>for a Cholesky update, what
happens if the matrix is singular: <code>"warning"</code> only and
returning the not updated factor, <code>"error"</code>  or  return simply <code>"NULL"</code>.</p>
</dd>
<dt>
<code>spam.cholincreasefactor=c(1.25,1.25)</code>:</dt>
<dd>
<p>If not enought memory
could be allocated, these are the steps to increase it.</p>
</dd>
<dt>
<code>spam.nnznearestdistnnz=c(400^2,400)</code>:</dt>
<dd>
<p>Memory allocation
parameters for <code>nearest.dist</code>.</p>
</dd>
<dt>
<code>spam.nearestdistincreasefactor=1.25</code>:</dt>
<dd>
<p>If not enought memory
could be allocated, this is the step to increase it. </p>
</dd>
</dl>
<h3>See Also</h3>

<p>Functions influenced by these options include: <code>print.spam</code>,
<code>display.spam</code>,  <code>image.spam</code>, <code>upper.tri.spam</code>,
<code>chol.spam</code>, <code>nearest.dist</code>, etc.<br><code>powerboost</code><br></p>


<h3>Examples</h3>

<pre><code class="language-R">smat &lt;- diag.spam( 1:8)
smat
options(spam.printsize=49)
smat

# List all spam options:
options()[grep("spam",names(options()))]

# Reset to default values:
options(spam.eps=.Machine$double.eps,
        spam.drop=FALSE,
        spam.printsize=100,
        spam.imagesize=10000,
        spam.cex=1200,
        spam.structurebased=FALSE,
        spam.inefficiencywarning=1e6,
        spam.trivalues=FALSE,
        spam.listmethod="PE",
        spam.NAOK=FALSE,
        spam.safemodevalidity=TRUE,
        spam.dopivoting=TRUE,
        spam.cholsymmetrycheck=TRUE,
        spam.cholpivotcheck=TRUE,
        spam.cholupdatesingular="warning",
        spam.cholincreasefactor=c(1.25,1.25),
        spam.nearestdistincreasefactor=1.25,
        spam.nearestdistnnz=c(400^2,400))

</code></pre>


</div>