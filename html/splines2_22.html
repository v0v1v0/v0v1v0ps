<div class="container">

<table style="width: 100%;"><tr>
<td>mSpline</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>M-Spline Basis for Polynomial Splines</h2>

<h3>Description</h3>

<p>Generates the basis matrix of regular M-spline, periodic M-spline, and the
corresponding integrals and derivatives.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

msp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.
Duplicated internal knots are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>A nonnegative integer specifying the degree of the piecewise
polynomial. The default value is <code>3</code> for cubic splines. Zero degree
is allowed for piecewise constant basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>periodic</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the periodic splines will
be returned.  The default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
splines basis function.  The default value is <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integral</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the corresponding
integrals of spline basis functions will be returned.  The default value
is <code>FALSE</code>. For periodic splines, the integral of each basis is
integrated from the left boundary knot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function contains an implementation of the closed-form M-spline basis
based on the recursion formula given by Ramsay (1988) or periodic M-spline
basis following the procedure producing periodic B-splines given in Piegl
and Tiller (1997).  For monotone regression, one can use I-splines (see
<code>iSpline</code>) instead of M-splines.  For shape-restricted
regression, see Wang and Yan (2021) for examples.
</p>
<p>The function <code>msp()</code> is an alias of to encourage the use in a model
formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns if <code>periodic = FALSE</code>, or
<code>length(knots) + as.integer(intercept)</code> columns if <code>periodic =
    TRUE</code>.  Attributes that correspond to the arguments specified are
returned for usage of other functions in this package.
</p>


<h3>References</h3>

<p>Ramsay, J. O. (1988). Monotone regression splines in action.
<em>Statistical science</em>, 3(4), 425–441.
</p>
<p>Piegl, L., &amp; Tiller, W. (1997). <em>The NURBS book</em>. Springer Science &amp;
Business Media.
</p>
<p>Wang, W., &amp; Yan, J. (2021). <em>Shape-restricted regression splines with R
package splines2</em>. Journal of Data Science, 19(3),498–517.
</p>


<h3>See Also</h3>

<p><code>bSpline</code> for B-splines;
<code>iSpline</code> for I-splines;
<code>cSpline</code> for C-splines.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(splines2)

### example given in the reference paper by Ramsay (1988)
x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)
msMat &lt;- mSpline(x, knots = knots, degree = 2, intercept = TRUE)

op &lt;- par(mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(msMat, mark_knots = "internal")

## derivatives of M-splines
dmsMat &lt;- mSpline(x, knots = knots, degree = 2,
                  intercept = TRUE, derivs = 1)

## or using the deriv method
dmsMat1 &lt;- deriv(msMat)
stopifnot(all.equal(dmsMat, dmsMat1, check.attributes = FALSE))

### periodic M-splines
x &lt;- seq.int(0, 3, 0.01)
bknots &lt;- c(0, 1)
pMat &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                Boundary.knots = bknots, periodic = TRUE)
## integrals
iMat &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                Boundary.knots = bknots, periodic = TRUE, integral = TRUE)
## first derivatives by "derivs = 1"
dMat1 &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                 Boundary.knots = bknots, periodic = TRUE, derivs = 1)
## first derivatives by using the deriv() method
dMat2 &lt;- deriv(pMat)

par(mfrow = c(2, 2))
plot(pMat, ylab = "Periodic Basis", mark_knots = "boundary")
plot(iMat, ylab = "Integrals from 0")
abline(v = seq.int(0, max(x)), h = seq.int(0, max(x)), lty = 2, col = "grey")
plot(dMat1, ylab = "1st derivatives by 'derivs=1'", mark_knots = "boundary")
plot(dMat2, ylab = "1st derivatives by 'deriv()'", mark_knots = "boundary")
par(op) # reset to previous plotting settings

### default placement of internal knots for periodic splines
default_knots &lt;- function(x, df, intercept = FALSE,
                        Boundary.knots = range(x, na.rm = TRUE)) {
    ## get x in the cyclic interval [0, 1)
    x2 &lt;- (x - Boundary.knots[1]) %% (Boundary.knots[2] - Boundary.knots[1])
    knots &lt;- quantile(x2, probs = seq(0, 1, length.out = df + 2 - intercept))
    unname(knots[- c(1, length(knots))])
}

df &lt;- 8
degree &lt;- 3
intercept &lt;- TRUE
internal_knots &lt;- default_knots(x, df, intercept)

## 1. specify df
spline_basis1 &lt;- mSpline(x, degree = degree, df = df,
                         periodic = TRUE, intercept = intercept)
## 2. specify knots
spline_basis2 &lt;- mSpline(x, degree = degree, knots = internal_knots,
                         periodic = TRUE, intercept = intercept)

all.equal(internal_knots, knots(spline_basis1))
all.equal(spline_basis1, spline_basis2)
</code></pre>


</div>