<div class="container">

<table style="width: 100%;"><tr>
<td>ktensor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>k-tensors</h2>

<h3>Description</h3>

<p>Functionality for <code class="reqn">k</code>-tensors
</p>


<h3>Usage</h3>

<pre><code class="language-R">ktensor(S)
as.ktensor(M,coeffs)
is.ktensor(x)
## S3 method for class 'ktensor'
as.function(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M,coeffs</code></td>
<td>
<p>Matrix of indices and coefficients, as in
<code>spray(M,coeffs)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>ktensor</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A <dfn><code class="reqn">k</code>-tensor</dfn> object <code class="reqn">S</code> is a map from <code class="reqn">V^k</code>
to the reals <code class="reqn">R</code>, where <code class="reqn">V</code> is a vector space (here
<code class="reqn">R^n</code>) that satisfies multilinearity:
</p>
<p style="text-align: center;"><code class="reqn">S\left(v_1,\ldots,av_i,\ldots,v_k\right)=a\cdot
  S\left(v_1,\ldots,v_i,\ldots,v_k\right)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">S\left(v_1,\ldots,v_i+{v_i}',\ldots,v_k\right)=S\left(v_1,\ldots,v_i,\ldots,x_v\right)+
  S\left(v_1,\ldots,{v_i}',\ldots,v_k\right).</code>
</p>

<p>Note that this is <em>not</em> equivalent to linearity over
<code class="reqn">V^{nk}</code> (see examples).
</p>
<p>In the <a href="https://CRAN.R-project.org/package=stokes"><span class="pkg">stokes</span></a> package, <code class="reqn">k</code>-tensors are represented as
sparse arrays (<code>spray</code> objects), but with a class of
<code>c("ktensor", "spray")</code>.  This is a natural and efficient
representation for tensors that takes advantage of sparsity using
<a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> package features.
</p>
<p>Function <code>as.ktensor()</code> will coerce a <code class="reqn">k</code>-form to a
<code class="reqn">k</code>-tensor via <code>kform_to_ktensor()</code>.
</p>


<h3>Value</h3>

<p>All functions documented here return a <code>ktensor</code> object
except <code>as.function.ktensor()</code>, which returns a function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Spivak 1961</p>


<h3>See Also</h3>

<p><code>tensorprod</code>,<code>kform</code>,<code>wedge</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
as.ktensor(cbind(1:4,2:5,3:6),1:4)


## Test multilinearity:
k &lt;- 4
n &lt;- 5
u &lt;- 3

## Define a randomish k-tensor:
S  &lt;- ktensor(spray(matrix(1+sample(u*k)%%n,u,k),seq_len(u)))

## And a random point in V^k:
E &lt;- matrix(rnorm(n*k),n,k)  

E1 &lt;- E2 &lt;- E3 &lt;- E

x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
r1 &lt;- rnorm(1)
r2 &lt;- rnorm(1)

# change one column:
E1[,2] &lt;- x1
E2[,2] &lt;- x2
E3[,2] &lt;- r1*x1 + r2*x2

f &lt;- as.function(S)

r1*f(E1) + r2*f(E2) -f(E3) # should be small

## Note that multilinearity is different from linearity:
r1*f(E1) + r2*f(E2) - f(r1*E1 + r2*E2)  # not small!


</code></pre>


</div>