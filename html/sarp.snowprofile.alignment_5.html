<div class="container">

<table style="width: 100%;"><tr>
<td>chooseICavg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get index of appropriate initial condition average profile</h2>

<h3>Description</h3>

<p>To average a set of snow profiles, dbaSP requires a snow profile as initial condition (IC) to start the algorithm. To prevent persistent weak layers (PWLs) and crusts
from being averaged-out during the call to <code>dbaSP</code>, it is advised to start the algorithm with a best-guess IC. This best guess IC contains a large number of PWLs and crusts to ensure
that the most prevalent ones actually make their way into the final average profile. This function helps to choose meaningful IC profiles. See Details or (better) the source code
for how this function picks the profiles.
</p>


<h3>Usage</h3>

<pre><code class="language-R">chooseICavg(
  set,
  n,
  classifyPWLs,
  classifyCRs,
  nPWL = round((2 * n/3) + 0.001),
  sm = summary(set)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p>a sarp.snowprofile::snowprofileSet</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of profile indices to be picked (i.e., returned)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifyPWLs</code></td>
<td>
<p>an argument list for a function call to sarp.snowprofile::findPWL which returns relevant PWLs for identifying initial conditions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifyCRs</code></td>
<td>
<p>an argument list for a function call to sarp.snowprofile::findPWL which returns relevant CR(ust)s for identifying initial conditions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPWL</code></td>
<td>
<p>number of profile indices to be picked from profiles that have many PWLs in many different vertical levels; an analogous <code>nCR</code> will be the difference <code>n - nPWL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sm</code></td>
<td>
<p>a (precomputed) summary of the <code>set</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function first computes how many PWLs and how many crusts are in the profiles that have a close to median total snow height HS.
Each of these profile is then divided into several vertical levels (by sarp.snowprofile::numberOfPWLsPerVerticalLevel).
nPWL and nCR profiles are then randomly picked from the profiles that have PWLs or CR in most vertical levels and additionally have a rather large number of PWLs/CR overall.
The larger <code>n</code>, the more profiles with decreasing number of PWLs/CR in different levels are also returned. Note that this function is best applied
to large profile sets to obtain semi-random results. For small sets, the indices returned can actually be deterministic since the pool of relevant profiles is too small.
</p>


<h3>Value</h3>

<p><code>n</code> number of indices that correspond to profiles in the <code>set</code>
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p>sarp.snowprofile::findPWL, averageSP
</p>


<h3>Examples</h3>

<pre><code class="language-R">plot(SPgroup, SortMethod = "unsorted", TopDown = TRUE,
     xticklabels = "originalIndices", main = "entire profile set")
IC_ids_pwl &lt;- chooseICavg(SPgroup, n = 4, nPWL = 4,
                          classifyPWLs = list(pwl_gtype = c("SH", "DH")),
                          classifyCRs = NULL)
plot(SPgroup[IC_ids_pwl], SortMethod = "unsorted", hardnessResidual = 0, TopDown = TRUE,
     xticklabels = IC_ids_pwl, main = "sample of profiles with rather many and distributed PWLs")

</code></pre>


</div>