<div class="container">

<table style="width: 100%;"><tr>
<td>krigecv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross validation, n-fold and leave-one-out for kriging methods ('krige')</h2>

<h3>Description</h3>

<p>This function is a cross validation function
for kriging methods ('krige') in 'gstat'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">krigecv(
  longlat,
  trainy,
  trainpredx = NULL,
  validation = "CV",
  cv.fold = 10,
  nmax = 12,
  transformation = "none",
  delta = 1,
  formula = var1 ~ 1,
  vgm.args = ("Sph"),
  anis = c(0, 1),
  alpha = 0,
  block = 0,
  beta,
  predacc = "VEcv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainy</code></td>
<td>
<p>a vector of response, must have length equal to the number of
rows in trainx.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainpredx</code></td>
<td>
<p>a dataframe contains predictive variables of point samples.
If longitude and latitude are going to be used as predictive variables, they
should also be included but they should be named in names other than 'long' and 'lat'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validation</code></td>
<td>
<p>validation methods, include 'LOO': leave-one-out, and 'CV':
cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.fold</code></td>
<td>
<p>integer; number of folds in the cross-validation. if &gt; 1,
then apply n-fold cross validation; the default is 10, i.e., 10-fold cross
validation that is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p>for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest is
defined in terms of the space of the spatial locations. By default, 12
observations are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformation</code></td>
<td>
<p>transform response variable to normalise the data;
can be "sqrt" for square root, "arcsine" for arcsine, "log" or "none"
for non transformation. By default, "none" is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>numeric; to avoid 'log(0)' in "log" transformation. The default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula defining response vector and (possible) regressor.
an object (i.e., 'variogram.formula') for 'variogram' or a formula for
'krige'. see 'variogram' and 'krige' in the 'gstat' package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vgm.args</code></td>
<td>
<p>arguments for 'vgm', e.g. variogram model of response
variable and anisotropy parameters. see 'vgm' in the 'gstat' package for details.
By default, "Sph" is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anis</code></td>
<td>
<p>anisotropy parameters: see notes 'vgm' in the 'gstat' package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>direction in plane (x,y). see variogram in the 'gstat' package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>block size. see 'krige' in the 'gstat' package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>for simple kriging. see 'krige' in the 'gstat' package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predacc</code></td>
<td>
<p>can be either "VEcv" for vecv or "ALL" for all measures
in function pred.acc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to the function 'gstat'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following components:
me, rme, mae, rmae, mse, rmse, rrmse, vecv and e1; or vecv only
</p>


<h3>Note</h3>

<p>This function is largely based on rfcv in 'randomForest' and
some functions in 'library(gstat)'.  When 'A zero or negative range was fitted
to variogram' occurs, to allow 'gstat' running, the range was set to be positive by
using 'min(vgm1$dist)'. In this case, caution should be taken in applying this
method. If it still occurs for 'okpred' function, different method may need to be
used.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., 2013. Predictive Modelling Using Random Forest and Its
Hybrid Methods with Geostatistical Techniques in Marine Environmental
Geosciences, In: Christen, P., Kennedy, P., Liu, L., Ong, K.-L., Stranieri,
A., Zhao, Y. (Eds.), The proceedings of the Eleventh Australasian Data
Mining Conference (AusDM 2013), Canberra, Australia, 13-15 November 2013.
Conferences in Research and Practice in Information Technology, Vol. 146.
</p>
<p>A. Liaw and M. Wiener (2002). Classification and Regression by
randomForest. R News 2(3), 18-22.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(sp)
library(spm)
data(swmud)
data(petrel)

set.seed(1234)
okcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", vgm.args = ("Sph"), predacc = "VEcv")
okcv1

set.seed(1234)
skcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", vgm.args = ("Sph"), predacc = "VEcv", beta = mean(swmud[, 3]))
skcv1

set.seed(1234)
ukcv1 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], nmax = 7, transformation =
"arcsine", formula = var1 ~ long + lat, vgm.args = ("Sph"), predacc = "VEcv")
ukcv1

set.seed(1234)
okcv2 &lt;- krigecv(longlat = swmud[, c(1,2)], trainy = swmud[, 3], validation = "LOO", nmax = 7,
transformation = "arcsine", vgm.args = ("Sph"), predacc = "ALL")
okcv2

set.seed(1234)
n &lt;- 20 # number of iterations,60 to 100 is recommended.
VEcv &lt;- NULL
for (i in 1:n) {
okcv1 &lt;- krigecv(longlat = petrel[, c(1,2)], trainy = petrel[, 5], nmax = 12,
transformation = "arcsine", predacc = "VEcv")
VEcv [i] &lt;- okcv1
}
plot(VEcv ~ c(1:n), xlab = "Iteration for OK", ylab = "VEcv (%)")
points(cumsum(VEcv) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(VEcv), col = 'blue', lwd = 2)

set.seed(1234)
n &lt;- 20 # number of iterations, 60 to 100 is recommended.
measures &lt;- NULL
for (i in 1:n) {
okcv1 &lt;- krigecv(longlat = petrel[, c(1,2)], trainy = petrel[, 3], nmax = 12, transformation =
"arcsine", predacc = "ALL")
measures &lt;- rbind(measures, okcv1$vecv)
}
plot(measures ~ c(1:n), xlab = "Iteration for OK", ylab = "VEcv (%)")
points(cumsum(measures) / c(1:n) ~ c(1:n), col = 2)
abline(h = mean(measures), col = 'blue', lwd = 2)


</code></pre>


</div>