<div class="container">

<table style="width: 100%;"><tr>
<td>smcmc-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2><code>smcmc-class</code></h2>

<h3>Description</h3>

<p>Object representing the results of MCMC estimation on an object of class <code>synlik</code>, from which it inherits.
</p>


<h3>Slots</h3>


<dl>
<dt>initPar</dt>
<dd>
<p>Vector of initial parameters where the MCMC chain will start (<code>numeric</code>).</p>
</dd>
<dt>niter</dt>
<dd>
<p>Number of MCMC iterations (<code>integer</code>).</p>
</dd>
<dt>nsim</dt>
<dd>
<p>Number of simulations from the simulator at each step of the MCMC algorithm (<code>integer</code>).</p>
</dd>
<dt>burn</dt>
<dd>
<p>Number of initial MCMC iterations that are discarded (<code>integer</code>).</p>
</dd>
<dt>priorFun</dt>
<dd>
<p>Function that takes a vector of parameters as input and the log-density of the prior
as output. If the output is not finite the proposed point will be discarded. (<code>function</code>).
The function needs to have signature <code>fun(x, ...)</code>, where <code>x</code> represents the input parameters (<code>function</code>).</p>
</dd>
<dt>propCov</dt>
<dd>
<p>Matrix representing the covariance matrix to be used to perturb the 
parameters at each step of the MCMC chain (<code>matrix</code>).</p>
</dd>
<dt>targetRate</dt>
<dd>
<p>Target rate for the adaptive MCMC sampler. Should be in (0, 1), default is NULL (no adaptation). The adaptation
uses the approach of Vihola (2011). (<code>numeric</code>)</p>
</dd>
<dt>recompute</dt>
<dd>
<p>If TRUE the synthetic likelihood will be evaluated at the current and proposed positions in the parameter
space (thus doubling the computational effort). If FALSE the likelihood of the current
position won't be re-estimated (<code>logical</code>).</p>
</dd>
<dt>multicore</dt>
<dd>
<p>If TRUE the <code>object@simulator</code> and <code>object@summaries</code> functions will
be executed in parallel. That is the nsim simulations will be divided in multiple cores (<code>logical</code>).</p>
</dd>
<dt>ncores</dt>
<dd>
<p>Number of cores to use if multicore == TRUE (<code>integer</code>).</p>
</dd>
<dt>accRate</dt>
<dd>
<p>Acceptance rate of the MCMC chain, between 0 and 1 (<code>numeric</code>).</p>
</dd>
<dt>chains</dt>
<dd>
<p>Matrix of size niter by length(initPar) where the i-th row contains the position of the MCMC algorithm
in the parameter space at the i-th (<code>matrix</code>).</p>
</dd>
<dt>llkChain</dt>
<dd>
<p>Vector of niter elements where the i-th element is contains the estimate of the 
synthetic likelihood at the i-th iteration (<code>numeric</code>).</p>
</dd>
<dt>control</dt>
<dd>
<p>Control parameters used by the MCMC sampler: </p>

<ul>
<li>
<p><code>theta</code> = controls the speed of adaption. Should be between 0.5 and 1.
A lower gamma leads to faster adaption.
</p>
</li>
<li>
<p><code>adaptStart</code> = iteration where the adaption starts. Default 0.
</p>
</li>
<li>
<p><code>adaptStop</code> = iteration where the adaption stops. Default <code>burn + niter</code>
</p>
</li>
<li>
<p><code>saveFile</code> = path to the file where the intermediate results will be stored (ex: "~/Res.RData").
</p>
</li>
<li>
<p><code>saveFreq</code> = frequency with which the intermediate results will be saved on <code>saveFile</code>.
Default 100.
</p>
</li>
<li>
<p><code>verbose</code> = if <code>TRUE</code> intermediate posterior means will be printer.
</p>
</li>
<li>
<p><code>verbFreq</code> = frequency with which the intermediate posterior means will be printer. Default 500.
</p>
</li>
</ul>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>References</h3>

<p>Vihola, M. (2011) Robust adaptive Metropolis algorithm with coerced acceptance rate. 
Statistics and Computing.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load "synlik" object
data(ricker_sl)

plot(ricker_sl)
 
# MCMC estimation
set.seed(4235)
ricker_sl &lt;- smcmc(ricker_sl, 
                   initPar = c(3.2, -1, 2.6),
                   niter = 50, 
                   burn = 3,
                   priorFun = function(input, ...) 1, 
                   propCov = diag( c(0.1, 0.1, 0.1) )^2, 
                   nsim = 200, 
                   multicore = FALSE)

# Continue with additional 50 iterations
ricker_sl &lt;- continue(ricker_sl, niter = 50)

plot(ricker_sl)       

</code></pre>


</div>