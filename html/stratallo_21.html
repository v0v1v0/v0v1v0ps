<div class="container">

<table style="width: 100%;"><tr>
<td>opt_1sided</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Algorithms for Optimum Sample Allocation Under One-Sided Bounds</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>Functions that implement selected optimal allocation algorithms that compute
a solution to the optimal allocation problem defined in the language of
mathematical optimization as follows.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">f(x_1,\ldots,x_H) = \sum_{h=1}^H \frac{A^2_h}{x_h}</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H c_h x_h = c</code>
</p>

<p>and either
</p>
<p style="text-align: center;"><code class="reqn">x_h \leq M_h, \quad h = 1,\ldots,H</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">x_h \geq m_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where
<code class="reqn">c &gt; 0,\, c_h &gt; 0,\, A_h &gt; 0,\, m_h &gt; 0,\, M_h &gt; 0,\, h = 1,\ldots,H</code>,
are given numbers. The minimization is on <code class="reqn">\mathbb R_+^H</code>.
</p>
<p>The inequality constraints are optional and user can choose whether and how
they are to be added to the optimization problem.
If one-sided lower bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>, must be imposed, it
is then required that <code class="reqn">c \geq \sum_{h=1}^H c_h m_h</code>.
If one-sided upper bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>, must be imposed, it
is then required that <code class="reqn">0 &lt; c \leq \sum_{h=1}^H c_h M_h</code>.
Lower bounds can be specified instead of the upper bounds only in case of the
<em>LRNA</em> algorithm. All other algorithms allow only for specification of
the upper bounds. For the sake of clarity, we emphasize that in the
optimization problem consider here, the lower and upper bounds cannot be
imposed jointly.
</p>
<p>Costs <code class="reqn">c_h,\, h = 1,\ldots,H</code>, of surveying one element in stratum, can
be specified by the user only in case of the <em>RNA</em> and <em>LRNA</em>
algorithms. For remaining algorithms, these costs are fixed at 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
<p>The following is the list of all the algorithms available to use along with
the name of the function that implements a given algorithm. See the
description of a specific function to find out more about the corresponding
algorithm.
</p>

<ul>
<li> <p><em>RNA</em> - <code>rna()</code>
</p>
</li>
<li> <p><em>LRNA</em>- <code>rna()</code>
</p>
</li>
<li> <p><em>SGA</em>- <code>sga()</code>
</p>
</li>
<li> <p><em>SGAPLUS</em> - <code>sgaplus()</code>
</p>
</li>
<li> <p><em>COMA</em> - <code>coma()</code>
</p>
</li>
</ul>
<p>Functions in this family should not be called directly by the user. Use
<code>opt()</code> or <code>optcost()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rna(
  total_cost,
  A,
  bounds = NULL,
  unit_costs = 1,
  check_violations = .Primitive("&gt;="),
  details = FALSE
)

sga(total_cost, A, M)

sgaplus(total_cost, A, M)

coma(total_cost, A, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>total_cost</code></td>
<td>
<p>(<code>number</code>)<br> total cost <code class="reqn">c</code> of the survey. A strictly
positive scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(<code>numeric</code>)<br> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>) <br> optional lower bounds
<code class="reqn">m_1,\ldots,m_H</code>, or upper bounds <code class="reqn">M_1,\ldots,M_H</code>, or <code>NULL</code> to
indicate that there is no inequality constraints in the optimization
problem considered.
If not <code>NULL</code>, the <code>bounds</code> is to be treated either as:
</p>

<ul>
<li>
<p> lower bounds, if <code>check_violations = .Primitive("&lt;=")</code>. In this case, it
is required that <code>total_cost &gt;= sum(unit_costs * bounds)</code>, <br>
or
</p>
</li>
<li>
<p> upper bounds, if <code>check_violations = .Primitive("&gt;=")</code>. In this case, it
is required that <code>total_cost &lt;= sum(unit_costs * bounds)</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit_costs</code></td>
<td>
<p>(<code>numeric</code>)<br> costs <code class="reqn">c_1,\ldots,c_H</code>, of surveying one
element in stratum. A strictly positive numbers. Can be also of length 1,
if all unit costs are the same for all strata. In this case, the elements
will be recycled to the length of <code>bounds</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_violations</code></td>
<td>
<p>(<code>function</code>) <br> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>. The first of these choices
causes that <code>bounds</code> are treated as lower bounds and then <code>rna()</code> function
performs the <em>LRNA</em> algorithm. The latter option causes that <code>bounds</code>
are treated as upper bounds, and then <code>rna()</code> function performs the
<em>RNA</em> algorithm. This argument is ignored when <code>bounds</code> is set to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>(<code>flag</code>) <br> should detailed information about strata
assignments (either to take-Neyman or take-bound), values of set function
<code class="reqn">s</code> and number of iterations be added to the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata. If no upper bounds should be
imposed, then <code>M</code> must be set to <code>NULL</code>. Otherwise, it is required that
<code>total_cost &lt;= sum(unit_costs * M)</code>. Strictly positive numbers.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata. In case
of the <code>rna()</code> only, it can also be a <code>list</code> with optimal sample
allocations and strata assignments (either to take-Neyman or take-bound).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rna()</code>: <em>Recursive Neyman Algorithm</em> (<em>RNA</em>) and its
twin version, <em>Lower Recursive Neyman Algorithm</em> (<em>LRNA</em>)
dedicated to the allocation problem with one-sided lower-bounds constraints.
The <em>RNA</em> is described in Wesołowski et al. (2021), while <em>LRNA</em> is
introduced in Wójciak (2023).
</p>
</li>
<li> <p><code>sga()</code>: Stenger-Gabler type algorithm <em>SGA</em>, described in
Wesołowski et al. (2021) and in Stenger and Gabler (2005).
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li>
<li> <p><code>sgaplus()</code>: modified Stenger-Gabler type algorithm, described in
Wójciak (2019) as <em>Sequential Allocation (version 1)</em> algorithm.
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li>
<li> <p><code>coma()</code>: <em>Change of Monotonicity Algorithm</em> (<em>COMA</em>),
described in Wesołowski et al. (2021).
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>If no inequality constraints are added, the allocation is given by the
Neyman allocation as:
</p>
<p style="text-align: center;"><code class="reqn">x_h = \frac{A_h}{\sqrt{c_h}} \frac{n}{\sum_{i=1}^H A_i \sqrt{c_i}},
  \quad h = 1,\ldots,H.</code>
</p>

<p>For <em>stratified <code class="reqn">\pi</code> estimator</em> of the population total with
<em>stratified simple random sampling without replacement</em> design in use,
the parameters of the objective function <code class="reqn">f</code> are:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code> and <code class="reqn">S_h</code> denotes
standard deviation of a given study variable in stratum <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>Wójciak, W. (2023).
Another Solution of Some Optimum Allocation Problem.
<em>Statistics in Transition new series</em>, 24(5) (in press).
<a href="https://arxiv.org/abs/2204.04035">https://arxiv.org/abs/2204.04035</a> <br></p>
<p>Wesołowski, J., Wieczorkowski, R., Wójciak, W. (2021).
Optimality of the Recursive Neyman Allocation.
<em>Journal of Survey Statistics and Methodology</em>, 10(5), pp. 1263–1275.
<a href="https://doi.org/10.1093/jssam/smab018">doi:10.1093/jssam/smab018</a>,
<a href="https://doi.org/10.48550/arXiv.2105.14486">doi:10.48550/arXiv.2105.14486</a> <br></p>
<p>Wójciak, W. (2019). Optimal Allocation in Stratified Sampling Schemes.
<em>MSc Thesis</em>, Warsaw University of Technology, Warsaw, Poland.
<a href="http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf">http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf</a> <br></p>
<p>Stenger, H., Gabler, S. (2005).
Combining random sampling and census strategies -
Justification of inclusion probabilities equal to 1.
<em>Metrika</em>, 61(2), pp. 137–156.
<a href="https://doi.org/10.1007/s001840400328">doi:10.1007/s001840400328</a> <br></p>
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>opt()</code>, <code>optcost()</code>, <code>rnabox()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">A &lt;- c(3000, 4000, 5000, 2000)
m &lt;- c(50, 40, 10, 30) # lower bounds
M &lt;- c(100, 90, 70, 80) # upper bounds

rna(total_cost = 190, A = A, bounds = M)
rna(total_cost = 190, A = A, bounds = m, check_violations = .Primitive("&lt;="))
sga(total_cost = 190, A = A, M = M)
sgaplus(total_cost = 190, A = A, M = M)
coma(total_cost = 190, A = A, M = M)
</code></pre>


</div>