<div class="container">

<table style="width: 100%;"><tr>
<td>timeSeq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Sequences of Times 
</h2>

<h3>Description</h3>

<p>Constructs a regularly-spaced <code>timeDate</code> object.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">timeSeq(from, to, by = "days", length.out, k.by=1, align.by=FALSE,  
        extend=FALSE, week.align=NULL, holidays, exceptions, 
        additions, format, zone)
</code></pre>


<h3>Arguments</h3>

<p>at least one of <code>from</code> or <code>to</code> is required, plus <code>length.out</code> (the 
desired length of the resulting sequence). Alternatively can be both <code>from</code> and <code>to</code>, in 
which case if <code>length.out</code> and <code>by</code> are supplied, <code>length.out</code> is ignored. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>the starting value of the sequence: a <code>timeDate</code> object (or number or 
character string representing one). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>

<p>the ending value of the sequence: a <code>timeDate</code> object (or number or 
character string representing one). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>

<p>the spacing between the successive values in the sequence.  This can be 
a <code>timeSpan</code>, <code>timeRelative</code>, or <code>numeric</code> value,  
in which case <code>k.by</code> is ignored. 
Alternatively, it can be one  
of the following character strings, giving the time units of intervals between values in the sequence: 
</p>
<pre>
    "milliseconds"
    "seconds"
    "minutes"
    "hours"
    "days"
    "weekdays"
    "bizdays"
    "weeks"
    "months"
    "quarters"
    "years"
    </pre> 
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.out</code></td>
<td>

<p>the length of the sequence before additions and exceptions are included. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.by</code></td>
<td>

<p>a non-zero integer giving the width of the interval between consecutive 
values in the sequence in terms of the units given in <code>by</code>.  Ignored if 
<code>by</code> is not a character string. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>align.by</code></td>
<td>

<p>a logical value. If <code>TRUE</code>, adjusts the sequence so that each element is on
a whole number of the <code>by * k.by</code> units.
For example, if the units are 2 months, the sequence  
is on only the first of January, March, May, and so on.
Ignored if <code>by</code> is not a character string. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>

<p>a logical value. If <code>TRUE</code> and <code>align.by</code> is also <code>TRUE</code>,
instead of making the entire sequence lie between <code>from</code> and <code>to</code>,
make it extend just past <code>from</code> and <code>to</code>
to the next aligned values.
For example, if <code>from</code> is January 15th and the sequence 
is by 1 month units, and if <code>extend</code> is <code>FALSE</code>,
the sequence starts on February 1st,
and if it is <code>TRUE</code>, January 1st.
Ignored if <code>by</code> is not a character string. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>week.align</code></td>
<td>

<p>if <code>by</code> is <code>"weeks"</code>,  
you can supply a character 
string (or a number 0 to 6, with 0 being Sunday)  
to specify a weekday.  The character string must 
be sufficient to make a unique case-insensitive match to the strings 
in <code>timeDateOptions("time.day.name")</code>.  
The sequence is adjusted so all its elements fall on the
given weekday. If <code>align.by</code> 
is <code>TRUE</code>, then it is adjusted
to start at midnight. The <code>extend</code> argument 
is used to decide which direction to adjust the day. 
</p>
<p>This argument is ignored if 
<code>by</code> is not a character string, or if it
is not <code>"weeks"</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holidays</code></td>
<td>

<p>the holidays for business day sequences (ignored if <code>by</code> is not 
a character string).   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exceptions</code></td>
<td>

<p>an event object giving any time periods when the sequence should have 
no values.  These are applied after the sequence is created from 
from/to/by <code>length.out</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>additions</code></td>
<td>

<p>any additional times or dates to put in the sequence. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>

<p>the time/date output format for printing. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zone</code></td>
<td>

<p>the time zone for the sequence. 
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>returns a time/date object as defined by the arguments. 
</p>


<h3>See Also</h3>

<p><code>seq</code>,  <code>timeAlign</code>,  <code>timeSequence</code>,  <code>format.timeDate</code>,
<code>holidays</code>,
<code>timeEvent</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">timeSeq("1/1/1992", "1/10/1992") 
timeSeq("1/1/1992", "12/1/1992", by = "months") 
timeSeq("1/3/1992", "12/5/1992", by = "months", align.by=TRUE) 
timeSeq("1/3/1992", "12/5/1992", by = "months", align.by=TRUE, extend=TRUE) 
timeSeq("1/1/1992", "1/31/1992", by = "weeks", align.by=TRUE,  
   week.align="Mon") 
timeSeq("1/1/1992", "12/31/1992", by="weekdays", exceptions=holidays(1992))
timeSeq("1/1/1992", "1/1/1995", by="months", exceptions=timeEvent("1/1/1993", "12/31/1993"))
## subtract one day from a first-of-month sequence to create
## an end-of-month sequence
timeSeq(from = "2/1/2003", to = "1/1/2004", by = "months" ) - 1
</code></pre>


</div>