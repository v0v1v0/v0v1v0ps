<div class="container">

<table style="width: 100%;"><tr>
<td>build_hmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a Hidden Markov Model</h2>

<h3>Description</h3>

<p>Function <code>build_hmm</code> constructs a hidden Markov model object of class <code>hmm</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">build_hmm(
  observations,
  n_states,
  transition_probs,
  emission_probs,
  initial_probs,
  state_names = NULL,
  channel_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code>seqdef</code>) containing
the sequences, or a list of such objects (one for each channel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_states</code></td>
<td>
<p>A scalar giving the number of hidden states. Not used if starting values for model parameters
are given with <code>initial_probs</code>, <code>transition_probs</code>, or <code>emission_probs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transition_probs</code></td>
<td>
<p>A matrix of transition probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emission_probs</code></td>
<td>
<p>A matrix of emission probabilities or a list of such
objects (one for each channel). Emission probabilities should follow the
ordering of the alphabet of observations (<code>alphabet(observations)</code>, returned as <code>symbol_names</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_probs</code></td>
<td>
<p>A vector of initial state probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state_names</code></td>
<td>
<p>A list of optional labels for the hidden states. If <code>NULL</code>,
the state names are taken from the row names of the transition matrix. If this is
also <code>NULL</code>, numbered states are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>channel_names</code></td>
<td>
<p>A vector of optional names for the channels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>simulate_transition_probs</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The returned model contains some attributes such as <code>nobs</code> and <code>df</code>,
which define the number of observations in the  model and the number of estimable
model parameters, used in computing BIC.
When computing <code>nobs</code> for a multichannel model with <code class="reqn">C</code> channels,
each observed value in a single channel amounts to <code class="reqn">1/C</code> observation,
i.e. a fully observed time point for a single sequence amounts to one observation.
For the degrees of freedom <code>df</code>, zero probabilities of the initial model are
defined as structural zeroes.
</p>


<h3>Value</h3>

<p>Object of class <code>hmm</code> with the following elements:
</p>

<dl>
<dt><code>observations</code></dt>
<dd>
<p>State sequence object or a list of such objects containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt>
<dd>
<p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt>
<dd>
<p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt>
<dd>
<p>A vector of initial probabilities.</p>
</dd>
<dt><code>state_names</code></dt>
<dd>
<p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt>
<dd>
<p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt>
<dd>
<p>Names for channels of sequence data.</p>
</dd>
<dt><code>length_of_sequences</code></dt>
<dd>
<p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt>
<dd>
<p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt>
<dd>
<p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt>
<dd>
<p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt>
<dd>
<p>Number of channels.</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>fit_model</code> for estimating model parameters; and
<code>plot.hmm</code> for plotting <code>hmm</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Single-channel data

data("mvad", package = "TraMineR")

mvad_alphabet &lt;- c(
  "employment", "FE", "HE", "joblessness", "school",
  "training"
)
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet, states = mvad_scodes,
  labels = mvad_labels, xtstep = 6
)

# Initializing an HMM with 4 hidden states, random starting values
init_hmm_mvad1 &lt;- build_hmm(observations = mvad_seq, n_states = 4)

# Starting values for the emission matrix
emiss &lt;- matrix(NA, nrow = 4, ncol = 6)
emiss[1, ] &lt;- seqstatf(mvad_seq[, 1:12])[, 2] + 1
emiss[2, ] &lt;- seqstatf(mvad_seq[, 13:24])[, 2] + 1
emiss[3, ] &lt;- seqstatf(mvad_seq[, 25:48])[, 2] + 1
emiss[4, ] &lt;- seqstatf(mvad_seq[, 49:70])[, 2] + 1
emiss &lt;- emiss / rowSums(emiss)

# Starting values for the transition matrix

tr &lt;- matrix(
  c(
    0.80, 0.10, 0.05, 0.05,
    0.05, 0.80, 0.10, 0.05,
    0.05, 0.05, 0.80, 0.10,
    0.05, 0.05, 0.10, 0.80
  ),
  nrow = 4, ncol = 4, byrow = TRUE
)

# Starting values for initial state probabilities
init &lt;- c(0.3, 0.3, 0.2, 0.2)

# HMM with own starting values
init_hmm_mvad2 &lt;- build_hmm(
  observations = mvad_seq, transition_probs = tr,
  emission_probs = emiss, initial_probs = init
)

#########################################


# Multichannel data

# Three-state three-channel hidden Markov model
# See ?hmm_biofam for a five-state version

data("biofam3c")

# Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

# Define colors
attr(marr_seq, "cpal") &lt;- c("violetred2", "darkgoldenrod2", "darkmagenta")
attr(child_seq, "cpal") &lt;- c("darkseagreen1", "coral3")
attr(left_seq, "cpal") &lt;- c("lightblue", "red3")

# Left-to-right HMM with 3 hidden states and random starting values
set.seed(1010)
init_hmm_bf1 &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  n_states = 3, left_right = TRUE, diag_c = 2
)


# Starting values for emission matrices

emiss_marr &lt;- matrix(NA, nrow = 3, ncol = 3)
emiss_marr[1, ] &lt;- seqstatf(marr_seq[, 1:5])[, 2] + 1
emiss_marr[2, ] &lt;- seqstatf(marr_seq[, 6:10])[, 2] + 1
emiss_marr[3, ] &lt;- seqstatf(marr_seq[, 11:16])[, 2] + 1
emiss_marr &lt;- emiss_marr / rowSums(emiss_marr)

emiss_child &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_child[1, ] &lt;- seqstatf(child_seq[, 1:5])[, 2] + 1
emiss_child[2, ] &lt;- seqstatf(child_seq[, 6:10])[, 2] + 1
emiss_child[3, ] &lt;- seqstatf(child_seq[, 11:16])[, 2] + 1
emiss_child &lt;- emiss_child / rowSums(emiss_child)

emiss_left &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_left[1, ] &lt;- seqstatf(left_seq[, 1:5])[, 2] + 1
emiss_left[2, ] &lt;- seqstatf(left_seq[, 6:10])[, 2] + 1
emiss_left[3, ] &lt;- seqstatf(left_seq[, 11:16])[, 2] + 1
emiss_left &lt;- emiss_left / rowSums(emiss_left)

# Starting values for transition matrix
trans &lt;- matrix(
  c(
    0.9, 0.07, 0.03,
    0, 0.9, 0.1,
    0, 0, 1
  ),
  nrow = 3, ncol = 3, byrow = TRUE
)

# Starting values for initial state probabilities
inits &lt;- c(0.9, 0.09, 0.01)

# HMM with own starting values
init_hmm_bf2 &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  transition_probs = trans,
  emission_probs = list(emiss_marr, emiss_child, emiss_left),
  initial_probs = inits
)

</code></pre>


</div>