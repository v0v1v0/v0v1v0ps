<div class="container">

<table style="width: 100%;"><tr>
<td>SpatialQuantile.ppp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spatially Weighted Quantile of Values at Points
</h2>

<h3>Description</h3>

<p>Given a spatial point pattern with numeric marks,
compute a weighted quantile of the mark values,
with spatially-varying weights that depend on distance to the data points.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> ## S3 method for class 'ppp'
SpatialQuantile(X, prob = 0.5, sigma = NULL, ...,
        type = 1, at = c("pixels", "points"), leaveoneout = TRUE,
        weights = NULL, edge = TRUE, diggle = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>)
with numeric marks.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>

<p>Probability for which the quantile is required.
A single numeric value between 0 and 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Smoothing bandwidth, passed to <code>density.ppp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to <code>density.ppp</code> controlling the
spatial smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Integer specifying the type of median
(using the convention of <code>quantile.default</code>;
see Details).
Only types 1 and 4 are currently implemented.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>

<p>Character string indicating whether to compute the quantile
at every pixel of a pixel image (<code>at="pixels"</code>, the default)
or at every data point of <code>X</code> (<code>at="points"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of numeric weights attached to the points of <code>X</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge,diggle</code></td>
<td>

<p>Arguments passed to <code>density.ppp</code> to
determine the edge correction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports
during the calculation.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>X</code> should be a spatial point pattern
(object of class <code>"ppp"</code>) with numeric marks.
</p>
<p>The algorithm computes the weighted quantile of the mark values
at each desired spatial location, using spatially-varying weights
which depend on distance to the data points.
</p>
<p>Suppose the data points are at spatial locations
<code class="reqn">x_1,\ldots,x_n</code>
and have mark values 
<code class="reqn">y_1,\ldots,y_n</code>.
For a query location <code class="reqn">u</code>, the smoothed quantile is defined
as the weighted quantile of the mark values
<code class="reqn">y_1,\ldots,y_n</code> with weights
<code class="reqn">w_1(u),\ldots,w_n(u)</code>,
where
</p>
<p style="text-align: center;"><code class="reqn">
    w_i(u) = \frac{k(u,x_i)}{\sum_{j=1}^n k(u,x_j)}
  </code>
</p>

<p>where <code class="reqn">k(u,v)</code> is the smoothing kernel with bandwidth <code>sigma</code>.
</p>
<p>If <code>at="points"</code> and <code>leaveoneout=TRUE</code>, then
a leave-one-out calculation is performed, which means that
when the query location is a data point <code class="reqn">x_i</code>,
the value at the data point is ignored, and 
the weighted quantile is computed from the values <code class="reqn">y_j</code>
for all <code class="reqn">j</code> not equal to <code class="reqn">i</code>.
</p>
<p>The calculation of the quantile value depends on the argument
<code>type</code> which is interpreted in the same way as for
<code>quantile.default</code>. Currently, only types 1 and 4
are implemented. 
If <code>type=1</code> (the default), the quantile value is
one of the mark values (one of the values in <code>marks(x)</code>).
If <code>type=4</code>, the quantile value is obtained by linearly interpolating
between mark values.
Note that the default values of <code>type</code>
in <code>SpatialQuantile.ppp</code> and <code>SpatialMedian.ppp</code>
are different.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
</p>
</li>
</ul>
<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li>
</ul>
<p>The return value has attributes
<code>"sigma"</code> and <code>"varcov"</code> which report the smoothing
bandwidth that was used.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code>SpatialMedian.ppp</code>, <code>SpatialMedian</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">   X &lt;- longleaf
   if(!interactive()) {
    ## mark values rounded to nearest multiple of 10 to reduce check time
    marks(X) &lt;- round(marks(X), -1)
   }
   Z &lt;- SpatialQuantile(X, prob=0.25, sigma=30)
   ZX &lt;- SpatialQuantile(X, prob=0.25, sigma=30, at="points")
</code></pre>


</div>