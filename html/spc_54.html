<div class="container">

<table style="width: 100%;"><tr>
<td>xcusum.crit.L0L1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control L1</h2>

<h3>Description</h3>

<p>Computation of the reference value k and the alarm threshold h
for one-sided CUSUM control charts monitoring normal mean, if the in-control ARL L0 and the out-of-control L1 are given.</p>


<h3>Usage</h3>

<pre><code class="language-R">xcusum.crit.L0L1(L0, L1, hs=0, sided="one", r=30, L1.eps=1e-6, k.eps=1e-8)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>in-control ARL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L1</code></td>
<td>
<p>out-of-control ARL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p>distinguishes between one-, two-sided and Crosier's modified
two-sided CUSUM schemoosing <code>"one"</code>, <code>"two"</code>, and <code>"Crosier"</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code> (Crosier).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L1.eps</code></td>
<td>
<p>error bound for the L1 error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.eps</code></td>
<td>
<p>bound for the difference of two successive values of k.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>xcusum.crit.L0L1</code> determines the reference value k and the alarm threshold h
for given in-control ARL <code>L0</code> and out-of-control ARL <code>L1</code>
by applying secant rule and using <code>xcusum.arl()</code> and <code>xcusum.crit()</code>.
These CUSUM design rules were firstly (and quite rarely afterwards) used by Ewan and Kemp.
</p>


<h3>Value</h3>

<p>Returns two values which resemble the reference value <code>k</code> and the threshold <code>h</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>W. D. Ewan and K. W. Kemp (1960),
Sampling inspection of continuous processes with no autocorrelation between successive results,
<em>Biometrika 47</em>, 363-380.
</p>
<p>K. W. Kemp (1962),
The Use of Cumulative Sums for Sampling Inspection Schemes,
<em>Journal of the Royal Statistical Sociecty C, Applied Statistics, 10</em>, 16-31.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL and <code>xcusum.crit</code> for threshold h computation.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Table 2 from Ewan/Kemp (1960) -- one-sided CUSUM
#
# A.R.L. at A.Q.L.   A.R.L. at A.Q.L.     k      h
#       1000                3           1.12   2.40
#       1000                7           0.65   4.06
#        500                3           1.04   2.26
#        500                7           0.60   3.80
#        250                3           0.94   2.11
#        250                7           0.54   3.51
#
L0.set &lt;- c(1000, 500, 250)
L1.set &lt;- c(3, 7)
cat("\nL0\tL1\tk\th\n")
for ( L0 in L0.set ) {
  for ( L1 in L1.set ) {
    result &lt;- round(xcusum.crit.L0L1(L0, L1), digits=2)
    cat(paste(L0, L1, result[1], result[2], sep="\t"), "\n")
  }
}
#
# two confirmation runs
xcusum.arl(0.54, 3.51, 0) # Ewan/Kemp
xcusum.arl(result[1], result[2], 0) # here
xcusum.arl(0.54, 3.51, 2*0.54) # Ewan/Kemp
xcusum.arl(result[1], result[2], 2*result[1]) # here
#
## Table II from Kemp (1962) -- two-sided CUSUM
#
#    Lr                  k
#             La=250   La=500   La=1000
#    2.5       1.05     1.17     1.27
#    3.0       0.94     1.035    1.13
#    4.0       0.78     0.85     0.92
#    5.0       0.68     0.74     0.80
#    6.0       0.60     0.655    0.71
#    7.5       0.52     0.57     0.62
#   10.0       0.43     0.48     0.52
#
L0.set &lt;- c(250, 500, 1000)
L1.set &lt;- c(2.5, 3:6, 7.5, 10)
cat("\nL1\tL0=250\tL0=500\tL0=1000\n")
for ( L1 in L1.set ) {
  cat(L1)
  for ( L0 in L0.set ) {
    result &lt;- round(xcusum.crit.L0L1(L0, L1, sided="two"), digits=2)
    cat("\t", result[1])
  }
  cat("\n")
}
</code></pre>


</div>