<div class="container">

<table style="width: 100%;"><tr>
<td>simulateSNPs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of SNP data</h2>

<h3>Description</h3>

<p>Simulates SNP data, where a specified proportion of cases and controls
is explained by specified set of SNP interactions. Can also be used
to simulate a data set with a multi-categorical response, i.e.\
a data set in which the cases are divided into several classes (e.g.,
different diseases or subtypes of a disease).
</p>


<h3>Usage</h3>

<pre><code class="language-R">simulateSNPs(n.obs, n.snp, vec.ia, prop.explain = 1, 
  list.ia.val = NULL, vec.ia.num = NULL, vec.cat = NULL,
  maf = c(0.1, 0.4), prob.val = rep(1/3, 3), list.equal = NULL, 
  prob.equal = 0.8, rm.redundancy = TRUE, shuffle = FALSE, 
  shuffle.obs = FALSE, rand = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>either an integer specifying the total number of 
observations, or a vector of length 2 specifying the number 
of cases and the number of controls. If <code>vec.cat</code> is specified,
then the partitioning of the number of cases to the different
classes can be governed by <code>vec.ia.num</code>. If <code>n.obs</code> is
an integer, then <code class="reqn">1 / c</code> of the observations will be controls and
the remaining observations will be cases, where <code class="reqn">c</code> is the total number
of groups (including the controls).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.snp</code></td>
<td>
<p>integer specifying the number of SNPs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec.ia</code></td>
<td>
<p>a vector of integers specifying the orders of the interactions
that explain the cases. <code>c(3,1,2,3)</code>, e.g., means that a three-way,
a one-way (i.e. just a SNP), a two-way, and a three-way interaction explain the cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop.explain</code></td>
<td>
<p>either an integer or a vector of <code>length(vec.ia)</code> 
specifying the proportions of cases explained by the interactions of interest
among all observation having the interaction of interest. Must be larger than 0.5.
E.g., <code>prop.explain = 1</code> means that only cases have the interactions of interest
specified by <code>vec.ia</code> (and <code>list.ia.val</code>). E.g., <code>vec.ia = c(3, 2)</code>
and <code>prop.explain = c(1, 0.8)</code> means that only cases have the three-way interaction of
interest, while 80% of the observations having the two-way interaction of interest
are cases, and 20% are controls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.ia.val</code></td>
<td>
<p>a list of <code>length(vec.ia)</code> specifying the exact interactions.
The objects in this list must be vectors of length <code>vec.ia[i]</code>, and consist
of the values 0 (for homozygous reference), 1 (heterozygous variant), or 2 (homozygous variant).
E.g., <code>vec.ia = c(3, 2)</code> and <code>list.ia.val = list(c(2, 0, 1), c(0, 2))</code> 
and <code>prob.equal = 1</code> (see also <code>list.equal</code>) means that
((SNP1 == 2) \&amp; (SNP2 == 0) \&amp; (SNP3 == 1)) and ((SNP4 == 0) \&amp; (SNP5 == 2))
are the explanatory interactions (if additionally <code>prob.equal = 1</code>; see also
<code>list.equal</code>). If <code>NULL</code>, the genotypes are randomly drawn
using the probabilities given by <code>prob.val</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec.ia.num</code></td>
<td>
<p>a vector of <code>length(vec.ia)</code> specifying the number of
<em>cases</em> (not observations) explained by the interactions in <code>vec.ia</code>.
If <code>NULL</code>, all the cases are divided into <code>length(vec.ia)</code> groups of
about the same size. <code>sum(vec.ia.num)</code> must be smaller than
or equal to the total number of cases. Each entry of <code>vec.ia.num</code> must currently be &gt;= 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec.cat</code></td>
<td>
<p>a vector of the same length of <code>vec.ia</code> specifying the subclasses
of the cases that are explained by the corresponding interaction in <code>vec.ia</code>. If <code>NULL</code>,
no subclasses will be considered. This feature is currently not fully tested. So be careful
if specifying <code>vec.cat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maf</code></td>
<td>
<p>either an integer, or a vector of length 2 or <code>n.snp</code> specifying
the minor allele frequencies. If an integer, all SNPs will have the same
minor allele frequency. If a vector of length <code>n.snp</code>, each SNP will have the minor
allele frequency specified in the corresponding entry of <code>maf</code>. If length 2, then
<code>maf</code> is interpreted as the range of the minor allele frequencies, and for each SNP,
a minor allele frequency will be randomly drawn from a uniform distribution with 
the range given by <code>maf</code>. Note: If a SNP belongs to an explanatory interaction,
then only the set of observations not explained by this interaction will have
the minor allele frequency specified by <code>maf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.val</code></td>
<td>
<p>a vector consisting of the probabilities for drawing a 0, 1, or 2,
if <code>list.ia.val = NULL</code>, i.e.\ if the genotypes of the SNPs explaining the case-control
status should be randomly drawn. Ignored if <code>list.ia.val</code> is specified. By default,
each genotype has the same probability of being drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.equal</code></td>
<td>
<p>list of same structure as <code>list.ia.val</code> containing only ones and
zeros, where a 1 specifies the equality to the corresponding value in
<code>list.ia.val</code>, and a 0 specifies the non-equality. Thus, the entries of <code>list.equal</code>
specify if the corresponding SNP should be of a particular genotype (when the entry is 1)
or should be not of this genotype (when entry is 0). If <code>NULL</code>, this list
will be generated automatically using <code>prob.equal</code>. If, e.g., <code>vec.ia = c(3, 2)</code>,
<code>list.ia.val = list(c(2, 0, 1), c(0, 2))</code>,
and <code>list.equal = list(c(1, -1, 1), c(1, -1))</code>, then the explanatory interactions are
given by ((SNP1 == 2) \&amp; (SNP2 != 0) \&amp; (SNP3 == 1)) and ((SNP4 == 0) \&amp; (SNP5 != 2))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.equal</code></td>
<td>
<p>a numeric value specifying the probability that a 1 is drawn when generating
<code>list.equal</code>. <code>prob.equal</code> is thus the probability for an equal sign.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.redundancy</code></td>
<td>
<p>should redundant SNPs be removed from the explaining interactions?
It is possible that one specify an explaining <code class="reqn">i</code>-way interaction, but an interaction
between <code class="reqn">(i-1)</code> of the variables contained in the <code class="reqn">i</code>-way
interaction already explains all the cases (and controls) that the <code class="reqn">i</code>-way interaction
should explain. In this case, the redundant SNP is removed if <code>rm.redundancy = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle</code></td>
<td>
<p>logical. By default, the first <code>sum(vec.ia)</code> columns of the generated
data set contain the explanatory SNPs in the same order as they appear in this data set.
If <code>TRUE</code>, this order will be shuffled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle.obs</code></td>
<td>
<p>should the observations be shuffled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>integer. Sets the random number generator in a reproducible state.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>simulatedSNPs</code> composed of
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix with <code>n.obs</code> rows and <code>n.snp</code> columns containing
the SNP data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a vector of length <code>n.obs</code> comprising the case-control status of the
observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tab.explain</code></td>
<td>
<p>a table naming the explanatory interactions and the numbers
of cases and controls explained by them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ia</code></td>
<td>
<p>character vector naming the interactions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maf</code></td>
<td>
<p>vector of length <code>n.snp</code> containing the minor allele frequencies.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Currently, the genotypes of all SNPs are simulated independently from each other
(except for the SNPs that belong to the same explanatory interaction).</p>


<h3>Author(s)</h3>

<p>Holger Schwender <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>See Also</h3>

<p><code>simulateSNPglm</code>, <code>simulateSNPcatResponse</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Simulate a data set containing 2000 observations (1000 cases
# and 1000 controls) and 50 SNPs, where one three-way and two 
# two-way interactions are chosen randomly to be explanatory 
# for the case-control status.

sim1 &lt;- simulateSNPs(2000, 50, c(3, 2, 2))
sim1

# Simulate data of 1200 cases and 800 controls for 50 SNPs, 
# where 90% of the observations showing a randomly chosen 
# three-way interaction are cases, and 95% of the observations 
# showing a randomly chosen two-way interactions are cases.

sim2 &lt;- simulateSNPs(c(1200, 800), 50, c(3, 2), 
   prop.explain = c(0.9, 0.95))
sim2

# Simulate a data set consisting of 1000 observations and 50 SNPs,
# where the minor allele frequency of each SNP is 0.25, and
# the interactions 
# ((SNP1 == 2) &amp; (SNP2 != 0) &amp; (SNP3 == 1))   and 
# ((SNP4 == 0) &amp; (SNP5 != 2))
# are explanatory for 200 and 250 of the 500 cases, respectively,
# and for none of the 500 controls.

list1 &lt;- list(c(2, 0, 1), c(0, 2))
list2 &lt;- list(c(1, 0, 1), c(1, 0))
sim3 &lt;- simulateSNPs(1000, 50, c(3, 2), list.ia.val = list1,
    list.equal = list2, vec.ia.num = c(200, 250), maf = 0.25)


## End(Not run)</code></pre>


</div>