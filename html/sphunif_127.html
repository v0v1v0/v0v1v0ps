<div class="container">

<table style="width: 100%;"><tr>
<td>Gegenbauer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gegenbauer polynomials and coefficients</h2>

<h3>Description</h3>

<p>The <a href="https://dlmf.nist.gov/18.3">Gegenbauer polynomials</a>
<code class="reqn">\{C_k^{(\lambda)}(x)\}_{k = 0}^\infty</code>
form a family of orthogonal polynomials on the interval <code class="reqn">[-1, 1]</code>
with respect to the weight function <code class="reqn">(1 - x^2)^{\lambda - 1/2}</code>,
for <code class="reqn">\lambda &gt; -1/2</code>, <code class="reqn">\lambda \neq 0</code>. They usually appear
when dealing with functions defined on
<code class="reqn">S^{p-1} := \{{\bf x} \in R^p : ||{\bf x}|| = 1\}</code> with index <code class="reqn">\lambda = p / 2 - 1</code>.
</p>
<p>The Gegenbauer polynomials are somehow simpler to evaluate for
<code class="reqn">x = \cos(\theta)</code>, with <code class="reqn">\theta \in [0, \pi]</code>. This simplifies
also the connection with the Chebyshev polynomials
<code class="reqn">\{T_k(x)\}_{k = 0}^\infty</code>, which admit
the <a href="https://dlmf.nist.gov/18.5.E1">explicit expression</a>
<code class="reqn">T_k(\cos(\theta)) = \cos(k\theta)</code>. The Chebyshev polynomials
appear as the limit of the Gegenbauer polynomials
(divided by <code class="reqn">\lambda</code>) when <code class="reqn">\lambda</code> goes to <code class="reqn">0</code>, so they
can be regarded as the extension by continuity of
<code class="reqn">\{C_k^{(p/2 - 1)}(x)\}_{k = 0}^\infty</code> to the case <code class="reqn">p = 2</code>.
</p>
<p>For a <a href="https://dlmf.nist.gov/18.18.i">reasonably smooth</a> function
<code class="reqn">\psi</code> defined on <code class="reqn">[0, \pi]</code>,
</p>
<p style="text-align: center;"><code class="reqn">\psi(\theta) = \sum_{k = 0}^\infty b_{k, p}
C_k^{(p/2 - 1)}(\cos(\theta)),</code>
</p>

<p>provided that the coefficients
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p} := \frac{1}{c_{k, p}} \int_0^\pi \psi(\theta)
C_k^{(p/2 - 1)}(\cos(\theta)) (\sin(\theta))^{p - 2}\,\mathrm{d}\theta</code>
</p>

<p>are finite, where the normalizing constants are
</p>
<p style="text-align: center;"><code class="reqn">c_{k, p} := \int_0^\pi (C_k^{(p/2 - 1)}(\cos(\theta)))^2
(\sin(\theta))^{p - 2} \,\mathrm{d}\theta.</code>
</p>

<p>The (squared) "Gegenbauer norm" of <code class="reqn">\psi</code> is
</p>
<p style="text-align: center;"><code class="reqn">\|\psi\|_{G, p}^2 := \int_0^\pi \psi(\theta)^2
C_k^{(p/2 - 1)}(\cos(\theta)) (\sin(\theta))^{p - 2}\,\mathrm{d}\theta.</code>
</p>

<p>The previous expansion can be generalized for a 2-dimensional function
<code class="reqn">\psi</code> defined on <code class="reqn">[0, \pi] \times [0, \pi]</code>:
</p>
<p style="text-align: center;"><code class="reqn">\psi(\theta_1, \theta_2) = \sum_{k = 0}^\infty \sum_{m = 0}^\infty
b_{k, m, p} C_k^{(p/2 - 1)}(\cos(\theta_1))
C_k^{(p/2 - 1)}(\cos(\theta_2)),</code>
</p>

<p>with coefficients
</p>
<p style="text-align: center;"><code class="reqn">b_{k, m, p} := \frac{1}{c_{k, p} c_{m, p}} \int_0^\pi\int_0^\pi
\psi(\theta_1, \theta_2) C_k^{(p/2 - 1)}(\cos(\theta_1))
C_k^{(p/2 - 1)}(\cos(\theta_2)) (\sin(\theta_1))^{p - 2}
(\sin(\theta_2))^{p - 2}\,\mathrm{d}\theta_1\,\mathrm{d}\theta_2.</code>
</p>

<p>The (squared) "Gegenbauer norm" of <code class="reqn">\psi</code> is
</p>
<p style="text-align: center;"><code class="reqn">\|\psi\|_{G, p}^2 := \int_0^\pi\int_0^\pi \psi(\theta_1, \theta_2)^2
C_k^{(p/2 - 1)}(\cos(\theta_1)) C_k^{(p/2 - 1)}(\cos(\theta_2))
(\sin(\theta_1))^{p - 2} (\sin(\theta_2))^{p - 2}
\,\mathrm{d}\theta_1\,\mathrm{d}\theta_2.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">Gegen_polyn(theta, k, p)

Gegen_coefs(k, p, psi, Gauss = TRUE, N = 320, normalize = TRUE,
  only_const = FALSE, tol = 1e-06, ...)

Gegen_series(theta, coefs, k, p, normalize = TRUE)

Gegen_norm(coefs, k, p, normalize = TRUE, cumulative = FALSE)

Gegen_polyn_2d(theta_1, theta_2, k, m, p)

Gegen_coefs_2d(k, m, p, psi, Gauss = TRUE, N = 320, normalize = TRUE,
  only_const = FALSE, tol = 1e-06, ...)

Gegen_series_2d(theta_1, theta_2, coefs, k, m, p, normalize = TRUE)

Gegen_norm_2d(coefs, k, m, p, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta, theta_1, theta_2</code></td>
<td>
<p>vectors with values in <code class="reqn">[0, \pi]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k, m</code></td>
<td>
<p>vectors with the orders of the Gegenbauer polynomials. Must
be integers larger or equal than <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>function defined in <code class="reqn">[0, \pi]</code> and whose Gegenbauer
coefficients are to be computed. Must be vectorized. For
<code>Gegen_coefs_2d</code>, it must return a matrix of size
<code>c(length(theta_1), length(theta_2))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gauss</code></td>
<td>
<p>use a Gauss–Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code>integrate</code>. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of points used in the 
Gauss–Legendre quadrature for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>consider normalized coefficients (divided by
<code class="reqn">c_{k, p}</code>)? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only_const</code></td>
<td>
<p>return only the normalizing constants <code class="reqn">c_{k, p}</code>?
Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance passed to <code>integrate</code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to <code>psi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>for <code>Gegen_series</code> and <code>Gegen_norm</code>, a vector of
coefficients <code class="reqn">b_{k, p}</code> with length <code>length(k)</code>. For
<code>Gegen_series_2d</code> and <code>Gegen_norm_2d</code>, a matrix of coefficients
<code class="reqn">b_{k, m, p}</code> with size <code>c(length(k), length(m))</code>. The
order of the coefficients is given by <code>k</code> and <code>m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>return the cumulative norm for increasing truncation of
the series? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>Gegen_polyn</code> function is a wrapper to the functions
<code>gegenpoly_n</code> and
<code>gegenpoly_array</code> in the
<code>gsl-package</code>, which they interface the functions
defined in the header file <code>gsl_sf_gegenbauer.h</code> (documented
<a href="https://www.gnu.org/software/gsl/doc/html/specfunc.html#gegenbauer-functions">
here</a>) of the <a href="https://www.gnu.org/software/gsl/">
GNU Scientific Library</a>.
</p>
<p>Note that the function <code>Gegen_polyn</code> computes the regular
<em>unnormalized</em> Gegenbauer polynomials.
</p>
<p>For the case <code class="reqn">p = 2</code>, the Chebyshev polynomials are considered.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>Gegen_polyn</code>: a matrix of size
<code>c(length(theta), length(k))</code> containing the evaluation of the
<code>length(k)</code> Gegenbauer polynomials at <code>theta</code>.
</p>
</li>
<li> <p><code>Gegen_coefs</code>: a vector of size <code>length(k)</code> containing
the coefficients <code class="reqn">b_{k, p}</code>.
</p>
</li>
<li> <p><code>Gegen_series</code>: the evaluation of the truncated series
expansion, a vector of size <code>length(theta)</code>.
</p>
</li>
<li> <p><code>Gegen_norm</code>: the Gegenbauer norm of the truncated series,
a scalar if <code>cumulative = FALSE</code>, otherwise a vector of size
<code>length(k)</code>.
</p>
</li>
<li> <p><code>Gegen_polyn_2d</code>: a 4-dimensional array of size
<code>c(length(theta_1), length(theta_2), length(k), length(m))</code>
containing the evaluation of the <code>length(k) * length(m)</code>
2-dimensional Gegenbauer polynomials at the bivariate grid
spanned by <code>theta_1</code> and <code>theta_2</code>.
</p>
</li>
<li> <p><code>Gegen_coefs_2d</code>: a matrix of size
<code>c(length(k), length(m))</code> containing the coefficients
<code class="reqn">b_{k, m, p}</code>.
</p>
</li>
<li> <p><code>Gegen_series_2d</code>: the evaluation of the truncated series
expansion, a matrix of size <code>c(length(theta_1), length(theta_2))</code>.
</p>
</li>
<li> <p><code>Gegen_norm_2d</code>: the 2-dimensional Gegenbauer norm of the
truncated series, a scalar.
</p>
</li>
</ul>
<h3>References</h3>

<p>Galassi, M., Davies, J., Theiler, J., Gough, B., Jungman, G., Alken, P.,
Booth, M., and Rossi, F. (2009) <em>GNU Scientific Library Reference
Manual</em>. Network Theory Ltd. <a href="http://www.gnu.org/software/gsl/">http://www.gnu.org/software/gsl/</a>
</p>
<p><em>NIST Digital Library of Mathematical Functions</em>. Release
1.0.20 of 2018-09-15. F. W. J. Olver, A. B. Olde Daalhuis, D. W. Lozier,
B. I. Schneider, R. F. Boisvert, C. W. Clark, B. R. Miller,
and B. V. Saunders, eds. <a href="https://dlmf.nist.gov/">https://dlmf.nist.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Representation of Gegenbauer polynomials (Chebyshev polynomials for p = 2)

th &lt;- seq(0, pi, l = 500)
k &lt;- 0:3
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) {
  matplot(th, t(Gegen_polyn(theta = th, k = k, p = p)), lty = 1,
          type = "l", main = substitute(p == d, list(d = p)),
          axes = FALSE, xlab = expression(theta), ylab = "")
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  mtext(text = expression({C[k]^{p/2 - 1}}(cos(theta))), side = 2,
        line = 2, cex = 0.75)
  legend("bottomleft", legend = paste("k =", k), lwd = 2, col = seq_along(k))
}
par(old_par)

## Coefficients and series in p = 2

# Function in [0, pi] to be projected in Chebyshev polynomials
psi &lt;- function(th) -sin(th / 2)

# Coefficients
p &lt;- 2
k &lt;- 0:4
(coefs &lt;- Gegen_coefs(k = k, p = p, psi = psi))

# Series
plot(th, psi(th), type = "l", axes = FALSE, xlab = expression(theta),
      ylab = "", ylim = c(-1.25, 0))
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2); box()
col &lt;- viridisLite::viridis(length(coefs))
for (i in seq_along(coefs)) {
  lines(th, Gegen_series(theta = th, coefs = coefs[1:(i + 1)], k = 0:i,
                         p = p), col = col[i])
}
lines(th, psi(th), lwd = 2)

## Coefficients and series in p = 3

# Function in [0, pi] to be projected in Gegenbauer polynomials
psi &lt;- function(th) tan(th / 3)

# Coefficients
p &lt;- 3
k &lt;- 0:10
(coefs &lt;- Gegen_coefs(k = k, p = p, psi = psi))

# Series
plot(th, psi(th), type = "l", axes = FALSE, xlab = expression(theta),
      ylab = "", ylim = c(0, 2))
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2); box()
col &lt;- viridisLite::viridis(length(coefs))
for (i in seq_along(coefs)) {
  lines(th, Gegen_series(theta = th, coefs = coefs[1:(i + 1)], k = 0:i,
                         p = p), col = col[i])
}
lines(th, psi(th), lwd = 2)

## Surface representation

# Surface in [0, pi]^2 to be projected in Gegenbauer polynomials
p &lt;- 3
psi &lt;- function(th_1, th_2) A_theta_x(theta = th_1, x = cos(th_2),
                                      p = p, as_matrix = TRUE)

# Coefficients
k &lt;- 0:20
m &lt;- 0:10
coefs &lt;- Gegen_coefs_2d(k = k, m = m, p = p, psi = psi)

# Series
th &lt;- seq(0, pi, l = 100)
col &lt;- viridisLite::viridis(20)
old_par &lt;- par(mfrow = c(2, 2))
image(th, th, A_theta_x(theta = th, x = cos(th), p = p), axes = FALSE,
      col = col, zlim = c(0, 1), xlab = expression(theta[1]),
      ylab = expression(theta[2]), main = "Original")
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
box()
for(K in c(5, 10, 20)) {
  A &lt;- Gegen_series_2d(theta_1 = th, theta_2 = th,
                       coefs = coefs[1:(K + 1), ], k = 0:K, m = m, p = p)
  image(th, th, A, axes = FALSE, col = col, zlim = c(0, 1),
        xlab = expression(theta[1]), ylab = expression(theta[2]),
        main = paste(K, "x", m[length(m)], "coefficients"))
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  box()
}
par(old_par)

</code></pre>


</div>