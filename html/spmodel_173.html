<div class="container">

<table style="width: 100%;"><tr>
<td>spautor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit spatial autoregressive models</h2>

<h3>Description</h3>

<p>Fit spatial linear models for areal data (i.e., spatial autoregressive models)
using a variety of estimation methods, allowing for random effects,
partition factors, and row standardization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spautor(
  formula,
  data,
  spcov_type,
  spcov_initial,
  estmethod = "reml",
  random,
  randcov_initial,
  partition_factor,
  W,
  row_st = TRUE,
  M,
  range_positive = TRUE,
  cutoff,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A two-sided linear formula describing the fixed effect structure
of the model, with the response to the left of the <code>~</code> operator and
the terms, separated by <code>+</code> operators, on the right.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or <code>sf</code> object that contains
the variables in <code>fixed</code>, <code>random</code>, and <code>partition_factor</code>,
as well as potentially geographical information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spcov_type</code></td>
<td>
<p>The spatial covariance type. Available options include
<code>"car"</code> and <code>"sar"</code>. Parameterizations of each spatial covariance type are
available in Details. When <code>spcov_type</code> is specified, relevant spatial
covariance parameters are assumed unknown, requiring estimation.
<code>spcov_type</code> is not required (and is
ignored) if <code>spcov_initial</code> is provided.  Multiple values can be
provided in a character vector. Then <code>spautor()</code> is called iteratively
for each element and a list is returned for each model fit.
The default for <code>spcov_type</code> is <code>"car"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spcov_initial</code></td>
<td>
<p>An object from <code>spcov_initial()</code> specifying initial and/or
known values for the spatial covariance parameters.
Not required if <code>spcov_type</code> is provided. Multiple <code>spcov_initial()</code>
objects can be provided in a list. Then <code>spautor()</code> is called iteratively
for each element and a list is returned for each model fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estmethod</code></td>
<td>
<p>The estimation method. Available options include
<code>"reml"</code> for restricted maximum likelihood and <code>"ml"</code> for maximum
likelihood The default is
<code>"reml"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>A one-sided linear formula describing the random effect structure
of the model. Terms are specified to the right of the <code>~ operator</code>.
Each term has the structure <code>x1 + ... + xn | g1/.../gm</code>, where <code>x1 + ... + xn</code>
specifies the model for the random effects and <code>g1/.../gm</code> is the grouping
structure. Separate terms are separated by <code>+</code> and must generally
be wrapped in parentheses. Random intercepts are added to each model
implicitly when at least  one other variable is defined.
If a random intercept is not desired, this must be explicitly
defined (e.g., <code>x1 + ... + xn - 1 | g1/.../gm</code>). If only a random intercept
is desired for a grouping structure, the random intercept must be specified
as <code>1 | g1/.../gm</code>. Note that <code>g1/.../gm</code> is shorthand for <code>(1 | g1/.../gm)</code>.
If only random intercepts are desired and the shorthand notation is used,
parentheses can be omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randcov_initial</code></td>
<td>
<p>An optional object specifying initial and/or
known values for the random effect variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition_factor</code></td>
<td>
<p>A one-sided linear formula with a single term
specifying the partition factor.  The partition factor assumes observations
from different levels of the partition factor are uncorrelated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Weight matrix specifying the neighboring structure used.
Not required if <code>data</code> is an <code>sf</code> object wtih <code>POLYGON</code> geometry,
as <code>W</code> is calculated internally using queen contiguity. If calculated internally,
<code>W</code> is computed using <code>sf::st_intersects()</code>. Also not required if <code>data</code>
is an <code>sf</code> object with <code>POINT</code> geometry as long as <code>cutoff</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_st</code></td>
<td>
<p>A logical indicating whether row standardization be performed on
<code>W</code>. The default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p><code>M</code> matrix satisfying the car symmetry condition. The car
symmetry condition states that <code class="reqn">(I - range * W)^{-1}M</code> is symmetric, where
<code class="reqn">I</code> is an identity matrix, <code class="reqn">range</code> is a constant that controls the
spatial dependence, <code>W</code> is the weights matrix,
and <code class="reqn">^{-1}</code> represents the inverse operator.
<code>M</code> is required for car models
when <code>W</code> is provided and <code>row_st</code> is <code>FALSE</code>.  When <code>M</code>,
is required, the default is the identity matrix. <code>M</code> must be diagonal
or given as a vector or one-column matrix assumed to be the diagonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range_positive</code></td>
<td>
<p>Whether the range should be constrained to be positive.
The default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>The numeric, distance-based cutoff used to determine <code>W</code>
when <code>W</code> is not specified. For an <code>sf</code> object with <code>POINT</code> geometry,
two locations are considered neighbors if the distance between them is less
than or equal to <code>cutoff</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to <code>stats::optim()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The spatial linear model for areal data (i.e., spatial autoregressive model)
can be written as
<code class="reqn">y = X \beta + \tau + \epsilon</code>, where <code class="reqn">X</code> is the fixed effects design
matrix, <code class="reqn">\beta</code> are the fixed effects, <code class="reqn">\tau</code> is random error that is
spatially dependent, and <code class="reqn">\epsilon</code> is random error that is spatially
independent. Together, <code class="reqn">\tau</code> and <code class="reqn">\epsilon</code> are modeled using
a spatial covariance function, expressed as
<code class="reqn">de * R + ie * I</code>, where <code class="reqn">de</code> is the dependent error variance, <code class="reqn">R</code>
is a matrix that controls the spatial dependence structure among observations,
<code class="reqn">ie</code> is the independent error variance, and <code class="reqn">I</code> is
an identity matrix. Note that <code class="reqn">de</code> and <code class="reqn">ie</code> must be non-negative while <code class="reqn">range</code>
must be between the reciprocal of the maximum
eigenvalue of <code>W</code> and the reciprocal of the minimum eigenvalue of
<code>W</code>.
</p>
<p><code>spcov_type</code> Details: Parametric forms for <code class="reqn">R</code> are given below:
</p>

<ul>
<li>
<p> car: <code class="reqn">(I - range * W)^{-1}M</code>, weights matrix <code class="reqn">W</code>,
symmetry condition matrix <code class="reqn">M</code>
</p>
</li>
<li>
<p> sar: <code class="reqn">[(I - range * W)(I - range * W)^T]^{-1}</code>,
weights matrix <code class="reqn">W</code>, <code class="reqn">^T</code> indicates matrix transpose
</p>
</li>
</ul>
<p>If there are observations with no neighbors, they are given a unique variance
parameter called <code>extra</code>, which must be non-negative.
</p>
<p><code>estmethod</code> Details: The various estimation methods are
</p>

<ul>
<li> <p><code>reml</code>: Maximize the restricted log-likelihood.
</p>
</li>
<li> <p><code>ml</code>: Maximize the log-likelihood.
</p>
</li>
</ul>
<p>By default, all spatial covariance parameters except <code>ie</code>
as well as all random effect variance parameters
are assumed unknown, requiring estimation. <code>ie</code> is assumed zero and known by default
(in contrast to models fit using <code>splm()</code>, where <code>ie</code> is assumed
unknown by default). To change this default behavior, specify <code>spcov_initial</code>
(an <code>NA</code> value for <code>ie</code> in <code>spcov_initial</code> to assume
<code>ie</code> is unknown, requiring estimation).
</p>
<p><code>random</code> Details: If random effects are used, the model
can be written as <code class="reqn">y = X \beta + Z1u1 + ... Zjuj + \tau + \epsilon</code>,
where each Z is a random effects design matrix and each u is a random effect.
</p>
<p><code>partition_factor</code> Details:  The partition factor can be represented in matrix form as <code class="reqn">P</code>, where
elements of <code class="reqn">P</code> equal one for observations in the same level of the partition
factor and zero otherwise. The covariance matrix involving only the
spatial and random effects components is then multiplied element-wise
(Hadmard product) by <code class="reqn">P</code>, yielding the final covariance matrix.
</p>
<p>Observations with <code>NA</code> response values are removed for model
fitting, but their values can be predicted afterwards by running
<code>predict(object)</code>. This is the only way to perform prediction for
<code>spautor()</code> models (i.e., the prediction locations must be known prior
to estimation).
</p>


<h3>Value</h3>

<p>A list with many elements that store information about
the fitted model object. If <code>spcov_type</code> or <code>spcov_initial</code> are
length one, the list has class <code>spautor</code>. Many generic functions that
summarize model fit are available for <code>spautor</code> objects, including
<code>AIC</code>, <code>AICc</code>, <code>anova</code>, <code>augment</code>, <code>BIC</code>, <code>coef</code>,
<code>cooks.distance</code>, <code>covmatrix</code>, <code>deviance</code>, <code>fitted</code>, <code>formula</code>,
<code>glance</code>, <code>glances</code>, <code>hatvalues</code>, <code>influence</code>,
<code>labels</code>, <code>logLik</code>, <code>loocv</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>pseudoR2</code>, <code>summary</code>,
<code>terms</code>, <code>tidy</code>, <code>update</code>, <code>varcomp</code>, and <code>vcov</code>. If
<code>spcov_type</code> or <code>spcov_initial</code> are length greater than one, the
list has class <code>spautor_list</code> and each element in the list has class
<code>spautor</code>. <code>glances</code> can be used to summarize <code>spautor_list</code>
objects, and the aforementioned <code>spautor</code> generics can be used on each
individual list element (model fit).
</p>


<h3>Note</h3>

<p>This function does not perform any internal scaling. If optimization is not
stable due to large extremely large variances, scale relevant variables
so they have variance 1 before optimization.
</p>


<h3>Examples</h3>

<pre><code class="language-R">spmod &lt;- spautor(log_trend ~ 1, data = seal, spcov_type = "car")
summary(spmod)
</code></pre>


</div>