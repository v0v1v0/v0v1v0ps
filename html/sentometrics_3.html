<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate.sentiment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate textual sentiment across sentences, documents and time</h2>

<h3>Description</h3>

<p>Aggregates textual sentiment scores at sentence- or document-level into a panel of textual
sentiment measures. Can also be used to aggregate sentence-level sentiment scores into
document-level sentiment scores. This function is called within the <code>sento_measures</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sentiment'
aggregate(x, ctr, do.full = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>sentiment</code> object created using <code>compute_sentiment</code> (from a <code>sento_corpus</code>
object) or using <code>as.sentiment</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctr</code></td>
<td>
<p>output from a <code>ctr_agg</code> call. The <code>howWithin</code> and <code>nCore</code> elements are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.full</code></td>
<td>
<p>if <code>do.full = TRUE</code> (by default), does entire aggregation up to a <code>sento_measures</code>
object, else only goes from sentence-level to document-level. Ignored if no <code>"sentence_id"</code> column in
<code>sentiment</code> input object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A document-level <code>sentiment</code> object or a fully aggregated <code>sento_measures</code> object.
</p>


<h3>Author(s)</h3>

<p>Samuel Borms, Keven Bluteau
</p>


<h3>See Also</h3>

<p><code>compute_sentiment</code>, <code>ctr_agg</code>, <code>sento_measures</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(505)

data("usnews", package = "sentometrics")
data("list_lexicons", package = "sentometrics")
data("list_valence_shifters", package = "sentometrics")

# computation of sentiment
corpus &lt;- sento_corpus(corpusdf = usnews)
corpusSample &lt;- quanteda::corpus_sample(corpus, size = 500)
l1 &lt;- sento_lexicons(list_lexicons[c("LM_en", "HENRY_en")],
                     list_valence_shifters[["en"]])
l2 &lt;- sento_lexicons(list_lexicons[c("LM_en", "HENRY_en")],
                     list_valence_shifters[["en"]][, c("x", "t")])
sent1 &lt;- compute_sentiment(corpusSample, l1, how = "counts")
sent2 &lt;- compute_sentiment(corpusSample, l2, do.sentence = TRUE)
sent3 &lt;- compute_sentiment(as.character(corpusSample), l2,
                           do.sentence = TRUE)
ctr &lt;- ctr_agg(howTime = c("linear"), by = "year", lag = 3)

# aggregate into sentiment measures
sm1 &lt;- aggregate(sent1, ctr)
sm2 &lt;- aggregate(sent2, ctr)

# two-step aggregation (first into document-level sentiment)
sd2 &lt;- aggregate(sent2, ctr, do.full = FALSE)
sm3 &lt;- aggregate(sd2, ctr)

# aggregation of a sentiment data.table
cols &lt;- c("word_count", names(l2)[-length(l2)])
sd3 &lt;- sent3[, lapply(.SD, sum), by = "id", .SDcols = cols]

</code></pre>


</div>