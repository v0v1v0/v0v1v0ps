<div class="container">

<table style="width: 100%;"><tr>
<td>seq-decimal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sequence generation at decimal level</h2>

<h3>Description</h3>

<p>Functions that provide a smooth interface to generating
sequences based on the input values' decimal depth. Each function creates a
sequence with a step size of one unit on the level of the input values'
ultimate decimal digit (e.g., <code>2.45</code>, <code>2.46</code>, <code>2.47</code>, ...):
</p>

<ul>
<li> <p><code>seq_endpoint()</code> creates a sequence from one input value to another. For
step size, it goes by the value with more decimal places.
</p>
</li>
<li> <p><code>seq_distance()</code> only takes the starting point and, instead of the
endpoint, the desired output length. For step size, it goes by the starting
point by default.
</p>
</li>
</ul>
<p><code>seq_endpoint_df()</code> and <code>seq_distance_df()</code> are variants that create a data
frame. Further columns can be added as in <code>tibble::tibble()</code>. Regular
arguments are the same as in the respective non-<code>df</code> function, but with a dot
before each.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seq_endpoint(from, to, offset_from = 0L, offset_to = 0L, string_output = TRUE)

seq_distance(
  from,
  by = NULL,
  length_out = 10L,
  dir = 1,
  offset_from = 0L,
  string_output = TRUE
)

seq_endpoint_df(
  .from,
  .to,
  ...,
  .offset_from = 0L,
  .offset_to = 0L,
  .string_output = TRUE
)

seq_distance_df(
  .from,
  .by = NULL,
  ...,
  .length_out = 10L,
  .dir = 1,
  .offset_from = 0L,
  .string_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>from, .from</code></td>
<td>
<p>Numeric (or string coercible to numeric). Starting point of
the sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to, .to</code></td>
<td>
<p>Numeric (or string coercible to numeric). Endpoint of the
sequence. Only in <code>seq_endpoint()</code> and <code>seq_endpoint_df()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset_from, .offset_from</code></td>
<td>
<p>Integer. If set to a non-zero number, the
starting point will be offset by that many units on the level of the last
decimal digit. Default is <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset_to, .offset_to</code></td>
<td>
<p>Integer. If set to a non-zero number, the
endpoint will be offset by that many units on the level of the last decimal
digit. Default is <code>0</code>. Only in <code>seq_endpoint()</code> and <code>seq_endpoint_df()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>string_output, .string_output</code></td>
<td>
<p>Logical or string. If <code>TRUE</code> (the
default), the output is a string vector. Decimal places are then padded
with zeros to match <code>from</code>'s (or <code>to</code>'s) number of decimal places. <code>"auto"</code>
works like <code>TRUE</code> if and only if <code>from</code> (<code>.from</code>) is a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by, .by</code></td>
<td>
<p>Numeric. Only in <code>seq_distance()</code> and <code>seq_distance_df()</code>. Step
size of the sequence. If not set, inferred automatically. Default is
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length_out, .length_out</code></td>
<td>
<p>Integer. Length of the output vector (i.e., the
number of its values). Default is <code>10</code>. Only in <code>seq_distance()</code> and
<code>seq_distance_df()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir, .dir</code></td>
<td>
<p>Integer. If set to <code>-1</code>, the sequence goes backward. Default
is <code>1</code>. Only in <code>seq_distance()</code> and <code>seq_distance_df()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further columns, added as in <code>tibble::tibble()</code>. Only in
<code>seq_endpoint_df()</code> and <code>seq_distance_df()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If either <code>from</code> or <code>to</code> ends on zero, be sure to enter that value
as a string! This is crucial because trailing zeros get dropped from
numeric values. A handy way to format numeric values or number-strings
correctly is <code>restore_zeros()</code>. The output of the present functions is
like that by default (of <code>string_output</code>).
</p>
<p>In <code>seq_endpoint()</code> and <code>seq_endpoint_df()</code>, the step size is determined by
<code>from</code> and <code>to</code>, whichever has more decimal places. In <code>seq_distance()</code> and
<code>seq_distance_df()</code>, it's determined by the decimal places of <code>from</code>.
</p>
<p>These functions are scrutiny's take on <code>base::seq()</code>, and themselves
wrappers around it.
</p>


<h3>Value</h3>

<p>String by default of <code>string_output</code>, numeric otherwise.
</p>


<h3>See Also</h3>

<p><code>seq_disperse()</code> for sequences centered around the input.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sequence between two points:
seq_endpoint(from = 4.7, to = 5)

# Sequence of some length; default is 10:
seq_distance(from = 0.93)
seq_distance(from = 0.93, length_out = 5)

# Both of these functions can offset the
# starting point...
seq_endpoint(from = 14.2, to = 15, offset_from = 4)
seq_distance(from = 14.2, offset_from = 4)

# ...but only `seq_endpoint()` can offset the
# endpoint, because of its `to` argument:
seq_endpoint(from = 9.5, to = 10, offset_to = 2)

# In return, `seq_distance()` can reverse its direction:
seq_distance(from = 20.03, dir = -1)

# Both functions have a `_df` variant that returns
# a data frame. Arguments are the same but with a
# dot, and further columns can be added as in
# `tibble::tibble()`:
seq_endpoint_df(.from = 4.7, .to = 5, n = 20)
seq_distance_df(.from = 0.43, .length_out = 5, sd = 0.08)
</code></pre>


</div>