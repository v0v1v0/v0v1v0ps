<div class="container">

<table style="width: 100%;"><tr>
<td>invalidateLater</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Scheduled Invalidation</h2>

<h3>Description</h3>

<p>Schedules the current reactive context to be invalidated in the given number
of milliseconds.
</p>


<h3>Usage</h3>

<pre><code class="language-R">invalidateLater(millis, session = getDefaultReactiveDomain())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>millis</code></td>
<td>
<p>Approximate milliseconds to wait before invalidating the
current reactive context.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>A session object. This is needed to cancel any scheduled
invalidations after a user has ended the session. If <code>NULL</code>, then
this invalidation will not be tied to any session, and so it will still
occur.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If this is placed within an observer or reactive expression, that object will
be invalidated (and re-execute) after the interval has passed. The
re-execution will reset the invalidation flag, so in a typical use case, the
object will keep re-executing and waiting for the specified interval. It's
possible to stop this cycle by adding conditional logic that prevents the
<code>invalidateLater</code> from being run.
</p>


<h3>See Also</h3>

<p><code>reactiveTimer()</code> is a slightly less safe alternative.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Only run examples in interactive R sessions
if (interactive()) {

ui &lt;- fluidPage(
  sliderInput("n", "Number of observations", 2, 1000, 500),
  plotOutput("plot")
)

server &lt;- function(input, output, session) {

  observe({
    # Re-execute this reactive expression after 1000 milliseconds
    invalidateLater(1000, session)

    # Do something each time this is invalidated.
    # The isolate() makes this observer _not_ get invalidated and re-executed
    # when input$n changes.
    print(paste("The value of input$n is", isolate(input$n)))
  })

  # Generate a new histogram at timed intervals, but not when
  # input$n changes.
  output$plot &lt;- renderPlot({
    # Re-execute this reactive expression after 2000 milliseconds
    invalidateLater(2000)
    hist(rnorm(isolate(input$n)))
  })
}

shinyApp(ui, server)
}
</code></pre>


</div>