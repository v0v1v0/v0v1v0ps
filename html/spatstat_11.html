<div class="container">

<table style="width: 100%;"><tr>
<td>spatstat-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Spatstat Package</h2>

<h3>Description</h3>

<p>This is a summary of the features of 
<span class="pkg">spatstat</span>, a family of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages
for the statistical analysis of spatial point patterns.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is a family of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> packages
for the statistical analysis
of spatial data. Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p><span class="pkg">spatstat</span> is designed to support a complete statistical analysis
of spatial data. It supports
</p>

<ul>
<li>
<p> creation, manipulation and plotting of point patterns;
</p>
</li>
<li>
<p> exploratory data analysis;
</p>
</li>
<li>
<p> spatial random sampling;
</p>
</li>
<li>
<p> simulation of point process models;
</p>
</li>
<li>
<p> parametric model-fitting;
</p>
</li>
<li>
<p> non-parametric smoothing and regression;
</p>
</li>
<li>
<p> formal inference (hypothesis tests, confidence intervals);
</p>
</li>
<li>
<p> model diagnostics.
</p>
</li>
</ul>
<p>Apart from two-dimensional point patterns and point processes,
<span class="pkg">spatstat</span> also supports point patterns in three dimensions, 
point patterns in multidimensional space-time,
point patterns on a linear network,
patterns of line segments in two dimensions, 
and spatial tessellations and random sets in two dimensions.
</p>
<p>The package can fit several types of point process models
to a point pattern dataset:
</p>

<ul>
<li>
<p> Poisson point process models
(by Berman-Turner approximate maximum likelihood
or by spatial logistic regression)
</p>
</li>
<li>
<p> Gibbs/Markov point process models
(by Baddeley-Turner approximate maximum pseudolikelihood,
Coeurjolly-Rubak logistic likelihood, or
Huang-Ogata approximate maximum likelihood)
</p>
</li>
<li>
<p> Cox/cluster point process models
(by Waagepetersen's two-step fitting procedure
and minimum contrast, composite likelihood, or Palm likelihood)
</p>
</li>
<li>
<p> determinantal point process models
(by Waagepetersen's two-step fitting procedure
and minimum contrast, composite likelihood, or Palm likelihood)
</p>
</li>
</ul>
<p>The models may include spatial trend,
dependence on covariates, and complicated interpoint interactions.
Models are specified by 
a <code>formula</code> in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>  language, and are fitted using
a function analogous to <code>lm</code> and <code>glm</code>.
Fitted models can be printed, plotted, predicted, simulated and so on.
</p>


<h3>Getting Started</h3>

<p>For a quick introduction to <span class="pkg">spatstat</span>, read
the package vignette <em>Getting started with spatstat</em>
installed with <span class="pkg">spatstat</span>. To read that document, you can either
</p>

<ul>
<li>
<p> visit <a href="https://cran.r-project.org/package=spatstat">https://cran.r-project.org/package=spatstat</a>
and click on <code>Getting Started with Spatstat</code>
</p>
</li>
<li>
<p>start <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, type <code>library(spatstat)</code> and <code>vignette('getstart')</code>
</p>
</li>
<li>
<p>start <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, type <code>help.start()</code> to open the help
browser, and navigate to <code>Packages &gt; spatstat &gt; Vignettes</code>.
</p>
</li>
</ul>
<p>Once you have installed <span class="pkg">spatstat</span>, start <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and type
<code>library(spatstat)</code>. Then type <code>beginner</code>
for a beginner's introduction, or 
<code>demo(spatstat)</code> for a demonstration of the package's capabilities.
</p>
<p>For a complete course on <span class="pkg">spatstat</span>,
and on statistical analysis of spatial point patterns,
read the book by Baddeley, Rubak and Turner (2015).
Other recommended books on spatial point process methods
are Diggle (2014), Gelfand et al (2010) and Illian et al (2008).
</p>
<p>The <span class="pkg">spatstat</span> package includes over 50 datasets,
which can be useful when learning the package.
Type <code>demo(data)</code> to see plots of all datasets
available in the package.
Type <code>vignette('datasets')</code> for detailed background information
on these datasets, and plots of each dataset.
</p>
<p>For information on converting your data into <span class="pkg">spatstat</span> format,
read Chapter 3 of Baddeley, Rubak and Turner (2015).
This chapter is available free online, as one of the sample chapters
at the book companion website, <a href="https://book.spatstat.org/">https://book.spatstat.org/</a>.
</p>







<h3>Structure of the spatstat family</h3>

  
<p>The original <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.univar</span> containing functions for estimating
probability distributions of random variables
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing functionality for geometrical
operations, and defining the main classes of spatial objects
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the main functions for exploratory
analysis of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functions for
parametric statistical modelling and analysis,
and formal inference, for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li>
</ul>
<p>The breakup has been done in such a way that the user should not notice
any difference. Source code that worked with the old <span class="pkg">spatstat</span>
package should work with the new <span class="pkg">spatstat</span> family.
Code that is documented in our books, journal articles and vignettes
should still work.
</p>
<p>When you install <span class="pkg">spatstat</span>, the sub-packages listed above are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported. 
</p>
<p>This help file covers all the functionality and datasets
that are provided in the sub-packages listed above.
</p>


<h3>Extension packages</h3>

<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li>
</ul>
<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Updates</h3>

<p>New versions of <span class="pkg">spatstat</span> are released every 8 weeks.
Users are advised to update their installation of <span class="pkg">spatstat</span>
regularly.
</p>
<p>Type <code>latest.news</code> to read the news documentation about
changes to the current installed version of <span class="pkg">spatstat</span>.
</p>
<p>See the Vignette <em>Summary of recent updates</em>,
installed with <span class="pkg">spatstat</span>, which describes the main changes
to <span class="pkg">spatstat</span> since the book (Baddeley, Rubak and Turner, 2015)
was published. It is accessible as <code>vignette('updates')</code>.
</p>
<p>Type <code>news(package="spatstat")</code> to read news documentation about
all previous versions of the package.
</p>


<h3>FUNCTIONS AND DATASETS</h3>

<p>Following is a summary of the main functions and datasets
in the <span class="pkg">spatstat</span> package.
Alternatively an alphabetical list of all functions and
datasets is available by typing <code>library(help=spatstat)</code>.
</p>
<p>For further information on any of these,
type <code>help(name)</code> or <code>?name</code>
where <code>name</code> is the name of the function
or dataset.
</p>


<h3>CONTENTS:</h3>


<table>
<tr>
<td style="text-align: left;">
    I. </td>
<td style="text-align: left;"> Creating and manipulating data </td>
</tr>
<tr>
<td style="text-align: left;">
    II. </td>
<td style="text-align: left;"> Exploratory Data Analysis </td>
</tr>
<tr>
<td style="text-align: left;">
    III. </td>
<td style="text-align: left;"> Model fitting (Cox and cluster models) </td>
</tr>
<tr>
<td style="text-align: left;">
    IV. </td>
<td style="text-align: left;"> Model fitting (Poisson and Gibbs models) </td>
</tr>
<tr>
<td style="text-align: left;">
    V. </td>
<td style="text-align: left;"> Model fitting (determinantal point processes)</td>
</tr>
<tr>
<td style="text-align: left;">
    VI. </td>
<td style="text-align: left;"> Model fitting (spatial logistic regression)</td>
</tr>
<tr>
<td style="text-align: left;">
    VII. </td>
<td style="text-align: left;"> Simulation </td>
</tr>
<tr>
<td style="text-align: left;">
    VIII. </td>
<td style="text-align: left;"> Tests and diagnostics</td>
</tr>
<tr>
<td style="text-align: left;">
    IX. </td>
<td style="text-align: left;"> Documentation
  </td>
</tr>
</table>
<h3>I. CREATING AND MANIPULATING DATA</h3>

<p><b>Types of spatial data:</b>
</p>
<p>The main types of spatial data supported by <span class="pkg">spatstat</span> are:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>ppp</code> </td>
<td style="text-align: left;"> point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>owin</code> </td>
<td style="text-align: left;"> window (spatial region) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>im</code> </td>
<td style="text-align: left;"> pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psp</code> </td>
<td style="text-align: left;"> line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>tess</code> </td>
<td style="text-align: left;"> tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pp3</code> </td>
<td style="text-align: left;"> three-dimensional point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppx</code> </td>
<td style="text-align: left;"> point pattern in any number of dimensions </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lpp</code> </td>
<td style="text-align: left;"> point pattern on a linear network
  </td>
</tr>
</table>
<p><b>To create a point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>ppp</code> </td>
<td style="text-align: left;">
    create a point pattern from <code class="reqn">(x,y)</code> and window information
    </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">
    <code>ppp(x, y, xlim, ylim)</code> for rectangular window</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">
    <code>ppp(x, y, poly)</code> for polygonal window </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">
    <code>ppp(x, y, mask)</code> for binary image window </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.ppp</code> </td>
<td style="text-align: left;">
    convert other types of data to a <code>ppp</code> object </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clickppp</code> </td>
<td style="text-align: left;">
    interactively add points to a plot </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>marks&lt;-</code>, <code>%mark%</code>  </td>
<td style="text-align: left;">
    attach/reassign marks to a point pattern
  </td>
</tr>
</table>
<p><b>To simulate a random point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>runifpoint</code> </td>
<td style="text-align: left;">
	generate <code class="reqn">n</code> independent uniform random points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rpoint</code> </td>
<td style="text-align: left;">
	generate <code class="reqn">n</code> independent random points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rmpoint</code> </td>
<td style="text-align: left;">
	generate <code class="reqn">n</code> independent multitype random points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rpoispp</code> </td>
<td style="text-align: left;">
	simulate the (in)homogeneous Poisson point process </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rmpoispp</code> </td>
<td style="text-align: left;">
	simulate the (in)homogeneous multitype Poisson point process </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>runifdisc</code> </td>
<td style="text-align: left;">
	generate <code class="reqn">n</code> independent uniform random points in disc</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rstrat</code> </td>
<td style="text-align: left;">
	stratified random sample of points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rsyst</code> </td>
<td style="text-align: left;">
	systematic random sample of points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rjitter</code> </td>
<td style="text-align: left;">
	apply random displacements to points in a pattern</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rMaternI</code>  </td>
<td style="text-align: left;">
	simulate the Matern Model I inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rMaternII</code> </td>
<td style="text-align: left;">
	simulate the Matern Model II inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rSSI</code> </td>
<td style="text-align: left;">
	simulate Simple Sequential Inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rStrauss</code> </td>
<td style="text-align: left;">
	simulate Strauss process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rHardcore</code> </td>
<td style="text-align: left;">
	simulate Hard Core process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rStraussHard</code> </td>
<td style="text-align: left;">
	simulate Strauss-hard core process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rDiggleGratton</code> </td>
<td style="text-align: left;">
	simulate Diggle-Gratton process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rDGS</code> </td>
<td style="text-align: left;">
	simulate Diggle-Gates-Stibbard process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rPenttinen</code> </td>
<td style="text-align: left;">
	simulate Penttinen process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rNeymanScott</code> </td>
<td style="text-align: left;">
	simulate a general Neyman-Scott process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rPoissonCluster</code> </td>
<td style="text-align: left;">
	simulate a general Poisson cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rMatClust</code> </td>
<td style="text-align: left;">
	simulate the Matern Cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rThomas</code> </td>
<td style="text-align: left;">
	simulate the Thomas process  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rGaussPoisson</code>  </td>
<td style="text-align: left;">
	simulate the Gauss-Poisson cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rCauchy</code> </td>
<td style="text-align: left;">
	simulate Neyman-Scott Cauchy cluster process </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rVarGamma</code> </td>
<td style="text-align: left;">
	simulate Neyman-Scott Variance Gamma cluster process </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rthin</code> </td>
<td style="text-align: left;">  random thinning  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rcell</code> </td>
<td style="text-align: left;">
	simulate the Baddeley-Silverman cell process  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rmh</code> </td>
<td style="text-align: left;">
	simulate Gibbs point process using Metropolis-Hastings </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>simulate.ppm</code> </td>
<td style="text-align: left;">
	simulate Gibbs point process using Metropolis-Hastings </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>runifpointOnLines</code> </td>
<td style="text-align: left;">
	generate <code class="reqn">n</code> random points along specified line segments </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rpoisppOnLines</code> </td>
<td style="text-align: left;">
	generate Poisson random points along specified line segments 
      </td>
</tr>
</table>
<p><b>To randomly change an existing point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>rshift</code> </td>
<td style="text-align: left;"> random shifting of points </td>
</tr>
<tr>
<td style="text-align: left;">
        <code>rjitter</code> </td>
<td style="text-align: left;">
	apply random displacements to points in a pattern</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rthin</code> </td>
<td style="text-align: left;">  random thinning </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rlabel</code> </td>
<td style="text-align: left;"> random (re)labelling of a multitype
	point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
        <code>quadratresample</code> </td>
<td style="text-align: left;"> block resampling 
      </td>
</tr>
</table>
<p><b>Standard point pattern datasets:</b>
</p>
<p>Datasets in <span class="pkg">spatstat</span> are lazy-loaded, so you can simply
type the name of the dataset to use it; there is no need
to type <code>data(amacrine)</code> etc.
</p>
<p>Type <code>demo(data)</code> to see a display of all the datasets
installed with the package.
</p>
<p>Type <code>vignette('datasets')</code> for a document giving an overview
of all datasets, including background information, and plots.
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>amacrine</code> </td>
<td style="text-align: left;"> Austin Hughes' rabbit amacrine cells </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>anemones</code> </td>
<td style="text-align: left;"> Upton-Fingleton sea anemones data</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>ants</code> </td>
<td style="text-align: left;"> Harkness-Isham ant nests data</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bdspots</code> </td>
<td style="text-align: left;"> Breakdown spots in microelectrodes </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bei</code> </td>
<td style="text-align: left;"> Tropical rainforest trees </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>betacells</code> </td>
<td style="text-align: left;"> Waessle et al. cat retinal ganglia data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bramblecanes</code> </td>
<td style="text-align: left;"> Bramble Canes data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bronzefilter</code> </td>
<td style="text-align: left;"> Bronze Filter Section data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>cells</code> </td>
<td style="text-align: left;"> Crick-Ripley biological cells data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>chicago</code> </td>
<td style="text-align: left;"> Chicago crimes </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>chorley</code> </td>
<td style="text-align: left;"> Chorley-Ribble cancer data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>clmfires</code> </td>
<td style="text-align: left;"> Castilla-La Mancha forest fires </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>copper</code> </td>
<td style="text-align: left;"> Berman-Huntington copper deposits data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>dendrite</code> </td>
<td style="text-align: left;"> Dendritic spines </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>demohyper</code> </td>
<td style="text-align: left;"> Synthetic point patterns</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>demopat</code> </td>
<td style="text-align: left;"> Synthetic point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>finpines</code> </td>
<td style="text-align: left;"> Finnish Pines data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>flu</code> </td>
<td style="text-align: left;"> Influenza virus proteins </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>gordon</code> </td>
<td style="text-align: left;"> People in Gordon Square, London </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>gorillas</code> </td>
<td style="text-align: left;"> Gorilla nest sites </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>hamster</code> </td>
<td style="text-align: left;"> Aherne's hamster tumour data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>humberside</code> </td>
<td style="text-align: left;"> North Humberside childhood leukaemia data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>hyytiala</code> </td>
<td style="text-align: left;"> Mixed forest in
Hyytiala, Finland</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>japanesepines</code> </td>
<td style="text-align: left;"> Japanese Pines data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>lansing</code> </td>
<td style="text-align: left;"> Lansing Woods data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>longleaf</code> </td>
<td style="text-align: left;"> Longleaf Pines data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>mucosa</code> </td>
<td style="text-align: left;"> Cells in gastric mucosa </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>murchison</code> </td>
<td style="text-align: left;"> Murchison gold deposits </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>nbfires</code> </td>
<td style="text-align: left;"> New Brunswick fires data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>nztrees</code> </td>
<td style="text-align: left;"> Mark-Esler-Ripley trees data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>osteo</code> </td>
<td style="text-align: left;"> Osteocyte lacunae (3D, replicated) </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>paracou</code> </td>
<td style="text-align: left;"> Kimboto trees in Paracou, French Guiana </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>ponderosa</code> </td>
<td style="text-align: left;"> Getis-Franklin ponderosa pine trees data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pyramidal</code> </td>
<td style="text-align: left;"> Pyramidal neurons from 31 brains </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>redwood</code> </td>
<td style="text-align: left;"> Strauss-Ripley redwood saplings data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>redwoodfull</code> </td>
<td style="text-align: left;"> Strauss redwood saplings data (full set) </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>residualspaper</code> </td>
<td style="text-align: left;"> Data from Baddeley et al (2005) </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>shapley</code> </td>
<td style="text-align: left;"> Galaxies in an astronomical survey </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>simdat</code> </td>
<td style="text-align: left;"> Simulated point pattern (inhomogeneous, with interaction) </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>spiders</code> </td>
<td style="text-align: left;"> Spider webs on mortar lines of brick wall </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>sporophores</code> </td>
<td style="text-align: left;"> Mycorrhizal fungi around a tree </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>spruces</code> </td>
<td style="text-align: left;"> Spruce trees in Saxonia </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>swedishpines</code> </td>
<td style="text-align: left;"> Strand-Ripley Swedish pines data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>urkiola</code> </td>
<td style="text-align: left;"> Urkiola Woods data </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>waka</code> </td>
<td style="text-align: left;"> Trees in Waka national park </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>waterstriders</code> </td>
<td style="text-align: left;"> Insects on water surface 
      </td>
</tr>
</table>
<p><b>To display a 2D point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>plot.ppp</code> </td>
<td style="text-align: left;">
	plot a point pattern (e.g. <code>plot(X)</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>spatstat.gui::iplot</code> </td>
<td style="text-align: left;">
	plot a point pattern interactively </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>persp.ppp</code> </td>
<td style="text-align: left;">
	perspective plot of marked point pattern
      </td>
</tr>
</table>
<p><b>To manipulate a 2D point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>edit.ppp</code> </td>
<td style="text-align: left;"> interactive text editor </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>[.ppp</code> </td>
<td style="text-align: left;">
	extract or replace a subset of a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
        </td>
<td style="text-align: left;"> <code>pp[subset]</code> or <code>pp[subwindow]</code> </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>subset.ppp</code> </td>
<td style="text-align: left;">
	extract subset of point pattern satisfying a condition </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>superimpose</code> </td>
<td style="text-align: left;">
	combine several point patterns  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>by.ppp</code> </td>
<td style="text-align: left;">
	apply a function to sub-patterns of a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>cut.ppp</code> </td>
<td style="text-align: left;">
	classify the points in a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>split.ppp</code> </td>
<td style="text-align: left;">
	divide pattern into sub-patterns </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>unmark</code> </td>
<td style="text-align: left;">
	remove marks  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>npoints</code> </td>
<td style="text-align: left;">
	count the number of points  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>coords</code> </td>
<td style="text-align: left;">
	extract coordinates, change coordinates  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>marks</code> </td>
<td style="text-align: left;">
	extract marks, change marks or attach marks  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rotate</code> </td>
<td style="text-align: left;">
	rotate pattern  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>shift </code> </td>
<td style="text-align: left;">
	translate pattern  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>flipxy </code> </td>
<td style="text-align: left;">
	swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>reflect </code> </td>
<td style="text-align: left;">
	reflect in the origin  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>periodify </code> </td>
<td style="text-align: left;">
	make several translated copies  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>affine</code> </td>
<td style="text-align: left;">
	apply affine transformation</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>scalardilate</code> </td>
<td style="text-align: left;">
	apply scalar dilation</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>density.ppp</code> </td>
<td style="text-align: left;">
	kernel estimation of point pattern intensity</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>densityHeat.ppp</code> </td>
<td style="text-align: left;">
	diffusion kernel estimation of point pattern intensity</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>Smooth.ppp</code> </td>
<td style="text-align: left;">
	kernel smoothing of marks of point pattern</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>nnmark</code> </td>
<td style="text-align: left;">
	mark value of nearest data point</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>sharpen.ppp</code> </td>
<td style="text-align: left;">
	data sharpening</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>identify.ppp</code> </td>
<td style="text-align: left;">
	interactively identify points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>unique.ppp</code> </td>
<td style="text-align: left;">
	remove duplicate points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>duplicated.ppp</code> </td>
<td style="text-align: left;">
	determine which points are duplicates </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>uniquemap.ppp</code> </td>
<td style="text-align: left;">
	map duplicated points to unique points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>connected.ppp</code> </td>
<td style="text-align: left;"> find clumps of points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>dirichlet</code> </td>
<td style="text-align: left;">
	compute Dirichlet-Voronoi tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>delaunay</code> </td>
<td style="text-align: left;">
	compute Delaunay triangulation </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>delaunayDistance</code> </td>
<td style="text-align: left;">
	graph distance in Delaunay triangulation </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>convexhull</code> </td>
<td style="text-align: left;"> compute convex hull </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>discretise</code> </td>
<td style="text-align: left;"> discretise coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pixellate.ppp</code> </td>
<td style="text-align: left;"> approximate point pattern by 
	pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.im.ppp</code> </td>
<td style="text-align: left;"> approximate point pattern by 
	pixel image 
      </td>
</tr>
</table>
<p>See <code>spatstat.options</code> to control plotting behaviour.
</p>
<p><b>To create a window:</b>
</p>
<p>An object of class <code>"owin"</code> describes a spatial region
(a window of observation).
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>owin</code>	</td>
<td style="text-align: left;">	Create a window object </td>
</tr>
<tr>
<td style="text-align: left;">
	</td>
<td style="text-align: left;"> <code>owin(xlim, ylim)</code> for rectangular window </td>
</tr>
<tr>
<td style="text-align: left;">
	</td>
<td style="text-align: left;"> <code>owin(poly)</code> for polygonal window </td>
</tr>
<tr>
<td style="text-align: left;">
	</td>
<td style="text-align: left;"> <code>owin(mask)</code> for binary image window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>Window</code>	</td>
<td style="text-align: left;">
	Extract window of another object </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>Frame</code>	</td>
<td style="text-align: left;">
	Extract the containing rectangle ('frame') of another object </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.owin</code>	</td>
<td style="text-align: left;">
	Convert other data to a window object </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>square</code>    </td>
<td style="text-align: left;">	make a square window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>disc</code>    </td>
<td style="text-align: left;">	make a circular window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>ellipse</code>    </td>
<td style="text-align: left;">	make an elliptical window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>ripras</code>    </td>
<td style="text-align: left;">
	Ripley-Rasson estimator of window, given only the points </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>convexhull</code> </td>
<td style="text-align: left;"> compute convex hull of something </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>letterR</code>    </td>
<td style="text-align: left;">
	polygonal window in the shape of the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> logo </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>clickpoly</code>    </td>
<td style="text-align: left;">
	interactively draw a polygonal window  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>clickbox</code>    </td>
<td style="text-align: left;">
	interactively draw a rectangle  
      </td>
</tr>
</table>
<p><b>To manipulate a window:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>plot.owin</code>	</td>
<td style="text-align: left;">	plot a window. </td>
</tr>
<tr>
<td style="text-align: left;">
	</td>
<td style="text-align: left;">		<code>plot(W)</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>boundingbox</code> </td>
<td style="text-align: left;">
	Find a tight bounding box for the window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>erosion</code>	</td>
<td style="text-align: left;">
	erode window by a distance r</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>dilation</code>	</td>
<td style="text-align: left;">
	dilate window by a distance r</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>closing</code>	</td>
<td style="text-align: left;">
	close window by a distance r</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>opening</code>	</td>
<td style="text-align: left;">
	open window by a distance r</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>border</code>	</td>
<td style="text-align: left;">
	difference between window and its erosion/dilation </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>complement.owin</code>	</td>
<td style="text-align: left;">
	invert (swap inside and outside)</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>simplify.owin</code>	</td>
<td style="text-align: left;">
	approximate a window by a simple polygon  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rotate</code> </td>
<td style="text-align: left;"> rotate window  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>flipxy</code> </td>
<td style="text-align: left;"> swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>shift </code> </td>
<td style="text-align: left;"> translate window  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>periodify </code> </td>
<td style="text-align: left;"> make several translated copies  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>affine</code> </td>
<td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.data.frame.owin</code> </td>
<td style="text-align: left;">
	convert window to data frame 
      </td>
</tr>
</table>
<p><b>Digital approximations:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>as.mask</code>	</td>
<td style="text-align: left;">
	Make a discrete pixel approximation of a given window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.im.owin</code> </td>
<td style="text-align: left;"> convert window to pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pixellate.owin</code> </td>
<td style="text-align: left;"> convert window to pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>commonGrid</code> </td>
<td style="text-align: left;"> find common pixel grid for windows </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>nearest.raster.point</code> </td>
<td style="text-align: left;">
	map continuous coordinates to raster locations</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>raster.x</code> </td>
<td style="text-align: left;">
	raster x coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>raster.y</code> </td>
<td style="text-align: left;">
	raster y coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>raster.xy</code> </td>
<td style="text-align: left;">
	raster x and y coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.polygonal</code> </td>
<td style="text-align: left;">
	convert pixel mask to polygonal window 
      </td>
</tr>
</table>
<p>See <code>spatstat.options</code> to control the approximation
</p>
<p><b>Geometrical computations with windows:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>edges</code>	</td>
<td style="text-align: left;">	extract boundary edges </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>intersect.owin</code>	</td>
<td style="text-align: left;">	intersection of two windows</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>union.owin</code>	</td>
<td style="text-align: left;">	union of two windows</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>setminus.owin</code>	</td>
<td style="text-align: left;">	set subtraction of two windows</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>inside.owin</code>	</td>
<td style="text-align: left;">	determine whether a point is inside a window</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>area.owin</code>	</td>
<td style="text-align: left;">	compute area </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>perimeter</code>	</td>
<td style="text-align: left;">	compute perimeter length </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>diameter.owin</code>	</td>
<td style="text-align: left;">	compute diameter</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>incircle</code>	</td>
<td style="text-align: left;">	find largest circle inside a window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>inradius</code>	</td>
<td style="text-align: left;">	radius of incircle </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>connected.owin</code>    </td>
<td style="text-align: left;"> find connected components of window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>eroded.areas</code>	</td>
<td style="text-align: left;">	compute areas of eroded windows</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>dilated.areas</code>	</td>
<td style="text-align: left;">	compute areas of dilated windows</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bdist.points</code>	</td>
<td style="text-align: left;">	compute distances from data points to window boundary </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bdist.pixels</code>	</td>
<td style="text-align: left;">	compute distances from all pixels to window boundary </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>bdist.tiles</code>	</td>
<td style="text-align: left;">
	boundary distance for each tile in tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>distmap.owin</code>	</td>
<td style="text-align: left;">	distance transform image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>distfun.owin</code>	</td>
<td style="text-align: left;">	distance transform </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>centroid.owin</code>	</td>
<td style="text-align: left;"> compute centroid (centre of mass) of window</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>is.subset.owin</code>    </td>
<td style="text-align: left;"> determine whether one
	window contains another </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>is.convex</code> </td>
<td style="text-align: left;"> determine whether a window is convex </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>convexhull</code> </td>
<td style="text-align: left;"> compute convex hull </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>triangulate.owin</code> </td>
<td style="text-align: left;"> decompose into triangles </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.mask</code> </td>
<td style="text-align: left;"> pixel approximation of window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.polygonal</code> </td>
<td style="text-align: left;"> polygonal approximation of window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>is.rectangle</code> </td>
<td style="text-align: left;"> test whether window is a rectangle </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>is.polygonal</code> </td>
<td style="text-align: left;"> test whether window is polygonal </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>is.mask</code> </td>
<td style="text-align: left;"> test whether window is a mask </td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>setcov</code> </td>
<td style="text-align: left;"> spatial covariance function of window </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pixelcentres</code> </td>
<td style="text-align: left;"> extract centres of pixels in mask </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>clickdist</code>    </td>
<td style="text-align: left;">
	measure distance between two points clicked by user
      </td>
</tr>
</table>
<p><b>Pixel images:</b>
An object of class <code>"im"</code> represents a pixel image. 
Such objects are returned by some of the functions in
<span class="pkg">spatstat</span> including <code>Kmeasure</code>,
<code>setcov</code> and <code>density.ppp</code>. 
</p>

<table>
<tr>
<td style="text-align: left;">
	<code>im</code> </td>
<td style="text-align: left;"> create a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.im</code> </td>
<td style="text-align: left;"> convert other data to a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pixellate</code> </td>
<td style="text-align: left;"> convert other data to a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.matrix.im</code> </td>
<td style="text-align: left;"> convert pixel image to matrix</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.data.frame.im</code> </td>
<td style="text-align: left;"> convert pixel image to data frame</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>as.function.im</code> </td>
<td style="text-align: left;"> convert pixel image to function</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>plot.im</code>	</td>
<td style="text-align: left;">	plot a pixel image on screen as a digital image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>contour.im</code>	</td>
<td style="text-align: left;"> draw contours of a pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>persp.im</code>	</td>
<td style="text-align: left;"> draw perspective plot of a pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rgbim</code>	</td>
<td style="text-align: left;"> create colour-valued pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>hsvim</code>	</td>
<td style="text-align: left;"> create colour-valued pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>[.im</code> 	</td>
<td style="text-align: left;"> extract a subset of a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>[&lt;-.im</code> 	</td>
<td style="text-align: left;"> replace a subset of a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rotate.im</code> </td>
<td style="text-align: left;"> rotate pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>shift.im</code> </td>
<td style="text-align: left;"> apply vector shift to pixel image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>affine.im</code> </td>
<td style="text-align: left;"> apply affine transformation to image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>X</code>	</td>
<td style="text-align: left;">	print very basic information about image <code>X</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>summary(X)</code> </td>
<td style="text-align: left;">	summary of image <code>X</code> </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>hist.im</code> </td>
<td style="text-align: left;">	histogram of image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>mean.im</code> </td>
<td style="text-align: left;">	mean pixel value of image  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>integral.im</code> </td>
<td style="text-align: left;">	integral of pixel values  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>quantile.im</code> </td>
<td style="text-align: left;">	quantiles of image  </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>cut.im</code> </td>
<td style="text-align: left;">	convert numeric image to factor image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>is.im</code> </td>
<td style="text-align: left;"> test whether an object is a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>interp.im</code> </td>
<td style="text-align: left;"> interpolate a pixel image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>blur</code> </td>
<td style="text-align: left;"> apply Gaussian blur to image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>Smooth.im</code> </td>
<td style="text-align: left;"> apply Gaussian blur to image</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>connected.im</code> </td>
<td style="text-align: left;"> find connected components </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>compatible.im</code> </td>
<td style="text-align: left;"> test whether two images have
	compatible dimensions </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>harmonise.im</code> </td>
<td style="text-align: left;"> make images compatible </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>commonGrid</code> </td>
<td style="text-align: left;"> find a common pixel grid for images </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>eval.im</code> </td>
<td style="text-align: left;"> evaluate any expression involving images</td>
</tr>
<tr>
<td style="text-align: left;">
	<code>im.apply</code> </td>
<td style="text-align: left;"> evaluate a function of several images </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>scaletointerval</code> </td>
<td style="text-align: left;"> rescale pixel values </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>zapsmall.im</code> </td>
<td style="text-align: left;"> set very small pixel values to zero </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>levelset</code> </td>
<td style="text-align: left;"> level set of an image</td>
</tr>
<tr>
<td style="text-align: left;"> 
	<code>solutionset</code> </td>
<td style="text-align: left;"> region where an expression is true </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>imcov</code> </td>
<td style="text-align: left;"> spatial covariance function of image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>convolve.im</code> </td>
<td style="text-align: left;"> spatial convolution of images </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>transect.im</code> </td>
<td style="text-align: left;"> line transect of image </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>pixelcentres</code> </td>
<td style="text-align: left;"> extract centres of pixels </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>transmat</code> </td>
<td style="text-align: left;"> convert matrix of pixel values </td>
</tr>
<tr>
<td style="text-align: left;">
	                       </td>
<td style="text-align: left;"> to a different indexing convention </td>
</tr>
<tr>
<td style="text-align: left;">
	<code>rnoise</code> </td>
<td style="text-align: left;"> random pixel noise
     </td>
</tr>
</table>
<p><b>Line segment patterns</b>
</p>
<p>An object of class <code>"psp"</code> represents a pattern of straight line
segments.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>psp</code> </td>
<td style="text-align: left;"> create a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.psp</code> </td>
<td style="text-align: left;"> convert other data into a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>edges</code> </td>
<td style="text-align: left;"> extract edges of a window </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>is.psp</code> </td>
<td style="text-align: left;"> determine whether a dataset has class <code>"psp"</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.psp</code> </td>
<td style="text-align: left;"> plot a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>print.psp</code> </td>
<td style="text-align: left;"> print basic information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>summary.psp</code> </td>
<td style="text-align: left;"> print summary information </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[.psp</code> </td>
<td style="text-align: left;"> extract a subset of a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.psp</code> </td>
<td style="text-align: left;"> extract subset of line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.data.frame.psp</code> </td>
<td style="text-align: left;">
      convert line segment pattern to data frame </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks.psp</code> </td>
<td style="text-align: left;"> extract marks of line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>marks&lt;-.psp</code> </td>
<td style="text-align: left;"> assign new marks to line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unmark.psp</code> </td>
<td style="text-align: left;"> delete marks from line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>midpoints.psp</code> </td>
<td style="text-align: left;">
      compute the midpoints of line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>endpoints.psp</code> </td>
<td style="text-align: left;"> extract the endpoints of line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>lengths_psp</code> </td>
<td style="text-align: left;"> compute the lengths of line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>angles.psp</code> </td>
<td style="text-align: left;"> compute the orientation angles of line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>superimpose</code> </td>
<td style="text-align: left;"> combine several line segment patterns  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>flipxy</code> </td>
<td style="text-align: left;"> swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>rotate.psp</code> </td>
<td style="text-align: left;"> rotate a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>shift.psp</code> </td>
<td style="text-align: left;"> shift a line segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>periodify</code> </td>
<td style="text-align: left;"> make several shifted copies </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>affine.psp</code> </td>
<td style="text-align: left;"> apply an affine transformation </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>pixellate.psp</code> </td>
<td style="text-align: left;"> approximate line segment pattern
    by pixel image </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>psp2mask</code> </td>
<td style="text-align: left;"> approximate line segment pattern
    by binary mask </td>
</tr>
<tr>
<td style="text-align: left;">      
      <code>distmap.psp</code> </td>
<td style="text-align: left;"> compute the distance map of a line
      segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>distfun.psp</code> </td>
<td style="text-align: left;"> compute the distance map of a line
      segment pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>density.psp</code> </td>
<td style="text-align: left;"> kernel smoothing of line segments</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>selfcrossing.psp</code> </td>
<td style="text-align: left;"> find crossing points between
      line segments </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>selfcut.psp</code> </td>
<td style="text-align: left;"> cut segments where they cross </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>crossing.psp</code> </td>
<td style="text-align: left;"> find crossing points between
      two line segment patterns </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>extrapolate.psp</code> </td>
<td style="text-align: left;"> extrapolate line segments to
      infinite lines </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nncross</code> </td>
<td style="text-align: left;"> find distance to nearest line segment
      from a given point</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>nearestsegment</code> </td>
<td style="text-align: left;"> find line segment closest to a
      given point </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>project2segment</code> </td>
<td style="text-align: left;"> find location along a line segment
      closest to a given point </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>pointsOnLines</code> </td>
<td style="text-align: left;"> generate points evenly spaced
      along line segment </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rpoisline</code> </td>
<td style="text-align: left;"> generate a realisation of the
      Poisson line process inside a window</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rlinegrid</code> </td>
<td style="text-align: left;"> generate a random array of parallel
      lines through a window
    </td>
</tr>
</table>
<p><b>Tessellations</b>
</p>
<p>An object of class <code>"tess"</code> represents a tessellation.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>tess</code> </td>
<td style="text-align: left;"> create a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>quadrats</code> </td>
<td style="text-align: left;"> create a tessellation of rectangles</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>hextess</code> </td>
<td style="text-align: left;"> create a tessellation of hexagons </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>polartess</code> </td>
<td style="text-align: left;"> tessellation using polar coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>quantess</code> </td>
<td style="text-align: left;"> quantile tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>venn.tess</code> </td>
<td style="text-align: left;"> Venn diagram tessellation </td>
</tr>
<tr>
<td style="text-align: left;"> 
      <code>dirichlet</code> </td>
<td style="text-align: left;"> compute Dirichlet-Voronoi tessellation of points</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>delaunay</code> </td>
<td style="text-align: left;"> compute Delaunay triangulation of points</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.tess</code> </td>
<td style="text-align: left;"> convert other data to a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.tess</code> </td>
<td style="text-align: left;"> plot a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tiles</code> </td>
<td style="text-align: left;"> extract all the tiles of a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[.tess</code> </td>
<td style="text-align: left;"> extract some tiles of a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[&lt;-.tess</code> </td>
<td style="text-align: left;"> change some tiles of a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>intersect.tess</code> </td>
<td style="text-align: left;"> intersect two tessellations </td>
</tr>
<tr>
<td style="text-align: left;">
                              </td>
<td style="text-align: left;"> or restrict a tessellation to a window </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>chop.tess</code> </td>
<td style="text-align: left;"> subdivide a tessellation by a line </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rpoislinetess</code> </td>
<td style="text-align: left;"> generate tessellation using Poisson line
      process </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tile.areas</code>	</td>
<td style="text-align: left;">
      area of each tile in tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>bdist.tiles</code>	</td>
<td style="text-align: left;">
      boundary distance for each tile in tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>connected.tess</code> </td>
<td style="text-align: left;"> find connected components of tiles </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shift.tess</code> </td>
<td style="text-align: left;"> shift a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rotate.tess</code> </td>
<td style="text-align: left;"> rotate a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>reflect.tess</code> </td>
<td style="text-align: left;"> reflect about the origin </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>flipxy.tess</code> </td>
<td style="text-align: left;"> reflect about the diagonal </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>affine.tess</code> </td>
<td style="text-align: left;"> apply affine transformation 
    </td>
</tr>
</table>
<p><b>Three-dimensional point patterns</b>
</p>
<p>An object of class <code>"pp3"</code> represents a three-dimensional
point pattern in a rectangular box. The box is represented by
an object of class <code>"box3"</code>.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>pp3</code> </td>
<td style="text-align: left;"> create a 3-D point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.pp3</code> </td>
<td style="text-align: left;"> plot a 3-D point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>coords</code> </td>
<td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.hyperframe</code> </td>
<td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.pp3</code> </td>
<td style="text-align: left;"> extract subset of 3-D point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unitname.pp3</code> </td>
<td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>npoints</code> </td>
<td style="text-align: left;"> count the number of points  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>runifpoint3</code> </td>
<td style="text-align: left;"> generate uniform random points in 3-D </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rpoispp3</code> </td>
<td style="text-align: left;"> generate Poisson random points in 3-D </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>envelope.pp3</code> </td>
<td style="text-align: left;"> generate simulation envelopes for
      3-D pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>box3</code> </td>
<td style="text-align: left;"> create a 3-D rectangular box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.box3</code> </td>
<td style="text-align: left;"> convert data to 3-D rectangular box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unitname.box3</code> </td>
<td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>diameter.box3</code> </td>
<td style="text-align: left;"> diameter of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>volume.box3</code> </td>
<td style="text-align: left;"> volume of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shortside.box3</code> </td>
<td style="text-align: left;"> shortest side of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>eroded.volumes</code> </td>
<td style="text-align: left;"> volumes of erosions of box 
    </td>
</tr>
</table>
<p><b>Multi-dimensional space-time point patterns</b>
</p>
<p>An object of class <code>"ppx"</code> represents a 
point pattern in multi-dimensional space and/or time.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>ppx</code> </td>
<td style="text-align: left;"> create a multidimensional space-time point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>coords</code> </td>
<td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.hyperframe</code> </td>
<td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.ppx</code> </td>
<td style="text-align: left;"> extract subset </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>unitname.ppx</code> </td>
<td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>npoints</code> </td>
<td style="text-align: left;"> count the number of points  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>runifpointx</code> </td>
<td style="text-align: left;"> generate uniform random points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rpoisppx</code> </td>
<td style="text-align: left;"> generate Poisson random points </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>boxx</code> </td>
<td style="text-align: left;"> define multidimensional box  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>diameter.boxx</code> </td>
<td style="text-align: left;"> diameter of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>volume.boxx</code> </td>
<td style="text-align: left;"> volume of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>shortside.boxx</code> </td>
<td style="text-align: left;"> shortest side of box </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>eroded.volumes.boxx</code> </td>
<td style="text-align: left;"> volumes of erosions of box 
    </td>
</tr>
</table>
<p><b>Point patterns on a linear network</b>
</p>
<p>An object of class <code>"linnet"</code> represents a linear network
(for example, a road network).
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>linnet</code> </td>
<td style="text-align: left;"> create a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>clickjoin</code> </td>
<td style="text-align: left;"> interactively join vertices in network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>spatstat.gui::iplot.linnet</code> </td>
<td style="text-align: left;"> interactively plot network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>simplenet</code> </td>
<td style="text-align: left;"> simple example of network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>lineardisc</code> </td>
<td style="text-align: left;"> disc in a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>delaunayNetwork</code> </td>
<td style="text-align: left;"> network of Delaunay triangulation </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dirichletNetwork</code> </td>
<td style="text-align: left;"> network of Dirichlet edges </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>methods.linnet</code> </td>
<td style="text-align: left;"> methods for <code>linnet</code> objects</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>vertices.linnet</code> </td>
<td style="text-align: left;"> nodes of network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>joinVertices</code> </td>
<td style="text-align: left;"> join existing vertices in a network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>insertVertices</code> </td>
<td style="text-align: left;"> insert new vertices at positions
      along a network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>addVertices</code> </td>
<td style="text-align: left;"> add new vertices, extending a network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>thinNetwork</code> </td>
<td style="text-align: left;"> remove vertices or lines from a network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>repairNetwork</code> </td>
<td style="text-align: left;"> repair internal format </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>pixellate.linnet</code> </td>
<td style="text-align: left;"> approximate by pixel image
    </td>
</tr>
</table>
<p>An object of class <code>"lpp"</code> represents a 
point pattern on a linear network (for example,
road accidents on a road network).
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>lpp</code> </td>
<td style="text-align: left;"> create a point pattern on a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>methods.lpp</code> </td>
<td style="text-align: left;"> methods for <code>lpp</code> objects </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.lpp</code> </td>
<td style="text-align: left;"> method for <code>subset</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rpoislpp</code> </td>
<td style="text-align: left;"> simulate Poisson points on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>runiflpp</code> </td>
<td style="text-align: left;"> simulate random points on a linear network </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>chicago</code> </td>
<td style="text-align: left;"> Chicago crime data </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dendrite</code> </td>
<td style="text-align: left;"> Dendritic spines data </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>spiders</code> </td>
<td style="text-align: left;"> Spider webs on mortar lines of brick wall 
    </td>
</tr>
</table>
<p><b>Hyperframes</b>
</p>
<p>A hyperframe is like a data frame, except that the entries
may be objects of any kind.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>hyperframe</code> </td>
<td style="text-align: left;"> create a hyperframe </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.hyperframe</code> </td>
<td style="text-align: left;"> convert data to hyperframe </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.hyperframe</code> </td>
<td style="text-align: left;"> plot hyperframe </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>with.hyperframe</code> </td>
<td style="text-align: left;"> evaluate expression using each row
      of hyperframe </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>cbind.hyperframe</code> </td>
<td style="text-align: left;"> combine hyperframes by columns</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>rbind.hyperframe</code> </td>
<td style="text-align: left;"> combine hyperframes by rows</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>as.data.frame.hyperframe</code> </td>
<td style="text-align: left;"> convert hyperframe to
      data frame </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>subset.hyperframe</code> </td>
<td style="text-align: left;"> method for <code>subset</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>head.hyperframe</code> </td>
<td style="text-align: left;"> first few rows of hyperframe </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tail.hyperframe</code> </td>
<td style="text-align: left;"> last few rows of hyperframe
    </td>
</tr>
</table>
<p><b>Layered objects</b>
</p>
<p>A layered object represents data that should be plotted in
successive layers, for example, a background and a foreground.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>layered</code> </td>
<td style="text-align: left;"> create layered object </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.layered</code> </td>
<td style="text-align: left;"> plot layered object</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>[.layered</code> </td>
<td style="text-align: left;"> extract subset of layered object
    </td>
</tr>
</table>
<p><b>Colour maps</b>
</p>
<p>A colour map is a mechanism for associating colours with data.
It can be regarded as a function, mapping data to colours.
Using a <code>colourmap</code> object in a plot command
ensures that the mapping from numbers to colours is
the same in different plots. 
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>colourmap</code> </td>
<td style="text-align: left;"> create a colour map  </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>plot.colourmap</code> </td>
<td style="text-align: left;"> plot the colour map only</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>tweak.colourmap</code> </td>
<td style="text-align: left;"> alter individual colour values </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>interp.colourmap</code> </td>
<td style="text-align: left;"> make a smooth transition
      between colours </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>beachcolourmap</code> </td>
<td style="text-align: left;"> one special colour map
    </td>
</tr>
</table>
<h3>II. EXPLORATORY DATA ANALYSIS</h3>

<p><b>Inspection of data:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>summary(X)</code> </td>
<td style="text-align: left;">
    print useful summary of point pattern <code>X</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X</code> </td>
<td style="text-align: left;">
    print basic description of point pattern <code>X</code>  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>any(duplicated(X))</code> </td>
<td style="text-align: left;">
    check for duplicated points in pattern <code>X</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>spatstat.gui::istat(X)</code> </td>
<td style="text-align: left;"> Interactive exploratory analysis </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>spatstat.gui::View.ppp(X)</code> </td>
<td style="text-align: left;"> spreadsheet-style viewer
  </td>
</tr>
</table>
<p><b>Classical exploratory tools:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>clarkevans</code> </td>
<td style="text-align: left;"> Clark and Evans aggregation index </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fryplot</code> </td>
<td style="text-align: left;"> Fry plot </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>miplot</code> </td>
<td style="text-align: left;"> Morisita Index plot
  </td>
</tr>
</table>
<p><b>Smoothing:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>density.ppp</code> </td>
<td style="text-align: left;"> kernel smoothed density/intensity</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>relrisk</code> </td>
<td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Smooth.ppp</code> </td>
<td style="text-align: left;"> spatial interpolation of marks  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.diggle</code> </td>
<td style="text-align: left;"> cross-validated bandwidth selection
                               for <code>density.ppp</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.ppl</code> </td>
<td style="text-align: left;"> likelihood cross-validated bandwidth selection
                               for <code>density.ppp</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.CvL</code> </td>
<td style="text-align: left;"> Cronie-Van Lieshout bandwidth selection
                                for density estimation</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.scott</code> </td>
<td style="text-align: left;"> Scott's rule of thumb 
                                for density estimation</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.abram</code> </td>
<td style="text-align: left;"> Abramson's rule for adaptive bandwidths</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.relrisk</code> </td>
<td style="text-align: left;"> cross-validated bandwidth selection
                               for <code>relrisk</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.smoothppp</code> </td>
<td style="text-align: left;"> cross-validated bandwidth selection
                               for <code>Smooth.ppp</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.frac</code> </td>
<td style="text-align: left;"> bandwidth selection using window geometry</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bw.stoyan</code> </td>
<td style="text-align: left;"> Stoyan's rule of thumb for bandwidth
                               for <code>pcf</code>
  </td>
</tr>
</table>
<p><b>Modern exploratory tools:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>clusterset</code> </td>
<td style="text-align: left;"> Allard-Fraley feature detection  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnclean</code> </td>
<td style="text-align: left;"> Byers-Raftery feature detection  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>sharpen.ppp</code> </td>
<td style="text-align: left;"> Choi-Hall data sharpening </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rhohat</code> </td>
<td style="text-align: left;"> Kernel estimate of covariate effect</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rho2hat</code> </td>
<td style="text-align: left;"> Kernel estimate of effect of two covariates</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>spatialcdf</code> </td>
<td style="text-align: left;"> Spatial cumulative distribution function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>roc</code> </td>
<td style="text-align: left;"> Receiver operating characteristic curve
  </td>
</tr>
</table>
<p><b>Summary statistics for a point pattern:</b>
Type <code>demo(sumfun)</code> for a demonstration of many
of the summary statistics.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>intensity</code> </td>
<td style="text-align: left;"> Mean intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>quadratcount</code> </td>
<td style="text-align: left;"> Quadrat counts </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>intensity.quadratcount</code> </td>
<td style="text-align: left;"> Mean intensity in quadrats </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Fest</code> </td>
<td style="text-align: left;"> empty space function <code class="reqn">F</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gest</code> </td>
<td style="text-align: left;"> nearest neighbour distribution function <code class="reqn">G</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Jest</code> </td>
<td style="text-align: left;"> <code class="reqn">J</code>-function <code class="reqn">J = (1-G)/(1-F)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kest</code> </td>
<td style="text-align: left;"> Ripley's <code class="reqn">K</code>-function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Lest</code> </td>
<td style="text-align: left;"> Besag <code class="reqn">L</code>-function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Tstat</code> </td>
<td style="text-align: left;"> Third order <code class="reqn">T</code>-function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>allstats</code> </td>
<td style="text-align: left;"> all four functions <code class="reqn">F</code>, <code class="reqn">G</code>, <code class="reqn">J</code>, <code class="reqn">K</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcf</code> </td>
<td style="text-align: left;"> 	pair correlation function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kinhom</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Linhom</code> </td>
<td style="text-align: left;"> <code class="reqn">L</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfinhom</code> </td>
<td style="text-align: left;"> pair correlation for inhomogeneous patterns</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Finhom</code> </td>
<td style="text-align: left;"> <code class="reqn">F</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Ginhom</code> </td>
<td style="text-align: left;"> <code class="reqn">G</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Jinhom</code> </td>
<td style="text-align: left;"> <code class="reqn">J</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localL</code> </td>
<td style="text-align: left;"> Getis-Franklin neighbourhood density function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localK</code> </td>
<td style="text-align: left;"> neighbourhood K-function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localpcf</code> </td>
<td style="text-align: left;"> local pair correlation function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localKinhom</code> </td>
<td style="text-align: left;"> local <code class="reqn">K</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localLinhom</code> </td>
<td style="text-align: left;"> local <code class="reqn">L</code> for inhomogeneous point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localpcfinhom</code> </td>
<td style="text-align: left;"> local pair correlation for inhomogeneous patterns</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Ksector</code> </td>
<td style="text-align: left;"> Directional <code class="reqn">K</code>-function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kscaled</code> </td>
<td style="text-align: left;"> locally scaled <code class="reqn">K</code>-function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kest.fft</code> </td>
<td style="text-align: left;"> fast <code class="reqn">K</code>-function using FFT for large datasets </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmeasure</code> </td>
<td style="text-align: left;"> reduced second moment measure </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope</code> </td>
<td style="text-align: left;"> simulation envelopes for a summary
    function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>varblock</code> </td>
<td style="text-align: left;"> variances and confidence intervals</td>
</tr>
<tr>
<td style="text-align: left;">
                   </td>
<td style="text-align: left;"> for a summary function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lohboot</code> </td>
<td style="text-align: left;"> bootstrap for a summary function 
  </td>
</tr>
</table>
<p>Related facilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>plot.fv</code> </td>
<td style="text-align: left;"> plot a summary function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>eval.fv</code> </td>
<td style="text-align: left;"> evaluate any expression involving
    summary functions</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>harmonise.fv</code> </td>
<td style="text-align: left;"> make functions compatible </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>eval.fasp</code> </td>
<td style="text-align: left;"> evaluate any expression involving
    an array of functions</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>with.fv</code> </td>
<td style="text-align: left;"> evaluate an expression for a 
    summary function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Smooth.fv</code> </td>
<td style="text-align: left;"> apply smoothing to a summary function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>deriv.fv</code> </td>
<td style="text-align: left;"> calculate derivative of a summary function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pool.fv</code> </td>
<td style="text-align: left;"> pool several estimates of a summary function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nndist</code> </td>
<td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnwhich</code> </td>
<td style="text-align: left;"> find nearest neighbours </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pairdist</code> </td>
<td style="text-align: left;"> distances between all pairs of points</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>crossdist</code> </td>
<td style="text-align: left;"> distances between points in two patterns</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nncross</code> </td>
<td style="text-align: left;"> nearest neighbours between two point patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>exactdt</code> </td>
<td style="text-align: left;"> distance from any location to nearest data point</td>
</tr>
<tr>
<td style="text-align: left;"> 
    <code>distmap</code> </td>
<td style="text-align: left;"> distance map image</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>distfun</code> </td>
<td style="text-align: left;"> distance map function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnmap</code> </td>
<td style="text-align: left;"> nearest point image </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnfun</code> </td>
<td style="text-align: left;"> nearest point function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>density.ppp</code> </td>
<td style="text-align: left;"> kernel smoothed density</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityHeat.ppp</code> </td>
<td style="text-align: left;"> diffusion kernel smoothed density</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Smooth.ppp</code> </td>
<td style="text-align: left;"> spatial interpolation of marks  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>relrisk</code> </td>
<td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>sharpen.ppp</code> </td>
<td style="text-align: left;"> data sharpening  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rknn</code> </td>
<td style="text-align: left;"> theoretical distribution of nearest
    neighbour distance
 </td>
</tr>
</table>
<p><b>Summary statistics for a multitype point pattern:</b>
A multitype point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> such that <code>marks(X)</code> is a factor. 
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>relrisk</code> </td>
<td style="text-align: left;"> kernel estimation of relative risk  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>scan.test</code> </td>
<td style="text-align: left;"> spatial scan test of elevated risk  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gcross,Gdot,Gmulti</code> </td>
<td style="text-align: left;">
    multitype nearest neighbour distributions 
    <code class="reqn">G_{ij}, G_{i\bullet}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kcross,Kdot, Kmulti</code> </td>
<td style="text-align: left;">
    multitype <code class="reqn">K</code>-functions 
    <code class="reqn">K_{ij}, K_{i\bullet}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Lcross,Ldot</code> </td>
<td style="text-align: left;">
    multitype <code class="reqn">L</code>-functions 
    <code class="reqn">L_{ij}, L_{i\bullet}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Jcross,Jdot,Jmulti</code> </td>
<td style="text-align: left;">
    multitype <code class="reqn">J</code>-functions
    <code class="reqn">J_{ij}, J_{i\bullet}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfcross</code> </td>
<td style="text-align: left;">
    multitype pair correlation function <code class="reqn">g_{ij}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfdot</code> </td>
<td style="text-align: left;">
    multitype pair correlation function <code class="reqn">g_{i\bullet}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfmulti</code> </td>
<td style="text-align: left;">
    general pair correlation function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markconnect</code> </td>
<td style="text-align: left;">
    marked connection function <code class="reqn">p_{ij}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>alltypes</code> </td>
<td style="text-align: left;">  estimates of the above
    for all <code class="reqn">i,j</code> pairs </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Iest</code> </td>
<td style="text-align: left;">  multitype <code class="reqn">I</code>-function</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kcross.inhom,Kdot.inhom</code> </td>
<td style="text-align: left;">
    inhomogeneous counterparts of <code>Kcross</code>, <code>Kdot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Lcross.inhom,Ldot.inhom</code> </td>
<td style="text-align: left;">
    inhomogeneous counterparts of <code>Lcross</code>, <code>Ldot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfcross.inhom,pcfdot.inhom</code> </td>
<td style="text-align: left;">
    inhomogeneous counterparts of <code>pcfcross</code>, <code>pcfdot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localKcross,localKdot</code> </td>
<td style="text-align: left;">
    local counterparts of <code>Kcross</code>, <code>Kdot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localLcross,localLdot</code> </td>
<td style="text-align: left;">
    local counterparts of <code>Lcross</code>, <code>Ldot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>localKcross.inhom,localLcross.inhom</code> </td>
<td style="text-align: left;">
    local counterparts of <code>Kcross.inhom</code>, <code>Lcross.inhom</code> 
  </td>
</tr>
</table>
<p><b>Summary statistics for a marked point pattern:</b>
A marked point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> with a component <code>X$marks</code>.
The entries in the vector <code>X$marks</code> may be numeric, complex,
string or any other atomic type. For numeric marks, there are the
following functions:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>markmean</code> </td>
<td style="text-align: left;"> smoothed local average of marks </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markvar</code> </td>
<td style="text-align: left;"> smoothed local variance of marks </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markcorr</code> </td>
<td style="text-align: left;"> mark correlation function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markcrosscorr</code> </td>
<td style="text-align: left;"> mark cross-correlation function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markvario</code> </td>
<td style="text-align: left;"> mark variogram </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markmarkscatter</code> </td>
<td style="text-align: left;"> mark-mark scatterplot </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmark</code> </td>
<td style="text-align: left;"> mark-weighted <code class="reqn">K</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Emark</code> </td>
<td style="text-align: left;"> mark independence diagnostic <code class="reqn">E(r)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Vmark</code> </td>
<td style="text-align: left;"> mark independence diagnostic <code class="reqn">V(r)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnmean</code> </td>
<td style="text-align: left;"> nearest neighbour mean index </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnvario</code> </td>
<td style="text-align: left;"> nearest neighbour mark variance index 
  </td>
</tr>
</table>
<p>For marks of any type, there are the following:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>Gmulti</code> </td>
<td style="text-align: left;"> multitype nearest neighbour distribution </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmulti</code> </td>
<td style="text-align: left;"> multitype <code class="reqn">K</code>-function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Jmulti</code> </td>
<td style="text-align: left;"> multitype <code class="reqn">J</code>-function 
  </td>
</tr>
</table>
<p>Alternatively use <code>cut.ppp</code> to convert a marked point pattern
to a multitype point pattern.
</p>
<p><b>Programming tools:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>applynbd</code> </td>
<td style="text-align: left;"> apply function to every neighbourhood
    in a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>markstat</code> </td>
<td style="text-align: left;"> apply function to the marks of neighbours
    in a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>marktable</code> </td>
<td style="text-align: left;"> tabulate the marks of neighbours
    in a point pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pppdist</code> </td>
<td style="text-align: left;"> find the optimal match between two point
    patterns
  </td>
</tr>
</table>
<p><b>Summary statistics for a point pattern on a linear network:</b>
</p>
<p>These are for point patterns on a linear network (class <code>lpp</code>).
For unmarked patterns:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>linearK</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKinhom</code> </td>
<td style="text-align: left;">
    inhomogeneous <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcf</code> </td>
<td style="text-align: left;">
    pair correlation function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfinhom</code> </td>
<td style="text-align: left;">
    inhomogeneous pair correlation on linear network
  </td>
</tr>
</table>
<p>For multitype patterns:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>linearKcross</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function between two types of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKdot</code> </td>
<td style="text-align: left;">
    <code class="reqn">K</code> function from one type to any type </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKcross.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearKcross</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearKdot.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearKdot</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearmarkconnect</code> </td>
<td style="text-align: left;">
    Mark connection function  on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearmarkequal</code> </td>
<td style="text-align: left;">
    Mark equality function on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfcross</code> </td>
<td style="text-align: left;">
    Pair correlation between two types of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfdot</code> </td>
<td style="text-align: left;">
    Pair correlation from one type to any type </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfcross.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearpcfcross</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linearpcfdot.inhom</code> </td>
<td style="text-align: left;">
    Inhomogeneous version of <code>linearpcfdot</code> 
  </td>
</tr>
</table>
<p>Related facilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>pairdist.lpp</code> </td>
<td style="text-align: left;"> distances between pairs  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>crossdist.lpp</code> </td>
<td style="text-align: left;"> distances between pairs </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nndist.lpp</code> </td>
<td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nncross.lpp</code> </td>
<td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnwhich.lpp</code> </td>
<td style="text-align: left;"> find nearest neighbours  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnfun.lpp</code> </td>
<td style="text-align: left;"> find nearest data point  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>density.lpp</code> </td>
<td style="text-align: left;"> kernel smoothing estimator of intensity  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>densityHeat.lpp</code> </td>
<td style="text-align: left;"> diffusion kernel estimate  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>distfun.lpp</code> </td>
<td style="text-align: left;"> distance transform  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope.lpp</code> </td>
<td style="text-align: left;"> simulation envelopes  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rpoislpp</code> </td>
<td style="text-align: left;"> simulate Poisson points on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>runiflpp</code> </td>
<td style="text-align: left;"> simulate random points on a linear network 
  </td>
</tr>
</table>
<p>It is also possible to fit point process models to <code>lpp</code> objects.
See Section IV.
</p>
<p><b>Summary statistics for a three-dimensional point pattern:</b>
</p>
<p>These are for 3-dimensional point pattern objects (class <code>pp3</code>).
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>F3est</code> </td>
<td style="text-align: left;"> empty space function <code class="reqn">F</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>G3est</code> </td>
<td style="text-align: left;"> nearest neighbour function <code class="reqn">G</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>K3est</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code>-function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcf3est</code> </td>
<td style="text-align: left;"> pair correlation function
  </td>
</tr>
</table>
<p>Related facilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>envelope.pp3</code> </td>
<td style="text-align: left;"> simulation envelopes </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pairdist.pp3</code> </td>
<td style="text-align: left;"> distances between all pairs of
    points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>crossdist.pp3</code> </td>
<td style="text-align: left;"> distances between points in
    two patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nndist.pp3</code> </td>
<td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnwhich.pp3</code> </td>
<td style="text-align: left;"> find nearest neighbours </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nncross.pp3</code> </td>
<td style="text-align: left;"> find nearest neighbours in another pattern
  </td>
</tr>
</table>
<p><b>Computations for multi-dimensional point pattern:</b>
</p>
<p>These are for multi-dimensional space-time
point pattern objects (class <code>ppx</code>).
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>pairdist.ppx</code> </td>
<td style="text-align: left;"> distances between all pairs of
    points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>crossdist.ppx</code> </td>
<td style="text-align: left;"> distances between points in
    two patterns </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nndist.ppx</code> </td>
<td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>nnwhich.ppx</code> </td>
<td style="text-align: left;"> find nearest neighbours
  </td>
</tr>
</table>
<p><b>Summary statistics for random sets:</b>
</p>
<p>These work for point patterns (class <code>ppp</code>),
line segment patterns (class <code>psp</code>)
or windows (class <code>owin</code>).
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>Hest</code> </td>
<td style="text-align: left;"> spherical contact distribution <code class="reqn">H</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gfox</code> </td>
<td style="text-align: left;"> Foxall <code class="reqn">G</code>-function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Jfox</code> </td>
<td style="text-align: left;"> Foxall <code class="reqn">J</code>-function
  </td>
</tr>
</table>
<h3>III. MODEL FITTING (COX AND CLUSTER MODELS)</h3>

<p>Cluster process models (with homogeneous or inhomogeneous intensity)
and Cox processes can be fitted by the function <code>kppm</code>.
Its result is an object of class <code>"kppm"</code>.
The fitted model can be printed, plotted, predicted, simulated
and updated.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>kppm</code> </td>
<td style="text-align: left;">  Fit model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.kppm</code> </td>
<td style="text-align: left;">  Plot the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary.kppm</code> </td>
<td style="text-align: left;">  Summarise the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.kppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.kppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>update.kppm</code> </td>
<td style="text-align: left;"> Update the model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>improve.kppm</code> </td>
<td style="text-align: left;"> Refine the estimate of trend </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.kppm</code> </td>
<td style="text-align: left;"> Generate simulated realisations </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.kppm</code> </td>
<td style="text-align: left;"> Variance-covariance matrix of coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.kppm</code>
    </td>
<td style="text-align: left;"> Extract trend coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>formula.kppm</code>
    </td>
<td style="text-align: left;"> Extract trend formula </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>parameters</code> </td>
<td style="text-align: left;"> Extract all model parameters </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clusterfield.kppm</code> </td>
<td style="text-align: left;"> Compute offspring density </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clusterradius.kppm</code> </td>
<td style="text-align: left;"> Radius of support of offspring density </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmodel.kppm</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfmodel.kppm</code> </td>
<td style="text-align: left;"> Pair correlation of fitted model 
  </td>
</tr>
</table>
<p>For model selection, you can also use 
the generic functions <code>step</code>, <code>drop1</code> 
and <code>AIC</code> on fitted point process models.
For variable selection, see <code>sdr</code>.
</p>
<p>The theoretical models can also be simulated,
for any choice of parameter values,
using <code>rThomas</code>, <code>rMatClust</code>,
<code>rCauchy</code>, <code>rVarGamma</code>,
and <code>rLGCP</code>.
</p>
<p>Lower-level fitting functions include:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>lgcp.estK</code> </td>
<td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lgcp.estpcf</code> </td>
<td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>thomas.estK</code> </td>
<td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>thomas.estpcf</code> </td>
<td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matclust.estK</code> </td>
<td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>matclust.estpcf</code> </td>
<td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>cauchy.estK</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>cauchy.estpcf</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
   <code>vargamma.estK</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
<td style="text-align: left;">
   <code>vargamma.estpcf</code> </td>
<td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>mincontrast</code> </td>
<td style="text-align: left;"> low-level algorithm for fitting models
    </td>
</tr>
<tr>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> by the method of minimum contrast 
  </td>
</tr>
</table>
<h3>IV. MODEL FITTING (POISSON AND GIBBS MODELS)</h3>

<p><b>Types of models</b>
</p>
<p>Poisson point processes are the simplest models for point patterns.
A Poisson model assumes that the points are stochastically
independent. It may allow the points to have a non-uniform spatial
density. The special case of a Poisson process with a uniform
spatial density is often called Complete Spatial Randomness.
</p>
<p>Poisson point processes are included in the more general class of Gibbs point
process models. In a Gibbs model, there is <em>interaction</em>
or dependence between points. Many different types of interaction
can be specified.
</p>
<p>For a detailed explanation of how to fit Poisson or
Gibbs point process models to point pattern data using <span class="pkg">spatstat</span>,
see Baddeley and Turner (2005b) or Baddeley (2008).
</p>
<p><b>To fit a Poisson or Gibbs point process model:</b>
</p>
<p>Model fitting in <span class="pkg">spatstat</span> is performed mainly by the function
<code>ppm</code>. Its result is an object of class <code>"ppm"</code>.
</p>
<p>Here are some examples, where <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
<td style="text-align: left;">
    <em>command</em> </td>
<td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ 1)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ x)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                             </td>
<td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ 1, Strauss(0.1))</code> </td>
<td style="text-align: left;"> Stationary Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>ppm(X ~ x, Strauss(0.1))</code> </td>
<td style="text-align: left;"> Strauss process with </td>
</tr>
<tr>
<td style="text-align: left;">
                              </td>
<td style="text-align: left;"> conditional intensity loglinear in <code class="reqn">x</code>
  </td>
</tr>
</table>
<p>It is also possible to fit models that depend on
other covariates.
</p>
<p><b>Manipulating the fitted model:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>plot.ppm</code> </td>
<td style="text-align: left;"> 		Plot the fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.ppm</code>
    </td>
<td style="text-align: left;">   Compute the spatial trend and conditional intensity</td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">   of the fitted point process model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.ppm</code> </td>
<td style="text-align: left;"> Extract the fitted model coefficients</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>parameters</code> </td>
<td style="text-align: left;"> Extract all model parameters</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>formula.ppm</code> </td>
<td style="text-align: left;"> Extract the trend formula</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>intensity.ppm</code> </td>
<td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kmodel.ppm</code> </td>
<td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pcfmodel.ppm</code> </td>
<td style="text-align: left;"> pair correlation of fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.ppm</code> </td>
<td style="text-align: left;"> Compute fitted conditional intensity at quadrature points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>residuals.ppm</code> </td>
<td style="text-align: left;"> Compute point process residuals at quadrature points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>update.ppm</code> </td>
<td style="text-align: left;"> Update the fit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.ppm</code> </td>
<td style="text-align: left;"> Variance-covariance matrix of estimates</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rmh.ppm</code> </td>
<td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.ppm</code> </td>
<td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>print.ppm</code> </td>
<td style="text-align: left;"> Print basic information about a fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary.ppm</code> </td>
<td style="text-align: left;"> Summarise a fitted model</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>effectfun</code> </td>
<td style="text-align: left;"> Compute the fitted effect of one covariate</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>logLik.ppm</code> </td>
<td style="text-align: left;"> log-likelihood or log-pseudolikelihood</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>anova.ppm</code> </td>
<td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.frame.ppm</code> </td>
<td style="text-align: left;"> Extract data frame used to fit model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.images</code> </td>
<td style="text-align: left;"> Extract spatial data used to fit model  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>model.depends</code> </td>
<td style="text-align: left;"> Identify variables in the model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>as.interact</code> </td>
<td style="text-align: left;"> Interpoint interaction component of model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitin</code> </td>
<td style="text-align: left;"> Extract fitted interpoint interaction </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>is.hybrid</code> </td>
<td style="text-align: left;"> Determine whether the model is a hybrid </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>valid.ppm</code> </td>
<td style="text-align: left;"> Check the model is a valid point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>project.ppm</code> </td>
<td style="text-align: left;"> Ensure the model is a valid point process 
  </td>
</tr>
</table>
<p>For model selection, you can also use 
the generic functions <code>step</code>, <code>drop1</code> 
and <code>AIC</code> on fitted point process models.
For variable selection, see <code>sdr</code>.
</p>
<p>See <code>spatstat.options</code> to control plotting of fitted model.
</p>
<p><b>To specify a point process model:</b>
</p>
<p>The first order trend of the model is determined by an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 
language formula. The formula specifies the form of the
<em>logarithm</em> of the trend.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>X ~ 1</code>  </td>
<td style="text-align: left;"> No trend (stationary) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ x</code>   </td>
<td style="text-align: left;"> Loglinear trend
      <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta x)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> where <code class="reqn">x,y</code> are Cartesian coordinates </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ polynom(x,y,3)</code>  </td>
<td style="text-align: left;"> Log-cubic polynomial trend  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ harmonic(x,y,2)</code>  </td>
<td style="text-align: left;"> Log-harmonic polynomial trend </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>X ~ Z</code>   </td>
<td style="text-align: left;"> Loglinear function of covariate <code>Z</code> </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;">  <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta Z(x,y))</code> 
  </td>
</tr>
</table>
<p>The higher order (interaction) components are described by
an object of class <code>"interact"</code>. Such objects are created by:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>Poisson()</code> </td>
<td style="text-align: left;">		the Poisson point process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>AreaInter()</code>	 </td>
<td style="text-align: left;"> Area-interaction process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>BadGey()</code> </td>
<td style="text-align: left;">	multiscale Geyer process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Concom()</code> </td>
<td style="text-align: left;">	connected component interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>DiggleGratton() </code> </td>
<td style="text-align: left;"> Diggle-Gratton potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>DiggleGatesStibbard() </code> </td>
<td style="text-align: left;"> Diggle-Gates-Stibbard potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Fiksel()</code>	 </td>
<td style="text-align: left;"> Fiksel pairwise interaction process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Geyer()</code>	 </td>
<td style="text-align: left;"> Geyer's saturation process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Hardcore()</code>	 </td>
<td style="text-align: left;"> Hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierHard()</code>	 </td>
<td style="text-align: left;"> Hierarchical multiype hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierStrauss()</code>	 </td>
<td style="text-align: left;"> Hierarchical multiype Strauss process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>HierStraussHard()</code>	 </td>
<td style="text-align: left;">
    Hierarchical multiype Strauss-hard core process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Hybrid()</code>	 </td>
<td style="text-align: left;"> Hybrid of several interactions</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>LennardJones() </code> </td>
<td style="text-align: left;"> Lennard-Jones potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiHard()</code> </td>
<td style="text-align: left;"> 		multitype hard core process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiStrauss()</code> </td>
<td style="text-align: left;"> 		multitype Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>MultiStraussHard()</code> </td>
<td style="text-align: left;"> 	multitype Strauss/hard core process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>OrdThresh()</code> </td>
<td style="text-align: left;">		Ord process, threshold potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Ord()</code> </td>
<td style="text-align: left;"> 		        Ord model, user-supplied potential </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>PairPiece()</code> </td>
<td style="text-align: left;">		pairwise interaction, piecewise constant </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Pairwise()</code> </td>
<td style="text-align: left;">	pairwise interaction, user-supplied potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Penttinen()</code> </td>
<td style="text-align: left;">	Penttinen pairwise interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>SatPiece()</code> </td>
<td style="text-align: left;">	Saturated pair model, piecewise  constant potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Saturated()</code> </td>
<td style="text-align: left;">	Saturated pair model, user-supplied potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Softcore()</code> </td>
<td style="text-align: left;"> pairwise interaction, soft core potential</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Strauss()</code> </td>
<td style="text-align: left;">  Strauss process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>StraussHard()</code> </td>
<td style="text-align: left;"> Strauss/hard core point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Triplets()</code> </td>
<td style="text-align: left;"> Geyer triplets process
  </td>
</tr>
</table>
<p>Note that it is also possible to combine several such interactions
using <code>Hybrid</code>.
</p>
<p><b>Finer control over model fitting:</b>
</p>
<p>A quadrature scheme is represented by an object of
class <code>"quad"</code>. To create a quadrature scheme, typically
use <code>quadscheme</code>.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>quadscheme</code> </td>
<td style="text-align: left;"> default quadrature scheme </td>
</tr>
<tr>
<td style="text-align: left;">
                             </td>
<td style="text-align: left;"> using rectangular cells or Dirichlet cells</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>pixelquad</code>  </td>
<td style="text-align: left;"> quadrature scheme based on image pixels </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>quad</code>       </td>
<td style="text-align: left;"> create an object of class <code>"quad"</code>
  </td>
</tr>
</table>
<p>To inspect a quadrature scheme:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>plot(Q)</code> </td>
<td style="text-align: left;"> plot quadrature scheme <code>Q</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>print(Q)</code> </td>
<td style="text-align: left;"> print basic information about quadrature scheme <code>Q</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>summary(Q)</code> </td>
<td style="text-align: left;"> summary of quadrature scheme <code>Q</code>
  </td>
</tr>
</table>
<p>A quadrature scheme consists of data points, dummy points, and
weights. To generate dummy points:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>default.dummy</code> </td>
<td style="text-align: left;"> default pattern of dummy points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>gridcentres</code> </td>
<td style="text-align: left;"> dummy points in a rectangular grid </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rstrat</code> </td>
<td style="text-align: left;"> stratified random dummy pattern </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>spokes</code> </td>
<td style="text-align: left;"> radial pattern of dummy points  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>corners</code> </td>
<td style="text-align: left;"> dummy points at corners of the window
  </td>
</tr>
</table>
<p>To compute weights:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>gridweights</code> </td>
<td style="text-align: left;"> quadrature weights by the grid-counting rule  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>dirichletWeights</code> </td>
<td style="text-align: left;"> quadrature weights are
    Dirichlet tile areas
  </td>
</tr>
</table>
<p><b>Simulation and goodness-of-fit for fitted models:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>rmh.ppm</code> </td>
<td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.ppm</code> </td>
<td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope</code> </td>
<td style="text-align: left;"> compute simulation envelopes for a
    fitted model 
  </td>
</tr>
</table>
<p><b>Point process models on a linear network:</b>
</p>
<p>An object of class <code>"lpp"</code> represents a pattern of points on
a linear network. Point process models can also be fitted to these
objects. Currently only Poisson models can be fitted.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>lppm</code> </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>anova.lppm</code> </td>
<td style="text-align: left;"> analysis of deviance for </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope.lppm</code> </td>
<td style="text-align: left;"> simulation envelopes for </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.lppm</code> </td>
<td style="text-align: left;"> fitted intensity values </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.lppm</code> </td>
<td style="text-align: left;"> model prediction on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linim</code> </td>
<td style="text-align: left;"> pixel image on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.linim</code> </td>
<td style="text-align: left;"> plot a pixel image on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>eval.linim</code> </td>
<td style="text-align: left;"> evaluate expression involving images </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>linfun</code> </td>
<td style="text-align: left;"> function defined on linear network </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>methods.linfun</code> </td>
<td style="text-align: left;"> conversion facilities
  </td>
</tr>
</table>
<h3>V. MODEL FITTING (DETERMINANTAL POINT PROCESS MODELS)</h3>

<p>Code for fitting <em>determinantal point process models</em> has 
recently been added to <span class="pkg">spatstat</span>.
</p>
<p>For information, see the help file for <code>dppm</code>.
</p>


<h3>VI. MODEL FITTING (SPATIAL LOGISTIC REGRESSION)</h3>

<p><b>Logistic regression</b>
</p>
<p>Pixel-based spatial logistic regression is an alternative
technique for analysing spatial point patterns
that is widely used in Geographical Information Systems.
It is approximately equivalent to fitting a Poisson point process
model.
</p>
<p>In pixel-based logistic regression, the spatial domain is
divided into small pixels, the presence or absence of a
data point in each pixel is recorded, and logistic regression
is used to model the presence/absence indicators as a function
of any covariates.
</p>
<p>Facilities for performing spatial logistic regression are
provided in <span class="pkg">spatstat</span> for comparison purposes.
</p>
<p><b>Fitting a spatial logistic regression</b>
</p>
<p>Spatial logistic regression is performed by the function
<code>slrm</code>. Its result is an object of class <code>"slrm"</code>.
There are many methods for this class, including methods for
<code>print</code>, <code>fitted</code>, <code>predict</code>, <code>simulate</code>,
<code>anova</code>, <code>coef</code>, <code>logLik</code>, <code>terms</code>,
<code>update</code>, <code>formula</code> and <code>vcov</code>. 
</p>
<p>For example, if <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
<td style="text-align: left;">
    <em>command</em> </td>
<td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ 1)</code> </td>
<td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ x)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                </td>
<td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>slrm(X ~ Z)</code> </td>
<td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
<td style="text-align: left;">
                </td>
<td style="text-align: left;"> intensity loglinear in covariate <code>Z</code>
  </td>
</tr>
</table>
<p><b>Manipulating a fitted spatial logistic regression</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>anova.slrm</code> </td>
<td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>coef.slrm</code>  </td>
<td style="text-align: left;"> Extract fitted coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>vcov.slrm</code>  </td>
<td style="text-align: left;"> Variance-covariance matrix of fitted coefficients </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>fitted.slrm</code> </td>
<td style="text-align: left;"> Compute fitted probabilities or
    intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>logLik.slrm</code>   </td>
<td style="text-align: left;"> Evaluate loglikelihood of fitted
    model </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>plot.slrm</code>    </td>
<td style="text-align: left;"> Plot fitted probabilities or
    intensity </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>predict.slrm</code> </td>
<td style="text-align: left;"> Compute predicted probabilities or
    intensity with new data </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>simulate.slrm</code> </td>
<td style="text-align: left;"> Simulate model
  </td>
</tr>
</table>
<p>There are many other undocumented methods for this class,
including methods for <code>print</code>, <code>update</code>, <code>formula</code>
and <code>terms</code>. Stepwise model selection is
possible using <code>step</code> or <code>stepAIC</code>.
For variable selection, see <code>sdr</code>.
</p>


<h3>VII. SIMULATION</h3>

<p>There are many ways to generate a random point pattern,
line segment pattern, pixel image or tessellation
in <span class="pkg">spatstat</span>. 
</p>
<p><b>Random point patterns:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>runifpoint</code> </td>
<td style="text-align: left;">
    generate <code class="reqn">n</code> independent uniform random points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rpoint</code> </td>
<td style="text-align: left;">
    generate <code class="reqn">n</code> independent random points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rmpoint</code> </td>
<td style="text-align: left;">
    generate <code class="reqn">n</code> independent multitype random points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rpoispp</code> </td>
<td style="text-align: left;">
    simulate the (in)homogeneous Poisson point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rmpoispp</code> </td>
<td style="text-align: left;">
    simulate the (in)homogeneous multitype Poisson point process </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>runifdisc</code> </td>
<td style="text-align: left;">
    generate <code class="reqn">n</code> independent uniform random points in disc</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rstrat</code> </td>
<td style="text-align: left;">
    stratified random sample of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rsyst</code> </td>
<td style="text-align: left;">
    systematic random sample (grid) of points </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rMaternI</code>  </td>
<td style="text-align: left;">
    simulate the Matern Model I inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rMaternII</code> </td>
<td style="text-align: left;">
    simulate the Matern Model II inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rSSI</code> </td>
<td style="text-align: left;">
    simulate Simple Sequential Inhibition process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rHardcore</code> </td>
<td style="text-align: left;">
    simulate hard core process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rStrauss</code> </td>
<td style="text-align: left;">
    simulate Strauss process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rStraussHard</code> </td>
<td style="text-align: left;">
    simulate Strauss-hard core process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rDiggleGratton</code> </td>
<td style="text-align: left;">
    simulate Diggle-Gratton process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rDGS</code> </td>
<td style="text-align: left;">
    simulate Diggle-Gates-Stibbard process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rPenttinen</code> </td>
<td style="text-align: left;">
    simulate Penttinen process (perfect simulation)</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rNeymanScott</code> </td>
<td style="text-align: left;">
    simulate a general Neyman-Scott process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rMatClust</code> </td>
<td style="text-align: left;">
    simulate the Matern Cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rThomas</code> </td>
<td style="text-align: left;">
    simulate the Thomas process  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rLGCP</code> </td>
<td style="text-align: left;">
    simulate the log-Gaussian Cox process  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rGaussPoisson</code>  </td>
<td style="text-align: left;">
    simulate the Gauss-Poisson cluster process</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rCauchy</code> </td>
<td style="text-align: left;">
    simulate Neyman-Scott process with Cauchy clusters </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rVarGamma</code> </td>
<td style="text-align: left;">
    simulate Neyman-Scott process with Variance Gamma clusters </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rcell</code> </td>
<td style="text-align: left;">
    simulate the Baddeley-Silverman cell process  </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>runifpointOnLines</code> </td>
<td style="text-align: left;">
    generate <code class="reqn">n</code> random points along specified line segments </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rpoisppOnLines</code> </td>
<td style="text-align: left;">
    generate Poisson random points along specified line segments 
  </td>
</tr>
</table>
<p><b>Resampling a point pattern:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>quadratresample</code> </td>
<td style="text-align: left;"> block resampling </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rjitter</code> </td>
<td style="text-align: left;">
    apply random displacements to points in a pattern</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rshift</code> </td>
<td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rthin</code> </td>
<td style="text-align: left;">  random thinning 
  </td>
</tr>
</table>
<p>See also <code>varblock</code> for estimating the variance
of a summary statistic by block resampling, and
<code>lohboot</code> for another bootstrap technique.
</p>
<p><b>Fitted point process models:</b>
</p>
<p>If you have fitted a point process model to a point pattern dataset,
the fitted model can be simulated.
</p>
<p>Cluster process models 
are fitted by the function <code>kppm</code> yielding an
object of class <code>"kppm"</code>. To generate one or more simulated
realisations of this fitted model, use 
<code>simulate.kppm</code>.
</p>
<p>Gibbs point process models 
are fitted by the function <code>ppm</code> yielding an
object of class <code>"ppm"</code>. To generate a simulated
realisation of this fitted model, use <code>rmh</code>.
To generate one or more simulated realisations of the fitted model,
use <code>simulate.ppm</code>.
</p>
<p><b>Other random patterns:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
     <code>rlinegrid</code> </td>
<td style="text-align: left;">
     generate a random array of parallel lines through a window </td>
</tr>
<tr>
<td style="text-align: left;">
     <code>rpoisline</code> </td>
<td style="text-align: left;">
     simulate the Poisson line process within a window </td>
</tr>
<tr>
<td style="text-align: left;">
     <code>rpoislinetess</code> </td>
<td style="text-align: left;">
     generate random tessellation using Poisson line process </td>
</tr>
<tr>
<td style="text-align: left;">
     <code>rMosaicSet</code> </td>
<td style="text-align: left;">
     generate random set by selecting some tiles of a tessellation </td>
</tr>
<tr>
<td style="text-align: left;">
     <code>rMosaicField</code> </td>
<td style="text-align: left;">
     generate random pixel image by assigning random values
     in each tile of a tessellation
   </td>
</tr>
</table>
<p><b>Simulation-based inference</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>envelope</code> </td>
<td style="text-align: left;"> critical envelope for Monte Carlo
    test of goodness-of-fit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bits.envelope</code> </td>
<td style="text-align: left;"> critical envelope for balanced
    two-stage Monte Carlo test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>qqplot.ppm</code> </td>
<td style="text-align: left;"> diagnostic plot for interpoint
    interaction </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>scan.test</code> </td>
<td style="text-align: left;"> spatial scan statistic/test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>studpermu.test</code> </td>
<td style="text-align: left;"> studentised permutation test</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>segregation.test</code> </td>
<td style="text-align: left;"> test of segregation of types 
  </td>
</tr>
</table>
<h3>VIII. TESTS AND DIAGNOSTICS</h3>

<p><b>Hypothesis tests:</b>
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>quadrat.test</code> </td>
<td style="text-align: left;"> <code class="reqn">\chi^2</code> goodness-of-fit
    test on quadrat counts </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>clarkevans.test</code> </td>
<td style="text-align: left;"> Clark and Evans test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>cdf.test</code> </td>
<td style="text-align: left;"> Spatial distribution goodness-of-fit test</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>berman.test</code> </td>
<td style="text-align: left;"> Berman's goodness-of-fit tests</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>envelope</code> </td>
<td style="text-align: left;"> critical envelope for Monte Carlo
    test of goodness-of-fit </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>scan.test</code> </td>
<td style="text-align: left;"> spatial scan statistic/test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>dclf.test</code> </td>
<td style="text-align: left;"> Diggle-Cressie-Loosmore-Ford test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>mad.test</code> </td>
<td style="text-align: left;"> Mean Absolute Deviation test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>anova.ppm</code> </td>
<td style="text-align: left;"> Analysis of Deviance for
    point process models 
  </td>
</tr>
</table>
<p>More recently-developed tests:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>dg.test</code> </td>
<td style="text-align: left;"> Dao-Genton test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>bits.test</code> </td>
<td style="text-align: left;"> Balanced independent two-stage test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>dclf.progress</code> </td>
<td style="text-align: left;"> Progress plot for DCLF test </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>mad.progress</code> </td>
<td style="text-align: left;"> Progress plot for MAD test </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p><b>Sensitivity diagnostics:</b>
</p>
<p>Classical measures of model sensitivity such as leverage and influence
have been adapted to point process models.
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>leverage.ppm</code> </td>
<td style="text-align: left;"> Leverage for point process model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>influence.ppm</code> </td>
<td style="text-align: left;"> Influence for point process model</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dfbetas.ppm</code> </td>
<td style="text-align: left;"> Parameter influence</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>dffit.ppm</code> </td>
<td style="text-align: left;"> Effect change diagnostic
    </td>
</tr>
</table>
<p><b>Diagnostics for covariate effect:</b>
</p>
<p>Classical diagnostics for covariate effects have been adapted to
point process models.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>parres</code> </td>
<td style="text-align: left;"> Partial residual plot</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>addvar</code> </td>
<td style="text-align: left;"> Added variable plot </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rhohat</code> </td>
<td style="text-align: left;"> Kernel estimate of covariate effect</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rho2hat</code> </td>
<td style="text-align: left;"> Kernel estimate of covariate effect
    (bivariate) 
  </td>
</tr>
</table>
<p><b>Residual diagnostics:</b>
</p>
<p>Residuals for a fitted point process model, and diagnostic plots
based on the residuals, were introduced in Baddeley et al (2005) and
Baddeley, Rubak and Moller (2011).
</p>
<p>Type <code>demo(diagnose)</code>
for a demonstration of the diagnostics features.
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>diagnose.ppm</code> </td>
<td style="text-align: left;"> diagnostic plots for spatial trend</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>qqplot.ppm</code> </td>
<td style="text-align: left;"> diagnostic Q-Q plot for interpoint interaction</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>residualspaper</code> </td>
<td style="text-align: left;"> examples from Baddeley et al (2005) </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kcom</code> </td>
<td style="text-align: left;"> model compensator of <code class="reqn">K</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gcom</code> </td>
<td style="text-align: left;"> model compensator of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Kres</code> </td>
<td style="text-align: left;"> score residual of <code class="reqn">K</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>Gres</code> </td>
<td style="text-align: left;"> score residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psst</code> </td>
<td style="text-align: left;"> pseudoscore residual of summary function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psstA</code> </td>
<td style="text-align: left;"> pseudoscore residual of empty space function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>psstG</code> </td>
<td style="text-align: left;"> pseudoscore residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>compareFit</code> </td>
<td style="text-align: left;"> compare compensators of several fitted
    models
  </td>
</tr>
</table>
<p><b>Resampling and randomisation procedures</b>
</p>
<p>You can build your own tests based on randomisation
and resampling using the following capabilities:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>quadratresample</code> </td>
<td style="text-align: left;"> block resampling </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rjitter</code> </td>
<td style="text-align: left;">
    apply random displacements to points in a pattern</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rshift</code> </td>
<td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
<td style="text-align: left;">
    <code>rthin</code> </td>
<td style="text-align: left;">  random thinning  
  </td>
</tr>
</table>
<h3>IX. DOCUMENTATION</h3>

<p>The online manual entries are quite detailed and should be consulted
first for information about a particular function.
</p>
<p>The book
Baddeley, Rubak and Turner (2015) is a complete course
on analysing spatial point patterns, with full details about
<span class="pkg">spatstat</span>.
</p>
<p>Older material (which is now out-of-date but is freely available)
includes Baddeley and Turner (2005a), a brief overview of
the package in its early development;
Baddeley and Turner (2005b), a more detailed explanation of
how to fit point process models to data; and 
Baddeley (2010), a complete set of notes from a 2-day workshop
on the use of <span class="pkg">spatstat</span>. 
</p>
<p>Type <code>citation("spatstat")</code> to get a list of these references.
</p>


<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the "GNU 
General Public License", a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ottmar Cronie,
Tilman Davies,
Yongtao Guan,
Ute Hahn,
Abdollah Jalilian,
Marie-Colette van Lieshout,
Greg McSwiggan,
Tuomas Rajala,
Suman Rakshit,
Dominic Schuhmacher,
Rasmus Waagepetersen
and
Hangsheng Wang
made substantial contributions of code.
</p>
<p>Additional contributions and suggestions from
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Julian Gilbey,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kassel Hingee,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Bethany Macdonald,
Ben Madin,
Martin Maechler,
Daniel Manrique-Castano,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Suman Rakshit,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Yonatan Rosen,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2010)
<em>Analysing spatial point patterns in R</em>.
Workshop notes, Version 4.1.
Online technical publication, CSIRO.
<a href="https://research.csiro.au/software/wp-content/uploads/sites/6/2015/02/Rspatialcourse_CMIS_PDF-Standard.pdf">https://research.csiro.au/software/wp-content/uploads/sites/6/2015/02/Rspatialcourse_CMIS_PDF-Standard.pdf</a>
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015)
<em>Spatial Point Patterns: Methodology and Applications with R</em>.
Chapman and Hall/CRC Press.
</p>
<p>Baddeley, A. and Turner, R. (2005a)
Spatstat: an R package for analyzing spatial point patterns.
<em>Journal of Statistical Software</em> <b>12</b>:6, 142.
<code>DOI: 10.18637/jss.v012.i06</code>. 
</p>
<p>Baddeley, A. and Turner, R. (2005b)
Modelling spatial point patterns in R.
In: A. Baddeley, P. Gregori, J. Mateu, R. Stoica, and D. Stoyan,
editors, <em>Case Studies in Spatial Point Pattern Modelling</em>,
Lecture Notes in Statistics number 185. Pages 2374.
Springer-Verlag, New York, 2006. 
ISBN: 0-387-28311-0.
</p>
<p>Baddeley, A., Turner, R.,
Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617666.
</p>
<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613646.
</p>
<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 143.
<a href="https://www.jstatsoft.org/v55/i11/">https://www.jstatsoft.org/v55/i11/</a>
</p>
<p>Diggle, P.J. (2003)
<em>Statistical analysis of spatial point patterns</em>,
Second edition. Arnold.
</p>
<p>Diggle, P.J. (2014)
<em>Statistical Analysis of Spatial and Spatio-Temporal Point Patterns</em>,
Third edition. Chapman and Hall/CRC.
</p>
<p>Gelfand, A.E., Diggle, P.J., Fuentes, M. and Guttorp, P., editors (2010)
<em>Handbook of Spatial Statistics</em>.
CRC Press.
</p>
<p>Huang, F. and Ogata, Y. (1999)
Improvements of the maximum pseudo-likelihood
estimators in various spatial statistical models.
<em>Journal of Computational and Graphical Statistics</em>
<b>8</b>, 510530.
</p>
<p>Illian, J., Penttinen, A., Stoyan, H. and Stoyan, D. (2008)
<em>Statistical Analysis and Modelling of Spatial Point Patterns.</em>
Wiley.
</p>
<p>Waagepetersen, R.
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b> (2007) 252258.
</p>


</div>