<div class="container">

<table style="width: 100%;"><tr>
<td>asof_join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Temporal join</h2>

<h3>Description</h3>

<p>Perform left-outer join on 2 'TimeSeriesRDD's based on inexact timestamp
matches
</p>


<h3>Usage</h3>

<pre><code class="language-R">asof_join(
  left,
  right,
  tol = "0ms",
  direction = c("&gt;=", "&lt;=", "&lt;"),
  key_columns = list(),
  left_prefix = NULL,
  right_prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>The left 'TimeSeriesRDD'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>The right 'TimeSeriesRDD'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A character vector specifying a time duration (e.g., "0ns", "5ms",
"5s", "1d", etc) as the tolerance for absolute difference in timestamp values
between each record from 'left' and its matching record from 'right'.
By default, 'tol' is "0ns", which means a record from 'left' will only be
matched with a record from 'right' if both contain the exact same timestamps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Specifies the temporal direction of the join, must be one
of "&gt;=", "&lt;=", or "&lt;".
If direction is "&gt;=", then each record from 'left' with timestamp 'tl'
gets joined with a record from 'right' having the largest/most recent
timestamp 'tr' such that 'tl' &gt;= 'tr' and 'tl' - 'tr' &lt;= 'tol' (or
equivalently, 0 &lt;= 'tl' - 'tr' &lt;= 'tol').
If direction is "&lt;=", then each record from 'left' with timestamp 'tl'
gets joined with a record from 'right' having the smallest/least recent
timestamp 'tr' such that 'tl' &lt;= 'tr' and 'tr' - 'tl' &lt;= 'tol' (or
equivalently, '0 &lt;= 'tr' - 'tl' &lt;= 'tol').
If direction is "&lt;", then each record from 'left' with timestamp 'tl'
gets joined with a record from 'right' having the smallest/least recent
timestamp 'tr' such that 'tr' &gt; 'tl' and 'tr' - 'tl' &lt;= 'tol' (or
equivalently, 0 &lt; 'tr' - 'tl' &lt;= 'tol').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key_columns</code></td>
<td>
<p>Columns to be used as the matching key among records from
'left' and 'right': if non-empty, then in addition to matching criteria
imposed by timestamps, a record from 'left' will only match one from the
'right' only if they also have equal values in all key columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left_prefix</code></td>
<td>
<p>A string to prepend to all columns from 'left' after the
join (usually for disambiguation purposes if 'left' and 'right' contain
overlapping column names).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right_prefix</code></td>
<td>
<p>A string to prepend to all columns from 'right' after the
join (usually for disambiguation purposes if 'left' and 'right' contain
overlapping column names).</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>Other Temporal join functions: 
<code>asof_future_left_join()</code>,
<code>asof_left_join()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(sparklyr)
library(sparklyr.flint)

sc &lt;- try_spark_connect(master = "local")
if (!is.null(sc)) {
  ts_1 &lt;- copy_to(sc, tibble::tibble(t = seq(10), u = seq(10))) %&gt;%
    from_sdf(is_sorted = TRUE, time_unit = "SECONDS", time_column = "t")
  ts_2 &lt;- copy_to(sc, tibble::tibble(t = seq(10) + 1, v = seq(10) + 1L)) %&gt;%
    from_sdf(is_sorted = TRUE, time_unit = "SECONDS", time_column = "t")
  future_left_join_ts &lt;- asof_join(ts_1, ts_2, tol = "1s", direction = "&lt;=")
} else {
  message("Unable to establish a Spark connection!")
}

</code></pre>


</div>