<div class="container">

<table style="width: 100%;"><tr>
<td>glrSearch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
This function searches through a space of design boundaries (scalar
values a and b) to find values that achieve close to specified
type I and type II errors for the sequential generalized
likelihood ratio test of p0 versus p1 (specified
respectively as vector of length 2) in pre-licensure vaccine trials
</h2>

<h3>Description</h3>

<p>The search through the space of <code class="reqn">b_1</code> (corresponds to <code class="reqn">b_1</code> in
paper) and <code class="reqn">b_0</code> (corresponds to <code class="reqn">b_0</code> in paper) is greedy
initially. Then refinements to the boundary are made by adjusting the
boundaries by the step-size. It is entirely possible that the
step-size is so small that a maximum number of iterations can be
reached. Depending on how close <code class="reqn">p_0</code> and <code class="reqn">p_1</code> are the memory
usage can grow significantly. The process is computationally intensive
being dominated by a recursion deep in the search.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glrSearch(p, alpha, beta, stepSize = 0.5, tol = 1e-7,
          startB1 = log(1/beta), startB0 = log(1/alpha),
          maxIter = 25, gridIt = FALSE, nGrid = 5, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The vector of <code class="reqn">p_0</code> and <code class="reqn">p_1</code>, with <code class="reqn">p_0 &lt; p_1</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>A value for type I error <code class="reqn">\alpha</code> between 0 and 1 typically 0.05 which is the
default value
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>A value for type II error (<code class="reqn">\beta</code>) between 0 and 1 typically below .2,
default 0.10
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSize</code></td>
<td>

<p>A value to use for moving the boundaries during the search, 0.5
default seems to work.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>A value that is used for deciding when to terminate the search. A
euclidean metric is used. Default 1e-7.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startB1</code></td>
<td>

<p>A starting value for the futility boundary, default is log of reciprocal
type I error
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startB0</code></td>
<td>

<p>A starting value for the rejection boundary, default is log of reciprocal
type II error
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>

<p>A maximum number of iterations to be used for the search. This
allows for a bailout if the step size is too small.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridIt</code></td>
<td>

<p>A logical value indicating if a grid of values should be evaluated
once the boundaries are bracketed in the search.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGrid</code></td>
<td>

<p>The number of grid points to use, default 5
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A logical flag indicating if you want verbose output during
search. Useful for situations where the code gets confused.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One should not use this code without a basic understanding of the
Shih, Lai, Heyse and Chen paper cited below, particularly the section
on the pre-licensure vaccine trials.
</p>
<p>As the search can be computationally intensive, the program needs to
use some variables internally by reference, particularly large tables
that stay constant.
</p>
<p>In our experiments, starting off with the default step size has
usually worked, but in other cases the step size and the maximum
number of iterations may need to be adjusted.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>The explored values of the futility boundary
<code class="reqn">b_1</code> (corresponds to the boundary <code class="reqn">b_1</code> in the appendix of reference)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>The explored values of the rejection boundary
<code class="reqn">b_0</code> (corresponds to the boundary <code class="reqn">b_0</code> in the appendix of reference)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate </code></td>
<td>
<p>The estimated <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
values corresponding to the explored boundaries (a 2-column matrix);
first column is <code class="reqn">\alpha</code>, second is <code class="reqn">\beta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glrTables</code></td>
<td>
<p>The constant values of the log likelihoods under
<code class="reqn">p_0</code>, <code class="reqn">p_1</code> and the estimate probability of terminating at that
step. The first two, are, in turn, lists of length <code class="reqn">n</code> where <code class="reqn">n</code>
is the maximum number of adverse events that might be needed for the
test. The last element is a matrix of 2 columns, specifying the
probability of terminating at each value of <code class="reqn">n</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaTable</code></td>
<td>
<p>a matrix (nGrid x nGrid) of <code class="reqn">\alpha</code> values
corresponding to the combinations of boundaries <code class="reqn">b</code> and <code class="reqn">a</code>
(which are the row and column names of the matrix). This is computed
only if <code>gridIt=TRUE</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betaTable</code></td>
<td>
<p>a matrix (nGrid x nGrid) of <code class="reqn">\beta</code> values
corresponding to the combinations of boundaries <code class="reqn">b</code> and <code class="reqn">a</code>
(which are the row and column names of the matrix). This is computed
only if <code>gridIt=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1Vals</code></td>
<td>
<p>the vector of <code class="reqn">b_1</code> (or equivalently <code class="reqn">b_1</code>) values
used in the grid, computed only if <code>gridIt=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0Vals</code></td>
<td>
<p>the vector of <code class="reqn">b_0</code> (or equivalently <code class="reqn">b_0</code>) values
used in the grid, computed only if <code>gridIt=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>The number of iterations actually used</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan
</p>


<h3>References</h3>

<p>“Sequential Generalized Likelihood Ratio Tests for Vaccine Safety Evaluation”
doi: <a href="https://doi.org/10.1002/sim.4036">10.1002/sim.4036</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sglr)
result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10)

result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10, verbose=TRUE)

result &lt;- glrSearch(p=c(.5, .75), alpha=0.05, beta=0.10, gridIt=TRUE)
print(result$alphaTable)
print(result$betaTable)

## takes a while
result &lt;- glrSearch(p=c(.5, 2/3), alpha=0.05, beta=0.10)
print(names(result))

##result &lt;- glrSearch(p=c(.5, 2/3), alpha=0.05, beta=0.10, gridIt=TRUE)
##print(result$alphaTable)
##print(result$betaTable)
</code></pre>


</div>