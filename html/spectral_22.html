<div class="container">

<table style="width: 100%;"><tr>
<td>waterfall</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the local frequencies</h2>

<h3>Description</h3>

<p>A <code>waterfall</code>-diagramm displays the local frequency in dependence of
or spatial vector. One can then locate an event in time or space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">waterfall(
  y = stop("y value is missing"),
  x = NULL,
  nf = 3,
  type = "b",
  width = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric real valued data vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric real valued spatial vector. (time or space)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nf</code></td>
<td>
<p>steepness of the bandpass filter, degree of the polynomial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of weightening function: "poly", "sinc", "bi-cubic","gauss", can be abbreviated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>normalized maximum "inverse" width of the bandpass <code class="reqn">bw = fc/width</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Each frequency is evaluated by calculating the amplitude demodulation, which
is equivalent to the envelope function of the band pass filtered signal.
The frequency of interest defines automatically the center frequency <code class="reqn">fc</code> of the
applied band pass with the bandwidth <code class="reqn">BW</code>:
</p>
<p style="text-align: center;"><code class="reqn">BW = fc / width, BW &lt; width -&gt; BW = width, BW &gt; width -&gt; BW = fc / width</code>
</p>

<p>The frequency is normalized so the minimal frequency is <code class="reqn">1</code>.
With increasing frequency the bandwidth becomes wider, which lead to a variable
resolution in space and frequency. This is comparable to the wavelet
(or Gabor) transform,
which scales the wavelet (window) according to the frequency.
However, the necessary bandwidth is changed by frequency to take the
uncertainty principle into account. Slow oscillating events are measured precisely
in frequency and fast changing processes can be determined more exact in space.
This means for a signal with steady
increasing frequency the <code>waterfall</code> function will produce a diagonally
stripe. See the examples below.
</p>


<h3>Value</h3>

<p>a special <code>fft</code>-object is returned. It has mode "waterfall" and
<code>x</code> and <code>fx</code> present, so it is only plotable.
</p>


<h3>Missing values</h3>

<p>Given a regualar grid <code class="reqn">x_i = \delta x \cdot i</code> there might be missing values
marked with <code>NA</code>, which are treated by the function as 0's.
This "zero-padding" leads to a loss of signal energy being
roughly proportional to the number of missing values.
The correction factor is then <code class="reqn">(1 - Nna/N)</code> as long as <code class="reqn">Nna / N &lt; 0.2</code>.
As long as the locations of missing values are randomly
distributed the implemented procedure workes quite robust. If, in any case,
the distribution becomes correlated the proposed correction is faulty and
projects the wrong energies.
</p>
<p>The amplitudes and PSD values are compensated to show up an estimate of the
"correct" value. Therefore this method is experimental
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### noisy signal with amplitude modulation ####
x &lt;- seq(0,3, length.out = 1000)
# original data
# extended example from envelope function
y &lt;- 1*(abs(x-1.5))*sin(10*2*pi*x) + ifelse(x &gt; 1.5,sin(15*(1+0.25*(x - 1.5))*2*pi*x),0)
ye &lt;- base::Re(envelope(y))

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))

# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")
lines(x,ye)
legend("bottomright",c("modulated","envelope"),col=c("grey","black"),lty=c(2,1))

par(mar=c(3.5,3.5,2,0))
wf &lt;- waterfall(y,x,nf = 3)
# rasterImage2(x = wf$x, y = wf$fx, z = wf$A
#              ,ylim = c(0,60))

plot(wf,ylim=c(0,40),main="Waterfall")


#### uncertainty principle ####
#
# take a look at the side effects
# at [0,30] and [1,0]
#
# With a large steepness e.g. n = 50 you will gain
# artefacts.
#
# if frequency is not stationary
# PSD becomes &gt; 1 depending on the type of band filter.
#
###############################
x &lt;- seq(0,1, length.out=1500)
y &lt;- sin(100*x*x)

FT &lt;- spec.fft(x = x, y = y)
wf &lt;- waterfall(y,x)

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))
# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")

par(mar=c(3.5,3.5,2,0))
plot(wf
             ,ylim=c(0,40),main="Waterfall"
             )
abline(h = 25, lty = 3, lwd = 3, col = "grey")
range(wf$PSD,na.rm = TRUE)
range(wf$A)

###### effect of missing values #####
#
# 10% random missing values cause a
# distortion and a miss scaling of
# the PSD value, which becomes &gt;1 now.
# This depends on the type of band pass
# filter selected.
#
#####################################
x &lt;- seq(0,5, length.out=500)
y &lt;- sin(2*pi * 15 * x + 2*1*cos(2*pi*0.5*x))

# delete 10% of the data
y[sample(length(y),size = 50)] &lt;- NA

wf &lt;- waterfall(y,x,type = "b")

par(mfrow=c(2,1),mar=c(1,3.5,3,3),mgp=c(2.5,1,0))
# plot results
plot(x,y,type="l",lwd=1,col="darkgrey",lty=2,ylab="y",main="Original Data",xaxt="n",xlab="")

par(mar=c(3.5,3.5,2,0))
plot(wf
     ,ylim=c(10,20),main="Waterfall"
)
abline(h = 25, lty = 3, lwd = 3, col = "grey")

# check the PSD range
range(wf$PSD)
range(wf$A)
</code></pre>


</div>