<div class="container">

<table style="width: 100%;"><tr>
<td>knncatimputeLarge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Missing Value Imputation with kNN for High-Dimensional Data</h2>

<h3>Description</h3>

<p>Imputes missing values in a high-dimensional matrix composed of categorical variables
using <code class="reqn">k</code> Nearest Neighbors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">knncatimputeLarge(data, mat.na = NULL, fac = NULL, fac.na = NULL,
   nn = 3, distance = c("smc", "cohen", "snp1norm", "pcc"), 
   n.num = 100, use.weights = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a numeric matrix consisting of integers between 1 and <code class="reqn">n_{cat}</code>,
where <code class="reqn">n_{cat}</code> is maximum number of levels the categorical variables
can take. If <code>mat.na</code> is specified, <code>data</code> is assumed to contain only
non-missing data, and the rows of <code>data</code> are used to impute the missing values
in <code>mat.na</code>. Otherwise, <code>data</code> is also allowed to contain missing values,
and the missing values in the rows of <code>data</code> are imputed by employing the rows of
<code>data</code> showing no missing values.
</p>
<p>Each row of <code>data</code> represents one of the objects that should be used to identify the
<code class="reqn">k</code> nearest neighbors, i.e.\ if the <code class="reqn">k</code> nearest variables should be used to
replace the missing values, then each row must represent one of the variables. If the
<code class="reqn">k</code> nearest observations should be used to impute the missing values, then each
row must correspond to one of the observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat.na</code></td>
<td>
<p>a numeric matrix containing missing values. Must have the same number of
columns as <code>data</code>. All non-missing values must be integers between 1 and
<code class="reqn">n_{cat}</code>. If <code>NULL</code>, <code>data</code> is assumed to also contain the
rows with missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>a numeric or character vector of length <code>nrow{data}</code> specifying the values of
a factor used to split <code>data</code> into subsets. If, e.g., the values of <code>fac</code>
are given by the chromosomes to which the SNPs represented by the rows of <code>data</code>
belong, then <code class="reqn">k</code> nearest neighbors is applied chromosomewise to the missing values
in <code>mat.na</code> (or <code>data</code>). If <code>NULL</code>, no such splitting is done. Must be
specified, if <code>fac.na</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac.na</code></td>
<td>
<p>a numeric or character vector of length <code>nrow{mat.na}</code> specifying the values
of a factor by which <code>mat.na</code> is split into subsets. Each possible value of <code>fac.na</code>
must be at least <code>nn</code> times in <code>fac</code>. Must be specified, if <code>fac</code> and <code>mat.na</code>
is specified. If both <code>fac</code> and <code>fac.na</code> are <code>NULL</code>, then no splitting is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>an integer specifying <code class="reqn">k</code>, i.e.\ the number of nearest neighbors, used to impute
the missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>character string naming the distance measure used in <code class="reqn">k</code> Nearest Neighbors.
Must be either <code>"smc"</code> (default), <code>"cohen"</code>, <code>"snp1norm"</code> (which denotes the
Manhattan distance for SNPs), or <code>"pcc"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.num</code></td>
<td>
<p>an integer giving the number of rows of <code>mat.na</code> considered simultaneously
when replacing the missing values in <code>mat.na</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.weights</code></td>
<td>
<p>should weighted <code class="reqn">k</code> nearest neighbors be used to impute the missing values?
If <code>TRUE</code>, the votes of the nearest neighbors are weighted by the reciprocal of their
distances to the variable (or observation) whose missing values are imputed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should more information about the progress of the imputation be printed?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>mat.na = NULL</code>, then a matrix of the same size as <code>data</code> in which the missing
values have been replaced. If <code>mat.na</code> has been specified, then a matrix of the same size as
<code>mat.na</code> in which the missing values have been replaced.
</p>


<h3>Note</h3>

<p>While in <code>knncatimpute</code> all variable/rows are considered when replacing
missing values, <code>knncatimputeLarge</code> only considers the rows with no missing values
when searching for the <code class="reqn">k</code> nearest neighbors.
</p>


<h3>Author(s)</h3>

<p>Holger Schwender, <a href="mailto:holger.schwender@udo.edu">holger.schwender@udo.edu</a></p>


<h3>References</h3>

<p>Schwender, H. and Ickstadt, K.\ (2008). Imputing Missing Genotypes with <code class="reqn">k</code> Nearest Neighbors.
<em>Technical Report</em>, SFB 475, Department of Statistics, University of Dortmund. Appears soon.
</p>


<h3>See Also</h3>

<p><code>knncatimpute</code>, <code>gknn</code>, <code>smc</code>, <code>pcc</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Generate a data set consisting of 100 columns and 2000 rows (actually,
# knncatimputeLarge is made for much larger data sets), where the values
# are randomly drawn from the integers 1, 2, and 3.
# Afterwards, remove 200 of the observations randomly.

mat &lt;- matrix(sample(3, 200000, TRUE), 2000)
mat[sample(200000, 20)] &lt;- NA

# Apply knncatimputeLarge to mat to remove the missing values.

mat2 &lt;- knncatimputeLarge(mat)
sum(is.na(mat))
sum(is.na(mat2))

# Now assume that the first 100 rows belong to SNPs from chromosome 1,
# the second 100 rows to SNPs from chromosome 2, and so on.

chromosome &lt;- rep(1:20, e = 100)

# Apply knncatimputeLarge to mat chromosomewise, i.e. only consider
# the SNPs that belong to the same chromosome when replacing missing
# genotypes.

mat4 &lt;- knncatimputeLarge(mat, fac = chromosome)


## End(Not run)</code></pre>


</div>