<div class="container">

<table style="width: 100%;"><tr>
<td>rank_spatial_predictors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Ranks spatial predictors</h2>

<h3>Description</h3>

<p>Ranks spatial predictors generated by <code>mem_multithreshold()</code> or <code>pca_multithreshold()</code> by their effect in reducing the Moran's I of the model residuals (<code>ranking.method = "effect"</code>), or by their own Moran's I (<code>ranking.method = "moran"</code>).
</p>
<p>In the former case, one model of the type <code>y ~ predictors + spatial_predictor_X</code> is fitted per spatial predictor, and the Moran's I of this model's residuals is compared with the one of the model without spatial predictors (<code>y ~ predictors</code>), to finally rank the spatial predictor from maximum to minimum difference in Moran's I.
</p>
<p>In the latter case, the spatial predictors are ordered by their Moran's I alone (this is the faster option).
</p>
<p>In both cases, spatial predictors that are redundant with others at a Pearson correlation &gt; 0.5 and spatial predictors with no effect (no reduction of Moran's I  or Moran's I of the spatial predictor equal or lower than 0) are removed.
</p>
<p>This function has been designed to be used internally by <code>rf_spatial()</code> rather than directly by a user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rank_spatial_predictors(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  ranking.method = c("moran", "effect"),
  reference.moran.i = 1,
  verbose = FALSE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame with a response variable and a set of predictors. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dependent.variable.name</code></td>
<td>
<p>Character string with the name of the response variable. Must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor.variable.names</code></td>
<td>
<p>Character vector with the names of the predictive variables. Every element of this vector must be in the column names of <code>data</code>. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.matrix</code></td>
<td>
<p>Squared matrix with the distances among the records in <code>data</code>. The number of rows of <code>distance.matrix</code> and <code>data</code> must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.thresholds</code></td>
<td>
<p>Numeric vector with neighborhood distances. All distances in the distance matrix below each value in <code>dustance.thresholds</code> are set to 0 for the computation of Moran's I. If <code>NULL</code>, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranger.arguments</code></td>
<td>
<p>List with ranger arguments. See rf or rf_repeat for further details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial.predictors.df</code></td>
<td>
<p>Data frame of spatial predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranking.method</code></td>
<td>
<p>Character, method used by to rank spatial predictors. The method "effect" ranks spatial predictors according how much each predictor reduces Moran's I of the model residuals, while the method "moran" ranks them by their own Moran's I. Default: <code>"moran"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.moran.i</code></td>
<td>
<p>Moran's I of the residuals of the model without spatial predictors. Default: <code>1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, ff <code>TRUE</code>, messages and plots generated during the execution of the function are displayed, Default: <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel execution. Creates a socket cluster with <code>parallel::makeCluster()</code>, runs operations in parallel with <code>foreach</code> and <code style="white-space: pre;">⁠%dopar%⁠</code>, and stops the cluster with <code>parallel::clusterStop()</code> when the job is done. Default: <code>parallel::detectCores() - 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A cluster definition generated with <code>parallel::makeCluster()</code>. If provided, overrides <code>n.cores</code>. When <code>cluster = NULL</code> (default value), and <code>model</code> is provided, the cluster in <code>model</code>, if any, is used instead. If this cluster is <code>NULL</code>, then the function uses <code>n.cores</code> instead. The function does not stop a provided cluster, so it should be stopped with <code>parallel::stopCluster()</code> afterwards. The cluster definition is stored in the output list under the name "cluster" so it can be passed to other functions via the <code>model</code> argument, or using the <code style="white-space: pre;">⁠%&gt;%⁠</code> pipe. Default: <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with four slots:
</p>

<ul>
<li> <p><code>method</code>: Character, name of the method used to rank the spatial predictors.
</p>
</li>
<li> <p><code>criteria</code>: Data frame with two different configurations depending on the ranking method. If <code>ranking.method = "effect"</code>, the columns contain the names of the spatial predictors, the r-squared of the model, the Moran's I of the model residuals, the difference between the Moran's I of the model including the given spatial predictor, and the Moran's I of the model fitted without spatial predictors, and the interpretation of the Moran's I value. If <code>ranking.method = "moran"</code>, only the name of the spatial predictor and it's Moran's I are in the output data frame.
</p>
</li>
<li> <p><code>ranking</code>: Ordered character vector with the names of the spatial predictors selected.
</p>
</li>
<li> <p><code>spatial.predictors.df</code>: data frame with the selected spatial predictors in the order of the ranking.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){

 #loading distance matrix
 data(distance_matrix)

 #computing Moran's Eigenvector Maps
 mem.df &lt;- mem(
  distance.matrix = distance_matrix[1:50, 1:50],
  distance.threshold = 0
 )

 #ranking by the Moran's I of the spatial predictor
 rank &lt;- rank_spatial_predictors(
  distance.matrix = distance_matrix[1:50, 1:50],
  distance.thresholds = 0,
  spatial.predictors.df = mem.df,
  ranking.method = "moran",
  n.cores = 1
 )

 #checking Moran's I of MEMs
 rank$criteria

 #checking rank of MEMs
 rank$ranking
}
</code></pre>


</div>