<div class="container">

<table style="width: 100%;"><tr>
<td>armaccf_xe</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crosscovariances between an ARMA process and its innovations</h2>

<h3>Description</h3>

<p>Compute autocovariances of ARMA models and crosscovariances between an
ARMA process and its innovations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">armaccf_xe(model, lag.max = 1)
armaacf(model, lag.max, compare)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>the model, a list with components <code>ar</code>, <code>ma</code> and
<code>sigma2</code> (for the time being, <code>sigmasq</code> is also accepted,
if <code>model$sigma2</code> is NULL).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.max</code></td>
<td>
<p>maximal lag for the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compare</code></td>
<td>

<p>if <code>TRUE</code> compute the autocovariances also using
<code>tacvfARMA()</code> and return both results for comparison.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a causal ARMA model, <code>armaccf_xe</code> computes theoretical
crosscovariances <code class="reqn">R_{xe}(0)</code>, <code class="reqn">R_{xe}(1)</code>,
<code class="reqn">R_{xe}(lag.max)</code>, where <code class="reqn">R_{xe}(k)=E(X_{t}e_{t-k})</code>, between
an ARMA process and its innovations. Negative lags are not considered
since <code class="reqn">R_{xe}(k)=0</code> for <code class="reqn">k&lt;0</code>. The moving average polynomial
may have roots on the unit circle.
</p>
<p>This is a simple illustration of the equations I give in my time
series courses.
</p>
<p><code>armaacf</code> computes ARMA autocovariances. The default method
computes computes the zero lag autocovariance using
<code>armaccf_xe()</code> and multiplies the autocorrelations obtained from
<code>ARMAacf</code> (which computes autocorrelations, not
autocovariances). If <code>compare = TRUE</code> it also uses
<code>tacvfARMA</code> from package <span class="pkg">ltsa</span> and returns both results in a
matrix for comparison. The matrix has columns <code>"native"</code>,
<code>"tacvfARMA"</code> and <code>"difference"</code>, where the last column
contains the (zapped) differences between the autocorrelations
obtained by the two methods.
</p>
<p>The ARMA parameters in argument <code>model</code> follow the
Brockwell-Davis convention for the signs. Since <code>tacvfARMA()</code>
uses the Box-Jenkins convention for the signs, the moving average
parameters are negated for calls to <code>tacvfARMA()</code>.
</p>


<h3>Value</h3>

<p>for <code>armaccf_xe</code>, the crosscovariances for lags 0, ..., maxlag.
</p>
<p>for <code>armaacf</code>, the autocovariances, see Details.
</p>


<h3>Note</h3>

<p><code>armaacf</code> is useful for exploratory computations but
<code>autocovariances</code> is more convenient and eliminates the
need to know function names for particular cases.


</p>





<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI, Yu H, Krougly Z (2007).
“Algorithms for Linear Time Series Analysis: With R Package.”
<em>Journal of Statistical Software</em>, <b>23</b>(5).
<a href="https://doi.org/10.18637/jss.v023.i05">doi:10.18637/jss.v023.i05</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1 from ?ltsa::tacvfARMA
z &lt;- sqrt(sunspot.year)
n &lt;- length(z)
p &lt;- 9
q &lt;- 0
ML &lt;- 5
out &lt;- arima(z, order = c(p, 0, q))

phi &lt;- theta &lt;- numeric(0)
if (p &gt; 0) phi &lt;- coef(out)[1:p]
if (q &gt; 0) theta &lt;- coef(out)[(p+1):(p+q)]
zm &lt;- coef(out)[p+q+1]
sigma2 &lt;- out$sigma2

armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20)
## this illustrates that the methods
## based on ARMAacf and tacvARMA are equivalent:
armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20, compare = TRUE)

## In the original example in ?ltsa::tacvfARMA
## the comparison is with var(z), not with the theoretical variance:
rA &lt;- ltsa::tacvfARMA(phi, - theta, maxLag=n+ML-1, sigma2=sigma2)
rB &lt;- var(z) * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1)
## so rA and rB are different.
## but the difference is due to the variance:
rB2 &lt;- rA[1] * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1)
cbind(rA[1:5], rB[1:5], rB2[1:5])

## There is no need to use specific functions,
## autocovariances() is most convenient for routine use:
armalist &lt;- list(ar = phi, ma = theta, sigma2 = sigma2)
autocovariances(armalist, maxlag = 10)

## even better, set up an ARMA model:
mo &lt;- new("ArmaModel", ar = phi, ma = theta, sigma2 = sigma2)
autocovariances(mo, maxlag = 10)
</code></pre>


</div>