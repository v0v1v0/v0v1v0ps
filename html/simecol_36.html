<div class="container">

<table style="width: 100%;"><tr>
<td>fitOdeModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parameter Fitting for odeModel Objects</h2>

<h3>Description</h3>

<p>Fit parameters of <code>odeModel</code> objects to measured data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitOdeModel(simObj, whichpar = names(parms(simObj)), obstime, yobs, 
  sd.yobs = as.numeric(lapply(yobs, sd)), initialize = TRUE, 
  weights = NULL, debuglevel = 0, fn = ssqOdeModel, 
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "PORT",
   "newuoa", "bobyqa"),
  lower = -Inf, upper = Inf, scale.par = 1,
  control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simObj</code></td>
<td>
<p>a valid object of class <code>odeModel</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whichpar</code></td>
<td>
<p>character vector with names of parameters which are to
be optimized (subset of parameter names of the <code>simObj</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obstime</code></td>
<td>
<p>vector with time steps for which observational data are
available,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yobs</code></td>
<td>
<p>data frame with observational data for all or a subset of
state variables. Their names must correspond exacly with existing
names of state variables in the <code>odeModel</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.yobs</code></td>
<td>
<p>vector of given standard deviations (or scale) for all
observational variables given in <code>yobs</code>.  If no standard
deviations (resp. scales) are given, these are estimated from
<code>yobs</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialize</code></td>
<td>
<p>optional boolean value whether the simObj should be
re-initialized after the assignment of new parameter values. This
can be necessary in certain models to assign consistent values to
initial state variables if they depend on parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional weights to be used in the fitting process.
See cost function (currently only <code>ssqOdeModel</code>) for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debuglevel</code></td>
<td>
<p>a positive number that specifies the amount of
debugging information printed,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>objective function, i.e. function that returns the quality
criterium that is minimized, defaults to <code>ssqOdeModel</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>optimization method, see <code>nlminb</code> for
the PORT algorithm, <code>newuoa</code> resp.
<code>bobyqa</code>  for the newuoa and bobyqa
algorithms, and <code>optim</code> for all other  methods,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>bounds of the parameters for method L-BFGS-B, see
<code>optim</code>, PORT see <code>nlminb</code>
and bobyqa <code>bobyqa</code>.
The bounds are also respected by other optimizers
by means of an internal transformation of the parameter space (see 
<code>p.constrain</code>). In this case, <em>named vectors</em> are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.par</code></td>
<td>
<p>scaling of parameters for method PORT see
<code>nlminb</code>.  In many cases, automatic scaling
(<code>scale.par = 1</code>) does well, but sometimes (e.g. if parameter
ranges differ several orders of magnitude) manual adjustment is
required. Often you get a reasonable choice if you set
<code>scale.par = 1/upper</code>.  The parameter is ignored by all other
methods. For <code>"Nelder-Mead"</code>, <code>"BFGS"</code>, <code>"CG"</code> and
<code>"SANN"</code> parameter scaling occurs as a side effect of parameter
transformation with <code>p.constrain</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters for
<code>optim</code> resp.  <code>nlminb</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to the solver method
(e.g. to <code>lsoda</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function works currently only with <code>odeModel</code> objects where
<code>parms</code> is a vector, not a list.
</p>
<p>Note also that the control parameters of the PORT algorithm are
different from the control parameters of the other optimizers.
</p>


<h3>Value</h3>

<p>A list with the optimized parameters and other information, see
<code>optim</code> resp. <code>nlminb</code> for
details.
</p>


<h3>References</h3>

<p>Gay, D. M. (1990) Usage Summary for Selected Optimization Routines.
Computing Science Technical Report No. 153. AT&amp;T Bell Laboratories,
Murray Hill, NJ.
</p>
<p>Powell, M. J. D. (2009). The BOBYQA algorithm for bound constrained
optimization without derivatives. Report No. DAMTP 2009/NA06, Centre
for Mathematical Sciences, University of Cambridge, UK.
<a href="https://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf">https://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf</a>
</p>


<h3>See Also</h3>

<p><code>ssqOdeModel</code>, <code>optim</code>, <code>nlminb</code>,
<code>bobyqa</code>
</p>
<p>Note also that package <span class="pkg">FME</span> function
<code>modFit</code> has even more flexible means to fit
model parameters.
</p>
<p>Examples are given in the package vignettes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## ======== load example model =========
data(chemostat)

#source("chemostat.R")

## derive scenarios
cs1 &lt;- cs2 &lt;- chemostat

## generate some noisy data
parms(cs1)[c("vm", "km")] &lt;- c(2, 10)
times(cs1) &lt;- c(from=0, to=20, by=2)
yobs &lt;- out(sim(cs1))
obstime &lt;- yobs$time
yobs$time &lt;- NULL
yobs$S &lt;- yobs$S + rnorm(yobs$S, sd= 0.1 * sd(yobs$S))*2
yobs$X &lt;- yobs$X + rnorm(yobs$X, sd= 0.1 * sd(yobs$X))

## ======== optimize it! =========

## time steps for simulation, either small for rk4 fixed step
# times(cs2)["by"] &lt;- 0.1
# solver(cs2) &lt;- "rk4"

## or, faster: use lsoda and and return only required steps that are in the data
times(cs2) &lt;- obstime
solver(cs2) &lt;- "lsoda"

## Nelder-Mead (default)
whichpar  &lt;- c("vm", "km")

res &lt;- fitOdeModel(cs2, whichpar=whichpar, obstime, yobs,
  debuglevel=0,
  control=list(trace=TRUE))

coef(res)

## assign fitted parameters to the model, i.e. as start values for next step
parms(cs2)[whichpar] &lt;- coef(res)

## alternatively, L-BFGS-B (allows lower and upper bounds for parameters)
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "L-BFGS-B", lower = 0,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## alternative 2, transform parameters to constrain unconstrained method
## Note: lower and upper are *named* vectors
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "BFGS", lower = c(vm=0, km=0), upper=c(vm=4, km=20),
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)


## alternative 3a, use PORT algorithm
parms(cs2)[whichpar] &lt;- c(vm=1, km=2)

lower &lt;- c(vm=0, km=0)
upper &lt;- c(vm=4, km=20)

res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "PORT", lower = lower, upper = upper,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## alternative 3b, PORT algorithm with manual parameter scaling
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "PORT", lower = lower, upper = upper, scale.par = 1/upper,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## set model parameters to  fitted values and simulate again
parms(cs2)[whichpar] &lt;- coef(res)
times(cs2) &lt;- c(from=0, to=20, by=1)
ysim &lt;- out(sim(cs2))

## plot results
par(mfrow=c(2,1))
plot(obstime, yobs$X, ylim = range(yobs$X, ysim$X))
lines(ysim$time, ysim$X, col="red")
plot(obstime, yobs$S, ylim= range(yobs$S, ysim$S))
lines(ysim$time, ysim$S, col="red")

</code></pre>


</div>