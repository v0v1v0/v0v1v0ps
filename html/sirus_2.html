<div class="container">

<table style="width: 100%;"><tr>
<td>sirus.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit SIRUS.</h2>

<h3>Description</h3>

<p>Fit SIRUS for a given number of rules (10 by default) or a given <code>p0</code>. <br>
SIRUS is a regression and classification algorithm, based on random forests (Breiman, 2001), that takes the form of a short list of rules.
SIRUS combines the simplicity of rule algorithms or decision trees with an accuracy close to random forests.
More importantly, the rule selection is stable with respect to data perturbation.
SIRUS for classification is defined in (Benard et al. 2021a), and the extension to regression is provided in (Benard et al. 2021b).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sirus.fit(
  data,
  y,
  type = "auto",
  num.rule = 10,
  p0 = NULL,
  num.rule.max = 25,
  q = 10,
  discrete.limit = 10,
  num.trees.step = 1000,
  alpha = 0.05,
  mtry = NULL,
  max.depth = 2,
  num.trees = NULL,
  num.threads = NULL,
  replace = TRUE,
  sample.fraction = ifelse(replace, 1, 0.632),
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input dataframe, each row is an observation vector. Each column is an input variable and is numeric or factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric response variable. For classification, <code>y</code> takes only 0 and 1 values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>'reg' for regression, 'classif' for classification and 'auto' for automatic detection (classification if <code>y</code> takes only 0 and 1 values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.rule</code></td>
<td>
<p>Number of rules in SIRUS model. Default is 10. Ignored if a <code>p0</code> value is provided. For regression, the effective number of rules can be smaller than <code>num.rule</code> because of null coefficients in the final linear aggregation of the rules.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>Selection threshold on the frequency of appearance of a path in the forest to set the number of rules. Default is NULL and <code>num.rule</code> is used to select rules. <code>sirus.cv</code> provides the optimal <code>p0</code> by cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.rule.max</code></td>
<td>
<p>Maximum number of rules in SIRUS model. Ignored if <code>num.rule</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Number of quantiles used for node splitting in the forest construction. Default and recommended value is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete.limit</code></td>
<td>
<p>Maximum number of distinct values for a variable to be considered discrete. If higher, variable is continuous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.trees.step</code></td>
<td>
<p>Number of trees grown between two evaluations of the stopping criterion. Ignored if <code>num.trees</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter of the stopping criterion for the number of trees: stability has to reach 1-<code>alpha</code> to stop the growing of the forest. Ignored if <code>num.trees</code> is provided. Default value is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>
<p>Number of variables to possibly split at each node. Default is the number of variables divided by 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.depth</code></td>
<td>
<p>Maximal tree depth. Default and recommended value is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.trees</code></td>
<td>
<p>Number of trees grown in the forest. Default is NULL. If NULL (recommended), the number of trees is automatically set using a stability based stopping criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.threads</code></td>
<td>
<p>Number of threads used to grow the forest. Default is number of CPUs available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Boolean. If true (default), sample with replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.fraction</code></td>
<td>
<p>Fraction of observations to sample. Default is 1 for sampling with replacement and 0.632 for sampling without replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean. If true, information messages are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed. Default is NULL, which generates the seed from R. Set to 0 to ignore the R seed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the output <code>y</code> takes only 0 and 1 values, a classification model is fit, otherwise a regression model is fit.
SIRUS algorithm proceeds the following steps:
</p>

<ol>
<li>
<p> Discretize data
</p>
</li>
<li>
<p> Fit a random forest
</p>
</li>
<li>
<p> Extract rules from tree nodes
</p>
</li>
<li>
<p> Select the most frequent rules (which occur in at least a fraction p0 of the trees)
</p>
</li>
<li>
<p> Filter rules to remove linear dependence between them
</p>
</li>
<li>
<p> Aggregate the selected rules
</p>

<ul>
<li>
<p> Classification: rules are averaged
</p>
</li>
<li>
<p> Regression: rules are linearly combined via a ridge regression (constrained to have all coefficients positive)
</p>
</li>
</ul>
</li>
</ol>
<p>The hyperparameter <code>p0</code> can be tuned using <code>sirus.cv</code> to set the optimal number of rules. <br>
The number of trees is automatically set with a stopping criterion based on stability: 
the forest growing is stopped when the number of trees is high enough to ensure that 95% of the rules in average are identical over two runs of SIRUS on the provided dataset. <br>
Data is discretized depending on variable types: numerical variables are binned using <code>q</code>-quantiles, 
categorical variables are transformed in ordered variables as in <code>ranger</code> (standard method to handle categorical variables in trees),
while discrete variables (numerical variables with less than <code>discrete.limit</code> distinct values) are left untouched.
Notice that categorical variables with a high number of categories should be discarded or transformed, as SIRUS is likely to identify associated irrelevant rules.
</p>


<h3>Value</h3>

<p>SIRUS model with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>List of rules in SIRUS model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules.out</code></td>
<td>
<p>List of rule outputs. <code>rule.out</code>: the output mean whether the rule is satisfied or not. <code>supp.size</code>: the number of points inside and outside the rule.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proba</code></td>
<td>
<p>Frequency of occurence of paths in the forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>List of selected paths (symbolic representation with quantile order for continuous variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule.weights</code></td>
<td>
<p>Vector of positive or null coefficients assigned to each rule for the linear aggregation (1/number of rules for classification).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule.glm</code></td>
<td>
<p>Fitted glmnet object for regression (linear rule aggregation with ridge penalty).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of SIRUS model: 'reg' for regression, 'classif' for classification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.trees</code></td>
<td>
<p>Number of trees used to build SIRUS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.names</code></td>
<td>
<p>Names of input variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>Mean output over the full training data. Default model output if no rule is selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>List of type and possible split values for all input variables.</p>
</td>
</tr>
</table>
<h3>References</h3>


<ul>
<li>
<p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021a). SIRUS: Stable and Interpretable RUle Set for Classification. Electronic Journal of Statistics, 15:427-505. <a href="https://doi.org/10.1214/20-EJS1792">doi:10.1214/20-EJS1792</a>.
</p>
</li>
<li>
<p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021b). Interpretable Random Forests via Rule Extraction. Proceedings of The 24th International Conference on Artificial Intelligence and Statistics, PMLR 130:937-945. <a href="http://proceedings.mlr.press/v130/benard21a">http://proceedings.mlr.press/v130/benard21a</a>. 
</p>
</li>
<li>
<p> Breiman, L. (2001). Random forests. Machine learning, 45, 5-32.
</p>
</li>
<li>
<p> Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. <a href="https://doi.org/10.18637/jss.v077.i01">doi:10.18637/jss.v077.i01</a>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

## fit SIRUS
sirus.m &lt;- sirus.fit(data, y)

</code></pre>


</div>