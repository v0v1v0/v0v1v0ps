<div class="container">

<table style="width: 100%;"><tr>
<td>mewma.arl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute ARLs of MEWMA control charts</h2>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for multivariate exponentially weighted moving average (MEWMA) charts monitoring multivariate normal mean.</p>


<h3>Usage</h3>

<pre><code class="language-R">mewma.arl(l, cE, p, delta=0, hs=0, r=20, ntype=NULL, qm0=20, qm1=qm0)

mewma.arl.f(l, cE, p, delta=0, r=20, ntype=NULL, qm0=20, qm1=qm0)

mewma.ad(l, cE, p, delta=0, r=20, n=20, type="cond", hs=0, ntype=NULL, qm0=20, qm1=qm0)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>smoothing parameter lambda of the MEWMA control chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cE</code></td>
<td>
<p>alarm threshold of the MEWMA control chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>dimension of multivariate normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>magnitude of the potential change, <code>delta=0</code> refers to the in-control state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>so-called headstart (enables fast initial response) – must be non-negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of quadrature nodes – dimension of the resulting linear equation system
for <code>delta</code> = 0. For non-zero <code>delta</code> this dimension is mostly r^2 (Markov chain approximation leads
to some larger values). Caution: If <code>ntype</code> is set to <code>"co"</code> (collocation), then values of <code>r</code>
larger than 20 lead to large computing times.
For the other selections this would happen for values larger than 40.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntype</code></td>
<td>
<p>choose the numerical algorithm to solve the ARL integral equation. For <code>delta</code>=0:
Possible values are
<code>"gl"</code>, <code>"gl2"</code> (gauss-legendre, classic and with variables change: square),
<code>"co"</code> (collocation, for <code>delta</code> &gt; 0 with sin transformation),
<code>"ra"</code> (radau),
<code>"cc"</code> (clenshaw-curtis),
<code>"mc"</code> (markov chain),
and <code>"sr"</code> (simpson rule).
For <code>delta</code> larger than 0, some more values besides the others are possible:
<code>"gl3"</code>, <code>"gl4"</code>, <code>"gl5"</code> (gauss-legendre with a further change in variables: sin, tan, sinh),
<code>"co2"</code>, <code>"co3"</code> (collocation with some trimming and tan as quadrature stabilizing transformations, respectively).
If it is set to <code>NULL</code> (the default), then for <code>delta</code>=0 then <code>"gl2"</code> is chosen.
If <code>delta</code> larger than 0, then for <code>p</code> equal 2 or 4 <code>"gl3"</code> and for all other values <code>"gl5"</code> is taken.
<code>"ra"</code> denotes the method used in Rigdon (1995a). <code>"mc"</code> denotes the Markov chain approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>switch between <code>"cond"</code> and <code>"cycl"</code> for differentiating between the conditional
(no false alarm) and the cyclical (after false alarm re-start in <code>hs</code>), respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of quadrature nodes for Calculating the steady-state ARL integral(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qm0,qm1</code></td>
<td>
<p>number of collocation quadrature nodes for the out-of-control case (<code>qm0</code> for the inner integral,
<code>qm1</code> for the outer one), that is, for positive <code>delta</code>,
and for the in-control case (now only <code>qm0</code> is deployed) if via <code>ntype</code> the collocation procedure is requested.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Basically, this is the implementation of different numerical algorithms for
solving the integral equation for the MEWMA in-control (<code>delta</code> = 0) ARL introduced in Rigdon (1995a)
and out-of-control (<code>delta</code> != 0) ARL in Rigdon (1995b).
Most of them are nothing else than the Nystroem approach – the integral is replaced by a suitable quadrature.
Here, the Gauss-Legendre (more powerful), Radau (used by Rigdon, 1995a), Clenshaw-Curtis, and
Simpson rule (which is really bad) are provided.
Additionally, the collocation approach is offered as well, because it is much better for small odd values for <code>p</code>.
FORTRAN code for the Radau quadrature based Nystroem of Rigdon (1995a)
was published in Bodden and Rigdon (1999) – see also <a href="https://lib.stat.cmu.edu/jqt/31-1">https://lib.stat.cmu.edu/jqt/31-1</a>.
Furthermore, FORTRAN code for the Markov chain approximation (in- and out-ot-control)
could be found at <a href="https://lib.stat.cmu.edu/jqt/33-4/">https://lib.stat.cmu.edu/jqt/33-4/</a>.
The related papers are Runger and Prabhu (1996) and Molnau et al. (2001).
The idea of the Clenshaw-Curtis quadrature was taken from
Capizzi and Masarotto (2010), who successfully deployed a modified Clenshaw-Curtis quadrature
to calculate the ARL of combined (univariate) Shewhart-EWMA charts. It turns out that it works also nicely for the
MEWMA ARL. The version <code>mewma.arl.f()</code> without the argument <code>hs</code> provides the ARL as function of one (in-control)
or two (out-of-control) arguments.
</p>


<h3>Value</h3>

<p>Returns a single value which is simply the zero-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>Kevin M. Bodden and Steven E. Rigdon (1999),
A program for approximating the in-control ARL for the MEWMA chart,
<em>Journal of Quality Technology 31(1)</em>, 120-123.
</p>
<p>Giovanna Capizzi and Guido Masarotto (2010),
Evaluation of the run-length distribution for a combined Shewhart-EWMA control chart,
<em>Statistics and Computing 20(1)</em>, 23-33.
</p>
<p>Sven Knoth (2017),
ARL Numerics for MEWMA Charts,
<em>Journal of Quality Technology 49(1)</em>, 78-89.
</p>
<p>Wade E. Molnau et al. (2001),
A Program for ARL Calculation for Multivariate EWMA Charts,
<em>Journal of Quality Technology 33(4)</em>, 515-521.
</p>
<p>Sharad S. Prabhu and George C. Runger (1997),
Designing a multivariate EWMA control chart,
<em>Journal of Quality Technology 29(1)</em>, 8-15.
</p>
<p>Steven E. Rigdon (1995a), An integral equation for the in-control average run length of a multivariate
exponentially weighted moving average control chart, <em>J. Stat. Comput. Simulation 52(4)</em>, 351-365.
</p>
<p>Steven E. Rigdon (1995b), A double-integral equation for the average run length of a multivariate
exponentially weighted moving average control chart, <em>Stat. Probab. Lett. 24(4)</em>, 365-373.
</p>
<p>George C. Runger and Sharad S. Prabhu (1996),
A Markov Chain Model for the Multivariate Exponentially Weighted Moving Averages Control Chart,
<em>J. Amer. Statist. Assoc. 91(436)</em>, 1701-1706.
</p>


<h3>See Also</h3>

<p><code>mewma.crit</code> for getting the alarm threshold to attain a certain in-control ARL.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Rigdon (1995a), p. 357, Tab. 1
p &lt;- 2
r &lt;- 0.25
h4 &lt;- c(8.37, 9.90, 11.89, 13.36, 14.82, 16.72)
for ( i in 1:length(h4) ) cat(paste(h4[i], "\t", round(mewma.arl(r, h4[i], p, ntype="ra")), "\n"))

r &lt;- 0.1
h4 &lt;- c(6.98, 8.63, 10.77, 12.37, 13.88, 15.88)
for ( i in 1:length(h4) ) cat(paste(h4[i], "\t", round(mewma.arl(r, h4[i], p, ntype="ra")), "\n"))


# Rigdon (1995b), p. 372, Tab. 1
## Not run: 
r &lt;- 0.1
p &lt;- 4
h &lt;- 12.73
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

p &lt;- 5
h &lt;- 14.56
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

p &lt;- 10
h &lt;- 22.67
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

## End(Not run)

# Runger/Prabhu (1996), p. 1704, Tab. 1
## Not run: 
r &lt;- 0.1
p &lt;- 4
H &lt;- 12.73
cat(paste(0, "\t", round(mewma.arl(r, H, p, delta=0, ntype="mc", r=50), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.arl(r, H, p, delta=delta, ntype="mc", r=25), digits=2), "\n"))
# compare with Fortran program (MEWMA-ARLs.f90) from Molnau et al. (2001) with m1 = m2 = 25
# H4      P     R   DEL  ARL
# 12.73  4.  0.10  0.00 199.78
# 12.73  4.  0.10  0.50  35.05
# 12.73  4.  0.10  1.00  12.17
# 12.73  4.  0.10  1.50   7.22
# 12.73  4.  0.10  2.00   5.19
# 12.73  4.  0.10  3.00   3.42

p &lt;- 20
H &lt;- 37.01
cat(paste(0, "\t",
    round(mewma.arl(r, H, p, delta=0, ntype="mc", r=50), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.arl(r, H, p, delta=delta, ntype="mc", r=25), digits=2), "\n"))
# compare with Fortran program (MEWMA-ARLs.f90) from Molnau et al. (2001) with m1 = m2 = 25
# H4      P     R   DEL  ARL
# 37.01 20.  0.10  0.00 199.09
# 37.01 20.  0.10  0.50  61.62
# 37.01 20.  0.10  1.00  20.17
# 37.01 20.  0.10  1.50  11.40
# 37.01 20.  0.10  2.00   8.03
# 37.01 20.  0.10  3.00   5.18

## End(Not run)

# Knoth (2017), p. 85, Tab. 3, rows with p=3
## Not run: 
p &lt;- 3
lambda &lt;- 0.05
h4 &lt;- mewma.crit(lambda, 200, p)
benchmark &lt;- mewma.arl(lambda, h4, p, delta=1, r=50)
  
mc.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=25, ntype="mc")
ra.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=27, ntype="ra")
co.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=12, ntype="co2")
gl3.arl &lt;- mewma.arl(lambda, h4, p, delta=1, r=30, ntype="gl3")
gl5.arl &lt;- mewma.arl(lambda, h4, p, delta=1, r=25, ntype="gl5")
  
abs( benchmark - data.frame(mc.arl, ra.arl, co.arl, gl3.arl, gl5.arl) )

## End(Not run)

# Prabhu/Runger (1997), p. 13, Tab. 3
## Not run: 
p &lt;- 2
r &lt;- 0.1
H &lt;- 8.64
cat(paste(0, "\t",
    round(mewma.ad(r, H, p, delta=0, type="cycl", ntype="mc", r=60), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.ad(r, H, p, delta=delta, type="cycl", ntype="mc", r=30), digits=2), "\n"))

# better accuracy
for ( delta in c(0, .5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.ad(r, H, p, delta=delta^2, type="cycl", r=30), digits=2), "\n"))

## End(Not run)
</code></pre>


</div>