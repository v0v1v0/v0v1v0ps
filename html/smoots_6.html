<div class="container">

<table style="width: 100%;"><tr>
<td>dsmooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time
Series</h2>

<h3>Description</h3>

<p>This function runs through an iterative process in order to find the
optimal bandwidth for the nonparametric estimation of the first or second
derivative of the trend in an equidistant time series (with short-memory
errors) and subsequently employs the obtained bandwidth via local
polynomial regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dsmooth(
  y,
  d = c(1, 2),
  mu = c(0, 1, 2, 3),
  pp = c(1, 3),
  bStart.p = 0.15,
  bStart = 0.15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>an integer <code>1</code> or <code>2</code> that defines the order of
derivative; the default is <code>d = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number</strong> </td>
<td style="text-align: left;"> <strong>Kernel</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Triweight Kernel
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pp</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression) that indicates the order of polynomial upon which
<code class="reqn">c_f</code>, i.e. the variance factor, will be calculated by
<code>msmooth</code>; the default is <code>pp = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bStart.p</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process for the calculation of <code class="reqn">c_f</code>; should
be <code class="reqn">&gt; 0</code>; is set to <code>0.15</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bStart</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process; should be <code class="reqn">&gt; 0</code>; is set to
<code>0.15</code> by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trend's derivative is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and short-range dependence (see also Beran and Feng,
2002). With this function, the first or second derivative of <code class="reqn">m(x_t)</code>
can be estimated without a parametric model assumption for the error series.
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), was proposed by Feng, Gries and
Fritz (2020).
</p>
<p>Define <code class="reqn">I[m^{(k)}] = \int_{c_b}^{d_b} [m^{(k)}(x)]^2 dx</code>, <code class="reqn">\beta_{(\nu, k)} = \int_{-1}^{1} u^k
K_{(\nu, k)}(u) du</code>
and <code class="reqn">R(K) = \int_{-1}^{1} K_{(\nu, k)}^{2}(u) du</code>, where <code class="reqn">p</code> is the order of the polynomial,
<code class="reqn">k = p + 1</code> is the order of the asymptotically equivalent kernel,
<code class="reqn">\nu</code> is the order of the trend function's derivative, <code class="reqn">0 \leq c_{b}
&lt; d_{b} \leq 1</code>, <code class="reqn">c_f</code> is the variance factor and
<code class="reqn">K_{(\nu, k)}(u)</code> the <code class="reqn">k</code>-th order equivalent kernel
obtained for the estimation of <code class="reqn">m^{(\nu)}</code> in the interior.
<code class="reqn">m^{(\nu)}</code> is the <code class="reqn">\nu</code>-th order derivative (<code class="reqn">\nu = 0,
1, 2, ...</code>) of the nonparametric trend.
</p>
<p>Furthermore, we define
</p>
<p style="text-align: center;"><code class="reqn">C_{1} = \frac{I[m^{(k)}] \beta_{(\nu, k)}^2}{(k!)^2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">C_{2} = \frac{2 \pi c_{f} (d_b - c_b) R(K)}{nh^{2 \nu + 1}}</code>
</p>

<p>with <code class="reqn">h</code> being the bandwidth and <code class="reqn">n</code> being the number of
observations. The AMISE is then
</p>
<p style="text-align: center;"><code class="reqn">AMISE(h) = h^{2(k-\nu)}C_{1} + C_{2}.</code>
</p>

<p>The variance factor <code class="reqn">c_f</code> is first obtained from a pilot-estimation of
the time series' nonparametric trend (<code class="reqn">\nu = 0</code>) with polynomial order
<code class="reqn">p_p</code>. The estimate is then plugged into the iterative procedure for
estimating the first or second derivative (<code class="reqn">\nu = 1</code> or <code class="reqn">\nu = 2</code>).
For further details on the asymptotic theory or the algorithm, we refer the
user to Feng, Fritz and Gries (2020) and Feng et al. (2019).
</p>
<p>The function itself is applicable in the following way: Based on a data input
<code>y</code>, an order of polynomial <code>pp</code> for the variance factor estimation
procedure, a starting value for the relative bandwidth <code>bStart.p</code> in the
variance factor estimation procedure, a kernel function defined by the
smoothness parameter <code>mu</code> and a starting value for the relative
bandwidth <code>bStart</code> in the bandwidth estimation procedure, an optimal
bandwidth is numerically calculated for the trend's derivative of order
<code>d</code>. In fact, aside from the input vector <code>y</code>, every argument has a
default setting that can be adjusted for the individual case. However, it is
recommended to initially use the default values for the estimation of the
first derivative and adjust the argument <code>d</code> to <code>d = 2</code> for the
estimation of the second derivative. Following Feng, Gries and Fritz (2020),
the initial bandwidth does not affect the resulting optimal bandwidth in
theory. However in practice, local minima of the AMISE can influence the
results. Therefore, the default starting bandwidth is set to <code>0.15</code>, the
suggested starting bandwidth by Feng, Gries and Fritz (2020) for the
data-driven  estimation of the first derivative. The recommended initial
bandwidth for the second derivative, however, is <code>0.2</code> and not
<code>0.15</code>. Thus, if the algorithm does not give suitable results
(especially for <code>d = 2</code>), the adjustment of the initial bandwidth might
be a good starting point. Analogously, the default starting bandwidth for the
trend estimation for the variance factor is <code>bStart.p = 0.15</code>, although
according to Feng, Gries and Fritz (2020), <code>bStart.p = 0.1</code> is suggested
for <code>pp = 1</code> and <code>bStart.p = 0.2</code> for <code>pp = 3</code>. The default is
therefore a compromise between the two suggested values. For more specific
information on the input arguments consult the section <em>Arguments</em>.
</p>
<p>After the bandwidth estimation, the nonparametric derivative of the series
is calculated with respect to the obtained optimal bandwidth by means of a
local polynomial regression. The output object is then a list that contains,
among other components, the original time series, the estimates of the
derivative and the estimated optimal bandwidth.
</p>
<p>The default print method for this function delivers key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>
<p>NOTE:
</p>
<p>The estimates are obtained for the rescaled time points on the interval
<code class="reqn">[0, 1]</code>. Therefore, the estimated derivatives might not reflect the
derivatives for the actual time points. To rescale them, we refer the
user to the <code>rescale</code> function of the <code>smoots</code> package.
</p>
<p>With package version 1.1.0, this function implements C++ code by means
of the <code>Rcpp</code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>b0</dt>
<dd>
<p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bStart</dt>
<dd>
<p>the starting bandwidth for the local polynomial
regression based derivative estimation procedure; input argument.</p>
</dd>
<dt>bStart.p</dt>
<dd>
<p>the starting bandwidth for the nonparametric trend estimation
that leads to the variance factor estimate; input argument.</p>
</dd>
<dt>bvc</dt>
<dd>
<p>indicates whether an enlarged bandwidth was used for the variance
factor estimation or not; it is always set to <code>"Y"</code> (yes) for this
function.</p>
</dd>
<dt>cf0</dt>
<dd>
<p>the estimated variance factor; in contrast to the definitions
given in the <em>Details</em> section, this object actually contains an
estimated value of <code class="reqn">2\pi c_f</code>, i.e. it corresponds to the estimated sum
of autocovariances.</p>
</dd>
<dt>InfR</dt>
<dd>
<p>the inflation rate setting.</p>
</dd>
<dt>iterations</dt>
<dd>
<p>the bandwidths of the single iterations steps</p>
</dd>
<dt>Mcf</dt>
<dd>
<p>the estimation method for the variance factor estimation; it is
always estimated nonparametrically (<code>"NP"</code>) within this function.</p>
</dd>
<dt>mu</dt>
<dd>
<p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt>
<dd>
<p>the number of observations.</p>
</dd>
<dt>niterations</dt>
<dd>
<p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt>
<dd>
<p>the original input series; input argument.</p>
</dd>
<dt>p</dt>
<dd>
<p>the order of polynomial for the local polynomial
regression used within derivative estimation procedure.</p>
</dd>
<dt>pp</dt>
<dd>
<p>the order of polynomial for the local polynomial
regression used in the variance factor estimation; input argument.</p>
</dd>
<dt>v</dt>
<dd>
<p>the considered order of the trend's derivative; input argument
<code>d</code>.</p>
</dd>
<dt>ws</dt>
<dd>
<p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt>
<dd>
<p>the nonparametric estimates of the derivative for the rescaled
time points on the interval <code class="reqn">[0, 1]</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul>
<li>
<p> Yuanhua Feng (Department of Economics, Paderborn University), <br>
Author of the Algorithms <br>
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li>
<p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br>
Package Creator and Maintainer
</p>
</li>
</ul>
<h3>References</h3>

<p>Feng, Y., Gries, T. and Fritz, M. (2020). Data-driven
local polynomial for the trend and its derivatives in economic time
series. Journal of Nonparametric Statistics, 32:2, 510-533.
</p>
<p>Feng, Y., Gries, T., Letmathe, S. and Schulz, D. (2019). The smoots package
in R for semiparametric modeling of trend stationary time series. Discussion
Paper. Paderborn University. Unpublished.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Logarithm of test data
test_data &lt;- gdpUS
y &lt;- log(test_data$GDP)
t &lt;- seq(from = 1947, to = 2019.25, by = 0.25)

# Applied dsmooth function for the trend's first derivative
result_d &lt;- dsmooth(y, d = 1, mu = 1, pp = 1, bStart.p = 0.1, bStart = 0.15)
estim &lt;- result_d$ye

# Plot of the results
plot(t, estim, xlab = "Year", ylab = "First derivative", type = "l",
 main = paste0("Estimated first derivative of the trend for log-quarterly ",
 "US-GDP, Q1 1947 - Q2 2019"), cex.axis = 0.8, cex.main = 0.8,
 cex.lab = 0.8, bty = "n")

# Print result
result_d
</code></pre>


</div>