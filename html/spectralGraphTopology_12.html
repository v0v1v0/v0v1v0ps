<div class="container">

<table style="width: 100%;"><tr>
<td>learn_bipartite_graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learn a bipartite graph
Learns a bipartite graph on the basis of an observed data matrix</h2>

<h3>Description</h3>

<p>Learn a bipartite graph
</p>
<p>Learns a bipartite graph on the basis of an observed data matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">learn_bipartite_graph(
  S,
  is_data_matrix = FALSE,
  z = 0,
  nu = 10000,
  alpha = 0,
  w0 = "naive",
  m = 7,
  maxiter = 10000,
  abstol = 1e-06,
  reltol = 1e-04,
  record_weights = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>either a pxp sample covariance/correlation matrix, or a pxn data
matrix, where p is the number of nodes and n is the number of
features (or data points per node)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_data_matrix</code></td>
<td>
<p>whether the matrix S should be treated as data matrix
or sample covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>the number of zero eigenvalues for the Adjancecy matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>regularization hyperparameter for the term ||A(w) - V Psi V'||^2_F</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>L1 regularization hyperparameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w0</code></td>
<td>
<p>initial estimate for the weight vector the graph or a string
selecting an appropriate method. Available methods are: "qp": finds w0 that minimizes
||ginv(S) - L(w0)||_F, w0 &gt;= 0; "naive": takes w0 as the negative of the
off-diagonal elements of the pseudo inverse, setting to 0 any elements s.t.
w0 &lt; 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>in case is_data_matrix = TRUE, then we build an affinity matrix based
on Nie et. al. 2017, where m is the maximum number of possible connections
for a given node</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>absolute tolerance on the weight vector w</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>relative tolerance on the weight vector w</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>record_weights</code></td>
<td>
<p>whether to record the edge values at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether to output a progress bar showing the evolution of the
iterations</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>laplacian</code></td>
<td>
<p>the estimated Laplacian Matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>the estimated Adjacency Matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>the estimated weight vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>optimization variable accounting for the eigenvalues of the Adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>eigenvectors of the estimated Adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed_time</code></td>
<td>
<p>elapsed time recorded at every iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj_fun</code></td>
<td>
<p>values of the objective function at every iteration in case record_objective = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negloglike</code></td>
<td>
<p>values of the negative loglikelihood at every iteration in case record_objective = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_seq</code></td>
<td>
<p>sequence of weight vectors at every iteration in case record_weights = TRUE</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ze Vinicius and Daniel Palomar
</p>


<h3>References</h3>

<p>S. Kumar, J. Ying, J. V. M. Cardoso, D. P. Palomar. A unified
framework for structured graph learning via spectral constraints.
Journal of Machine Learning Research, 2020.
http://jmlr.org/papers/v21/19-276.html
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(spectralGraphTopology)
library(igraph)
library(viridis)
library(corrplot)
set.seed(42)
n1 &lt;- 10
n2 &lt;- 6
n &lt;- n1 + n2
pc &lt;- .9
bipartite &lt;- sample_bipartite(n1, n2, type="Gnp", p = pc, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- runif(gsize(bipartite), min = 0, max = 1)
# get true Laplacian and Adjacency
Ltrue &lt;- as.matrix(laplacian_matrix(bipartite))
Atrue &lt;- diag(diag(Ltrue)) - Ltrue
# get samples
Y &lt;- MASS::mvrnorm(100 * n, rep(0, n), Sigma = MASS::ginv(Ltrue))
# compute sample covariance matrix
S &lt;- cov(Y)
# estimate Adjacency matrix
graph &lt;- learn_bipartite_graph(S, z = 4, verbose = FALSE)
graph$adjacency[graph$adjacency &lt; 1e-3] &lt;- 0
# Plot Adjacency matrices: true, noisy, and estimated
corrplot(Atrue / max(Atrue), is.corr = FALSE, method = "square",
         addgrid.col = NA, tl.pos = "n", cl.cex = 1.25)
corrplot(graph$adjacency / max(graph$adjacency), is.corr = FALSE,
         method = "square", addgrid.col = NA, tl.pos = "n", cl.cex = 1.25)
# build networks
estimated_bipartite &lt;- graph_from_adjacency_matrix(graph$adjacency,
                                                   mode = "undirected",
                                                   weighted = TRUE)
V(estimated_bipartite)$type &lt;- c(rep(0, 10), rep(1, 6))
la = layout_as_bipartite(estimated_bipartite)
colors &lt;- viridis(20, begin = 0, end = 1, direction = -1)
c_scale &lt;- colorRamp(colors)
E(estimated_bipartite)$color = apply(
  c_scale(E(estimated_bipartite)$weight / max(E(estimated_bipartite)$weight)), 1,
                          function(x) rgb(x[1]/255, x[2]/255, x[3]/255))
E(bipartite)$color = apply(c_scale(E(bipartite)$weight / max(E(bipartite)$weight)), 1,
                      function(x) rgb(x[1]/255, x[2]/255, x[3]/255))
la = la[, c(2, 1)]
# Plot networks: true and estimated
plot(bipartite, layout = la, vertex.color=c("red","black")[V(bipartite)$type + 1],
     vertex.shape = c("square", "circle")[V(bipartite)$type + 1],
     vertex.label = NA, vertex.size = 5)
plot(estimated_bipartite, layout = la,
     vertex.color=c("red","black")[V(estimated_bipartite)$type + 1],
     vertex.shape = c("square", "circle")[V(estimated_bipartite)$type + 1],
     vertex.label = NA, vertex.size = 5)
</code></pre>


</div>