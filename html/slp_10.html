<div class="container">

<table style="width: 100%;"><tr>
<td>slp.mgcv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a Basis Matrix for Discrete Prolate Spheroidal (Slepian) Sequences</h2>

<h3>Description</h3>

<p>Generate the basis matrix for a particular <code>N, W</code> Slepian sequence
family member, with the additional property that the smoother captures/passes constants
without distortion. Can be quite slow in execution due to the latter property.
</p>
<p>Based on <code>smooth.construct.cr.smooth.spec</code> for implementation 
with <code>mgcv</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'slp.smooth.spec'
smooth.construct(object,data,knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a smooth specification object, usually generated by a model term <code>s(..., bs = 'slp', ..., xt = list(...))</code>,
and for this type, <b>requiring</b> an additional <code>xt = list()</code> object containing parameters.
For examples, see below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing just the data required by this term, with names corresponding to
<code>object[['term']]</code>. Typically just a single time index array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup – should be <code>NULL</code>, as
slp basis objects are not generated from knots.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>slp</code> is based on <code>.dpss</code>, which generates a family of Discrete
Prolate Spheroidal (Slepian) Sequences. These vectors are orthonormal, have alternating
even/odd parity, and form the optimally concentrated basis set for the subspace of 
<code>R^N</code> corresponding to the bandwidth <code>W</code>. Full details are given
in Slepian (1978).  These basis functions have natural boundary conditions, and lack any form of 
knot structure. This version is returned for <code>naive = TRUE</code>.
</p>
<p>The <code>dpss</code> basis vectors can be adapted to provide the additional
useful property of capturing or passing constants perfectly. That is, the smoother matrix
<code>S</code> formed from the returned rectangular matrix will either reproduce constants
at near round-off precision, i.e., <code>S %*% rep(1, N) = rep(1, N)</code>, 
for <code>naive = FALSE</code> with <code>intercept = TRUE</code>, or will pass constants, 
i.e., <code>S %*% rep(1, N) = rep(0, N)</code>, for <code>naive = FALSE</code> with <code>intercept = FALSE</code>. 
</p>
<p>The primary use is in modeling formula to directly specify a Slepian time-based smoothing
term in a model: see the examples.
</p>
<p>For large <code>N</code> this routine can be <b>very</b> slow. If you are computing models with
large <code>N</code>, we highly recommend pre-computing the basis object, then using it
in your models without recomputation. The third example below demonstrates this approach.
</p>


<h3>Value</h3>

<p>An object of class <code>slp.smooth</code>. In addition to the usual elements of a smooth
class (see <code>smooth.construct</code>), this object will
contain:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>a constraint matrix which restricts <code>mgcv</code> from modifying the (already) 
orthogonal and mean-passing/capturing basis vectors. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>the user-specified number of basis vectors, or the computed <code>K</code> from
user-supplied <code>W</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>the user-specified bandwidth <code>W</code>, or the computed <code>W</code> from
user-supplied <code>K</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullBasis</code></td>
<td>
<p>the full-span computed, normalized basis set, before contiguity is
taken into account. Used by <code>predict</code> 
when given an object of type <code>slp.smooth</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contiguous</code></td>
<td>
<p>a logical variable declaring whether or not the input time array
was considered to be contiguous by the basis computation procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wx</code></td>
<td>
<p>the “corrected” input time array; if <code>contiguous == FALSE</code> then 
this will be the same as <code>data[object[['term']]]</code>. </p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with 
R. Chapman and Hall/CRC Press.
</p>
<p>Hastie T.J. &amp; Tibshirani, R.J. (1990) Generalized Additive Models.
Chapman and Hall.
</p>
<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>.
Volume <b>70</b>, number 9, pp. 1055-1096.
</p>
<p>Slepian, David (1978)
Prolate Spheroidal Wave Functions, Fourier Analysis, and Uncertainty V: the Discrete Case.
<em>Bell System Technical Journal</em>. Volume <b>57</b>, pp. 1371-1429.
</p>


<h3>See Also</h3>

<p><code>smooth.construct</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # Examples using pkg:mgcv
    library("mgcv")
    library("slp")

    N &lt;- 730
    W &lt;- 8 / N
    K &lt;- 16         # will actually use 15 df as intercept = FALSE
    x &lt;- rnorm(n = N, sd = 1)
    y &lt;- x + rnorm(n = N, sd = 2) + 5.0
    t &lt;- seq(1, N)    

    # note: all three examples share identical results

    # example with in-call computation, using K (df)
    fit1 &lt;- gam(y ~ x + s(t, bs = 'slp', xt = list(K = K)), family = gaussian) 

    # example with in-call computation, using W
    fit2 &lt;- gam(y ~ x + s(t, bs = 'slp', xt = list(W = W)), family = gaussian)

</code></pre>


</div>