<div class="container">

<table style="width: 100%;"><tr>
<td>msmooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data-driven Nonparametric Regression for the Trend in Equidistant Time
Series</h2>

<h3>Description</h3>

<p>This function runs an iterative plug-in algorithm to find the optimal
bandwidth for the estimation of the nonparametric trend in equidistant
time series (with short memory errors) and then employs the resulting
bandwidth via either local polynomial or kernel regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">msmooth(
  y,
  p = c(1, 3),
  mu = c(0, 1, 2, 3),
  bStart = 0.15,
  alg = c("A", "B", "N", "NA", "NAM", "NM", "O", "OA", "OAM", "OM"),
  method = c("lpr", "kr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector that contains the input time series ordered from
past to present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression); represents the order of polynomial within the local
polynomial regression (see also the 'Details' section); is set to <code>1</code>
by default; is automatically set to <code>1</code> if <code>method = "kr"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set
to <code>1</code> by default.
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Number</strong> </td>
<td style="text-align: left;"> <strong>Kernel</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>0</code> </td>
<td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>1</code> </td>
<td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>2</code> </td>
<td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
<td style="text-align: center;">
<code>3</code> </td>
<td style="text-align: left;"> Triweight Kernel
</td>
</tr>
</table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bStart</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process; should be <code class="reqn">&gt; 0</code>; is set to
<code>0.15</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg</code></td>
<td>
<p>a control parameter (as character) that indicates the
corresponding algorithm used (set to <code>"A"</code> by default for <code>p = 1</code>
and to <code>"B"</code> for <code>p = 3</code>).
</p>

<table>
<tr>
<td style="text-align: center;">
<strong>Algorithm</strong> </td>
<td style="text-align: left;"> <strong>Description</strong>
</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"A"</code> </td>
<td style="text-align: left;"> Nonparametric estimation of the variance factor with an
enlarged bandwidth, optimal inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"B"</code> </td>
<td style="text-align: left;"> Nonparametric estimation of the variance factor with an
enlarged bandwidth, naive inflation rate </td>
</tr>
<tr>
<td style="text-align: center;">
<code>"O"</code> </td>
<td style="text-align: left;"> Nonparametric estimation of the variance factor, optimal
inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"N"</code> </td>
<td style="text-align: left;"> Nonparametric estimation of the variance factor, naive
inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"OAM"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
ARMA(<code class="reqn">p,q</code>)-models, optimal inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"NAM"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
ARMA(<code class="reqn">p,q</code>)-models, naive inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"OA"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
AR(<code class="reqn">p</code>)-models, optimal inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"NA"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
AR(<code class="reqn">p</code>)-models, naive inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"OM"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
MA(<code class="reqn">q</code>)-models, optimal inflation rate</td>
</tr>
<tr>
<td style="text-align: center;">
<code>"NM"</code> </td>
<td style="text-align: left;"> Estimation of the variance factor with
MA(<code class="reqn">q</code>)-models, naive inflation rate
</td>
</tr>
</table>
<p>It is proposed to use <code>alg = "A"</code> in combination with <code>p = 1</code>.
If the user finds that the chosen bandwidth by algorithm <code>"A"</code> is too
small, <code>alg = "B"</code> with preferably <code>p = 3</code> is suggested. For more
information on the components of the different algorithms, please consult
<code>tsmooth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the smoothing approach; <code>"lpr"</code> represents the local
polynomial regression, whereas <code>"kr"</code> implements a kernel regression;
is set to <code>"lpr"</code> by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and short-range dependence (see also Beran and Feng,
2002). With this function <code class="reqn">m(x_t)</code> can be estimated without a parametric
model assumption for the error series. Thus, after estimating and removing
the trend, any suitable parametric model, e.g. an ARMA(<code class="reqn">p,q</code>) model, can
be fitted to the residuals (see <code>arima</code>).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), was proposed by Feng, Gries
and Fritz (2020).
</p>
<p>Define <code class="reqn">I[m^{(k)}] = \int_{c_b}^{d_b} [m^{(k)}(x)]^2 dx</code>, <code class="reqn">\beta_{(\nu, k)} = \int_{-1}^{1} u^k
K_{(\nu, k)}(u) du</code>
and <code class="reqn">R(K) = \int_{-1}^{1} K_{(\nu, k)}^{2}(u) du</code>, where <code class="reqn">p</code> is the order of the polynomial,
<code class="reqn">k = p + 1</code> is the order of the asymptotically equivalent kernel,
<code class="reqn">\nu</code> is the order of the trend function's derivative, <code class="reqn">0 \leq c_{b}
&lt; d_{b} \leq 1</code>, <code class="reqn">c_f</code> is the variance factor and
<code class="reqn">K_{(\nu, k)}(u)</code> the <code class="reqn">k</code>-th order equivalent kernel
obtained for the estimation of <code class="reqn">m^{(\nu)}</code> in the interior.
<code class="reqn">m^{(\nu)}</code> is the <code class="reqn">\nu</code>-th order derivative (<code class="reqn">\nu = 0,
1, 2, ...</code>) of the nonparametric trend.
</p>
<p>Furthermore, we define
</p>
<p style="text-align: center;"><code class="reqn">C_{1} = \frac{I[m^{(k)}] \beta_{(\nu, k)}^2}{(k!)^2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">C_{2} = \frac{2 \pi c_{f} (d_b - c_b) R(K)}{nh^{2 \nu + 1}}</code>
</p>

<p>with <code class="reqn">h</code> being the bandwidth and <code class="reqn">n</code> being the number of
observations. The AMISE is then
</p>
<p style="text-align: center;"><code class="reqn">AMISE(h) = h^{2(k-\nu)}C_{1} + C_{2}.</code>
</p>

<p>The function calculates suitable estimates for <code class="reqn">c_f</code>, the variance
factor, and <code class="reqn">I[m^{(k)}]</code> over different iterations. In each
iteration, a bandwidth is obtained in accordance with the AMISE that once
more serves as an input for the following iteration. The process repeats
until either convergence or the 40th iteration is reached. For further
details on the asymptotic theory or the algorithm, please consult Feng,
Gries and Fritz (2020) or Feng et al. (2019).
</p>
<p>To apply the function, only few arguments are needed: a data input <code>y</code>,
an order of polynomial <code>p</code>, a kernel function defined by the smoothness
parameter <code>mu</code>, a starting value for the relative bandwidth
<code>bStart</code> and a final smoothing method <code>method</code>.
In fact, aside from the input vector <code>y</code>, every argument has a default
setting that can be adjusted for the individual case. It is recommended to
initially use the default values for <code>p</code>, <code>alg</code> and
<code>bStart</code> and adjust them in the rare case of the resulting optimal
bandwidth being either too small or too large. Theoretically, the
initial bandwidth does not affect the selected optimal bandwidth. However, in
practice local minima of the AMISE might exist and influence the selected
bandwidth. Therefore, the default setting is <code>bStart = 0.15</code>, which is a
compromise between the starting values <code>bStart = 0.1</code> for <code>p = 1</code>
and <code>bStart = 0.2</code> for <code>p = 3</code> that were proposed by Feng, Gries
and Fritz (2020). In the rare case of a clearly unsuitable optimal bandwidth,
a starting bandwidth that differs from the default value is a first
possible approach to obtain a better result. Other argument adjustments can
be tried as well. For more specific information on the input arguments
consult the section <em>Arguments</em>.
</p>
<p>When applying the function, an optimal bandwidth is obtained based on the
IPI algorithm proposed by Feng, Gries and Fritz (2020). In a second step,
the nonparametric trend of the series is calculated with respect
to the chosen bandwidth and the selected regression method (<code>lpf</code> or
<code>kr</code>). It is notable that <code>p</code> is automatically set to 1 for
<code>method = "kr"</code>. The output object is then a list that contains, among
other components, the original time series, the estimated trend values and
the series without the trend.
</p>
<p>The default print method for this function delivers key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>
<p>NOTE:
</p>
<p>With package version 1.1.0, this function implements C++ code by means
of the <code>Rcpp</code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>AR.BIC</dt>
<dd>
<p>the Bayesian Information Criterion of the optimal AR(<code class="reqn">p</code>)
model when estimating the variance factor via autoregressive models
(if calculated; calculated for <code>alg = "OA"</code> and <code>alg = "NA"</code>).</p>
</dd>
<dt>ARMA.BIC</dt>
<dd>
<p>the Bayesian Information Criterion of the optimal
ARMA(<code class="reqn">p,q</code>) model when estimating the variance factor via
autoregressive-moving-average models (if calculated; calculated for
<code>alg = "OAM"</code> and <code>alg = "NAM"</code>).</p>
</dd>
<dt>cb</dt>
<dd>
<p>the percentage of omitted observations on each side of the
observation period; always equal to 0.05.</p>
</dd>
<dt>b0</dt>
<dd>
<p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bb</dt>
<dd>
<p>the boundary bandwidth method used within the IPI; always equal to
1.</p>
</dd>
<dt>bStart</dt>
<dd>
<p>the starting value of the (relative) bandwidth; input
argument.</p>
</dd>
<dt>bvc</dt>
<dd>
<p>indicates whether an enlarged bandwidth was used for the variance
factor estimation or not; depends on the chosen algorithm.</p>
</dd>
<dt>cf0</dt>
<dd>
<p>the estimated variance factor; in contrast to the definitions
given in the <em>Details</em> section, this object actually contains an
estimated value of <code class="reqn">2\pi c_f</code>, i.e. it corresponds to the estimated sum
of autocovariances.</p>
</dd>
<dt>cf0.AR</dt>
<dd>
<p>the estimated variance factor obtained by estimation of
autoregressive models (if calculated; <code>alg = "OA"</code> or <code>"NA"</code>).</p>
</dd>
<dt>cf0.ARMA</dt>
<dd>
<p>the estimated variance factor obtained by estimation of
autoregressive-moving-average models (if calculated; calculated for
<code>alg = "OAM"</code> and <code>alg = "NAM"</code>).</p>
</dd>
<dt>cf0.LW</dt>
<dd>
<p>the estimated variance factor obtained by Lag-Window Spectral
Density Estimation following Bühlmann (1996) (if calculated; calculated for
algorithms <code>"A"</code>, <code>"B"</code>, <code>"O"</code> and <code>"N"</code>).</p>
</dd>
<dt>cf0.MA</dt>
<dd>
<p>the estimated variance factor obtained by estimation of
moving-average models (if calculated; calculated for <code>alg = "OM"</code> and
<code>alg = "NM"</code>).</p>
</dd>
<dt>I2</dt>
<dd>
<p>the estimated value of <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt>InfR</dt>
<dd>
<p>the setting for the inflation rate according to the chosen
algorithm.</p>
</dd>
<dt>iterations</dt>
<dd>
<p>the bandwidths of the single iterations steps</p>
</dd>
<dt>L0.opt</dt>
<dd>
<p>the optimal bandwidth for the lag-window spectral density
estimation (if calculated; calculated for algorithms <code>"A"</code>, <code>"B"</code>,
<code>"O"</code> and <code>"N"</code>).</p>
</dd>
<dt>MA.BIC</dt>
<dd>
<p>the Bayesian Information Criterion of the optimal MA(<code class="reqn">q</code>)
model when estimating the variance factor via moving-average models (if
calculated; calculated for <code>alg = "OM"</code> and <code>alg = "NM"</code>).</p>
</dd>
<dt>Mcf</dt>
<dd>
<p>the estimation method for the variance factor estimation; depends
on the chosen algorithm.</p>
</dd>
<dt>mu</dt>
<dd>
<p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt>
<dd>
<p>the number of observations.</p>
</dd>
<dt>niterations</dt>
<dd>
<p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt>
<dd>
<p>the original input series; input argument.</p>
</dd>
<dt>p.BIC</dt>
<dd>
<p>the order p of the optimal AR(<code class="reqn">p</code>) or ARMA(<code class="reqn">p,q</code>) model
when estimating the variance factor via autoregressive or
autoregressive-moving average models (if calculated; calculated for
<code>alg = "OA"</code>, <code>alg = "NA"</code>, <code>alg = "OAM"</code> and
<code>alg = "NAM"</code>).</p>
</dd>
<dt>p</dt>
<dd>
<p>the order of polynomial used in the IPI-algorithm; also used for the
final smoothing, if <code>method = "lpr"</code>; input argument.</p>
</dd>
<dt>q.BIC</dt>
<dd>
<p>the order <code class="reqn">q</code> of the optimal MA(<code class="reqn">q</code>) or ARMA(<code class="reqn">p,q</code>)
model when estimating the variance factor via moving-average or
autoregressive-moving average models (if calculated; calculated for
<code>alg = "OM"</code>,
<code>alg = "NM"</code>, <code>alg = "OAM"</code> and <code>alg = "NAM"</code>).</p>
</dd>
<dt>res</dt>
<dd>
<p>the estimated residual series.</p>
</dd>
<dt>v</dt>
<dd>
<p>the considered order of derivative of the trend; is always zero for
this function.</p>
</dd>
<dt>ws</dt>
<dd>
<p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt>
<dd>
<p>the nonparametric estimates of the trend.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul>
<li>
<p> Yuanhua Feng (Department of Economics, Paderborn University), <br>
Author of the Algorithms <br>
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li>
<p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br>
Package Creator and Maintainer
</p>
</li>
</ul>
<h3>References</h3>

<p>Beran, J. and Feng, Y. (2002). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Bühlmann, P. (1996). Locally adaptive lag-window spectral estimation.
Journal of Time Series Analysis, 17(3), 247-270.
</p>
<p>Feng, Y., Gries, T. and Fritz, M. (2020). Data-driven
local polynomial for the trend and its derivatives in economic time
series. Journal of Nonparametric Statistics, 32:2, 510-533.
</p>
<p>Feng, Y., Gries, T., Letmathe, S. and Schulz, D. (2019). The smoots package
in R for semiparametric modeling of trend stationary time series. Discussion
Paper. Paderborn University. Unpublished.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example 1: US-GDP ###

# Logarithm of test data
# -&gt; the logarithm of the data is assumed to follow the additive model
test_data &lt;- gdpUS
y &lt;- log(test_data$GDP)

# Applied msmooth function for the trend
results &lt;- msmooth(y, p = 1, mu = 1, bStart = 0.1, alg = "A", method = "lpr")
res &lt;- results$res
ye &lt;- results$ye

# Plot of the results
t &lt;- seq(from = 1947, to = 2019.25, by = 0.25)
matplot(t, cbind(y, ye), type = "ll", lty = c(3, 1), col = c(1, "red"),
 xlab = "Years", ylab = "Log-Quartlery US-GDP",
 main = "Log-Quarterly US-GDP vs. Trend, Q1 1947 - Q2 2019")
legend("bottomright", legend = c("Original series", "Estimated trend"),
 fill = c(1, "red"), cex = 0.7)
results

## Not run: 
### Example 2: German Stock Index ###

# The following procedure can be considered, if (log-)returns are assumed
# to follow a model from the general class of semiparametric GARCH-type
# models (including Semi-GARCH, Semi-Log-GARCH and Semi-APARCH models among
# others) with a slowly changing variance over time due to a deterministic,
# nonparametric scale function.

# Obtain the logarithm of the squared returns
returns &lt;- diff(log(dax$Close))   # (log-)returns
rt &lt;- returns - mean(returns)     # demeaned (log-)returns
yt &lt;- log(rt^2)                   # logarithm of the squared returns

# Apply 'smoots' function to the log-data, because the logarithm of
# the squared returns follows an additive model with a nonparametric trend
# function, if the returns are assumed to follow a semiparametric GARCH-type
# model.

# In this case, the setting 'alg = "A"' is used in combination with p = 3, as
# the resulting estimates appear to be more suitable than for 'alg = "B"'.
est &lt;- msmooth(yt, p = 3, alg = "A")
m_xt &lt;- est$ye                    # estimated trend values

# Obtain the standardized returns 'eps' and the scale function 'scale.f'
res &lt;- est$res                    # the detrended log-data
C &lt;- -log(mean(exp(res)))         # an estimate of a constant value needed
                                  # for the retransformation
scale.f &lt;- exp((m_xt - C) / 2)    # estimated values of the scale function in
                                  # the returns
eps &lt;- rt / scale.f               # the estimated standardized returns

# -&gt; 'eps' can now be analyzed by any suitable GARCH-type model.
#    The total volatilities are then the product of the conditional
#    volatilities obtained from 'eps' and the scale function 'scale.f'.

## End(Not run)
</code></pre>


</div>