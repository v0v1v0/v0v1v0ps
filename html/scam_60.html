<div class="container">

<table style="width: 100%;"><tr>
<td>scam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shape constrained additive models (SCAM) and integrated smoothness selection</h2>

<h3>Description</h3>

<p>This function fits a SCAM to data. Various shape constrained smooths (SCOP-splines), including univariate smooths subject to monotonicity, convexity, or monotonicity plus convexity, bivariate smooths with double or single monotonicity  are available as model terms. See <code>shape.constrained.smooth.terms</code> for a complete overview of what is available. Smoothness selection is estimated as part of the fitting. Confidence/credible intervals are available for each smooth term.    
</p>
<p>The shaped constrained smooths have been added to the <code>gam()</code> in package <code>mgcv</code> setup using the <code>smooth.construct</code> function.  The routine calls a <code>gam()</code> function for the model set up, but there are separate functions for the model fitting, <code>scam.fit</code>, and smoothing parameter selection, <code>bfgs_gcv.ubre</code>. Any smooth available in the <code>mgcv</code> can be taken as a model term for SCAM. User-defined smooths can be included as well.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scam(formula, family = gaussian(), data = list(), gamma = 1, 
      sp = NULL, weights = NULL, offset = NULL,optimizer=c("bfgs","newton"), 
      optim.method=c("Nelder-Mead","fd"),scale = 0, knots=NULL,
      not.exp=FALSE, start= NULL, etastart=NULL,mustart= NULL,
      control=list(),AR1.rho=0, AR.start=NULL,drop.unused.levels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A SCAM formula.  
This is exactly like the formula for a GAM (see <code>formula.gam</code> of the <code>mgcv</code> library) except that shape constrained smooth terms,
can be added in the expression of the form, e.g., 
<code>s(x1,k=12,bs="mpi",by=z),</code>  where <code>bs</code> indicates the basis to use for the constrained smooth (increasing in this case): 
the built in options for the shape constrained smooths are described in <br><code>shape.constrained.smooth.terms</code>, 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A family object specifying the distribution and link to use in
fitting etc. See <code>glm</code> and <code>family</code> for more
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from 
<code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>A constant multiplier to inflate the model degrees of freedom in the GCV or UBRE/AIC score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p>A vector of smoothing parameters can be provided here. Smoothing parameters must be supplied in the order that 
the smooth terms appear in the model formula. The default <code>sp=NULL</code> indicates that smoothing parameters should be estimated.
If <code>length(sp)</code> does not correspond to the number of underlying smoothing parameters or negative values supplied then
the vector is ignored and all the smoothing parameters will be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Prior weights on the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Used to supply a model offset for use in fitting. Note that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code>. This conforms to the behaviour of <code>lm</code>, <code>glm</code> and <code>gam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>An array specifying the numerical optimization methods 
to optimize the smoothing parameter estimation criterion (specified in the first 
element  of <code>optimizer</code>) and to use to estimate the model coefficients
(specified in the second element of <code>optimizer</code>). For the model coefficients
estimation there are two alternatives: "newton" (default) and "bfgs" methods.
For the smoothing parameter selection the available methods are "bfgs" (default)
for the built in to <code>scam</code> package routine <code>bfgs_gcv.ubre</code>, "optim", "nlm", 
"nlm.fd" (based on finite-difference approximation of the derivatives), "efs". 
"efs" for the extended Fellner Schall method of Wood and Fasiolo (2017) 
(rather than minimizing REML as in <code>gam(mgcv)</code> this minimizes the GCV/UBRE criterion)
Note that 'bfgs' method for the coefficient estimation works only with 'efs'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>In case of <code>optimizer="optim"</code> this specifies the numerical method to be used in <code>optim</code>
in the first element, the second element of <code>optim.method</code> indicates whether the finite difference
approximation should be used ("fd") or analytical gradient ("grad"). The default is <code>optim.method=c("Nelder-Mead","fd")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If this is positive then it is taken as the known scale parameter of the exponential family distribution.
Negative value indicates that the scale paraemter is unknown. 0 indicates that the scale parameter is 1  for Poisson and binomial
and unknown otherwise. This conforms to the behaviour of <code>gam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>An optional list containing user specified knot values to be used for basis construction. Different terms can use different numbers of knots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>not.exp</code></td>
<td>
<p>if <code>TRUE</code> then <code>notExp(x,b,threshold)</code> re-parameterization function will be used in place of <code>exp()</code> (default value) to ensure positivity in the model coefficients (scop-splines coefficients). <code>notExp()</code> is a softplus function, <code>1/b*log(1+exp(b*x)</code>, as implemented in PyTorch, it reverts to the linear function when x*b &gt; threshold, for numerical stability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Initial values for the model coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>Initial values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>Initial values for the expected values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of fit control parameters to replace defaults returned by <code>scam.control</code>.
Values not set assume default values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR1.rho</code></td>
<td>
<p>The AR1 correlation parameter. An AR1 error model can be used for the residuals of Gaussian-identity link models. Standardized residuals (approximately uncorrelated under correct model) returned in
<code>std.rsd</code> if non-zero. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR.start</code></td>
<td>
<p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> (default) then there are no breaks in AR1 correlaion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.unused.levels</code></td>
<td>
<p>as with <code>gam</code> by default unused levels are dropped from factors before fitting.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A shape constrained additive model (SCAM) is a generalized linear model (GLM) 
in which the linear predictor is given by strictly parametric components plus a sum of smooth functions of the covariates where
some of the functions are assumed to be shape constrained. For example,
</p>
<p style="text-align: center;"><code class="reqn">\log(E(Y_i)) = X_i^*b+f_1(x_{1i})+m_2(x_{2i})+f_3(x_{3i})</code>
</p>

<p>where the independent response variables <code class="reqn">Y_i</code> follow Poisson distribution with <code>log</code> link function,
<code class="reqn">f_1</code>, <code class="reqn">m_2</code>, and <code class="reqn">f_3</code> are smooth functions of the corresponding covariates, and <code class="reqn">m_2</code> 
is subject to monotone increasing constraint.  
</p>
<p>Available shape constrained smooths are decsribed in <code>shape.constrained.smooth.terms</code>.
</p>
<p>Residual auto-correlation with a simple AR1 correlation structure can be dealt with, for Gaussian models with identity link. Currently, the AR1 correlation parameter should be supplied (rather than estimated) in <code>AR1.rho</code>. <code>AR.start</code> input argument (logical) allows to set independent sections of AR1 correlation. Standardized residuals (approximately uncorrelated under correct model) are returned in <code>std.rsd</code> if <code>AR1.rho</code> is non zero. Use <code>acf(model$std.rsd)</code> for computing and plotting estimates of the autocorrelation function to check correlation.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>"scam"</code> with the following elements (this agrees with <code>gamObject</code>):
</p>
<table>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>AIC of the fitted model: the degrees of freedom used to calculate this are the effective degrees of freedom of the model, and the likelihood is evaluated at the maximum of the penalized likelihood, not at the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assign</code></td>
<td>
<p>Array whose elements indicate which model term (listed in
<code>pterms</code>) each parameter relates to: applies only to non-smooth terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bfgs.info</code></td>
<td>
<p>If <code>optimizer[1]="bfgs"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of the BFGS taken to get convergence; <code>grad</code>, the gradient of the GCV/UBRE score at 
convergence; <code>score.hist</code>, the succesive values of the score up until convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the coefficients of the fitted model. Parametric
coefficients are  first, followed  by coefficients for each
spline term in turn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients.t</code></td>
<td>
<p>the parametrized coefficients of the fitted model (exponentiated for the monotonic smooths).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>indicates whether or not the iterative fitting method converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CPU.time</code></td>
<td>
<p>indicates the real and CPU time (in seconds) taken by the fitting process in case of unknown smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the original supplied data argument. Only included if the <code>scam</code> argument
<code>keepData</code> is set to <code>TRUE</code> (default is <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>model deviance (not penalized deviance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.null</code></td>
<td>
<p>null degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>effective residual degrees of freedom of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>estimated degrees of freedom for each model parameter. Penalization
means that many of these are less than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf1</code></td>
<td>
<p>alternative estimate of edf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>efs.info</code></td>
<td>
<p>If <code>optimizer[1]="efs"</code>, a list of convergence diagnostics relating to the extended Fellner Schall method fot smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the efs algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of the efs taken to get convergence; <code>score.hist</code>, the succesive values of the score up until convergence. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>family object specifying distribution and link used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>fitted model predictions of expected value for each
datum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcv.ubre</code></td>
<td>
<p>the minimized GCV or UBRE score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dgcv.ubre</code></td>
<td>
<p>the gradient of the GCV or UBRE score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations of the Newton-Raphson method taken to get convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>fitted model prediction of link function of
expected value for  each datum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>"GCV"</code> or <code>"UBRE"</code>, depending on the fitting criterion used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.edf</code></td>
<td>
<p>Minimum possible degrees of freedom for whole model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model frame containing all variables needed in original model fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlm.info</code></td>
<td>
<p>If <code>optimizer[1]="nlm"</code> or <code>optimizer[1]="nlm.fd"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of
BFGS taken to get convergence; <code>grad</code>, the gradient of the GCV/UBRE score at 
convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>not.exp</code></td>
<td>
<p>if <code>TRUE</code> then <code>notExp()</code> function will be used in place of <code>exp</code> (default value) in positivity ensuring model parameters re-parameterization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsdf</code></td>
<td>
<p>number of parametric, non-smooth, model terms including the
intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null.deviance</code></td>
<td>
<p>deviance for single parameter model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>model offset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.info</code></td>
<td>
<p>If <code>optimizer[1]="optim"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of
BFGS taken to get convergence; <code>optim.method</code>, the numerical optimization method used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.weights</code></td>
<td>
<p>prior weights on observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pterms</code></td>
<td>
<p><code>terms</code> object for strictly parametric part of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Factor R from QR decomposition of weighted model matrix, unpivoted to be in same column order as model matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the working residuals for the fitted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.estimated</code></td>
<td>
<p><code>TRUE</code> if the scale parameter was estimated, <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig2</code></td>
<td>
<p>estimated or supplied variance/scale parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>list of smooth objects, containing the basis information for each term in the 
model formula in the order in which they appear. These smooth objects are returned by
the <code>smooth.construct</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p>estimated smoothing parameters for the model. These are the underlying smoothing
parameters, subject to optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.rsd</code></td>
<td>
<p>Standardized residuals (approximately uncorrelated under correct model) if <code>AR1.rho</code> non zero </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>termcode</code></td>
<td>
<p>an integer indicating why the optimization process of the smoothness selection
terminated (see <code>bfgs_gcv.ubre</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p><code>terms</code> object of <code>model</code> model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trA</code></td>
<td>
<p>trace of the influence matrix, total number of the estimated degrees of freedom (<code>sum(edf)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.summary</code></td>
<td>
<p>A named list of summary information on the predictor variables. See <code>gamObject</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ve</code></td>
<td>
<p>frequentist estimated covariance matrix for the parameter
estimators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vp</code></td>
<td>
<p>estimated covariance matrix for the parameters. This is a Bayesian
posterior covariance matrix that results from adopting a particular Bayesian
model of the smoothing process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ve.t</code></td>
<td>
<p>frequentist estimated covariance matrix for the reparametrized parameter
estimators obtained using the delta method. Particularly useful for testing whether terms are zero. Not so
useful for CI's as smooths are usually biased.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vp.t</code></td>
<td>
<p>estimated covariance matrix for the reparametrized parameters obtained using the delta method. 
Paricularly useful for creating credible/confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>final weights used in the Newton-Raphson iteration.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>cmX</code></td>
<td>
<p>column means of the model matrix (with elements corresponding to smooths set to zero).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>contrasts associated with a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>levels of a factor variable used in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response data.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based partly on <code>mgcv</code> by Simon Wood
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press
</p>
<p>Wood, S.N. (2006) On confidence intervals for generalized additive models based on penalized regression splines. Australian and New Zealand Journal of Statistics. 48(4): 445-464.
</p>
<p>Wood, S.N. and M. Fasiolo (2017) A generalized Fellner-Schall method for smoothing
parameter optimization with application to Tweedie location, scale and shape models.
Biometrics 73 (4), 1071-1081
</p>


<h3>See Also</h3>

<p><code>scam-package</code>, <code>shape.constrained.smooth.terms</code>, 
<code>gam</code>, <code>s</code>,
<code>plot.scam</code>, <code>summary.scam</code>, <code>scam.check</code>, <code>predict.scam</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##=============================
## Gaussian model, two smooth terms: unconstrained and increasing...
 ## simulating data...
require(scam)
set.seed(4)
n &lt;- 200
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
y &lt;- f1+f2 +rnorm(n)*.5
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi"),data=dat)
b
summary(b)
plot(b,pages=1,shade=TRUE)

##===============================
## Gaussian model, two smooth terms: increasing and mixed (decreasing and convex)...
 ## simulating data...
set.seed(4)
n &lt;- 200
x1 &lt;- runif(n)*4-1;
f1 &lt;- exp(4*x1)/(1+exp(4*x1)) # increasing smooth
x2 &lt;- runif(n)*3-1;
f2 &lt;- exp(-3*x2)/15  # decreasing and convex smooth
y &lt;- f1+f2 + rnorm(n)*.4
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
  ## fit model, results, and plot...
b &lt;- scam(y~ s(x1,bs="mpi")+s(x2, bs="mdcx"),data=dat)
summary(b)
plot(b,pages=1,scale=0,shade=TRUE)

##=================================
## Not run: 
## using the extended Fellner-Schall method for smoothing parameter selection...
b0 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="efs")
summary(b0)

## using the extended Fellner-Schall method for smoothing parameter selection, 
## and BFGS for model coefficient estimation...
b0 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer=c("efs","bfgs"))
summary(b0)

## using optim() for smoothing parameter selection...
b1 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="optim")
summary(b1)

b2 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="optim",
           optim.method=c("BFGS","fd"))
summary(b2)

## using nlm()...
b3 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="nlm")
summary(b3)

## End(Not run)

##===================================
## Poisson model ....
 ## simulating data...
set.seed(2)
n &lt;- 200
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
f &lt;- f1+f2
y &lt;- rpois(n,exp(f))
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
  ## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi"),
      family=poisson(link="log"),data=dat,optimizer=c("efs","bfgs"))
summary(b)
plot(b,pages=1,shade=TRUE)
scam.check(b)


## Gamma model...
   ## simulating data...
set.seed(6)
n &lt;- 300
x1 &lt;- runif(n)*6-3
f1 &lt;- 1.5*sin(1.5*x1) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- 1.5/(1+exp(-10*(x2+.75)))+1.5/(1+exp(-5*(x2-.75))) # increasing smooth
x3 &lt;- runif(n)*6-3;
f3 &lt;- 3*exp(-x3^2)  # unconstrained term
f &lt;- f1+f2+f3
y &lt;- rgamma(n,shape=1,scale=exp(f))
dat &lt;- data.frame(x1=x1,x2=x2,x3=x3,y=y)
   ## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="ps")+s(x2,k=15,bs="mpi")+s(x3,bs="ps"),
          family=Gamma(link="log"),data=dat,optimizer=c("efs","bfgs"))
b
summary(b)
par(mfrow=c(2,2))
plot(b,shade=TRUE)

## Not run: 
## bivariate example...
 ## simulating data...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))+2*sin(pi*x2[j])}
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model  and plot ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs=c("tesmd1","ps")),data=dat,optimizer="efs")
   summary(b)
   old.par &lt;- par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data",pch=".",cex=3)
   par(old.par)

## example with random effect smoother...
   set.seed(2)
   n &lt;- 200
   x1 &lt;- runif(n)*6-3
   f1 &lt;- 3*exp(-x1^2) # unconstrained term
   x2 &lt;- runif(n)*4-1;
   f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # increasing smooth
   f &lt;- f1+f2
   a &lt;- factor(sample(1:10,200,replace=TRUE))   
   Xa &lt;- model.matrix(~a-1)    # random main effects
   y &lt;- f + Xa%*%rnorm(length(levels(a)))*.5 + rnorm(n)*.4    
   dat &lt;- data.frame(x1=x1,x2=x2,y=y,a=a)
   ## fit model and plot...
   b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi")+s(a,bs="re"), data=dat)
   summary(b)
   scam.check(b)
   plot(b,pages=1,shade=TRUE)

## example with AR1 errors...
set.seed(8)
n &lt;- 500
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # increasing smooth
f &lt;- f1+f2
e &lt;- rnorm(n,0,sd=2)
for (i in 2:n) e[i] &lt;- .6*e[i-1] + e[i]
y &lt;- f + e
dat &lt;- data.frame(x1=x1,x2=x2,y=y)  
b &lt;- scam(y~s(x1,bs="cr")+s(x2,k=25,bs="mpi"),
            data=dat, AR1.rho=.6, optimizer="efs")
b
## Raw residuals still show correlation...
acf(residuals(b)) 
## But standardized are now fine...
x11()
acf(b$std.rsd)
 
## End(Not run)
</code></pre>


</div>