<div class="container">

<table style="width: 100%;"><tr>
<td>mspeNERlin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute MSPE through linearization method for Nested error regression model
</h2>

<h3>Description</h3>

<p>This function returns MSPE estimator with linearization method for Nested error regression model. These include the seminal Prasad-Rao method and its generalizations by Datta-Lahiri. All these methods are developed for general linear mixed effects models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mspeNERlin(ni, X, Y, X.mean, method = "PR", var.method = "default")

mspeNERPR(ni, X, Y, X.mean, var.method = "default")

mspeNERDL(ni, X, Y, X.mean, var.method = "default")

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ni</code></td>
<td>

<p>(vector). It represents the sample number for every small area.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>(matrix). Stands for the available auxiliary values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>(vector). It represents the response value for Nested error regression model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.mean</code></td>
<td>

<p>(matrix). Stands for the population mean of auxiliary values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The MSPE estimation method to be used. See "Details".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.method</code></td>
<td>

<p>The variance component estimation method to be used. See "Details".
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Default <code>method</code> for <code>mspeNERlin</code> is "PR" ,proposed by N. G. N. Prasad and J. N. K. Rao, Prasad-Rao (PR) method uses Taylor series expansion to obtain a second-order approximation to the MSPE. Function <code>mspeNERlin</code> also provide the following method:
</p>
<p>Method "DL" advanced PR method to cover the cases when the variance components are estimated by ML and REML estimator. Set <code>method = "DL"</code>.
</p>
<p>For <code>method = "PR"</code>, <code>var.method = "MOM"</code> is the only available variance component estimation method,
</p>
<p>For <code>method = "DL"</code>, <code>var.method = "ML"</code> or <code>var.method = "REML"</code> are available.
</p>


<h3>Value</h3>

<p>This function returns a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>MSPE</code></td>
<td>
<p>(vector) MSPE estimates for NER model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bhat</code></td>
<td>
<p>(vector) Estimates of the unknown regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigvhat2</code></td>
<td>
<p>(numeric) Estimates of the area-specific variance component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigehat2</code></td>
<td>
<p>(numeric) Estimates of the random error variance component.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Peiwen Xiao, Xiaohui Liu, Yuzi Liu, Jiming Jiang, and Shaochu Liu
</p>


<h3>References</h3>

<p>N. G. N. Prasad and J. N. K. Rao. The estimation of the mean squared error of small-area estimators. <em>Journal of the American Statistical Association</em>, 85(409):163-171, 1990.
</p>
<p>G. S. Datta and P. Lahiri. A unified measure of uncertainty of estimated best linear unbiased predictors in small area estimation problems. <em>Statistica Sinica</em>, 10(2):613-627, 2000.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### parameter setting 
Ni = 1000; sigmaX = 1.5; K = 100; C = 50; m = 10
beta = c(0.5, 1)
sigma_v2 = 0.8; sigma_e2 = 1
ni = sample(seq(1,10), m,replace = TRUE); n = sum(ni)
p = length(beta)
### population function
pop.model = function(Ni, sigmaX, beta, sigma_v2, sigma_e2, m){
  x = rnorm(m * Ni, 1, sqrt(sigmaX)); v = rnorm(m, 0, sqrt(sigma_v2)); y = numeric(m * Ni)
  theta = numeric(m); kk = 1
  for(i in 1 : m){
    sumx = 0
    for(j in 1:Ni){
      sumx = sumx + x[kk]
      y[kk] = beta[1] + beta[2] * x[kk] + v[i] + rnorm(1, 0, sqrt(sigma_e2))
      kk = kk + 1
    }
    meanx = sumx/Ni
    theta[i] = beta[1] + beta[2] * meanx + v[i]
  }
  group = rep(seq(m), each = Ni)
  x = cbind(rep(1, m*Ni), x)
  data = cbind(x, y, group)
  return(list(data = data, theta = theta))
} 
### sample function
sampleXY = function(Ni, ni, m, Population){
  Indx = c()
  for(i in 1:m){
    Indx = c(Indx, sample(c(((i - 1) * Ni + 1) : (i * Ni)), ni[i]))
  }
  Sample = Population[Indx, ]; Nonsample = Population[-Indx, ]
  return(list(Sample, Nonsample))
} 
### data generation process
Population = pop.model(Ni, sigmaX, beta, sigma_v2, sigma_e2, m)$data
XY = sampleXY(Ni, ni, m, Population)[[1]]
X = XY[, 1:p]
Y = XY[, p+1]
Xmean = matrix(NA, m, p)
for(tt in 1: m){
  Xmean[tt, ] = colMeans(Population[which(Population[,p+2] == tt), 1:p])
}
### mspe result
mspeNERlin(ni, X, Y, Xmean, method = "PR", var.method = "default")
</code></pre>


</div>