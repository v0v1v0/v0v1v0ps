<div class="container">

<table style="width: 100%;"><tr>
<td>SSGL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spike-and-Slab Group Lasso Regression</h2>

<h3>Description</h3>

<p>This is a stand-alone function for group-regularized regression models in the exponential dispersion family with the spike-and-slab group lasso (SSGL) penalty.  Let <code class="reqn">y_i</code> denote the <code class="reqn">i</code>th response and <code class="reqn">x_i</code> denote a <code class="reqn">p</code>-dimensional vector of covariates. We fit models of the form,
</p>
<p style="text-align: center;"><code class="reqn">g(E(y_i)) = \beta_0 + x_i^T \beta, i = 1, ..., n,</code>
</p>

<p>where <code class="reqn">g</code> is a monotone increasing link function. The identity link function is used for Gaussian regression, the logit link is used for binomial regression, and the log link is used for Poisson, negative binomial, and gamma regression.
</p>
<p>If the covariates in each <code class="reqn">x_i</code> are grouped according to known groups <code class="reqn">g=1, ..., G</code>, then this function may estimate some of the <code class="reqn">G</code> groups of coefficients as all zero, depending on the amount of regularization. 
</p>
<p>Another implementation of the SSGL model for Gaussian regression models is available on Github at https://github.com/jantonelli111/SSGL. This package <code>sparseGAM</code> also implements the SSGL model for binomial, Poisson, negative binomial, and gamma regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SSGL(y, X, X.test, groups, 
     family=c("gaussian","binomial","poisson","negativebinomial","gamma"), 
     nb.size=1, gamma.shape=1, weights, nlambda0=20, lambda0, lambda1, a, b, 
     max.iter=100, tol = 1e-6, print.iter=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code class="reqn">n \times 1</code> vector of responses for training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code class="reqn">n \times p</code> design matrix for training data, where the <code class="reqn">j</code>th column of <code>X</code> corresponds to the <code class="reqn">j</code>th overall covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.test</code></td>
<td>
<p><code class="reqn">n_{test} \times p</code> design matrix for test data to calculate predictions. <code>X.test</code> must have the <em>same</em> number of columns as <code>X</code>, but not necessarily the same number of rows. If <em>no</em> test data is provided or if in-sample predictions are desired, then the function automatically sets <code>X.test=X</code> in order to calculate <em>in-sample</em> predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p><code class="reqn">p</code>-dimensional vector of group labels. The <code class="reqn">j</code>th entry in <code>groups</code> should contain either the group number <em>or</em> the name of the factor level that the <code class="reqn">j</code>th covariate belongs to. <code>groups</code> must be either a vector of integers or factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>exponential dispersion family. Allows for <code>"gaussian"</code>, <code>"binomial"</code>, <code>"poisson"</code>, <code>"negativebinomial"</code>, and <code>"gamma"</code>. Note that for <code>"negativebinomial"</code>, the size parameter must be specified, while for <code>"gamma"</code>, the shape parameter must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.size</code></td>
<td>
<p>known size parameter <code class="reqn">\alpha</code> in <code class="reqn">NB(\alpha,\mu_i)</code> distribution for the negative binomial responses. Default is <code>nb.size=1</code>. Ignored if <code>family</code> is not <code>"negativebinomial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.shape</code></td>
<td>
<p>known shape parameter <code class="reqn">\nu</code> in <code class="reqn">Gamma(\mu_i,\nu)</code> distribution for gamma responses. Default is <code>gamma.shape=1</code>. Ignored if <code>family</code> is not <code>"gamma"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>group-specific, nonnegative weights for the penalty. Default is to use the square roots of the group sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda0</code></td>
<td>
<p>number of spike hyperparameters <code class="reqn">L</code>. Default is <code>nlambda0=20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>grid of <code class="reqn">L</code> spike hyperparameters <code class="reqn">\lambda_0</code>. The user may specify either a scalar or a vector. If the user does not provide this, the program chooses the grid automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>slab hyperparameter <code class="reqn">\lambda_1</code> in the SSGL prior. Default is <code>lambda1=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>shape hyperparameter for the <code class="reqn">Beta(a,b)</code> prior on the mixing proportion in the SSGL prior. Default is <code>a=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>shape hyperparameter for the <code class="reqn">Beta(a,b)</code> prior on the mixing proportion in the SSGL prior. Default is <code>b=dim(X)[2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum number of iterations in the algorithm. Default is <code>max.iter=100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>convergence threshold for algorithm. Default is <code>tol=1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.iter</code></td>
<td>
<p>Boolean variable for whether or not to print the current <code>nlambda0</code> in the algorithm. Default is <code>print.iter=TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p><code class="reqn">L \times 1</code> vector of spike hyperpameters <code>lambda0</code> used to fit the model. <code>lambda0</code> is displayed in descending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p><code class="reqn">L \times 1</code> vector of estimated intercepts. The <code class="reqn">k</code>th entry in <code>beta0</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p><code class="reqn">p \times L</code> matrix of estimated regression coefficients. The <code class="reqn">k</code>th column in <code>beta</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.pred</code></td>
<td>
<p><code class="reqn">n_{test} \times L</code> matrix of predicted mean response values <code class="reqn">\mu_{test} = E(Y_{test})</code> based on the <em>test</em> data in <code>X.test</code> (or training data <code>X</code> if no argument was specified for<code>X.test</code>). The <code class="reqn">k</code>th column in <code>mu.pred</code> corresponds to the predictions for the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifications</code></td>
<td>
<p><code class="reqn">G \times L</code> matrix of classifications, where <code class="reqn">G</code> is the number of groups. An entry of "1" indicates that the group was classified as nonzero, and an entry of "0" indicates that the group was classified as zero. The <code class="reqn">k</code>th column of <code>classifications</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>vector of either the residual sum of squares (<code>"gaussian"</code>) or the negative log-likelihood (<code>"binomial"</code>, <code>"poisson"</code>, <code>"negativebinomial"</code>, <code>"gamma"</code>) of the fitted model. The <code class="reqn">k</code>th entry in <code>loss</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bai R. (2021). "Spike-and-slab group lasso for consistent Bayesian estimation and variable selection in non-Gaussian generalized additive models." <em>arXiv pre-print arXiv:2007.07021</em>.
</p>
<p>Bai, R., Moran, G. E., Antonelli, J. L., Chen, Y., and Boland, M.R. (2021). "Spike-and-slab group lassos for grouped regression and sparse generalized additive models." <em>Journal of the American Statistical Association</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate data
set.seed(12345)
X = matrix(runif(100*10), nrow=100)
n = dim(X)[1]
groups = c("A","A","A","B","B","B","C","C","D","D")
groups = as.factor(groups)
true.beta = c(-2.5,1.5,1.5,0,0,0,2,-2,0,0)

## Generate responses from Gaussian distribution
y = crossprod(t(X),true.beta) + rnorm(n)

## Generate test data
n.test = 50
X.test = matrix(runif(n.test*10), nrow=n.test)

## Fit SSGL model with 10 spike hyperparameters
## Note that if user does not specify lambda0, the SSGL function chooses a grid automatically.

SSGL.mod = SSGL(y, X, X.test, groups, family="gaussian", lambda0=seq(from=50,to=5,by=-5))

## Regression coefficient estimates
SSGL.mod$beta

# Predicted n.test-dimensional vectors mu=E(Y.test) based on test data, X.test. 
# The kth column of 'mu.pred' corresponds to the kth entry in 'lambda.'
SSGL.mod$mu.pred 

# Classifications of the 8 groups. The kth column of 'classifications'
# corresponds to the kth entry in 'lambda.'
SSGL.mod$classifications


## Example with binomial regression

## Generate binary responses
eta = crossprod(t(X), true.beta)
y = rbinom(n, size=1, prob=1/(1+exp(-eta)))

## Fit SSGL model with 10 spike hyperparameters
## Note that if user does not specify lambda0, the SSGL function chooses a grid automatically.

SSGL.mod = SSGL(y, X, X.test, groups, family="binomial", 
		lambda0=seq(from=10,to=1,by=-1))

## Predicted probabilities of success mu=E(Y.test) based on test data, X.test
SSGL.mod$mu.pred

## Classifications of the 8 groups. 
SSGL.mod$classifications

</code></pre>


</div>