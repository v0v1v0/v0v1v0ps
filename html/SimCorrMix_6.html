<div class="container">

<table style="width: 100%;"><tr>
<td>corr_error</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Error Loop to Correct Final Correlation of Simulated Variables</h2>

<h3>Description</h3>

<p>This function attempts to correct the final pairwise correlations of simulated variables to be within <code>epsilon</code>
of the target correlations.  It updates the intermediate normal correlation iteratively in a loop until either the maximum error
is less than epsilon or the number of iterations exceeds <code>maxit</code>.  This function would not ordinarily be called directly by
the user.  The function is a modification of  Barbiero &amp; Ferrari's <code>ordcont</code> function in
<code>GenOrd-package</code>.  The <code>ordcont</code> function has been modified in the following ways:
</p>
<p>1) It works for continuous, ordinal (r &gt;= 2 categories), and count (regular or zero-inflated, Poisson or Negative Binomial) variables.
</p>
<p>2) The initial correlation check has been removed because the intermediate correlation matrix
<code>Sigma</code> from <code>corrvar</code> or <code>corrvar2</code> has already been
checked for positive-definiteness and used to generate variables.
</p>
<p>3) Eigenvalue decomposition is done on <code>Sigma</code> to impose the correct intermediate correlations on the normal variables.
If <code>Sigma</code> is not positive-definite, the negative eigenvalues are replaced with 0.
</p>
<p>4) The final positive-definite check has been removed.
</p>
<p>5) The intermediate correlation update function was changed to accommodate more situations.
</p>
<p>6) Allowing specifications for the sample size and the seed for reproducibility.
</p>
<p>The vignette <b>Variable Types</b> describes the algorithm used in the error loop.
</p>


<h3>Usage</h3>

<pre><code class="language-R">corr_error(n = 10000, k_cat = 0, k_cont = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), means = NULL, vars = NULL,
  constants = NULL, marginal = list(), support = list(), lam = NULL,
  p_zip = 0, size = NULL, mu = NULL, p_zinb = 0, seed = 1234,
  epsilon = 0.001, maxit = 1000, rho0 = NULL, Sigma = NULL,
  rho_calc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_cont</code></td>
<td>
<p>the number of continuous variables (these may be regular continuous variables or components of continuous mixture variables)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_pois</code></td>
<td>
<p>the number of Poisson (regular or zero-inflated) variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_nb</code></td>
<td>
<p>the number of Negative Binomial (regular or zero-inflated) variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used to generate the continuous variables.  "Fleishman" uses a third-order polynomial transformation
and "Polynomial" uses Headrick's fifth-order transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>a vector of means for the continuous variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>a vector of variances for the continuous variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = "Fleishman") or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = "Polynomial"), like that returned by <code>find_constants</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marginal</code></td>
<td>
<p>a list of length equal <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>
<p>a list of length equal <code>k_cat</code>; the i-th element is a vector of containing the r
ordered support values; if not provided, the default is for the i-th element to be the vector 1, ..., r</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the zero-inflated
Poisson variables (see <code>VGAM::dzipois</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables; order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>the seed value for random number generation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlation; smaller epsilons take more time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>the maximum number of iterations to use to find the intermediate correlation; the
correction loop stops when either the iteration number passes <code>maxit</code> or <code>epsilon</code> is reached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho0</code></td>
<td>
<p>the target correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>the intermediate correlation matrix previously used in <code>corrvar</code>
or <code>corrvar2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho_calc</code></td>
<td>
<p>the final correlation matrix calculated in <code>corrvar</code>
or <code>corrvar2</code> before execution of <code>corr_error</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>Sigma</code> the intermediate MVN correlation matrix resulting from the error loop
</p>
<p><code>rho_calc</code> the calculated final correlation matrix generated from Sigma
</p>
<p><code>Y_cat</code> the ordinal variables
</p>
<p><code>Y</code> the continuous (mean 0, variance 1) variables
</p>
<p><code>Y_cont</code> the continuous variables with desired mean and variance
</p>
<p><code>Y_pois</code> the Poisson variables
</p>
<p><code>Y_nb</code> the Negative Binomial variables
</p>
<p><code>niter</code> a matrix containing the number of iterations required for each variable pair
</p>


<h3>References</h3>

<p>Please see references for <code>SimCorrMix</code>.
</p>


<h3>See Also</h3>

<p><code>corrvar</code>, <code>corrvar2</code>
</p>


</div>