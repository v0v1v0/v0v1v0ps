<div class="container">

<table style="width: 100%;"><tr>
<td>Kmeasure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reduced Second Moment Measure</h2>

<h3>Description</h3>

<p>Estimates the reduced second moment measure <code class="reqn">\kappa</code> 
from a point pattern in a window of arbitrary shape.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  Kmeasure(X, sigma, edge=TRUE, ..., varcov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of <code class="reqn">\kappa</code> will be computed.
An object of class <code>"ppp"</code>, or data
in any format acceptable to <code>as.ppp()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma</code> of the Gaussian
smoothing kernel. Incompatible with <code>varcov</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge</code></td>
<td>

<p>Logical value indicating whether an edge correction
should be applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to <code>as.mask</code> controlling
the pixel resolution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcov</code></td>
<td>

<p>Variance-covariance matrix of the Gaussian smoothing kernel.
Incompatible with <code>sigma</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a point pattern dataset, 
this command computes an estimate of the reduced second moment
measure <code class="reqn">\kappa</code> of the point process.
The result is a pixel image whose pixel values are estimates of
the density of the reduced second moment measure. 
</p>
<p>The reduced second moment measure <code class="reqn">\kappa</code>
can be regarded as a generalisation of the more familiar
<code class="reqn">K</code>-function.
An estimate of <code class="reqn">\kappa</code> derived from a spatial point
pattern dataset can be useful in exploratory data analysis.
Its advantage over the <code class="reqn">K</code>-function is that it is also sensitive
to anisotropy and directional effects. 
</p>
<p>In a nutshell, the command <code>Kmeasure</code> computes a smoothed version
of the <em>Fry plot</em>. 
As explained under <code>fryplot</code>, the Fry plot is a scatterplot of the
vectors joining all pairs of points in the pattern.
The reduced second moment measure is (essentially) defined as
the average of the Fry plot over different realisations of the point
process. The command <code>Kmeasure</code> effectively smooths the Fry plot
of a dataset to obtain an estimate of the reduced second moment measure.
</p>
<p>In formal terms, the reduced second moment measure <code class="reqn">\kappa</code>
of a stationary point process <code class="reqn">X</code> is a measure defined on the
two-dimensional plane such that,
for a ‘typical’ point <code class="reqn">x</code> of the process, 
the expected number of other points <code class="reqn">y</code> of the process
such that the vector <code class="reqn">y - x</code> lies in a region <code class="reqn">A</code>,
equals <code class="reqn">\lambda \kappa(A)</code>.
Here <code class="reqn">\lambda</code>
is the intensity of the process,
i.e. the expected number of points of <code class="reqn">X</code> per unit area.
</p>
<p>The <code class="reqn">K</code>-function is a special case. The function value <code class="reqn">K(t)</code> is
the value of the reduced second moment measure
for the disc of radius <code class="reqn">t</code> centred at the origin; that is,
<code class="reqn">K(t) = \kappa(b(0,t))</code>.
</p>
<p>The command <code>Kmeasure</code> computes an estimate of <code class="reqn">\kappa</code>
from a point pattern dataset <code>X</code>,
which is assumed to be a realisation of a stationary point process,
observed inside a known, bounded window. Marks are ignored.
</p>
<p>The algorithm approximates the point pattern and its window by binary pixel
images, introduces a Gaussian smoothing kernel
and uses the Fast Fourier Transform <code>fft</code>
to form a density estimate of <code class="reqn">\kappa</code>. The calculation
corresponds to the edge correction known as the “translation
correction”.
</p>
<p>The Gaussian smoothing kernel may be specified by either of the
arguments <code>sigma</code> or <code>varcov</code>. If <code>sigma</code> is a single
number, this specifies an isotropic Gaussian kernel
with standard deviation <code>sigma</code> on each coordinate axis.
If <code>sigma</code> is a vector of two numbers, this specifies a Gaussian
kernel with standard deviation <code>sigma[1]</code> on the <code class="reqn">x</code> axis,
standard deviation <code>sigma[2]</code> on the <code class="reqn">y</code> axis, and zero
correlation between the <code class="reqn">x</code> and <code class="reqn">y</code> axes. If <code>varcov</code> is
given, this specifies the variance-covariance matrix of the
Gaussian kernel. There do not seem to be any well-established rules
for selecting the smoothing kernel in this context.
</p>
<p>The density estimate of <code class="reqn">\kappa</code>
is returned in the form of a real-valued pixel image.
Pixel values are estimates of the normalised
second moment density at the centre of the pixel.
(The uniform Poisson process would have values identically equal to
<code class="reqn">1</code>.)
The image <code>x</code> and <code>y</code>
coordinates are on the same scale as vector displacements in the
original point pattern window. The point <code>x=0, y=0</code> corresponds
to the ‘typical point’.
A peak in the image near <code>(0,0)</code> suggests clustering;
a dip in the image near <code>(0,0)</code> suggests inhibition;
peaks or dips at other positions suggest possible periodicity.
</p>
<p>If desired, the value of <code class="reqn">\kappa(A)</code> for a region
<code class="reqn">A</code> can be estimated by computing the integral of the pixel image
over the domain <code class="reqn">A</code>, i.e.\ summing the pixel values and
multiplying by pixel area, using <code>integral.im</code>.
One possible application is to compute anisotropic counterparts of the
<code class="reqn">K</code>-function (in which the disc of radius <code class="reqn">t</code> is replaced
by another shape). See Examples.
</p>


<h3>Value</h3>

<p>A real-valued pixel image (an object of class <code>"im"</code>,
see <code>im.object</code>) whose pixel values are estimates
of the density of the reduced second moment measure
at each location.
</p>


<h3>Warning</h3>

<p>Some writers use the term <em>reduced second moment measure</em>
when they mean the <code class="reqn">K</code>-function. This has caused
confusion. 
</p>
<p>As originally defined, the
reduced second moment measure is a measure, obtained by modifying
the second moment measure, while the <code class="reqn">K</code>-function is a function
obtained by evaluating this measure for discs of increasing radius.
In <span class="pkg">spatstat</span>, the <code class="reqn">K</code>-function is computed by
<code>Kest</code> and the reduced second moment measure is computed
by <code>Kmeasure</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1995)
<em>Stochastic geometry and its applications</em>.
2nd edition. Springer Verlag.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code>Kest</code>,
<code>fryplot</code>,
<code>spatstat.options</code>,
<code>integral.im</code>,
<code>im.object</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> plot(Kmeasure(cells, 0.05))
 # shows pronounced dip around origin consistent with strong inhibition
 plot(Kmeasure(redwood, 0.03), col=grey(seq(1,0,length=32)))
 # shows peaks at several places, reflecting clustering and ?periodicity
 M &lt;- Kmeasure(cells, 0.05)
 # evaluate measure on a sector
 W &lt;- Window(M)
 ang &lt;- as.im(atan2, W)
 rad &lt;- as.im(function(x,y){sqrt(x^2+y^2)}, W)
 sector &lt;- solutionset(ang &gt; 0 &amp; ang &lt; 1 &amp; rad &lt; 0.6)
 integral.im(M[sector, drop=FALSE])
</code></pre>


</div>