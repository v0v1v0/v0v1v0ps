<div class="container">

<table style="width: 100%;"><tr>
<td>is_numeric_like</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test whether a vector is numeric or coercible to numeric</h2>

<h3>Description</h3>

<p><code>is_numeric_like()</code> tests whether an object is "coercible to
numeric" by the particular standards of scrutiny. This means:
</p>

<ul>
<li>
<p> Integer and double vectors are <code>TRUE</code>.
</p>
</li>
<li>
<p> Logical vectors are <code>FALSE</code>, as are non-vector objects.
</p>
</li>
<li>
<p> Other vectors (most likely strings) are <code>TRUE</code> if all their non-<code>NA</code>
values can be coerced to non-<code>NA</code> numeric values, and <code>FALSE</code> otherwise.
</p>
</li>
<li>
<p> Factors are first coerced to string, then tested.
</p>
</li>
<li>
<p> Lists are tested like atomic vectors unless any of their elements have
length greater 1, in which case they are always <code>FALSE</code>.
</p>
</li>
<li>
<p> If all values are non-numeric, non-logical <code>NA</code>, the output is also <code>NA</code>.
</p>
</li>
</ul>
<p>See details for discussion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is_numeric_like(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object to be tested.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The scrutiny package often deals with "number-strings", i.e.,
strings that can be coerced to numeric without introducing new <code>NA</code>s. This
is a matter of displaying data in a certain way, as opposed to their
storage mode.
</p>
<p><code>is_numeric_like()</code> returns <code>FALSE</code> for logical vectors simply because
these are displayed as strings, not as numbers, and the usual coercion
rules would be misleading in this context. Likewise, the function treats
factors like strings because that is how they are displayed: the fact that
factors are stored as integers is irrelevant.
</p>
<p>Why store numbers as strings or factors? Only these data types can preserve
trailing zeros, and only if the data were originally entered as strings.
See <code>vignette("wrangling")</code>, section <em>Trailing zeros</em>.
</p>


<h3>Value</h3>

<p>Logical (length 1).
</p>


<h3>See Also</h3>

<p>The <a href="https://vctrs.r-lib.org/">vctrs</a> package, which provides a
serious typing framework for R; in contrast to this rather ad-hoc function.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Numeric vectors are `TRUE`:
is_numeric_like(x = 1:5)
is_numeric_like(x = 2.47)

# Logical vectors are always `FALSE`:
is_numeric_like(x = c(TRUE, FALSE))

# Strings are `TRUE` if all of their non-`NA`
# values can be coerced to non-`NA` numbers,
# and `FALSE` otherwise:
is_numeric_like(x = c("42", "0.7", NA))
is_numeric_like(x = c("42", "xyz", NA))

# Factors are treated like their
# string equivalents:
is_numeric_like(x = as.factor(c("42", "0.7", NA)))
is_numeric_like(x = as.factor(c("42", "xyz", NA)))

# Lists behave like atomic vectors if all of their
# elements have length 1...
is_numeric_like(x = list("42", "0.7", NA))
is_numeric_like(x = list("42", "xyz", NA))

# ...but if they don't, they are `FALSE`:
is_numeric_like(x = list("42", "0.7", NA, c(1, 2, 3)))

# If all values are `NA`, so is the output...
is_numeric_like(x = as.character(c(NA, NA, NA)))

# ...unless the `NA`s are numeric or logical:
is_numeric_like(x = as.numeric(c(NA, NA, NA)))
is_numeric_like(x = c(NA, NA, NA))
</code></pre>


</div>