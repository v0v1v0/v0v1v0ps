<div class="container">

<table style="width: 100%;"><tr>
<td>microaggregation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Microaggregation</h2>

<h3>Description</h3>

<p>Function to perform various methods of microaggregation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">microaggregation(
  obj,
  variables = NULL,
  aggr = 3,
  strata_variables = NULL,
  method = "mdav",
  weights = NULL,
  nc = 8,
  clustermethod = "clara",
  measure = "mean",
  trim = 0,
  varsort = 1,
  transf = "log"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>either an object of class <code>sdcMicroObj-class</code> or a <code>data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>variables to microaggregate. For <code>NULL</code>: If obj is of class
sdcMicroObj, all numerical key variables are chosen per default. For
<code>data.frames</code>, all columns are chosen per default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggr</code></td>
<td>
<p>aggregation level (default=3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata_variables</code></td>
<td>
<p>for <code>data.frames</code>, by-variables for applying microaggregation only
within strata defined by the variables. For <code>sdcMicroObj-class</code>-objects, the
stratification-variable defined in slot <code>@strataVar</code> is used. This slot can be changed any
time using <code>strataVar&lt;-</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>pca, rmd, onedims, single, simple, clustpca, pppca,
clustpppca, mdav, clustmcdpca, influence, mcdpca</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>sampling weights. If obj is of class sdcMicroObj the vector
of sampling weights is chosen automatically. If determined, a weighted
version of the aggregation measure is chosen automatically, e.g. weighted
median or weighted mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>number of cluster, if the chosen method performs cluster analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustermethod</code></td>
<td>
<p>clustermethod, if necessary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>aggregation statistic, mean, median, trim, onestep (default=mean)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>trimming percentage, if measure=trim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varsort</code></td>
<td>
<p>variable for sorting, if method=single</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transf</code></td>
<td>
<p>transformation for data x</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>On <a href="https://research.cbs.nl/casc/glossary.htm">https://research.cbs.nl/casc/glossary.htm</a> one can found the
“official” definition of microaggregation:
</p>
<p>Records are grouped based on a proximity measure of variables of interest,
and the same small groups of records are used in calculating aggregates for
those variables. The aggregates are released instead of the individual
record values.
</p>
<p>The recommended method is “rmd” which forms the proximity using
multivariate distances based on robust methods. It is an extension of the
well-known method “mdav”.  However, when computational speed is
important, method “mdav” is the preferable choice.
</p>
<p>While for the proximity measure very different concepts can be used, the
aggregation itself is naturally done with the arithmetic mean.
Nevertheless, other measures of location can be used for aggregation,
especially when the group size for aggregation has been taken higher than 3.
Since the median seems to be unsuitable for microaggregation because of
being highly robust, other mesures which are included can be chosen. If a
complex sample survey is microaggregated, the corresponding sampling weights
should be determined to either aggregate the values by the weighted
arithmetic mean or the weighted median.
</p>
<p>This function contains also a method with which the data can be clustered
with a variety of different clustering algorithms. Clustering observations
before applying microaggregation might be useful.  Note, that the data are
automatically standardised before clustering.
</p>
<p>The usage of clustering method ‘Mclust’ requires package mclust02,
which must be loaded first. The package is not loaded automatically, since
the package is not under GPL but comes with a different licence.
</p>
<p>The are also some projection methods for microaggregation included.  The
robust version ‘pppca’ or ‘clustpppca’ (clustering at first)
are fast implementations and provide almost everytime the best results.
</p>
<p>Univariate statistics are preserved best with the individual ranking method
(we called them ‘onedims’, however, often this method is named
‘individual ranking’), but multivariate statistics are strong
affected.
</p>
<p>With method ‘simple’ one can apply microaggregation directly on the
(unsorted) data. It is useful for the comparison with other methods as a
benchmark, i.e. replies the question how much better is a sorting of the
data before aggregation.
</p>


<h3>Value</h3>

<p>If ‘obj’ was of class <code>sdcMicroObj-class</code> the corresponding
slots are filled, like manipNumVars, risk and utility. If ‘obj’ was
of class “data.frame”, an object of class “micro” with following entities is returned:
</p>

<dl>
<dt>
<code>x</code>: </dt>
<dd>
<p>original data</p>
</dd>
<dt>
<code>mx</code>: </dt>
<dd>
<p>the microaggregated dataset</p>
</dd>
<dt>
<code>method</code>: </dt>
<dd>
<p>method</p>
</dd>
<dt>
<code>aggr</code>: </dt>
<dd>
<p>aggregation level</p>
</dd>
<dt>
<code>measure</code>: </dt>
<dd>
<p>proximity measure for aggregation</p>
</dd>
</dl>
<h3>Note</h3>

<p>if only one variable is specified, <code>mafast</code> is applied and argument <code>method</code> is ignored.
Parameters <code>measure</code> are ignored for methods <code>mdav</code> and <code>rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Templ, Bernhard Meindl
</p>
<p>For method “mdav”: This work is being supported by the International
Household Survey Network (IHSN) and funded by a DGF Grant provided by the
World Bank to the PARIS21 Secretariat at the Organisation for Economic
Co-operation and Development (OECD).  This work builds on previous work
which is elsewhere acknowledged.
</p>
<p>Author for the integration of the code for mdav in R: Alexander Kowarik.
</p>


<h3>References</h3>

<p>Templ, M. and Meindl, B., <em>Robust Statistics Meets SDC: New Disclosure
Risk Measures for Continuous Microdata Masking</em>, Lecture Notes in Computer
Science, Privacy in Statistical Databases, vol. 5262, pp. 113-126, 2008.
</p>
<p>Templ, M. <em>Statistical Disclosure Control for Microdata Using the
R-Package sdcMicro</em>, Transactions on Data Privacy, vol. 1, number 2, pp.
67-85, 2008.  <a href="http://www.tdp.cat/issues/abs.a004a08.php">http://www.tdp.cat/issues/abs.a004a08.php</a>
</p>
<p>Templ, M. <em>New Developments in Statistical Disclosure Control and
Imputation: Robust Statistics Applied to Official Statistics</em>,
Suedwestdeutscher Verlag fuer Hochschulschriften, 2009, ISBN: 3838108280,
264 pages.
</p>
<p>Templ, M. Statistical Disclosure Control for Microdata: Methods and Applications in R.
<em>Springer International Publishing</em>, 287 pages, 2017. ISBN 978-3-319-50272-4. <a href="https://doi.org/10.1007/978-3-319-50272-4">doi:10.1007/978-3-319-50272-4</a>
<a href="https://doi.org/10.1007/978-3-319-50272-4">doi:10.1007/978-3-319-50272-4</a>
</p>
<p>Templ, M. and Meindl, B. and Kowarik, A.: <em>Statistical Disclosure Control for
Micro-Data Using the R Package sdcMicro</em>, Journal of Statistical Software,
67 (4), 1–36, 2015.
</p>


<h3>See Also</h3>

<p><code>summary.micro</code>, <code>plotMicro</code>,
<code>valTable</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(testdata)
# donttest since Examples with CPU time larger 2.5 times elapsed time, because
# of using data.table and multicore computation.

m &lt;- microaggregation(
  obj = testdata[1:100, c("expend", "income", "savings")],
  method = "mdav",
  aggr = 4
)
summary(m)

## for objects of class sdcMicro:
## no stratification because `@strataVar` is `NULL`
data(testdata2)
sdc &lt;- createSdcObj(
  dat = testdata2,
  keyVars = c("urbrur", "roof", "walls", "water", "electcon", "sex"),
  numVars = c("expend", "income", "savings"),
  w = "sampling_weight"
)
sdc &lt;- microaggregation(
  obj = sdc,
  variables = c("expend", "income")
)

## with stratification using variable `"relat"`
strataVar(sdc) &lt;- "relat"
sdc &lt;- microaggregation(
  obj = sdc,
  variables = "savings"
)

</code></pre>


</div>