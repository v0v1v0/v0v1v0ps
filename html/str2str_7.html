<div class="container">

<table style="width: 100%;"><tr>
<td>abind&lt;-</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add array slices to 3D+ Array
<code>`abind&lt;-`</code> adds array slices to arrays as a side effect. It used the function
<code>abind</code> in the <code>abind</code> package. The purpose of the function is to replace
the need to use ary2 &lt;- abind(ary1, mat1); ary3 &lt;- rbind(ary2, mat2); ary4 &lt;- rbind(ary3, mat3),
etc. It allows you to specify the dimension you wish to bind <code>along</code> as well as the dimname you
wish to bind <code>after</code>. Unlike <code>`cbind&lt;-`</code>, <code>`rbind&lt;-`</code>, and <code>`append&lt;-`</code>,
it does not have overwriting functionality (I could not figure out how to code that);
therefore, if <code>value</code> has some dimnames that are the same as those in <code>a</code>,
it will NOT overwrite them and simply bind them to <code>a</code>, resulting in duplicate
dimnames.</h2>

<h3>Description</h3>

<p>Some traditional R folks may find this function uncomfortable. R is famous for limiting
side effects, except for a few notable exceptions (e.g., <code>`[&lt;-`</code> and <code>`names&lt;-`</code>).
Part of the reason is that side effects can be computationally inefficient in R.
The entire object often has to be re-constructed and re-saved to memory. For
example, a more computationally efficient alternative to abind(ary) &lt;- mat1;
abind(ary) &lt;- mat2; abind(ary) &lt;- mat3 is ary1 &lt;- do.call(what = abind,
args = list(ary, mat1, mat2, mat3)). However, <code>`abind&lt;-`</code> was not created
for R programming use when computational efficiency is valued; it is created
for R interactive use when user convenience is valued.
</p>


<h3>Usage</h3>

<pre><code class="language-R">abind(
  a,
  along = ndim(a),
  after = dim(a)[along],
  dim.nm = NULL,
  overwrite = FALSE
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>3D+ array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>along</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying the dimension along which to bind <code>value</code>. If an integer
vector, it is the position of the dimension. If a character vector it is the
dimension with that dimlabel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>after</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying where to add <code>value</code> within the dimension specified by
<code>along</code>. If an integer vector, it is the position within the dimension.
If a character vector it is the dimname within the dimension. Similar to
<code>append</code>, use 0L if you want the added array slice to be first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim.nm</code></td>
<td>
<p>character vector of length equal to <code>ndim(value)[along]</code> that
specifies the dimnames of <code>value</code> once added to <code>a</code> as array slices.
This is an optional argument that defaults to NULL where the pre-existing dimnames
of <code>value</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>not currently used, but there are plans to use it in future
versions of the functions. Right now the only option is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>matrix or array to be added as slices to <code>a</code>. Must have ndim
equal to <code>ndim(a)</code> or <code>ndim(a) - 1L</code>. Note, the dimensions have to match
those in <code>a</code>. For example, if <code>value</code> is a matrix you want to bind
along the third dimension of <code>a</code>, then <code>dim(value)</code> must be equal to
<code>dim(a)[1:2]</code>. If not, you will get an error from <code>abind::abind</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
<code>`rbind&lt;-`</code> does not appear to have a return object. However, it technically
does as a side effect. The argument <code>data</code> will have been changed such that
<code>value</code> has been added as rows. If a traditional return object is desired,
and no side effects, then it can be called like a traditional function:
dat2 &lt;- 'rbind&lt;-'(dat1, value = add1).
</p>


<h3>Examples</h3>

<pre><code class="language-R"># abind along the last dimension
# default `along` and `after`
HairEyeColor2 &lt;- HairEyeColor
intersex_ary &lt;- array(1:16, dim = c(4,4,1), dimnames = list(NULL, NULL, "Sex" = "Intersex"))
abind(HairEyeColor2) &lt;- intersex_ary
print(HairEyeColor2)
# user-specified `along` and `after`
HairEyeColor2 &lt;- HairEyeColor
intersex_ary &lt;- array(1:16, dim = c(4,4,1), dimnames = list(NULL, NULL, "Sex" = "Intersex"))
abind(HairEyeColor2, along = "Sex", after = 0L) &lt;- intersex_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
intersex_mat &lt;- matrix(1:16, nrow = 4, ncol = 4)
abind(HairEyeColor2, dim.nm = "Intersex") &lt;- intersex_mat
print(HairEyeColor2)

# abind along the first dimension
# array as `value`
HairEyeColor2 &lt;- HairEyeColor
auburn_ary &lt;- array(1:8, dim = c(1,4,2), dimnames = list("Hair" = "Auburn", NULL, NULL))
abind(HairEyeColor2, along = 1L) &lt;- auburn_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
auburn_mat &lt;- matrix(1:8, nrow = 4, ncol = 2) # rotate 90-degrees counter-clockwise in your mind
abind(HairEyeColor2, along = 1L, dim.nm = "Auburn") &lt;- auburn_mat
print(HairEyeColor2)
# `after` in the middle
HairEyeColor2 &lt;- HairEyeColor
auburn_mat &lt;- matrix(1:8, nrow = 4, ncol = 2) # rotate 90-degrees counter-clockwise in your mind
abind(HairEyeColor2, along = 1L, after = 2L, dim.nm = "Auburn") &lt;- auburn_mat
print(HairEyeColor2)

# abind along the second dimension
# array as `value`
HairEyeColor2 &lt;- HairEyeColor
amber_ary &lt;- array(1:8, dim = c(4,1,2), dimnames = list(NULL, "Eye" = "Amber", NULL))
abind(HairEyeColor2, along = 2L) &lt;- amber_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
amber_mat &lt;- matrix(1:8, nrow = 4, ncol = 2)
abind(HairEyeColor2, along = 2L, dim.nm = "Amber") &lt;- amber_mat
print(HairEyeColor2)
# `after` in the middle
HairEyeColor2 &lt;- HairEyeColor
amber_mat &lt;- matrix(1:8, nrow = 4, ncol = 2)
abind(HairEyeColor2, along = 2L, after = "Blue", dim.nm = "Amber") &lt;- amber_mat
print(HairEyeColor2)
</code></pre>


</div>