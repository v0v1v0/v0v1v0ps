<div class="container">

<table style="width: 100%;"><tr>
<td>beta_builder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a Parameter Vector from Lattice Locations</h2>

<h3>Description</h3>

<p>Specify the locations in the lattice/image that have non-zero parameters
as well as the values for those parameters, and the function creates
the parameter vector that matches the correct locations in the design 
matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">beta_builder(
  row.index,
  col.index,
  im.res,
  B0 = 0,
  B.values,
  index.type = "manual",
  decay.fn = "gaussian",
  phi = 0.5,
  max.d = Inf,
  h,
  w,
  bayesian = FALSE,
  bayesian.dist = NULL,
  bayesian.scale = NULL,
  output.indices = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>row.index, col.index</code></td>
<td>
<p>Vectors of row/columns indices for non-zero 
parameters.
If <code>index.type = "manual"</code>, each vector should contain specific
coordinates.
If <code>index.type = "rectangle"</code>, each vector should specify rectangle 
length; e.g. row.index = 1:3 means the rectangle's 'length' is from rows
1 to 3.
If <code>index.type = "ellipse"</code>, the arguments should be scalar values
specifying the row/column coordinates for the center of the ellipse.
If <code>index.type = "decay"</code>, the arguments should specify the row/column coordinates,
respectively, of the peak parameter value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>im.res</code></td>
<td>
<p>A vector specifying the dimension/resolution of the image. 
The first entry is the number of 'rows' in the lattice/image, and the
second entry is the number of 'columns' in the lattice/image.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>is the "true" intercept value; default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.values</code></td>
<td>
<p>is a vector "true" parameter values for non-zero parameters.
The order of assignment is by row. If B.values argument is a single value,
then all non-zero parameters are assigned to that value, unless 
<code>decay.fn</code> has been specified, in which case <code>B.values</code> is the 
"peak", and non-zero parameters decay smoothly by distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.type</code></td>
<td>
<p>is one of index.type = c("manual", "rectangle", "ellipse", "decay")
</p>

<ul>
<li> <p><code>index.type = "manual"</code> uses row.index and col.index 
arguments to specify manually selected non-zero locations. This 
setting is good for irregular shaped regions.
</p>
</li>
<li> <p><code>index.type = "rectangle"</code> uses row.index and col.index 
arguments to specify a rectangular region of non-zero parameters.
</p>
</li>
<li> <p><code>index.type = "ellipse"</code> uses <code>w</code> and <code>h</code> 
arguments to specify elliptical region of non-zero parameters.
</p>
</li>
<li> <p><code>index.type = "decay"</code> allows the user to specify a peak
location with <code>row.index</code> and <code>col.index</code>, as with 
<code>index.type = "ellipse"</code>. However, the non-zero parameter values
decay as a function of distance from the peak.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decay.fn</code></td>
<td>
<p>An argument to specify the decay function of non-zero 
parameters decay from the peak when <code>index.type = "decay"</code>. Options 
are "exponential" or "gaussian". The rate of decay is given by 
<code class="reqn">B.values * exp(-phi * d)</code> and <code class="reqn">B.values * exp(-phi * d ^ 2)</code> for
"exponential" and "gaussian", respectively. The default is 
<code>decay.fn = "gaussian"</code>. Note that <code class="reqn">d</code> is the Euclidean distance
between the peak and a specified location, while <code class="reqn">phi</code> is the rate of 
decay and is set by the user with <code>phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay rate of
non-zero parameters when <code>index.type = "decay"</code>. The default is 
<code>phi = 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.d</code></td>
<td>
<p>When <code>index.type = "decay"</code>, <code>max.d</code> determines the
maximum Euclidean distance from the peak that is allowed to be non-zero; 
parameters for locations further than <code>max.d</code> from the peak are set 
to zero. If this argument is not set by the user then all parameter values 
are determined by the decay function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w, h</code></td>
<td>
<p>If index.type = "ellipse" then the width and height of the 
ellipse, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bayesian</code></td>
<td>
<p>If <code>TRUE</code>, then parameters are drawn from distributions
based on initial
<code>B.values</code> vector. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bayesian.dist</code></td>
<td>
<p>When <code>bayesian = TRUE</code>, specifies the distribution
of the parameters. Options are <code>"gaussian"</code> and <code>uniform</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bayesian.scale</code></td>
<td>
<p>A list. When <code>bayesian = TRUE</code> and 
<code>bayesian.dist = "gaussian"</code>, specifies the sd for the distributions 
of parameters. When <code>bayesian = TRUE</code> and 
<code>bayesian.dist = "uniform"</code>, specifies the width for the uniform 
distributions for the parameters. The first entry should be one of 
<code>"unique", "binary"</code>. If  <code>"unique"</code>, then the second entry in 
the list should be a vector with length equal to <code>B.values + 1</code> with 
unique values for the sd's/widths, including B0. B0 can be set to a constant
value by setting the first position of <code>bayesian.scale[[2]]</code> to 0. 
If <code>"binary"</code>, then the second entry in the list should be a 3-element
vector whose first entry is the sd/width of B0, second entry the sd/width 
of "non-zero" or "important" parameters, and the third entry is the 
sd/width of the "zero" or  "irrelevant"  parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.indices</code></td>
<td>
<p>If <code>output.indices = TRUE</code>, then the first 
element of the returned list contains the indices for the non-zero parameter
locations (Default). If <code>output.indices = FALSE</code>, then only the 
parameter vector is returned.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A 2-element list containing (1) indices for the locations of "true"
non-zero parameters, and (2) a parameter vector.
</p>


<h3>Note</h3>

<p>The order of the parameters is by row. That is, if the lattice/image
is 4x4, then parameters 1-4 make up the first row, 5-8 then second, and so
forth.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## example
Bex1 &lt;- beta_builder(row.index = c(5, 5, 6, 6),
                    col.index = c(5, 6, 5, 6),
                    im.res = c(10, 10),
                    B0 = 0, B.values = rep(1, 4))

## True non-zero parameters are locations 45, 46, 55, 56 in B
## i.e. locations (5, 5), (5, 6), (6, 5), (6, 6)

## Suppose that we index rows by i = 1, ... , I
##                       cols by j = 1, ... , J

## The index for a parameter is given by  J * (i - 1) + j
## In this example, I = 10, J = 10; Thus:

## (5, 5) -&gt; 10 * (5 - 1) + 5 = 45
## (5, 6) -&gt; 10 * (5 - 1) + 6 = 46
## (6, 5) -&gt; 10 * (6 - 1) + 5 = 55
## (6, 6) -&gt; 10 * (6 - 1) + 6 = 45
Bex1
## length 101 (includes B0 w/ 100 variable parameter values)
length(Bex1$B)

## example: index.type = "rectangle"
Bex2 &lt;- beta_builder(row.index = 12:15, col.index = 6:19,
                    im.res = c(20, 20), B0 = 16,
                    B.values = 1:(length(12:15) * length(6:19)),
                    index.type = "rectangle")

Bex2
matrix(Bex2$B[-1], nrow = 20, byrow = TRUE)

## example: index.type = "ellipse"
Bex3 &lt;- beta_builder(row.index = 4, col.index = 5,
                    im.res = c(10, 10),
                    B0 = 16, B.values = 3,
                    index.type = "ellipse",
                    h = 5, w = 4)
Bex3
matrix(Bex3$B[-1], nrow = 10, byrow = TRUE)

## decaying parameter values
Bex4 &lt;- beta_builder(row.index = 10, col.index = 20,
                     im.res = c(30, 30), B0 = 0, B.values = 10,
                     index.type = "decay", max.d = 7,
                     output.indices = FALSE)
inf_2D_image(B = Bex4, im.res = c(30, 30), binarize.B = FALSE)

Bex5 &lt;- beta_builder(row.index = 4, col.index = 5,
                     im.res = c(10, 10),
                     B0 = 16, B.values = 5,
                     index.type = "ellipse",
                     h = 5, w = 4,
                     bayesian = TRUE,
                     bayesian.dist = "gaussian",
                     bayesian.scale = list("binary", c(0, 1, 0.25)))

inf_2D_image(B = Bex5$B, im.res = c(10, 10), binarize.B = FALSE)

</code></pre>


</div>