<div class="container">

<table style="width: 100%;"><tr>
<td>sits_factory_function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a closure for calling functions with and without data</h2>

<h3>Description</h3>

<p>This function implements the factory method pattern.
Its creates a generic interface to closures in R so that the functions
in the sits package can be called in two different ways:
1. Called directly, passing input data and parameters.
2. Called as second-order values (parameters of another function).
In the second case, the call will pass no data values
and only pass the parameters for execution
</p>
<p>The factory pattern is used in many situations in the sits package,
to allow different alternatives
for filtering, pattern creation, training, and cross-validation
</p>
<p>Please see the chapter "Technical Annex" in the sits book for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sits_factory_function(data, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function that performs calculation on the input data.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A closure that encapsulates the function applied to data.
</p>


<h3>Author(s)</h3>

<p>Rolf Simoes, <a href="mailto:rolf.simoes@inpe.br">rolf.simoes@inpe.br</a>
</p>
<p>Gilberto Camara, <a href="mailto:gilberto.camara@inpe.br">gilberto.camara@inpe.br</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># example code
if (sits_run_examples()) {
    # Include a new machine learning function (multiple linear regression)
    # function that returns mlr model based on a sits sample tibble

    sits_mlr &lt;- function(samples = NULL, formula = sits_formula_linear(),
                         n_weights = 20000, maxit = 2000) {
        train_fun &lt;- function(samples) {
            # Data normalization
            ml_stats &lt;- sits_stats(samples)
            train_samples &lt;- sits_predictors(samples)
            train_samples &lt;- sits_pred_normalize(
                pred = train_samples,
                stats = ml_stats
            )
            formula &lt;- formula(train_samples[, -1])
            # call method and return the trained model
            result_mlr &lt;- nnet::multinom(
                formula = formula,
                data = train_samples,
                maxit = maxit,
                MaxNWts = n_weights,
                trace = FALSE,
                na.action = stats::na.fail
            )

            # construct model predict closure function and returns
            predict_fun &lt;- function(values) {
                # retrieve the prediction (values and probs)
                prediction &lt;- tibble::as_tibble(
                    stats::predict(result_mlr,
                        newdata = values,
                        type = "probs"
                    )
                )
                return(prediction)
            }
            class(predict_fun) &lt;- c("sits_model", class(predict_fun))
            return(predict_fun)
        }
        result &lt;- sits_factory_function(samples, train_fun)
        return(result)
    }
    # create an mlr model using a set of samples
    mlr_model &lt;- sits_train(samples_modis_ndvi, sits_mlr)
    # classify a point
    point_ndvi &lt;- sits_select(point_mt_6bands, bands = "NDVI")
    point_class &lt;- sits_classify(point_ndvi, mlr_model, multicores = 1)
    plot(point_class)
}
</code></pre>


</div>