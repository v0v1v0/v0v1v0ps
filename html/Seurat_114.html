<div class="container">

<table style="width: 100%;"><tr>
<td>FindIntegrationAnchors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find integration anchors</h2>

<h3>Description</h3>

<p>Find a set of anchors between a list of <code>Seurat</code> objects.
These  anchors can later be used to integrate the objects using the
<code>IntegrateData</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FindIntegrationAnchors(
  object.list = NULL,
  assay = NULL,
  reference = NULL,
  anchor.features = 2000,
  scale = TRUE,
  normalization.method = c("LogNormalize", "SCT"),
  sct.clip.range = NULL,
  reduction = c("cca", "rpca", "jpca", "rlsi"),
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object.list</code></td>
<td>
<p>A list of <code>Seurat</code> objects between which to
find anchors for downstream integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assay</code></td>
<td>
<p>A vector of assay names specifying which assay to use when
constructing anchors. If NULL, the current default assay for each object is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>A vector specifying the object/s to be used as a reference
during integration. If NULL (default), all pairwise anchors are found (no
reference/s). If not NULL, the corresponding objects in <code>object.list</code>
will be used as references. When using a set of specified references, anchors
are first found between each query and each reference. The references are
then integrated through pairwise integration. Each query is then mapped to
the integrated reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anchor.features</code></td>
<td>
<p>Can be either:
</p>

<ul>
<li>
<p>A numeric value. This will call <code>SelectIntegrationFeatures</code>
to select the provided number of features to be used in anchor finding
</p>
</li>
<li>
<p>A vector of features to be used as input to the anchor finding process
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Whether or not to scale the features provided. Only set to FALSE
if you have previously scaled the features you want to use for each object in
the object.list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sct.clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values
the Pearson residual will be clipped to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors. Can
be one of:
</p>

<ul>
<li>
<p>cca: Canonical correlation analysis
</p>
</li>
<li>
<p>rpca: Reciprocal PCA
</p>
</li>
<li>
<p>jpca: Joint PCA
</p>
</li>
<li>
<p>rlsi: Reciprocal LSI
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.norm</code></td>
<td>
<p>Perform L2 normalization on the CCA cell embeddings after
dimensional reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Which dimensions to use from the CCA to specify the neighbor
search space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the
neighborhood search space in the anchor filtering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from RANN/Annoy)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019:
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>First, determine anchor.features if not explicitly specified using
<code>SelectIntegrationFeatures</code>. Then for all pairwise combinations
of reference and query datasets:
</p>

<ul>
<li>
<p>Perform dimensional reduction on the dataset pair as specified via
the <code>reduction</code> parameter. If <code>l2.norm</code> is set to <code>TRUE</code>,
perform L2 normalization of the embedding vectors.
</p>
</li>
<li>
<p>Identify anchors - pairs of cells from each dataset
that are contained within each other's neighborhoods (also known as mutual
nearest neighbors).
</p>
</li>
<li>
<p>Filter low confidence anchors to ensure anchors in the low dimension
space are in broad agreement with the high dimensional measurements. This
is done by looking at the neighbors of each query cell in the reference
dataset using <code>max.features</code> to define this space. If the reference
cell isn't found within the first <code>k.filter</code> neighbors, remove the
anchor.
</p>
</li>
<li>
<p>Assign each remaining anchor a score. For each anchor cell, determine
the nearest <code>k.score</code> anchors within its own dataset and within its
pair's dataset. Based on these neighborhoods, construct an overall neighbor
graph and then compute the shared neighbor overlap between anchor and query
cells (analogous to an SNN graph). We use the 0.01 and 0.90 quantiles on
these scores to dampen outlier effects and rescale to range between 0-1.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns an <code>AnchorSet</code> object that can be used as input to
<code>IntegrateData</code>.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")

# perform standard preprocessing on each object
for (i in 1:length(pancreas.list)) {
  pancreas.list[[i]] &lt;- NormalizeData(pancreas.list[[i]], verbose = FALSE)
  pancreas.list[[i]] &lt;- FindVariableFeatures(
    pancreas.list[[i]], selection.method = "vst",
    nfeatures = 2000, verbose = FALSE
  )
}

# find anchors
anchors &lt;- FindIntegrationAnchors(object.list = pancreas.list)

# integrate data
integrated &lt;- IntegrateData(anchorset = anchors)

## End(Not run)

</code></pre>


</div>