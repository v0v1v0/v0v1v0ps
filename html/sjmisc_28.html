<div class="container">

<table style="width: 100%;"><tr>
<td>frq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Frequency table of labelled variables</h2>

<h3>Description</h3>

<p>This function returns a frequency table of labelled vectors, as data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">frq(
  x,
  ...,
  sort.frq = c("none", "asc", "desc"),
  weights = NULL,
  auto.grp = NULL,
  show.strings = TRUE,
  show.na = TRUE,
  grp.strings = NULL,
  min.frq = 0,
  out = c("txt", "viewer", "browser"),
  title = NULL,
  encoding = "UTF-8",
  file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or a data frame. May also be a grouped data frame
(see 'Note' and 'Examples').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.frq</code></td>
<td>
<p>Determines whether categories should be sorted
according to their frequencies or not. Default is <code>"none"</code>, so
categories are not sorted by frequency. Use <code>"asc"</code> or
<code>"desc"</code> for sorting categories ascending or descending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Bare name, or name as string, of a variable in <code>x</code>
that indicates the vector of weights, which will be applied to weight all
observations. Default is <code>NULL</code>, so no weights are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto.grp</code></td>
<td>
<p>Numeric value, indicating the minimum amount of unique
values in a variable, at which automatic grouping into smaller  units
is done (see <code>group_var</code>). Default value for <code>auto.group</code>
is <code>NULL</code>, i.e. auto-grouping is off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.strings</code></td>
<td>
<p>Logical, if <code>TRUE</code>, frequency tables for character
vectors will not be printed. This is useful when printing frequency tables
of all variables from a data frame, and due to computational reasons
character vectors should not be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.na</code></td>
<td>
<p>Logical, or <code>"auto"</code>. If <code>TRUE</code>, the output always
contains information on missing values, even if variables have no missing
values. If <code>FALSE</code>, information on missing values are removed from
the output. If <code>show.na = "auto"</code>, information on missing values
is only shown when variables actually have missing values, else it's not
shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grp.strings</code></td>
<td>
<p>Numeric, if not <code>NULL</code>, groups string values in
character vectors, based on their similarity. See <code>group_str</code>
and <code>str_find</code> for details on grouping, and their
<code>precision</code>-argument to get more details on the distance of strings
to be treated as equal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.frq</code></td>
<td>
<p>Numeric, indicating the minimum frequency for which a
value will be shown in the output (except for the missing values, prevailing
<code>show.na</code>). Default value for <code>min.frq</code> is <code>0</code>, so all value
frequencies are shown. All values or categories that have less than
<code>min.frq</code> occurences in the data will be summarized in a <code>"n &lt; 100"</code>
category.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out</code></td>
<td>
<p>Character vector, indicating whether the results should be printed
to console (<code>out = "txt"</code>) or as HTML-table in the viewer-pane
(<code>out = "viewer"</code>) or browser (<code>out = "browser"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>String, will be used as alternative title to the variable
label. If <code>x</code> is a grouped data frame, <code>title</code> must be a
vector of same length as groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>Character vector, indicating the charset encoding used
for variable and value labels. Default is <code>"UTF-8"</code>. Only used
when <code>out</code> is not <code>"txt"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Destination file, if the output should be saved as file.
Only used when <code>out</code> is not <code>"txt"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ...-argument not only accepts variable names or expressions
from select-helpers. You can also use logical
conditions, math operations, or combining variables to produce "crosstables".
See 'Examples' for more details.
</p>


<h3>Value</h3>

<p>A list of data frames with values, value labels, frequencies, raw, valid and
cumulative percentages of <code>x</code>.
</p>


<h3>Note</h3>

<p><code>x</code> may also be a grouped data frame (see <code>group_by</code>)
with up to two grouping variables. Frequency tables are created for each
subgroup then.
<br><br>
The <code>print()</code>-method adds a table header with information on the
variable label, variable type, total and valid N, and mean and
standard deviations. Mean and SD are <em>always</em> printed, even for
categorical variables (factors) or character vectors. In this case,
values are coerced into numeric vector to calculate the summary
statistics.
<br><br>
To print tables in markdown or HTML format, use <code>print_md()</code> or
<code>print_html()</code>.
</p>


<h3>See Also</h3>

<p><code>flat_table</code> for labelled (proportional) tables.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simple vector
data(efc)
frq(efc$e42dep)

# with grouped data frames, in a pipe
library(dplyr)
efc %&gt;%
  group_by(e16sex, c172code) %&gt;%
  frq(e42dep)

# show only categories with a minimal amount of frequencies
frq(mtcars$gear)

frq(mtcars$gear, min.frq = 10)

frq(mtcars$gear, min.frq = 15)

# with select-helpers: all variables from the COPE-Index
# (which all have a "cop" in their name)
frq(efc, contains("cop"))

# all variables from column "c161sex" to column "c175empl"
frq(efc, c161sex:c175empl)

# for non-labelled data, variable name is printed,
# and "label" column is removed from output
data(iris)
frq(iris, Species)

# also works on grouped data frames
efc %&gt;%
  group_by(c172code) %&gt;%
  frq(is.na(nur_pst))

# group variables with large range and with weights
efc$weights &lt;- abs(rnorm(n = nrow(efc), mean = 1, sd = .5))
frq(efc, c160age, auto.grp = 5, weights = weights)

# different weight options
frq(efc, c172code, weights = weights)
frq(efc, c172code, weights = "weights")
frq(efc, c172code, weights = efc$weights)
frq(efc$c172code, weights = efc$weights)

# group string values
dummy &lt;- efc[1:50, 3, drop = FALSE]
dummy$words &lt;- sample(
  c("Hello", "Helo", "Hole", "Apple", "Ape",
    "New", "Old", "System", "Systemic"),
  size = nrow(dummy),
  replace = TRUE
)

frq(dummy)
frq(dummy, grp.strings = 2)

#### other expressions than variables

# logical conditions
frq(mtcars, cyl ==6)

frq(efc, is.na(nur_pst), contains("cop"))

iris %&gt;%
  frq(starts_with("Petal"), Sepal.Length &gt; 5)

# computation of variables "on the fly"
frq(mtcars, (gear + carb) / cyl)

# crosstables
set.seed(123)
d &lt;- data.frame(
  var_x = sample(letters[1:3], size = 30, replace = TRUE),
  var_y = sample(1:2, size = 30, replace = TRUE),
  var_z = sample(LETTERS[8:10], size = 30, replace = TRUE)
)
table(d$var_x, d$var_z)
frq(d, paste0(var_x, var_z))
frq(d, paste0(var_x, var_y, var_z))
</code></pre>


</div>