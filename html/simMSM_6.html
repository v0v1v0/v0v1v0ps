<div class="container">

<table style="width: 100%;"><tr>
<td>simeventhistories</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate Event Histories</h2>

<h3>Description</h3>

<p>Simulates n individual event histories.</p>


<h3>Usage</h3>

<pre><code class="language-R">simeventhistories(n, mpl, max.time, change.times, X, states.at.origin = NULL, 
Xstruc, partial.markov.x = NULL, partial.markov.eta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mpl</code></td>
<td>
<p>model parameter list as generated (only a skeleton that has 
to be suitably completed) by the function <code>mplskeleton</code> 
(see examples below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.time</code></td>
<td>
<p>maximum entry time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>change.times</code></td>
<td>
<p>vector giving the times of change of the time-change 
covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>design matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states.at.origin</code></td>
<td>
<p>state-types at origin (default is all possible 
entry state-types, which is internally calculated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xstruc</code></td>
<td>
<p>X structure matrix. See Examples for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial.markov.x</code></td>
<td>
<p>function defining how the partial Markov covariates 
are generated (see example below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial.markov.eta</code></td>
<td>
<p>list of lists (as generated by the function 
<code>pmeskeleton</code> in close analogy to <code>mpl</code>) defining how 
the partial Markov linear predictors are generated (see example below).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The example below provides an intuitive description of how to 
use the different input arguments. 
The idea of partial Markov covariates is based on the definition in 
Commenges (1991). 
A description of this idea directly in the context of illness-death models 
is described on pp. 224-225 in Beyersmann et al. (1999).</p>


<h3>Value</h3>

<p>Three data frames named <code>msm.bascis</code>, <code>ttsce</code>, 
<code>tt.indicators</code> are returned organized within one list. 
The three data frames and their respective variables will be described 
in the next lines.
</p>
<p><code>msm.bascis</code> contains the following variables variables:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>id (1, ..., n) of the individual</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>entry</code></td>
<td>
<p>entry times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exit</code></td>
<td>
<p>exit times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>values of initial states</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>values of final states</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>non-censoring indicator function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>values of first covariate (additional covariates follow). 
If partial Markov objects are supplied, the generated covariates are 
attached as additional variables.</p>
</td>
</tr>
</table>
<p>The second data frame <code>ttsce</code> contains a transition-type specific 
covariate expansion (as well for partial Markov covariates in the case 
of a partial Markov set-up).
</p>
<p>The third data frame <code>tt.indicators</code> contains the values of 
transition-type indicator functions. For censored observations, all 
values of one data line are equal to zero (as e.g. needed in a BayesX 
full likelihood analysis).</p>


<h3>Author(s)</h3>

<p>Holger Reulen</p>


<h3>References</h3>

<p>Daniel Commenges (1991)
Multi-state Models in Epidemiology. 
Lifetime Data Analysis, Vol. 5, No. 4.
</p>
<p>Jan Beyersmann, Martin Schumacher, Arthur Allignol (2012)
Competing Risks and Multistate Models with R. 
Springer Series 'UseR!'.</p>


<h3>See Also</h3>

<p><code>mplskeleton</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## An example for a time-varying setup without partial Markov effects:
tra2 &lt;- matrix(ncol = 2, nrow = 2, data = FALSE)
tra2[1, 2] &lt;- tra2[2, 1] &lt;- TRUE
mpl &lt;- mplskeleton(tmat = tra2)
mpl[[1]]$bhr[[2]] &lt;- mpl[[2]]$bhr[[1]] &lt;- function(t){return(0.5)}
mpl[[1]]$eta[[2]] &lt;- function(x.i, t){ ## time-varying x2 and time-varying f(x2)
  ifelse(t &lt; 5, 
         return(1.0 * x.i[1] + 0.5 * x.i[2]), 
         return(1.0 * x.i[1] + 1.0 * x.i[3]))}
mpl[[2]]$eta[[1]] &lt;- function(x.i, t){ ## time-varying x2 and time-varying f(x1)
  ifelse(t &lt; 5, 
         return(-0.5 * x.i[1] + 0.5 * x.i[2]), 
         return( 1.0 * x.i[1] + 0.5 * x.i[3]))}
set.seed(123)
N &lt;- 2
X &lt;- matrix(nrow = N, ncol = 2, rnorm(2 * N))
X &lt;- cbind(X, X[, 2] + runif(N)/10)
colnames(X) &lt;- c("x1", "x2.t1", "x2.t2")
Xstruc &lt;- matrix(ncol = 2, nrow = 2, data = 0)
rownames(Xstruc) &lt;- c("t1", "t2")
colnames(Xstruc) &lt;- c("x1", "x2")
Xstruc[, 1] &lt;- 1
Xstruc[, 2] &lt;- c(2, 3)
d &lt;- simeventhistories(n = N, mpl = mpl, X = X, max.time = 10, 
                       change.times = c(5), Xstruc = Xstruc)
head(d$msm.basics)
## Not run: 
## An Illness-Death model example with time-varying setup and partial Markov 
## effects:
traIDM &lt;- matrix(nrow = 3, ncol = 3, FALSE)
traIDM[1, 2] &lt;- traIDM[1, 3] &lt;- traIDM[2, 1] &lt;- traIDM[2, 3] &lt;- TRUE
mpl &lt;- mplskeleton(tmat = traIDM)
mpl[[1]]$bhr[[2]] &lt;- mpl[[1]]$bhr[[3]] &lt;- mpl[[2]]$bhr[[1]] &lt;- 
                     mpl[[2]]$bhr[[3]] &lt;- function(t){0.25}
mpl[[1]]$eta[[2]] &lt;- mpl[[1]]$eta[[3]] &lt;- mpl[[2]]$eta[[1]] &lt;- 
  mpl[[2]]$eta[[3]] &lt;- function(x.i, t){
    ifelse(t &lt; 5, 
      return(0.5 * x.i[1]), 
      return(0.5 * x.i[2]))}
set.seed(123)
N &lt;- 500
X &lt;- matrix(nrow = N, ncol = 1, rnorm(N))
X &lt;- cbind(X, X[, 1] + rnorm(N)/10)
colnames(X) &lt;- c("x1.t1", "x1.t2")
Xstruc &lt;- matrix(ncol = 1, nrow = 2, data = 0)
rownames(Xstruc) &lt;- c("t1", "t2")
colnames(Xstruc) &lt;- c("x1")
Xstruc[, 1] &lt;- c(1, 2)
Xstruc
## Now set-up the partial Markov influences:
## Function 'partial.markov.x' has to take 5 input arguments representig vectors 
## of past history information. They have to take names 'entry', 'exit', 'from', 
## 'to', and 'delta':
partial.markov.x &lt;- function(entry, exit, from, to, delta){
  count.12 &lt;- sum(as.numeric((from == 1) &amp; (to == 2) &amp; (delta == 1)))
  count.21 &lt;- sum(as.numeric((from == 2) &amp; (to == 1) &amp; (delta == 1)))
  return(c(count.12, count.21))}
## List 'partial.markov.eta' is a list of lists in analogy to 'mpl':
partial.markov.eta &lt;- pmeskeleton(traIDM)
partial.markov.eta[[1]][[2]] &lt;- function(x){return( 0.25 * x[1])}
partial.markov.eta[[1]][[3]] &lt;- function(x){return( 0.50 * x[1])}
partial.markov.eta[[2]][[1]] &lt;- function(x){return(-0.50 * x[1] + 0.25 * x[2])}
partial.markov.eta[[2]][[3]] &lt;- function(x){return(0)}
## Event history simulation:
d &lt;- simeventhistories(n = N, mpl = mpl, X = X, max.time = 10, 
                       change.times = c(5), Xstruc = Xstruc, 
                       partial.markov.x = partial.markov.x, 
                       partial.markov.eta = partial.markov.eta)

## End(Not run)
</code></pre>


</div>