<div class="container">

<table style="width: 100%;"><tr>
<td>recalib</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibrate weights</h2>

<h3>Description</h3>

<p>Calibrate weights for bootstrap replicates by using iterative proportional
updating to match population totals on various household and personal levels.
</p>


<h3>Usage</h3>

<pre><code class="language-R">recalib(
  dat,
  hid = attr(dat, "hid"),
  weights = attr(dat, "weights"),
  b.rep = attr(dat, "b.rep"),
  period = attr(dat, "period"),
  conP.var = NULL,
  conH.var = NULL,
  conP = NULL,
  conH = NULL,
  epsP = 0.01,
  epsH = 0.02,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>either data.frame or data.table containing the sample survey for
various periods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hid</code></td>
<td>
<p>character specifying the name of the column in <code>dat</code> containing
the household ID.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>character specifying the name of the column in <code>dat</code>
containing the sample weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.rep</code></td>
<td>
<p>character specifying the names of the columns in <code>dat</code>
containing bootstrap weights which should be recalibratet</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>character specifying the name of the column in <code>dat</code> containing
the sample period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conP.var</code></td>
<td>
<p>character vector containig person-specific variables to which
weights should be calibrated or a list of such character vectors.
Contingency tables for the population are calculated per <code>period</code> using
<code>weights</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conH.var</code></td>
<td>
<p>character vector containig household-specific variables to
which weights should be calibrated or a list of such character vectors.
Contingency tables for the population are calculated per <code>period</code> using
<code>weights</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conP</code></td>
<td>
<p>list or (partly) named list defining the constraints on person
level.  The list elements are contingency tables in array representation
with dimnames corresponding to the names of the relevant calibration
variables in <code>dat</code>. If a numerical variable is to be calibrated, the
respective list element has to be named with the name of that numerical
variable. Otherwise the list element shoud NOT be named.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conH</code></td>
<td>
<p>list or (partly) named list defining the constraints on
household level.  The list elements are contingency tables in array
representation with dimnames corresponding to the names of the relevant
calibration variables in <code>dat</code>. If a numerical variable is to be
calibrated, the respective list element has to be named with the name of
that numerical variable. Otherwise the list element shoud NOT be named.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsP</code></td>
<td>
<p>numeric value specifying the convergence limit for <code>conP.var</code>
or <code>conP</code>, see <code>ipf()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsH</code></td>
<td>
<p>numeric value specifying the convergence limit for <code>conH.var</code>
or <code>conH</code>, see <code>ipf()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed on to function <code>ipf()</code> from this
package.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>recalib</code> takes survey data (<code>dat</code>) containing the bootstrap replicates
generated by draw.bootstrap and calibrates weights for each bootstrap
replication according to population totals for person- or household-specific
variables. <br><code>dat</code> must be household data where household members correspond to multiple
rows with the same household identifier. The data should at least containt
the following columns:
</p>

<ul>
<li>
<p> Column indicating the sample period;
</p>
</li>
<li>
<p> Column indicating the household ID;
</p>
</li>
<li>
<p> Column containing the household sample weights;
</p>
</li>
<li>
<p> Columns which contain the bootstrap replicates (see output of
draw.bootstrap);
</p>
</li>
<li>
<p> Columns indicating person- or household-specific variables for which sample
weight should be adjusted.
</p>
</li>
</ul>
<p>For each period and each variable in <code>conP.var</code> and/or <code>conH.var</code> contingency
tables are estimated to get margin totals on personal- and/or
household-specific variables in the population.<br>
Afterwards the bootstrap replicates are multiplied with the original sample
weight and the resulting product ist then adjusted using <code>ipf()</code> to match the
previously calcualted contingency tables. In this process the columns of the
bootstrap replicates are overwritten by the calibrated weights.<br></p>


<h3>Value</h3>

<p>Returns a data.table containing the survey data as well as the
calibrated weights for the bootstrap replicates. The original bootstrap
replicates are overwritten by the calibrated weights. If calibration of a
bootstrap replicate does not converge the bootsrap weight is not returned
and numeration of the returned bootstrap weights is reduced by one.
</p>


<h3>Author(s)</h3>

<p>Johannes Gussenbauer, Alexander Kowarik, Statistics Austria
</p>


<h3>See Also</h3>

<p><code>ipf()</code> for more information on iterative
proportional fitting.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

eusilc &lt;- demo.eusilc(prettyNames = TRUE)

dat_boot &lt;- draw.bootstrap(eusilc, REP = 10, hid = "hid",
                           weights = "pWeight",
                           strata = "region", period = "year")

# calibrate weight for bootstrap replicates
dat_boot_calib &lt;- recalib(dat_boot, conP.var = "gender", conH.var = "region",
                          verbose = TRUE)


# calibrate on other variables
dat_boot_calib &lt;- recalib(dat_boot, conP.var = c("gender", "age"),
                          conH.var = c("region", "hsize"), verbose = TRUE)

# supply contingency tables directly
conP &lt;- xtabs(pWeight ~ age + gender + year, data = eusilc)
conH &lt;- xtabs(pWeight ~ hsize + region + year,
              data = eusilc[!duplicated(paste(db030,year))])
dat_boot_calib &lt;- recalib(dat_boot, conP.var = NULL,
                          conH.var = NULL, conP = list(conP),
                          conH = list(conH), verbose = TRUE)

## End(Not run)

</code></pre>


</div>