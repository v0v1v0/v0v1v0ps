<div class="container">

<table style="width: 100%;"><tr>
<td>createSparseGrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create sparse grid
</h2>

<h3>Description</h3>

<p>Creates nodes and weights that can be used for sparse grid integration. Based on Matlab code by Florian Heiss and Viktor Winschel, available from http://www.sparse-grids.de
</p>


<h3>Usage</h3>

<pre><code class="language-R">createSparseGrid(type, dimension, k, sym = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>String or function for type of 1D integration rule, can take on values
</p>

<dl>
<dt><code>"KPU"</code></dt>
<dd>
<p>Nested rule for unweighted integral over [0,1]</p>
</dd>
<dt><code>"KPN"</code></dt>
<dd>
<p>Nested rule for integral with Gaussian weight</p>
</dd>
<dt><code>"GQU"</code></dt>
<dd>
<p>Gaussian quadrature for unweighted integral over [0,1] (Gauss-Legendre)</p>
</dd>
<dt><code>"GQN"</code></dt>
<dd>
<p>Gaussian quadrature for integral with Gaussian weight (Gauss-Hermite)</p>
</dd>
<dt><code>func</code></dt>
<dd>
<p>any function. Function must accept level k and return a list with two elements <code>nodes</code> and <code>weights</code> for univariate quadrature rule with polynomial exactness 2k-1.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>

<p>dimension of the integration problem.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>Accuracy level. The rule will be exact for polynomial up to total order 2k-1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sym</code></td>
<td>

<p>(optional) only used for own 1D quadrature rule (type not "KPU",...). If
sym is supplied and not FALSE, the code will run faster but will
produce incorrect results if 1D quadrature rule is asymmetric.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The return value contains a list with nodes and weights
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>matrix with a node in each row</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>vector with corresponding weights</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jelmer Ypma
</p>


<h3>References</h3>

<p>Florian Heiss, Viktor Winschel, Likelihood approximation by numerical integration on sparse grids, Journal of Econometrics, Volume 144, Issue 1, May 2008, Pages 62-80, <a href="http://www.sparse-grids.de">http://www.sparse-grids.de</a>
</p>


<h3>See Also</h3>

<p><code>createProductRuleGrid</code>
<code>createMonteCarloGrid</code>
<code>createIntegrationGrid</code>
<code>integrate</code>
<code>pmvnorm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load library
library('SparseGrid')

# define function to be integrated
# g(x) = x[1] * x[2] * ... * x[n]
g &lt;- function( x ) {
	return( prod( x ) )
}

#
# Create sparse integration grid to approximate integral of a function with uniform weights
#
sp.grid &lt;- createSparseGrid( 'KPU', dimension=3, k=5 )

# number of nodes and weights
length( sp.grid$weights )

# evaluate function g in nodes
gx.sp &lt;- apply( sp.grid$nodes, 1, g )

# take weighted sum to get approximation for the integral
val.sp &lt;- gx.sp %*% sp.grid$weights

#
# Create integration grid to approximate integral of a function with uniform weights
#
pr.grid &lt;- createProductRuleGrid( 'KPU', dimension=3, k=5 )

# number of nodes and weights
length( pr.grid$weights )

# evaluate function g in nodes
gx.pr &lt;- apply( pr.grid$nodes, 1, g )

# take weighted sum to get approximation for the integral
val.pr &lt;- gx.pr %*% pr.grid$weights

#
# Create integration grid to approximation integral using Monte Carlo simulation
#
set.seed( 3141 )
mc.grid &lt;- createMonteCarloGrid( runif, dimension=3, num.sim=1000 )

# number of nodes and weights
length( mc.grid$weights )

# evaluate function g in MC nodes
gx.mc   &lt;- apply( mc.grid$nodes, 1, g )

# take weighted sum to get approximation for the integral
# the weights are all equal to 1/1000 in this case
val.mc &lt;- gx.mc %*% mc.grid$weights

val.sp
val.pr
val.mc
</code></pre>


</div>