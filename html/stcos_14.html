<div class="container">

<table style="width: 100%;"><tr>
<td>Covariance Approximation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Best Approximation to Covariance Structure</h2>

<h3>Description</h3>

<p>Compute the best positive approximant for use in the STCOS
model, under several prespecified covariance structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cov_approx_randwalk(Delta, S)

cov_approx_blockdiag(Delta, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Delta</code></td>
<td>
<p>Covariance (<code class="reqn">n \times n</code>) for observations within a time
point for the process whose variance we wish to approximate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Design matrix (<code class="reqn">N \times r</code>) of basis functions evaluated on
the fine-level process over <code class="reqn">T = N / n</code> time points.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">\bm{\Sigma}</code> be an <code class="reqn">N \times N</code> symmetric and positive-definite
covariance matrix and <code class="reqn">\bm{S}</code> be an <code class="reqn">N \times r</code> matrix with
rank <code class="reqn">r</code>. The objective is to compute a matrix <code class="reqn">\bm{K}</code> which minimizes
the Frobenius norm
</p>
<p style="text-align: center;"><code class="reqn">
  \Vert \bm{\Sigma} - \bm{S} \bm{C} \bm{S}^\top {\Vert}_\textrm{F},
</code>
</p>

<p>over symmetric positive-definite matrices <code class="reqn">\bm{C}</code>. The
solution is given by
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{K} = (\bm{S}^\top \bm{S})^{-1} \bm{S}^\top \bm{\Sigma} \bm{S} (\bm{S}^\top \bm{S})^{-1}.
</code>
</p>

<p>In the STCOS model, <code class="reqn">\bm{S}</code> represents the design matrix from a basis
function computed from a fine-level support having <code class="reqn">n</code> areas, using
<code class="reqn">T</code> time steps. Therefore <code class="reqn">N = n T</code> represents the dimension of
covariance for the fine-level support.
</p>
<p>We provide functions to handle some possible structures for target
covariance matrices of the form
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Sigma} =
  \left(
  \begin{array}{ccc}
  \bm{\Gamma}(1,1) &amp; \cdots &amp; \bm{\Gamma}(1,T) \\
  \vdots           &amp; \ddots &amp; \vdots \\
  \bm{\Gamma}(T,1) &amp; \cdots &amp; \bm{\Gamma}(T,T)
  \end{array}
  \right),
</code>
</p>

<p>where each <code class="reqn">\bm{\Gamma}(s,t)</code> is an <code class="reqn">n \times n</code> matrix.
</p>

<ul>
<li> <p><code>cov_approx_randwalk</code> assumes <code class="reqn">\bm{\Sigma}</code> is based on the
autocovariance function of a random walk
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Y}_{t+1} = \bm{Y}_{t} + \bm{\epsilon}_t, \quad \bm{\epsilon}_t \sim \textrm{N}(\bm{0}, \bm{\Delta}).
</code>
</p>

<p>so that
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Gamma}(s,t) = \min(s,t) \bm{\Delta}.
</code>
</p>

</li>
<li> <p><code>cov_approx_blockdiag</code> assumes <code class="reqn">\bm{\Sigma}</code> is based on
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Y}_{t+1} = \bm{Y}_{t} + \bm{\epsilon}_t, \quad \bm{\epsilon}_t \sim \textrm{N}(\bm{0}, \bm{\Delta}).
</code>
</p>

<p>which are independent across <code class="reqn">t</code>, so that
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Gamma}(s,t) = I(s = t) \bm{\Delta},
</code>
</p>

</li>
</ul>
<p>The block structure is used to reduce the computational burden, as <code class="reqn">N</code>
may be large.
</p>


</div>