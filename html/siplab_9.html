<div class="container">

<table style="width: 100%;"><tr>
<td>edges</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Adjust for Edge Effects
</h2>

<h3>Description</h3>


<p>Shrink a point pattern, or expand it through replication.
</p>


<h3>Usage</h3>

<pre><code class="language-R">edges(plants, width)

core(plants, distance)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>plants</code></td>
<td>


<p>A <span class="pkg">spatstat</span> point pattern object (class <code>ppp</code>). It normally contains the plants coordinates, and marks with the plant size and possibly other attributes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>


<p>Distance from the edges to shrink, if negative, or to expand, if positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>


<p>Distance from the edges.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>When computing assimilation or competition indices, those near the edges of the study region are distorted because the outside is empty. Common solutions to this problem are not to use indices computed for plants near the edges, or (with rectangular regions) to attach translated copies, thus changing the topology intothat of a torus. This function implements both strategies. When expanding, the extentt of the copies to be used can be specified to avoid unnecessary computation.
</p>
<p>Typically, in the first case the indices are computed for the full pattern, and then the edges are discarded using <code>edges()</code> with a negative <code>width</code>. In the second case, the point pattern is first expanded with <code>edges(plants, width)</code>, the indices are computed for the expanded pattern, and then the resulta are restricted to the original size with <code>edges(result, -width)</code>. 
</p>
<p><code>core()</code> returns a logical vector indicating which plants are at more than the given distance from the edges. Thus, <code>plants[core(plants, width)]</code> is equivalent to <code>edges(plants, -width)</code>.
</p>


<h3>Value</h3>






<p><code>edges()</code> returns a point pattern with the same structure as <code>plants</code>.
</p>
<p>If <code>width</code> is negative, the parts of the pattern that are at a distance less than <code>-width</code> from an edge are discarded.
</p>
<p>If <code>width</code> is positive, the pattern is first expanded by surrounding it with 8 shifted copies (the window must be rectangular). Then, the parts of the pattern that are at a distance greater than <code>width</code> from an edge of the original pattern are discarded.
</p>
<p>If <code>width</code> = 0, <code>plants</code> is returned unchanged.
</p>
<p><code>core()</code> returns a logical vector with <code>TRUE</code> for the plants that are at more than the given distance from the edges, and <code>FALSE</code> for the rest.
</p>


<h3>Note</h3>


<p>Requires the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>


<p>Oscar Garc√≠a.
</p>


<h3>References</h3>


<p><a href="https://github.com/ogarciav/siplab">https://github.com/ogarciav/siplab</a>
</p>


<h3>See Also</h3>


<p><code>assimilation</code>, <code>pairwise</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">finpines
edges(finpines, 3)
edges(finpines, -3)
</code></pre>


</div>