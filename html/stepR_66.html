<div class="container">

<table style="width: 100%;"><tr>
<td>steppath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution path of step-functions</h2>

<h3>Description</h3>

<p>Find optimal fits with step-functions having jumps at given candidate positions for all possible subset sizes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">steppath(y, ..., max.blocks)
## Default S3 method:
steppath(y, x = 1:length(y), x0 = 2 * x[1] - x[2], max.cand = NULL,
  family = c("gauss", "gaussvar", "poisson", "binomial", "gaussKern"), param = NULL,
  weights = rep(1, length(y)), cand.radius = 0, ..., max.blocks = max.cand)
## S3 method for class 'stepcand'
steppath(y, ..., max.blocks = sum(!is.na(y$number)))
## S3 method for class 'steppath'
x[[i]]
## S3 method for class 'steppath'
length(x)
## S3 method for class 'steppath'
print(x, ...)
## S3 method for class 'steppath'
logLik(object, df = NULL, nobs = object$cand$rightIndex[nrow(object$cand)], ...)
</code></pre>


<h3>Arguments</h3>

<p>for <code>steppath</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>either an object of class <code>stepcand</code> for <code>steppath.stepcand</code> or a numeric vector containing the serial data for <code>steppath.default</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, x0, max.cand, family, param, weights, cand.radius</code></td>
<td>
<p>for <code>steppath.default</code> which calls <code>stepcand</code>; see there</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.blocks</code></td>
<td>
<p>single integer giving the maximal number of blocks to find; defaults to number of candidates (note: there will be one block more than the number of jumps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for generic methods only</p>
</td>
</tr>
</table>
<p>for methods on a <code>steppath</code> object <code>x</code> or <code>object</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>if this is an integer returns the fit with <code>i</code> blocks as an object of class <code>stepcand</code>, else the standard behaviour of a <code>list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the number of estimated parameters: by default the number of blocks for families <code>poisson</code> and <code>binomial</code>, one more (for the variance) for family <code>gauss</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>the number of observations used for estimating</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>steppath</code> an object of class <code>steppath</code>, i.e. a <code>list</code> with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>A list of length <code>length(object)</code> where the <code>i</code>th element contains the best fit by a step-function having <code>i-1</code> jumps (i.e. <code>i</code> blocks), given by the candidates indices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>A numeric vector of length <code>length(object)</code> giving the value of the cost functional corresponding to the solutions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cand</code></td>
<td>
<p>An object of class <code>stepcand</code> giving the candidates among which the jumps were selected.</p>
</td>
</tr>
</table>
<p><code>[[.steppath</code> returns the fit with <code>i</code> blocks as an object of class <code>stepfit</code>; <code>length.steppath</code> the maximum number of blocks for which a fit has been computed. <code>logLik.stepfit</code> returns an object of class <code>logLik</code> giving the likelihood of the data given the fits corresponding to <code>cost</code>, e.g. for use with <code>AIC.</code>
</p>


<h3>References</h3>

<p>Friedrich, F., Kempe, A., Liebscher, V., Winkler, G. (2008) Complexity penalized M-estimation: fast computation. <em>Journal of Computational and Graphical Statistics</em> <b>17</b>(1), 201â€“224.
</p>


<h3>See Also</h3>

<p><code>stepcand</code>, <code>stepfit</code>, family, <code>logLik</code>, <code>AIC</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate 5 blocks (4 jumps) within a total of 100 data points
b &lt;- c(sort(sample(1:99, 4)), 100)
f &lt;- rep(rnorm(5, 0, 4), c(b[1], diff(b)))
# add Gaussian noise
x &lt;- f + rnorm(100)
# find 10 candidate jumps
cand &lt;- stepcand(x, max.cand = 10)
cand
# compute solution path
path &lt;- steppath(cand)
path
plot(x)
lines(path[[5]], col = "red")
# compare result having 5 blocks with truth
fit &lt;- path[[5]]
fit
logLik(fit)
AIC(logLik(fit))
cbind(fit, trueRightEnd = b, trueLevel = unique(f))
# for poisson observations
y &lt;- rpois(100, exp(f / 10) * 20)
# compute solution path, compare result having 5 blocks with truth
cbind(steppath(y, max.cand = 10, family = "poisson")[[5]],
  trueRightEnd = b, trueIntensity = exp(unique(f) / 10) * 20)
# for binomial observations
size &lt;- 10
z &lt;- rbinom(100, size, pnorm(f / 10))
# compute solution path, compare result having 5 blocks with truth
cbind(steppath(z, max.cand = 10, family = "binomial", param = size)[[5]],
  trueRightEnd = b, trueIntensity = pnorm(unique(f) / 10))
# an example where stepcand is not optimal but indices found are close to optimal ones
blocks &lt;- c(rep(0, 9), 1, 3, rep(1, 9))
blocks
stepcand(blocks, max.cand = 3)[,c("rightEnd", "value", "number")]
# erroneously puts the "1" into the right block in the first step
steppath(blocks)[[3]][,c("rightEnd", "value")]
# putting the "1" in the middle block is optimal
steppath(blocks, max.cand = 3, cand.radius = 1)[[3]][,c("rightEnd", "value")]
# also looking in the 1-neighbourhood remedies the problem
</code></pre>


</div>