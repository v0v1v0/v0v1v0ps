<div class="container">

<table style="width: 100%;"><tr>
<td>HierarchyCompute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical Computations</h2>

<h3>Description</h3>

<p>This function computes aggregates by crossing several hierarchical specifications and factorial variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">HierarchyCompute(
  data,
  hierarchies,
  valueVar,
  colVar = NULL,
  rowSelect = NULL,
  colSelect = NULL,
  select = NULL,
  inputInOutput = FALSE,
  output = "data.frame",
  autoLevel = TRUE,
  unionComplement = FALSE,
  constantsInOutput = NULL,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  selectionByMultiplicationLimit = 10^7,
  colNotInDataWarning = TRUE,
  useMatrixToDataFrame = TRUE,
  handleDuplicated = "sum",
  asInput = FALSE,
  verbose = FALSE,
  reOrder = FALSE,
  reduceData = TRUE,
  makeRownames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The input data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchies</code></td>
<td>
<p>A named (names in <code>data</code>) list with hierarchies. Variables can also be coded by <code>"rowFactor"</code> and <code>"colFactor"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valueVar</code></td>
<td>
<p>Name of the variable(s) to be aggregated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colVar</code></td>
<td>
<p>When non-NULL, the function <code>HierarchyCompute2</code> is called. See its documentation for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is not included.
In addition <code>rowSelect="removeEmpty"</code> removes combinations corresponding to empty rows (only zeros) of <code>dataDummyHierarchy</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colSelect</code></td>
<td>
<p>Vector specifying categories of the colFactor variable for output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>One of "data.frame" (default), "dummyHierarchies", "outputMatrix", "dataDummyHierarchy", "valueMatrix", "fromCrossCode",
"toCrossCode", "crossCode" (as toCrossCode), "outputMatrixWithCrossCode", "matrixComponents",
"dataDummyHierarchyWithCodeFrame", "dataDummyHierarchyQuick".
The latter two do not require <code>valueVar</code> (<code>reduceData</code> set to <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoLevel</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, level is computed by automatic method as in <code>HierarchyFix</code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction as in <code>DummyHierarchy</code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constantsInOutput</code></td>
<td>
<p>A single row data frame to be combine by the other output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code>HierarchyFix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>rowSelect</code> and when the number of elements in <code>dataDummyHierarchy</code> exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colNotInDataWarning</code></td>
<td>
<p>When TRUE, warning produced when elements of <code>colSelect</code> are not in data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useMatrixToDataFrame</code></td>
<td>
<p>When TRUE (default) special functionality for saving time and memory is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handleDuplicated</code></td>
<td>
<p>Handling of duplicated code rows in data. One of: "sum" (default), "sumByAggregate", "sumWithWarning", "stop" (error), "single" or "singleWithWarning".
With no colFactor sum and sumByAggregate/sumWithWarning are different (original values or aggregates in "valueMatrix").
When single, only one of the values is used (by matrix subsetting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asInput</code></td>
<td>
<p>When TRUE (FALSE is default) output matrices match input data. Thus
<code>valueMatrix</code> <code>=</code> <code>Matrix(data[, valueVar],ncol=1)</code>. Only possible when no colFactor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reOrder</code></td>
<td>
<p>When TRUE (FALSE is default) output codes are ordered differently, more similar to a usual model matrix ordering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduceData</code></td>
<td>
<p>When TRUE (default) unnecessary (for the aggregated result) rows of <code>valueMatrix</code> are allowed to be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>makeRownames</code></td>
<td>
<p>When TRUE <code>dataDummyHierarchy</code> contains rownames. By default, this is decided based on the parameter <code>output</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A key element of this function is the matrix multiplication:
<code>outputMatrix</code> <code>=</code> <code>dataDummyHierarchy</code> <code>%*%</code> <code>valueMatrix</code>.
The matrix, <code>valueMatrix</code> is a re-organized version of the valueVar vector from input. In particular,
if a variable is selected as <code>colFactor</code>, there is one column for each level of that variable.
The matrix, <code>dataDummyHierarchy</code> is constructed by crossing dummy coding of hierarchies (<code>DummyHierarchy</code>) and factorial variables
in a way that matches <code>valueMatrix</code>.  The code combinations corresponding to rows and columns of <code>dataDummyHierarchy</code>
can be obtained as <code>toCrossCode</code> and <code>fromCrossCode</code>.  In the default data frame output, the <code>outputMatrix</code> is stacked
to one column and combined with the code combinations of all variables.
</p>


<h3>Value</h3>

<p>As specified by the parameter <code>output</code>
</p>


<h3>Author(s)</h3>

<p>Ã˜yvind Langsrud
</p>


<h3>See Also</h3>

<p><code>Hierarchies2ModelMatrix</code>, <code>AutoHierarchies</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Data and hierarchies used in the examples
x &lt;- SSBtoolsData("sprt_emp")  # Employment in sport in thousand persons from Eurostat database
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

# Two hierarchies and year as rowFactor
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per")

# Same result with year as colFactor (but columns ordered differently)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per")

# Internally the computations are different as seen when output='matrixComponents'
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 output = "matrixComponents")
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")


# Include input age groups by setting inputInOutput = TRUE for this variable
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 inputInOutput = c(TRUE, FALSE))

# Only input age groups by switching to rowFactor
HierarchyCompute(x, list(age = "rowFactor", geo = geoHier, year = "colFactor"), "ths_per")

# Select some years (colFactor) including a year not in input data (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 colSelect = c("2014", "2016", "2018"))

# Select combinations of geo and age including a code not in data or hierarchy (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 rowSelect = data.frame(geo = "EU", age = c("Y0-100", "Y15-64", "Y15-29")))
                 
# Select combinations of geo, age and year 
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
     select = data.frame(geo = c("EU", "Spain"), age = c("Y15-64", "Y15-29"), year = 2015))

# Extend the hierarchy table to illustrate the effect of unionComplement 
# Omit level since this is handled by autoLevel
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  geoHier[, -4])

# Spain is counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per")

# Can be seen in the dataDummyHierarchy matrix
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")

# With unionComplement=TRUE Spain is not counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 unionComplement = TRUE)

# With constantsInOutput
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per",
                 constantsInOutput = data.frame(c1 = "AB", c2 = "CD"))
                 
# More that one valueVar
x$y &lt;- 10*x$ths_per
HierarchyCompute(x, list(age = ageHier, geo = geoHier), c("y", "ths_per"))
</code></pre>


</div>