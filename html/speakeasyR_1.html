<div class="container">

<table style="width: 100%;"><tr>
<td>cluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SpeakEasy 2 community detection</h2>

<h3>Description</h3>

<p>Group nodes into communities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cluster(
  graph,
  discard_transient = 3,
  independent_runs = 10,
  max_threads = 0,
  seed = 0,
  target_clusters = 0,
  target_partitions = 5,
  subcluster = 1,
  min_clust = 5,
  verbose = FALSE,
  is_directed = "detect"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A graph or adjacency matrix in a form that can be converted to
<code>matrix</code> or <code>Matrix::dgCMatrix</code> using an <code>as.matrix()</code> coercion method.
Accepted types include <code>matrix</code>, <code>dgCMatrix</code>, <code>ngCMatrix</code>, and
<code>igraph::graph</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discard_transient</code></td>
<td>
<p>The number of partitions to discard before tracking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>independent_runs</code></td>
<td>
<p>How many runs SpeakEasy2 should perform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_threads</code></td>
<td>
<p>The maximum number of threads to use. By default this is
the same as the number of independent runs. If max_threads is greater than
or equal to the number of processing cores, all cores may run. If
max_threads is less than the number of cores, at most max_threads cores
will run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed to use for reproducible results. SpeakEasy2 uses a
different random number generator than R, but if the seed is not
explicitly set, R's random number generator is used create one. Because of
this, setting R's RNG will also cause reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_clusters</code></td>
<td>
<p>The number of random initial labels to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_partitions</code></td>
<td>
<p>Number of partitions to find per independent run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subcluster</code></td>
<td>
<p>Depth of clustering. If greater than 1, perform recursive
clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_clust</code></td>
<td>
<p>Smallest clusters to recursively cluster. If subcluster not
set to a value greater than 1, this has no effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to provide additional information about the
clustering or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_directed</code></td>
<td>
<p>Whether the graph should be treated as directed or not.
By default, if the graph is symmetric it is treated as undirected.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A membership vector. If subclustering, returns a matrix with number
of rows equal to the number of recursive clustering. Each row is the
membership at different hierarchical scales, such that the last rows are
the highest resolution.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require("igraph")) {
  graph &lt;- igraph::graph.famous("zachary")
  membership &lt;- cluster(graph, max_threads = 2)
}
</code></pre>


</div>