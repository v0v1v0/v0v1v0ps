<div class="container">

<table style="width: 100%;"><tr>
<td>SSAsave</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Identification of Non-stationarity in Variance
</h2>

<h3>Description</h3>

<p>SSAsave method for identifying non-stationarity in variance
</p>


<h3>Usage</h3>

<pre><code class="language-R">SSAsave(X, ...)

## Default S3 method:
SSAsave(X, K, n.cuts = NULL, ...)
## S3 method for class 'ts'
SSAsave(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>.
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. Algorithm first calculates matrix
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = \sum_{i = 1}^K \frac{T_i}{T}({\bf I} - {\bf S}_{T_i}) ({\bf I} - {\bf S}_{T_i})^T,</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, <code class="reqn">{\bf I}</code> is an identity matrix, and <code class="reqn">{\bf S}_{T_i}</code> is the sample variance of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> via eigendecomposition
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = {\bf UDU}^T.</code>
</p>

<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf U}</code> are the eigenvectors corresponding to the non-zero eigenvalues and the rest correspond to the zero eigenvalues. In the same way, the first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of components with non-stationary variance, and the last <code class="reqn">p-k</code> rows to the subspace of components with stationary variance. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>W </code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M </code></td>
<td>
<p>Used separation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K </code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p>Eigenvalues of M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU </code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cut </code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method </code></td>
<td>
<p>Name of the method ("SSAsave"), to be used in e.g. screeplot.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code>JADE</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 5000
A &lt;- rorth(4)

z1 &lt;- rtvvar(n, alpha = 0.2, beta = 0.5)
z2 &lt;- rtvvar(n, alpha = 0.1, beta = 1)
z3 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24))) 
z4 &lt;- arima.sim(n, model = list(ar = c(0.34, 0.27, 0.18)))

Z &lt;- cbind(z1, z2, z3, z4)
X &lt;- as.ts(tcrossprod(Z, A)) # An mts object

res &lt;- SSAsave(X, K = 6)
res$D # Two non-zero eigenvalues
screeplot(res, type = "lines") # This can also be seen in screeplot
ggscreeplot(res, type = "lines") # ggplot version of screeplot

# Plotting the components as an mts object
plot(res) # The first two are nonstationary in variance


</code></pre>


</div>