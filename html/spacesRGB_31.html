<div class="container">

<table style="width: 100%;"><tr>
<td>composition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The composition of TransferFunction objects</h2>

<h3>Description</h3>

<p>The function <code>composition(TF1,TF2)</code> returns a <code>TransferFunction</code> that is 
<code>TF1</code> followed by <code>TF2</code>.
Four equivalent infix operators are also available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'TransferFunction'
composition( TF1, TF2 )

## S3 method for class 'TransferFunction'
 TF1 * TF2 
## S3 method for class 'TransferFunction'
 TF1 %;% TF2 
## S3 method for class 'TransferFunction'
 TF1 %X% TF2 
## S3 method for class 'TransferFunction'
 TF2 %O% TF1 

identity.TF

## S3 method for class 'TransferFunction'
is.identity( TF )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>TF1</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TF2</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TF</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In order to be composed, the dimensions of <code>TF1</code> and <code>TF2</code> must be equal,
or the dimension of one of them must be 1.
In the latter case, the function is applied to each coordinate in exactly the same way.
</p>
<p>All the above represent the function <code>TF1</code> followed by <code>TF2</code>.
In mathematics this operation is usually called <em>composition of functions</em>
(and <em>composition of morphisms</em> in category theory),
and in computer science and BT.2100 and BT.2390 it is called the <em>concatenation</em>.
In BT.2390 it is also called the <em>cascade</em>.
</p>
<p>The ACES literature uses infix notation with the symbol <code>'+'</code> 
which is unfortunate because in mathematics
the plus symbol is only used for commutative operations, which composition certainly is not.
The symbol <code>'*'</code> is offered here as an alternative,
since <code>'*'</code> does not imply commutativity (e.g. as in MATLAB's matrix multiplication).
In computer science the symbol <code>';'</code> is common, and so <code>%;%</code> is offered as an alternative.
In BT.2100 and BT.2390 the symbol   ⊗  is used, and so <code>%X%</code> is offered as an alternative.
And finally, in mathematics   ○  is used but in the opposite order,
so that <code>TF2 %O% TF1</code> is identical to <code>composition(TF1,TF2)</code>.
<br>
Each <code>TransferFunction</code> object is actually a list of so-called <em>elementary</em> transfer functions.
If <code>TF1</code> has <code class="reqn">M_1</code> elementary functions and <code>TF2</code> has <code class="reqn">M_2</code> elementary functions,
then <code>composition(TF1,TF2)</code> has <code class="reqn">\le M_1 + M_2</code> elementary functions.
It can be strictly less if there is cancellation of elementary functions at the end of <code>TF1</code>
and the beginning of <code>TF2</code>.
</p>


<h3>Value</h3>

<p><code>composition(TF1,TF2)</code> returns a <code>TransferFunction</code> object,
which applies <code>TF1</code> followed by <code>TF2</code>.
The individual objects <code>TF1</code> and <code>TF2</code> are stored  inside the returned object.
In case of ERROR it returns <code>NULL</code>.
The 4 infix operators above all invoke <code>composition()</code>.
</p>
<p><code>identity.TF</code> is a built-in global <code>TransferFunction</code> object which is a 
universal identity for composition.
This means that for any <code>TransferFunction</code>  <code>TF</code>,  
<code>TF*identity.TF = identity.TF*TF = TF</code>.
Moreover, <code>TF*TF^-1 = TF^1*TF = identity.TF</code>.
This is *not* the same as <code>base::identity()</code>.
</p>
<p><code>is.identity(TF)</code> tests whether <code>TF</code> is the universal identity,
and returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>References</h3>

<p>Technical Bulletin.
TB-2018-002.
ACES Output Transform Details.
June 2018 (draft).
</p>
<p>ACES Retrospective and Enhancements
March 2017.
</p>
<p>BT.2100.
Image parameter values for high dynamic range television for use in production
and international programme exchange.
June 2017.
</p>
<p>BT.2390.
High dynamic range television for production and international programme exchange.
April 2018.
</p>


<h3>See Also</h3>

<p><code>TransferFunction</code>,
<code>transfer()</code>,
<code>inverse()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">comp = power.OOTF(2.2) * power.OOTF(1.4)
x = 0:100 / 100
max( abs( transfer(comp,x) - transfer(power.OOTF(2.2*1.4),x) ) )  #  1.110223e-16

comp * comp^-1
## This is a universal identity TransferFunction.

is.identity(comp * comp^-1)          # TRUE

identical( comp * identity.TF, comp )  # TRUE
</code></pre>


</div>