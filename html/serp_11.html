<div class="container">

<table style="width: 100%;"><tr>
<td>serp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Smooth Effects on Response Penalty for CLM</h2>

<h3>Description</h3>

<p>Fits cumulative link models (CLMs) with the
smooth-effect-on-response penalty (SERP) via a modified Newton-Raphson
algorithm. SERP enables the regularization of the parameter space between
the general and the restricted cumulative models, with a resultant shrinkage
of all subject-specific effects to global effects. The Akaike information
critrion (<code>aic</code>), K-fold cross validation (<code>cv</code>), among other tuning
aproaches, provide the means of arriving at an optimal tuning parameter in a
in a situation where a user-supplied tuning value is not available.
The <code>slope</code> argument allows for the selection of a penalized, unparallel,
parallel, or partial slope.
</p>


<h3>Usage</h3>

<pre><code class="language-R">serp(
     formula,
     link = c("logit", "probit","loglog", "cloglog", "cauchit"),
     slope = c("penalize", "parallel", "unparallel", "partial"),
     tuneMethod = c("aic", "cv", "finite", "user"),
     reverse = FALSE,
     lambdaGrid = NULL,
     cvMetric = c("brier", "logloss", "misclass"),
     gridType = c("discrete", "fine"),
     globalEff = NULL,
     data,
     subset,
     weights = NULL,
     weight.type = c("analytic", "frequency"),
     na.action = NULL,
     lambda = NULL,
     contrasts = NULL,
     control = list(),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>regression formula of the form: response ~ predictors. The
response should be a factor (ordered).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>sets the link function for the cumulative link model including:
logit, probit, complementary log-log, cloglog, cauchit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope</code></td>
<td>
<p>selects the form of coefficients used in the model, with
<code>penalize</code> denoting the penalized coefficients, <code>unparallel</code>,
<code>parallel</code> and <code>partial</code> denoting the unpenalized non-parallel,
parallel and semi-parallel coefficients respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuneMethod</code></td>
<td>
<p>sets the method of choosing an optimal shrinkage
parameter, including: <code>aic</code>, <code>cv</code>, <code>finite</code> and
<code>user</code>. i.e., the lambda value along parameter shrinkage path at
which the fit's AIC or the k-fold cross-validated test error is
minimal. The finite tuning is used to obtain the model along parameter
shrinkage for which the log-Likelihood exist (is finite). The 'user'
tuning supports a user-supplied lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>false by default, when true the sign of the linear predictor
is reversed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaGrid</code></td>
<td>
<p>optional user-supplied lambda grid for the <code>aic</code>,
and <code>cv</code> tuning methods, when the discrete <code>gridType</code>
is chosen. Negative range of values are not allowed. A short lambda grid
could increase computation time assuming large number of predictors and
cases in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvMetric</code></td>
<td>
<p>sets the performance metric for the cv tuning, with the
brier score used by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridType</code></td>
<td>
<p>chooses if a discrete or a continuous lambda grid should be
used to select the optimal tuning parameter. The former is used by default
and could be adjusted as desired in <code>serp.control</code>. The latter
is on the range (0, <code>maxPen</code>). A user-supplied grid is also possible,
which automatically overrides the internal grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globalEff</code></td>
<td>
<p>specifies variable(s) to be assigned global effects during
penalization or when <code>slope</code> is set to <code>partial</code>. Variables are
specified as a formula with an empty left hand side, for instance,
globalEff = ~predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional dataframe explaining the variables used in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>specifies which subset of the rows of the data should be used
for fit. All observations are used by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional case weights in fitting. Negative weights are not
allowed. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.type</code></td>
<td>
<p>chooses between analytic and frequency weights with the
former used by default. The latter should be used when weights are mere
case counts used to compress the data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function to filter missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a user-supplied single numeric value for the tuning parameter
when using the <code>user</code> tuning method. Negative values are not
allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of the
factors appearing as variables in the model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of fit control parameters to replace default values
returned by <code>serp.control</code>. Values not set assume default values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>serp</code> function fits the cumulative link model (CLM)
with smooth-effect-on-response penalty (SERP). The cumulative
model developed by McCullagh (1980) is probably most frequently
used ordinal model. When motivated by an underlying latent
variable, a simple form of the model is expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">P(Y\leq r|x) = F(\delta_{0r} + x^T\delta)</code>
</p>

<p>where <code class="reqn">x</code> is a vector of covariates, <code class="reqn">\delta</code> a vector
of regression parameters and <code class="reqn">F</code> a continuous distribution
function. This model assumes that the effect of <code class="reqn">x</code> does not
depend on the  category. However, with this assumption relaxed,
one obtains the following general cumulative model:
</p>
<p style="text-align: center;"><code class="reqn">P(Y\leq r|x) = F(\delta_{0r} + x^T\delta_{r}),</code>
</p>

<p>where r=1,...,k-1. This model, however, has the stochastic ordering
property, which implies that <code class="reqn">P(Y\leq r-1|x) &lt; P(Y\leq r|x)</code>
holds for all <code class="reqn">x</code> and all categories <code class="reqn">r</code>. Such assumption
is often problematic, resulting in unstable likelihoods with
ill-conditioned parameter space during the iterative procedure.
</p>
<p>SERP offers a means of arriving at stable estimates of the general model.
It provides a form of regularization that is based on minimizing the
penalized log-likelihood:
</p>
<p style="text-align: center;"><code class="reqn">l_{p}(\delta)=l(\delta)-J_{\lambda}(\delta)</code>
</p>

<p>where <code class="reqn">l(\delta)</code>, is the log-likelihood of the general cumulative
model and <code class="reqn">J_{\lambda}(\delta)=\lambda J(\delta)</code> the penalty
function weighted by the turning parameter <code class="reqn">\lambda</code>. Assuming an
ordered categorical outcome <code class="reqn">Y \in \{1,\dots,k\}</code>, and considering
that the corresponding parameters <code class="reqn">\delta_{1j},\dots \delta_{k-1,j}</code>
vary smoothly over the categories, the following penalty
(Tutz and Gertheiss, 2016),
</p>
<p style="text-align: center;"><code class="reqn">J_{\lambda}(\delta)= \sum_{j=1}^{p} \sum_{r=1}^{k-2}
(\delta_{r+1,j}-\delta_{rj})^{2}</code>
</p>

<p>enables the smoothing of response categories such that all
category-specific effects associated with the response turn towards a
common global effect. SERP could also be applied to a semi-parallel model
with only the category-specific part of the model penalized. See,
Ugba (2021), Ugba et al. (2021) for further details and application in
empirical studies.
</p>
<p>An object of class <code>serp</code> with the components listed below,
depending on the type of slope modeled. Other summary methods include:
<code>summary</code>, <code>coef</code>, <code>predict</code>, <code>vcov</code>,
<code>anova</code>, etc.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>the akaike information criterion, with effective degrees of
freedom obtained from the trace of the generalized hat matrix
depending on the tuning parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bic</code></td>
<td>
<p>the bayesian information criterion, with effective degrees of
freedom obtained from the trace of the generalized hat matrix
depending on the tuning parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>a vector of coefficients of the fitted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>a character vector of fit convergence status.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of control parameters from <code>serp.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvMetric</code></td>
<td>
<p>the performance metric used for cv tuning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>the residual deviance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>the (effective) number of degrees of freedom used by the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globalEff</code></td>
<td>
<p>variable(s) in model treated as global effect(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>a column vector of gradients for the coefficients at the
model convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hessian</code></td>
<td>
<p>the hessian matrix for the coefficients at the model
convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of interactions before convergence or non-convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a user-supplied single numeric value for the <code>user</code>
tuning tuning method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaGrid</code></td>
<td>
<p>a numeric vector of lambda values used to determine the
optimum tuning parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLik</code></td>
<td>
<p>the realized log-likelihood at the model convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>character vector indicating the link function of the fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>character vector stating the type of convergence obtained</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>misc</code></td>
<td>
<p>a list to hold miscellaneous fit information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model.frame having variables from formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>(where relevant) information on the treatment of NAs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrFold</code></td>
<td>
<p>the number of k-fold cross validation for the cv tuning
method. Default to k = 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rdf</code></td>
<td>
<p>the residual degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>a logical vector indicating the the direction of the
cumulative probabilities. Default to P(Y&lt;=r).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope</code></td>
<td>
<p>a character vector indicating the type of slope parameters
fitted. Default to <code>penalize</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Terms</code></td>
<td>
<p>the terms structure describing the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testError</code></td>
<td>
<p>numeric value of the cross-validated test error at which
the optimal tuning parameter emerged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuneMethod</code></td>
<td>
<p>a character vector specifying the method for choosing an
optimal shrinkage parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>numeric value of AIC or logLik obtained at the optimal tuning
parameter when using <code>aic</code> or <code>finite</code> tuning methods respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylev</code></td>
<td>
<p>the number of the response levels.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Ugba, E. R. (2021). serp: An R package for smoothing in ordinal regression
<em>Journal of Open Source Software</em>, 6(66), 3705.
https://doi.org/10.21105/joss.03705
</p>
<p>Ugba, E. R., Mörlein, D. and Gertheiss, J. (2021). Smoothing in Ordinal
Regression: An Application to Sensory Data. <em>Stats</em>, 4, 616–633.
https://doi.org/10.3390/stats4030037
</p>
<p>Tutz, G. and Gertheiss, J. (2016). Regularized Regression
for Categorical Data (With Discussion and Rejoinder).
<em>Statistical Modelling</em>, 16, pp. 161-260.
https://doi.org/10.1177/1471082X16642560
</p>
<p>McCullagh, P. (1980). Regression Models for Ordinal Data.
<em>Journal of the Royal Statistical Society. Series B
(Methodological)</em>, 42, pp. 109-142.
https://doi.org/10.1111/j.2517-6161.1980.tb01109.x
</p>


<h3>See Also</h3>

<p><code>anova.serp</code>, <code>summary.serp</code>,
<code>predict.serp</code>, <code>confint.serp</code>,
<code>vcov.serp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(serp)

## The unpenalized non-proportional odds model returns unbounded estimates, hence,
## not fully identifiable.
f1 &lt;- serp(rating ~ temp + contact, slope = "unparallel",
           reverse = TRUE, link = "logit", data = wine)
coef(f1)

## The penalized non-proportional odds model with a user-supplied lambda gives
## a fully identified model with bounded estimates. A suitable tuning criterion
## could as well be used to select lambda (e.g., aic, cv)
f2 &lt;- serp(rating ~ temp + contact, slope = "penalize",
           link = "logit", reverse = TRUE, tuneMethod = "user",
           lambda = 1e1, data = wine)
coef(f2)

## A penalized partial proportional odds model with some variables set to
## global effect is also possible.
f3 &lt;- serp(rating ~ temp + contact, slope = "penalize",
           reverse = TRUE, link = "logit", tuneMethod = "user",
           lambda = 2e1, globalEff = ~ temp, data = wine)
coef(f3)


## The unpenalized proportional odds model having constrained estimates can
## as well be fit. Under extreme shrinkage, estimates in f2 equal those in
## this model.
f4 &lt;-  serp(rating ~ temp + contact, slope = "parallel",
            reverse = FALSE, link = "logit", data = wine)
summary(f4)

</code></pre>


</div>