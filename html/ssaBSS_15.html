<div class="container">

<table style="width: 100%;"><tr>
<td>SSAcomb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Combination Main SSA Methods
</h2>

<h3>Description</h3>

<p>SSAcomb method for identification for non-stationarity in mean, variance and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SSAcomb(X, ...)

## Default S3 method:
SSAcomb(X, K, n.cuts = NULL, tau = 1, eps = 1e-6, maxiter = 2000, ...)
## S3 method for class 'ts'
SSAcomb(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The lag as a scalar or a vector. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>. 
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. For all lags <code class="reqn">j = 1, ..., ntau</code>, algorithm first calculates the <code class="reqn">{\bf M}</code> matrices from SSAsir (matrix <code class="reqn">{\bf M}_1</code>), SSAsave (matrix <code class="reqn">{\bf M}_2</code>) and SSAcor (matrices <code class="reqn">{\bf M}_{j+2}</code>).
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^{ntau+2} ||\textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}')||^2.</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, ntau + 2</code>. The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf US}^{-1/2}</code>.
</p>
<p>Then the pseudo eigenvalues <code class="reqn">{\bf D}_i = \textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}') = \textrm{diag}(d_{i,1}, \ldots, d_{i,p})</code> are obtained and the value of <code class="reqn">d_{i,j}</code> tells if the <code class="reqn">j</code>th component is nonstationary with respect to <code class="reqn">{\bf M}_i</code>.
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>W </code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R </code></td>
<td>
<p>Used M-matrices as an array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K </code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p>The sums of pseudo eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DTable </code></td>
<td>
<p>The peudo eigenvalues of size <em>ntau + 2</em> to see which type of nonstationarity there exists in each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU </code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cut </code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k </code></td>
<td>
<p>The used lag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method </code></td>
<td>
<p>Name of the method ("SSAcomb"), to be used in e.g. screeplot.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code>JADE</code> <code>frjd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 10000
A &lt;- rorth(6)

z1 &lt;- arima.sim(n, model = list(ar = 0.7)) + rep(c(-1.52, 1.38), 
        c(floor(n*0.5), n - floor(n*0.5)))
z2 &lt;- rtvAR1(n)
z3 &lt;- rtvvar(n, alpha = 0.2, beta = 0.5)
z4 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24), ar = c(0.14, 0.45)))
z5 &lt;- arima.sim(n, model = list(ma = c(0.34))) 
z6 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.15)))

Z &lt;- cbind(z1, z2, z3, z4, z5, z6)
library(xts)
X &lt;- tcrossprod(Z, A)
X &lt;- xts(X, order.by = as.Date(1:n)) # An xts object

res &lt;- SSAcomb(X, K = 12, tau = 1)
ggscreeplot(res, type = "lines") # Three non-zero eigenvalues
res$DTable # Components have different kind of nonstationarities

# Plotting the components as an xts object
plot(res, multi.panel = TRUE) # The first three are nonstationary


</code></pre>


</div>