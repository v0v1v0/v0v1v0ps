<div class="container">

<table style="width: 100%;"><tr>
<td>thin_base</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Base binomial thinning function.</h2>

<h3>Description</h3>

<p>Given a matrix of counts (<code class="reqn">Y</code>) where <code class="reqn">log_2(E[Y]) = Q</code>,
a design matrix (<code class="reqn">X</code>), and a matrix of coefficients (<code class="reqn">B</code>),
<code>thin_diff</code> will generate a new matrix of counts such that
<code class="reqn">log_2(E[Y]) = BX' + u1' + Q</code>, where <code class="reqn">u</code> is some vector
of intercept coefficients. This function is used by all other
thinning functions. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class="language-R">thin_base(mat, designmat, coefmat, relative = TRUE, type = c("thin", "mult"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>designmat</code></td>
<td>
<p>A design matrix. The rows index the samples and the columns
index the variables. The intercept should <em>not</em> be included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefmat</code></td>
<td>
<p>A matrix of coefficients. The rows index the genes and the
columns index the samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>
<p>A logical. Should we apply relative thinning (<code>TRUE</code>)
or absolute thinning (<code>FALSE</code>). Only experts should change
the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix of new RNA-seq read-counts. This matrix has the signal
added from <code>designmat</code> and <code>coefmat</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul><li>
<p>Gerard, D (2020). "Data-based RNA-seq simulations by binomial thinning." <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>
<h3>See Also</h3>


<dl>
<dt><code>select_counts</code></dt>
<dd>
<p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code>thin_diff</code></dt>
<dd>
<p>For the function most users should
be using for general-purpose binomial thinning.</p>
</dd>
<dt><code>thin_2group</code></dt>
<dd>
<p>For the specific application of
thinning in the two-group model.</p>
</dd>
<dt><code>thin_lib</code></dt>
<dd>
<p>For the specific application of
library size thinning.</p>
</dd>
<dt><code>thin_gene</code></dt>
<dd>
<p>For the specific application of
total gene expression thinning.</p>
</dd>
<dt><code>thin_all</code></dt>
<dd>
<p>For the specific application of
thinning all counts uniformly.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 10
ngene &lt;- 1000
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 100), nrow = ngene)
X &lt;- matrix(rep(c(0, 1), length.out = nsamp))
B &lt;- matrix(seq(3, 0, length.out = ngene))
Ynew &lt;- thin_base(mat = Y, designmat = X, coefmat = B)

## Demonstrate how the log2 effect size is B
Bhat &lt;- coefficients(lm(t(log2(Ynew)) ~ X))["X", ]
plot(B, Bhat, xlab = "Coefficients", ylab = "Coefficient Estimates")
abline(0, 1, col = 2, lwd = 2)

</code></pre>


</div>