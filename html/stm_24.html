<div class="container">

<table style="width: 100%;"><tr>
<td>makeDesignMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make a Design Matrix</h2>

<h3>Description</h3>

<p>Create a sparse model matrix which respects the basis functions
of the original data on which it was created. Primarily for internal
use but may be of some independent interest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeDesignMatrix(formula, origData, newData, test = TRUE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the formula describing the design matrix.  Any responses will be deleted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origData</code></td>
<td>
<p>the original dataset as a dataframe</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newData</code></td>
<td>
<p>a dataframe containing any of the variables in the formula.  This will provide
the data in the returned model matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>when set to TRUE runs a test that the matrix was constructed correctly
see details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>by default returns a sparse matrix using <code>sparse.model.matrix</code> in 
<span class="pkg">Matrix</span></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions is designed to be used in settings where we need
to make a prediction using a model matrix.  The practical challenge
here is ensuring that the representation of the data lines up
with the original representation.  This becomes challenging for
functions that produce a different representation depending on their
inputs. A simple conceptual example is factor variables.  If we run 
our original model using a factor with levels <code>c("A","B", "C")</code>
then when we try to make predictions for data having only levels
<code>c("A","C")</code> we need to adjust for the missing level.  Base
R functions like <code>predict.lm</code> in <span class="pkg">stats</span> handle 
this gracefully and this function is essentially a version of 
<code>predict.lm</code> that only constructs the model matrix.
</p>
<p>Beyond factors the key use case for this are basis functions like
splines.  For a function like this to work it must either depend only
on the observation it is transforming (e.g. <code>log</code>) or it must
have a generic for <code>predict</code> and <code>makepredictcall</code>.
The spline wrapper <code>s</code> has both and so should work.
</p>
<p>When a function lacks these methods it will still produce a design matrix
but the values will be wrong.  To catch these settings we implement a quick
test when <code>test=TRUE</code> as it is by default.  To test we simply split
the original data in half and ensure that looking at each half separately produces
the same values as the complete original data.
</p>


<h3>See Also</h3>

<p><code>fitNewDocuments</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">foo &lt;- data.frame(response=rnorm(30),
                  predictor=as.factor(rep(c("A","B","C"),10)), 
                  predictor2=rnorm(30))
foo.new &lt;- data.frame(predictor=as.factor(c("A","C","C")), 
                      predictor2=foo$predictor2[1:3])
makeDesignMatrix(~predictor + s(predictor2), foo, foo.new)
</code></pre>


</div>