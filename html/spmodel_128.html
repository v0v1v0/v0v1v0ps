<div class="container">

<table style="width: 100%;"><tr>
<td>predict.spmodel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model predictions (Kriging)</h2>

<h3>Description</h3>

<p>Predicted values and intervals based on a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'splm'
predict(
  object,
  newdata,
  se.fit = FALSE,
  scale = NULL,
  df = Inf,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  type = c("response", "terms"),
  local,
  terms = NULL,
  ...
)

## S3 method for class 'spautor'
predict(
  object,
  newdata,
  se.fit = FALSE,
  scale = NULL,
  df = Inf,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  type = c("response", "terms"),
  local,
  terms = NULL,
  ...
)

## S3 method for class 'splm_list'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'spautor_list'
predict(
  object,
  newdata,
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  local,
  ...
)

## S3 method for class 'splmRF'
predict(object, newdata, local, ...)

## S3 method for class 'spautorRF'
predict(object, newdata, local, ...)

## S3 method for class 'splmRF_list'
predict(object, newdata, local, ...)

## S3 method for class 'spautorRF_list'
predict(object, newdata, local, ...)

## S3 method for class 'spglm'
predict(
  object,
  newdata,
  type = c("link", "response", "terms"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  dispersion = NULL,
  terms = NULL,
  local,
  var_correct = TRUE,
  newdata_size,
  ...
)

## S3 method for class 'spgautor'
predict(
  object,
  newdata,
  type = c("link", "response", "terms"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  dispersion = NULL,
  terms = NULL,
  local,
  var_correct = TRUE,
  newdata_size,
  ...
)

## S3 method for class 'spglm_list'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)

## S3 method for class 'spgautor_list'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  newdata_size,
  level = 0.95,
  local,
  var_correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A fitted model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>A data frame or <code>sf</code> object in which to
look for variables with which to predict. If a data frame, <code>newdata</code>
must contain all variables used by <code>formula(object)</code> and all variables
representing coordinates. If an <code>sf</code> object, <code>newdata</code> must contain
all variables used by <code>formula(object)</code> and coordinates are obtained
from the geometry of <code>newdata</code>. If omitted, missing data from the
fitted model object are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>A logical indicating if standard errors are returned.
The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A numeric constant by which to scale the regular standard errors and intervals.
Similar to but slightly different than <code>scale</code> for <code>stats::predict.lm()</code>, because
predictions form a spatial model may have different residual variances for each
observation in <code>newdata</code>. The default is <code>NULL</code>, which returns
the regular standard errors and intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degrees of freedom to use for confidence or prediction intervals
(ignored if <code>scale</code> is not specified). The default is <code>Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Type of interval calculation. The default is <code>"none"</code>.
Other options are <code>"confidence"</code> (for confidence intervals) and
<code>"prediction"</code> (for prediction intervals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Tolerance/confidence level. The default is <code>0.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The prediction type, either on the response scale, link scale (only for
<code>spglm()</code> or <code>spgautor()</code> model objects), or terms scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local</code></td>
<td>
<p>A optional logical or list controlling the big data approximation. If omitted, <code>local</code>
is set to <code>TRUE</code> or <code>FALSE</code> based on the observed data sample size (i.e., sample size of the fitted
model object) â€“ if the sample size exceeds 10,000, <code>local</code> is
set to <code>TRUE</code>, otherwise it is set to <code>FALSE</code>. This default behavior
occurs because main computational
burden of the big data approximation depends almost exclusively on the
observed data sample size, not the number of predictions desired
(which we feel is not intuitive at first glance).
If <code>local</code> is <code>FALSE</code>, no big data approximation
is implemented. If a list is provided, the following arguments detail the big
data approximation:
</p>

<ul>
<li> <p><code>method</code>: The big data approximation method. If <code>method = "all"</code>,
all observations are used and <code>size</code> is ignored. If <code>method = "distance"</code>,
the <code>size</code> data observations closest (in terms of Euclidean distance)
to the observation requiring prediction are used.
If <code>method = "covariance"</code>, the <code>size</code> data observations
with the highest covariance with the observation requiring prediction are used.
If random effects and partition factors are not used in estimation and
the spatial covariance function is monotone decreasing,
<code>"distance"</code> and <code>"covariance"</code> are equivalent. The default
is <code>"covariance"</code>. Only used with models fit using <code>splm()</code> or <code>spglm()</code>.
</p>
</li>
<li> <p><code>size</code>: The number of data observations to use when <code>method</code>
is <code>"distance"</code> or <code>"covariance"</code>. The default is 100. Only used
with models fit using <code>splm()</code> or <code>spglm()</code>.
</p>
</li>
<li> <p><code>parallel</code>: If <code>TRUE</code>, parallel processing via the
parallel package is automatically used. This can significantly speed
up computations even when <code>method = "all"</code> (i.e., no big data
approximation is used), as predictions
are spread out over multiple cores. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>ncores</code>: If <code>parallel = TRUE</code>, the number of cores to
parallelize over. The default is the number of available cores on your machine.
</p>
</li>
</ul>
<p>When <code>local</code> is a list, at least one list element must be provided to
initialize default arguments for the other list elements.
If <code>local</code> is <code>TRUE</code>, defaults for <code>local</code> are chosen such
that <code>local</code> is transformed into
<code>list(size = 100, method = "covariance", parallel = FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>If <code>type</code> is <code>"terms"</code>, the type of terms to be returned,
specified via either numeric position or name. The default is all terms are included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments. Only used for models fit using <code>splmRF()</code>
or <code>spautorRF()</code> where <code>...</code> indicates other
arguments to <code>ranger::predict.ranger()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>The dispersion of assumed when computing the prediction standard errors
for <code>spglm()</code> or <code>spgautor()</code> model objects when <code>family</code>
is <code>"nbinomial"</code>, <code>"beta"</code>, <code>"Gamma"</code>, or <code>"inverse.gaussian"</code>.
If omitted, the model object dispersion parameter is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_correct</code></td>
<td>
<p>A logical indicating whether to return the corrected prediction
variances when predicting via models fit using <code>spglm()</code> or <code>spgautor()</code>. The default is
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata_size</code></td>
<td>
<p>The <code>size</code> value for each observation in <code>newdata</code>
used when predicting for the binomial family.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>splm</code> and <code>spautor</code> objects, the (empirical) best linear unbiased predictions (i.e., Kriging
predictions) at each site are returned when <code>interval</code> is <code>"none"</code>
or <code>"prediction"</code> alongside standard errors. Prediction intervals
are also returned if <code>interval</code> is <code>"prediction"</code>. When
<code>interval</code> is <code>"confidence"</code>, the estimated mean is returned
alongside standard errors and confidence intervals for the mean. For <code>splm_list</code>
and <code>spautor_list</code> objects, predictions and associated intervals and standard errors are returned
for each list element.
</p>
<p>For <code>splmRF</code> or <code>spautorRF</code> objects, random forest spatial residual
model predictions are computed by combining the random forest prediction with
the (empirical) best linear unbiased prediction for the residual. Fox et al. (2020)
call this approach random forest regression Kriging. For <code>splmRF_list</code>
or <code>spautorRF</code> objects,
predictions are returned for each list element.
</p>


<h3>Value</h3>

<p>For <code>splm</code> or <code>spautor</code> objects, if <code>se.fit</code> is <code>FALSE</code>, <code>predict()</code> returns
a vector of predictions or a matrix of predictions with column names
<code>fit</code>, <code>lwr</code>, and <code>upr</code> if <code>interval</code> is <code>"confidence"</code>
or <code>"prediction"</code>. If <code>se.fit</code> is <code>TRUE</code>, a list with the following components is returned:
</p>

<ul>
<li> <p><code>fit</code>: vector or matrix as above
</p>
</li>
<li> <p><code>se.fit</code>: standard error of each fit
</p>
</li>
</ul>
<p>For <code>splm_list</code> or <code>spautor_list</code> objects, a list that contains relevant quantities for each
list element.
</p>
<p>For <code>splmRF</code> or <code>spautorRF</code> objects, a vector of predictions. For <code>splmRF_list</code>
or <code>spautorRF_list</code> objects, a list that contains relevant quantities for each list element.
</p>


<h3>References</h3>

<p>Fox, E.W., Ver Hoef, J. M., &amp; Olsen, A. R. (2020). Comparing spatial
regression to random forests for large environmental data sets.
<em>PloS one</em>, 15(3), e0229509.
</p>


<h3>Examples</h3>

<pre><code class="language-R">spmod &lt;- splm(sulfate ~ 1,
  data = sulfate,
  spcov_type = "exponential", xcoord = x, ycoord = y
)
predict(spmod, sulfate_preds)
predict(spmod, sulfate_preds, interval = "prediction")
augment(spmod, newdata = sulfate_preds, interval = "prediction")

sulfate$var &lt;- rnorm(NROW(sulfate)) # add noise variable
sulfate_preds$var &lt;- rnorm(NROW(sulfate_preds)) # add noise variable
sprfmod &lt;- splmRF(sulfate ~ var, data = sulfate, spcov_type = "exponential")
predict(sprfmod, sulfate_preds)


spgmod &lt;- spglm(presence ~ elev * strat,
  family = "binomial",
  data = moose,
  spcov_type = "exponential"
)
predict(spgmod, moose_preds)
predict(spgmod, moose_preds, interval = "prediction")
augment(spgmod, newdata = moose_preds, interval = "prediction")

</code></pre>


</div>