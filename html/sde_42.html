<div class="container">

<table style="width: 100%;"><tr>
<td>sde.sim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of stochastic differential equation</h2>

<h3>Description</h3>

<p>Generic interface to different methods of simulation of solutions to stochastic
differential equations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sde.sim(t0 = 0, T = 1, X0 = 1, N = 100, delta, drift, sigma, 
   drift.x, sigma.x, drift.xx, sigma.xx, drift.t, 
   method = c("euler", "milstein", "KPS", "milstein2", 
   "cdist","ozaki","shoji","EA"), 
   alpha = 0.5, eta = 0.5, pred.corr = T, rcdist = NULL, 
   theta = NULL, model = c("CIR", "VAS", "OU", "BS"),
   k1, k2, phi, max.psi = 1000, rh, A, M=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>t0</code></td>
<td>
<p>time origin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>horizon of simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X0</code></td>
<td>
<p>initial value of the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of simulation steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of trajectories.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>time step of the simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drift</code></td>
<td>
<p>drift coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>diffusion coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drift.x</code></td>
<td>
<p>partial derivative of the drift coefficient w.r.t. <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.x</code></td>
<td>
<p>partial derivative of the diffusion coefficient w.r.t.  <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drift.xx</code></td>
<td>
<p>second partial derivative of the drift coefficient w.r.t.  <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.xx</code></td>
<td>
<p>second partial derivative of the diffusion coefficient w.r.t. <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drift.t</code></td>
<td>
<p>partial derivative of the drift coefficient w.r.t.  <code>t</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method of simulation; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>weight <code>alpha</code> of the predictor-corrector scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>weight <code>eta</code> of the predictor-corrector scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.corr</code></td>
<td>
<p>boolean: whether to apply the predictor-correct adjustment; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rcdist</code></td>
<td>
<p>a function that is a random number generator from the conditional distribution of the process; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector of parameters for <code>cdist</code>; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model from which to simulate; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k1</code></td>
<td>
<p>lower bound for <code>psi(x)</code>; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>
<p>upper bound for <code>psi(x)</code>; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>the function <code>psi(x) - k1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.psi</code></td>
<td>
<p>upper value of the support of <code>psi</code> to search for its maximum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rh</code></td>
<td>
<p>the rejection function; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p><code>A(x)</code> is the integral of the <code>drift</code> between <code>0</code> and <code>x</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function returns a <code>ts</code> object of length <code>N+1</code>; i.e., <code>X0</code> and
the new <code>N</code> simulated values if <code>M=1</code>.
For <code>M&gt;1</code>, an <code>mts</code> (multidimensional <code>ts</code> object) is returned, which
means that <code>M</code> independent trajectories are simulated. 
If the initial value <code>X0</code> is not of the length <code>M</code>, the values are recycled
in order to have an initial vector of the correct length. 
If <code>delta</code> is not specified, then <code>delta = (T-t0)/N</code>.
If <code>delta</code> is specified, then <code>N</code>  values of the solution of the sde are generated and
the time horizon <code>T</code> is adjusted to be <code>N * delta</code>.
</p>
<p>The function <code>psi</code> is <code>psi(x) = 0.5*drift(x)^2 + 0.5*drift.x(x)</code>.
</p>
<p>If any of <code>drift.x</code>, <code>drift.xx</code>, <code>drift.t</code>,
<code>sigma.x</code>, and <code>sigma.xx</code> are not specified,
then numerical derivation is attempted when needed.
</p>
<p>If <code>sigma</code> is not specified, it is assumed to be the constant function <code>1</code>.
</p>
<p>The <code>method</code> of simulation can be one among: <code>euler</code>, <code>KPS</code>, <code>milstein</code>,
<code>milstein2</code>,  <code>cdist</code>, <code>EA</code>, <code>ozaki</code>, and <code>shoji</code>. 
No assumption on the coefficients or on <code>cdist</code> is checked: the user is 
responsible for using the right method for the process object of simulation.
</p>
<p>The <code>model</code> is one among: <code>CIR</code>: Cox-Ingersoll-Ross, <code>VAS</code>: Vasicek,
<code>OU</code> Ornstein-Uhlenbeck, <code>BS</code>: Black and Scholes. 
No assumption on the coefficient <code>theta</code> is checked: the user is responsible 
for using the right ones.
</p>
<p>If the <code>method</code> is <code>cdist</code>, then the process is simulated according to its
known conditional distribution. The random generator <code>rcdist</code> must be a 
function of <code>n</code>, the number of random numbers; <code>dt</code>, the time lag; 
<code>x</code>, the value of the process at time <code>t</code> - <code>dt</code>; and the
vector of parameters <code>theta</code>.
</p>
<p>For the exact algorithm method <code>EA</code>: if missing <code>k1</code> and <code>k2</code> as well 
as <code>A</code>, <code>rh</code> and <code>phi</code> are calculated numerically by the function.
</p>


<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>returns an invisible <code>ts</code> object</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>See Chapter 2 of the text.</p>


<h3>Examples</h3>

<pre><code class="language-R"># Ornstein-Uhlenbeck process
set.seed(123)
d &lt;- expression(-5 * x)
s &lt;- expression(3.5) 
sde.sim(X0=10,drift=d, sigma=s) -&gt; X
plot(X,main="Ornstein-Uhlenbeck")

# Multiple trajectories of the O-U process
set.seed(123)
sde.sim(X0=10,drift=d, sigma=s, M=3) -&gt; X
plot(X,main="Multiple trajectories of O-U")

# Cox-Ingersoll-Ross process
# dXt = (6-3*Xt)*dt + 2*sqrt(Xt)*dWt
set.seed(123)
d &lt;- expression( 6-3*x ) 
s &lt;- expression( 2*sqrt(x) ) 
sde.sim(X0=10,drift=d, sigma=s) -&gt; X
plot(X,main="Cox-Ingersoll-Ross")

# Cox-Ingersoll-Ross using the conditional distribution "rcCIR"

set.seed(123)
sde.sim(X0=10, theta=c(6, 3, 2), rcdist=rcCIR, 
        method="cdist") -&gt; X
plot(X, main="Cox-Ingersoll-Ross")

set.seed(123)
sde.sim(X0=10, theta=c(6, 3, 2), model="CIR") -&gt; X
plot(X, main="Cox-Ingersoll-Ross")

# Exact simulation
set.seed(123)
d &lt;- expression(sin(x))
d.x &lt;- expression(cos(x)) 
A &lt;- function(x) 1-cos(x)
sde.sim(method="EA", delta=1/20, X0=0, N=500, 
        drift=d, drift.x = d.x, A=A) -&gt; X
plot(X, main="Periodic drift")
</code></pre>


</div>