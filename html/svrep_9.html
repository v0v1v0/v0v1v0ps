<div class="container">

<table style="width: 100%;"><tr>
<td>calibrate_to_sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibrate weights from a primary survey to estimated totals from a control survey,
with replicate-weight adjustments that account for variance of the control totals</h2>

<h3>Description</h3>

<p>Calibrate the weights of a primary survey to match estimated totals from a control survey,
using adjustments to the replicate weights to account for the variance of the estimated control totals.
The adjustments to replicate weights are conducted using the method proposed by Opsomer and Erciulescu (2021).
This method can be used to implement general calibration as well as post-stratification or raking specifically
(see the details for the <code>calfun</code> parameter).
</p>


<h3>Usage</h3>

<pre><code class="language-R">calibrate_to_sample(
  primary_rep_design,
  control_rep_design,
  cal_formula,
  calfun = survey::cal.linear,
  bounds = list(lower = -Inf, upper = Inf),
  verbose = FALSE,
  maxit = 50,
  epsilon = 1e-07,
  variance = NULL,
  control_col_matches = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>primary_rep_design</code></td>
<td>
<p>A replicate design object for the primary survey, created with either the <code>survey</code> or <code>srvyr</code> packages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_rep_design</code></td>
<td>
<p>A replicate design object for the control survey.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cal_formula</code></td>
<td>
<p>A formula listing the variables to use for calibration.
All of these variables must be included in both <code>primary_rep_design</code> and <code>control_rep_design</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calfun</code></td>
<td>
<p>A calibration function from the <code>survey</code> package,
such as cal.linear, cal.raking, or cal.logit.
Use <code>cal.linear</code> for ordinary post-stratification, and <code>cal.raking</code> for raking.
See calibrate for additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Parameter passed to grake for calibration. See calibrate for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Parameter passed to grake for calibration. See calibrate for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Parameter passed to grake for calibration. See calibrate for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Parameter passed to grake for calibration. <br>
After calibration, the absolute difference between each calibration target and the calibrated estimate
will be no larger than <code>epsilon</code> times (1 plus the absolute value of the target).
See calibrate for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>Parameter passed to grake for calibration. See calibrate for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_col_matches</code></td>
<td>
<p>Optional parameter to specify which control survey replicate
is matched to each primary survey replicate. If the <code class="reqn">i-th</code> entry of <code>control_col_matches</code>
equals <code class="reqn">k</code>, then replicate <code class="reqn">i</code> in <code>primary_rep_design</code> is matched
to replicate <code class="reqn">k</code> in <code>control_rep_design.</code>
Entries of <code>NA</code> denote a primary survey replicate not matched to any control survey replicate.
If this parameter is not used, matching is done at random.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>With the Opsomer-Erciulescu method, each column of replicate weights from the control survey
is randomly matched to a column of replicate weights from the primary survey,
and then the column from the primary survey is calibrated to control totals estimated by
perturbing the control sample's full-sample estimates using the estimates from the
matched column of replicate weights from the control survey.
<br><br>
If there are fewer columns of replicate weights in the control survey than in the primary survey,
then not all primary replicate columns will be matched to a replicate column from the control survey. <br></p>
<p>If there are more columns of replicate weights in the control survey than in the primary survey,
then the columns of replicate weights in the primary survey will be duplicated <code>k</code> times, where <code>k</code> is the smallest
positive integer such that the resulting number of columns of replicate weights for the primary survey is greater than or equal
to the number of columns of replicate weights in the control survey. <br></p>
<p>Because replicate columns of the control survey are matched <em>at random</em> to primary survey replicate columns,
there are multiple ways to ensure that this matching is reproducible.
The user can either call set.seed before using the function,
or supply a mapping to the argument <code>control_col_matches</code>.
</p>


<h3>Value</h3>

<p>A replicate design object, with full-sample weights calibrated to totals from <code>control_rep_design</code>,
and replicate weights adjusted to account for variance of the control totals.
If <code>primary_rep_design</code> had fewer columns of replicate weights than <code>control_rep_design</code>,
then the number of replicate columns and the length of <code>rscales</code> will be increased by a multiple <code>k</code>,
and the <code>scale</code> will be updated by dividing by <code>k</code>. <br><br>
The element <code>control_column_matches</code> indicates, for each replicate column of the calibrated primary survey,
which column of replicate weights it was matched to from the control survey.
Columns which were not matched to control survey replicate column are indicated by <code>NA</code>. <br><br>
The element <code>degf</code> will be set to match that of the primary survey
to ensure that the degrees of freedom are not erroneously inflated by
potential increases in the number of columns of replicate weights.
</p>


<h3>Syntax for Common Types of Calibration</h3>

<p>For ratio estimation with an auxiliary variable <code>X</code>,
use the following options: <br>
- <code>cal_formula = ~ -1 + X</code> <br>
- <code>variance = 1</code>, <br>
- <code>cal.fun = survey::cal.linear</code>
</p>
<p>For post-stratification, use the following option:
</p>
<p>- <code>cal.fun = survey::cal.linear</code>
</p>
<p>For raking, use the following option:
</p>
<p>- <code>cal.fun = survey::cal.raking</code>
</p>


<h3>References</h3>

<p>Opsomer, J.D. and A. Erciulescu (2021).
"Replication variance estimation after sample-based calibration."
<strong>Survey Methodology</strong>, <em>47</em>: 265-277.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# Load example data for primary survey ----

  suppressPackageStartupMessages(library(survey))
  data(api)

  primary_survey &lt;- svydesign(id=~dnum, weights=~pw, data=apiclus1, fpc=~fpc) |&gt;
    as.svrepdesign(type = "JK1")

# Load example data for control survey ----

  control_survey &lt;- svydesign(id = ~ 1, fpc = ~fpc, data = apisrs) |&gt;
    as.svrepdesign(type = "JK1")

# Calibrate totals for one categorical variable and one numeric ----

  calibrated_rep_design &lt;- calibrate_to_sample(
    primary_rep_design = primary_survey,
    control_rep_design = control_survey,
    cal_formula = ~ stype + enroll,
  )

# Inspect estimates before and after calibration ----

  ##_ For the calibration variables, estimates and standard errors
  ##_ from calibrated design will match those of the control survey

    svytotal(x = ~ stype + enroll, design = primary_survey)
    svytotal(x = ~ stype + enroll, design = control_survey)
    svytotal(x = ~ stype + enroll, design = calibrated_rep_design)

  ##_ Estimates from other variables will be changed as well

    svymean(x = ~ api00 + api99, design = primary_survey)
    svymean(x = ~ api00 + api99, design = control_survey)
    svymean(x = ~ api00 + api99, design = calibrated_rep_design)

# Inspect weights before and after calibration ----

  summarize_rep_weights(primary_survey, type = 'overall')
  summarize_rep_weights(calibrated_rep_design, type = 'overall')

# For reproducibility, specify how to match replicates between surveys ----

  column_matching &lt;- calibrated_rep_design$control_col_matches
  print(column_matching)

  calibrated_rep_design &lt;- calibrate_to_sample(
    primary_rep_design = primary_survey,
    control_rep_design = control_survey,
    cal_formula = ~ stype + enroll,
    control_col_matches = column_matching
  )

## End(Not run)
</code></pre>


</div>