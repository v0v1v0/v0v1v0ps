<div class="container">

<table style="width: 100%;"><tr>
<td>rigider</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Rigid Transformation
</h2>

<h3>Description</h3>

<p>Find the optimal rigid transformation for a spatial field (e.g. an image).
</p>


<h3>Usage</h3>

<pre><code class="language-R">
rigider(x1, x0, p0, init = c(0, 0, 0), type = c("regular", "fast"),
    translate = TRUE, rotate = FALSE, loss, loss.args = NULL,
    interp = "bicubic", stages = TRUE,
    verbose = FALSE, ...)

## S3 method for class 'rigided'
plot(x, ...)

## S3 method for class 'rigided'
print(x, ...)

## S3 method for class 'rigided'
summary(object, ...)

rigidTransform(theta, p0, N, cen)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1, x0</code></td>
<td>

<p>matrices of same dimensions giving the forecast (or 1-energy) and observation (or 0-energy) fields, resp.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>list object of class “rigided” as output by <code>rigider</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>(optional) the dimension of the fields (i.e., if <code>x1</code> and <code>x0</code> are n by m, then <code>N</code> is the product m * n).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cen</code></td>
<td>
<p>N by 2 matrix whoes rows are all the same giving the center of the field (used to subtract before determining rotations, etc.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>

<p>N by 2 matrix giving the coordinates for the 0-energy (observed) field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>(optional) numeric vector of length equal to the number of parameters (e.g., 2 for translation only, 3 for both, and 1 for rotation only).  If missing, then these will be estimated by taking the difference in centroids (translation) and the difference in orientation angles (rotation) as determined using image moments by way of <code>imomenter</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>numeric vector of length 1, 2 or 3 (depending on whether you want to translate only (2), rotate only (1) or both (3)) giving the rigid transformation parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character stating whether to optimize a loss function or just find the centroid (and possibly orientation angle) difference(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>translate, rotate</code></td>
<td>

<p>logical, should the optimal translation/rotation be found?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>

<p>character naming a loss function (see details) to use in optimizing the rigid transformation (defaults to square error loss.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss.args</code></td>
<td>

<p>named list giving any optional arguments to <code>loss</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interp</code></td>
<td>

<p>character naming the 2-d interpolation method to use in calls to <code>Fint2d</code>.  Must be one of “round” (default), “bilinear” or “bicubic”.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stages</code></td>
<td>

<p>logical.  Should the optimal translation be found before finding both the optimal tranlsation and rotation?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical.  Should progress information be printed to the screen?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>optional arguments to <code>nlminb</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A rigid transformation translates coordinates of values in a matrix and/or rotates them.  That is, if (r, s) are coordinates in a field with center (c1, c2), then the rigid transformation with parameters (x, y) and theta is given by:
</p>
<p>(r, s) + (x, y) + Phi ((r, s) - (c1, c2)),
</p>
<p>where Phi is the matrix with first column given by (cos( theta ), - sin( theta)) and second column given by (sin( theta), cos( theta )).
</p>
<p>The optimal transformation is found by way of numerical optimization using the <code>nlminb</code> function on the loss function given by <code>loss</code>.  If no value is given for <code>loss</code>, then square error loss is assumed.  In this case, the loss function is based on an assumption of Gaussian errors, but this assumption is only important if you try to make inferences based on this model, in which case you should probably think much harder about what you are doing.  In particular, the default objective function, Q, is given by:
</p>
<p>Q = - sum( ( F(W(s)) - O(s) )^2 / (2 * sigma^2) - (N / 2) * log( sigma^2 ),
</p>
<p>where s are the coordinates, W(s) are the rigidly transformed coordinates, F(W(s)) is the value of the 1-enegy field (forecast) evaluated at W(s) (which is interpolated as the translations typically do not give integer translations), O(s) is the 0-energy (observed) field evaluated at coordinate s, and sigma^2 is the estimated variance of the error field.  A good alternative is to use “QcorrRigid”, which calculates the correlation between F and O instead, and has been found by some to give better performance.
</p>
<p>The function <code>rigidTransform</code> performs a rigid transform for given parameter values.  It is intended as an internal function, but may be of use to some users.
</p>


<h3>Value</h3>

<p>A list object of class “rigided” is returned with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p>the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>translation.only </code></td>
<td>
<p>If stages argument is true, this part is the optimal translation before rotation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate</code></td>
<td>
<p> optimal translation and rotation together, if stages argument is true.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>initial values used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interp.method</code></td>
<td>
<p> same as input argument interp.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.args</code></td>
<td>
<p>optional arguments passed to nlminb.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss, loss.args</code></td>
<td>
<p>same as input arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>optimal parameter values found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>value of loss function at optimal parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0, x1, p0</code></td>
<td>
<p>same as input arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>transformed p0 coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1.transformed</code></td>
<td>
<p>The field F(W(s)).</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Finding the optimal rigid transformation can be very tricky when applying both rotatons and translations.  This function helps, but for some fields may require more user input than is ideal, and should be considered experimental for the time being; as the examples will demonstrate.  It does seem to work well for translations only, which has been the recommended course of action for the CRA method.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>See Also</h3>

<p><code>nlminb</code>, <code>Fint2d</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Simple uninteresting example for the R robots.
x &lt;- y &lt;- matrix(0, 20, 40)

x[ 12:18, 2:3 ] &lt;- 1

y[ 13:19, 5:6 ] &lt;- 1

xycoords &lt;- cbind(rep(1:20, 40), rep(1:40, each = 20))

tmp &lt;- rigider(x1 = x, x0 = y, p0 = xycoords)
tmp
plot(tmp)

# Rotate a coordinate system.
data( "geom000" )

loc &lt;- cbind(rep(1:601, 501), rep(1:501, each = 601))

# Rotate the coordinates by pi / 4.
th &lt;- c(0, 0, pi / 4)
names(th) &lt;- c("x", "y", "rotation")
cen &lt;- colMeans(loc[ geom000 &gt; 0, ])
loc2 &lt;- rigidTransform(theta = th, p0 = loc, cen = cen)

geom101 &lt;- Fint2d(X = geom000, Ws = loc2, s = loc, method = "round")

## Not run: 

image.plot(geom101)

# Try to find the optimal rigid transformation.
# First, allow a translation as well as rotation.

tmp &lt;- rigider(x1 = geom101, x0 = geom000, p0 = loc,
    rotate = TRUE, verbose = TRUE)
tmp
plot(tmp)

# Now, only allow rotation, which does not work as
# well as one would hope.
tmp &lt;- rigider(x1 = geom101, x0 = geom000, p0 = loc,
    translate = FALSE, rotate = TRUE, verbose = TRUE)
tmp
plot(tmp)

# Using correlation.
tmp &lt;- rigider(x1 = geom101, x0 = geom000, p0 = loc,
    rotate = TRUE, loss = "QcorrRigid", verbose = TRUE)
tmp
summary(tmp)
plot(tmp)

##
## Examples from ICP phase 1.
##
## Geometric cases.
##

data( "geom001" )
data( "geom002" )
data( "geom003" )
data( "geom004" )
data( "geom005" )


tmp &lt;- rigider(x1 = geom001, x0 = geom000, p0 = loc, verbose = TRUE)
tmp
plot(tmp)

tmp &lt;- rigider(x1 = geom002, x0 = geom000, p0 = loc, verbose = TRUE)
tmp
plot(tmp)

tmp &lt;- rigider(x1 = geom003, x0 = geom000, p0 = loc, verbose = TRUE)
tmp
plot(tmp)

tmp &lt;- rigider(x1 = geom004, x0 = geom000, p0 = loc, verbose = TRUE)
tmp
plot(tmp)

# Note: Above is a scale error rather than a rotation, but can we
# approximate it with a rotation?
tmp &lt;- rigider(x1 = geom004, x0 = geom000, p0 = loc, rotate = TRUE,
    verbose = TRUE)
tmp
plot(tmp)
# Ok, maybe need to give it better starting values?  Or, run it again
# with just the translation.

tmp &lt;- rigider(x1 = geom005, x0 = geom000, p0 = loc, verbose = TRUE)
tmp
plot(tmp)



## End(Not run)
</code></pre>


</div>