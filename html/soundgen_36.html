<div class="container">

<table style="width: 100%;"><tr>
<td>audSpectrogram</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auditory spectrogram</h2>

<h3>Description</h3>

<p>Produces an auditory spectrogram by convolving the sound with a bank of
bandpass filters. The main difference from STFT is that we don't window the
signal and de facto get variable temporal resolution in different frequency
channels, as with a wavelet transform. The key settings are
<code>filterType</code>, <code>nFilters</code>, and <code>yScale</code>, which determine the
type, number, and spacing of the filters, respectively. Gammatone filters
were designed as a simple approximation of human perception - see
<code>gammatone</code> and Slaney 1993 "An Efficient Implementation
of the Patterson–Holdsworth Auditory Filter Bank". Butterworth or Chebyshev
filters are not meant to model perception, but can be useful for quickly
plotting a sound.
</p>


<h3>Usage</h3>

<pre><code class="language-R">audSpectrogram(
  x,
  samplingRate = NULL,
  scale = NULL,
  from = NULL,
  to = NULL,
  step = 1,
  dynamicRange = 80,
  filterType = c("butterworth", "chebyshev", "gammatone")[1],
  nFilters = 128,
  nFilters_oct = NULL,
  filterOrder = if (filterType == "gammatone") 4 else 3,
  bandwidth = NULL,
  bandwidthMult = 1,
  minFreq = 20,
  maxFreq = samplingRate/2,
  minBandwidth = 10,
  output = c("audSpec", "audSpec_processed", "filterbank", "filterbank_env", "roughness"),
  reportEvery = NULL,
  cores = 1,
  plot = TRUE,
  savePlots = NULL,
  plotFilters = FALSE,
  osc = c("none", "linear", "dB")[2],
  heights = c(3, 1),
  ylim = NULL,
  yScale = c("bark", "mel", "ERB", "log")[1],
  contrast = 0.2,
  brightness = 0,
  maxPoints = c(1e+05, 5e+05),
  padWithSilence = TRUE,
  colorTheme = c("bw", "seewave", "heat.colors", "...")[1],
  col = NULL,
  extraContour = NULL,
  xlab = NULL,
  ylab = NULL,
  xaxp = NULL,
  mar = c(5.1, 4.1, 4.1, 2),
  main = NULL,
  grid = NULL,
  width = 900,
  height = 500,
  units = "px",
  res = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>path to a folder, one or more wav or mp3 files c('file1.wav',
'file2.mp3'), Wave object, numeric vector, or a list of Wave objects or
numeric vectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingRate</code></td>
<td>
<p>sampling rate of <code>x</code> (only needed if <code>x</code> is a
numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>maximum possible amplitude of input used for normalization of
input vector (only needed if <code>x</code> is a numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from, to</code></td>
<td>
<p>if NULL (default), analyzes the whole sound, otherwise
from...to (s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>step, ms (determines time resolution of the plot, but not of the
returned envelopes per channel). step = NULL means no downsampling at all
(ncol of output = length of input audio)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dynamicRange</code></td>
<td>
<p>dynamic range, dB. All values more than one dynamicRange
under maximum are treated as zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filterType</code></td>
<td>
<p>"butterworth" = Butterworth filter
<code>butter</code>, "chebyshev" = Chebyshev filter
<code>butter</code>, "gammatone" =
<code>gammatone</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nFilters</code></td>
<td>
<p>the number of filters between <code>minFreq</code> and
<code>maxFreq</code> (determines frequency resolution, while <code>yScale</code>
determines the location of center frequencies)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nFilters_oct</code></td>
<td>
<p>an alternative way to specify frequency resolution: the
number of filters per octave</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filterOrder</code></td>
<td>
<p>filter order (defaults to 4 for gammatones, 3 otherwise)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>filter bandwidth, octaves. If NULL, defaults to ERB
bandwidths as in <code>gammatone</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidthMult</code></td>
<td>
<p>a scaling factor for all bandwidths (1 = no effect)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minFreq, maxFreq</code></td>
<td>
<p>the range of frequencies to analyze</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minBandwidth</code></td>
<td>
<p>minimum filter bandwidth, Hz (otherwise filters may
become too narrow when nFilters is high; has no effect if filterType =
'gammatone')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>a list of measures to return. Defaults to everything, but this
takes a lot of RAM, so shorten to what's needed if analyzing many files at
once</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reportEvery</code></td>
<td>
<p>when processing multiple inputs, report estimated time
left every ... iterations (NULL = default, NA = don't report)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cores for parallel processing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>should a spectrogram be plotted? TRUE / FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savePlots</code></td>
<td>
<p>full path to the folder in which to save the plots (NULL =
don't save, ” = same folder as audio)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotFilters</code></td>
<td>
<p>if TRUE, plots the filters as central frequencies ±
bandwidth/2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>osc</code></td>
<td>
<p>"none" = no oscillogram; "linear" = on the original scale; "dB" =
in decibels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heights</code></td>
<td>
<p>a vector of length two specifying the relative height of the
spectrogram and the oscillogram (including time axes labels)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>frequency range to plot, kHz (defaults to 0 to Nyquist
frequency). NB: still in kHz, even if yScale = bark, mel, or ERB</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yScale</code></td>
<td>
<p>determines the location of center frequencies of the filters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>spectrum is exponentiated by contrast (any real number,
recommended -1 to +1). Contrast &gt;0 increases sharpness, &lt;0 decreases
sharpness</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brightness</code></td>
<td>
<p>how much to "lighten" the image (&gt;0 = lighter, &lt;0 = darker)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxPoints</code></td>
<td>
<p>the maximum number of "pixels" in the oscillogram (if any)
and spectrogram; good for quickly plotting long audio files; defaults to
c(1e5, 5e5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>padWithSilence</code></td>
<td>
<p>if TRUE, pads the sound with just enough silence to
resolve the edges properly (only the original region is plotted, so the
apparent duration doesn't change)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorTheme</code></td>
<td>
<p>black and white ('bw'), as in seewave package ('seewave'),
matlab-type palette ('matlab'), or any palette from
<code>palette</code> such as 'heat.colors', 'cm.colors', etc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>actual colors, eg rev(rainbow(100)) - see ?hcl.colors for colors
in base R (overrides colorTheme)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extraContour</code></td>
<td>
<p>a vector of arbitrary length scaled in Hz (regardless of
yScale!) that will be plotted over the spectrogram (eg pitch contour); can
also be a list with extra graphical parameters such as lwd, col, etc. (see
examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab, main, mar, xaxp</code></td>
<td>
<p>graphical parameters for plotting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>if numeric, adds n = <code>grid</code> dotted lines per kHz</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width, height, units, res</code></td>
<td>
<p>graphical parameters for saving plots passed to
<code>png</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other graphical parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list for each analyzed file, including:
</p>
<dl>
<dt>audSpec</dt>
<dd>
<p>auditory spectrogram with frequencies in rows and
time in columns</p>
</dd> <dt>audSpec_processed</dt>
<dd>
<p>same but rescaled for plotting</p>
</dd>
<dt>filterbank</dt>
<dd>
<p>raw output of the filters</p>
</dd> <dt>roughness</dt>
<dd>
<p>roughness per
channel (as many as <code>nFilters</code>)</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"># synthesize a sound with gradually increasing hissing noise
sound = soundgen(sylLen = 200, temperature = 0.001,
  noise = list(time = c(0, 350), value = c(-40, 0)),
  formantsNoise = list(f1 = list(freq = 5000, width = 10000)),
  addSilence = 25)
# playme(sound, samplingRate = 16000)

# auditory spectrogram
as = audSpectrogram(sound, samplingRate = 16000, nFilters = 48)
dim(as$audSpec)

# compare to FFT-based spectrogram with similar time and frequency resolution
fs = spectrogram(sound, samplingRate = 16000, yScale = 'bark',
                 windowLength = 5, step = 1)
dim(fs)

## Not run: 
# add bells and whistles
audSpectrogram(sound, samplingRate = 16000,
  filterType = 'gammatone',
  nFilters = 50,
  yScale = 'ERB',
  bandwidth = 1/12,
  dynamicRange = 150,
  osc = 'dB',  # plot oscillogram in dB
  heights = c(2, 1),  # spectro/osc height ratio
  contrast = .2,  # increase contrast
  brightness = -.1,  # reduce brightness
  # colorTheme = 'heat.colors',  # pick color theme...
  col = hcl.colors(100, palette = 'Plasma'),  # ...or specify the colors
  cex.lab = .75, cex.axis = .75,  # text size and other base graphics pars
  grid = 5,  # to customize, add manually with graphics::grid()
  ylim = c(0.05, 8),  # always in kHz
  main = 'My auditory spectrogram' # title
  # + axis labels, etc
)

# NB: frequency resolution is controlled by both nFilters and bandwidth
audSpectrogram(sound, 16000, nFilters = 15, bandwidth = 1/2)
audSpectrogram(sound, 16000, nFilters = 15, bandwidth = 1/10)
audSpectrogram(sound, 16000, nFilters = 100, bandwidth = 1/2)
audSpectrogram(sound, 16000, nFilters = 100, bandwidth = 1/10)
audSpectrogram(sound, 16000, nFilters_oct = 5, bandwidth = 1/10)

# remove the oscillogram
audSpectrogram(sound, samplingRate = 16000, osc = 'none')

# save auditory spectrograms of all audio files in a folder
audSpectrogram('~/Downloads/temp',
  savePlots = '~/Downloads/temp/audSpec', cores = 4)

## End(Not run)
</code></pre>


</div>