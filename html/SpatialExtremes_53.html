<div class="container">

<table style="width: 100%;"><tr>
<td>map.latent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two dimensional map from a Bayesian hierarchical model</h2>

<h3>Description</h3>

<p>This function plots 2D maps from a Markov chain.
</p>


<h3>Usage</h3>

<pre><code class="language-R">map.latent(fitted, x, y, covariates = NULL, param = "quant", ret.per =
100, col = terrain.colors(64), plot.contour = TRUE, fun = mean, level =
0.95, show.data = TRUE, control = list(nlines = 500), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>An object of class "latent". Typically this will be the
output of <code>latent</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>Numeric vector specifying the coordinates of the grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>An array specifying the covariates at each grid
point defined by <code>x</code> and <code>y</code>. If <code>NULL</code>, no covariate
is needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>A character string. Must be one of "loc", "scale",
"shape" or "quant" for a map of the location, scale, shape
parameters or for a map of a specified quantile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret.per</code></td>
<td>
<p>A numeric giving the return period for which the
quantile map is plotted. It is only required if <code>param =
      "quant"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>A list of colors such as that generated by 'rainbow',
'heat.colors', 'topo.colors', 'terrain.colors' or similar
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.contour</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), contour lines
are added to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A character string specifying the function to be used to
get posterior point estimates. The default is to take posterior
means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>A numeric specifying the significance level for the
pointwise credible intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.data</code></td>
<td>
<p>Logical. Should the locations where have observed the
process have to be plotted?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list with named components specifying options to be
passed to <code>rgp</code>. Typically one might want specify
<code>nlines</code> to reduce the computational demand.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Several arguments to be passed to the <code>image</code>
function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A plot and a invisible list containing all the data required to do the
plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code>condrgp</code>, <code>map</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Generate realizations from the model
n.site &lt;- 30
n.obs &lt;- 50
coord &lt;- cbind(lon = runif(n.site, -10, 10), lat = runif(n.site, -10 , 10))

gp.loc &lt;- rgp(1, coord, "powexp", sill = 4, range = 20, smooth = 1)
gp.scale &lt;- rgp(1, coord, "powexp", sill = 0.4, range = 5, smooth = 1)
gp.shape &lt;- rgp(1, coord, "powexp", sill = 0.01, range = 10, smooth = 1)

locs &lt;- 26 + 0.5 * coord[,"lon"] + gp.loc
scales &lt;- 10 + 0.2 * coord[,"lat"] + gp.scale
shapes &lt;- 0.15 + gp.shape

data &lt;- matrix(NA, n.obs, n.site)
for (i in 1:n.site)
  data[,i] &lt;- rgev(n.obs, locs[i], scales[i], shapes[i])

loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

hyper &lt;- list()
hyper$sills &lt;- list(loc = c(1,8), scale = c(1,1), shape = c(1,0.02))
hyper$ranges &lt;- list(loc = c(2,20), scale = c(1,5), shape = c(1, 10))
hyper$smooths &lt;- list(loc = c(1,1/3), scale = c(1,1/3), shape = c(1, 1/3))
hyper$betaMeans &lt;- list(loc = rep(0, 2), scale = c(9, 0), shape = 0)
hyper$betaIcov &lt;- list(loc = solve(diag(c(400, 100))),
                       scale = solve(diag(c(400, 100))),
                       shape = solve(diag(c(10), 1, 1)))

## We will use an exponential covariance function so the jump sizes for
## the shape parameter of the covariance function are null.
prop &lt;- list(gev = c(2.5, 1.5, 0.2), ranges = c(0.7, 0.75, 0.9), smooths = c(0,0,0))
start &lt;- list(sills = c(4, .36, 0.009), ranges = c(24, 17, 16), smooths
              = c(1, 1, 1),  beta = list(loc = c(26, 0.5), scale = c(10, 0.2),
                               shape = c(0.15)))

## Generate a Markov chain
mc &lt;- latent(data, coord, loc.form = loc.form, scale.form = scale.form,
             shape.form = shape.form, hyper = hyper, prop = prop, start = start,
             n = 100)

x.grid &lt;- y.grid &lt;- seq(-10, 10, length = 50)
map.latent(mc, x.grid, y.grid, param = "shape")

## End(Not run)
</code></pre>


</div>