<div class="container">

<table style="width: 100%;"><tr>
<td>spBreg_lag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian MCMC spatial simultaneous autoregressive model estimation</h2>

<h3>Description</h3>

<p>The <code>spBreg_lag</code> function is an early-release version of the Matlab Spatial Econometrics Toolbox function <code>sar_g.m</code>, using drawing by inversion, and not accommodating heteroskedastic disturbances.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spBreg_lag(formula, data = list(), listw, na.action, Durbin, type,
    zero.policy=NULL, control=list())
spBreg_sac(formula, data = list(), listw, listw2=NULL, na.action, 
    Durbin, type, zero.policy=NULL, control=list())
spBreg_err(formula, data = list(), listw, na.action, Durbin, etype,
    zero.policy=NULL, control=list())
## S3 method for class 'MCMC_sar_G'
impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL)
## S3 method for class 'MCMC_sem_G'
impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL)
## S3 method for class 'MCMC_sac_G'
impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit. The details 
of model specification are given for <code>lm()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment which the function 
is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw, listw2</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function (default <code>options("na.action")</code>), can also be <code>na.omit</code> or <code>na.exclude</code> with consequences for residuals and fitted values - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Durbin</code></td>
<td>
<p>default FALSE (spatial lag model); if TRUE, full spatial Durbin model; if a formula object, the subset of explanatory variables to lag</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type, etype</code></td>
<td>
<p>(use the ‘Durbin=’ argument - retained for backwards compatibility only) default "lag", may be set to "mixed"; when "mixed", the lagged intercept is dropped for spatial weights style "W", that is row-standardised weights, but otherwise included; “Durbin” may be used instead of “mixed”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE (default) assign NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of extra control arguments - see section below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A spatial regression object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed through to methods in the <span class="pkg">coda</span> package</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr</code></td>
<td>
<p>A vector of traces of powers of the spatial weights matrix created using <code>trW</code>, for approximate impact measures; if not given, <code>listw</code> must be given for exact measures (for small to moderate spatial weights matrices); the traces must be for the same spatial weights as were used in fitting the spatial regression, and must be row-standardised</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalues</code></td>
<td>
<p>vector of eigenvalues of spatial weights matrix for impacts calculations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>default NULL, else an integer number of cumulative power series impacts to calculate if <code>tr</code> is given</p>
</td>
</tr>
</table>
<h3>Control arguments</h3>


<dl>
<dt>tol.opt:</dt>
<dd>
<p>the desired accuracy of the optimization - passed to <code>optimize()</code> (default=square root of double precision machine tolerance, a larger root may be used needed, see help(boston) for an example)</p>
</dd>
<dt>fdHess:</dt>
<dd>
<p>default NULL, then set to (method != "eigen") internally; use <code>fdHess</code> to compute an approximate Hessian using finite differences when using sparse matrix methods; used to make a coefficient covariance matrix when the number of observations is large; may be turned off to save resources if need be</p>
</dd>
<dt>optimHess:</dt>
<dd>
<p>default FALSE, use <code>fdHess</code> from <span class="pkg">nlme</span>, if TRUE, use <code>optim</code> to calculate Hessian at optimum</p>
</dd>
<dt>optimHessMethod:</dt>
<dd>
<p>default “optimHess”, may be “nlm” or one of the <code>optim</code> methods</p>
</dd>
<dt>compiled_sse:</dt>
<dd>
<p>default FALSE; logical value used in the log likelihood function to choose compiled code for computing SSE</p>
</dd>
<dt>Imult:</dt>
<dd>
<p>default 2; used for preparing the Cholesky decompositions for updating in the Jacobian function</p>
</dd>
<dt>super:</dt>
<dd>
<p>if NULL (default), set to FALSE to use a simplicial decomposition for the sparse Cholesky decomposition and method “Matrix_J”, set to  <code>as.logical(NA)</code> for method “Matrix”, if TRUE, use a supernodal decomposition</p>
</dd>
<dt>cheb_q:</dt>
<dd>
<p>default 5; highest power of the approximating polynomial for the Chebyshev approximation</p>
</dd>
<dt>MC_p:</dt>
<dd>
<p>default 16; number of random variates</p>
</dd>
<dt>MC_m:</dt>
<dd>
<p>default 30; number of products of random variates matrix and spatial weights matrix</p>
</dd>
<dt>spamPivot:</dt>
<dd>
<p>default “MMD”, alternative “RCM”</p>
</dd>
<dt>in_coef</dt>
<dd>
<p>default 0.1, coefficient value for initial Cholesky decomposition in “spam_update”</p>
</dd>
<dt>type</dt>
<dd>
<p>default “MC”, used with method “moments”; alternatives “mult” and “moments”, for use if <code>trs</code> is missing, <code>trW</code></p>
</dd>
<dt>correct</dt>
<dd>
<p>default TRUE, used with method “moments” to compute the Smirnov/Anselin correction term</p>
</dd>
<dt>trunc</dt>
<dd>
<p>default TRUE, used with method “moments” to truncate the Smirnov/Anselin correction term</p>
</dd>
<dt>SE_method</dt>
<dd>
<p>default “LU”, may be “MC”</p>
</dd>
<dt>nrho</dt>
<dd>
<p>default 200, as in SE toolbox; the size of the first stage lndet grid; it may be reduced to for example 40</p>
</dd>
<dt>interpn</dt>
<dd>
<p>default 2000, as in SE toolbox; the size of the second stage lndet grid</p>
</dd>
<dt>small_asy</dt>
<dd>
<p>default TRUE; if the method is not “eigen”, use asymmetric covariances rather than numerical Hessian ones if n &lt;= small</p>
</dd>
<dt>small</dt>
<dd>
<p>default 1500; threshold number of observations for asymmetric covariances when the method is not “eigen”</p>
</dd>
<dt>SElndet</dt>
<dd>
<p>default NULL, may be used to pass a pre-computed SE toolbox style matrix of coefficients and their lndet values to the "SE_classic" and "SE_whichMin" methods</p>
</dd>
<dt>LU_order</dt>
<dd>
<p>default FALSE; used in “LU_prepermutate”, note warnings given for <code>lu</code> method</p>
</dd>
<dt>pre_eig</dt>
<dd>
<p>default NULL; may be used to pass a pre-computed vector of eigenvalues</p>
</dd>
<dt>OrdVsign</dt>
<dd>
<p>default 1; used to set the sign of the final component to negative if -1 (alpha times ((sigma squared) squared) in Ord (1975) equation B.1).</p>
</dd>
</dl>
<h3>Extra Bayesian control arguments</h3>


<dl>
<dt>ldet_method</dt>
<dd>
<p>default “SE_classic”; equivalent to the <code>method</code> argument in <code>lagsarlm</code></p>
</dd>
<dt>interval</dt>
<dd>
<p>default <code>c(-1, 1)</code>; used unmodified or set internally by <code>jacobianSetup</code></p>
</dd>
<dt>ndraw</dt>
<dd>
<p>default <code>2500L</code>; integer total number of draws</p>
</dd>
<dt>nomit</dt>
<dd>
<p>default <code>500L</code>; integer total number of omitted burn-in draws</p>
</dd>
<dt>thin</dt>
<dd>
<p>default <code>1L</code>; integer thinning proportion</p>
</dd>
<dt>verbose</dt>
<dd>
<p>default <code>FALSE</code>; inverse of <code>quiet</code> argument in <code>lagsarlm</code></p>
</dd>
<dt>detval</dt>
<dd>
<p>default <code>NULL</code>; not yet in use, precomputed matrix of log determinants</p>
</dd>
<dt>prior</dt>
<dd>
<p>a list with the following components:
</p>

<dl>
<dt>rhoMH, lambdaMH</dt>
<dd>
<p>default FALSE; use Metropolis or griddy Gibbs</p>
</dd>
<dt>Tbeta</dt>
<dd>
<p>default <code>NULL</code>; values of the betas variance-covariance matrix, set to <code>diag(k)*1e+12</code> if <code>NULL</code></p>
</dd>
<dt>c_beta</dt>
<dd>
<p>default <code>NULL</code>; values of the betas set to 0 if <code>NULL</code></p>
</dd>
<dt>rho</dt>
<dd>
<p>default <code>0.5</code>; value of the autoregressive coefficient</p>
</dd>
<dt>sige</dt>
<dd>
<p>default <code>1</code>; value of the residual variance</p>
</dd>
<dt>nu</dt>
<dd>
<p>default <code>0</code>; informative Gamma(nu,d0) prior on sige</p>
</dd>
<dt>d0</dt>
<dd>
<p>default <code>0</code>; informative Gamma(nu,d0) prior on sige</p>
</dd>
<dt>a1</dt>
<dd>
<p>default <code>1.01</code>; parameter for beta(a1,a2) prior on rho</p>
</dd>
<dt>a2</dt>
<dd>
<p>default <code>1.01</code>; parameter for beta(a1,a2) prior on rho</p>
</dd>
<dt>cc</dt>
<dd>
<p>default <code>0.2</code>; initial tuning parameter for M-H sampling</p>
</dd>
<dt>gG_sige</dt>
<dd>
<p>default TRUE; include sige in lambda griddy Gibbs update</p>
</dd>
<dt>cc1</dt>
<dd>
<p>default <code>0.2</code>; initial tuning parameter for M-H sampling</p>
</dd>
<dt>cc2</dt>
<dd>
<p>default <code>0.2</code>; initial tuning parameter for M-H sampling</p>
</dd>
</dl>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>, with thanks to Abhirup Mallik and Virgilio Gómez-Rubio for initial coding GSoC 2011</p>


<h3>References</h3>

<p>LeSage J and RK Pace (2009) Introduction to Spatial Econometrics. CRC Press, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#require("spdep", quietly=TRUE)
data(oldcol, package="spdep")
lw &lt;- spdep::nb2listw(COL.nb, style="W")
require("coda", quietly=TRUE)
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw)
print(summary(COL.err.Bayes))
print(raftery.diag(COL.err.Bayes, r=0.01))
## Not run: 
ev &lt;- eigenw(lw)
W &lt;- as(lw, "CsparseMatrix")
trMatc &lt;- trW(W, type="mult")
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 control=list(prior=list(lambdaMH=TRUE)))
print(summary(COL.err.Bayes))
print(raftery.diag(COL.err.Bayes, r=0.01))
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=TRUE)
print(summary(COL.err.Bayes))
print(summary(impacts(COL.err.Bayes)))
print(raftery.diag(COL.err.Bayes, r=0.01))
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=TRUE, control=list(prior=list(lambdaMH=TRUE)))
print(summary(COL.err.Bayes))
print(summary(impacts(COL.err.Bayes)))
print(raftery.diag(COL.err.Bayes, r=0.01))
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=~INC)
print(summary(COL.err.Bayes))
print(summary(impacts(COL.err.Bayes)))
print(raftery.diag(COL.err.Bayes, r=0.01))
set.seed(1)
COL.err.Bayes &lt;- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=~INC, control=list(prior=list(lambdaMH=TRUE)))
print(summary(COL.err.Bayes))
print(summary(impacts(COL.err.Bayes)))
print(raftery.diag(COL.err.Bayes, r=0.01))
set.seed(1)
COL.sacW.B0 &lt;- spBreg_sac(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=FALSE, control=list(ndraw=1500L, nomit=500L))
print(summary(COL.sacW.B0))
print(summary(impacts(COL.sacW.B0, tr=trMatc), zstats=TRUE, short=TRUE))
set.seed(1)
COL.sacW.B1 &lt;- spBreg_sac(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,
 Durbin=TRUE, control=list(ndraw=1500L, nomit=500L))
print(summary(COL.sacW.B1))
print(summary(impacts(COL.sacW.B1, tr=trMatc), zstats=TRUE, short=TRUE))
set.seed(1)
COL.lag.Bayes &lt;- spBreg_lag(CRIME ~ INC + HOVAL, data=COL.OLD,
 listw=lw)
print(summary(COL.lag.Bayes))
print(summary(impacts(COL.lag.Bayes, tr=trMatc), short=TRUE, zstats=TRUE))
print(summary(impacts(COL.lag.Bayes, evalues=ev), short=TRUE, zstats=TRUE))
set.seed(1)
COL.D0.Bayes &lt;- spBreg_lag(CRIME ~ INC + HOVAL, data=COL.OLD,
 listw=lw, Durbin=TRUE)
print(summary(COL.D0.Bayes))
print(summary(impacts(COL.D0.Bayes, tr=trMatc), short=TRUE, zstats=TRUE))
set.seed(1)
COL.D1.Bayes &lt;- spBreg_lag(CRIME ~ DISCBD + INC + HOVAL, data=COL.OLD,
 listw=lw, Durbin= ~ INC)
print(summary(COL.D1.Bayes))
print(summary(impacts(COL.D1.Bayes, tr=trMatc), short=TRUE, zstats=TRUE))
#data(elect80, package="spData")
#lw &lt;- spdep::nb2listw(e80_queen, zero.policy=TRUE)
#el_ml &lt;- lagsarlm(log(pc_turnout) ~ log(pc_college) + log(pc_homeownership)
# + log(pc_income), data=elect80, listw=lw, zero.policy=TRUE, method="LU")
#print(summary(el_ml))
#set.seed(1)
#el_B &lt;- spBreg_lag(log(pc_turnout) ~ log(pc_college) + log(pc_homeownership)
# + log(pc_income), data=elect80, listw=lw, zero.policy=TRUE)
#print(summary(el_B))
#print(el_ml$timings)
#print(attr(el_B, "timings"))

## End(Not run)
</code></pre>


</div>