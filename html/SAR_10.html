<div class="container">

<table style="width: 100%;"><tr>
<td>rec_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Azure product recommendations model class</h2>

<h3>Description</h3>

<p>Class representing an individual product recommendations (SAR) model.
</p>


<h3>Format</h3>

<p>An R6 object of class <code>rec_model</code>.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>new(...)</code>: Initialize a model object. See 'Initialization' for more details.
</p>
</li>
<li> <p><code>delete(confirm=TRUE)</code>: Delete the model.
</p>
</li>
<li> <p><code>user_predict(userdata, k=10)</code>: Get personalised recommendations from the model. See 'Recommendations' for more details.
</p>
</li>
<li> <p><code>item_predict(item, k=10)</code>: Get item-to-item recommendations from the model. See 'Recommendations' for more details.
</p>
</li>
<li> <p><code>get_model_url()</code>: Get the individual service URL for this model.
</p>
</li>
</ul>
<h3>Initialization</h3>

<p>Generally, the easiest way to initialize a new model object is via the <code>get_model()</code> and <code>train_model()</code> methods of the <code>rec_endpoint</code> class, which will handle all the gory details.
</p>


<h3>Recommendations</h3>

<p>These arguments are used for obtaining personalised and item-to-item recommendations.
</p>

<ul>
<li> <p><code>userdata</code>: The input data on users for which to obtain personalised recommendations. This can be:
</p>

<ol>
<li>
<p> A character vector of user IDs. In this case, personalised recommendations will be computed based on the transactions in the training data, <em>ignoring</em> any transaction event IDs or weights.
</p>
</li>
<li>
<p> A data frame containing transaction item IDs, event types and/or weights, plus timestamps. In this case, all the transactions are assumed to be for a single (new) user. If the event types/weights are absent, all transactions are assigned equal weight.
</p>
</li>
<li>
<p> A data frame containing user IDs and transaction details as in (2). In this case, the recommendations are based on both the training data for the given user(s), plus the new transaction details.
</p>
</li>
</ol>
</li>
<li> <p><code>item</code>: A vector of item IDs for which to obtain item-to-item recommendations.
</p>
</li>
<li> <p><code>k</code>: The number of recommendations to return. Defaults to 10.
</p>
</li>
</ul>
<p>Both the <code>user_predict()</code> and <code>item_predict()</code> methods return a data frame with the top-K recommendations and scores.
</p>


<h3>See Also</h3>

<p>az_rec_service for the service backend, rec_endpoint for the client endpoint
</p>
<p><a href="https://github.com/Microsoft/Product-Recommendations/blob/master/doc/api-reference.md">API reference</a> and <a href="https://github.com/Microsoft/Product-Recommendations/blob/master/doc/sar.md">SAR model description</a> at the Product Recommendations API repo on GitHub
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# get a recommender endpoint and previously-trained model
rec_endp &lt;- rec_endpoint$new("myrecusacvjwpk4raost", admin_key="key1", rec_key="key2")
rec_model &lt;- rec_endp$get_model("model1")

data(ms_usage)

# item recommendations for a set of user IDs
users &lt;- unique(ms_usage$user)[1:5]
rec_model$user_predict(users)

# item recommendations for a set of user IDs and transactions (assumed to be new)
user_df &lt;- subset(ms_usage, user %in% users)
rec_model$user_predict(user_df)

# item recomendations for a set of item IDs
items &lt;- unique(ms_usage$item)[1:5]
rec_model$item_predict(items)


## End(Not run)
</code></pre>


</div>