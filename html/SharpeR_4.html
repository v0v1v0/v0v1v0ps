<div class="container">

<table style="width: 100%;"><tr>
<td>as.del_sropt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the Sharpe ratio of a hedged Markowitz portfolio.</h2>

<h3>Description</h3>

<p>Computes the Sharpe ratio of the hedged Markowitz portfolio of some observed returns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")

## Default S3 method:
as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")

## S3 method for class 'xts'
as.del_sropt(X, G, drag = 0, ope = 1, epoch = "yr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>matrix of returns, or <code>xts</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>an <code class="reqn">g \times q</code> matrix of hedge constraints. A 
garden variety application would have <code>G</code> be one row of the
identity matrix, with a one in the column of the instrument to be
'hedged out'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drag</code></td>
<td>
<p>the 'drag' term, <code class="reqn">c_0/R</code>. defaults to 0. It is assumed
that <code>drag</code> has been annualized, <em>i.e.</em> has been multiplied
by <code class="reqn">\sqrt{ope}</code>. This is in contrast to the <code>c0</code>
term given to <code>sr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>the string representation of the 'epoch', defaulting
to 'yr'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose <code class="reqn">x_i</code> are <code class="reqn">n</code> independent draws of a <code class="reqn">q</code>-variate
normal random variable with mean <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. Let <code class="reqn">G</code> be a <code class="reqn">g \times q</code> matrix
of rank <code class="reqn">g</code>.
Let <code class="reqn">\bar{x}</code> be the (vector) sample mean, and 
<code class="reqn">S</code> be the sample covariance matrix (using Bessel's correction). 
Let
</p>
<p style="text-align: center;"><code class="reqn">\zeta(w) = \frac{w^{\top}\bar{x} - c_0}{\sqrt{w^{\top}S w}}</code>
</p>

<p>be the (sample) Sharpe ratio of the portfolio <code class="reqn">w</code>, subject to 
risk free rate <code class="reqn">c_0</code>.
</p>
<p>Let <code class="reqn">w_*</code> be the solution to the portfolio optimization 
problem:
</p>
<p style="text-align: center;"><code class="reqn">\max_{w: 0 &lt; w^{\top}S w \le R^2,\,G S w = 0} \zeta(w),</code>
</p>

<p>with maximum value <code class="reqn">z_* = \zeta\left(w_*\right)</code>.
</p>
<p>Note that if <code>ope</code> and <code>epoch</code> are not given, the 
converter from <code>xts</code> attempts to infer the observations per epoch,
assuming yearly epoch.
</p>


<h3>Value</h3>

<p>An object of class <code>del_sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>del_sropt</code>, <code>sropt</code>, 
<code>sr</code>
</p>
<p>Other del_sropt: 
<code>del_sropt</code>,
<code>is.del_sropt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">nfac &lt;- 5
nyr &lt;- 10
ope &lt;- 253
# simulations with no covariance structure.
# under the null:
set.seed(as.integer(charToRaw("be determinstic")))
Returns &lt;- matrix(rnorm(ope*nyr*nfac,mean=0,sd=0.0125),ncol=nfac)
# hedge out the first one:
G &lt;- matrix(diag(nfac)[1,],nrow=1)
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
print(asro)
G &lt;- diag(nfac)[c(1:3),]
asro &lt;- as.del_sropt(Returns,G,drag=0,ope=ope)
# compare to sropt on the remaining assets
# they should be close, but not exact.
asro.alt &lt;- as.sropt(Returns[,4:nfac],drag=0,ope=ope)

# using real data.
if (require(xts)) {
  data(stock_returns)
  # hedge out SPY
  G &lt;- diag(dim(stock_returns)[2])[3,]
  asro &lt;- as.del_sropt(stock_returns,G=G)
}
</code></pre>


</div>