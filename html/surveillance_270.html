<div class="container">

<table style="width: 100%;"><tr>
<td>hhh4_plot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plots for Fitted <code>hhh4</code>-models</h2>

<h3>Description</h3>

<p>There are six <code>type</code>s of plots for fitted <code>hhh4</code> models:
</p>

<ul>
<li>
<p> Plot the <code>"fitted"</code> component means (of selected units)
along time along with the observed counts.
</p>
</li>
<li>
<p> Plot the estimated <code>"season"</code>ality of the three components.
</p>
</li>
<li>
<p> Plot the time-course of the dominant eigenvalue <code>"maxEV"</code>.
</p>
</li>
<li>
<p> If the units of the corresponding multivariate
<code>"sts"</code> object represent different regions,
maps of the fitted mean components averaged over time (<code>"maps"</code>),
or a map of estimated region-specific intercepts (<code>"ri"</code>) of a
selected model component can be produced.
</p>
</li>
<li>
<p> Plot the (estimated) neighbourhood weights
(<code>"neweights"</code>) as a function of neighbourhood order
(shortest-path distance between regions), i.e., <code>w_ji ~ o_ji</code>.
</p>
</li>
</ul>
<p>Spatio-temporal <code>"hhh4"</code> models and these plots are illustrated in
Meyer et al. (2017, Section 5), see <code>vignette("hhh4_spacetime")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'hhh4'
plot(x, type=c("fitted", "season", "maxEV", "maps", "ri", "neweights"), ...)

plotHHH4_fitted(x, units = 1, names = NULL,
                col = c("grey85", "blue", "orange"),
                pch = 19, pt.cex = 0.6, pt.col = 1,
                par.settings = list(),
                legend = TRUE, legend.args = list(),
                legend.observed = FALSE,
                decompose = NULL, total = FALSE, meanHHH = NULL, ...)

plotHHH4_fitted1(x, unit = 1, main = NULL,
                 col = c("grey85", "blue", "orange"),
                 pch = 19, pt.cex = 0.6, pt.col = 1, border = col, 
                 start = x$stsObj@start, end = NULL, xaxis = NULL,
                 xlim = NULL, ylim = NULL, xlab = "", ylab = "No. infected",
                 hide0s = FALSE, decompose = NULL, total = FALSE, meanHHH = NULL)

plotHHH4_season(..., components = NULL, intercept = FALSE,
                xlim = NULL, ylim = NULL,
                xlab = NULL, ylab = "", main = NULL,
                par.settings = list(), matplot.args = list(),
                legend = NULL, legend.args = list(),
                refline.args = list(), unit = 1, period = NULL)
getMaxEV_season(x, period = frequency(x$stsObj))

plotHHH4_maxEV(...,
               matplot.args = list(), refline.args = list(),
               legend.args = list())
getMaxEV(x)

plotHHH4_maps(x, which = c("mean", "endemic", "epi.own", "epi.neighbours"),
              prop = FALSE, main = which, zmax = NULL, col.regions = NULL,
              labels = FALSE, sp.layout = NULL, ...,
              map = x$stsObj@map, meanHHH = NULL)

plotHHH4_ri(x, component, exp = FALSE,
            at = list(n = 10), col.regions = cm.colors(100),
            colorkey = TRUE, labels = FALSE, sp.layout = NULL,
            gpar.missing = list(col = "darkgrey", lty = 2, lwd = 2),
            ...)

plotHHH4_neweights(x, plotter = boxplot, ...,
                   exclude = 0, maxlag = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a fitted <code>hhh4</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of plot: either <code>"fitted"</code> component means of
selected <code>units</code> along time along with the observed counts, or
<code>"season"</code>ality plots of the model components and the epidemic
dominant eigenvalue (which may also be plotted along overall time by
<code>type="maxEV"</code>, especially if the model contains time-varying
neighbourhood weights or unit-specific epidemic effects),
or <code>"maps"</code> of the fitted mean components averaged over time,
or a map of estimated region-specific random
intercepts (<code>"ri"</code>) of a specific model <code>component</code>.
The latter two require <code>x$stsObj</code> to contain a map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>plotHHH4_season</code> and <code>plotHHH4_maxEV</code>,
one or more <code>hhh4</code>-fits, or a single list of these.
Otherwise further arguments passed on to other functions.<br>
For the <code>plot</code>-method these go to the specific plot
<code>type</code> function.<br><code>plotHHH4_fitted</code> passes them to <code>plotHHH4_fitted1</code>, which is called
sequentially for every unit in <code>units</code>.<br><code>plotHHH4_maps</code> and <code>plotHHH4_ri</code> pass additional arguments to
<code>spplot</code>, and <code>plotHHH4_neweights</code> to the
<code>plotter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>units,unit</code></td>
<td>
<p>integer or character vector specifying a single
<code>unit</code> or possibly multiple <code>units</code> to plot.
It indexes <code>colnames(x$stsObj)</code>.<br>
In <code>plotHHH4_fitted</code>, <code>units=NULL</code> plots all units.<br>
In the seasonality plot,
selection of a unit is only relevant if the model contains
unit-specific intercepts or seasonality terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names,main</code></td>
<td>
<p>main title(s) for the selected
<code>unit</code>(<code>s</code>) / <code>components</code>. If <code>NULL</code> (default),
<code>plotHHH4_fitted1</code> will use the appropriate element of
<code>colnames(x$stsObj)</code>, whereas <code>plotHHH4_season</code> uses
default titles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col,border</code></td>
<td>
<p>length 3 vectors specifying the fill and border colors for the
endemic, autoregressive, and spatio-temporal component polygons (in
this order).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch,pt.cex,pt.col</code></td>
<td>
<p>style specifications for the dots drawn to represent
the observed counts. <code>pch=NA</code> can be used to disable these dots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.settings</code></td>
<td>
<p>list of graphical parameters for
<code>par</code>. Sensible defaults for <code>mfrow</code>, <code>mar</code> and
<code>las</code> will be applied unless overridden or
<code>!is.list(par.settings)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>Integer vector specifying in which of the
<code>length(units)</code> frames the legend should be drawn. If a logical
vector is supplied, <code>which(legend)</code> determines the frame
selection, i.e., the default is to drawn the legend in the first
(upper left) frame only, and <code>legend=FALSE</code> results in no
legend being drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.args</code></td>
<td>
<p>list of arguments for <code>legend</code>, e.g.,
to modify the default positioning
<code>list(x="topright", inset=0.02)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.observed</code></td>
<td>
<p>logical indicating if the legend should contain
a line for the dots corresponding to observed counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decompose</code></td>
<td>
<p>if <code>TRUE</code> or (a permutation of)
<code>colnames(x$stsObj)</code>, the fitted mean will be decomposed
into the contributions from each single unit and the endemic part
instead of the default endemic + AR + neighbours decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total</code></td>
<td>
<p>logical indicating if the fitted components should be
summed over all units to be compared with the total observed
counts at each time point. If <code>total=TRUE</code>, the
<code>units</code>/<code>unit</code> argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start,end</code></td>
<td>
<p>time range to plot specified by vectors of length two
in the form <code>c(year,number)</code>, see <code>"sts"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xaxis</code></td>
<td>
<p>if this is a list (of arguments for
<code>addFormattedXAxis</code>), the time axis is nicely labelled
similar to <code>stsplot_time</code>.
Note that in this case or if <code>xaxis = NA</code>,
the basic time indexes <code>1:nrow(x$stsObj)</code>
will be used as x coordinates, which is different from the
long-standing default (<code>xaxis = NULL</code>) with a real time scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>numeric vector of length 2 specifying the x-axis range.
The default (<code>NULL</code>) is to plot the complete time range
(<code>type="fitted"</code>) or period (<code>type="season"</code>), respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>y-axis range.
For <code>type="fitted"</code>, this defaults to 
<code>c(0,max(observed(x$stsObj)[,unit]))</code>.
For <code>type="season"</code>, <code>ylim</code> must be a list of length
<code>length(components)</code> specifying the range for every component
plot, or a named list to customize only a subset of these. If only
one <code>ylim</code> is specified, it will be recycled for all
<code>components</code> plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab,ylab</code></td>
<td>
<p>axis labels. For <code>plotHHH4_season</code>, <code>ylab</code>
specifies the y-axis labels for all <code>components</code> in a
list (similar to <code>ylim</code>). If <code>NULL</code> or incomplete, 
default mathematical expressions are used.
If a single name is supplied such as the default <code>ylab=""</code> (to
omit y-axis labels), it is used for all <code>components</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hide0s</code></td>
<td>
<p>logical indicating if dots for zero observed counts
should be omitted. Especially useful if there are too many.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanHHH</code></td>
<td>
<p>(internal) use different component means than those
estimated and available from <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>components</code></td>
<td>
<p>character vector of component names, i.e., a subset
of <code>c("ar", "ne", "end")</code>, for which to plot the estimated
seasonality. If <code>NULL</code> (the default), only components which
appear in any of the models in <code>...</code> are plotted.<br>
A seasonality plot of the epidemic dominant eigenvalue
is also available by including <code>"maxEV"</code> in <code>components</code>,
but it only supports models without epidemic covariates/offsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical indicating whether to include the global
intercept. For <code>plotHHH4_season</code>, the default (<code>FALSE</code>)
means to plot seasonality as a multiplicative effect on the
respective component. Multiplication by the intercept only
makes sense if there are no further (non-centered)
covariates/offsets in the component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exp</code></td>
<td>
<p>logical indicating whether to <code>exp</code>-transform the
color-key axis labels to show the multiplicative effect of
the region-specific random intercept on the respective component.
Axis labels are then computed using <code>log_breaks</code>
from package <span class="pkg">scales</span> (if that is available) or
<code>axisTicks</code> (as a fallback) respecting the
<code>colorkey$tick.number</code> setting (default: 7).
The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>a numeric vector of breaks for the color levels (see
<code>levelplot</code>), or a list specifying the number
of breaks <code>n</code> (default: 10) and their <code>range</code> (default:
range of the random effects, extended to be symmetric around 0).
In the latter case, breaks are equally spaced (on the original,
non-<code>exp</code> scale of the random intercepts). If <code>exp=TRUE</code>,
custom breaks (or <code>range</code>) need to be given on the exp-scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matplot.args</code></td>
<td>
<p>list of line style specifications passed to
<code>matplot</code>, e.g., <code>lty</code>, <code>lwd</code>, <code>col</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refline.args</code></td>
<td>
<p>list of line style specifications (e.g.,
<code>lty</code> or <code>col</code>) passed to <code>abline</code> when
drawing the reference line (<code>h=1</code>) in plots of seasonal effects
(if <code>intercept=FALSE</code>) and of the dominant eigenvalue.
The reference line is omitted if <code>refline.args</code> is not a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>a numeric value giving the (longest) period of the
harmonic terms in the model. This usually coincides with the
<code>freq</code> of the data (the default), but needs to be adjusted if
the model contains harmonics with a longer periodicity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>a character vector specifying the components of the mean
for which to produce maps. By default, the overall mean and all
three components are shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>a logical indicating whether the component maps should
display proportions of the total mean instead of absolute numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zmax</code></td>
<td>
<p>a numeric vector of length <code>length(which)</code> (recycled
as necessary) specifying upper limits for the color keys of the
maps, using a lower limit of 0.
A missing element (<code>NA</code>) means to use a map-specific color key
only covering the range of the values in that map
(can be useful for <code>prop = TRUE</code>).
The default <code>zmax = NULL</code> means to use the same scale for the component maps
and a separate scale for the map showing the overall mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.regions</code></td>
<td>
<p>a vector of colors used to encode the fitted
component means (see <code>levelplot</code>).
For <code>plotHHH4_maps</code>, the length of this color vector also
determines the number of levels, using 10 heat colors by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorkey</code></td>
<td>
<p>a Boolean indicating whether to draw the color key.
Alternatively, a list specifying how to draw it, see
<code>levelplot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>an object inheriting from <code>"SpatialPolygons"</code>
with <code>row.names</code> covering <code>colnames(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>component</code></td>
<td>
<p>component for which to plot the estimated
region-specific random intercepts. Must partially match one of
<code>colnames(ranef(x, tomatrix=TRUE))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>determines if and how regions are labeled, see
<code>layout.labels</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp.layout</code></td>
<td>
<p>optional list of additional layout items, see
<code>spplot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gpar.missing</code></td>
<td>
<p>list of graphical parameters for
<code>sp.polygons</code>, applied to regions
with missing random intercepts, i.e., not included in the model.
Such extra regions won't be plotted if
<code>!is.list(gpar.missing)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotter</code></td>
<td>
<p>the (name of a) function used to produce the plot of
weights (a numeric vector) as a function of neighbourhood order (a
factor variable). It is called as
<code>plotter(Weight ~ Distance, ...)</code> and defaults to
<code>boxplot</code>. A useful alternative is, e.g.,
<code>stripplot</code> from package <span class="pkg">lattice</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>vector of neighbourhood orders to be excluded from
plotting (passed to <code>factor</code>).
By default, the neighbourhood weight for order 0 is not
shown, which is usually zero anyway.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxlag</code></td>
<td>
<p>maximum order of neighbourhood to be assumed when
computing the <code>nbOrder</code> matrix. This additional step is
necessary iff <code>neighbourhood(x$stsObj)</code> only specifies a binary
adjacency matrix.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>plotHHH4_fitted1</code> invisibly returns a matrix of the fitted
component means for the selected <code>unit</code>, and <code>plotHHH4_fitted</code>
returns these in a list for all <code>units</code>.<br><code>plotHHH4_season</code> invisibly returns the plotted y-values, i.e. the
multiplicative seasonality effect within each of <code>components</code>.
Note that this will include the intercept, i.e. the point estimate of
<code class="reqn">exp(intercept + seasonality)</code> is plotted and returned.<br><code>getMaxEV_season</code> returns a list with elements
<code>"maxEV.season"</code> (as plotted by
<code>plotHHH4_season(..., components="maxEV")</code>,
<code>"maxEV.const"</code> and <code>"Lambda.const"</code> (the Lambda matrix and
its dominant eigenvalue if time effects are ignored).<br><code>plotHHH4_maxEV</code> (invisibly) and <code>getMaxEV</code> return the
dominant eigenvalue of the <code class="reqn">\Lambda_t</code> matrix for all time points
<code class="reqn">t</code> of <code>x$stsObj</code>.<br><code>plotHHH4_maps</code> returns a <code>trellis.object</code> if
<code>length(which) == 1</code> (a single <code>spplot</code>), and
otherwise uses <code>grid.arrange</code> from the
<span class="pkg">gridExtra</span> package to arrange all <code>length(which)</code>
<code>spplot</code>s on a single page.
<code>plotHHH4_ri</code> returns the generated <code>spplot</code>, i.e.,
a <code>trellis.object</code>.<br><code>plotHHH4_neweights</code> eventually calls <code>plotter</code> and
thus returns whatever is returned by that function.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>References</h3>

<p>Held, L. and Paul, M. (2012): Modeling seasonality in space-time
infectious disease surveillance data.
<em>Biometrical Journal</em>, <b>54</b>, 824-843.
<a href="https://doi.org/10.1002/bimj.201200037">doi:10.1002/bimj.201200037</a>
</p>
<p>Meyer, S., Held, L. and HÃ¶hle, M. (2017):
Spatio-temporal analysis of epidemic phenomena using the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package
<span class="pkg">surveillance</span>.
<em>Journal of Statistical Software</em>, <b>77</b> (11), 1-55.
<a href="https://doi.org/10.18637/jss.v077.i11">doi:10.18637/jss.v077.i11</a>
</p>


<h3>See Also</h3>

<p>other methods for <code>hhh4</code> fits, e.g., <code>summary.hhh4</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("measlesWeserEms")

## fit a simple hhh4 model
measlesModel &lt;- list(
    ar = list(f = ~ 1),
    end = list(f = addSeason2formula(~0 + ri(type="iid"), S=1, period=52),
               offset = population(measlesWeserEms)),
    family = "NegBin1"
    )
measlesFit &lt;- hhh4(measlesWeserEms, measlesModel)

## fitted values for a single unit
plot(measlesFit, units=2)

## sum fitted components over all units
plot(measlesFit, total=TRUE)

## 'xaxis' option for a nicely formatted time axis
## default tick locations and labels:
plot(measlesFit, total=TRUE, xaxis=list(epochsAsDate=TRUE, line=1))
## an alternative with monthly ticks:
oopts &lt;- surveillance.options(stsTickFactors = c("%m"=0.75, "%Y" = 1.5))
plot(measlesFit, total=TRUE, xaxis=list(epochsAsDate=TRUE,
    xaxis.tickFreq=list("%m"=atChange, "%Y"=atChange),
    xaxis.labelFreq=list("%Y"=atMedian), xaxis.labelFormat="%Y"))
surveillance.options(oopts)

## plot the multiplicative effect of seasonality
plot(measlesFit, type="season")

## alternative fit with biennial pattern, plotted jointly with original fit
measlesFit2 &lt;- update(measlesFit,
    end = list(f = addSeason2formula(~0 + ri(type="iid"), S=2, period=104)))
plotHHH4_season(measlesFit, measlesFit2, components="end", period=104)

## dominant eigenvalue of the Lambda matrix (cf. Held and Paul, 2012)
getMaxEV(measlesFit)  # here simply constant and equal to exp(ar.1)
plot(measlesFit, type="maxEV")  # not very exciting

## fitted mean components/proportions by district, averaged over time
if (requireNamespace("gridExtra")) {
    plot(measlesFit, type="maps", labels=list(cex=0.6),
         which=c("endemic", "epi.own"), prop=TRUE, zmax=NA,
         main=c("endemic proportion", "autoregressive proportion"))
}

## estimated random intercepts of the endemic component
round(nu0    &lt;- fixef(measlesFit)["end.ri(iid)"],   4) # global intercept
round(ranefs &lt;- ranef(measlesFit, tomatrix = TRUE), 4) # zero-mean deviations
stopifnot(all.equal(
    nu0 + ranefs,
    ranef(measlesFit, intercept = TRUE) # local intercepts (log-scale)
))
plot(measlesFit, type="ri", component="end",
     main="deviations around the endemic intercept (log-scale)")
exp(ranef(measlesFit))  # multiplicative effects, plotted below
plot(measlesFit, type="ri", component="end", exp=TRUE,
     main="multiplicative effects",
     labels=list(font=3, labels="GEN"))

## neighbourhood weights as a function of neighbourhood order
plot(measlesFit, type="neweights")  # boring, model has no "ne" component

## fitted values for the 6 regions with most cases and some customization
bigunits &lt;- tail(names(sort(colSums(observed(measlesWeserEms)))), 6)
plot(measlesFit, units=bigunits,
     names=measlesWeserEms@map@data[bigunits,"GEN"],
     legend=5, legend.args=list(x="top"), xlab="Time (weekly)",
     hide0s=TRUE, ylim=c(0,max(observed(measlesWeserEms)[,bigunits])),
     start=c(2002,1), end=c(2002,26), par.settings=list(xaxs="i"))
</code></pre>


</div>