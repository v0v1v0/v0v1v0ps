<div class="container">

<table style="width: 100%;"><tr>
<td>SBGAM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Bayesian Generalized Additive Models</h2>

<h3>Description</h3>

<p>This function implements sparse Bayesian generalized additive models (GAMs) with the spike-and-slab group lasso (SSGL) penalty. Let <code class="reqn">y_i</code> denote the <code class="reqn">i</code>th response and <code class="reqn">x_i</code> denote a <code class="reqn">p</code>-dimensional vector of covariates. GAMs are of the form,
</p>
<p style="text-align: center;"><code class="reqn">g(E(y_i)) = \beta_0 + \sum_{j=1}^{p} f_j (x_{ij}), i = 1, ..., n,</code>
</p>

<p>where <code class="reqn">g</code> is a monotone increasing link function. The identity link function is used for Gaussian regression, the logit link is used for binomial regression, and the log link is used for Poisson, negative binomial, and gamma regression. With the SSGL penalty, some of the univariate functions <code class="reqn">f_j(x_j)</code> will be estimated as <code class="reqn">\hat{f}_j(x_j) = 0</code>, depending on the size of the spike hyperparameter <code class="reqn">\lambda_0</code> in the SSGL prior. The functions <code class="reqn">f_j(x_j), j = 1, ..., p</code>, are modeled using B-spline basis expansions. 
</p>
<p>There is another implementation of sparse Gaussian GAMs with the SSGL penalty available at https://github.com/jantonelli111/SSGL, which uses natural cubic splines as the basis functions. This package <code>sparseGAM</code> uses B-spline basis functions and also implements sparse GAMs with the SSGL penalty for binomial, Poisson, negative binomial, and gamma regression.
</p>
<p>For implementation of sparse <em>frequentist</em> GAMs with the group LASSO, group SCAD, and group MCP penalties, use the <code>SFGAM</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SBGAM(y, X, X.test, df=6, 
      family=c("gaussian","binomial","poisson","negativebinomial","gamma"), 
      nb.size=1, gamma.shape=1, nlambda0=20, lambda0, lambda1, a, b, 
      max.iter=100, tol = 1e-6, print.iter=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code class="reqn">n \times 1</code> vector of responses for training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code class="reqn">n \times p</code> design matrix for training data, where the <code class="reqn">j</code>th column of <code>X</code> corresponds to the <code class="reqn">j</code>th overall covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.test</code></td>
<td>
<p><code class="reqn">n_{test} \times p</code> design matrix for test data to calculate predictions. <code>X.test</code> must have the <em>same</em> number of columns as <code>X</code>, but not necessarily the same number of rows. If <em>no</em> test data is provided or if in-sample predictions are desired, then the function automatically sets <code>X.test=X</code> in order to calculate <em>in-sample</em> predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>number of B-spline basis functions to use in each basis expansion. Default is <code>df=6</code>, but the user may specify degrees of freedom as any integer greater than or equal to 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>exponential dispersion family. Allows for <code>"gaussian"</code>, <code>"binomial"</code>, <code>"poisson"</code>, <code>"negativebinomial"</code>, and <code>"gamma"</code>. Note that for <code>"negativebinomial"</code>, the size parameter must be specified, while for <code>"gamma"</code>, the shape parameter must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.size</code></td>
<td>
<p>known size parameter <code class="reqn">\alpha</code> in <code class="reqn">NB(\alpha,\mu_i)</code> distribution for negative binomial responses. Default is <code>nb.size=1</code>. Ignored if <code>family</code> is not <code>"negativebinomial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.shape</code></td>
<td>
<p>known shape parameter <code class="reqn">\nu</code> in <code class="reqn">Gamma(\mu_i,\nu)</code> distribution for gamma responses. Default is <code>gamma.shape=1</code>. Ignored if <code>family</code> is not <code>"gamma"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda0</code></td>
<td>
<p>number of spike hyperparameter <code class="reqn">L</code>. Default is <code>nlambda0=20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>grid of <code class="reqn">L</code> spike hyperparameters <code class="reqn">\lambda_0</code>. The user may specify either a scalar or a vector. If the user does not provide this, the program chooses the grid automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>slab hyperparameter <code class="reqn">\lambda_1</code> in the SSGL prior. Default is <code>lambda1=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>shape hyperparameter for the <code class="reqn">Beta(a,b)</code> prior on the mixing proportion in the SSGL prior. Default is <code>a=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>shape hyperparameter for the <code class="reqn">Beta(a,b)</code> prior on the mixing proportion in the SSGL prior. Default is <code>b=dim(X)[2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum number of iterations in the algorithm. Default is <code>max.iter=100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>convergence threshold for algorithm. Default is <code>tol=1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.iter</code></td>
<td>
<p>Boolean variable for whether or not to print the current <code>nlambda0</code> in the algorithm. Default is <code>print.iter=TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p><code class="reqn">L \times 1</code> vector of spike hyperparameters <code>lambda0</code> used to fit the model. <code>lambda0</code> is displayed in descending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.pred</code></td>
<td>
<p>List of <code class="reqn">L</code> <code class="reqn">n_{test} \times p</code> matrices, where the <code class="reqn">k</code>th matrix in the list corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>. The <code class="reqn">j</code>th column in each matrix in <code>f.pred</code> is the estimate of the <code class="reqn">j</code>th function evaluated on the test data in <code>X.test</code> for the <code class="reqn">j</code>th covariate (or training data <code>X</code> if <code>X.test</code> was not specified). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.pred</code></td>
<td>
<p><code class="reqn">n_{test} \times L</code> matrix of predicted mean response values <code class="reqn">\mu_{test} = E(Y_{test})</code> based on the <em>test</em> data in <code>X.test</code> (or training data <code>X</code> if no argument was specified for <code>X.test</code>). The <code class="reqn">k</code>th column in <code>mu.pred</code> corresponds to the predictions for the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classifications</code></td>
<td>
<p><code class="reqn">p \times L</code> matrix of classifications. An entry of "1" indicates that the corresponding function was classified as nonzero, and an entry of "0" indicates that the function was classified as zero. The <code class="reqn">k</code>th column of <code>classifications</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p><code class="reqn">L \times 1</code> vector of estimated intercepts. The <code class="reqn">k</code>th entry in <code>beta0</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p><code class="reqn">dp \times L</code> matrix of estimated basis coefficients. The <code class="reqn">k</code>th column in <code>beta</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>vector of either the residual sum of squares (<code>"gaussian"</code>) or the negative log-likelihood (<code>"binomial"</code>, <code>"poisson"</code>, <code>"negativebinomial"</code>, <code>"gamma"</code>) of the fitted model. The <code class="reqn">k</code>th entry in <code>loss</code> corresponds to the <code class="reqn">k</code>th spike hyperparameter in <code>lambda0</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bai R. (2021). "Spike-and-slab group lasso for consistent Bayesian estimation and variable selection in non-Gaussian generalized additive models." <em>arXiv pre-print arXiv:2007.07021</em>.
</p>
<p>Bai, R., Moran, G. E., Antonelli, J. L., Chen, Y., and Boland, M.R. (2021). "Spike-and-slab group lassos for grouped regression and sparse generalized additive models." <em>Journal of the American Statistical Association</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate data
set.seed(12345)
X = matrix(runif(100*5), nrow=100)
n = dim(X)[1]
y = 3*sin(2*pi*X[,1])-3*cos(2*pi*X[,2]) + rnorm(n)

## Test data with 30 observations
X.test = matrix(runif(30*5), nrow=30)

## Fit sparse Bayesian generalized additive model to data with the SSGL penalty
## and 5 spike hyperparameters
SBGAM.mod = SBGAM(y, X, X.test, family="gaussian", lambda0=seq(from=50,to=10,by=-10))

## The model corresponding to the 1st spike hyperparameter
SBGAM.mod$lambda[1] 
SBGAM.mod$classifications[,1] 

## Plot first function f_1(x_1) in 2nd model
x1 = X.test[,1] 
## Estimates of all 20 function evaluations on test data
f.hat = SBGAM.mod$f.pred[[1]] 
## Extract estimates of f_1 
f1.hat = f.hat[,1] 

## Plot X_1 against f_1(x_1)
plot(x1[order(x1)], f1.hat[order(x1)], xlab=expression(x[1]), 
     ylab=expression(f[1](x[1])))
</code></pre>


</div>