<div class="container">

<table style="width: 100%;"><tr>
<td>Emark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Diagnostics for random marking
</h2>

<h3>Description</h3>

<p>Estimate the summary functions <code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> for 
a marked point pattern, proposed by Schlather et al (2004) as diagnostics 
for dependence between the points and the marks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Emark(X, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
Vmark(X, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ..., normalise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code>as.ppp</code>. The pattern should have numeric marks.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Optional. Numeric vector. The values of the argument <code class="reqn">r</code>
at which the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code> should be evaluated.
There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>

<p>A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed to the density estimation routine
(<code>density</code>, <code>loess</code> or <code>sm.density</code>)
selected by <code>method</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalise</code></td>
<td>

<p>If<code>TRUE</code>, normalise the estimate of <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
so that it would have value equal to 1 if the marks are independent
of the points.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a marked point process,
Schlather et al (2004) defined the functions
<code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> to be the conditional mean
and conditional variance of the mark attached to a
typical random point, given that there exists another random
point at a distance <code class="reqn">r</code> away from it.
</p>
<p>More formally,
</p>
<p style="text-align: center;"><code class="reqn">
    E(r) = E_{0u}[M(0)]
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    V(r) = E_{0u}[(M(0)-E(u))^2]
  </code>
</p>

<p>where <code class="reqn">E_{0u}</code> denotes the conditional expectation
given that there are points of the process at the locations
<code class="reqn">0</code> and <code class="reqn">u</code> separated by a distance <code class="reqn">r</code>,
and where <code class="reqn">M(0)</code> denotes the mark attached to the point <code class="reqn">0</code>. 
</p>
<p>These functions may serve as diagnostics for dependence
between the points and the marks. If the points and marks are
independent, then <code class="reqn">E(r)</code> and <code class="reqn">V(r)</code> should be
constant (not depending on <code class="reqn">r</code>). See Schlather et al (2004).
</p>
<p>The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code>as.ppp</code>.
It must be a marked point pattern with numeric marks.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">k_f(r)</code> is estimated.
</p>
<p>This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>Window(X)</code>)
may have arbitrary shape.
</p>
<p>Biases due to edge effects are
treated in the same manner as in <code>Kest</code>.
The edge corrections implemented here are
</p>

<dl>
<dt>isotropic/Ripley</dt>
<dd>
<p>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks).
</p>
</dd>
<dt>translate</dt>
<dd>
<p>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</p>
</dd>
</dl>
<p>Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>The numerator and denominator of the mark correlation function
(in the expression above) are estimated using density estimation
techniques. The user can choose between
</p>

<dl>
<dt><code>"density"</code></dt>
<dd>
<p>which uses the standard kernel
density estimation routine <code>density</code>, and
works only for evenly-spaced <code>r</code> values;
</p>
</dd>
<dt><code>"loess"</code></dt>
<dd>
<p>which uses the function <code>loess</code> in the
package <span class="pkg">modreg</span>;
</p>
</dd>
<dt><code>"sm"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is extremely slow;
</p>
</dd>
<dt><code>"smrep"</code></dt>
<dd>
<p>which uses the function <code>sm.density</code> in the
package <span class="pkg">sm</span> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>If <code>marks(X)</code> is a numeric vector, the result is 
an object of class <code>"fv"</code> (see <code>fv.object</code>).
If <code>marks(X)</code> is a data frame, the result is
a list of objects of class <code>"fv"</code>, one for each column of marks.
</p>
<p>An object of class <code>"fv"</code> is essentially
a data frame containing numeric columns 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the values of the argument <code class="reqn">r</code> 
at which the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
has been estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theo</code></td>
<td>
<p>the theoretical, constant value of <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
when the marks attached to different points are independent
</p>
</td>
</tr>
</table>
<p>together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <code class="reqn">E(r)</code> or <code class="reqn">V(r)</code>
obtained by the edge corrections named.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Schlather, M. and Ribeiro, P. and Diggle, P. (2004)
Detecting dependence between marks and locations of
marked point processes.
<em>Journal of the Royal Statistical Society, series B</em>
<b>66</b> (2004) 79-83.
</p>


<h3>See Also</h3>

<p>Mark correlation <code>markcorr</code>,
mark variogram <code>markvario</code> for numeric marks.
</p>
<p>Mark connection function <code>markconnect</code> and 
multitype K-functions <code>Kcross</code>, <code>Kdot</code>
for factor-valued marks.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    plot(Emark(spruces))
    E &lt;- Emark(spruces, method="density", kernel="epanechnikov")
    plot(Vmark(spruces))

    plot(Emark(finpines))
    V &lt;- Vmark(finpines)
</code></pre>


</div>