<div class="container">

<table style="width: 100%;"><tr>
<td>multinomial</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Analyzing multinomial data</h2>

<h3>Description</h3>

<p>These functions facilitate the conversion and analysis of multinomial data as as series of nested binomial data.
The main interface is the <code>multi</code> “family”, to be used in the <code>family</code> argument of the fitting functions.
Fits using it call <code>binomialize</code>, which can be called directly to check how the data are converted to nested binomial data, and to use these data directly. 
The <code>fitted.HLfitlist</code> method of the <code>fitted</code> generic function returns a matrix of fitted multinomial probabilities.
The <code>logLik.HLfitlist</code> method of the <code>logLik</code> generic function returns a log-likelihood for the joint fits.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multi(binResponse=c("npos","nneg"),binfamily=binomial(),input="types",...)
binomialize(data,responses,sortedTypes=NULL,binResponse=c("npos","nneg"),
             depth=Inf,input="types")
## S3 method for class 'HLfitlist'
fitted(object, version=2L, ...)
## S3 method for class 'HLfitlist'
logLik(object,which,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>The data frame to be analyzed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>A list of binomial fits returned by a multinomial analysis
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>responses</code></td>
<td>

<p>column names of the data, such that <code>&lt;data&gt;[,&lt;responses&gt;]</code> contain the multinomial response data, as levels of factor variables.   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortedTypes</code></td>
<td>

<p>Names of multinomial types, i.e. levels of the multinomial response factors. Their order determines  which types are taken first to define the nested binomial samples. By default, the most common types are considered first.   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binResponse</code></td>
<td>

<p>The names to be given to the number of “success” and “failures” in the binomial response. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth</code></td>
<td>

<p>The maximum number of nested binomial responses to be generated from the multinomial data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binfamily</code></td>
<td>

<p>The family applied to each binomial response.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>

<p>If <code>input="types"</code>, then the <code>responses</code> columns must contain factor levels of the binomial response.
If <code>input="counts"</code>, then the <code>responses</code> columns must contain counts of different factor levels, and the column names are the types.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Which element of the <code>APHLs</code> list to return. The default depends on the fitting method.In particular, if it was REML or one of its variants, the function returns the log restricted likelihood (exact or approximated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version</code></td>
<td>

<p>Integer, for <code>fitted.HLfitlist</code> (i.e. for multinomial fits using <code>multi</code>); <code>1</code> will provide the result of past versions up to 3.5.0 (See Value). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments passed from or to other functions.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A multinomial response, say counts 17, 13, 25, 8, 3, 1 for types <code>type1</code> to <code>type6</code>, can be represented as a series of nested binomials
e.g. <code>type1</code> against others (17 vs 50) then among these 50 others, <code>type2</code> versus others (13 vs 37), etc.
The <code>binomialize</code> function generates such a representation. By default the representation considers types in decreasing order of the number of positives, i.e. first <code>type3</code> against others (25 vs 42), then <code>type1</code> against others within these 42, etc. It stops if it has reached <code>depth</code> nested binomial responses. This can be modified by the <code>sortedTypes</code> argument, e.g. <code>sortedTypes=c("type6","type4","type2")</code>. 
<code>binomialize</code> returns a list of data frames which can be directly provided as a <code>data</code> argument for the fitting functions, with binomial response.
</p>
<p>Alternatively, one can provide the multinomial response data frame, which will be internally converted to nested binomial data if the <code>family</code> argument is a call to <code>multinomial</code> (see Examples).    
</p>
<p>For mixed models, the multinomial data can be fitted to a model with the same correlation parameters, and either the same or different variances of random effects, for all binomial responses. Which analysis is performed depends on whether the variances are fitted by “outer optimization” or by <code>HLfit</code>'s “inner iterative” algorithm, as controlled by the <code>init</code> or <code>init.corrHLfit</code> arguments (see Examples). These initial values therefore affect the definition of the model being fitted.      
<code>corrHLfit</code> will fit different variances by default. Adding an <code>init.corrHLfit</code> will force estimation of a single variance across models. <code>fitme</code>'s default optimization strategy is more complex, and has changed and still change over versions. This creates a <b>back-compatibility issue</b> where the model to be fitted may change over versions of spaMM. To avoid that, it is strongly advised to use an explicit initial value when fitting a <code>multi</code> model by <code>fitme</code>.        
</p>


<h3>Value</h3>

<p><code>binomialize</code> returns a list of data frames appropriate for analysis as binomial response. Each data frame contains the original one plus
two columns named according to <code>binResponse</code>. 
</p>
<p>The main fitting functions, when called on a model with <code>family=multi(.)</code>, return an object of  class <code>HLfitlist</code>, which is a list with attributes. The list elements are fits of the nested binomial models (objects of class <code>HLfit</code>). The attributes provide additional information about the overall multinomial model, such as global log-likelihood values and other information properly extracted by the <code>how()</code> function.  
</p>
<p><code>multi</code> is a function that returns a list, but users may never need to manipulate this output.
</p>
<p><code>fitted.HLfitlist</code> returns a matrix. The current default <code>version=2L</code> provides meaningful fitted values (predicted multinomial frequencies for each response type) even for data rows where the nested binomial fit for a type had no response information remaining. By contrast, the first version provided a matrix with <code>0</code>s for these row*fit combinations, except for the last column; in many cases this may be confusing.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Adding colour to the famous 'iris' dataset:
iriscol &lt;- iris
set.seed(123) # Simulate colours, then fit colour frequencies:
iriscol$col &lt;- sample(c("yellow", "purple", "blue"),replace = TRUE, 
                      size = nrow(iriscol), prob=c(0.5,0.3,0.2))
colfit &lt;- fitme(cbind(npos,nneg) ~ 1+(1|Species), family=multi(responses="col"), 
                data=iriscol, init=list(lambda=NA)) # note warning if no 'init'...
head(fitted(colfit))

# To only generate the binomial datasets:
binomialize(iriscol,responses="col")

## An example considering pseudo-data at one diploid locus for 50 individuals 
set.seed(123)
genecopy1 &lt;- sample(4,size=50,prob=c(1/2,1/4,1/8,1/8),replace=TRUE)
genecopy2 &lt;- sample(4,size=50,prob=c(1/2,1/4,1/8,1/8),replace=TRUE)
alleles &lt;- c("122","124","126","128")
genotypes &lt;- data.frame(type1=alleles[genecopy1],type2=alleles[genecopy2])
## Columns "type1","type2" each contains an allele type =&gt; input is "types" (the default)
datalist &lt;- binomialize(genotypes,responses=c("type1","type2"))

## two equivalent fits:
f1 &lt;- HLfit(cbind(npos,nneg)~1,data=datalist, family=binomial())
f2 &lt;- HLfit(cbind(npos,nneg)~1,data=genotypes, family=multi(responses=c("type1","type2")))
fitted(f2)

if (spaMM.getOption("example_maxtime")&gt;1.7) {

##### Control of lambda estimation over different binomial submodels

genoInSpace &lt;- data.frame(type1=alleles[genecopy1],type2=alleles[genecopy2],
                          x=runif(50),y=runif(50))
method &lt;- "PQL" # for faster exampple

## Fitting distinct variances for all binomial responses:           

multifit &lt;- corrHLfit(cbind(npos,nneg)~1+Matern(1|x+y),data=genoInSpace, 
                      family=multi(responses=c("type1","type2")),
                      ranFix=list(rho=1,nu=0.5), method=method)
length(unique(unlist(lapply(multifit, get_ranPars, which="lambda")))) # 3   

multifit &lt;- fitme(cbind(npos,nneg)~1+Matern(1|x+y),data=genoInSpace, 
                  family=multi(responses=c("type1","type2")),
                  init=list(lambda=NaN), # forcing 'inner' estimation for fitme 
                  fixed=list(rho=1,nu=0.5), method=method)
length(unique(unlist(lapply(multifit, get_ranPars, which="lambda")))) # 3          

## Fitting the same variance for all binomial responses:           

multifit &lt;- fitme(cbind(npos,nneg)~1+Matern(1|x+y),data=genoInSpace, 
                  family=multi(responses=c("type1","type2")),
                  init=list(lambda=NA), # forcing 'outer' estimation for fitme 
                  fixed=list(rho=1,nu=0.5), method=method)
length(unique(unlist(lapply(multifit, get_ranPars, which="lambda")))) # 1          

multifit &lt;- 
  corrHLfit(cbind(npos,nneg)~1+Matern(1|x+y),data=genoInSpace, 
            family=multi(responses=c("type1","type2")),
            init.corrHLfit=list(lambda=1), # forcing 'outer' estimation for corrHLfit 
            ranFix=list(rho=1,nu=0.5), method=method)
length(unique(unlist(lapply(multifit, get_ranPars, which="lambda")))) # 1          
}
</code></pre>


</div>