<div class="container">

<table style="width: 100%;"><tr>
<td>chol_s2Dp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build and Take the Cholesky Decomposition of a Covariance Matrix</h2>

<h3>Description</h3>

<p>The function first builds a correlation matrix with correlation.builder, 
converts that matrix to a covariance matrix if necessary, and then takes 
the Cholesky decomposition of the matrix using either base R or the R 
package <code>spam</code>. Note that <code>spam</code> is particularly effective when
the matrix is sparse.
</p>


<h3>Usage</h3>

<pre><code class="language-R">chol_s2Dp(
  matrix.type = "cov",
  im.res,
  use.spam = FALSE,
  corr.structure = "ar1",
  rho = NULL,
  phi = NULL,
  tau = 1,
  alpha = 0.75,
  corr.min = NULL,
  neighborhood = "none",
  w = NULL,
  h = NULL,
  r = NULL,
  print.R = FALSE,
  print.S = FALSE,
  print.Q = FALSE,
  sigma = 1,
  triangle = "upper",
  print.all = FALSE,
  round.d = FALSE,
  return.cov = TRUE,
  return.prec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrix.type</code></td>
<td>
<p>Determines whether to build a covariance matrix, 
<code>"cov"</code>, or a precision matrix, <code>"prec"</code>. See 
<code>correlation_builder{sim2Dpredictr}</code> and
<code>precision_builder{sim2Dpredictr}</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>im.res</code></td>
<td>
<p>A vector defining the dimension of spatial data. The first 
entry is the number of rows and the second  entry is the number of columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.spam</code></td>
<td>
<p>If <code>use.spam = TRUE</code> then use tools from the R package
<code>spam</code>; otherwise, base R functions are employed. For large dimension
MVN with sparse correlation structure, <code>spam</code> is recommended; 
otherwise, base R may be faster. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr.structure</code></td>
<td>
<p>One of <code>"ar1"</code>, <code>exponential</code>, 
<code>gaussian</code>, or <code>"CS"</code>. Correlations between locations i and j 
are <code>rho</code><code class="reqn">^{d}</code> for <code>corr.structure = "ar1"</code>, 
<code class="reqn">exp(-phi * d)</code> for <code>corr.structure = "exponential"</code>,
<code class="reqn">exp(-phi * d ^ 2)</code> for <code>corr.structure = "gaussian"</code>, and 
<code>rho</code> when <code>corr.structure = "CS"</code>. Note that <code>d</code> is the
Euclidean distance between locations i and j.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>This is the maximum possible correlation between locations i 
and j. For all i,j <code>rho</code> MUST be between -1 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>A scalar value greater than 0 that determines the decay rate of
correlation. This argument is only utilized when <code>corr.structure 
%in% c("exponential", "gaussian")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>A vector containing precision parameters. If of length 1, then 
all precisions are assumed equal. Otherwise the length of <code>tau</code> should 
equal the number of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A scalar value between 0 and 1 that defines the strength of 
correlations. Note that when <code>alpha = 0</code> the data are independent and
when <code>alpha = 1</code>, the joint distribution is the improper Intrinsic 
Autoregression (IAR), which cannot be used to generate data. Note also that
while <code>alpha</code> does control dependence it is not interpretable as a 
correlation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr.min</code></td>
<td>
<p>Scalar value to specify the minimum non-zero correlation. 
Any correlations below <code>corr.min</code> are set to 0. Especially for high 
image resolution using this option can result in a sparser covariance 
matrix, which may significantly speed up draws when using <code>spam</code>. 
This option is preferred to using <code>neighborhood</code> and associated 
arguments when the primary concern is to avoid very small correlations 
and improve computation efficiency. Default is <code>NULL</code>, which places
no restrictions on the correlations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighborhood</code></td>
<td>
<p>Defines the neighborhood within which marginal 
correlations are non-zero. The default is <code>"none"</code>, which allows 
marginal correlations to extend indefinitely. <code>neighborhood = "round"</code>
defines a circular neighborhood about locations and 
<code>neighborhood = "rectangle"</code> defines a rectangular neighborhood about
locations. Note that this argument differs from that in 
<code>precision_builder</code>, in which <code>neighborhood</code> defines conditional non-zero
correlations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w, h</code></td>
<td>
<p>If <code>neighborhood = "rectangle"</code> then w and h are the number
of locations to the left/right and above/below a location i that define 
its neighborhood. Any locations outside this neighborhood have have zero 
correlation with location i.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>If <code>neighborhood = "round"</code>, then if locations i,j are 
separated by distance <code class="reqn">d \ge r</code>, the correlation between them is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.R, print.S, print.Q</code></td>
<td>
<p>Logical. When <code>TRUE</code>, then print the 
correlation, covariance, or precision matrix before taking the Cholesky 
decomposition. If <code>sigma</code> = 1, then S = R.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Specify the desired standard deviations; the default is 1, in
which case the Cholesky decomposition is of a correlation matrix. If 
<code>sigma</code> != 1, then the Cholesky decomposition is of a covariance 
Matrix.
</p>

<ul>
<li>
<p> If sigma is a vector then length(sigma) must be equal to the
total number of locations, i.e. <code class="reqn">(n.row * n.col) by (n.row * n.col)</code>.
</p>
</li>
<li>
<p> sigma can take any scalar value when specifying common standard
deviation.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>triangle</code></td>
<td>
<p>Determine whether to output an upper 
(<code>triangle = "upper"</code>) or lower (<code>triangle = "lower"</code>) triangular
matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.all</code></td>
<td>
<p>If <code>print.all = TRUE</code>, then prints each correlation 
and allows you to check whether the correlations are as you intended. This
option is NOT recommended for large point lattices/images.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round.d</code></td>
<td>
<p>If <code>round.d = TRUE</code>, then d is rounded to the nearest 
whole number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.cov, return.prec</code></td>
<td>
<p>Logical. When <code>TRUE</code>, also return the 
covariance or precision matrix, respectively. This is recommended when 
using <code>spam</code> to generate draws from the MVN.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Matrix of dimension (n.row x n.col) x (n.row x n.col). If either 
<code>return.cov</code> or <code>return.prec</code> is <code>TRUE</code>, then returns a 
list where the first element is the covariance or precision matrix, and the
second element is the Cholesky factor.
</p>


<h3>References</h3>

<p>Banerjee S, Carlin BP, Gelfand AE (2015).
<em>Hierarchical Modeling and Analysis for Spatial Data</em>, Second edition.
Chapman &amp; Hall/CRC, Boca Raton, Florida.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>
<p>Rue H (2001).
“Fast Sampling of Gaussian Markov Random Fields.”
<em>Journal of the Royal Statistical Society B</em>, <b>63</b>, 325-338.
<a href="https://doi.org/10.1111/1467-9868.00288">doi:10.1111/1467-9868.00288</a>.
</p>
<p>Furrer R, Sain SR (2010).
“spam: A Sparse Matrix R Package with Emphasis on MCMC Methods for Gaussian Markov Random Fields.”
<em>Journal of Statistical Software</em>, <b>36</b>(10), 1-25.
<a href="https://www.jstatsoft.org/v36/i10/">https://www.jstatsoft.org/v36/i10/</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Use R package spam for Cholesky decomposition
R_spam &lt;- chol_s2Dp(im.res = c(3, 3), matrix.type = "prec",
                    use.spam = TRUE, neighborhood = "ar1",
                    triangle = "upper")

## Use base R for Cholesky decomposition
R_base &lt;- chol_s2Dp(corr.structure = "ar1", 
                    im.res = c(3, 3), rho = 0.15,
                    neighborhood = "round", 
                    r = 3, use.spam = FALSE)

## Specify standard deviations instead of default of sigma = 1.
R_sd &lt;- chol_s2Dp(corr.structure = "ar1",
                  im.res = c(3, 3), rho = 0.15,
                  neighborhood = "round", r = 3, 
                  sigma = runif(9, 1.1, 4))
## Not run: 
## Print options ON
R_pr_on &lt;- chol_s2Dp(corr.structure = "ar1", 
                     im.res = c(3, 3), rho = 0.15,
                     sigma = 1:9, neighborhood = "round", 
                     r = 3, print.R = TRUE, print.S = TRUE)
 
## End(Not run)

</code></pre>


</div>