<div class="container">

<table style="width: 100%;"><tr>
<td>geos_combine</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine or union feature geometries</h2>

<h3>Description</h3>

<p>Combine several feature geometries into one, without unioning or resolving internal boundaries
</p>


<h3>Usage</h3>

<pre><code class="language-R">st_combine(x)

st_union(x, y, ..., by_feature = FALSE, is_coverage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code> (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_feature</code></td>
<td>
<p>logical; if <code>TRUE</code>, union each feature if <code>y</code> is missing or else each pair of features; if <code>FALSE</code> return a single feature that is the geometric union of the set of features in <code>x</code> if <code>y</code> is missing, or else the unions of each of the elements of the Cartesian product of both sets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_coverage</code></td>
<td>
<p>logical; if <code>TRUE</code>, use an optimized algorithm for features that form a polygonal coverage (have no overlaps)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>st_combine</code> combines geometries without resolving borders, using c.sfg (analogous to c for ordinary vectors).
</p>
<p>If <code>st_union</code> is called with a single argument, <code>x</code>, (with <code>y</code> missing) and <code>by_feature</code> is <code>FALSE</code> all geometries are unioned together and an <code>sfg</code> or single-geometry <code>sfc</code> object is returned.
If <code>by_feature</code> is <code>TRUE</code> each feature geometry is unioned individually.
This can for instance be used to resolve internal boundaries after polygons were combined using <code>st_combine</code>.
If <code>y</code> is provided, all elements of <code>x</code> and <code>y</code> are unioned, pairwise if <code>by_feature</code> is TRUE, or else as the Cartesian product of both sets.
</p>
<p>Unioning a set of overlapping polygons has the effect of merging the areas (i.e. the same effect as iteratively unioning all individual polygons together).
Unioning a set of LineStrings has the effect of fully noding and dissolving the input linework. In this context "fully noded" means that there will be a node or endpoint in the output for every endpoint or line segment crossing in the input.
"Dissolved" means that any duplicate (e.g. coincident) line segments or portions of line segments will be reduced to a single line segment in the output.	Unioning a set of Points has the effect of merging all identical points (producing a set with no duplicates).
</p>


<h3>Value</h3>

<p><code>st_combine</code> returns a single, combined geometry, with no resolved boundaries; returned geometries may well be invalid.
</p>
<p>If <code>y</code> is missing, <code>st_union(x)</code> returns a single geometry with resolved boundaries, else the geometries for all unioned pairs of <code>x[i]</code> and <code>y[j]</code>.
</p>


<h3>See Also</h3>

<p>st_intersection, st_difference, st_sym_difference
</p>


<h3>Examples</h3>

<pre><code class="language-R">nc = st_read(system.file("shape/nc.shp", package="sf"))
st_combine(nc)
plot(st_union(nc))
</code></pre>


</div>