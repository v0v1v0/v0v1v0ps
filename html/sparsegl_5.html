<div class="container">

<table style="width: 100%;"><tr>
<td>cv.sparsegl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for a <code>sparsegl</code> object.</h2>

<h3>Description</h3>

<p>Performs k-fold cross-validation for <code>sparsegl()</code>.
This function is largely similar <code>glmnet::cv.glmnet()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.sparsegl(
  x,
  y,
  group = NULL,
  family = c("gaussian", "binomial"),
  lambda = NULL,
  pred.loss = c("default", "mse", "deviance", "mae", "misclass"),
  nfolds = 10,
  foldid = NULL,
  weights = NULL,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Double. A matrix of predictors, of dimension
<code class="reqn">n \times p</code>; each row
is a vector of measurements and each column is a feature. Objects of class
<code>Matrix::sparseMatrix</code> are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Double/Integer/Factor. The response variable.
Quantitative for <code>family="gaussian"</code> and for other exponential families.
If <code>family="binomial"</code> should be either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Character or function. Specifies the generalized linear model
to use. Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code> - least squares loss (regression, the default),
</p>
</li>
<li> <p><code>"binomial"</code> - logistic loss (classification)
</p>
</li>
</ul>
<p>For any other type, a valid <code>stats::family()</code> object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, <code>family = "gaussian"</code> and
<code>family = gaussian()</code> will produce the same results, but the first
will be much faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence. The default, <code>NULL</code>
results in an automatic computation based on <code>nlambda</code>, the smallest value
of <code>lambda</code> that would give the null model (all coefficient estimates equal
to zero), and <code>lambda.factor</code>. Supplying a value of <code>lambda</code> overrides
this behaviour. It is likely better to supply a
decreasing sequence of <code>lambda</code> values than a single (small) value. If
supplied, the user-defined <code>lambda</code> sequence is automatically sorted in
decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.loss</code></td>
<td>
<p>Loss to use for cross-validation error. Valid options are:
</p>

<ul>
<li> <p><code>"default"</code> the same as deviance (mse for regression and deviance otherwise)
</p>
</li>
<li> <p><code>"mse"</code> mean square error
</p>
</li>
<li> <p><code>"deviance"</code> the default (mse for Gaussian regression, and negative
log-likelihood otherwise)
</p>
</li>
<li> <p><code>"mae"</code> mean absolute error, can apply to any family
</p>
</li>
<li> <p><code>"misclass"</code> for classification only, misclassification error.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of folds - default is 10. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds = 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>An optional vector of values between 1 and <code>nfolds</code>
identifying which fold each observation is in. If supplied, <code>nfolds</code> can
be missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Double vector. Optional observation weights. These can
only be used with a <code>stats::family()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
<code>stats::family()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>sparsegl()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function runs <code>sparsegl()</code> <code>nfolds + 1</code> times; the first to
get the <code>lambda</code> sequence, and then the remainder to compute the fit
with each of the folds omitted. The average error and standard error
over the folds are computed.
</p>


<h3>Value</h3>

<p>An object of class <code>cv.sparsegl()</code> is returned, which is a
list with the components describing the cross-validation error.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The values of <code>lambda</code> used in the fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a vector of
length <code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvsd</code></td>
<td>
<p>Estimate of standard error of <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvupper</code></td>
<td>
<p>Upper curve = <code>cvm + cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlower</code></td>
<td>
<p>Lower curve = <code>cvm - cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>A text string indicating type of measure (for plotting
purposes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnzero</code></td>
<td>
<p>The number of non-zero coefficients for each <code>lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active_grps</code></td>
<td>
<p>The number of active groups for each <code>lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparsegl.fit</code></td>
<td>
<p>A fitted <code>sparsegl()</code> object for the full data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives
minimum cross validation error <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error
is within 1 standard error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The function call.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Liang, X., Cohen, A., Sólon Heinsfeld, A., Pestilli, F., and
McDonald, D.J. 2024.
<em>sparsegl: An <code>R</code> Package for Estimating Sparse Group Lasso.</em>
Journal of Statistical Software, Vol. 110(6): 1–23.
<a href="https://doi.org/10.18637/jss.v110.i06">doi:10.18637/jss.v110.i06</a>.
</p>


<h3>See Also</h3>

<p><code>sparsegl()</code>, as well as <code>plot()</code>,
<code>predict()</code>, and <code>coef()</code>
methods for <code>"cv.sparsegl"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
cv_fit &lt;- cv.sparsegl(X, y, groups)

</code></pre>


</div>