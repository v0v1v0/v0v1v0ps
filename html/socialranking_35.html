<div class="container">

<table style="width: 100%;"><tr>
<td>copelandScores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Copeland-like method</h2>

<h3>Description</h3>

<p>Based on <code>cpMajorityComparison()</code>, add or subtract scores
based on how an element fares against the others.
</p>
<p><code>copelandRanking()</code> returns the corresponding ranking.
</p>


<h3>Usage</h3>

<pre><code class="language-R">copelandScores(powerRelation, elements = powerRelation$elements)

copelandRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Strongly inspired by the Copeland score of social choice theory (Copeland 1951),
the Copeland-like solution is based on the net flow of the CP-majority graph (Allouche et al. 2020).
</p>
<p>Individuals are ordered according to the number of pairwise winning comparisons, minus the number of pairwise losing comparisons,
over the set of all CP-comparisons.
</p>
<p>More formally, in a given <code style="white-space: pre;">⁠PowerRelation pr⁠</code> with element <code class="reqn">i</code>, count the number of elements
<code class="reqn">j \in N \setminus \lbrace i \rbrace</code> where
<code>cpMajorityComparison</code><code style="white-space: pre;">⁠(pr, i, j) &gt;= 0⁠</code> and subtract those where
<code>cpMajorityComparison</code><code style="white-space: pre;">⁠(pr, i, j) &lt;= 0⁠</code>.
</p>


<h3>Value</h3>

<p>Score function returns a list of type <code>CopelandScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified). Each element is a vector of 2 numbers,
the number of pairwise winning comparisons and the number of pairwise losing comparisons.
Those two numbers summed together gives us the actual ordinal Copeland score.
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>References</h3>

<p>Allouche T, Escoffier B, Moretti S, Öztürk M (2020).
“Social Ranking Manipulability for the CP-Majority, Banzhaf and Lexicographic Excellence Solutions.”
In Bessiere C (ed.), <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 17–23.
<a href="https://doi.org/10.24963/ijcai.2020/3">doi:10.24963/ijcai.2020/3</a>, Main track.
</p>
<p>Copeland AH (1951).
“A reasonable social welfare function.”
mimeo, 1951. University of Michigan.
</p>


<h3>See Also</h3>

<p>Other CP-majority based functions: 
<code>cpMajorityComparison()</code>,
<code>kramerSimpsonScores()</code>
</p>
<p>Other ranking solution functions: 
<code>L1Scores()</code>,
<code>L2Scores()</code>,
<code>LPSScores()</code>,
<code>LPScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>lexcelScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># (123 ~ 12 ~ 3 ~ 1) &gt; (2 ~ 23) &gt; 13
pr &lt;- PowerRelation(list(
  list(c(1,2,3), c(1,2), 3, 1),
  list(c(2,3), 2),
  list(c(1,3))
))

copelandScores(pr)
# `1` = c(2, -1)
# `2` = c(2, -2)
# `3` = c(1, -2)

# only calculate results for two elements
copelandScores(pr, c(1,3))
# `1` = c(2, -1)
# `3` = c(1, -2)

# or just one element
copelandScores(pr, 2)
# `2` = c(2, -2)

# 1 &gt; 2 &gt; 3
copelandRanking(pr)

</code></pre>


</div>