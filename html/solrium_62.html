<div class="container">

<table style="width: 100%;"><tr>
<td>solr_mlt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>"more like this" search</h2>

<h3>Description</h3>

<p>Returns only more like this items
</p>


<h3>Usage</h3>

<pre><code class="language-R">solr_mlt(
  conn,
  name = NULL,
  params = NULL,
  body = NULL,
  callopts = list(),
  raw = FALSE,
  parsetype = "df",
  concat = ",",
  optimizeMaxRows = TRUE,
  minOptimizedRows = 50000L,
  progress = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conn</code></td>
<td>
<p>A solrium connection object, see SolrClient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>Name of a collection or core. Or leave as <code>NULL</code> if not needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>(list) a named list of parameters, results in a GET request
as long as no body parameters given</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>body</code></td>
<td>
<p>(list) a named list of parameters, if given a POST request
will be performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callopts</code></td>
<td>
<p>Call options passed on to crul::HttpClient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>(logical) If TRUE, returns raw data in format specified by wt param</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parsetype</code></td>
<td>
<p>(character) One of 'list' or 'df'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>concat</code></td>
<td>
<p>(character) Character to concatenate elements of longer than length 1.
Note that this only works reliably when data format is json (wt='json'). The parsing
is more complicated in XML format, but you can do that on your own.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizeMaxRows</code></td>
<td>
<p>(logical) If <code>TRUE</code>, then rows parameter will be
adjusted to the number of returned results by the same constraints.
It will only be applied if rows parameter is higher
than <code>minOptimizedRows</code>. Default: <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minOptimizedRows</code></td>
<td>
<p>(numeric) used by <code>optimizedMaxRows</code> parameter,
the minimum optimized rows. Default: 50000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>a function with logic for printing a progress
bar for an HTTP request, ultimately passed down to <span class="pkg">curl</span>. only supports
<code>httr::progress</code> for now. See the README for an example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further args to be combined into query</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>XML, JSON, a list, or data.frame
</p>


<h3>More like this parameters</h3>


<ul>
<li>
<p> q Query terms, defaults to '<em>:</em>', or everything.
</p>
</li>
<li>
<p> fq Filter query, this does not affect the search, only what gets returned
</p>
</li>
<li>
<p> mlt.count The number of similar documents to return for each result. Default is 5.
</p>
</li>
<li>
<p> mlt.fl The fields to use for similarity. NOTE: if possible these should have a stored
TermVector DEFAULT_FIELD_NAMES = new String[] "contents"
</p>
</li>
<li>
<p> mlt.mintf Minimum Term Frequency - the frequency below which terms will be ignored in
the source doc. DEFAULT_MIN_TERM_FREQ = 2
</p>
</li>
<li>
<p> mlt.mindf Minimum Document Frequency - the frequency at which words will be ignored which
do not occur in at least this many docs. DEFAULT_MIN_DOC_FREQ = 5
</p>
</li>
<li>
<p> mlt.minwl minimum word length below which words will be ignored.
DEFAULT_MIN_WORD_LENGTH = 0
</p>
</li>
<li>
<p> mlt.maxwl maximum word length above which words will be ignored.
DEFAULT_MAX_WORD_LENGTH = 0
</p>
</li>
<li>
<p> mlt.maxqt maximum number of query terms that will be included in any generated query.
DEFAULT_MAX_QUERY_TERMS = 25
</p>
</li>
<li>
<p> mlt.maxntp maximum number of tokens to parse in each example doc field that is not stored
with TermVector support. DEFAULT_MAX_NUM_TOKENS_PARSED = 5000
</p>
</li>
<li>
<p> mlt.boost (true/false) set if the query will be boosted by the interesting term relevance.
DEFAULT_BOOST = false
</p>
</li>
<li>
<p> mlt.qf Query fields and their boosts using the same format as that used in
DisMaxQParserPlugin. These fields must also be specified in mlt.fl.
</p>
</li>
<li>
<p> fl Fields to return. We force 'id' to be returned so that there is a unique identifier
with each record.
</p>
</li>
<li>
<p> wt (character) Data type returned, defaults to 'json'. One of json or xml. If json,
uses <code>fromJSON</code> to parse. If xml, uses <code>xmlParse</code> to
parse. csv is only supported in <code>solr_search</code> and <code>solr_all</code>.
</p>
</li>
<li>
<p> start Record to start at, default to beginning.
</p>
</li>
<li>
<p> rows Number of records to return. Defaults to 10.
</p>
</li>
<li>
<p> key API key, if needed.
</p>
</li>
</ul>
<h3>References</h3>

<p>See https://lucene.apache.org/solr/guide/8_2/morelikethis.html
for more information.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# connect
(conn &lt;- SolrClient$new(host = "api.plos.org", path = "search", port = NULL))

# more like this search
conn$mlt(params = list(q='*:*', mlt.count=2, mlt.fl='abstract', fl='score',
  fq="doc_type:full"))
conn$mlt(params = list(q='*:*', rows=2, mlt.fl='title', mlt.mindf=1,
  mlt.mintf=1, fl='alm_twitterCount'))
conn$mlt(params = list(q='title:"ecology" AND body:"cell"', mlt.fl='title',
  mlt.mindf=1, mlt.mintf=1, fl='counter_total_all', rows=5))
conn$mlt(params = list(q='ecology', mlt.fl='abstract', fl='title', rows=5))
solr_mlt(conn, params = list(q='ecology', mlt.fl='abstract',
  fl=c('score','eissn'), rows=5))
solr_mlt(conn, params = list(q='ecology', mlt.fl='abstract',
  fl=c('score','eissn'), rows=5, wt = "xml"))

# get raw data, and parse later if needed
out &lt;- solr_mlt(conn, params=list(q='ecology', mlt.fl='abstract', fl='title',
 rows=2), raw=TRUE)
solr_parse(out, "df")

## End(Not run)
</code></pre>


</div>