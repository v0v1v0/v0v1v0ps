<div class="container">

<table style="width: 100%;"><tr>
<td>trap.builder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Complex Detector Layouts
</h2>

<h3>Description</h3>

<p>Construct detector layouts comprising small arrays (clusters) replicated
across space, possibly at a probability sample of points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
trap.builder (n = 10, cluster, region = NULL, frame = NULL, 
    method = c("SRS", "GRTS", "all", "rank"), 
    edgemethod = c("clip", "allowoverlap", "allinside", "anyinside", "centreinside"), 
    samplefactor = 2, ranks = NULL, rotation = NULL, detector,
    exclude = NULL, exclmethod = c("clip", "alloutside", "anyoutside", "centreoutside"), 
    plt = FALSE, add = FALSE, ...)

mash (object, origin = c(0,0), clustergroup = NULL, ...)

cluster.counts (object)

cluster.centres (object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> integer number of clusters (ignored if method = "all") </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> traps object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p> bounding polygon(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frame</code></td>
<td>
<p> data frame of points used as a finite sampling frame </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> character string (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgemethod</code></td>
<td>
<p>character string (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplefactor</code></td>
<td>
<p> oversampling to allow for rejection of edge clusters
(multiple of n) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranks</code></td>
<td>
<p> vector of relative importance (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p> angular rotation of each cluster about centre (degrees) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detector</code></td>
<td>
<p> character detector type (see <code>detector</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p> polygon(s) from which detectors are to be excluded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclmethod</code></td>
<td>
<p>character string (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plt</code></td>
<td>
<p> logical: should array be plotted? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p> logical: add to existing plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> single-session multi-cluster capthist object, or traps
object for <code>cluster.centres</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p> new coordinate origin for detector array </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustergroup</code></td>
<td>
<p> list of vectors subscripting the clusters to be
mashed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed by trap.builder to spsurvey::grts (e.g., mindis) 
and by mash to make.capthist (e.g., sortrows)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The detector array in <code>cluster</code> is replicated <code>n</code>
times and translated to centres sampled from the area sampling frame
in <code>region</code> or the finite sampling frame in <code>frame</code>. Each
cluster may be rotated about its centre either by a fixed number of
degrees (<code>rotation</code> positive), or by a random angle (<code>rotation</code>
negative).
</p>
<p>If the <code>cluster</code> argument is not provided then single detectors of
the given type are placed according to the design.
</p>
<p>The sampling frame is finite (the points in <code>frame</code>) whenever
<code>frame</code> is not NULL. If <code>region</code> and <code>frame</code> are both
specified, sampling uses the finite frame but sites may be clipped
using the polygon.
</p>
<p><code>region</code> and <code>exclude</code> may be a two-column matrix or
dataframe of x-y coordinates for the boundary, or one of the other polygon 
sources listed in <code>boundarytoSF</code> (these allow multiple polygons). 
</p>
<p><code>method</code> may be "SRS", "GRTS", "all" or "rank". "SRS" takes a simple
random sample (without replacement in the case of a finite sampling
frame). "GRTS" takes a spatially representative sample using the
‘generalized random tessellation stratified’ (GRTS) method of Stevens
and Olsen (2004). "all" replicates <code>cluster</code> across all points in
the finite sampling frame. "rank" selects <code>n</code> sites from
<code>frame</code> on the basis of their ranking on the vector ‘ranks’,
which should have length equal to the number of rows in
<code>frame</code>; ties are resolved by drawing a site at random.
</p>
<p>Options for <code>edgemethod</code> are –
</p>

<table>
<tr>
<td style="text-align: left;">
  <code>edgemethod</code> </td>
<td style="text-align: left;"> Description</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>"clip"</code> </td>
<td style="text-align: left;"> reject any individual detectors outside <code>region</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  <code>"allowoverlap"</code> </td>
<td style="text-align: left;"> no action </td>
</tr>
<tr>
<td style="text-align: left;">
  <code>"allinside"</code> </td>
<td style="text-align: left;"> reject whole cluster if any component is outside <code>region</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  <code>"anyinside"</code> </td>
<td style="text-align: left;"> reject whole cluster if no component is inside <code>region</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>"centreinside"</code> </td>
<td style="text-align: left;"> reject whole cluster if centre outside <code>region</code>, and clip to <code>region</code>
  </td>
</tr>
</table>
<p>Similarly, <code>exclmethod</code> may be "clip" (reject individual detectors), 
"alloutside" (reject whole cluster if any component is outside <code>exclude</code>) etc. 
Sufficient additional samples (<code>(samplefactor--1) * n</code>) must be drawn to 
allow for replacement of any rejected clusters; otherwise, an error is reported 
(‘not enough clusters within polygon’).
</p>
<p>GRTS samples require function <code>grts</code> in version &gt;= 5.3.0 of package <span class="pkg">spsurvey</span> 
(Dumelle et al. 2022). More sophisticated stratified designs may be specified by using <code>grts</code>
directly.
</p>
<p><code>mash</code> collapses a multi-cluster capthist object as if all
detections were made on a single cluster. The new detector coordinates
in the ‘traps’ attribute are for a single cluster with (min(x),
min(y)) given by <code>origin</code>. <code>clustergroup</code> optionally selects
one or more groups of clusters to mash; if <code>length(clustergroup)
  &gt; 1</code> then a multisession capthist object will be generated, one
‘session’ per clustergroup. By default, all clusters are mashed.
</p>
<p><code>mash</code> discards detector-level covariates and occasion-specific
‘usage’, with a warning.
</p>
<p><code>cluster.counts</code> returns the number of <em>distinct</em>
individuals detected per cluster in a single-session multi-cluster
capthist object.
</p>
<p><code>cluster.centres</code> returns the centroid of the detector locations in each cluster. When clusters have been truncated these differ from the attribute <code>centres</code> set by <code>make.systematic</code>.
</p>


<h3>Value</h3>

<p><code>trap.builder</code> produces an object of class ‘traps’.
</p>
<p><code>plt = TRUE</code> causes a plot to be displayed, including the polygon
or finite sampling frame as appropriate.
</p>
<p><code>mash</code> produces a capthist object with the same number of rows as
the input but different detector numbering and ‘traps’. An attribute
‘n.mash’ is a vector of the numbers recorded at each cluster; its
length is the number of clusters. An attribute ‘centres’ is a
dataframe containing the x-y coordinates of the cluster centres. The
<code>predict</code> method for secr objects and the function <code>derived</code>
both recognise and adjust for mashing.
</p>
<p><code>cluster.counts</code> returns a vector with the number of individuals
detected at each cluster.
</p>
<p><code>cluster.centres</code> returns a dataframe of x- and y-coordinates.
</p>


<h3>Note</h3>

<p>The function <code>make.systematic</code> should be used to generate
systematic random layouts. It calls <code>trap.builder</code>.
</p>
<p>The sequence number of the cluster to which each detector belongs, and
its within-cluster sequence number, may be retrieved with the
functions <code>clusterID</code> and <code>clustertrap</code>.
</p>


<h3>References</h3>

<p>Dumelle, M., Kincaid, T. M., Olsen, A. R., and Weber, M. H. (2021). 
spsurvey: Spatial Sampling Design and Analysis. R package version 5.2.0.
</p>
<p>Stevens, D. L., Jr., and Olsen, A. R. (2004) Spatially-balanced
sampling of natural resources. <em>Journal of the American
Statistical Association</em> <b>99</b>, 262–278.
</p>


<h3>See Also</h3>

<p><code>make.grid</code>, <code>traps</code>,
<code>make.systematic</code>,
<code>clusterID</code>,
<code>clustertrap</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## solitary detectors placed randomly within a rectangle
tempgrid &lt;- trap.builder (n = 10, method = "SRS",
    region = cbind(x = c(0,1000,1000,0),
    y = c(0,0,1000,1000)), plt = TRUE)

## one detector in each 100-m grid cell -
## a form of stratified simple random sample
## see also Examples in ?make.grid

origins &lt;- expand.grid(x = seq(0, 900, 100),
    y = seq(0, 1100, 100))
XY &lt;- origins + runif(10 * 12 * 2) * 100
temp &lt;- trap.builder (frame = XY, method = "all",
    detector = "multi")
## same as temp &lt;- read.traps(data = XY)
plot(temp, border = 0)  ## default grid is 100 m

## Not run: 

## simulate some data
## regular lattice of mini-arrays
minigrid &lt;- make.grid(nx = 3, ny = 3, spacing = 50,
    detector = "proximity")
tempgrid &lt;- trap.builder (cluster = minigrid , method =
    "all", frame = expand.grid(x = seq(1000, 5000, 2000),
    y = seq(1000, 5000, 2000)), plt = TRUE)
tempcapt &lt;- sim.capthist(tempgrid, popn = list(D = 10))
cluster.counts(tempcapt)
cluster.centres(tempgrid)

## "mash" the CH
summary(mash(tempcapt))

## compare timings (estimates are near identical)
tempmask1 &lt;- make.mask(tempgrid, type = "clusterrect",
    buffer = 200, spacing = 10)
fit1 &lt;- secr.fit(tempcapt, mask = tempmask1, trace = FALSE)        

tempmask2 &lt;- make.mask(minigrid, spacing = 10)
fit2 &lt;- secr.fit(mash(tempcapt), mask = tempmask2, trace = FALSE)  
## density estimate is adjusted automatically
## for the number of mashed clusters (9)

predict(fit1)
predict(fit2)
fit1$proctime
fit2$proctime

## SRS excluding detectors from a polygon

region &lt;- cbind(x = c(0,6000,6000,0,0), y = c(0,0,6000,6000,0))
exclude &lt;- cbind(x = c(3000,7000,7000,3000,3000), y = c(2000,2000,4000,4000,2000))
newgrid &lt;- trap.builder (n = 40, cluster = minigrid,
    method = "SRS", edgemethod = "allinside", region = region,
    exclude = exclude, exclmethod = "alloutside",
    plt = TRUE)

## two-phase design: preliminary sample across region,
## followed by selection of sites for intensive grids

arena &lt;- data.frame(x = c(0,2000,2000,0), y = c(0,0,2500,2500))
t1 &lt;- make.grid(nx = 1, ny = 1)
t4 &lt;- make.grid(nx = 4, ny = 4, spacing = 50)
singletraps &lt;- make.systematic (n = c(8,10), cluster = t1,
    region = arena)
CH &lt;- sim.capthist(singletraps, popn = list(D = 2))
plot(CH, type = "n.per.cluster", title = "Number per cluster")
temp &lt;- trap.builder(10, frame = traps(CH), cluster = t4,
    ranks = cluster.counts(CH), method = "rank",
    edgemethod = "allowoverlap", plt = TRUE, add = TRUE)

## GRTS sample of mini-grids within a rectangle
## GRTS uses package 'spsurvey' &gt;= 5.3.0

minigrid &lt;- make.grid(nx = 3, ny = 3, spacing = 50,
    detector = "proximity")
region &lt;- cbind(x = c(0,6000,6000,0,0), y = c(0,0,6000,6000,0))

if (requireNamespace("spsurvey", versionCheck = list(version = "&gt;=5.3.0"))) {

  tempgrid &lt;- trap.builder (n = 20, cluster = minigrid, region = region, 
      plt = TRUE, method = "GRTS")
  
  # specifying minimum distance between cluster origins
  tempgrid2 &lt;- trap.builder (n = 20, cluster = minigrid, region = region, 
      plt = TRUE, method = "GRTS", mindis = 500, maxtry = 10)
  # use spsurvey::warnprnt() to view warnings (e.g., maxtry inadequate)
  
}


## End(Not run)

</code></pre>


</div>