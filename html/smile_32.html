<div class="container">

<table style="width: 100%;"><tr>
<td>fit_spm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting an underlying continuous process to areal data</h2>

<h3>Description</h3>

<p>Fitting an underlying continuous process to areal data
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_spm(x, ...)

## S3 method for class 'spm'
fit_spm(
  x,
  model,
  theta_st,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE,
  opt_method = "Nelder-Mead",
  control_opt = list(),
  comp_hess = TRUE,
  ...
)

fit_spm2(
  x,
  model,
  nu,
  tr,
  kappa = 1,
  mu2 = 1.5,
  comp_hess = TRUE,
  phi_min,
  phi_max,
  nphi = 10,
  cores = getOption("mc.cores", 1L)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of type <code>spm</code>. Note that, the dimension of
<code>theta_st</code> depends on the 2 factors. 1) the number of variables
being analyzed, and 2) if the input is a <code>spm</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters, either passed to stats::optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a <code>character</code> scalar indicating the family of the
covariance function to be used. The options are <code>c("matern",
    "pexp", "gaussian", "spherical", "gw")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_st</code></td>
<td>
<p>a <code>numeric</code> (named) vector containing the initial
parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>a <code>numeric</code> value indicating either the <code class="reqn">\nu</code>
parameter from the Matern covariance function (controlling the process
differentiability), or the "pexp" for the Powered Exponential family. If
the <code>model</code> chosen by the user is Matern and <code>nu</code> is not
informed, it is automatically set to .5. On the other hand, if the user
chooses the Powered Exponential family and do not inform <code>nu</code>,
then it is set to 1. In both cases, the covariance function becomes the
so called exponential covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr</code></td>
<td>
<p>tapper range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apply_exp</code></td>
<td>
<p>a <code>logical</code> scalar indicating whether the parameters
that cannot assume negative values should be exponentiate or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_method</code></td>
<td>
<p>a <code>character</code> scalar indicating the optimization
algorithm to be used. For details, see stats::optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_opt</code></td>
<td>
<p>a named <code>list</code> containing the control arguments for
the optimization algorithm to be used. For details, see stats::optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp_hess</code></td>
<td>
<p>a <code>boolean</code> indicating whether the Hessian matrix
should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_min</code></td>
<td>
<p>a <code>numeric</code> scalar representing the minimum <code class="reqn">phi</code>
value to look for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_max</code></td>
<td>
<p>a <code>numeric</code> scalar representing the maximum <code class="reqn">phi</code>
value to look for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nphi</code></td>
<td>
<p>a <code>numeric</code> scalar indicating the number of values to
compute a grid-search over <code class="reqn">phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>a <code>integer</code> scalar indicating number of cores to be used. Default is getOption("mc.cores"). No effect on Windows.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses the stats::optim function optimization
algorithms to find the Maximum Likelihood estimators, and their standard
errors, from a model adapted from. The function allows the user to input
the control parameters from the stats::optim function through the argument
<code>control_opt</code>, which is a named list. Additionally, the one can
input lower and upper boundaries for the optimization problem, as well
as the preferred optimization algorithm (as long as it is available for
stats::optim). The preferred algorithm is selected by the argument
<code>opt_method</code>. In addition to the control of the optimization, the
user can select a covariance function among the following: Matern,
Exponential, Powered Exponential, Gaussian, and Spherical. The parameter
<code>apply_exp</code> is a <code>logical</code> scalar such that, if set to
<code>TRUE</code>, the <code class="reqn">\exp</code> function is applied to the nonnegative
parameters, allowing the optimization algorithm to search for all the
parameters over the real numbers.
</p>
<div class="sourceCode"><pre>The model assumes \deqn{Y(\mathbf{s}) = \mu + S(\mathbf{s})} at the
point level.  Where \eqn{S ~ GP(0, \sigma^2 C(\lVert \mathbf{s} -
    \mathbf{s}_2 \rVert; \theta))}.  Further, the observed data is supposed
to be \eqn{Y(B) = \lvert B \rvert^{-1} \int_{B} Y(\mathbf{s}) \,
    \textrm{d} \mathbf{s}}.
</pre></div>


<h3>Value</h3>

<p>a <code>spm_fit</code> object containing the information about the
estimation of the model parameters.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(liv_lsoa) ## loading the LSOA data

msoa_spm &lt;- sf_to_spm(sf_obj = liv_msoa, n_pts = 500,
                      type = "regular", by_polygon = FALSE,
                      poly_ids = "msoa11cd",
                      var_ids = "leb_est")
## fitting model
theta_st_msoa &lt;- c("phi" = 1) # initial value for the range parameter

fit_msoa &lt;-
   fit_spm(x = msoa_spm,
           theta_st = theta_st_msoa,
           model = "matern",
           nu = .5,
           apply_exp  = TRUE,
           opt_method = "L-BFGS-B",
           control    = list(maxit = 500))

AIC(fit_msoa)

summary_spm_fit(fit_msoa, sig = .05)

</code></pre>


</div>