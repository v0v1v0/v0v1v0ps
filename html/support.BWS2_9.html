<div class="container">

<table style="width: 100%;"><tr>
<td>bws2.response</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generating artificial responses to Case 2 best-worst scaling questions
</h2>

<h3>Description</h3>

<p>The function synthesizes responses to Case 2 best-worst scaling (BWS) questions on the basis of a paired (maximum difference) model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bws2.response(design, attribute.levels, base.level = NULL,
 b, n, detail = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>

<p>A matrix or data frame containing an orthogonal main-effect design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attribute.levels</code></td>
<td>

<p>A list containing the names of the attributes and their levels.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base.level</code></td>
<td>

<p>A list containing the base level for each attribute.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>

<p>A vector containing parameters of independent variables in the model. The vector is used to calculate utilities for alternatives.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>An integer value showing the number of respondents in the resultant dataset.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>

<p>A logical variable: if <code>TRUE</code>, the dataset is returned in a detailed format; and if <code>FALSE</code> (default), the dataset is returned in a simple format.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>Seed for a random number generator.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function synthesizes responses to Case 2 BWS questions on the basis of a paired (maximum difference) model with attribute and/or level variables (see Model 1 and Model 2 in Aizaki and Fogarty (2019) for details). The model assumes that a profile has <code class="reqn">m</code> attributes and each attribute has two or more levels. The profile is expressed as a combination of <code class="reqn">m</code> levels. The number of possible pairs where level <code class="reqn">i</code> is selected as the best and level <code class="reqn">j</code> is selected as the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">m</code> levels is given by <code class="reqn">m \times (m - 1)</code>. The model also assumes that the respondents select level <code class="reqn">i</code> as the best and level <code class="reqn">j</code> as the worst because the difference in utility between levels <code class="reqn">i</code> and <code class="reqn">j</code> is the highest among all of the <code class="reqn">m \times (m - 1)</code> differences in utility. The systematic component of the utility is assumed to be a linear additive function of the attribute and level variables (Model 2 has no attribute variables). If the error component of the utility is assumed to be an independently, identically distributed type I extreme value, the probability of selecting level <code class="reqn">i</code> as the best and level <code class="reqn">j</code> as the worst is expressed as a conditional logit model.
</p>
<p>Given the parameter values assigned to the argument <code>b</code> and the choice sets assigned to the argument <code>design</code>, the function <code>bws2.response</code> calculates the utility for the levels. The parameter values assigned to the argument <code>b</code> are set as a numerical vector where the elements correspond to the parameters of attribute and/or level variables. The variables are set according to the model specification. Assume that a profile has four attributes A, B, C, and D with three levels each (e.g., levels A1, A2, and A3 for attribute A). For Model 1, dummy-coded attribute variables and effect-coded level variables are used, an arbitrary attribute is set as the base (reference) level, and an arbitrary level for each attribute is set as the base level. If the parameters of the dummy-coded attribute variables <code class="reqn">D_{A}</code>, <code class="reqn">D_{B}</code>, and <code class="reqn">D_{C}</code> are <code class="reqn">1.75</code>, <code class="reqn">1.31</code>, and <code class="reqn">0.84</code>, respectively (i.e., attribute D is the base attribute), and those of the effect-coded level variables <code class="reqn">D_{A1}</code>, <code class="reqn">D_{A2}</code>, <code class="reqn">D_{B1}</code>, <code class="reqn">D_{B2}</code>, <code class="reqn">D_{C1}</code>, <code class="reqn">D_{C2}</code>, <code class="reqn">D_{D1}</code>, and <code class="reqn">D_{D2}</code> are <code class="reqn">-1.24</code>, <code class="reqn">0.18</code>, <code class="reqn">-1.11</code>, <code class="reqn">0.10</code>, <code class="reqn">-1.11</code>, <code class="reqn">0.39</code>, <code class="reqn">-0.25</code>, and <code class="reqn">-0.37</code>, respectively (i.e., levels A3, B3, C3, and D3 are the base levels), a vector assigned to the argument <code>b</code> is given by <code>c(1.75, 1.31, 0.84, 0, -1.24, 0.18, -1.11, 0.10, -1.11, 0.39, -0.25, -0.37)</code>, where the fourth element corresponds to the base attribute (D), and thus has a value of 0. For Model 2, dummy-coded level variables are used and an arbitrary level is set as the base level. If the parameters of the dummy-coded level variables <code class="reqn">D_{A1}</code>, <code class="reqn">D_{A2}</code>, <code class="reqn">D_{A3}</code>, <code class="reqn">D_{B1}</code>, <code class="reqn">D_{B2}</code>, <code class="reqn">D_{B3}</code>, <code class="reqn">D_{C1}</code>, <code class="reqn">D_{C2}</code>, <code class="reqn">D_{C3}</code>, <code class="reqn">D_{D1}</code>, and <code class="reqn">D_{D2}</code> are <code class="reqn">-0.10</code>, <code class="reqn">1.32</code>, <code class="reqn">2.19</code>, <code class="reqn">-0.42</code>, <code class="reqn">0.79</code>, <code class="reqn">1.69</code>, <code class="reqn">-0.89</code>, <code class="reqn">0.62</code>, <code class="reqn">0.94</code>, <code class="reqn">-0.87</code>, and <code class="reqn">-0.99</code>, respectively (i.e., level D3 is the base level), a vector assigned to the argument <code>b</code> is given as <code>c(-0.10, 1.32, 2.19, -0.42, 0.79, 1.69, -0.89, 0.62, 0.94, -0.87, -0.99, 0)</code>, where the last element corresponds to the base level (D3), and thus has a value of 0. After calculating the utility values (by adding the calculated values of the systematic component of the utility and random numbers generated from a type I extreme value distribution), the function bws2.response finds the pair with the highest difference in utility from the <code class="reqn">m \times (m - 1)</code> differences in utility.
</p>


<h3>Value</h3>

<p>The function <code>bws2.response</code> returns a data frame that contains synthesized responses to Case 2 BWS questions, in either a detailed or a simple format. The detailed format dataset contains the following variables, as well as independent variables according to the arguments <code>attribute.levels</code> and <code>base.level</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>A serial number of questions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PAIR</code></td>
<td>

<p>A serial number of possible pairs of the best and worst levels for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BEST</code></td>
<td>

<p>An alternative number treated as the best in the possible pairs of the best and worst levels.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WORST</code></td>
<td>

<p>An alternative number treated as the worst in the possible pairs of the best and worst levels.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BEST.AT</code></td>
<td>

<p>A character showing the attribute corresponding to the level treated as the best in the possible pairs of the best and worst levels for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WORST.AT</code></td>
<td>

<p>A character showing the attribute corresponding to the level treated as the worst in the possible pairs of the best and worst levels for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BEST.LV</code></td>
<td>

<p>A character showing the level treated as the best in the possible pairs of the best and worst levels for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WORST.LV</code></td>
<td>

<p>A character showing the level treated as the worst in the possible pairs of the best and worst levels for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RES</code></td>
<td>

<p>Responses to BWS questions, taking the value of 1 if a possible pair of the best and worst levels is selected by the synthesized respondents and 0 otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STR</code></td>
<td>

<p>A stratification variable used to identify each combination of respondent and question.
</p>
</td>
</tr>
</table>
<p>The simple format dataset contains the following variables.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bi</code></td>
<td>

<p>A variable describing the row number of the level that is selected as the best in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>B1</code> for the first question, <code>B2</code> for the second question, and <code>B3</code> for the third question).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wi</code></td>
<td>

<p>A variable describing the row number of the level that is selected as the worst in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>W1</code> for the first question, <code>W2</code> for the second question, and <code>W3</code> for the third question).
</p>
</td>
</tr>
</table>
<p>The detailed format dataset includes a dependent variable and independent variables for the analysis, and thus is available for discrete choice analysis functions such as the function <code>clogit</code> in the <b>survival</b> package. On the other hand, the simple format dataset only contains variables that correspond to responses to BWS questions, as well as <code>id</code> variable. It must be converted using the function <code>bws2.dataset</code> in the package for the analysis. For details, see the Examples section.
</p>


<h3>References</h3>

<p>See the help page for <code>support.BWS2-package</code>.
</p>


<h3>See Also</h3>

<p><code>support.BWS2-package</code>, 
<code>bws2.dataset</code>, 
<code>clogit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The following lines of code synthesize responses to Case 2 BWS questions,
# return them in detailed and simple format, and then fit the models using
# the function clogit in the survival package. The profiles are expressed
# by four attributes with three levels each. The parameters for the attribute
# and level variables are the same as those explained in the Details section.

## Not run: 
# Load packages
library(survival)
library(support.BWS2)

# Set design for BWS2 questions
dsgn &lt;- cbind(
  c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  c(1, 2, 3, 1, 2, 3, 1, 2, 3),
  c(1, 3, 2, 3, 2, 1, 2, 1, 3),
  c(1, 2, 3, 3, 1, 2, 2, 3, 1))

# Synthesize responses to BWS2 questions (Model 1)
## attributes and their levels
attr.lev &lt;- list(
  A = c("A1", "A2", "A3"), B = c("B1", "B2", "B3"),
  C = c("C1", "C2", "C3"), D = c("D1", "D2", "D3"))
## base levels
base.lev &lt;- list(A = "A3", B = "B3", C = "C3", D = "D3")
## parameters
b1 &lt;- c(1.75, 1.31, 0.84, 0,       # pars for A, B, C, and D  
        -1.24, 0.18, -1.11, 0.10,  # pars for A1, A2, B1, and B2
        -1.11, 0.39, -0.25, -0.37) # pars for C1, C2, D1, and D2
## dataset in detailed format
dat.detail1 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  base.level = base.lev,
  b = b1,
  n = 100,
  detail = TRUE,
  seed = 123)
str(dat.detail1)
## dataset in simple format 
dat.simple1 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  base.level = base.lev,
  b = b1,
  n = 100,
  detail = FALSE,
  seed = 123) 
str(dat.simple1)

# Convert dat.simple1 into dataset for the analysis
rsp.var1 &lt;- colnames(dat.simple1)[-1]
dat.simple1.pr &lt;- bws2.dataset(
  data = dat.simple1,
  id = "id",
  response = rsp.var1,  
  choice.sets = dsgn,        
  attribute.levels = attr.lev,
  base.level = base.lev,
  model = "paired")

# Fit conditional logit models
mf1 &lt;- RES ~ A + B + C + A1 + A2 + B1 + B2 + C1 + C2 + 
             D1 + D2 + strata(STR)
out.detail1 &lt;- clogit(formula = mf1, data = dat.detail1)
out.simple1 &lt;- clogit(formula = mf1, data = dat.simple1.pr)
out.simple1
all.equal(coef(out.detail1), coef(out.simple1))


# Synthesize responses to BWS2 questions (Model 2)
## parameters
b2 &lt;- c(-0.10, 1.32, 2.19, # pars for A1, A2, and A3
        -0.42, 0.79, 1.69, # pars for B1, B2, and B3
        -0.89, 0.62, 0.94, # pars for C1, C2, and C3
        -0.87, -0.99, 0)   # pars for D1, D2, and D3
## dataset in detailed format
dat.detail2 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  b = b2,
  n = 100,
  detail = TRUE,
  seed = 123)
str(dat.detail2)
## dataset in simple format 
dat.simple2 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  b = b2,
  n = 100,
  detail = FALSE,
  seed = 123) 
str(dat.simple2)

# Convert dat.simple2 into dataset for the analysis
rsp.var2 &lt;- colnames(dat.simple2)[-1]
dat.simple2.pr &lt;- bws2.dataset(
  data = dat.simple2,
  id = "id",
  response = rsp.var2,  
  choice.sets = dsgn,        
  attribute.levels = attr.lev,
  model = "paired")

# Fit conditional logit models
mf2 &lt;- RES ~ A1 + A2 + A3 + B1 + B2 + B3 + C1 + C2 + C3 +
             D1 + D2 + strata(STR)
out.detail2 &lt;- clogit(formula = mf2, data = dat.detail2)
out.simple2 &lt;- clogit(formula = mf2, data = dat.simple2.pr)
out.simple2
all.equal(coef(out.detail2), coef(out.simple2))

## End(Not run)
</code></pre>


</div>