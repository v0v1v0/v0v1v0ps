<div class="container">

<table style="width: 100%;"><tr>
<td>slide_period</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Slide relative to an index chunked by period</h2>

<h3>Description</h3>

<p><code>slide_period()</code> breaks up the <code>.i</code>-ndex by <code>.period</code>, and then uses that
to define the indices to slide over <code>.x</code> with.
</p>
<p>It can be useful for, say, sliding over daily data in monthly chunks.
</p>
<p>The underlying engine for breaking up <code>.i</code> is <code>warp::warp_distance()</code>.
If you need more information about the <code>.period</code> types, that is the best
place to look.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slide_period(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_vec(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_period_dbl(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_int(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_lgl(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_chr(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_dfr(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_period_dfc(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.i</code></td>
<td>
<p><code style="white-space: pre;">⁠[Date / POSIXct / POSIXlt]⁠</code>
</p>
<p>A datetime index to break into periods.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li>
<p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li>
<p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li>
<p> The index cannot have missing values.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.period</code></td>
<td>
<p><code style="white-space: pre;">⁠[character(1)]⁠</code>
</p>
<p>A string defining the period to group by. Valid inputs can be roughly
broken into:
</p>

<ul>
<li> <p><code>"year"</code>, <code>"quarter"</code>, <code>"month"</code>, <code>"week"</code>, <code>"day"</code>
</p>
</li>
<li> <p><code>"hour"</code>, <code>"minute"</code>, <code>"second"</code>, <code>"millisecond"</code>
</p>
</li>
<li> <p><code>"yweek"</code>, <code>"mweek"</code>
</p>
</li>
<li> <p><code>"yday"</code>, <code>"mday"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p><code style="white-space: pre;">⁠[function / formula]⁠</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.every</code></td>
<td>
<p><code style="white-space: pre;">⁠[positive integer(1)]⁠</code>
</p>
<p>The number of periods to group together.
</p>
<p>For example, if the period was set to <code>"year"</code> with an every value of <code>2</code>,
then the years 1970 and 1971 would be placed in the same group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.origin</code></td>
<td>
<p><code style="white-space: pre;">⁠[Date(1) / POSIXct(1) / POSIXlt(1) / NULL]⁠</code>
</p>
<p>The reference date time value. The default when left as <code>NULL</code> is the
epoch time of <code style="white-space: pre;">⁠1970-01-01 00:00:00⁠</code>, <em>in the time zone of the index</em>.
</p>
<p>This is generally used to define the anchor time to count from, which is
relevant when the every value is <code style="white-space: pre;">⁠&gt; 1⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.before, .after</code></td>
<td>
<p><code style="white-space: pre;">⁠[integer(1) / Inf]⁠</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to "look forward" from the current element if used as the
<code>.before</code> value, or "look backwards" if used as <code>.after</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.complete</code></td>
<td>
<p><code style="white-space: pre;">⁠[logical(1)]⁠</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ptype</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(0) / NULL]⁠</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li>
<p> By default, input names are zapped.
</p>
</li>
<li>
<p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li>
<p> If <code>NULL</code>, the input names are used as row names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code>vec_as_names()</code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse recycling rules.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_period()</code></h4>


<ul>
<li> <p><code>vec_size(slide_period(.x)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period(.x)) == list()</code>
</p>
</li>
</ul>
<h4>
<code>slide_period_vec()</code> and <code style="white-space: pre;">⁠slide_period_*()⁠</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_period_vec(.x)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_size(slide_period_vec(.x)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period_vec(.x, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>block()</code>, <code>slide()</code>, <code>slide_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">i &lt;- as.Date("2019-01-28") + 0:5

# Split `i` into 2-day periods to apply `.f` to
slide_period(i, i, "day", identity, .every = 2)

# Or into 1-month periods
slide_period(i, i, "month", identity)

# Now select:
# - The current 2-day period
# - Plus 1 2-day period before the current one
slide_period(i, i, "day", identity, .every = 2, .before = 1)

# Alter the `origin` to control the reference date for
# how the 2-day groups are formed
origin &lt;- as.Date("2019-01-29")
slide_period(i, i, "day", identity, .every = 2, .origin = origin)

# This can be useful for, say, monthly averages
daily_sales &lt;- c(2, 5, 3, 6, 9, 4)
slide_period_dbl(daily_sales, i, "month", mean)

# If you need the index, slide over and return a data frame
sales_df &lt;- data.frame(i = i, sales = daily_sales)

slide_period_dfr(
  sales_df,
  sales_df$i,
  "month",
  ~data.frame(
     i = max(.x$i),
     sales = mean(.x$sales)
   )
)

# One of the most unique features about `slide_period()` is that it is
# aware of how far apart elements of `.i` are in the `.period` you are
# interested in. For example, if you do a monthly slide with `i2`, selecting
# the current month and 1 month before it, then it will recognize that
# `2019-02-01` and `2019-04-01` are not beside each other, and it won't
# group them together.
i2 &lt;- as.Date(c("2019-01-01", "2019-02-01", "2019-04-01", "2019-05-01"))

slide_period(i2, i2, "month", identity, .before = 1)

</code></pre>


</div>