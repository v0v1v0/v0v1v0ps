<div class="container">

<table style="width: 100%;"><tr>
<td>sor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Sequentially Offsetted Regression
</h2>

<h3>Description</h3>

<p>Fits model for data which was sampled based on a variable associated with the outcome.  This function works for binary, count, and continuous responses.
</p>


<h3>Usage</h3>

<pre><code class="language-R">	    sor(y.formula,
              	w1.formula,
                w2.formula = ~1,
                id,
                waves = NULL,
                family = "binomial",
                y0 = 0,
                hfunc = identity, 
                support = c(0,1),
                pi1.pi0.ratio = 1,  
                data = parent.frame(),
                init.beta=NULL,
                init.sig.2 = 1,
                weights=NULL,
                est.var = TRUE,
                CORSTR="independence")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y.formula</code></td>
<td>

<p>Regression formula for response
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w1.formula</code></td>
<td>

<p>Formula for Z, not interacted with hfunc(Y).  Of form Z~terms
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w2.formula</code></td>
<td>

<p>Formula for Z, interacted with hfunc(Y).  Of form ~terms
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>a vector identifying the clusters. By default, data are assumed to be sorted such that observations in a cluster are in consecutive rows and higher numbered rows in a cluster are assumed to be later.  If NULL, then each observation is assigned its own cluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>waves</code></td>
<td>

<p>an integer vector identifying components of a cluster. For example, this could be a time ordering. If integers are skipped within a cluster, then dummy rows with weight 0 are added in an attempt to preserve the correlation structure (except if <code>corstr = "exchangeable"</code> or <code>"independent"</code>). This can be skipped by setting <code>nodummy=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>Character string representing reference distribution for the response.  Can be one of "normal", "poisson", or "binomial".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y0</code></td>
<td>

<p>Representative value of response.  Ignored if <code>family="binomial"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hfunc</code></td>
<td>

<p>Function h, used with Y.  Set to identity if <code>family="binomial"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>

<p>Values on which to evaluate the integrals.  The lowest value should be less than the minimum response and the highest should be higher than the maximum response.  If response is binary, support should be c(0,1).  If response is count data, support should be an integer vector, for instance 0:50.  If response is continuous, support should be a vector of points on which to integrate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi1.pi0.ratio</code></td>
<td>

<p>The referral ratio
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Data frame or environment with all the data
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.beta</code></td>
<td>

<p>Initial values for parameters in <code>y.formula</code>.  Convergence may depend heavily on the initial values used.  If <code>family="binomial"</code>, the default is recommended.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.sig.2</code></td>
<td>

<p>Initial value for sigma^2.  Only for <code>family="normal"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>A vector of weights for each observation.  If an observation has weight 0, it is excluded from the calculations of any parameters.  Observations with a <code>NA</code> anywhere (even in variables not included in the model) will be assigned a weight of 0.  This should normally be used to preserve the correlation structure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.var</code></td>
<td>

<p>Logical.  Should the variance be estimated.  Only for <code>family="normal"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CORSTR</code></td>
<td>

<p>Correlation structure
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list with values from the fit.

</p>


<h3>Author(s)</h3>

<p>Lee S. McDaniel, Jonathan S. Schildcrout

</p>


<h3>References</h3>

<p>This package relies heavily on code from geeM:
</p>
<p>McDaniel, L. S., Henderson, N. C., &amp; Rathouz, P. J. (2013). Fast pure R implementation of GEE: application of the matrix package. The R journal, 5(1), 181.
</p>


<h3>Examples</h3>

<pre><code class="language-R">generatedata &lt;- function(beta,alpha,X,ntime,nsubj, betat, betat1)  {
  
  mean.vec &lt;- exp(crossprod(t(X), beta))
  y &lt;- matrix(0,nrow=nsubj, ncol=ntime)
  y[,1] &lt;- rpois(nsubj ,lambda = mean.vec)
  old.mean &lt;- mean.vec
  new.mean &lt;- old.mean*exp(betat + betat1*X[,2])
  for (t in 1:(ntime-1))  {
    lambda.t &lt;- new.mean - alpha*sqrt(old.mean*new.mean)
    theta.t &lt;- alpha*sqrt(new.mean/old.mean)
    I &lt;- rpois(nsubj, lambda = lambda.t)
    W &lt;- rbinom(nsubj, y[,t], theta.t)
    
    y[,t+1] = W + I
    old.mean &lt;- new.mean
    new.mean &lt;- old.mean*exp(betat + betat1*X[,2])
  }
  longform &lt;- c(t(y))
  time &lt;- rep(1:ntime,times=nsubj)
  subject &lt;- rep(c(1:nsubj),each=ntime)
  
  simdata &lt;- data.frame(count = longform, time = time, subject=subject)
  return(simdata)
}
logit &lt;- function(p) log(p)-log(1-p)
expit &lt;- function(x) exp(x)/(1+exp(x))
set.seed(1)

npop &lt;- 10000
beta0 &lt;- -1.4
beta1 &lt;- 0.4
alpha &lt;- 0.9
gam0 &lt;- -3.15
gam1 &lt;- 6.3
nsubj &lt;- 200
ntime &lt;- 8
betat &lt;- -0.1; betat1 &lt;- 0.1
thresh &lt;- 1

x0 &lt;- rep(1, npop)
x1 &lt;- rbinom(npop, 1, 0.5)

Xmat &lt;- cbind(x0, x1)
timevec &lt;- 0:(ntime-1)

testdat &lt;- generatedata(c(beta0, beta1), alpha, Xmat, ntime, npop, betat = betat, betat1 = betat1)
Y &lt;- matrix(testdat$count, nrow=npop, ncol=ntime, byrow=TRUE)
lambdap &lt;- expit(gam0 + gam1*as.numeric(Y[,1]&gt;=thresh))
Z &lt;- rbinom(npop, 1, lambdap)

casesamp &lt;- rep(0, npop)
casesamp[Z==1] &lt;- rbinom(sum(Z), 1, nsubj/(2*sum(Z)))
controlsamp &lt;- rep(0, npop)
controlsamp[Z==0] &lt;- rbinom(sum(1-Z), 1, nsubj/(2*sum(1-Z)))


case &lt;- which(casesamp==1)
control &lt;- which(controlsamp==1)
id &lt;- sort(c(case, control))
nsubj &lt;- length(control) + length(case)
Ysamp &lt;- NULL
lamsamp &lt;- NULL
zsamp &lt;- NULL
x1samp &lt;- NULL
idsamp &lt;- NULL
time &lt;- NULL
obspersubj &lt;- sample(3:ntime, size=nsubj, replace=TRUE)
for(i in 1:nsubj){
  Ysamp &lt;- c(Ysamp, Y[id[i],1:obspersubj[i]])
  zsamp &lt;- c(zsamp, rep(as.numeric(Z[id[i]]), obspersubj[i]))
  x1samp &lt;- c(x1samp, rep(x1[id[i]], obspersubj[i]))
  time &lt;- c(time, 0:(obspersubj[i]-1))
  idsamp &lt;- c(idsamp, rep(i, obspersubj[i]))
}
p1p0 &lt;- sum((1-Z))/sum(Z)

timemax &lt;- pmax(time-2, 0)
y0 &lt;- 1
betas &lt;- c(beta0, beta1, betat, betat1)
init &lt;-  runif(4, betas -0.1, betas + 0.1)

y.formula &lt;- y~x1+time + x1:time
w1 &lt;- z ~ x1+ as.factor(time) +  x1:time + x1:timemax 
w2 &lt;- ~x1 + time + timemax + x1:time + x1:timemax 

DAT.ods &lt;- data.frame("x1"= x1samp, "time" = time,
                      "timemax" = timemax, "z" = zsamp, "y" = Ysamp, "id" = idsamp)

sor(y.formula, w1, w2, id, family="poisson",y0=1,
    support=0:25, pi1.pi0.ratio=p1p0, data=DAT.ods, init.beta=init, CORSTR="ar1")



</code></pre>


</div>