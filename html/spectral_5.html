<div class="container">

<table style="width: 100%;"><tr>
<td>BP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simple bandpass function</h2>

<h3>Description</h3>

<p>This function represents a simple weightening procedure for spectral filtering accoring
to the type (<code>"poly", "sinc", "bi-cubic", "gauss"</code>) provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BP(f, fc, BW, n = 3, type = "poly")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>vector of frequencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fc</code></td>
<td>
<p>center frequency</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BW</code></td>
<td>
<p>bandwidth, with <code>w[ abs(f - fc) &gt; BW ] == min</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>degree of the polynom, <code>n</code> can be real, e.g. <code>n = 1.6 as sinc alike</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of weightening function: "poly", "sinc", "bi-cubic", "exp", can be abbreviated</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The band pass is represented troughout a function in the form of four different types:
</p>
<p>1. polynominial function </p>
<p style="text-align: center;"><code class="reqn">w = 1 - |((f - fc) / BW)|^n </code>
</p>
<p> with the degree <code class="reqn">n</code>. The parameter <code class="reqn">fc</code>
controlls the center frequency and desired band width <code>BW</code>. Outside the band width
</p>
<p style="text-align: center;"><code class="reqn">|f - fc| &gt; BW</code>
</p>
<p> the result is forced to zero. With <code>n =  1.6</code> a quasi sinc-filter
without side bands can be constructed. A quasi rectangular window can be gained by setting
<code>n &gt; 5</code>.
</p>
<p>2. sinc function corresponds to a rectangular observation window in time domain
with </p>
<p style="text-align: center;"><code class="reqn">\Delta T ~ 1/BW</code>
</p>
<p>. It values ALL frequencies according to the si(x) function.
Calculation speed might be reduced.
</p>
<p>3. bi-cubic encounters 2nd order interpolation kernel, providing a quasi rectangular observation window.
</p>
<p>4. exponential Gauss curve. Here the band width is defined as the value of 90
</p>


<h3>Value</h3>

<p>This function returns a weight vector [0..1], which is to apply to the frequency
vector <code>f</code> in a top level function
</p>


<h3>Examples</h3>

<pre><code class="language-R">
f &lt;- seq(-50,50,by = 1e-2)
fc &lt;- 0.3
BW &lt;- 0.75


par(mfrow = c(2,1))

curve(BP(x,fc = fc, BW = BW, type = "p"), -2,2, ylim = c(-0.2,1)
      ,main = "Filter weights"
      ,xlab = "fx",ylab = "w"
)
curve(BP(x,fc = fc, BW = BW, type = "s"), add = TRUE, lty = 2)
curve(BP(x,fc = fc, BW = BW, type = "b"), add = TRUE, lty = 3)
curve(BP(x,fc = fc, BW = BW, type = "g"), add = TRUE, lty = 4)

abline(v = c(fc,fc+BW,fc-BW), lty = 3, col = "grey")

# the corresponding Fourier-Transforms

ty &lt;- c("p","s","b","g")
A0 &lt;- integrate(BP,fc = fc, BW = BW, type = "s",lower = -2,upper = 2)$value

plot(NA,NA,xlab = "x", ylab = "|A|"
     ,main = "corresponding convolution kernels"
     ,xlim = 2*c(-1,1),ylim = c(0, sqrt(2)*A0/(length(f)*BW*min(diff(f))) )
)
for(i in 1:length(ty))
{
  FT &lt;- spec.fft(y = BP(f,fc,BW,type = ty[i]))
  lines(FT$fx * length(FT$fx) / diff(range(f)),Mod(FT$A),lty = i)

}
</code></pre>


</div>