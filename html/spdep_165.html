<div class="container">

<table style="width: 100%;"><tr>
<td>localmoran</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local Moran's I statistic</h2>

<h3>Description</h3>

<p>The local spatial statistic Moran's I is calculated for each zone based on the
spatial weights object used. The values returned include a Z-value, and may be
used as a diagnostic tool. The statistic is:
</p>
<p style="text-align: center;"><code class="reqn">I_i = \frac{(x_i-\bar{x})}{{\sum_{k=1}^{n}(x_k-\bar{x})^2}/(n-1)}{\sum_{j=1}^{n}w_{ij}(x_j-\bar{x})}</code>
</p>
<p>,
and its expectation and variance were given in Anselin (1995), but those from Sokal et al. (1998) are implemented here.
</p>


<h3>Usage</h3>

<pre><code class="language-R">localmoran(x, listw, zero.policy=attr(listw, "zero.policy"), na.action=na.fail,
        conditional=TRUE, alternative = "two.sided", mlvar=TRUE,
        spChk=NULL, adjust.x=FALSE)
localmoran_perm(x, listw, nsim=499, zero.policy=attr(listw, "zero.policy"), 
        na.action=na.fail, alternative = "two.sided", mlvar=TRUE,
        spChk=NULL, adjust.x=FALSE, sample_Ei=TRUE, iseed=NULL,
        no_repeat_in_row=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default default <code>attr(listw, "zero.policy")</code> as set when <code>listw</code> was created, if attribute not set, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. If <code>na.pass</code> is used, zero is substituted for NA values in calculating the spatial lag. (Note that na.exclude will only work properly starting from R 1.9.0, na.omit and na.exclude assign the wrong classes in 1.8.*)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>default TRUE: expectation and variance are calculated using the conditional randomization null (Sokal 1998 Eqs. A7 &amp; A8). Elaboration of these changes available in Sauer et al. (2021). If FALSE: expectation and variance are calculated using the total randomization null (Sokal 1998 Eqs. A3 &amp; A4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater, less or two.sided (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mlvar</code></td>
<td>
<p>default TRUE: values of local Moran's I are reported using the variance of the variable of interest (sum of squared deviances over n), but can be reported as the sample variance, dividing by (n-1) instead; both are used in other implementations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust.x</code></td>
<td>
<p>default FALSE, if TRUE, x values of observations with no neighbours are omitted in the mean of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>default 499, number of conditonal permutation simulations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_Ei</code></td>
<td>
<p>default TRUE; if conditional permutation, use the sample $E_i$ values, or the analytical values, leaving only variances calculated by simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>default NULL, used to set the seed; the output will only be reproducible if the count of CPU cores across which computation is distributed is the same</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_repeat_in_row</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, sample conditionally in each row without replacements to avoid duplicate values, <a href="https://github.com/r-spatial/spdep/issues/124">https://github.com/r-spatial/spdep/issues/124</a></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The values of local Moran's I are divided by the variance (or sample variance) of the variable of interest to accord with Table 1, p. 103, and formula (12), p. 99, in Anselin (1995), rather than his formula (7), p. 98. The variance of the local Moran statistic is taken from Sokal et al. (1998) p. 334, equations 4 &amp; 5 or equations 7 &amp; 8 located depending on user specification. By default, the implementation divides by n, not (n-1) in calculating the variance and higher moments. Conditional code contributed by Jeff Sauer and Levi Wolf.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Ii</code></td>
<td>
<p>local moran statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.Ii</code></td>
<td>
<p>expectation of local moran statistic; for <code>localmoran_perm</code>the permutation sample means</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Var.Ii</code></td>
<td>
<p>variance of local moran statistic; for <code>localmoran_perm</code>the permutation sample standard deviations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.Ii</code></td>
<td>
<p>standard deviate of local moran statistic; for <code>localmoran_perm</code> based on permutation sample means and standard deviations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pr()</code></td>
<td>
<p>p-value of local moran statistic using <code>pnorm()</code>; for <code>localmoran_perm</code> using standard deviatse based on permutation sample means and standard deviations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pr() Sim</code></td>
<td>
<p>For <code>localmoran_perm</code>, <code>rank()</code> and <code>punif()</code> of observed statistic rank for [0, 1] p-values using <code>alternative=</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pr(folded) Sim</code></td>
<td>
<p>the simulation folded [0, 0.5] range ranked p-value (based on <a href="https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213">https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213</a>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Skewness</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::skewness()</code> for the permutation samples underlying the standard deviates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kurtosis</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::kurtosis()</code> for the permutation samples underlying the standard deviates</p>
</td>
</tr>
</table>
<p>In addition, an attribute data frame <code>"quadr"</code> with mean and median quadrant columns, and a column splitting on the demeaned variable and lagged demeaned variable at zero.
</p>


<h3>Note</h3>

<p>Conditional permutations added for comparative purposes; permutations are over the whole data vector omitting the observation itself. For p-value adjustment, use <code>p.adjust()</code> or <code>p.adjustSP()</code> on the output vector.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association,
Geographical Analysis, 27, 93–115;
Getis, A. and Ord, J. K. 1996 Local spatial
statistics: an overview. In P. Longley and M. Batty (eds) <em>Spatial
analysis: modelling in a GIS environment</em> (Cambridge: Geoinformation
International), 261–277; Sokal, R. R, Oden, N. L. and Thomson, B. A. 1998. Local Spatial Autocorrelation in a Biological Model. Geographical Analysis, 30. 331–354; 
Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716–748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a>; 
Sauer, J., Oshan, T. M., Rey, S., &amp; Wolf, L. J. 2021. The Importance of Null Hypotheses: Understanding Differences in Local Moran’s under Heteroskedasticity. Geographical Analysis. <a href="https://doi.org/10.1111/gean.12304">doi:10.1111/gean.12304</a>
</p>
<p>Bivand, R. (2022), R Packages for Analyzing Spatial Data: A Comparative Case Study with Areal Data. Geographical Analysis, 54(3), 488-518. <a href="https://doi.org/10.1111/gean.12319">doi:10.1111/gean.12319</a>
</p>


<h3>See Also</h3>

<p><code>localG</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(afcon, package="spData")
oid &lt;- order(afcon$id)
resI &lt;- localmoran(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
hist(resI[,5])
mean(resI[,1])
sum(resI[,1])/Szero(nb2listw(paper.nb))
moran.test(afcon$totcon, nb2listw(paper.nb))
# note equality for mean() only when the sum of weights equals
# the number of observations (thanks to Juergen Symanzik)
resI &lt;- localmoran(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
hist(p.adjust(resI[,5], method="bonferroni"))
totcon &lt;-afcon$totcon
is.na(totcon) &lt;- sample(1:length(totcon), 5)
totcon
resI.na &lt;- localmoran(totcon, nb2listw(paper.nb), na.action=na.exclude,
 zero.policy=TRUE)
if (class(attr(resI.na, "na.action")) == "exclude") {
 print(data.frame(resI.na[oid,], row.names=afcon$name[oid]), digits=2)
} else print(resI.na, digits=2)
resG &lt;- localG(afcon$totcon, nb2listw(include.self(paper.nb)))
print(data.frame(resG[oid], row.names=afcon$name[oid]), digits=2)
set.seed(1)
resI_p &lt;- localmoran_perm(afcon$totcon, nb2listw(paper.nb))
printCoefmat(data.frame(resI_p[oid,], row.names=afcon$name[oid]),
 check.names=FALSE)
</code></pre>


</div>