<div class="container">

<table style="width: 100%;"><tr>
<td>sig_extract</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Signatures through NMF</h2>

<h3>Description</h3>

<p>Do NMF de-composition and then extract signatures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sig_extract(
  nmf_matrix,
  n_sig,
  nrun = 10,
  cores = 1,
  method = "brunet",
  optimize = FALSE,
  pynmf = FALSE,
  use_conda = TRUE,
  py_path = "/Users/wsx/anaconda3/bin/python",
  seed = 123456,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sig</code></td>
<td>
<p>number of signature. Please run sig_estimate to select a suitable value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrun</code></td>
<td>
<p>a <code>numeric</code> giving the number of run to perform for each value in <code>range</code>, <code>nrun</code> set to 30~50 is
enough to achieve robust result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>specification of the NMF algorithm. Use 'brunet' as default.
Available methods for NMF decompositions are 'brunet', 'lee', 'ls-nmf', 'nsNMF', 'offset'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with QP method, see sig_fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pynmf</code></td>
<td>
<p>if <code>TRUE</code>, use Python NMF driver <a href="http://nimfa.biolab.si/index.html">Nimfa</a>.
The seed currently is not used by this implementation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_conda</code></td>
<td>
<p>if <code>TRUE</code>, create an independent conda environment to run NMF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py_path</code></td>
<td>
<p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'. In my
test, it is more stable than <code>use_conda=TRUE</code>. You can install the Nimfa package by yourself
or set <code>use_conda</code> to <code>TRUE</code> to install required Python environment, and then set this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>specification of the starting point or seeding method, which will compute a starting point,
usually using data from the target matrix in order to provide a good guess.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>NMF::nmf()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>list</code> with <code>Signature</code> class.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Gaujoux, Renaud, and Cathal Seoighe. "A flexible R package for nonnegative matrix factorization." BMC bioinformatics 11.1 (2010): 367.
</p>
<p>Mayakonda, Anand, et al. "Maftools: efficient and comprehensive analysis of somatic variants in cancer." Genome research 28.11 (2018): 1747-1756.
</p>


<h3>See Also</h3>

<p>sig_tally for getting variation matrix,
sig_estimate for estimating signature number for sig_extract, sig_auto_extract for
extracting signatures using automatic relevance determination technique.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Extract copy number signatures
res &lt;- sig_extract(cn_tally_W$nmf_matrix, 2, nrun = 1)

</code></pre>


</div>