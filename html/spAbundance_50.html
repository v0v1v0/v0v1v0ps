<div class="container">

<table style="width: 100%;"><tr>
<td>ppcAbund</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for performing posterior predictive checks</h2>

<h3>Description</h3>

<p>Function for performing posterior predictive checks on <code>spAbundance</code> model objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ppcAbund(object, fit.stat, group, type = 'marginal', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>NMix</code>, <code>spNMix</code>, 
<code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>,
<code>abund</code>, <code>spAbund</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>DS</code>, <code>spDS</code>, 
<code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.stat</code></td>
<td>
<p>a quoted keyword that specifies the fit statistic
to use in the posterior predictive check. Supported fit statistics are
<code>"freeman-tukey"</code> and <code>"chi-squared"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>a positive integer indicating the way to group the
abundance data for the posterior predictive check. Value 
0 will not group the data and use the raw counts, 
1 will group values by row (site), and value 2 will group values by 
column (replicate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character string indicating whether fitted values should be generated conditional on the estimated latent abundance values (<code>type = 'conditional'</code>) estimated during the model or based on the marginal expected abundance values (<code>type = 'marginal'</code>). This is only relevant for N-mixture models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>ppcAbund</code> that is a list comprised of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit.y</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on the observed data when <code>object</code> is 
of class <code>NMix</code>, <code>spNMix</code>, <code>abund</code>, <code>spAbund</code>, <code>DS</code>, or <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>,
<code>msAbund</code>, <code>lfMsAbund</code>, <code>sfMsAbund</code>, 
<code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>, 
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.y.rep</code></td>
<td>
<p>a numeric vector of posterior samples for the 
fit statistic calculated on a replicate data set generated from the 
model when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, <code>abund</code>, 
<code>spAbund</code>, <code>DS</code>, <code>spDS</code>. When <code>object</code> is of 
class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, <code>lfMsDS</code>, <code>sfMsDS</code>,
this is a numeric matrix with rows corresponding to posterior samples
and columns corresponding to species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.y.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the observed data for each unique element
the fit statistic is calculated for (i.e., observations when group = 0, sites when group = 1,
replicates when group = 2) when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, 
<code>abund</code>, <code>spAbund</code>, <code>DS</code>, or <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>lfMsNMix</code>, <code>sfMsNMix</code>, 
<code>msAbund</code>, <code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, 
<code>lfMsDS</code>, <code>sfMsDS</code>, this is a three-dimensional
array with the additional dimension corresponding to species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.y.rep.group.quants</code></td>
<td>
<p>a matrix consisting of posterior quantiles
for the fit statistic using the model replicated data for each unique element
the fit statistic is calculated for (i.e., observations when group = 0, sites when group = 1, 
replicates when group = 2) when <code>object</code> is of class <code>NMix</code>, <code>spNMix</code>, 
<code>abund</code>, <code>spAbund</code>, <code>DS</code>, <code>spDS</code>. 
When <code>object</code> is of class <code>msNMix</code>, <code>sfMsNMix</code>, <code>msAbund</code>, 
<code>lfMsAbund</code>, <code>sfMsAbund</code>, <code>msDS</code>, <code>lfMsDS</code>, 
<code>sfMsDS</code>, this is a three-dimensional
array with the additional dimension corresponding to species.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for 
standard extractor functions. 
</p>


<h3>Note</h3>

<p><code>ppcAbund</code> will return an error for Gaussian or zero-inflated Gaussian models. 
For Gaussian models, standard residual diagnostics can be used to assess model fit.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br></p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1010)
J.x &lt;- 10
J.y &lt;- 10
J &lt;- J.x * J.y
n.rep &lt;- sample(3, J, replace = TRUE)
beta &lt;- c(0, -1.5)
p.abund &lt;- length(beta)
alpha &lt;- c(0.5, 1.2, -0.5)
p.det &lt;- length(alpha)
mu.RE &lt;- list()
p.RE &lt;- list()
phi &lt;- 3/.6
sigma.sq &lt;- 2
kappa &lt;- 0.3
sp &lt;- FALSE 
cov.model &lt;- 'exponential'
dist &lt;- 'NB'
dat &lt;- simNMix(J.x = J.x, J.y = J.y, n.rep = n.rep, beta = beta, alpha = alpha,
               kappa = kappa, mu.RE = mu.RE, p.RE = p.RE, sp = sp, 
               phi = phi, sigma.sq = sigma.sq, cov.model = cov.model, 
               family = 'NB')

y &lt;- dat$y
X &lt;- dat$X
X.p &lt;- dat$X.p

abund.covs &lt;- X
colnames(abund.covs) &lt;- c('int', 'abund.cov.1')

det.covs &lt;- list(det.cov.1 = X.p[, , 2], det.cov.2 = X.p[, , 3])

data.list &lt;- list(y = y, abund.covs = abund.covs,
                  det.covs = det.covs)

# Priors
prior.list &lt;- list(beta.normal = list(mean = rep(0, p.abund), 
                                      var = rep(100, p.abund)),
                   alpha.normal = list(mean = rep(0, p.det),
                                       var = rep(2.72, p.det)), 
                   kappa.unif = c(0, 10)) 
# Starting values
inits.list &lt;- list(alpha = 0, beta = 0, kappa = kappa, 
                   N = apply(y, 1, max, na.rm = TRUE))


tuning &lt;- 0.5
n.batch &lt;- 4
batch.length &lt;- 25
n.burn &lt;- 50
n.thin &lt;- 1
n.chains &lt;- 1

out &lt;- NMix(abund.formula = ~ abund.cov.1,
            det.formula = ~ det.cov.1 + det.cov.2, 
            data = data.list, 
            n.batch = n.batch, 
            batch.length = batch.length, 
            inits = inits.list, 
            priors = prior.list, 
            accept.rate = 0.43, 
            n.omp.threads = 1, 
            verbose = TRUE, 
            n.report = 1,
            n.burn = n.burn,
            n.thin = n.thin,
            n.chains = n.chains) 

# Posterior predictive check
ppc.out &lt;- ppcAbund(out, fit.stat = 'chi-squared', group = 0)
summary(ppc.out)
</code></pre>


</div>