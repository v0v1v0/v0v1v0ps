<div class="container">

<table style="width: 100%;"><tr>
<td>Skellam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> The Skellam Distribution </h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random number
generation for the Skellam distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dskellam(x, lambda1, lambda2 = lambda1, log = FALSE)
pskellam(q, lambda1, lambda2 = lambda1, 
    lower.tail = TRUE, log.p = FALSE)
qskellam(p, lambda1, lambda2 = lambda1, 
    lower.tail = TRUE, log.p = FALSE)
rskellam(n, lambda1, lambda2 = lambda1)
dskellam.sp(x, lambda1, lambda2 = lambda1, log = FALSE)
pskellam.sp(q, lambda1, lambda2 = lambda1, 
    lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, q</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1, lambda2</code></td>
<td>
<p>vectors of (non-negative) means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log, log.p</code></td>
<td>
<p> logical; if <code>TRUE</code>, probabilities p are given 
as log(p). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p> logical; if <code>TRUE</code> 
(default), probabilities are <code class="reqn">P[X \le x]</code>,
otherwise, <code class="reqn">P[X &gt; x]</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code> are Poisson variables with means 
<code class="reqn">\mu_1</code> and <code class="reqn">\mu_2</code>
and correlation <code class="reqn">\rho</code>, then <code class="reqn">X = Y_1 - Y_2</code> is Skellam with parameters
<code class="reqn">\lambda_1 = \mu_1 - \rho \sqrt{\mu_1 \mu_2}</code> and 
<code class="reqn">\lambda_2 = \mu_2 - \rho \sqrt{\mu_1 \mu_2}</code>.
</p>
<p><code>dskellam</code> returns a value equivalent to
</p>
<p style="text-align: center;"><code class="reqn">I(2 \sqrt{\lambda_1 \lambda_2}, |x|)  
    (\lambda_1/\lambda_2)^{x/2} \exp(-\lambda_1-\lambda_2)</code>
</p>

<p>where <code class="reqn">I(y,\nu)</code> is the modified Bessel function of the first kind.
The <code class="reqn">|x|</code> differs from most Skellam expressions in the literature, but is correct since <code class="reqn">x</code> is an integer, 
resulting in improved portability and (in R versions prior to 2.9) improved accuracy for <code class="reqn">x&lt;0</code>.
Exponential scaling is used in <code>besselI</code> to postpone numerical problems. 
When numerical problems do occur, a saddlepoint approximation is substituted,
which typically gives at least 4-figure accuracy.
An alternative representation is
<code class="reqn">dchisq(2 \lambda_1,2(x+1),2\lambda_2) 2</code>
for <code class="reqn">x \ge 0</code>, and
<code class="reqn">dchisq(2 \lambda_2,2(1-x),2\lambda_1) 2</code>
for <code class="reqn">x \le 0</code>; but in R <code>besselI</code> appears to be more accurately implemented
(for very small probabilities) than <code>dchisq</code>.
</p>
<p><code>pskellam(x,lambda1,lambda2)</code> returns
<code>pchisq(2*lambda2, -2*x, 2*lambda1)</code>
for <code class="reqn">x&lt;=0</code> and
<code>1 - pchisq(2*lambda1, 2*(x+1), 2*lambda2)</code>
for <code class="reqn">x&gt;=0</code>.
When <code>pchisq</code> incorrectly returns 0, a saddlepoint approximation is substituted,
which typically gives at least 2-figure accuracy.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.
For <code>lower.tail=FALSE</code>, the quantile is defined as the largest value <code class="reqn">x</code> such that
<code class="reqn">F(x,</code><code>lower.tail=FALSE</code><code class="reqn">) \le p</code>.
</p>
<p><code>rskellam</code> is calculated as <code>rpois(n,lambda1)-rpois(n,lambda2)</code>
</p>
<p><code>dskellam.sp</code> and <code>pskellam.sp</code> return saddlepoint approximations to the pmf and cdf.
They are called by <code>dskellam</code> and <code>pskellam</code> when results from primary methods are in doubt.
</p>


<h3>Value</h3>

<p><code>dskellam</code> gives the (log) density, <code>pskellam</code> gives the (log) distribution function,
<code>qskellam</code> gives the quantile function, and <code>rskellam</code> generates random deviates. 
Invalid <code>lambda</code>s will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>The <span class="pkg">VGAM</span> package
also contains Skellam functions, which are syntactically similar;
independently developed versions are included here for completeness.
Moreover, this <code>dskellam</code> function offers a broader working range,
correct handling of cases where at least one rate parameter is zero,
enhanced argument checking,
and (in R versions prior to 2.9) improved accuracy for <code class="reqn">x&lt;0</code>.
If both packages are loaded,
<code>skellam::dskellam</code>
or
<code>VGAM::dskellam</code>
can unambiguously specify which implementation to use.
</p>


<h3>Author(s)</h3>

<p> Jerry W. Lewis, Patrick E. Brown</p>


<h3>Source</h3>

<p>The relation of <code>dgamma</code> to the modified Bessel function of the first kind
was given by Skellam (1946).
The relation of <code>pgamma</code> to the noncentral chi-square was given by Johnson (1959).
Tables are given by Strackee and van der Gon (1962), which can be used to verify this implementation 
(cf. direct calculation in the examples below).
</p>
<p><code>qskellam</code> uses the Cornish–Fisher expansion to include skewness and kurtosis
corrections to a normal approximation, followed by a search.
If <code>getOption("verbose")==TRUE</code>, then <code>qskellam</code> will not use <code>qpois</code>
when one of the <code>lambda</code>s is zero,
in order to verify that this search algorithm has been implemented properly.
</p>


<h3>References</h3>

<p>Butler, R. (2007) <em>Saddlepoint Approximations with Applications</em>,
Cambridge University Press, Cambridge &amp; New York, p.17.
</p>
<p>Johnson, N. L. (1959) On an extension of the connection between Poisson and <code class="reqn">\chi^2</code> distributions.
<em>Biometrika</em> <b>46</b>, 352–362.
</p>
<p>Johnson, N. L.; Kotz, S.; Kemp, A. W. (1993) <em>Univariate Discrete Distributions</em>, 2nd ed.,
John Wiley and Sons, New York, pp.190-192.
</p>
<p>Skellam, J. G. (1946) The frequency distribution of the difference between two Poisson variates
belonging to different populations. <em>Journal of the Royal Statistical Society, series A</em> <b>109</b>/3, 26.
</p>
<p>Strackee, J.; van der Gon, J. J. D. (1962) The frequency distribution of the difference between two Poisson variates.
<em>Statistica Neerlandica</em> <b>16</b>/1, 17-23.
</p>
<p>Wikipedia. <em>Skellam distribution</em> <a href="https://en.wikipedia.org/wiki/Skellam_distribution">https://en.wikipedia.org/wiki/Skellam_distribution</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require('skellam')

# one lambda = 0 ~ Poisson
c(dskellam(0:10,5,0), dpois(0:10,5))
c(dskellam(-(0:10),0,5), dpois(0:10,5))
c(pskellam(0:10,5,0,lower.tail=TRUE), 
    ppois(0:10,5,lower.tail=TRUE))
c(pskellam(0:10,5,0,lower.tail=FALSE),
    ppois(0:10,5,lower.tail=FALSE))
c(pskellam(-(0:10),0,5,lower.tail=FALSE),
    ppois(0:10-1,5,lower.tail=TRUE))
c(pskellam(-(0:10),0,5,lower.tail=TRUE),
    ppois(0:10-1,5,lower.tail=FALSE))

# both lambdas != 0 ~ convolution of Poissons
dskellam(1,0.5,0.75)  # sum(dpois(1+0:10,0.5)*dpois(0:10,0.75))
pskellam(1,0.5,0.75)  # sum(dskellam(-10:1,0.5,0.75))
dskellam(c(-1,1),c(12,10),c(10,12))  # c(0.0697968,0.0697968)
dskellam(c(-1,1),c(12,10),c(10,12),log=TRUE) 
 # log(dskellam(c(-1,1),c(12,10),c(10,12)))
dskellam(256,257,1)  
# 0.024829348733183769  
# exact result for comparison with saddlepoint
dskellam(-3724,2000,3000)  
# 3.1058145363400105e-308  
# exact result for comparison with saddlepoint 
# (still accurate in extreme tail)
pskellam(c(-1,0),c(12,10),c(10,12))  # c(0.2965079,0.7034921)
pskellam(c(-1,0),c(12,10),c(10,12),lower.tail=FALSE) 
 # 1-pskellam(c(-1,0),c(12,10),c(10,12))
pskellam(-2:2,8.5,10.25,log.p=TRUE)  # log(pskellam(-2:2,8.5,10.25))
qskellam(c(0.05,0.95),3,4)  # c(-5,3); pskellam(cbind(-6:-5,2:3),3,4)
qskellam(c(0.05,0.95),3,0)  # c(1,6); qpois(c(0.05,0.95),3)
rskellam(35,8.5,10.25)
</code></pre>


</div>