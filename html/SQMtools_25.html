<div class="container">

<table style="width: 100%;"><tr>
<td>subsetORFs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select ORFs</h2>

<h3>Description</h3>

<p>Create a SQM object containing only the requested ORFs, and the contigs and bins that contain them. Internally, all the other subset functions in this package end up calling <code>subsetORFs</code> to do the work for them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">subsetORFs(
  SQM,
  orfs,
  tax_source = "orfs",
  trusted_functions_only = FALSE,
  ignore_unclassified_functions = FALSE,
  rescale_tpm = FALSE,
  rescale_copy_number = FALSE,
  contigs_override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SQM</code></td>
<td>
<p>SQM object to be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orfs</code></td>
<td>
<p>character. Vector of ORFs to be selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tax_source</code></td>
<td>
<p>character. Features used for calculating aggregated abundances at the different taxonomic ranks. Either <code>"orfs"</code> or <code>"contigs"</code> (default <code>"orfs"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trusted_functions_only</code></td>
<td>
<p>logical. If <code>TRUE</code>, only highly trusted functional annotations (best hit + best average) will be considered when generating aggregated function tables. If <code>FALSE</code>, best hit annotations will be used (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unclassified_functions</code></td>
<td>
<p>logical. If <code>FALSE</code>, ORFs with no functional classification will be aggregated together into an "Unclassified" category. If <code>TRUE</code>, they will be ignored (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_tpm</code></td>
<td>
<p>logical. If <code>TRUE</code>, TPMs for KEGGs, COGs, and PFAMs will be recalculated (so that the TPMs in the subset actually add up to 1 million). Otherwise, per-function TPMs will be calculated by aggregating the TPMs of the ORFs annotated with that function, and will thus keep the scaling present in the parent object (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_copy_number</code></td>
<td>
<p>logical. If <code>TRUE</code>, copy numbers with be recalculated using the RecA/RadA coverages in the subset. Otherwise, RecA/RadA coverages will be taken from the parent object. By default it is set to <code>FALSE</code>, which means that the returned copy numbers for each function will represent the average copy number of that function per genome in the parent object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contigs_override</code></td>
<td>
<p>character. Optional vector of contigs to be included in the subsetted object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>SQM object containing the requested ORFs.
</p>


<h3>A note on contig/bins subsetting</h3>

<p>While this function selects the contigs and bins that contain the desired orfs, it DOES NOT recalculate contig/bin abundance and statistics based on the selected ORFs only. This means that the abundances presented in tables such as <code>SQM$contig$abund</code> or <code>SQM$bins$tpm</code> will still refer to the complete contigs and bins, regardless of whether only a fraction of their ORFs are actually present in the returned SQM object. This is also true for the statistics presented in <code>SQM$contigs$table</code> and <code>SQM$bins$table</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Hadza)
# Select the 100 most abundant ORFs in our dataset.
mostAbundantORFnames = names(sort(rowSums(Hadza$orfs$tpm), decreasing=TRUE))[1:100]
mostAbundantORFs = subsetORFs(Hadza, mostAbundantORFnames)
</code></pre>


</div>