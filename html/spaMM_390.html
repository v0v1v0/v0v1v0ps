<div class="container">

<table style="width: 100%;"><tr>
<td>wrap_parallel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Selecting interfaces for parallelisation
</h2>

<h3>Description</h3>

<p>spaMM implements three interfaces for parallelisation. Depending on their arguments, either serial computation (default), a socket cluster (parallelisation default), or a fork cluster (available in linux and alike operating systems) can be used by all interfaces. 
</p>
<p><code>dopar</code> is called by default by its bootstrap procedures, and <code>dofuture</code> has been developed as an alternative, whose use is controlled by <code>spaMM.options(wrap_parallel="dofuture")</code> (versus the default, <code>spaMM.options(wrap_parallel="dopar")</code>. <code>combinepar</code> is the third and more recent interface; it is not a formally supported <code>wrap_parallel</code> option because its additional functionalities are of no use in <span class="pkg">spaMM</span>'s bootstrap procedures.
</p>
<p><code>dopar</code> is based on a patchwork of backends: for socket clusters, depending whether the <span class="pkg">doSNOW</span> package is attached, <code>foreach</code> or <code>pbapply</code> is called (<span class="pkg">doSNOW</span> allows more efficient load balancing than <code>pbapply</code>); for fork clusters, <code>parallel::mclapply</code> is used. This makes it impossible to ensure consistency of options accross computation environments, notably of enforcing the <code>.combine</code> control of <code>foreach</code>; and this makes it error-prone to ensure identical control of random number generators in all cases (although <code>dopar</code> and <code>combinepar</code> still aim to ensure the latter control).  
</p>
<p>By contrast, <code>dofuture</code> is based only on the <span class="pkg">future</span> and <span class="pkg">future.apply</span> packages, in principle allowing a single syntax to control of random number generator across the different cases, hence repeatable results across them. This does <b>not</b> make a difference for bootstrap computations in <span class="pkg">spaMM</span> as the bootstrap samples are never simulated in parallel: only refitting the models is performed in parallel, and fit results do not depend on random numbers. Further, the <span class="pkg">future</span>-based code for socket clusters appears significantly slower than the one used by <code>dopar</code>. For these reasons, the latter function is used by default by <span class="pkg">spaMM</span>.
</p>
<p><code>combinepar</code> is a third and more recent approach designed to address the other issue: it always uses <span class="pkg">foreach</span> so that the <code>.combine</code> control is consistently enforced. It uses <span class="pkg">future</span> only when no alternative is available to produce a progress bar (namely, for socket clusters when <span class="pkg">doSNOW</span> is not available).
</p>


</div>