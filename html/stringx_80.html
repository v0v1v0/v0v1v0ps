<div class="container">

<table style="width: 100%;"><tr>
<td>strsplit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split Strings into Tokens</h2>

<h3>Description</h3>

<p>Splits each string into chunks delimited by occurrences of a given pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">strsplit(
  x,
  pattern = split,
  ...,
  ignore_case = ignore.case,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  ignore.case = FALSE,
  split
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>character vector whose elements are to be examined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>character vector of nonempty search patterns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>stri_split</code>,
e.g., <code>omit_empty</code>, <code>locale</code>, <code>dotall</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_case</code></td>
<td>
<p>single logical value; indicates whether matching
should be case-insensitive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>single logical value;
<code>FALSE</code> for matching with regular expressions
(see about_search_regex);
<code>TRUE</code> for fixed pattern matching
(about_search_fixed);
<code>NA</code> for the Unicode collation algorithm
(about_search_coll)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl, useBytes</code></td>
<td>
<p>not used (with a warning if
attempting to do so) [DEPRECATED]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>alias to the <code>ignore_case</code> argument [DEPRECATED]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>alias to the <code>pattern</code> argument [DEPRECATED]</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is fully vectorised with respect to both arguments.
</p>
<p>For splitting text into 'characters' (grapheme clusters), words,
or sentences, use <code>stri_split_boundaries</code> instead.
</p>


<h3>Value</h3>

<p>Returns a list of character vectors representing the identified tokens.
</p>


<h3>Differences from Base R</h3>

<p>Replacements for base <code>strsplit</code>
implemented with <code>stri_split</code>.
</p>

<ul>
<li>
<p> base R implementation is not portable as it is based on
the system PCRE or TRE library
(e.g., some Unicode classes may not be available or matching thereof
can depend on the current <code>LC_CTYPE</code> category
<b>[fixed here]</b>
</p>
</li>
<li>
<p> not suitable for natural language processing
<b>[fixed here – use <code>fixed=NA</code>]</b>
</p>
</li>
<li>
<p> two different regular expression libraries are used
(and historically, ERE was used in place of TRE)
<b>[here, <span class="pkg">ICU</span> Java-like regular expression engine
is only available, hence the <code>perl</code> argument has no meaning]</b>
</p>
</li>
<li>
<p> there are inconsistencies between the argument order and naming
in <code>grepl</code>, <code>strsplit</code>,
and <code>startsWith</code> (amongst others); e.g.,
where the needle can precede the haystack, the use of the forward
pipe operator, <code>|&gt;</code>, is less convenient
<b>[fixed here]</b>
</p>
</li>
<li> <p><code>grepl</code> also features the <code>ignore.case</code> argument
<b>[added here]</b>
</p>
</li>
<li>
<p> if <code>split</code> is a zero-length vector, it is treated as <code>""</code>,
which extracts individual code points (which is not the best idea
for natural language processing tasks)
<b>[empty search patterns are not supported here, zero-length vectors
are propagated correctly]</b>
</p>
</li>
<li>
<p> last empty token is removed from the output, but first is not
<b>[fixed here – see also the <code>omit_empty</code> argument]</b>
</p>
</li>
<li>
<p> missing values in <code>split</code> are not propagated correctly
<b>[fixed here]</b>
</p>
</li>
<li>
<p> partial recycling without the usual warning, not fully vectorised
w.r.t. the <code>split</code> argument
<b>[fixed here]</b>
</p>
</li>
<li>
<p> only the <code>names</code> attribute of <code>x</code> is preserved
<b>[fixed here]</b>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringx</span> at <a href="https://stringx.gagolewski.com/">https://stringx.gagolewski.com/</a>
</p>
<p>Related function(s): <code>paste</code>, <code>nchar</code>,
<code>grepl</code>, <code>gsub</code>, <code>substr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">stringx::strsplit(c(x="a, b", y="c,d,  e"), ",\\s*")
x &lt;- strcat(c(
    "abc", "123", ",!.", "\U0001F4A9",
    "\U0001F64D\U0001F3FC\U0000200D\U00002642\U0000FE0F",
    "\U000026F9\U0001F3FF\U0000200D\U00002640\U0000FE0F",
    "\U0001F3F4\U000E0067\U000E0062\U000E0073\U000E0063\U000E0074\U000E007F"
))
# be careful when splitting into individual code points:
base::strsplit(x, "")  # stringx does not support this
stringx::strsplit(x, "(?s)(?=.)", omit_empty=TRUE)  # look-ahead for any char with dot-all
stringi::stri_split_boundaries(x, type="character")  # grapheme clusters

</code></pre>


</div>