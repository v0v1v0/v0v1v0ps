<div class="container">

<table style="width: 100%;"><tr>
<td>order.custom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Custom Order Permutation</h2>

<h3>Description</h3>

<p><code>order.custom</code> creates the order of the positions in the atomic vectors
from <code>X</code> that would cause the atomic vectors from <code>X</code> to be sorted
according to the atomic vectors from <code>ORD</code>. This is analogus to the
<code>order</code> function, but instead of doing default sorting (e.g., 1, 2, 3, etc.
or "A", "B", "C", etc.), the sorting is customized by <code>ORD</code>.
<code>order.custom</code> does custom ordering by converting each atomic vector from
<code>X</code> to an ordered factor and then default sorting the ordered factors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">order.custom(X, ORD, na.last = FALSE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>list of atomic vectors parellel matched with the atomic vectors in <code>X</code>
specifying the elements to be ordered. Can also be a single atomic vector, which
will internally be converted to a list with one element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ORD</code></td>
<td>
<p>list of atomic vectors that do NOT have to be the same length
specifying the order of the unique values for sorting. Can also be a single
atomic vector, which will internally be converted to a list with one element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.last</code></td>
<td>
<p>logical vector of length 1 specifying whether missing values
should be put last (TRUE), first (FALSE), or removed (NA).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the sorting
should start with the first element of the atomic vectors within <code>ORD</code>
and proceed forward (FALSE) or the last element of the atomic vectors within
<code>ORD</code> and proceed backwards (TRUE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note, that the atomic vectors within <code>X</code> are always forward sequenced;
if backward sequence is desired, then the user should call <code>rev</code> on both
the input to <code>X</code> and <code>ORD</code>. This is analogous to reversing the
order of the atomic vectors given to <code>...</code> within <code>order</code>.
</p>


<h3>Value</h3>

<p>integer vector of length = <code>X[[1]]</code> (after converting <code>X</code> to
a list with one element is need be) providing the revised order of the atomic
vectors within <code>X</code> that sorts them according to <code>ORD</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># character vector
x &lt;- esoph[["tobgp"]]
order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day"))
x[order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day"))] # returns character
esoph[order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day")), ]
# order by position
sort(state.region)
x &lt;- as.character(state.region)
order.custom(X = x, ORD = unique(x))
x[order.custom(X = x, ORD = unique(x))]
# numeric vector
y &lt;- esoph[["ncases"]]
order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9))
y[order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9))] # returns numeric
esoph[order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9)), ]
   # some unique values not provided in `ORD` (appended at the end and sorted by
   # where they appear in the dataset)
y &lt;- esoph[["ncases"]]
order.custom(X = y, ORD = c(6,5,4,3,2,1,0))
y[order.custom(X = y, ORD = c(6,5,4,3,2,1,0))] # returns numeric
esoph[order.custom(X = y, ORD = c(6,5,4,3,2,1,0)), ]
# multiple vectors
z &lt;- esoph[c("agegp","alcgp","tobgp")]
ord &lt;- order.custom(X = z, ORD = list(
   "agegp" = c("45-54","55-64","35-44","65-74","25-34","75+"),
   "alcgp" = c("40-79","80-119","0-39g/day","120+"),
   "tobgp" = c("10-19","20-29","0-9g/day","30+")))
esoph[ord, ]
</code></pre>


</div>