<div class="container">

<table style="width: 100%;"><tr>
<td>simulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>simulate</h2>

<h3>Description</h3>

<p>Estimates empirical power using a simulation approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simulate(
  modelH0 = NULL,
  modelH1 = NULL,
  Sigma = NULL,
  mu = NULL,
  N = NULL,
  alpha = NULL,
  simOptions = list(nReplications = 500, minConvergenceRate = 0.75, type = "normal",
    missingVars = NULL, missingVarProp = 0, missingProp = 0, missingMechanism = "MCAR",
    nCores = 1),
  lavOptions = NULL,
  lavOptionsH1 = lavOptions,
  returnFmin = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>population means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>alpha error probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simOptions</code></td>
<td>
<p>a list of additional options specifying simulation details, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavOptionsH1</code></td>
<td>
<p>lavoptions when fitting <code>modelH1</code>. If <code>NULL</code>, the same as <code>lavOptions</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnFmin</code></td>
<td>
<p>whether to return the mean unbiased Fmin over replications (i. e., <code>fmin_0 = fmin_hat - df/N</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The details of the simulation are specified in <code>simOptions</code>, which is a list that may have the following components:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of valid simulation runs, defaults to 500.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .75. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RK'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to <code>NULL</code>).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>'MCAR'</code> (the default), <code>'MAR'</code>, or <code>'NMAR'</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doFuture</code> package.
</p>
</li>
</ul>
<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.
</p>
<p>Foldnes, N. &amp; Olsson, U. H. (2016) A Simple Simulation Technique for Nonnormal Data with Prespecified Skewness, Kurtosis, and Covariance Matrix. <em>Multivariate Behavioral Research, 51</em>, 207-219. doi: 10.1080/00273171.2015.1133274
</p>
<p>Qu, W., Liu, H., &amp; Zhang, Z. (2020). A method of generating multivariate non-normal random numbers with desired multivariate skewness and kurtosis. <em>Behavior Research Methods, 52</em>, 939-946. doi: 10.3758/s13428-019-01291-5
</p>
<p>Ruscio, J., &amp; Kaczetow, W. (2008). Simulating multivariate nonnormal data using an iterative algorithm. <em>Multivariate Behavioral Research, 43</em>, 355-381. doi: 10.1080/00273170802285693
</p>
<p>Vale, C. &amp; Maurelli, V. (1983). Simulating multivariate nonnormal distributions. <em>Psychometrika, 48</em>, 465-471.
</p>


<h3>Value</h3>

<p>Returns empirical power: <code>sum(p &lt; alpha) / nReplications</code> or a list (if <code>returnFmin = TRUE</code>) with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ePower</code></td>
<td>
<p>the empirical power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanFmin</code></td>
<td>
<p>the estimated mean unbiased Fmin over replications (i. e., <code>fmin_0 = fmin_hat - df/N</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanFminGroups</code></td>
<td>
<p>the estimated mean unbiased Fmin by groups given as a vector, assuming the df spread equally over groups. Therefore, <code>meanFmin != sum(meanFminGroups)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the model df.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>the number of successful replications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergenceRate</code></td>
<td>
<p>the convergence rate of the H0 model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bChiSq</code></td>
<td>
<p>median chi-square bias of the H1 model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bLambda</code></td>
<td>
<p>average median bias in lambda in the H1 model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bPhi</code></td>
<td>
<p>average median bias in phi in the H1 model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bPsi</code></td>
<td>
<p>average median bias in psi in the H1 model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bBeta</code></td>
<td>
<p>average median bias in beta in the H1 model</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# create Sigma and modelH0 using powerCFA
powerCFA &lt;- semPower.powerCFA(type = 'a-priori', alpha = .05, beta = .05,
                              comparison = 'saturated',
                              Phi = .2, loadings = list(rep(.5, 3), rep(.7, 3)))
                              
# perform simulated power analysis using defaults       
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE)
         

# same with additional options       
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(nReplications = 500, 
                           minConvergenceRate = .80, 
                           nCores = 8))


# same with IG as data generation routine
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'IG', 
                           skewness = c(0, 1, -2, 6, 5, 4), 
                           kurtosis = c(-3, 6, 9, 0, 2, -2)))
                           
                           
# same with mnonr as data generation routine
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'mnonr', 
                           skewness = 1, 
                           kurtosis = 50))
                           
                           
# same with RK as data generation routine
distributions &lt;- list(
  list('rnorm', list(mean = 0, sd = 10)),
  list('runif', list(min = 0, max = 1)),
  list('rbeta', list(shape1 = 1, shape2 = 2)),
  list('rexp', list(rate = 1)),
  list('rpois', list(lambda = 4)),
  list('rbinom', list(size = 1, prob = .5))
)
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'RK', 
                           distributions = distributions))

## End(Not run)

</code></pre>


</div>