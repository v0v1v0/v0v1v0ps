<div class="container">

<table style="width: 100%;"><tr>
<td>set_spatial_grid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set Spatial Grid Attributes to a Data Table</h2>

<h3>Description</h3>

<p>This function creates the spatial grid attribute for a data table.
If the data table already has such an attribute, missing information is filled in.
In particular, the function checks whether a grid is regular, allowing for rounding errors in the grid coordinates, see details below.
By default the grid coordinates are rounded to a regular grid if they are very close to being regular.
While this sounds dangerous, it is almost always desirable to treat coordinates like that when working with data tables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">set_spatial_grid(
  dt,
  coor_cns = NULL,
  check_regular = TRUE,
  regular_tolerance = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A data table object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coor_cns</code></td>
<td>
<p>Optional character vector of length two indicating the names of the spatial coordinates
within the data table in order <code>x</code>,<code>y</code>. Default (<code>NULL</code>) makes the function guess based on column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_regular</code></td>
<td>
<p>A logical indicating whether to check for regularity of the grid. This should essentially always be done but can be suppressed for speed.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regular_tolerance</code></td>
<td>
<p>Value &gt;= 0 specifying the amount of rounding error we allow for still recognizing a grid as regular.
Given in percent of the minimum of <code>dx</code> and <code>dy</code>. Default is 1. Based on this value coordinates are rounded to the smallest after-comma-digit making them regular,
as long as this rounding introduces less error than <code>min(dx,dy)*regular_tolerance/100</code>.
Set this to <code>NULL</code> if you are absolutely certain that you don't want to round/change the grid. Doing this or decreasing this below 1 is not recommended, see details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the grid information is printed out (by a call to <code>grid_info</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The grid attribute is a named list with (some of) the following pages:
</p>

<ul>
<li>
<p><code>coor_cns</code>: Character vector of length two specifying the names of the data-table-columns containing the spatial grids (in order x,y).
</p>
</li>
<li>
<p><code style="white-space: pre;">⁠x,y⁠</code>: Numeric vectors of all unique x- and y-coordinates in increasing order (NAs not included).
</p>
</li>
<li>
<p><code>regular</code>: Logical. Is the grid <em>regular</em>? See details below.
</p>
</li>
<li>
<p><code style="white-space: pre;">⁠dx,dy⁠</code>: Step sizes of the regular grid (only contained if <code>regular = TRUE</code>). By convention we set <code>dx</code> to 9999 if only one x-coordinate is present, likewise for <code>dy</code>.
</p>
</li>
<li>
<p><code>complete</code>: Logical. Is the regular grid <em>complete</em>? See details below.
</p>
</li>
</ul>
<p>We call a grid <em>regular</em> if there is a coordinate <code style="white-space: pre;">⁠(x0,y0)⁠</code> and positive values <code>dx</code>, <code>dy</code>,
such that each coordinate of the grid can be written as <code style="white-space: pre;">⁠(x0 + n*dx,y0 + m*dy)⁠</code> for integers <code>n</code>,<code>m</code>.
Importantly, a regular grid does not need to be "a complete rectangle", we allow for missing coordinates, see details below.
We call it a <em>regular complete grid</em> if the grid contains these numbers for all integers <code>n</code>, <code>m</code> between some limits <code>n_min</code> and <code>n_max</code>,
respectively <code>m_min</code>, <code>m_max</code>.
</p>
<p>Checking regularity properly is a difficult problem, because we allow for missing coordinates
in the grid and allow for rounding errors.
For the treatment of rounding errors it is not recommended to set <code>regular_tolerance</code> to <code>NULL</code> or a very small value
(e.g. 0.1 or smaller). In this case, grids that are regular in praxis are frequently not recognized as regular:
Take for example the three x-coordinates 1, 1.5001, 2.4999. They are supposed to be rounded to 1 digit after
the comma and then the grid is regular with <code>dx = 0.5</code>. However, if <code>regular_tolerance</code> is NULL, the grid will be marked as irregular.
Similarly, if <code>regular_tolerance</code> is too small, the function is not allowed to make rounding errors of 0.0001
and the grid will also not be recognized as regular.
</p>
<p>When it comes to the issue of missing values in the grid, we are (deliberately) a bit sloppy and only check whether
the coordinates are part of a grid with <code>dx</code> being the minimum <code>x</code>-difference between two coordinates,
and similar <code>dy</code>. This may not detect regularity, when we have data that is sparse on a regular grid.
An example would be the three lon/lat coordinates <code>c(0,0)</code>, <code>c(2,0)</code>, <code>c(5,0)</code>. They clearly lie on the regular integer-lon/lat-
grid. However, the grid would show as not regular, because <code>dx</code> is not checked for smaller values than 2.
This choice is on purpose, since for most applications grids with many (or mostly) holes should be treated as irregular (e.g. plotting, upscaling, etc.).
The most important case of regular but not complete grids is gridded data that is restricted to a certain region, e.g. a country
or restricted to land. This is what we think of when we think of a regular incomplete grid, and for such data the check works perfectly.
</p>
<p>Note that at the very bottom it is the definition of regularity itself that is a bit tricky:
If we allow <code>dx</code>, <code>dy</code> to go all the way down to the machine-delta,
then pretty much any set of coordinates represented in a computer is part of a regular grid.
This hints at testing and detecting regularity actually depending on how small you're willing to make your <code>dx</code>,<code>dy</code>.
An example in 1 dimension: consider the three 1-dimensional coordinates <code>0</code>, <code>1</code>, and <code>m/n</code>, with <code>m</code> and <code>n</code> integers
without common divisors and <code>m&gt;n</code>. It is not difficult to see that these coordinates are part of a regular grid and that the
largest <code>dx</code> for detecting this is 1/n. This shows that you can have very small coordinate sets that are in theory regular, but their regularity
can be arbitrarily hard to detect. An example of a grid that is truely not regular are the three <code>x</code>-coordinates 0,1,a with a irrational.
</p>


<h3>Value</h3>

<p>Nothing, the attributes of dt are set in the parent environment. Moreover, the grid coordinates may be rounded If <code>regular</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dt = data.table(lon = 1:4, lat = rep(1:2,each = 2), some_data = runif(4))
print(dt)
attr(dt,'grid')

set_spatial_grid(dt)
attr(dt,'grid')

</code></pre>


</div>