<div class="container">

<table style="width: 100%;"><tr>
<td>sim_Y_MVN_X</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate Scalar Outcomes from Simulated Spatially Correlated Predictors</h2>

<h3>Description</h3>

<p>N spatially correlated design vectors are simulated from an MVN. These
design vectors are used to then simulate scalar outcomes that have
one of Gaussian, Binomial, Multinomial or Poisson distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_Y_MVN_X(
  N,
  B,
  L = NULL,
  R = NULL,
  S = NULL,
  Q = NULL,
  use.spam = TRUE,
  mu = 0,
  rand.err = 1,
  dist = "gaussian",
  V = NULL,
  incl.subjectID = TRUE,
  threshold.method = "none",
  Y.thresh = NULL,
  X.categorical = FALSE,
  X.num.categories = 2,
  X.category.type = "percentile",
  X.manual.thresh = NULL,
  X.cat.names = NULL,
  print.out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>The number of draws to take from MVN; i.e., the number of subjects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>A vector parameter values; i.e. "betas". Note that 
<code>length(B)</code> must equal <code>p + 1 = n.row * n.col + 1</code>; e.g. for 
normal outcomes <code class="reqn">Y = XB + e</code> with <code>Y</code> a scalar outcome and 
<code>e</code> the random error. Note that when <code>dist = "multinomial"</code> then
<code>B</code> should be a list with length equal to <code>V - 1</code>, i.e., should
contain parameter values associated with all categories except the 
reference category. Alternatively, when <code>dist = "multinomial"</code>  
<code>B</code> may be a list of length <code>V</code> if one desires to specify 
parameters for every category, i.e., the over-parameterized model used in 
Friedman (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L, R</code></td>
<td>
<p><code>L</code> and <code>R</code> are lower and upper triangular matrices, 
respectively, and are the Cholesky factor(s) of the desired covariance 
matrix for the MVN. Obtain <code>L</code> or <code>R</code> via <code>chol_s2Dp()</code> 
with settings <code>triangle = "lower"</code> or <code>triangle = "upper"</code>, 
respectively. Specify either <code>L</code> or <code>R</code>, but NOT both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S, Q</code></td>
<td>
<p>A covariance or precision matrix respectively. These are for 
use with <code>spam</code>, and can be extracted from output of 
<code>chol_s2Dp</code> after choosing 
<code>return.cov = TRUE</code> or <code>return.prec = TRUE</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.spam</code></td>
<td>
<p>Logical. If <code>use.spam = TRUE</code> then use tools from the
R package <code>spam</code>; otherwise, base R functions are employed. For large
dimension MVN with sparse correlation structure, <code>spam</code> is 
recommended; otherwise, base R may be faster. Defaults to <code>FALSE</code>.
Requires either the covariance matrix <code>S</code> or precision matrix, 
<code>Q</code>, that corresponds to the Cholesky factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li>
<p> A single scalar value for common mean.
</p>
</li>
<li>
<p> A vector of length <code>nrow(R)</code> (equivalently <code>nrow(R)</code>)
containing means for the MVN.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand.err</code></td>
<td>
<p>A vector for the random error standard deviation when 
<code>dist = "gaussian"</code>, or thresholding is used to obtain non-Normal 
draws. Must have length 1 or length N.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>The distribution of the scalar outcome.
</p>

<ul>
<li> <p><code>dist = "gaussian"</code> has <code class="reqn">Y = XB + e</code>, where
<code class="reqn">e ~ N(0, rand.err)</code>.
</p>
</li>
<li> <p><code>dist = "binomial"</code>: Y is drawn from a binomial distribution
with probability of "success" equal to <code class="reqn">1 / (1 + 1 / exp(XB))</code> 
using <code>rbinom()</code> when <code>binary.method = "traditional"</code>. If 
<code>binary.method = "gaussian"</code>, then simulation  is based on a 
cutoff using <code>binary.cutoff</code>.
</p>
</li>
<li> <p><code>dist = "multinomial"</code>: Y is drawn from <code>sample()</code> 
using probabilities generated based on Chapter 6.1.3 of Agresti (2007)
when <code>length(B) = V - 1</code> or Friedman (2010) when the 
<code>length(B) = V</code>. Threshold-based approaches are not currently 
supported.
</p>
</li>
<li> <p><code>dist = "poisson"</code>: Y is drawn from <code class="reqn">Poisson(exp(XB))</code>
using <code>rpois()</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>A numeric value stating the number of categories desired when 
<code>dist = "multinomial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incl.subjectID</code></td>
<td>
<p>When <code>incl.subjectID = TRUE</code> a column of subject
indices is generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold.method</code></td>
<td>
<p>One of <code>"none", "manual", "percentile", "round"</code>.
When <code>"none"</code> draws from Binomial or Poisson distributions are taken 
subject-wise using base <code>R</code> functions. For the remaining options, 
draws are first taken from a Normal distribution and then thresholded. 
<code>"manual"</code> uses <code>Y.thresh</code> to manually select a cutoff, 
<code>"percentile"</code> uses <code>Y.thresh</code> to select percentiles used to 
bin outcomes, and <code>"round"</code> sets values equal or less than 0 to 0, 
and rounds all positive values to the nearest whole number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.thresh</code></td>
<td>
<p>A manual value used to threshold when 
<code>threshold.method = "manual"</code>; values equal or greater than the cutoff
are assigned 1 and all others 0. When <code>threshold.method = "percentile"</code>,
a percentile to use to bin outcomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.categorical</code></td>
<td>
<p>Default is <code>X.categorical = FALSE</code>. If
<code>X.categorical = TRUE</code> then thresholds are applied to categorize
each predictor/image value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.num.categories</code></td>
<td>
<p>A scalar value denoting the number of categories
in which to divide the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.category.type</code></td>
<td>
<p>Tells R how to categorize the data. Options are
<code>X.category.type = c("percentile", "manual")</code>.
If <code>X.category.type = "percentile"</code> then the data are divided into
percentiles based on <code>X.num.categories</code>; e.g. if 
<code>X.num.categories = 4</code> then the values are divided into quartiles, 
and values in Q1 equal 0, between Q1 and Q2 equal 1, between Q2 and Q3 
equal 2, and greater than Q3 equal 3. 
If <code>X.category.type = "manual"</code> then specify the cutoff points with
<code>X.manual.thresh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.manual.thresh</code></td>
<td>
<p>A vector containing the thresholds for categorizing
the values; e.g. if <code>X.num.categories = 4</code> and 
<code>X.manual.thresh = c(-3, 1, 17)</code>, then values less than -3 are set to
0, equal or greater than -3 and less than 1 are set to 1, equal or greater
than 1 but less than 17 are set to 2, and equal or greater than 17 are set
to 3. Note that <code>length(X.manual.thresh)</code> must always equal 
<code>X.num.categories - 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.cat.names</code></td>
<td>
<p>A vector of category names. If <code>X.cat.names = NULL</code>
then the initial integers assigned are left as the values; the names in
<code>X.cat.names</code> are assigned in ascending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.out</code></td>
<td>
<p>If <code>print.out = TRUE</code> then print the following for
each subject, indexed y: </p>

<ul>
<li> <p><code>X[y] %*% B</code>
</p>
</li>
<li> <p><code>p[y]</code>, <code>lambda[y]</code> for Binomial, Poisson, respectively.
</p>
</li>
</ul>
<p>This is useful to see the effect of image parameter selection and beta
parameter selection on distributional parameters for the outcome of 
interest.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data frame where each row consists of a single subject's data.
Col 1 is the outcome, Y, and each successive column contains the subject
predictor values.
</p>


<h3>Note</h3>

<p>Careful parameter selection, i.e. <code>B</code>, is necessary to ensure 
that simulated outcomes are reasonable; in particular, counts arising from
the Poisson distribution can be unnaturally large.
</p>


<h3>References</h3>

<p>Furrer R, Sain SR (2010).
“spam: A Sparse Matrix R Package with Emphasis on MCMC Methods for Gaussian Markov Random Fields.”
<em>Journal of Statistical Software</em>, <b>36</b>(10), 1-25.
<a href="https://www.jstatsoft.org/v36/i10/">https://www.jstatsoft.org/v36/i10/</a>.
</p>
<p>Ripley BD (1987).
<em>Stochastic Simulation</em>.
John Wiley &amp; Sons.
<a href="https://doi.org/10.1002/9780470316726">doi:10.1002/9780470316726</a>.
</p>
<p>Rue H (2001).
“Fast Sampling of Gaussian Markov Random Fields.”
<em>Journal of the Royal Statistical Society B</em>, <b>63</b>, 325-338.
<a href="https://doi.org/10.1111/1467-9868.00288">doi:10.1111/1467-9868.00288</a>.
</p>
<p>Agresti A (2007).
<em>An Introduction to Categorical Analysis</em>, 2nd edition.
John Wiley &amp; Sons, Hoboken, New Jersey.
</p>
<p>Friedman J, Hastie T, Tibshirani R (2010).
“Regularization paths for generalized linear models via coordinate descent.”
<em>Journal of Statistical Software</em>, <b>33</b>, 1-22.
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate precision matrix and take Cholesky decomposition
Rpre &lt;- chol_s2Dp(im.res = c(3, 3), matrix.type = "prec",
                  use.spam = TRUE, neighborhood = "ar1",
                  triangle = "upper", return.prec = TRUE)
## Generate correlation matrix &amp; take Cholesky decomposition
Rcov &lt;- chol_s2Dp(corr.structure = "ar1", im.res = c(3, 3), 
                  rho = 0.5,
                  triangle = "upper",
                  use.spam = FALSE, neighborhood = "none")

## Define non-zero beta values
Bex &lt;- beta_builder(row.index = c(2, 3), 
                    col.index = c(3, 3),
                    im.res = c(3, 3),
                    B0 = 0, B.values = rep(1, 2),
                    output.indices = FALSE)
## Simulate Datasets
## parameter values
Nex = 100
set.seed(28743)

## with precision matrix
Gauss.exp &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                         R = Rpre$R, Q = Rpre$Q,
                         dist = "gaussian")
hist(Gauss.exp$Y)

## with covariance matrix
Gauss.exc &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                         R = Rcov$R, S = Rcov$S,
                         dist = "gaussian")
hist(Gauss.exc$Y)

## direct draws from binomial
Bin.ex &lt;- sim_Y_MVN_X(N = Nex, B = Bex, R = Rcov$R, S = Rcov$S,
                      dist = "binomial", print.out = TRUE)
table(Bin.ex$Y)

## manual cutoff
Bin.ex2 &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "binomial",
                       threshold.method = "manual",
                       Y.thresh = 1.25)
table(Bin.ex2$Y)

## percentile cutoff
Bin.ex3 &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "binomial",
                       threshold.method = "percentile",
                       Y.thresh = 0.75)
table(Bin.ex3$Y)

## Poisson Example - note the large counts
Pois.ex &lt;- sim_Y_MVN_X(N = Nex, B = Bex,
                       R = Rcov$R, S = Rcov$S,
                       dist = "poisson", print.out = TRUE)
mean(Pois.ex$Y)
quantile(Pois.ex$Y, 
         probs = c(0, 0.1, 0.25, 0.45, 0.5,
                   0.75, 0.9, 0.95, 0.99, 1))
hist(Pois.ex$Y)
</code></pre>


</div>