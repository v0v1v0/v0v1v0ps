<div class="container">

<table style="width: 100%;"><tr>
<td>gscor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Find the Structural Correlations Between Two or More Graphs </h2>

<h3>Description</h3>

<p><code>gscor</code> finds the product-moment structural correlation between the adjacency matrices of graphs indicated by <code>g1</code> and <code>g2</code> in stack <code>dat</code> (or possibly <code>dat2</code>) given exchangeability list <code>exchange.list</code>.  Missing values are permitted. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">gscor(dat, dat2=NULL, g1=NULL, g2=NULL,  diag=FALSE, 
    mode="digraph", method="anneal", reps=1000, prob.init=0.9,
    prob.decay=0.85, freeze.time=25, full.neighborhood=TRUE, 
    exchange.list=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> a stack of input graphs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat2</code></td>
<td>
<p> optionally, a second graph stack. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g1</code></td>
<td>
<p> the indices of <code>dat</code> reflecting the first set of graphs to be compared; by default, all members of <code>dat</code> are included. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g2</code></td>
<td>
<p> the indices or <code>dat</code> (or <code>dat2</code>, if applicable) reflecting the second set of graphs to be compared; by default, all members of <code>dat</code> are included. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p> boolean indicating whether or not the diagonal should be treated as valid data.  Set this true if and only if the data can contain loops.  <code>diag</code> is <code>FALSE</code> by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p> string indicating the type of graph being evaluated.  <code>"digraph"</code> indicates that edges should be interpreted as directed; <code>"graph"</code> indicates that edges are undirected.  <code>mode</code> is set to <code>"digraph"</code> by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> method to be used to search the space of accessible permutations; must be one of <code>"none"</code>, <code>"exhaustive"</code>, <code>"anneal"</code>, <code>"hillclimb"</code>, or <code>"mc"</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reps</code></td>
<td>
<p> number of iterations for Monte Carlo method. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.init</code></td>
<td>
<p> initial acceptance probability for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.decay</code></td>
<td>
<p> cooling multiplier for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freeze.time</code></td>
<td>
<p> freeze time for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.neighborhood</code></td>
<td>
<p> should the annealer evaluate the full neighborhood of pair exchanges at each iteration? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exchange.list</code></td>
<td>
<p> information on which vertices are exchangeable (see below); this must be a single number, a vector of length n, or a nx2 matrix. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The structural correlation coefficient between two graphs G and H is defined as
</p>
<p style="text-align: center;"><code class="reqn">scor\left(G,H \left| L_G,L_H\right.\right) = \max_{L_G,L_H} cor(\ell(G),\ell(H))</code>
</p>

<p>where <code class="reqn">L_G</code> is the set of accessible permutations/labelings of G, <code class="reqn">\ell(G)</code> is a permutation/relabeling of G, and <code class="reqn">\ell(G) \in L_G</code>.  The set of accessible permutations on a given graph is determined by the <em>theoretical exchangeability</em> of its vertices; in a  nutshell, two vertices are considered to be theoretically exchangeable for a given problem if all predictions under the conditioning theory are invariant to a relabeling of the vertices in question (see Butts and Carley (2001) for a more formal exposition).  Where no vertices are exchangeable, the structural correlation becomes the simple graph correlation.  Where <em>all</em> vertices are exchangeable, the structural correlation reflects the correlation between unlabeled graphs; other cases correspond to correlation under partial labeling.  
</p>
<p>The accessible permutation set is determined by the <code>exchange.list</code> argument, which is dealt with in the following manner. First, <code>exchange.list</code> is expanded to fill an nx2 matrix.  If <code>exchange.list</code> is a single number, this is trivially accomplished by replication; if <code>exchange.list</code> is a vector of length n, the matrix is formed by cbinding two copies together.  If <code>exchange.list</code> is already an nx2 matrix, it is left as-is.  Once the nx2 exchangeability matrix has been formed, it is interpreted as follows: columns refer to graphs 1 and 2, respectively; rows refer to their corresponding vertices in the original adjacency matrices; and vertices are taken to be theoretically exchangeable iff their corresponding exchangeability matrix values are identical.  To obtain an unlabeled graph correlation (the default), then, one could simply let <code>exchange.list</code> equal any single number.  To obtain the standard graph correlation, one would use the vector <code>1:n</code>.
</p>
<p>Because the set of accessible permutations is, in general, very large (<code class="reqn">o(n!)</code>), searching the set for the maximum correlation is a non-trivial affair.  Currently supported methods for estimating the structural correlation are hill climbing, simulated annealing, blind monte carlo search, or exhaustive search (it is also possible to turn off searching entirely).  Exhaustive search is not recommended for graphs larger than size 8 or so, and even this may take days; still, this is a valid alternative for small graphs.  Blind monte carlo search and hill climbing tend to be suboptimal for this problem and are not, in general recommended, but they are available if desired.  The preferred (and default) option for permutation search is simulated annealing, which seems to work well on this problem (though some tinkering with the annealing parameters may be needed in order to get optimal performance).  See the help for <code>lab.optimize</code> for more information regarding these options.
</p>
<p>Structural correlation matrices are p.s.d., and are p.d. so long as no graph within the set is a linear combination of any other under any accessible permutation.  Their eigendecompositions are meaningful and they may be used in linear subspace analyses, so long as the researcher is careful to interpret the results in terms of the appropriate set of accessible labelings.  Classical null hypothesis tests should not be employed with structural correlations, and QAP tests are almost never appropriate (save in the uniquely labeled case).  See <code>cugtest</code> for a more reasonable alternative.
</p>


<h3>Value</h3>

<p>An estimate of the structural correlation matrix
</p>


<h3>Warning </h3>

<p>The search process can be <em>very slow</em>, particularly for large graphs.  In particular, the <em>exhaustive</em> method is order factorial, and will take approximately forever for unlabeled graphs of size greater than about 7-9.</p>


<h3>Note</h3>

<p> Consult Butts and Carley (2001) for advice and examples on theoretical exchangeability. </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p> Butts, C.T., and Carley, K.M.  (2001).  “Multivariate Methods for Interstructural Analysis.”  CASOS Working Paper, Carnegie Mellon University.</p>


<h3>See Also</h3>

 <p><code>gscov</code>, <code>gcor</code>, <code>gcov</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate two random graphs
g.1&lt;-rgraph(5)
g.2&lt;-rgraph(5)

#Copy one of the graphs and permute it
perm&lt;-sample(1:5)
g.3&lt;-g.2[perm,perm]

#What are the structural correlations between the labeled graphs?
gscor(g.1,g.2,exchange.list=1:5)
gscor(g.1,g.3,exchange.list=1:5)
gscor(g.2,g.3,exchange.list=1:5)

#What are the structural correlations between the underlying 
#unlabeled graphs?
gscor(g.1,g.2)
gscor(g.1,g.3)
gscor(g.2,g.3)
</code></pre>


</div>