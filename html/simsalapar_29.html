<div class="container">

<table style="width: 100%;"><tr>
<td>subjob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subjob - Compute one Row of the Virtual Grid</h2>

<h3>Description</h3>

<p><code>subjob()</code> computes one row of the virtual grid in a simulation
study, provides several seeding methods, and sub-job monitoring
(information about the sub-job just finished).
</p>
<p><code>printInfo</code> is a named list of functions optionally to be used as
<code>monitor</code> in <code>subjob()</code> for printing information at the end of
each sub-job.
</p>


<h3>Usage</h3>

<pre><code class="language-R">subjob(i, pGrid, nonGrids, n.sim, seed, keepSeed = FALSE,
       repFirst = TRUE, doOne,
       timer = mkTimer(gcFirst=FALSE), monitor = FALSE, ...)

printInfo # or
# printInfo[["default"]]
</code></pre>


<h3>Arguments</h3>





<table>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>row number of the virtual grid. <code>i.sim</code> and <code>j</code>
together determine <code>i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pGrid</code></td>
<td>
<p>“physical grid” of all combinations of variables
of type <code>"grid"</code>, as returned by <code>mkGrid(&lt;varlist&gt;)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonGrids</code></td>
<td>
<p>values of non-"grid"-variables (if provided, passed to
<code>doOne()</code>), i.e., typically
<code>get.nonGrids(&lt;varlist&gt;)[["nonGrids"]]</code>.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>number of simulation replications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>one of:
</p>

<dl>
<dt><code>NULL</code></dt>
<dd>
<p><code>.Random.seed</code> remains
untouched.  If it does not exist, generate it by calling
<code>runif(1)</code>.  This case typically leads to <b>non</b>-reproducible
results.</p>
</dd>
<dt><code>numeric(n.sim)</code></dt>
<dd>
<p>a <code>numeric</code> vector
of length <code>n.sim</code> containing the seed for each simulation
replications (same seed for each row in the (physical) grid;
this ensures least variance across computations for the same
replication).  This case leads to reproducible results.</p>
</dd>
<dt><code>vector("list", n.sim)</code></dt>
<dd>
<p>a <code>list</code> of
length <code>n.sim</code> containing seeds (typically numeric vectors)
for each of the <code>n.sim</code> simulation replications
(same seed for each row in the (physical) grid).  The seeds are
assigned to <code>.Random.seed</code> in <code>globalenv()</code>
and can thus be used for other random number generators such as
<code>"L'Ecuyer-CMRG"</code>, see <code>set.seed()</code>.  This case
leads to reproducible results.</p>
</dd>
<dt><code>NA</code></dt>
<dd>
<p><code>.Random.seed</code> remains
untouched.  If it does not exist, so be it.  No fifth component is
concatenated to the result of the <code>doOne()</code> call in this
case even when <code>keepSeed=TRUE</code> (where in all other cases,
the seed is appended as 5th component).  This method typically
leads to <b>non</b>-reproducible results.</p>
</dd>
<dt>
<code>character</code> string</dt>
<dd>
<p>a character string
specifying a seeding method.  Currently only <code>"seq"</code> in
which case the seeds 1 to <code>n.sim</code> for the <code>n.sim</code>
simulation replications are used.  This is the default.
Functionally, it is a special case of the “<code>numeric(n.sim)</code>”
specification above (with <code>seed = 1:n.sim</code>) and hence leads
to reproducible results.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepSeed</code></td>
<td>
<p><code>logical</code> indicating if <code>.Random.seed</code>
should be appended to each return value of <code>doCallWE()</code>
- unless <code>seed = NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repFirst</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code> (the
default), all <code>n.sim</code> replications are computed for a
row in the (physical) grid first, before the next row is considered;
if <code>FALSE</code>, first all rows of the (physical) grid are
computed for a fixed replicate until the next replicate is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doOne</code></td>
<td>
<p><code>function</code> for computing one row in the
(physical) grid; must return a numeric vector, <code>matrix</code>,
or <code>array</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timer</code></td>
<td>
<p>a <code>function</code> similar to
<code>system.time()</code>, passed to <code>doCallWE()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitor</code></td>
<td>
<p><code>logical</code> or <code>function</code>
indicating whether or how monitoring output is displayed.
<code>TRUE</code> defaults to the <code>printInfo[["default"]]</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>doOne()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the vignette or references in <code>simsalapar-package</code> for
how to use these functions.
</p>
<p>The case where <code>seed</code> is a <code>numeric</code> vector of length
<code>n.sim</code> also leads to the same results no matter which variables
are of type “grid” or “inner”; see <code>demo(robust.mean)</code> where
this is tested.  This is important to guarantee since one might want to
change certain “inner” variables to “grid” variables due to
load-balancing while computing the desired statistics based on the
same seed (or generated data from this seed).</p>


<h3>Value</h3>


<dl>
<dt>printInfo</dt>
<dd>
<p><em>is</em> a named <code>list</code> of
<code>function</code>s which produce output (<code>cat(..)</code>)
containing information about the sub-job which <code>subjob()</code> has
just finished.  Note that components <code>"gfile"</code>
(“global file”) and <code>"fileEach"</code> each direct the
monitoring output to <em>files</em>.</p>
</dd>
<dt>subjob()</dt>
<dd>
<p>returns a vector of length five if <code>keepSeed</code> is true
and <code>seed</code> is not <code>NA</code>, otherwise (also by default), of
length four.  The first four components contain the
return value of <code>doCallWE()</code>.  If <code>keepSeed</code> is
true, the fifth component contains <code>.Random.seed</code>
before the call of <code>doCallWE()</code> (for reproducibility).</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Marius Hofert and Martin Maechler.</p>


<h3>See Also</h3>

<p><code>doCallWE()</code>; <code>.Random.seed</code> for
information about random number generators and seeds.
</p>
<p>For examples of <em>implicit</em> use of <code>subjob</code>, see
<code>doLapply</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">names(printInfo)# currently "default", "gfile", "fileEach"

str(printInfo, give.attr=FALSE)
## the functions in printInfo share a common environment() with utility functions:
ls.str(environment(printInfo$default))
if(FALSE) # show them all
as.list(environment(printInfo$default))
</code></pre>


</div>