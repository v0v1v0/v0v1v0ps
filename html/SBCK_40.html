<div class="container">

<table style="width: 100%;"><tr>
<td>PrePostProcessing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PrePostProcessing base class</h2>

<h3>Description</h3>

<p>Base class to pre/post process data before/after a bias correction
</p>


<h3>Details</h3>

<p>This base class can be considered as the identity pre-post processing, and
is used to be herited by others pre/post processing class. The key ideas are:<br>
- A PrePostProcessing based class contains a bias correction method, initalized
by the 'bc_method' argument, always available for all herited class<br>
- The 'pipe' keyword is a list of pre/post processing class, applied one after
the other.<br></p>
<p>Try with an example, start with a dataset similar to tas/pr:<br>
&gt;&gt;&gt; XY = SBCK::dataset_like_tas_pr(2000)<br>
&gt;&gt;&gt; X0 = XY$X0<br>
&gt;&gt;&gt; X1 = XY$X1<br>
&gt;&gt;&gt; Y0 = XY$Y0<br></p>
<p>The first column is Gaussian, but the second is an exponential law with a Dirac
mass at 0, represented the 0 of precipitations. For a quantile mapping
correction in the calibration period, we just apply<br>
&gt;&gt;&gt; qm = SBCK::QM$new()<br>
&gt;&gt;&gt; qm$fit(Y0,X0)<br>
&gt;&gt;&gt; Z0 = qm$predict(X0)<br></p>
<p>Now, if we want to pre-post process with the SSR method (0 are replaced by
random values between 0 (excluded) and the minimal non zero value), we write:<br>
&gt;&gt;&gt; ppp = SBCK::PPPSSR$new( bc_method = QM , cols = 2 )<br>
&gt;&gt;&gt; ppp$fit(Y0,X0)<br>
&gt;&gt;&gt; Z0 = ppp$predict(X0)<br></p>
<p>The SSR approach is applied only on the second column (the precipitation), and
the syntax is the same than for a simple bias correction method.<br></p>
<p>Imagine now that we want to apply the SSR, and to ensure the positivity of CDFt
for precipitation, we also want to use the LogLinLink pre-post processing
method. This can be done with the following syntax:<br>
&gt;&gt;&gt; ppp = PPPLogLinLink$new( bc_method = CDFt , cols = 2 ,<br>
&gt;&gt;&gt;                          pipe = list(PPPSSR) , <br>
&gt;&gt;&gt;                          pipe_kwargs = list( list(cols = 2) ) )<br>
&gt;&gt;&gt; ppp$fit(Y0,X0,X1)<br>
&gt;&gt;&gt; Z = ppp$predict(X1,X0)<br></p>
<p>With this syntax, the pre processing operation is
PPPLogLinLink$transform(PPPSSR$transform(data)) and post processing operation
PPPSSR$itransform(PPPLogLinLink$itransform(bc_data)). So the formula can read
from right to left (as the mathematical composition). Note it is equivalent
to define:<br>
&gt;&gt;&gt; ppp = PrePostProcessing$new( bc_method = CDFt,<br>
&gt;&gt;&gt;                              pipe = list(PPPLogLinLink,PPPSSR),<br>
&gt;&gt;&gt;                              pipe_kwargs = list( list(cols=2) , list(cols=2) ) )<br></p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PrePostProcessing-new"><code>PrePostProcessing$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-transform"><code>PrePostProcessing$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-itransform"><code>PrePostProcessing$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-fit"><code>PrePostProcessing$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-predict"><code>PrePostProcessing$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-clone"><code>PrePostProcessing$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-PrePostProcessing-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new PrePostProcessing object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$new(
  bc_method = NULL,
  bc_method_kwargs = list(),
  pipe = list(),
  pipe_kwargs = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bc_method</code></dt>
<dd>
<p>The bias correction method</p>
</dd>
<dt><code>bc_method_kwargs</code></dt>
<dd>
<p>Dict of keyword arguments passed to bc_method</p>
</dd>
<dt><code>pipe</code></dt>
<dd>
<p>list of others PrePostProcessing class to pipe</p>
</dd>
<dt><code>pipe_kwargs</code></dt>
<dd>
<p>list of list of keyword arguments passed to each
elements of pipe</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new 'PrePostProcessing' object.
</p>


<hr>
<a id="method-PrePostProcessing-transform"></a>



<h4>Method <code>transform()</code>
</h4>

<p>Transformation applied to data before the bias correction. Just the
identity for this class
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>[matrix: n_samples * n_features]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Xt [matrix: n_samples * n_features]
</p>


<hr>
<a id="method-PrePostProcessing-itransform"></a>



<h4>Method <code>itransform()</code>
</h4>

<p>Transformation applied to data after the bias correction. Just the
identity for this class
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt>
<dd>
<p>[matrix: n_samples * n_features]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>X [matrix: n_samples * n_features]
</p>


<hr>
<a id="method-PrePostProcessing-fit"></a>



<h4>Method <code>fit()</code>
</h4>

<p>Apply the pre processing and fit the bias correction method. If X1 is
NULL, the method is considered as stationary
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$fit(Y0, X0, X1 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt>
<dd>
<p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt>
<dd>
<p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt>
<dd>
<p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-PrePostProcessing-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Predict the correction, apply pre-processing before, and post-processing
after
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$predict(X1 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt>
<dd>
<p>[matrix: n_samples * n_features or NULL] Model in projection</p>
</dd>
<dt><code>X0</code></dt>
<dd>
<p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL (and vice-versa), else return a list
containing Z1 and Z0, the corrections of X1 and X0
</p>


<hr>
<a id="method-PrePostProcessing-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define pre/post processing method
ppp = PrePostProcessing$new( bc_method = CDFt,
                             pipe = list(PPPLogLinLink,PPPSSR),
                             pipe_kwargs = list( list(cols=2) , list(cols=2) ) )

## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>


</div>