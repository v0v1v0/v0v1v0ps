<div class="container">

<table style="width: 100%;"><tr>
<td>GRFClassifierSSLR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General Interface for GRFClassifier (Label propagation using Gaussian Random Fields and Harmonic) model</h2>

<h3>Description</h3>

<p>model from RSSL package
Implements the approach proposed in Zhu et al. (2003) to label propagation over
an affinity graph. Note, as in the original paper, we consider the transductive
scenario, so the implementation does not generalize to out of sample predictions.
The approach minimizes the squared difference in labels assigned to different objects,
where the contribution of each difference to the loss is weighted by the affinity between
the objects. The default in this implementation is to use a knn adjacency matrix based on euclidean
distance to determine this weight. Setting adjacency="heat" will use an RBF kernel over
euclidean distances between objects to determine the weights.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GRFClassifierSSLR(
  adjacency = "nn",
  adjacency_distance = "euclidean",
  adjacency_k = 6,
  adjacency_sigma = 0.1,
  class_mass_normalization = TRUE,
  scale = FALSE,
  x_center = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>character; "nn" for nearest neighbour graph or "heat" for radial basis adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency_distance</code></td>
<td>
<p>character; distance metric for nearest neighbour adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency_k</code></td>
<td>
<p>integer; number of neighbours for the nearest neighbour adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency_sigma</code></td>
<td>
<p>double; width of the rbf adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class_mass_normalization</code></td>
<td>
<p>logical; Should the Class Mass Normalization heuristic be applied? (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical; Should the features be normalized? (default: FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_center</code></td>
<td>
<p>logical; Should the features be centered?</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Zhu, X., Ghahramani, Z. &amp; Lafferty, J., 2003
Semi-supervised learning using gaussian fields and harmonic functions. In Proceedings of the 20th International Conference on Machine Learning. pp. 912-919.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(tidyverse)
library(caret)
library(SSLR)
library(tidymodels)

data(wine)


cls &lt;- which(colnames(wine) == "Wine")

#% LABELED
labeled.index &lt;- createDataPartition(wine$Wine, p = .2, list = FALSE)
wine[-labeled.index,cls] &lt;- NA


m &lt;- GRFClassifierSSLR() %&gt;% fit(Wine ~ ., data = wine)

#Accesing model from RSSL
model &lt;- m$model

#Predictions of unlabeled
preds_unlabeled &lt;- m %&gt;% predictions()
print(preds_unlabeled)

preds_unlabeled &lt;- m %&gt;% predictions(type = "raw")
print(preds_unlabeled)

#Total
y_total &lt;- wine[,cls]
y_total[-labeled.index] &lt;- preds_unlabeled
</code></pre>


</div>