<div class="container">

<table style="width: 100%;"><tr>
<td>sm.pca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Smooth principal components analysis
</h2>

<h3>Description</h3>

<p>This function calculates principal components in a manner which changes 
smoothly with a covariate.  The smooth eigenvalues and eigenvector
loadings can be plotted.  A permutation test of equality of the components,
both eigenvalues and eigenvectors, can be carried out.    
</p>


<h3>Usage</h3>

<pre><code class="language-R">sm.pca(x, Y, h, cor = TRUE, nperm = 100, pc = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a vector of covariate values or a list object which is the output of a previous call to <code>sm.pca</code>.  In the latter case, previously computed information is used to create plots and tests and the arguments <code>Y</code>, <code>h</code>, <code>cor</code> and <code>nperm</code> are not required.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>a matrix of responses whose rows correspond to the covariate values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>the smoothing parameter which controls the smoothness of estimation with respect to the covariate <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>

<p>a logical value indicating whether the correlation, rather than covariance, matrix should be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>

<p>the number of permutations used in the permutation test and graphical reference band.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc</code></td>
<td>

<p>an integer value indicating the component to be plotted against the covariate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other optional parameters are passed to the <code>sm.options</code>
function, through a mechanism which limits their effect only to this
call of the function. Those relevant for this function are the following:
<code>display</code> (here set to <code>"eigevalues"</code> or <code>"eigenvectors"</code>)
<code>ngrid</code>,
<code>xlab</code>;
see the documentation of  <code>sm.options</code> for their description.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Several further arguments may be set and these are passed to <code>sm.options</code>.  Relevant arguments for this function are <code>display</code> (<code>"eigenvalues"</code>, <code>"eigenvectors"</code>), <code>ngrid</code> and <code>df</code>.  See <code>link{sm.options}</code> for further details.
</p>
<p>The smoothing is performed by the local constant kernel method and the smoothing parameter corresponds to the standard deviation of a normal kernel function.  If <code>h</code> is left unspecified then it is selected to correspond to the degrees of freedom set by the parameter <code>df</code>.
</p>
<p>The reference band for a constant eigenvalue is constructed from the upper and lower pointwise 2.5 percentiles of the smooth eigenvalue curves from the data with permuted covariate values.  The p-value compares the observed value of the difference between the smoothed and constant eigenvalues, summed over the covariate grid in <code>eval.points</code>, with the values generated from the permuted data.
</p>
<p>In the eigenvector case, a reference band is computed from the percentiles of the curves from the permuted data, for each of the loadings.  In order to plot all the loadings curves simultaneously, the locations where each curve lies inside its respective reference band are indicated by pale colour.  The p-value compares the observed value of <code>1 - sum(e*e0)^2</code>, where <code>e</code> and <code>e0</code> are the eigenvectors under the smooth and constant scenarios (summed over the covariate grid), with the values generated from the permuted data.  This test statistic differs from the one described in the Miller and Bowman (2012) reference below.  It has been used as it conveniently handles the arbitrary sign of principal components.
</p>
<p>When some components explain similar proportions of variance, the eigenvalues and eigenvectors can easily interchange, causing apparent sharp changes in the eigenvalue and eigenvector curves.  It is difficult to track the components to avoid this.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>

<dl>
<dt>xgrid</dt>
<dd>
<p>a vector of values on the covariate scale at which the smooth estimates are constructed.</p>
</dd>
<dt>evals</dt>
<dd>
<p>a matrix whose columns give the smooth eigenvalues for each component at the covariate values.</p>
</dd>
<dt>evecs</dt>
<dd>
<p>a three-dimensional array whose third dimension corresponds to the covariate values and whose second dimension indexes the smooth components.</p>
</dd>
<dt>mhat</dt>
<dd>
<p>a matrix whose columns give the estimated smooth means for each dimension of <code>Y</code> at the covariate values.</p>
</dd>
<dt>var.explained</dt>
<dd>
<p>a matrix whose rows give the proportions of variance explained by each component at each covariate value.</p>
</dd>
<dt>xlab</dt>
<dd>
<p>the label attached to the x-axis.</p>
</dd>
<dt>h</dt>
<dd>
<p>the smoothing parameter used.</p>
</dd>
<dt>x</dt>
<dd>
<p>the covariate values, after removal of missing cases.</p>
</dd>
<dt>Y</dt>
<dd>
<p>the matrix of response values, after removal of missing cases.</p>
</dd>
<dt>cor</dt>
<dd>
<p>a logical indicator of whether the correlation, rather than covariance, matrix is used in the construction of the eigenvalues and eigenvectors.</p>
</dd>
</dl>
<p>When a test or reference band is computed, the list has the additional components:
</p>

<dl>
<dt>nperm</dt>
<dd>
<p>the number of permutations used.</p>
</dd>
<dt>evals.perm</dt>
<dd>
<p>the eigenvalues computed from the permuted data.</p>
</dd>
<dt>evecs.perm</dt>
<dd>
<p>the eigenvectors computed from the permuted data.</p>
</dd>
</dl>
<p>When display contains <code>"eigenvalues"</code> or <code>"eigenvectors"</code>, the list has the additional components:
</p>

<dl>
<dt>p.values</dt>
<dd>
<p>the p-value for a test of constant eigenvalue for the component identified by <code>pc</code>.</p>
</dd>
<dt>p.vectors</dt>
<dd>
<p>the p-value for a test of constant eigenvectors for the component identified by <code>pc</code>.</p>
</dd>
</dl>
<p>When display contains <code>"eigenvalues"</code>, the list has the additional component:
</p>

<dl>
<dt>band</dt>
<dd>
<p>a matrix whose two columns contain the boundaries of a reference band which indicates where the smooth eigenvalue curve should like if the hypothesis of no change in the eigenvalues with the covariate is correct.</p>
</dd>
</dl>
<p>When display contains <code>"eigenvectors"</code>, the list has the additional components:
</p>

<dl>
<dt>xgrid.plot</dt>
<dd>
<p>a vector of values used for plotting the smooth eigenvectors.</p>
</dd>
<dt>evecs.plot</dt>
<dd>
<p>a matrix whose rows contain the smooth eigenvectors at each value of <code>xgrid.plot</code>.</p>
</dd>
<dt>evecs.plot</dt>
<dd>
<p>a matrix whose columns contain the colours for the line segments in each smooth eigenvector component.</p>
</dd>
</dl>
<h3>Side Effects</h3>

<p>a plot on the current graphical device is produced, unless <code>display="none"</code>
</p>


<h3>References</h3>

<p>Miller, C. and Bowman, A.W. (2012). 
Smooth principal components for investigating changes in covariances over time.
<em>Applied Statistics</em> <b>61</b>, 693â€“714.
</p>


<h3>See Also</h3>

<p><code>sm.regression</code>, <code>sm.options</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
Y    &lt;- log(as.matrix(aircraft[ , -(1:2)]))
year &lt;- aircraft$Yr
h    &lt;- h.select(year, Y[ , 1], method = "df", df = 4)
spca &lt;- sm.pca(year, Y, h, display = "none")
sm.pca(year, Y, h, display = "eigenvalues")
sm.pca(year, Y, h, display = "eigenvectors", ylim = c(-1, 1))

# The following code shows how the plots can be redrawn from the returned object

spca &lt;- sm.pca(year, Y, h, display = "eigenvalues")
spca &lt;- sm.pca(year, Y, h, display = "eigenvectors", ylim = c(-1, 1))

with(spca, {
   ylim &lt;- range(evals[ , 1], band)
   plot(xgrid, evals[ , 1], type = "n", ylab = "Variance", ylim = ylim)
   polygon(c(xgrid, rev(xgrid)), c(band[ , 1], rev(band[ , 2])),
           col = "lightgreen", border = NA)
   lines(xgrid, evals[ , 1], col = "red")
})

with(spca, {
   pc &lt;- 1
   plot(range(xgrid.plot), range(evecs.plot), type = "n",
        xlab = "x", ylab = "PC loadings")
   for (i in 1:ncol(Y))
      segments(xgrid.plot[-length(xgrid.plot)],
               evecs.plot[-nrow(evecs.plot), i],
               xgrid.plot[-1], evecs.plot[-1, i],
               col = col.plot[ , i], lty = i)
})

## End(Not run)
</code></pre>


</div>