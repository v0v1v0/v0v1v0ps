<div class="container">

<table style="width: 100%;"><tr>
<td>fuzzy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fuzzy logic</h2>

<h3>Description</h3>

<p>Fuzzy Logic</p>


<h3>Usage</h3>

<pre><code class="language-R">fuzzy_logic(new, ...)
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>Numeric vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new</code></td>
<td>
<p>A character string specifying one of the available fuzzy
logic “families” (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional parameters for the selected family.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A call to <code>fuzzy_logic()</code> without arguments returns the currently
set fuzzy logic, i.e., a named list with four
components <code>N</code>, <code>T</code>, <code>S</code>, and <code>I</code> containing the
corresponding functions for negation, conjunction
(“t-norm”), disjunction (“t-conorm”), and residual
implication (which may not be available).
</p>
<p>The package provides several fuzzy logic <em>families</em>.
A concrete fuzzy logic is selected 
by calling <code>fuzzy_logic</code> with a character
string specifying the family name, and optional parameters.  Let us
refer to <code class="reqn">N(x) = 1 - x</code> as the <em>standard</em> negation, and,
for a t-norm <code class="reqn">T</code>, let <code class="reqn">S(x, y) = 1 - T(1 - x, 1 - y)</code> be the
<em>dual</em> (or complementary) t-conorm.  Available specifications and
corresponding families are as follows, with the standard negation used
unless stated otherwise.
</p>

<dl>
<dt><code>"Zadeh"</code></dt>
<dd>
<p>Zadeh's logic with <code class="reqn">T = \min</code> and
<code class="reqn">S = \max</code>.  Note that the minimum t-norm, also known as the
Gödel t-norm, is the pointwise largest t-norm, and that the
maximum t-conorm is the smallest t-conorm.</p>
</dd>
<dt><code>"drastic"</code></dt>
<dd>
<p>the drastic logic with t-norm
<code class="reqn">T(x, y) = y</code> if <code class="reqn">x = 1</code>, <code class="reqn">x</code> if <code class="reqn">y = 1</code>, and 0
otherwise, and complementary t-conorm <code class="reqn">S(x, y) = y</code> if
<code class="reqn">x = 0</code>, <code class="reqn">x</code> if <code class="reqn">y = 0</code>, and 1 otherwise.  Note that
the drastic t-norm and t-conorm are the smallest t-norm and
largest t-conorm, respectively.</p>
</dd>
<dt><code>"product"</code></dt>
<dd>
<p>the family with the product t-norm
<code class="reqn">T(x, y) = xy</code> and dual t-conorm <code class="reqn">S(x, y) = x + y - xy</code>.</p>
</dd> 
<dt><code>"Lukasiewicz"</code></dt>
<dd>
<p>the Lukasiewicz logic with t-norm
<code class="reqn">T(x, y) = \max(0, x + y - 1)</code> and dual t-conorm
<code class="reqn">S(x, y) = \min(x + y, 1)</code>.</p>
</dd>
<dt><code>"Fodor"</code></dt>
<dd>
<p>the family with Fodor's <em>nilpotent
minimum</em> t-norm given by <code class="reqn">T(x, y) = \min(x, y)</code> if
<code class="reqn">x + y &gt; 1</code>, and 0 otherwise, and the dual t-conorm given by
<code class="reqn">S(x, y) = \max(x, y)</code> if <code class="reqn">x + y &lt; 1</code>, and 1 otherwise.</p>
</dd>
<dt><code>"Frank"</code></dt>
<dd>
<p>the family of Frank t-norms <code class="reqn">T_p</code>,
<code class="reqn">p \ge 0</code>, which gives the Zadeh, product and Lukasiewicz
t-norms for <code class="reqn">p = 0</code>, 1, and <code class="reqn">\infty</code>, respectively,
and otherwise is given by 
<code class="reqn">T(x, y) = \log_p (1 + (p^x - 1) (p^y - 1) / (p - 1))</code>.</p>
</dd>
<dt><code>"Hamacher"</code></dt>
<dd>
<p>the three-parameter family of Hamacher,
with negation <code class="reqn">N_\gamma(x) = (1 - x) / (1 + \gamma x)</code>,
t-norm
<code class="reqn">T_\alpha(x, y) = xy / (\alpha + (1 - \alpha)(x + y - xy))</code>,
and t-conorm
<code class="reqn">S_\beta(x, y) = (x + y + (\beta - 1) xy) / (1 + \beta xy)</code>,
where <code class="reqn">\alpha \ge 0</code> and <code class="reqn">\beta, \gamma \ge -1</code>.  This
gives a deMorgan triple (for which <code class="reqn">N(S(x, y)) = T(N(x), N(y))</code>
iff <code class="reqn">\alpha = (1 + \beta) / (1 + \gamma)</code>.  The parameters can
be specified as <code>alpha</code>, <code>beta</code> and <code>gamma</code>,
respectively.  If <code class="reqn">\alpha</code> is not given, it is taken as
<code class="reqn">\alpha = (1 + \beta) / (1 + \gamma)</code>. 
The default values for <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> are 0, so that
by default, the product family is obtained.</p>
</dd>
</dl>
<p>The following parametric families are obtained by combining the
corresponding families of t-norms with the standard negation.
</p>

<dl>
<dt><code>"Schweizer-Sklar"</code></dt>
<dd>
<p>the Schweizer-Sklar family
<code class="reqn">T_p</code>, <code class="reqn">-\infty \le p \le \infty</code>, which
gives the Zadeh (minimum), product and drastic t-norms for
<code class="reqn">p = -\infty</code>, <code class="reqn">0</code>, and <code class="reqn">\infty</code>,
respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, (x^p + y^p - 1)^{1/p})</code>.</p>
</dd>
<dt><code>"Yager"</code></dt>
<dd>
<p>the Yager family <code class="reqn">T_p</code>, <code class="reqn">p \ge 0</code>,
which gives the drastic and minimum t-norms for <code class="reqn">p = 0</code>
and <code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, 1 - ((1-x)^p + (1-y)^p)^{1/p})</code>.</p>
</dd>
<dt><code>"Dombi"</code></dt>
<dd>
<p>the Dombi family <code class="reqn">T_p</code>, <code class="reqn">p \ge 0</code>,
which gives the drastic and minimum t-norms for <code class="reqn">p = 0</code>
and <code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = 0</code> if <code class="reqn">x = 0</code> or <code class="reqn">y = 0</code>, and
<code class="reqn">T_p(x, y) = 1 / (1 + ((1/x - 1)^p + (1/y - 1)^p)^{1/p})</code> if
both <code class="reqn">x &gt; 0</code> and <code class="reqn">y &gt; 0</code>.</p>
</dd>
<dt><code>"Aczel-Alsina"</code></dt>
<dd>
<p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">p \ge 0</code>, introduced by Aczél and Alsina, which gives the
drastic and minimum t-norms for <code class="reqn">p = 0</code> and
<code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \exp(-(|\log(x)|^p + |\log(y)|^p)^{1/p})</code>.</p>
</dd>
<dt><code>"Sugeno-Weber"</code></dt>
<dd>
<p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">-1 \le p \le \infty</code>, introduced by Weber
with dual t-conorms introduced by Sugeno, which gives the
drastic and product t-norms for <code class="reqn">p = -1</code> and
<code class="reqn">\infty</code>, respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = \max(0, (x + y - 1 + pxy) / (1 + p))</code>.</p>
</dd>
<dt><code>"Dubois-Prade"</code></dt>
<dd>
<p>the family of t-norms <code class="reqn">T_p</code>,
<code class="reqn">0 \le p \le 1</code>, introduced by Dubois and Prade, which gives
the minimum and product t-norms for <code class="reqn">p = 0</code> and <code class="reqn">1</code>,
respectively, and otherwise is given by
<code class="reqn">T_p(x, y) = xy / \max(x, y, p)</code>.</p>
</dd>
<dt><code>"Yu"</code></dt>
<dd>
<p>the family of t-norms <code class="reqn">T_p</code>, <code class="reqn">p \ge -1</code>,
introduced by Yu, which gives the product and drastic t-norms for
<code class="reqn">p = -1</code> and <code class="reqn">\infty</code>, respectively, and otherwise is
given by <code class="reqn">T(x, y) = \max(0, (1 + p) (x + y - 1) - p x y)</code>.</p>
</dd>
</dl>
<p>By default, the Zadeh logic is used.
</p>
<p><code>.N.</code>, <code>.T.</code>, <code>.S.</code>, and <code>.I.</code> are dynamic
functions, i.e., wrappers that call the corresponding function of the
current fuzzy logic.  Thus, the behavior of code using these
functions will change according to the chosen logic.
</p>


<h3>References</h3>

<p>C. Alsina, M. J. Frank and B. Schweizer (2006),
<em>Associative Functions: Triangular Norms and Copulas</em>.
World Scientific. ISBN 981-256-671-6.
</p>
<p>J. Dombi (1982),
A general class of fuzzy operators, the De Morgan class of fuzzy
operators and fuzziness measures induced by fuzzy operators,
<em>Fuzzy Sets and Systems</em> <b>8</b>, 149–163.
</p>
<p>J. Fodor and M. Roubens (1994),
<em>Fuzzy Preference Modelling and Multicriteria Decision Support</em>.
Kluwer Academic Publishers, Dordrecht.
</p>
<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1–27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>
<p>B. Schweizer and A. Sklar (1983),
<em>Probabilistic Metric Spaces</em>.
North-Holland, New York.  ISBN 0-444-00666-4.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(0.7, 0.8)
y &lt;- c(0.2, 0.3)

## Use default family ("Zadeh")
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)

## Switch family and try again
fuzzy_logic("Fodor")
.N.(x)
.T.(x, y)
.S.(x, y)
.I.(x, y)
</code></pre>


</div>