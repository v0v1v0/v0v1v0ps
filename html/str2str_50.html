<div class="container">

<table style="width: 100%;"><tr>
<td>lv2m</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>List of (atomic) Vectors to Matrix</h2>

<h3>Description</h3>

<p><code>lv2m</code> converts a list of (atomic) vectors to a matrix. This function
is similar to a hypothetical <code>as.matrix.list</code> method if it existed.
Note, if the vectors are not all the same typeof, then the matrix will have
the most complex typeof any vector in <code>lv</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lv2m(lv, along, fill = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lv</code></td>
<td>
<p>list of (atomic) vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>along</code></td>
<td>
<p>numeric vector of length 1 specifying either 1 for binding along rows
(i.e., each list element is a row) and 2 for binding along columns (i.e., each
list element in a column).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>logical vector of length 1 specifying whether 1) to allow the vectors
in <code>lv</code> to have different lengths, names, or both, 2) to bind by the names
of the vectors within <code>lv</code> rather than by their positions (unless no names
are present in which case positions are used), and 3) fill in any missing values
in the return object with NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lv</code> is a list of atomic
vectors. This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If fill = FALSE, <code>lv2m</code> uses a combination of <code>do.call</code> and <code>rbind</code>
if <code>along</code> = 1 or <code>do.call</code> and <code>cbind</code> if <code>along</code> = 2.
rownames and colnames of the returned data.frame are determined by the names of
<code>lv</code> and the names of the first vector within <code>lv</code>. If either are NULL,
then the positions are used as the dimension names. If fill = FALSE, then an
error is returned ff the vectors in <code>lv</code> do not all have the same length.
If fill = FALSE, there is no check to ensure the elements within each <code>lv</code>
vector have the same names in the same order. The names are taken from the first
vector in <code>lv</code>, and it is assumed those names and their order apply to each
vector in <code>lv</code>. Essentially, if fill = FALSE, <code>lv</code> binds the vectors
by positions and not names.
</p>
<p>If fill = TRUE, <code>lv2m</code> uses <code>plyr::rbind.fill.matrix</code> if <code>along</code> = 1 or
<code>plyr::rbind.fill.matrix</code> and <code>t.default</code> if <code>along</code> = 2. If fill = TRUE,
<code>lv2d</code> binds the vectors by by names (and by positions if no names are present).
Depending on what the user wants, fill = FALSE or TRUE could be safer. If the user
wants an error returned when any vectors within <code>lv</code> have different lengths,
then fill = FALSE should be used. If the user wants to bind by names rather than
position, then fill = TRUE should be used.
</p>


<h3>Value</h3>

<p>matrix with the elements of <code>lv</code> either as rows or columns and dimnames
determined by the names of <code>lv</code> and <code>lv[[1]]</code>. The typeof is determined
by the highest typeof in the elements of <code>lv</code> (i.e., highest to lowest: character &gt;
double &gt; integer &gt; logical).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# 1) `lv` has names; vectors have names
lv &lt;- setNames(object = lapply(X = letters, FUN = setNames, nm = "alphabet"), nm = LETTERS)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 2) `lv` has names; no vector names
lv &lt;- setNames(object = as.list(letters), nm = LETTERS)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 3) no `lv` names; vector have names
lv &lt;- lapply(X = letters, FUN = setNames, nm = "alphabet")
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 4) no `lv` names; no vector names
lv &lt;- as.list.default(letters)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# actual use case (sort of)
lv &lt;- lapply(X = asplit(x = as.matrix(attitude), MARGIN = 1),
   FUN = undim) # need undim since asplit returns 1D arrays
cbind(lv) # not what we want
do.call(what = cbind, args = lv) # doesn't have useful dimnames
lv2m(lv, along = 2) # finally what we want

# when vectors have named elements in different positions
lv &lt;- list("row_1" = c("col_A" = "col_A1", "col_B" = "col_B1", "col_C" = "col_C1"),
   "row_2" = c("col_B" = "col_B2", "col_C" = "col_C2", "col_A" = "col_A2"),
   "row_3" = c("col_C" = "col_C3", "col_A" = "col_A3", "col_B" = "col_B3"))
lv2m(lv, along = 1, fill = FALSE) # probably not what you want
lv2m(lv, along = 1, fill = TRUE) # what you want (See details)

# when you have a list with only one vector
lv &lt;- list("A" = c("one" = 1, "two" = 2, "three" = 3))
x &lt;- lv2m(lv, along = 1, fill = FALSE)
y &lt;- lv2m(lv, along = 1, fill = TRUE)
identical(x, y)

</code></pre>


</div>