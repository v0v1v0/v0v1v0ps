<div class="container">

<table style="width: 100%;"><tr>
<td>sdc_mpar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SparseDC Multi Parallel</h2>

<h3>Description</h3>

<p>Applies sparse clustering to data from multiple conditions, linking the
clusters across conditions and selecting a set of marker variables for
each cluster and condition. This is a wrapper function to run SparseMDC in
parallel and choose the solution with the mimimum score for each run.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sdc_mpar(pdat, nclust, dim, lambda1, lambda2, nitter = 20,
  nstarts = 50, init_iter = 5, delta = 1e-07, par_starts, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclust</code></td>
<td>
<p>Number of clusters in the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>The lambda 1 value to use in the SparseMDC function. This
value controls the number of marker genes detected for each of the clusters
in the final result. This can be calculated using the "lambda1_calculator"
function or supplied by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>The lambda 2 value to use in the SparseMDC function. This
value controls the number of genes that show condition-dependent
expression within each cell type. This can be calculated using the
"lambda2_calculator" function or supplied by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nitter</code></td>
<td>
<p>The max number of iterations for each of the start values, the
default value is 20.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstarts</code></td>
<td>
<p>The max number of possible starts. The default
value is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_iter</code></td>
<td>
<p>The number of iterations used to initialize the
algorithm. Higher values result in less starts but more accurate and
vice versa. Default is 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_starts</code></td>
<td>
<p>Number of parallel starts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores to use.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing cluster assignments, center values and the scores
for each start.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
# Calculate lambda1
lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3)
# Calcualte lambda2
lambda2 &lt;- lambda2_calculator(pdat, dim = 3, nclust = 3, lambda1 = lambda1)
# Prepare parallel enviornment
library(doParallel) # Load package
library(foreach)  # Load the package
library(doRNG)
# Apply SparseMDC
smdc_res &lt;- sdc_mpar(pdat, nclust = 3, dim = 3, lambda1 = lambda1,
lambda2 = lambda2, par_starts = 2, cores = 2)
</code></pre>


</div>