<div class="container">

<table style="width: 100%;"><tr>
<td>mem_multithreshold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Moran's Eigenvector Maps for different distance thresholds</h2>

<h3>Description</h3>

<p>Computes Moran's Eigenvector Maps of a distance matrix (using <code>mem()</code>) over different distance thresholds.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mem_multithreshold(
  distance.matrix = NULL,
  distance.thresholds = NULL,
  max.spatial.predictors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>distance.matrix</code></td>
<td>
<p>Distance matrix. Default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.thresholds</code></td>
<td>
<p>Numeric vector with distance thresholds defining neighborhood in the distance matrix, Default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.spatial.predictors</code></td>
<td>
<p>Maximum number of spatial predictors to generate. Only useful to save memory when the distance matrix <code>x</code> is very large. Default: <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function takes the distance matrix <code>x</code>, computes its weights at difference distance thresholds, double-centers the resulting weight matrices with <code>double_center_distance_matrix()</code>, applies eigen to each double-centered matrix, and returns eigenvectors with positive normalized eigenvalues for different distance thresholds.
</p>


<h3>Value</h3>

<p>A data frame with as many rows as the distance matrix <code>x</code> containing positive Moran's Eigenvector Maps. The data frame columns are named "spatial_predictor_DISTANCE_COLUMN", where DISTANCE is the given distance threshold, and COLUMN is the column index of the given spatial predictor.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){

 #loading example data
 data(distance_matrix)

 #computing Moran's eigenvector maps for 0, 1000, and 2000 km
 mem.df &lt;- mem_multithreshold(
   distance.matrix = distance_matrix,
   distance.thresholds = c(0, 1000, 2000)
   )
 head(mem.df)

}
</code></pre>


</div>