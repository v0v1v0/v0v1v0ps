<div class="container">

<table style="width: 100%;"><tr>
<td>modelOrder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get the model order and other properties of models</h2>

<h3>Description</h3>

<p>Get the model order and other properties of models.</p>


<h3>Usage</h3>

<pre><code class="language-R">modelOrder(object, convention, ...)

modelPoly(object, convention, ...)

modelPolyCoef(object, convention, lag_0 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convention</code></td>
<td>
<p>convention.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag_0</code></td>
<td>
<p>if TRUE include lag_0 coef, otherwise drop it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments for methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions return the requested quantity, optionally requesting
the returned value to follow a specific convention, see also
<code>modelCoef</code>.
</p>
<p>When called with one argument, these functions return corresponding
property in the native format for the object's class.
</p>
<p>Argument <code>convention</code> requests the result in some other
format. The mental model is that the returned value is as if the
object was first converted to the class specified by <code>convention</code>
and then the property extracted or computed. Normally, the object is
not actually converted to that class. one obvious reason is efficiency
but it may also not be possible, for example if argument
<code>convention</code> is the name of a virtual class.
</p>
<p>For example, the order of a seasonal SARIMA model is specified by
several numbers. The call <code>modelOrder(object)</code> returns it as a
list with components ar, ma, sar, sma, iorder, siorder and nseasons.
For some computations all that is needed are the overall AR and MA
orders obtained by multiplying out the AR-like and MA-like terms in
the model.
The result would be an ARMA filter and could be requested  by
<code>modelOrder(object, "ArmaFilter")</code>.
</p>
<p>The above operation is valid for any ARIMA model, so will always
succeed.  On the other hand, if further computation would work only if
there are no moving average terms in the model one could use
<code>modelOrder(object, "ArFilter")</code>. Here, if <code>object</code> contains
MA terms an error will be raised.
</p>
<p>The concept is powerful and helps in writing expressive code.
In this example a simple check on the returned value would do but even
so, such a check may require additional care.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>modelCoef</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">m1 &lt;- new("SarimaModel", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)
modelOrder(m1)
modelOrder(m1, "ArmaFilter")
modelOrder(m1, new("ArmaFilter"))

modelPoly(m1, "ArmaModel")
modelPolyCoef(m1, "ArmaModel")
</code></pre>


</div>