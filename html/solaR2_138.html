<div class="container">

<table style="width: 100%;"><tr>
<td>A4_prodGCPV</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performance of a grid connected PV system.</h2>

<h3>Description</h3>

<p>Compute every step from solar angles to effective irradiance to calculate the performance of a grid connected PV system.</p>


<h3>Usage</h3>

<pre><code class="language-R">prodGCPV(lat,
         modeTrk = 'fixed',
         modeRad = 'prom',
         dataRad,
         sample = 'hour',
         keep.night = TRUE,
         sunGeometry = 'michalsky',
         corr, f,
         betaLim = 90, beta = abs(lat)-10, alpha = 0,
         iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE,
         module = list(),
         generator = list(),
         inverter = list(),
         effSys = list(),
         modeShd = '',
         struct = list(),
         distances = data.table(),
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lat</code></td>
<td>
<p>numeric, latitude (degrees) of the point of the Earth where calculations are needed. It is positive for locations above the Equator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeTrk</code></td>
<td>
<p>A character string, describing the tracking method
of the generator. See <code>calcGef</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeRad, dataRad</code></td>
<td>
<p>Information about the source data of the
global irradiation. See <code>calcG0</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample, keep.night</code></td>
<td>
<p>See <code>calcSol</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sunGeometry</code></td>
<td>
<p><code>character</code>, method for the sun geometry
calculations. See <code>calcSol</code>, <code>fSolD</code> and <code>fSolI</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr, f</code></td>
<td>
<p>See <code>calcG0</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betaLim, beta, alpha, iS, alb, horizBright, HCPV</code></td>
<td>
<p>See <code>calcGef</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>module</code></td>
<td>
<p>list of numeric values with information about the PV module, </p>

<dl>
<dt><code>Vocn</code></dt>
<dd>
<p>open-circuit voltage of the module at Standard
Test Conditions (default value 57.6 volts.)</p>
</dd>
<dt><code>Iscn</code></dt>
<dd>
<p>short circuit current of the module at Standard
Test Conditions (default value 4.7 amperes.)</p>
</dd>
<dt><code>Vmn</code></dt>
<dd>
<p>maximum power point voltage of the module at
Standard Test Conditions (default value 46.08 amperes.)</p>
</dd>
<dt><code>Imn</code></dt>
<dd>
<p>Maximum power current of the module at Standard
Test Conditions (default value 4.35 amperes.)</p>
</dd>
<dt><code>Ncs</code></dt>
<dd>
<p>number of cells in series inside the module
(default value 96)</p>
</dd>
<dt><code>Ncp</code></dt>
<dd>
<p>number of cells in parallel inside the module (default value 1)</p>
</dd>
<dt><code>CoefVT</code></dt>
<dd>
<p>coefficient of decrement of voltage of each
cell with the temperature (default value 0.0023 volts per celsius degree)</p>
</dd>
<dt><code>TONC</code></dt>
<dd>
<p>nominal operational  cell temperature, celsius
degree (default value 47).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generator</code></td>
<td>
<p>list of numeric values with information about the generator, </p>

<dl>
<dt><code>Nms</code></dt>
<dd>
<p>number of modules in series (default value 12)</p>
</dd>
<dt><code>Nmp</code></dt>
<dd>
<p>number of modules in parallel (default value 11)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverter</code></td>
<td>
<p>list of numeric values with information about the DC/AC inverter, </p>

<dl>
<dt><code>Ki</code></dt>
<dd>
<p>vector of three values, coefficients of the
efficiency curve of the inverter (default c(0.01, 0.025, 0.05)),
or a matrix of nine values (3x3) if there is dependence with the
voltage (see references).</p>
</dd>
<dt><code>Pinv</code></dt>
<dd>
<p>nominal inverter power (W) (default value 25000
watts.)</p>
</dd>
<dt><code>Vmin, Vmax</code></dt>
<dd>
<p> minimum and maximum voltages of the MPP
range of the inverter (default values 420 and 750 volts)</p>
</dd>
<dt><code>Gumb</code></dt>
<dd>
<p> minimum irradiance for the inverter to start
(W/m²) (default value 20 W/m²)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effSys</code></td>
<td>
<p>list of numeric values with information about the system losses, </p>

<dl>
<dt><code>ModQual</code></dt>
<dd>
<p>average tolerance of the set of modules (%), default value is 3</p>
</dd>
<dt><code>ModDisp</code></dt>
<dd>
<p> module parameter disperssion losses (%), default value is 2</p>
</dd>
<dt><code>OhmDC</code></dt>
<dd>
<p> Joule losses due to the DC wiring (%), default value is 1.5</p>
</dd>
<dt><code>OhmAC</code></dt>
<dd>
<p>Joule losses due to the AC wiring (%), default value is 1.5</p>
</dd>
<dt><code>MPP</code></dt>
<dd>
<p> average error of the MPP algorithm of the inverter (%), default value is 1</p>
</dd>
<dt><code>TrafoMT</code></dt>
<dd>
<p>losses due to the MT transformer (%), default value is 1</p>
</dd>
<dt><code>Disp</code></dt>
<dd>
<p> losses due to stops of the system (%), default value is 0.5</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modeShd, struct, distances</code></td>
<td>
<p>See <code>calcShd</code> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for <code>calcG0</code> or <code>calcGef</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The calculation of the irradiance on the horizontal plane is
carried out with the function <code>calcG0</code>. The transformation
to the inclined surface makes use of the <code>fTheta</code> and
<code>fInclin</code> functions inside the <code>calcGef</code>
function. The shadows are computed with  <code>calcShd</code> while
the performance of the PV system is simulated with
<code>fProd</code>.</p>


<h3>Value</h3>

<p>A <code>ProdGCPV</code> object.</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro,
Francisco Delgado López.</p>


<h3>References</h3>


<ul>
<li>
<p> Perpiñán, O, Energía Solar Fotovoltaica, 2015.
(<a href="https://oscarperpinan.github.io/esf/">https://oscarperpinan.github.io/esf/</a>)
</p>
</li>
<li>
<p> Perpiñán, O. (2012), "solaR: Solar Radiation and Photovoltaic
Systems with R", Journal of Statistical Software, 50(9), 1-32,
<a href="https://doi.org/10.18637/jss.v050.i09">doi:10.18637/jss.v050.i09</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>fProd</code>,
<code>calcGef</code>,
<code>calcShd</code>,
<code>calcG0</code>,
<code>compare</code>,
<code>compareLosses</code>,
<code>mergesolaR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(lattice)
library(latticeExtra)

lat &lt;- 37.2;

G0dm &lt;- c(2766, 3491, 4494, 5912, 6989, 7742, 7919, 7027, 5369, 3562,
          2814, 2179)

Ta &lt;- c(10, 14.1, 15.6, 17.2, 19.3, 21.2, 28.4, 29.9, 24.3, 18.2,
        17.2, 15.2)

prom &lt;- list(G0dm = G0dm, Ta = Ta)

###Comparison of different tracker methods
prodFixed &lt;- prodGCPV(lat = lat, dataRad = prom,
                      keep.night = FALSE)

prod2x &lt;- prodGCPV(lat = lat, dataRad = prom,
                   modeTrk = 'two',
                   keep.night = FALSE)

prodHoriz &lt;- prodGCPV(lat = lat,dataRad = prom,
                      modeTrk = 'horiz',
                      keep.night = FALSE)

##Comparison of yearly productivities
compare(prodFixed, prod2x, prodHoriz)
compareLosses(prodFixed, prod2x, prodHoriz)

##Comparison of power time series
ComparePac &lt;- data.table(Dates = indexI(prod2x),
                         two = as.data.tableI(prod2x)$Pac,
                         horiz = as.data.tableI(prodHoriz)$Pac,
                         fixed = as.data.tableI(prodFixed)$Pac)

AngSol &lt;- as.data.tableI(as(prodFixed, 'Sol'))

ComparePac &lt;- merge(AngSol, ComparePac, by = 'Dates')

ComparePac[, Month := as.factor(month(Dates))]

xyplot(two + horiz + fixed ~ AzS|Month, data = ComparePac,
       type = 'l',
       auto.key = list(space = 'right',
                     lines = TRUE,
                     points = FALSE),
       ylab = 'Pac')



###Shadows
#Two-axis trackers
struct2x &lt;- list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 8)
dist2x &lt;- data.table(Lew = 40, Lns = 30, H = 0)
prod2xShd &lt;- prodGCPV(lat = lat, dataRad = prom,
                      modeTrk = 'two',
                      modeShd = 'area',
                      struct = struct2x,
                      distances = dist2x)
print(prod2xShd)

#Horizontal N-S tracker
structHoriz &lt;- list(L = 4.83);
distHoriz &lt;- data.table(Lew = structHoriz$L*4);

#Without Backtracking
prodHorizShd &lt;- prodGCPV(lat = lat, dataRad = prom,
                         sample = '10 min',
                         modeTrk = 'horiz',
                         modeShd = 'area', betaLim = 60,
                         distances = distHoriz,
                         struct = structHoriz)
print(prodHorizShd)

xyplot(r2d(Beta)~r2d(w),
       data = prodHorizShd,
       type = 'l',
       main = 'Inclination angle of a horizontal axis tracker',
       xlab = expression(omega (degrees)),
       ylab = expression(beta (degrees)))

#With Backtracking
prodHorizBT &lt;- prodGCPV(lat = lat, dataRad = prom,
                        sample = '10 min',
                        modeTrk = 'horiz',
                        modeShd = 'bt', betaLim = 60,
                        distances = distHoriz,
                        struct = structHoriz)

print(prodHorizBT)

xyplot(r2d(Beta)~r2d(w),
       data = prodHorizBT,
       type = 'l',
       main = 'Inclination angle of a horizontal axis tracker\n with backtracking',
       xlab = expression(omega (degrees)),
       ylab = expression(beta (degrees)))

compare(prodFixed, prod2x, prodHoriz, prod2xShd,
        prodHorizShd, prodHorizBT)

compareLosses(prodFixed, prod2x, prodHoriz, prod2xShd,
              prodHorizShd, prodHorizBT)

compareYf2 &lt;- mergesolaR(prodFixed, prod2x, prodHoriz, prod2xShd,
                         prodHorizShd, prodHorizBT)

xyplot(prodFixed + prod2x +prodHoriz + prod2xShd + prodHorizShd + prodHorizBT ~ Dates,
       data = compareYf2, type = 'l', ylab = 'kWh/kWp',
       main = 'Daily productivity',
       auto.key = list(space = 'right'))

</code></pre>


</div>