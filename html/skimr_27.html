<div class="container">

<table style="width: 100%;"><tr>
<td>get_skimmers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Retrieve the summary functions for a specific data type</h2>

<h3>Description</h3>

<p>These functions are used to set the default skimming functions for a data
type. They are combined with the base skim function list (<code>sfl</code>) in
<code>skim_with()</code>, to create the summary tibble for each type.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_skimmers(column)

## Default S3 method:
get_skimmers(column)

## S3 method for class 'numeric'
get_skimmers(column)

## S3 method for class 'factor'
get_skimmers(column)

## S3 method for class 'character'
get_skimmers(column)

## S3 method for class 'logical'
get_skimmers(column)

## S3 method for class 'complex'
get_skimmers(column)

## S3 method for class 'Date'
get_skimmers(column)

## S3 method for class 'POSIXct'
get_skimmers(column)

## S3 method for class 'difftime'
get_skimmers(column)

## S3 method for class 'Timespan'
get_skimmers(column)

## S3 method for class 'ts'
get_skimmers(column)

## S3 method for class 'list'
get_skimmers(column)

## S3 method for class 'AsIs'
get_skimmers(column)

## S3 method for class 'haven_labelled'
get_skimmers(column)

modify_default_skimmers(skim_type, new_skim_type = NULL, new_funs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>column</code></td>
<td>
<p>An atomic vector or list. A column from a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skim_type</code></td>
<td>
<p>A character scalar. The class of the object with default
skimmers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_skim_type</code></td>
<td>
<p>The type to assign to the looked up set of skimmers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_funs</code></td>
<td>
<p>Replacement functions for those in</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When creating your own set of skimming functions, call <code>sfl()</code> within a
<code>get_skimmers()</code> method for your particular type. Your call to <code>sfl()</code> should
also provide a matching class in the <code>skim_type</code> argument.  Otherwise, it
will not be possible to dynamically reassign your default functions when
working interactively.
</p>
<p>Call <code>get_default_skimmers()</code> to see the functions for each type of summary
function currently supported. Call <code>get_default_skimmer_names()</code> to just see
the names of these functions. Use <code>modify_default_skimmers()</code> for a method
for changing the <code>skim_type</code> or functions for a default <code>sfl</code>. This is useful
for creating new default <code>sfl</code>'s.
</p>


<h3>Value</h3>

<p>A <code>skim_function_list</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>get_skimmers(default)</code>: The default method for skimming data. Only used when
a column's data type doesn't match currently installed types. Call
get_default_skimmer_names to see these defaults.
</p>
</li>
<li> <p><code>get_skimmers(numeric)</code>: Summary functions for numeric columns, covering both
<code>double()</code> and <code>integer()</code> classes: <code>mean()</code>, <code>sd()</code>, <code>quantile()</code> and
<code>inline_hist()</code>.
</p>
</li>
<li> <p><code>get_skimmers(factor)</code>: Summary functions for factor columns:
<code>is.ordered()</code>, <code>n_unique()</code> and <code>top_counts()</code>.
</p>
</li>
<li> <p><code>get_skimmers(character)</code>: Summary functions for character columns. Also, the
default for unknown columns: <code>min_char()</code>, <code>max_char()</code>, <code>n_empty()</code>,
<code>n_unique()</code> and <code>n_whitespace()</code>.
</p>
</li>
<li> <p><code>get_skimmers(logical)</code>: Summary functions for logical/ boolean columns:
<code>mean()</code>, which produces rates for each value, and <code>top_counts()</code>.
</p>
</li>
<li> <p><code>get_skimmers(complex)</code>: Summary functions for complex columns: <code>mean()</code>.
</p>
</li>
<li> <p><code>get_skimmers(Date)</code>: Summary functions for <code>Date</code> columns: <code>min()</code>,
<code>max()</code>, <code>median()</code> and <code>n_unique()</code>.
</p>
</li>
<li> <p><code>get_skimmers(POSIXct)</code>: Summary functions for <code>POSIXct</code> columns: <code>min()</code>,
<code>max()</code>, <code>median()</code> and <code>n_unique()</code>.
</p>
</li>
<li> <p><code>get_skimmers(difftime)</code>: Summary functions for <code>difftime</code> columns: <code>min()</code>,
<code>max()</code>, <code>median()</code> and <code>n_unique()</code>.
</p>
</li>
<li> <p><code>get_skimmers(Timespan)</code>: Summary functions for <code>Timespan</code> columns: <code>min()</code>,
<code>max()</code>, <code>median()</code> and <code>n_unique()</code>.
</p>
</li>
<li> <p><code>get_skimmers(ts)</code>: Summary functions for <code>ts</code> columns: <code>min()</code>,
<code>max()</code>, <code>median()</code> and <code>n_unique()</code>.
</p>
</li>
<li> <p><code>get_skimmers(list)</code>: Summary functions for <code>list</code> columns: <code>n_unique()</code>,
<code>list_min_length()</code> and <code>list_max_length()</code>.
</p>
</li>
<li> <p><code>get_skimmers(AsIs)</code>: Summary functions for <code>AsIs</code> columns: <code>n_unique()</code>,
<code>list_min_length()</code> and <code>list_max_length()</code>.
</p>
</li>
<li> <p><code>get_skimmers(haven_labelled)</code>: Summary functions for <code>haven_labelled</code> columns.
Finds the appropriate skimmers for the underlying data in the vector.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>sfl()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Defining default skimming functions for a new class, `my_class`.
# Note that the class argument is required for dynamic reassignment.
get_skimmers.my_class &lt;- function(column) {
  sfl(
    skim_type = "my_class",
    mean,
    sd
  )
}

# Integer and double columns are both "numeric" and are treated the same
# by default. To switch this behavior in another package, add a method.
get_skimmers.integer &lt;- function(column) {
  sfl(
    skim_type = "integer",
    p50 = ~ stats::quantile(
      .,
      probs = .50, na.rm = TRUE, names = FALSE, type = 1
    )
  )
}
x &lt;- mtcars[c("gear", "carb")]
class(x$carb) &lt;- "integer"
skim(x)
## Not run: 
# In a package, to revert to the V1 behavior of skimming separately with the
# same functions, assign the numeric `get_skimmers`.
get_skimmers.integer &lt;- skimr::get_skimmers.numeric

# Or, in a local session, use `skim_with` to create a different `skim`.
new_skim &lt;- skim_with(integer = skimr::get_skimmers.numeric())

# To apply a set of skimmers from an old type to a new type
get_skimmers.new_type &lt;- function(column) {
  modify_default_skimmers("old_type", new_skim_type = "new_type")
}

## End(Not run)
</code></pre>


</div>