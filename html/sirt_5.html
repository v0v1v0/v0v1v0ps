<div class="container">

<table style="width: 100%;"><tr>
<td>rasch.copula2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multidimensional IRT Copula Model
</h2>

<h3>Description</h3>

<p>This function handles local dependence by specifying
copulas for residuals in multidimensional item response
models for dichotomous item responses
(Braeken, 2011; Braeken, Tuerlinckx &amp; de Boeck, 2007;
Schroeders, Robitzsch &amp; Schipolowski, 2014).
Estimation is allowed for item difficulties, item slopes and
a generalized logistic link function (Stukel, 1988).
</p>
<p>The function <code>rasch.copula3</code> allows the estimation of multidimensional
models while <code>rasch.copula2</code> only handles unidimensional models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rasch.copula2(dat, itemcluster, weights=NULL, copula.type="bound.mixt",
    progress=TRUE, mmliter=1000, delta=NULL,
    theta.k=seq(-4, 4, len=21), alpha1=0, alpha2=0,
    numdiff.parm=1e-06,  est.b=seq(1, ncol(dat)),
    est.a=rep(1, ncol(dat)), est.delta=NULL, b.init=NULL, a.init=NULL,
    est.alpha=FALSE, glob.conv=0.0001, alpha.conv=1e-04, conv1=0.001,
    dev.crit=.2, increment.factor=1.01)

rasch.copula3(dat, itemcluster, dims=NULL, copula.type="bound.mixt",
    progress=TRUE, mmliter=1000, delta=NULL,
    theta.k=seq(-4, 4, len=21), alpha1=0, alpha2=0,
    numdiff.parm=1e-06,  est.b=seq(1, ncol(dat)),
    est.a=rep(1, ncol(dat)), est.delta=NULL, b.init=NULL, a.init=NULL,
    est.alpha=FALSE, glob.conv=0.0001, alpha.conv=1e-04, conv1=0.001,
    dev.crit=.2, rho.init=.5, increment.factor=1.01)

## S3 method for class 'rasch.copula2'
summary(object, file=NULL, digits=3, ...)
## S3 method for class 'rasch.copula3'
summary(object, file=NULL, digits=3, ...)

## S3 method for class 'rasch.copula2'
anova(object,...)
## S3 method for class 'rasch.copula3'
anova(object,...)

## S3 method for class 'rasch.copula2'
logLik(object,...)
## S3 method for class 'rasch.copula3'
logLik(object,...)

## S3 method for class 'rasch.copula2'
IRT.likelihood(object,...)
## S3 method for class 'rasch.copula3'
IRT.likelihood(object,...)

## S3 method for class 'rasch.copula2'
IRT.posterior(object,...)
## S3 method for class 'rasch.copula3'
IRT.posterior(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>An <code class="reqn">N \times I</code> data frame. Cases with only missing responses
are removed from the analysis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemcluster</code></td>
<td>

<p>An integer vector of length <code class="reqn">I</code> (number of items). Items with
the same integers define a joint item cluster of (positively) locally
dependent items. Values of zero indicate that the corresponding item
is not included in any item cluster of dependent responses.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional vector of sampling weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>

<p>A vector indicating to which dimension an item is allocated.
The default is that all items load on the first dimension.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copula.type</code></td>
<td>

<p>A character or a vector containing one of the following copula
types: <code>bound.mixt</code> (boundary mixture copula),
<code>cook.johnson</code> (Cook-Johnson copula) or <code>frank</code> (Frank copula)
(see Braeken, 2011).
The vector <code>copula.type</code> must match the number of different
itemclusters. For every itemcluster, a different copula type
may be specified (see Examples).
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>Print progress? Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mmliter</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>An optional vector of starting values for the dependency parameter <code>delta</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>

<p>Discretized trait distribution
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>

<p><code>alpha1</code> parameter in the generalized logistic item response model
(Stukel, 1988). The default is 0 which leads together with <code>alpha2=0</code>
to the logistic link function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha2</code></td>
<td>

<p><code>alpha2</code> parameter in the generalized logistic item response model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdiff.parm</code></td>
<td>

<p>Parameter for numerical differentiation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.b</code></td>
<td>

<p>Integer vector of item difficulties to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.a</code></td>
<td>

<p>Integer vector of item discriminations to be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.delta</code></td>
<td>

<p>Integer vector of length <code>length(itemcluster)</code>. Nonzero integers
correspond to <code>delta</code> parameters which are estimated.
Equal integers indicate parameter equality constraints.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.init</code></td>
<td>

<p>Initial <code class="reqn">b</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.init</code></td>
<td>

<p>Initial <code class="reqn">a</code> parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.alpha</code></td>
<td>

<p>Should both alpha parameters be estimated? Default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.conv</code></td>
<td>

<p>Convergence criterion for all parameters
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.conv</code></td>
<td>

<p>Maximal change in alpha parameters for convergence
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv1</code></td>
<td>

<p>Maximal change in item parameters for convergence
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.crit</code></td>
<td>

<p>Maximal change in the deviance. Default is <code>.2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho.init</code></td>
<td>
<p>Initial value for off-diagonal elements in correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>increment.factor</code></td>
<td>
<p>A numeric value larger than one which controls the
size of increments in iterations. To stabilize convergence,
choose values 1.05 or 1.1 in some situations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>rasch.copula2</code> or <code>rasch.copula3</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optional file name for <code>summary</code> output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits after decimal in <code>summary</code> output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>N.itemclusters</code></td>
<td>
<p>Number of item clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>Estimated item parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Estimated dependency parameters <code class="reqn">\delta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Estimated item difficulties</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Estimated item slopes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Standard deviation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>
<p>Parameter <code class="reqn">\alpha_1</code> in the generalized item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha2</code></td>
<td>
<p>Parameter <code class="reqn">\alpha_2</code> in the generalized item response model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.k</code></td>
<td>
<p>Discretized ability distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.k</code></td>
<td>
<p>Fixed <code class="reqn">\theta</code> distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>Item response patterns with frequencies and posterior
distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>Data frame with person parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datalist</code></td>
<td>
<p>List of generated data frames during estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EAP.rel</code></td>
<td>
<p>Reliability of the EAP</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copula.type</code></td>
<td>
<p>Type of copula</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary.delta</code></td>
<td>
<p>Summary for estimated <code class="reqn">\delta</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.qk.yi</code></td>
<td>
<p>Individual posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.yi.qk</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further values</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Braeken, J. (2011). A boundary mixture approach to violations of conditional
independence. <em>Psychometrika, 76</em>(1), 57-76.
<a href="https://doi.org/10.1007/s11336-010-9190-4">doi:10.1007/s11336-010-9190-4</a>
</p>
<p>Braeken, J., Kuppens, P., De Boeck, P., &amp; Tuerlinckx, F. (2013).
Contextualized personality questionnaires: A case for copulas in structural
equation models for categorical data. <em>Multivariate Behavioral Research, 48</em>(6),
845-870.
<a href="https://doi.org/10.1080/00273171.2013.827965">doi:10.1080/00273171.2013.827965</a>
</p>
<p>Braeken, J., &amp; Tuerlinckx, F. (2009). Investigating latent constructs with item
response models: A MATLAB IRTm toolbox.
<em>Behavior Research Methods, 41</em>(4), 1127-1137.
</p>
<p>Braeken, J., Tuerlinckx, F., &amp; De Boeck, P. (2007).
Copula functions for residual dependency. <em>Psychometrika, 72</em>(3), 393-411.
<a href="https://doi.org/10.1007/s11336-007-9005-4">doi:10.1007/s11336-007-9005-4</a>
</p>
<p>Schroeders, U., Robitzsch, A., &amp; Schipolowski, S. (2014). A comparison of different
psychometric approaches to modeling testlet structures: An example with C-tests.
<em>Journal of Educational Measurement, 51</em>(4), 400-418.
<a href="https://doi.org/10.1111/jedm.12054">doi:10.1111/jedm.12054</a>
</p>
<p>Stukel, T. A. (1988). Generalized logistic models.
<em>Journal of the American Statistical Association, 83</em>(402), 426-431.
<a href="https://doi.org/10.1080/01621459.1988.10478613">doi:10.1080/01621459.1988.10478613</a>
</p>


<h3>See Also</h3>

<p>For a summary see <code>summary.rasch.copula2</code>.
</p>
<p>For simulating locally dependent item responses see <code>sim.rasch.dep</code>.
</p>
<p>Person parameters estimates are obtained by <code>person.parameter.rasch.copula</code>.
</p>
<p>See <code>rasch.mml2</code> for the generalized logistic link function.
</p>
<p>See also Braeken and Tuerlinckx (2009) for alternative (and more expanded)
copula models implemented in the MATLAB software. See
<a href="https://ppw.kuleuven.be/okp/software/irtm/">https://ppw.kuleuven.be/okp/software/irtm/</a>.
</p>
<p>See Braeken, Kuppens, De Boeck and Tuerlinckx (2013) for an extension of the
copula modeling approach to polytomous data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Reading Data
#############################################################################

data(data.read)
dat &lt;- data.read

# define item clusters
itemcluster &lt;- rep( 1:3, each=4 )

# estimate Copula model
mod1 &lt;- sirt::rasch.copula2( dat=dat, itemcluster=itemcluster)

## Not run: 
# estimate Rasch model
mod2 &lt;- sirt::rasch.copula2( dat=dat, itemcluster=itemcluster,
        delta=rep(0,3), est.delta=rep(0,3) )
summary(mod1)
summary(mod2)

# estimate copula 2PL model
I &lt;- ncol(dat)
mod3 &lt;- sirt::rasch.copula2( dat=dat, itemcluster=itemcluster, est.a=1:I,
                increment.factor=1.05)
summary(mod3)

#############################################################################
# EXAMPLE 2: 11 items nested within 2 item clusters (testlets)
#    with 2 resp. 3 dependent and 6 independent items
#############################################################################

set.seed(5698)
I &lt;- 11                             # number of items
n &lt;- 3000                           # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
theta &lt;- stats::rnorm( n, sd=1 ) # person abilities
# define item clusters
itemcluster &lt;- rep(0,I)
itemcluster[ c(3,5 )] &lt;- 1
itemcluster[c(2,4,9)] &lt;- 2
# residual correlations
rho &lt;- c( .7, .5 )

# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("I", seq(1,ncol(dat)), sep="")

# estimate Rasch copula model
mod1 &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster )
summary(mod1)

# both item clusters have Cook-Johnson copula as dependency
mod1c &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster,
            copula.type="cook.johnson")
summary(mod1c)

# first item boundary mixture and second item Cook-Johnson copula
mod1d &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster,
            copula.type=c( "bound.mixt", "cook.johnson" ) )
summary(mod1d)

# compare result with Rasch model estimation in rasch.copula2
# delta must be set to zero
mod2 &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster, delta=c(0,0),
            est.delta=c(0,0) )
summary(mod2)

#############################################################################
# EXAMPLE 3: 12 items nested within 3 item clusters (testlets)
#   Cluster 1 -&gt; Items 1-4; Cluster 2 -&gt; Items 6-9;  Cluster 3 -&gt; Items 10-12
#############################################################################

set.seed(967)
I &lt;- 12                             # number of items
n &lt;- 450                            # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
b &lt;- sample(b)                      # sample item difficulties
theta &lt;- stats::rnorm( n, sd=1 ) # person abilities
# itemcluster
itemcluster &lt;- rep(0,I)
itemcluster[ 1:4 ] &lt;- 1
itemcluster[ 6:9 ] &lt;- 2
itemcluster[ 10:12 ] &lt;- 3
# residual correlations
rho &lt;- c( .35, .25, .30 )

# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("I", seq(1,ncol(dat)), sep="")

# estimate Rasch copula model
mod1 &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster )
summary(mod1)

# person parameter estimation assuming the Rasch copula model
pmod1 &lt;- sirt::person.parameter.rasch.copula(raschcopula.object=mod1 )

# Rasch model estimation
mod2 &lt;- sirt::rasch.copula2( dat, itemcluster=itemcluster,
             delta=rep(0,3), est.delta=rep(0,3) )
summary(mod1)
summary(mod2)

#############################################################################
# EXAMPLE 4: Two-dimensional copula model
#############################################################################

set.seed(5698)
I &lt;- 9
n &lt;- 1500                           # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
theta0 &lt;- stats::rnorm( n, sd=sqrt( .6 ) )

#*** Dimension 1
theta &lt;- theta0 + stats::rnorm( n, sd=sqrt( .4 ) )   # person abilities
# itemcluster
itemcluster &lt;- rep(0,I)
itemcluster[ c(3,5 )] &lt;- 1
itemcluster[c(2,4,9)] &lt;- 2
itemcluster1 &lt;- itemcluster
# residual correlations
rho &lt;- c( .7, .5 )
# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("A", seq(1,ncol(dat)), sep="")
dat1 &lt;- dat
# estimate model of dimension 1
mod0a &lt;- sirt::rasch.copula2( dat1, itemcluster=itemcluster1)
summary(mod0a)

#*** Dimension 2
theta &lt;- theta0 + stats::rnorm( n, sd=sqrt( .8 ) )        # person abilities
# itemcluster
itemcluster &lt;- rep(0,I)
itemcluster[ c(3,7,8 )] &lt;- 1
itemcluster[c(4,6)] &lt;- 2
itemcluster2 &lt;- itemcluster
# residual correlations
rho &lt;- c( .2, .4 )
# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("B", seq(1,ncol(dat)), sep="")
dat2 &lt;- dat
# estimate model of dimension 2
mod0b &lt;- sirt::rasch.copula2( dat2, itemcluster=itemcluster2)
summary(mod0b)

# both dimensions
dat &lt;- cbind( dat1, dat2 )
itemcluster2 &lt;- ifelse( itemcluster2 &gt; 0, itemcluster2 + 2, 0 )
itemcluster &lt;- c( itemcluster1, itemcluster2 )
dims &lt;- rep( 1:2, each=I)

# estimate two-dimensional copula model
mod1 &lt;- sirt::rasch.copula3( dat, itemcluster=itemcluster, dims=dims, est.a=dims,
            theta.k=seq(-5,5,len=15) )
summary(mod1)

#############################################################################
# EXAMPLE 5: Subset of data Example 2
#############################################################################

set.seed(5698)
I &lt;- 11                             # number of items
n &lt;- 3000                           # number of persons
b &lt;- seq(-2,2, len=I)               # item difficulties
theta &lt;- stats::rnorm( n, sd=1.3 )  # person abilities
# define item clusters
itemcluster &lt;- rep(0,I)
itemcluster[ c(3,5)] &lt;- 1
itemcluster[c(2,4,9)] &lt;- 2
# residual correlations
rho &lt;- c( .7, .5 )
# simulate data
dat &lt;- sirt::sim.rasch.dep( theta, b, itemcluster, rho )
colnames(dat) &lt;- paste("I", seq(1,ncol(dat)), sep="")

# select subdataset with only one dependent item cluster
item.sel &lt;- scan( what="character", nlines=1 )
    I1 I6 I7 I8 I10 I11 I3 I5
dat1 &lt;- dat[,item.sel]

#******************
#*** Model 1a: estimate Copula model in sirt
itemcluster &lt;- rep(0,8)
itemcluster[c(7,8)] &lt;- 1
mod1a &lt;- sirt::rasch.copula2( dat3, itemcluster=itemcluster )
summary(mod1a)

#******************
#*** Model 1b: estimate Copula model in mirt
library(mirt)
#*** redefine dataset for estimation in mirt
dat2 &lt;- dat1[, itemcluster==0 ]
dat2 &lt;- as.data.frame(dat2)
# combine items 3 and 5
dat2$C35 &lt;- dat1[,"I3"] + 2*dat1[,"I5"]
table( dat2$C35, paste0( dat1[,"I3"],dat1[,"I5"]) )
#* define mirt model
mirtmodel &lt;- mirt::mirt.model("
      F=1-7
      CONSTRAIN=(1-7,a1)
      " )
#-- Copula function with two dependent items
# define item category function for pseudo-items like C35
P.copula2 &lt;- function(par,Theta, ncat){
     b1 &lt;- par[1]
     b2 &lt;- par[2]
     a1 &lt;- par[3]
     ldelta &lt;- par[4]
     P1 &lt;- stats::plogis( a1*(Theta - b1 ) )
     P2 &lt;- stats::plogis( a1*(Theta - b2 ) )
     Q1 &lt;- 1-P1
     Q2 &lt;- 1-P2
     # define vector-wise minimum function
     minf2 &lt;- function( x1, x2 ){
         ifelse( x1 &lt; x2, x1, x2 )
                                }
     # distribution under independence
     F00 &lt;- Q1*Q2
     F10 &lt;- Q1*Q2 + P1*Q2
     F01 &lt;- Q1*Q2 + Q1*P2
     F11 &lt;- 1+0*Q1
     F_ind &lt;- c(F00,F10,F01,F11)
     # distribution under maximal dependence
     F00 &lt;- minf2(Q1,Q2)
     F10 &lt;- Q2              #=minf2(1,Q2)
     F01 &lt;- Q1              #=minf2(Q1,1)
     F11 &lt;- 1+0*Q1          #=minf2(1,1)
     F_dep &lt;- c(F00,F10,F01,F11)
     # compute mixture distribution
     delta &lt;- stats::plogis(ldelta)
     F_tot &lt;- (1-delta)*F_ind + delta * F_dep
     # recalculate probabilities of mixture distribution
     L1 &lt;- length(Q1)
     v1 &lt;- 1:L1
     F00 &lt;- F_tot[v1]
     F10 &lt;- F_tot[v1+L1]
     F01 &lt;- F_tot[v1+2*L1]
     F11 &lt;- F_tot[v1+3*L1]
     P00 &lt;- F00
     P10 &lt;- F10 - F00
     P01 &lt;- F01 - F00
     P11 &lt;- 1 - F10 - F01 + F00
     prob_tot &lt;- c( P00, P10, P01, P11 )
     return(prob_tot)
        }
# create item
copula2 &lt;- mirt::createItem(name="copula2", par=c(b1=0, b2=0.2, a1=1, ldelta=0),
                est=c(TRUE,TRUE,TRUE,TRUE), P=P.copula2,
                lbound=c(-Inf,-Inf,0,-Inf), ubound=c(Inf,Inf,Inf,Inf) )
# define item types
itemtype &lt;- c( rep("2PL",6), "copula2" )
customItems &lt;- list("copula2"=copula2)
# parameter table
mod.pars &lt;- mirt::mirt(dat2, 1, itemtype=itemtype,
                customItems=customItems, pars='values')
# estimate model
mod1b &lt;- mirt::mirt(dat2, mirtmodel, itemtype=itemtype, customItems=customItems,
                verbose=TRUE, pars=mod.pars,
                technical=list(customTheta=as.matrix(seq(-4,4,len=21)) ) )
# estimated coefficients
cmod &lt;- sirt::mirt.wrapper.coef(mod)$coef

# compare common item discrimination
round( c("sirt"=mod1a$item$a[1], "mirt"=cmod$a1[1] ), 4 )
  ##     sirt   mirt
  ##   1.2845 1.2862
# compare delta parameter
round( c("sirt"=mod1a$item$delta[7], "mirt"=stats::plogis( cmod$ldelta[7] ) ), 4 )
  ##     sirt   mirt
  ##   0.6298 0.6297
# compare thresholds a*b
dfr &lt;- cbind( "sirt"=mod1a$item$thresh,
               "mirt"=c(- cmod$d[-7],cmod$b1[7]*cmod$a1[1], cmod$b2[7]*cmod$a1[1]))
round(dfr,4)
  ##           sirt    mirt
  ##   [1,] -1.9236 -1.9231
  ##   [2,] -0.0565 -0.0562
  ##   [3,]  0.3993  0.3996
  ##   [4,]  0.8058  0.8061
  ##   [5,]  1.5293  1.5295
  ##   [6,]  1.9569  1.9572
  ##   [7,] -1.1414 -1.1404
  ##   [8,] -0.4005 -0.3996

## End(Not run)
</code></pre>


</div>