<div class="container">

<table style="width: 100%;"><tr>
<td>solve_chol</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve Systems of Equations Using Direct Methods</h2>

<h3>Description</h3>

<p>Direct solvers using Cholesky, LU, or QR decompositions for systems of
equations <code class="reqn">Ax = b</code>. Dense or sparse methods are used depending
on the format of the input matrix (see <code>sparsify</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">solve_chol(a, b, pivot = 1L, ordering = 0L)

solve_lu(a, b, pivot = 1L, ordering = 1L)

solve_qr(a, b, pivot = 1L, ordering = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Square numeric matrix with the coefficients of the linear system.
Both dense and sparse matrices are supported (see <code>sparsify</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Numeric vector or matrix at the right-hand side of the linear
system. If missing, 'b' is set to an identity matrix and 'a' is
inverted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pivot</code></td>
<td>
<p>Integer scalar indicating the pivoting scheme to be used.
Defaults to partial pivoting. See the Details for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordering</code></td>
<td>
<p>Integer scalar indicating the ordering scheme to be used.
See the Details for further information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Pivoting schemes for dense matrices can be set to <code>0</code> for no pivoting,
<code>1</code> (default) for partial pivoting, or <code>2</code> for full pivoting. Not
all schemes are available for every decomposition:
</p>
<p>* <code>solve_chol()</code> The default is <code>pivot = 1</code> for the robust LDLT
decomposition of <code class="reqn">A</code>, such that <code class="reqn">A = P'LDL^*P</code>. For
the LDLT <code class="reqn">A</code> needs to be positive or negative semidefinite. Set
<code>pivot = 0</code> for the plain LLT decomposition of <code class="reqn">A</code>, such that
<code class="reqn">A = LL^* = U^*U</code>. For the LLT <code class="reqn">A</code> needs to be
positive definite and preferably numerically stable.
* <code>solve_lu()</code> The default is <code>pivot = 1</code> for the partial pivoting
LU decomposition of <code class="reqn">A</code>, such that <code class="reqn">A = PLU</code>. For this
scheme <code class="reqn">A</code> needs to be invertible and preferably numerically stable. Set
<code>pivot = 2</code> for the complete pivoting LU decomposition of <code class="reqn">A</code>,
such that <code class="reqn">A = P^{-1}LUQ^{-1}</code>. This scheme is applicable to
square matrices, rank-revealing, and stable.
<code>solve_qr()</code> The default is <code>pivot = 1</code> for the column pivoting
Householder QR decomposition of <code class="reqn">A</code>, such that <code class="reqn">AP = QR</code>.
This scheme is generally applicable, rank-revealing, and stable. Set
<code>pivot = 2</code> for the full pivoting Householder QR decomposition of
<code class="reqn">A</code>, such that <code class="reqn">PAP' = QR</code>. This scheme is generally
applicable, rank-revealing, and optimally stable. Set <code>pivot = 0</code> for
an unpivoted Householder QR decomposition of <code class="reqn">A</code>, such that
<code class="reqn">A = QR</code>. This scheme is generally applicable, but not as stable
as pivoted variants.
</p>
<p>Ordering schemes for sparse matrices can be set to <code>0</code> for approximate
minimum degree (AMD) ordering, <code>1</code> for column approximate minimum degree
(COLAMD) ordering, or <code>2</code> for natural ordering. Not all orderings are
available for every decomposition:
</p>
<p>* <code>solve_chol()</code> The default is <code>ordering = 0</code> for AMD ordering.
Set <code>ordering = 2</code> for natural ordering.
* <code>solve_lu()</code> The default is <code>ordering = 1</code> for COLAMD ordering.
Set <code>ordering = 0</code> for AMD or <code>ordering = 2</code> for natural ordering.
* <code>solve_qr()</code> The default is <code>ordering = 1</code> for COLAMD ordering.
Set <code>ordering = 0</code> for AMD or <code>ordering = 2</code> for natural ordering.
</p>


<h3>Value</h3>

<p>Solves for <code class="reqn">x</code> and returns a numeric matrix with the results.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)
x &lt;- rnorm(3)

# Solve via QR for general matrices
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
b &lt;- A %*% x
norm(solve_qr(A, b) - x)

# Solve via LU for square matrices
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
b &lt;- A %*% x
norm(solve_lu(A, b) - x)

# Solve via Cholesky for symmetric matrices
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_chol(A, b) - x)

# Sparse methods are available for the 'dgCMatrix' class from Matrix
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_qr(sparsify(A), b))
norm(solve_lu(sparsify(A), b))
norm(solve_chol(sparsify(A), b))

</code></pre>


</div>