<div class="container">

<table style="width: 100%;"><tr>
<td>intPGOcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for Fitting Single-Species Integrated Occupancy Models Using Polya-Gamma Latent Variables</h2>

<h3>Description</h3>

<p>Function for fitting single-species integrated occupancy models using Polya-Gamma latent variables. Data integration is done using a joint likelihood framework, assuming distinct detection models for each data source that are each conditional on a single latent occurrence process. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">intPGOcc(occ.formula, det.formula, data, inits, priors, n.samples, 
         n.omp.threads = 1, verbose = TRUE, n.report = 1000, 
         n.burn = round(.10 * n.samples), n.thin = 1, n.chains = 1,
         k.fold, k.fold.threads = 1, k.fold.seed, 
         k.fold.data, k.fold.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>occ.formula</code></td>
<td>
<p>a symbolic description of the model to be fit
for the occurrence portion of the model using R's model syntax. Only
right-hand side of formula is specified. See example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>det.formula</code></td>
<td>
<p>a list of symbolic descriptions of the models to be fit
for the detection portion of the model using R's model syntax for 
each data set. Each element in the list is a formula for the detection 
model of a given data set. Only right-hand side of formula is specified. 
See example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing data necessary for model fitting.
Valid tags are <code>y</code>, <code>occ.covs</code>, <code>det.covs</code>, and <code>sites</code>. 
<code>y</code> is a list of matrices or data frames for each data set used in 
the integrated model. Each element of the list has first dimension equal 
to the number of sites with that data source and second dimension equal 
to the maximum number of replicates at a given site. <code>occ.covs</code> is 
a matrix or data frame containing the variables used in the occupancy 
portion of the model, with the number of rows being the number of sites 
with at least one data source for each column (variable). <code>det.covs</code> is a list of
variables included in the detection portion of the model for each data source. 
<code>det.covs</code> should have the same number of elements as <code>y</code>, where
each element is itself a list. Each element of the list for a given data
source is a different detection covariate, which can be site-level or 
observational-level. Site-level covariates are specified as a vector 
with length equal to the number of observed sites of that data source,
while observation-level covariates are specified as a matrix or data frame 
with the number of rows equal to the number of observed sites of that data source
and number of columns equal to the maximum number of replicates at a given site.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inits</code></td>
<td>
<p>a list with each tag corresponding to a parameter name.
Valid tags are <code>z</code>, <code>beta</code>, and <code>alpha</code>. The value portion
of tags <code>z</code> and <code>beta</code> is the parameter's initial value. The tag
<code>alpha</code> is a list comprised of the initial values for the detection 
parameters for each data source. Each element of the list should be a vector of 
initial values for all detection parameters in the given data source or a single value
for each data source to assign all parameters for a given data source
the same initial value. See <code>priors</code> description for definition of 
each parameter name. Additionally, the tag <code>fix</code> can be set to <code>TRUE</code> 
to fix the starting values across all chains. If <code>fix</code> is not specified
(the default), starting values are varied randomly across chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. 
Valid tags are <code>beta.normal</code> and <code>alpha.normal</code>. Occurrence 
(<code>beta</code>) and detection (<code>alpha</code>) regression coefficients 
are assumed to follow a normal distribution. For <code>beta</code> hyperparameters of the 
normal distribution are passed as a list of length two with the first
and second elements corresponding to the mean and variance of the normal
distribution, which are each specified as vectors of 
length equal to the number of coefficients to be estimated or of 
length one if priors are the same for all coefficients. For 
the detection coefficients <code>alpha</code>, the mean and variance 
hyperparameters are themselves passed in as lists, with each element 
of the list corresponding to the specific hyperparameters for the 
detection parameters in a given data source. If not specified, prior means 
are set to 0 and prior variances set to 2.72.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of posterior samples to collect in each chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating the number of threads
to use for SMP parallel processing. The package must be compiled for 
OpenMP support. For most Intel-based machines, we recommend setting 
<code>n.omp.threads</code> up to the number of hypterthreaded cores. Note, 
<code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, messages about data preparation, 
model specification, and progress of the sampler are printed to the screen. 
Otherwise, no messages are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report MCMC progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.burn</code></td>
<td>
<p>the number of samples out of the total <code>n.samples</code> to 
discard as burn-in. By default, the first 10% of samples is discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.thin</code></td>
<td>
<p>the thinning interval for collection of MCMC samples. The
thinning occurs after the <code>n.burn</code> samples are discarded. Default 
value is set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chains</code></td>
<td>
<p>the number of chains to run in sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold</code></td>
<td>
<p>specifies the number of <em>k</em> folds for cross-validation.
If not specified as an argument, then cross-validation is not performed
and <code>k.fold.threads</code> and <code>k.fold.seed</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>data</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em> subsamples,
<em>k</em> - 1 subsamples are used to fit the model and the remaining <em>k</em>
samples are used for prediction. The cross-validation process is repeated
<em>k</em> times (the folds). As a scoring rule, we use the model deviance
as described in Hooten and Hobbs (2015). Cross-validation is performed
after the full model is fit using all the data. Cross-validation results
are reported in the <code>k.fold.deviance</code> object in the return list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.threads</code></td>
<td>
<p>number of threads to use for cross-validation. If
<code>k.fold.threads &gt; 1</code> parallel processing is accomplished using the
<span class="pkg">foreach</span> and <span class="pkg">doParallel</span> packages. Ignored if <code>k.fold</code>
is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.seed</code></td>
<td>
<p>seed used to split data set into <code>k.fold</code> parts
for k-fold cross-validation. Ignored if <code>k.fold</code> is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.data</code></td>
<td>
<p>an integer specifying the specific data set to hold out
values from. If not specified, data from all data set locations will 
be incorporated into the k-fold cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.only</code></td>
<td>
<p>a logical value indicating whether to only perform 
cross-validation (<code>TRUE</code>) or perform cross-validation after fitting 
the full model (<code>FALSE</code>). Default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>intPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the occupancy regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the detection regression coefficients for all data sources.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples 
for the latent occupancy values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples
for the latent occupancy probability values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhat</code></td>
<td>
<p>a list of Gelman-Rubin diagnostic values for some of the model
parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ESS</code></td>
<td>
<p>a list of effective sample sizes for some of the model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.fold.deviance</code></td>
<td>
<p>scoring rule (deviance) from k-fold cross-validation. A 
separate deviance value is returned for each data source. Only included if 
<code>k.fold</code> is specified in function call. Only a single value is returned
if <code>k.fold.data</code> is specified.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for 
subsequent prediction and/or model fit evaluation. Note that detection
probability estimated values are not included in the model object, but can be 
extracted using <code>fitted()</code>.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random numbers from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br>
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. 
<em>Journal of the American Statistical Association</em>, 108:1339-1349.
</p>
<p>Hooten, M. B., and Hobbs, N. T. (2015). A guide to Bayesian model 
selection for ecologists. Ecological monographs, 85(1), 3-28.
</p>
<p>Finley, A. O., Datta, A., and Banerjee, S. (2020). spNNGP R 
package for nearest neighbor Gaussian process models. 
arXiv preprint arXiv:2001.09111.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1008)

# Simulate Data -----------------------------------------------------------
J.x &lt;- 15
J.y &lt;- 15
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 1)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
for (i in 1:n.data) {
  alpha[[i]] &lt;- runif(2, -1, 1)
}
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = FALSE)

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2]) 
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2]) 
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2]) 
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2]) 
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites)

J &lt;- length(dat$z.obs)
# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)))
n.samples &lt;- 5000
out &lt;- intPGOcc(occ.formula = ~ occ.cov, 
                det.formula = list(f.1 = ~ det.cov.1.1, 
                                   f.2 = ~ det.cov.2.1, 
                                   f.3 = ~ det.cov.3.1, 
                                   f.4 = ~ det.cov.4.1), 
                data = data.list,
                inits = inits.list,
                n.samples = n.samples, 
                priors = prior.list, 
                n.omp.threads = 1, 
                verbose = TRUE, 
                n.report = 1000, 
                n.burn = 1000, 
                n.thin = 1, 
                n.chains = 1)

summary(out)
</code></pre>


</div>