<div class="container">

<table style="width: 100%;"><tr>
<td>standardize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standardize a formula and data frame for regression.</h2>

<h3>Description</h3>

<p>Create a <code>standardized</code> object which places
all variables in <code>data</code> on the same scale based on <code>formula</code>,
making regression output easier to interpret.
For mixed effects regressions, this also offers computational benefits, and
for Bayesian regressions, it also makes determining reasonable priors easier.
</p>


<h3>Usage</h3>

<pre><code class="language-R">standardize(formula, data, family = gaussian, scale = 1, offset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A regression <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing the variables in <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A regression <code>family</code> (default gaussian).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>The desired scale for the regression frame. Must be a single
positive number. See 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>An optional <code>offset</code> vector. Offsets can
also be included in the <code>formula</code> (e.g. <code>y ~ x + offset(o)</code>), but
if this is done, then the column <code>o</code> (in this example) must be in any
data frame passed as the <code>newdata</code> argument to
<code>predict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently unused.  If <code>na.action</code> is specified in <code>...</code>
and is anything other than <code>na.pass</code>, a warning is issued and the argument
argument is ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First <code>model.frame</code> is called. Then,
if <code>family = gaussian</code>, the response is checked to ensure that it is
numeric and has more than two unique values.  If <code>scale_by</code> is
used on the response in <code>formula</code>, then the <code>scale</code> argument to
<code>scale_by</code> is ignored and forced to <code>1</code>.  If <code>scale_by</code>
is not called, then <code>scale</code> is used with default arguments.
The result is that gaussian responses are on unit scale (i.e. have mean
<code>0</code> and standard deviation <code>1</code>), or, if <code>scale_by</code> is
used on the left hand side of <code>formula</code>, unit scale within each
level of the specified conditioning factor.
Offsets in gaussian models are divided by the standard deviation of the
the response prior to scaling (within-factor-level if <code>scale_by</code>
is used on the response).  In this way, if the transformed offset is added
to the transformed response, and then placed back on the response's original
scale, the result would be the same as if the un-transformed offset had
been added to the un-transformed response.
For all other values for <code>family</code>, the response and offsets are not checked.
If offsets are used within the <code>formula</code>, then they will be in the
<code>formula</code> and <code>data</code> elements of the <code>standardized</code>
object.  If the <code>offset</code> argument to the <code>standardize</code> function is
used, then the offset provided in the argument will be
in the <code>offset</code> element of the <code>standardized</code> object
(scaled if <code>family = gaussian</code>).
</p>
<p>For the other predictors in the formula, first any random effects grouping factors
in the formula are coerced to factor and unused levels are dropped.  The
levels of the resulting factor are then recorded in the <code>groups</code> element.
Then for the remaining predictors, regardless of their original
class, if they have only two unique non-<code>NA</code> values, they are coerced
to unordered factors.  Then, <code>named_contr_sum</code> and
<code>scaled_contr_poly</code> are called for unordered and ordered factors,
respectively, using the <code>scale</code> argument provided in the call
to <code>standardize</code> as the <code>scale</code> argument to the contrast
functions.  For numeric variables, if the variable contains a call to
<code>scale_by</code>, then, regardless of whether the call to
<code>scale_by</code> specifies <code>scale</code>, the value of <code>scale</code>
in the call to <code>standardize</code> is used.  If the numeric variable
does not contain a call to <code>scale_by</code>, then
<code>scale</code> is called, ensuring that the result has
standard deviation <code>scale</code>.
</p>
<p>With the default value of <code>scale = 1</code>, the result is a
<code>standardized</code> object which contains a formula and data
frame (and offset vector if the <code>offset</code> argument to the
<code>standardize</code> function was used) which can be used to fit regressions
where the predictors are all on a similar scale.  Its data frame
has numeric variables on unit scale, unordered factors with named sum
sum contrasts, and ordered factors with orthogonal polynomial contrasts
on unit scale.  For gaussian regressions, the response is also placed on
unit scale.  If <code>scale = 0.5</code> (for example),
then gaussian responses would still
be placed on unit scale, but unordered factors' named sum contrasts would
take on values -0.5, 0, 0.5 rather than -1, 0, 1, the standard deviation
of each column in the contrast matrices for ordered factors would be
<code>0.5</code> rather than <code>1</code>, and the standard deviation of numeric
variables would be <code>0.5</code> rather than <code>1</code> (within-factor-level
in the case of <code>scale_by</code> calls).
</p>


<h3>Value</h3>

<p>A <code>standardized</code> object. The
<code>formula</code>, <code>data</code>, and <code>offset</code> elements of the object can
be used in calls to regression functions.
</p>


<h3>Note</h3>

<p>The <code>scale_by</code>
function is supported so long as it is not nested within other function
calls.  The <code>poly</code> function is supported so long as
it is either not nested within other function calls, or is nested as the
transformation of the numeric variable in a <code>scale_by</code> call.
If <code>poly</code> is used, then the <code>lsmeans</code> function
will yield misleading results (as would normally be the case).
</p>
<p>In previous versions of <code>standardize</code> (v0.2.0 and earlier),
<code>na.action</code> could be specified.  Starting with v0.2.1, specifying
something other than <code>na.pass</code> is ignored with a warning.  Use of
<code>na.omit</code> and <code>na.exclude</code> should be done when calling regression
fitting functions using the elements returned in the
<code>standardized</code> object.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>For scaling and contrasts, see <code>scale</code>,
<code>scale_by</code>, <code>named_contr_sum</code>, and
<code>scaled_contr_poly</code>. For putting new data into the same space
as the standardized data, see <code>predict</code>.
For the elements in the returned object, see
<code>standardized</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- expand.grid(ufac = letters[1:3], ofac = 1:3)
dat &lt;- as.data.frame(lapply(dat, function(n) rep(n, 60)))
dat$ofac &lt;- factor(dat$ofac, ordered = TRUE)
dat$x &lt;- rpois(nrow(dat), 5)
dat$z &lt;- rnorm(nrow(dat), rep(rnorm(30), each = 18), rep(runif(30), each = 18))
dat$subj &lt;- rep(1:30, each = 18)
dat$y &lt;- rnorm(nrow(dat), -2, 5)

sobj &lt;- standardize(y ~ log(x + 1) + scale_by(z ~ subj) + ufac + ofac +
  (1 | subj), dat)

sobj
sobj$formula
head(dat)
head(sobj$data)
sobj$contrasts
sobj$groups
mean(sobj$data$y)
sd(sobj$data$y)
mean(sobj$data$log_x.p.1)
sd(sobj$data$log_x.p.1)
with(sobj$data, tapply(z_scaled_by_subj, subj, mean))
with(sobj$data, tapply(z_scaled_by_subj, subj, sd))

sobj &lt;- standardize(y ~ log(x + 1) + scale_by(z ~ subj) + ufac + ofac +
  (1 | subj), dat, scale = 0.5)

sobj
sobj$formula
head(dat)
head(sobj$data)
sobj$contrasts
sobj$groups
mean(sobj$data$y)
sd(sobj$data$y)
mean(sobj$data$log_x.p.1)
sd(sobj$data$log_x.p.1)
with(sobj$data, tapply(z_scaled_by_subj, subj, mean))
with(sobj$data, tapply(z_scaled_by_subj, subj, sd))

## Not run: 
mod &lt;- lmer(sobj$formula, sobj$data)
# this next line causes warnings about contrasts being dropped, but
# these warnings can be ignored (i.e. the statement still evaluates to TRUE)
all.equal(predict(mod, newdata = predict(sobj, dat)), fitted(mod))

## End(Not run)
</code></pre>


</div>