<div class="container">

<table style="width: 100%;"><tr>
<td>hclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>QTS Hierarchical Agglomerative Clustering</h2>

<h3>Description</h3>

<p>This function massages the input quaternion time series to apply hierarchical
agglomerative clustering on them, with the possibility of separating
amplitude and phase variability and of choosing the source of variability
through which clusters should be searched.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hclust(x, metric, linkage_criterion, ...)

## Default S3 method:
hclust(
  x,
  metric = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  linkage_criterion = c("complete", "average", "single", "ward.D2"),
  ...
)

## S3 method for class 'qts_sample'
hclust(
  x,
  metric = c("l2", "pearson"),
  linkage_criterion = c("complete", "average", "single", "ward.D2"),
  n_clusters = 1L,
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  cluster_on_phase = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns) or an object of class qts_sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>A character string specifying the distance measure to be used.
This must be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code> or <code>"minkowski"</code> if <code>x</code> is not a QTS sample.
Otherwise, it must be one of <code>"l2"</code>, <code>"pearson"</code> or <code>"dtw"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linkage_criterion</code></td>
<td>
<p>A string specifying which linkage criterion should
be used to compute distances between sets of curves. Choices are
<code>"complete"</code> for complete linkage, <code>"average"</code> for average linkage and
<code>"single"</code> for single linkage. See <code>stats::hclust()</code> for more details.
Defaults to <code>"complete"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further graphical arguments.  E.g., <code>cex</code> controls
the size of the labels (if plotted) in the same way as <code>text</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters.
Defaults to <code>1L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>stats::kmeans</code> or <code>stats::hclust</code> or
<code>dbscan_fast</code> if the input <code>x</code> is NOT of class <code>qts_sample</code>. Otherwise,
an object of class <code>qtsclust</code> which is effectively a list with four
components:
</p>

<ul>
<li> <p><code>qts_aligned</code>: An object of class <code>qts_sample</code> storing the sample of
aligned QTS;
</p>
</li>
<li> <p><code>qts_centers</code>: A list of objects of class <code>qts</code> representing the centers
of the clusters;
</p>
</li>
<li> <p><code>best_clustering</code>: An object of class <code>fdacluster::caps</code> storing the
results of the best k-mean alignment result among all initialization that
were tried.
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the clustering structure;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">out &lt;- hclust(vespa64$igp[1:10], n_clusters = 2)
plot(out)
</code></pre>


</div>