<div class="container">

<table style="width: 100%;"><tr>
<td>sv_between</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Validate that a field is a number bounded by minimum and maximum values</h2>

<h3>Description</h3>

<p>The <code>sv_between()</code> function validates that a field has values between left
and right boundary values. Both bounds are inclusive by default, but both can
be set as either inclusive or exclusive with the <code>inclusive</code> argument. In its
default mode, the validation check will effectively be of the form <code style="white-space: pre;">⁠&lt;left&gt; &lt;= &lt;field&gt; &lt;= &lt;right&gt;⁠</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sv_between(
  left,
  right,
  inclusive = c(TRUE, TRUE),
  message_fmt = "Must be between {left} and {right}.",
  allow_na = FALSE,
  allow_nan = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>left, right</code></td>
<td>
<p>The left and right boundary values. Inclusively for each of
the boundaries is set with the <code>inclusive</code> argument; the defaults are set
for inclusive bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inclusive</code></td>
<td>
<p>A two-element logical vector that indicates whether the
<code>left</code> and <code>right</code> bounds, respectively, should be inclusive. Both bounds
are by default are inclusive, using <code>c(TRUE, TRUE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message_fmt</code></td>
<td>
<p>The validation error message to use if a value fails to
match the rule. The message can be customized by using the <code>"{left}"</code> and
<code>"{right}"</code> string parameters, which allows for the insertion of the <code>left</code>
and <code>right</code> values. While the default message uses both of these string
parameters, they are not required in a user-defined <code>message_fmt</code> string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_na, allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A function suitable for use as an
<code>InputValidator$add_rule()</code> rule.
</p>


<h3>See Also</h3>

<p>The <code>sv_in_set()</code> function, which tests whether a field values are
part of a specified set.
</p>
<p>Other rule functions: 
<code>compose_rules()</code>,
<code>sv_email()</code>,
<code>sv_equal()</code>,
<code>sv_gte()</code>,
<code>sv_gt()</code>,
<code>sv_in_set()</code>,
<code>sv_integer()</code>,
<code>sv_lte()</code>,
<code>sv_lt()</code>,
<code>sv_not_equal()</code>,
<code>sv_numeric()</code>,
<code>sv_optional()</code>,
<code>sv_regex()</code>,
<code>sv_required()</code>,
<code>sv_url()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("count", "Count")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_between()` requires `left` and
  # `right` boundary values; a message will be
  # displayed if the validation of `input$count` fails
  iv$add_rule("count", sv_between(10, 100))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>


</div>