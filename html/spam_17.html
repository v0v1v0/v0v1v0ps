<div class="container">

<table style="width: 100%;"><tr>
<td>spam-operations</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Basic Linear Algebra for Sparse Matrices</h2>

<h3>Description</h3>

<p>Basic linear algebra operations for sparse matrices
of class <code>spam</code>.
</p>


<h3>Details</h3>

<p>Linear algebra operations for matrices of class
<code>spam</code> are designed to behave exactly as for
regular matrices.  In particular, matrix multiplication, transpose, addition,
subtraction and various logical operations should work as with the conventional
dense form of matrix storage, as does indexing, rbind, cbind, and diagonal
assignment and extraction (see for example <code>diag</code>).
Further functions with identical behavior are <code>dim</code> and thus <code>nrow</code>, <code>ncol</code>.
</p>
<p>The function <code>norm</code> calculates the (matrix-)norm of the argument.
The argument <code>type</code> specifies the <code>l1</code> norm, <code>sup</code> or max
norm (default), or the Frobenius or Hilbert-Schmidt
(<code>frobenius/hs</code>) norm. Partial matching can be used. For example,
<code>norm</code> is used to check for symmetry in the function <code>chol</code> by
computing the norm of the difference between the matrix and its
transpose
</p>
<p>The operator <code>%d*%</code> efficiently multiplies a diagonal matrix (in
vector form) and a sparse matrix and is used for compatibility with the
package fields. More specifically, this method is used in the internal
functions of <code>Krig</code> to make the code more readable. It avoids
having a branch in the source code to handle the diagonal or nondiagonal
cases.  Note that this operator is not symmetric: a vector in
the left argument is interpreted as a diagonal matrix and a vector in
the right argument is kept as a column vector.
</p>
<p>The operator <code>%d+%</code> efficiently adds a diagonal matrix (in vector
form) and a sparse matrix, similarly to the operator <code>%d+%</code>.
</p>


<h3>References</h3>

<p>Some Fortran functions are based on
<a href="https://github.com/johannesgerer/jburkardt-f/blob/master/sparsekit/sparsekit.html">https://github.com/johannesgerer/jburkardt-f/blob/master/sparsekit/sparsekit.html</a>
</p>


<h3>See Also</h3>

<p><code>spam</code> for coercion and other class relations involving the
sparse matrix classes.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create a weight matrix and scale it:
## Not run: 
wij &lt;- distmat
# with distmat from a nearest.dist(..., upper=TRUE) call

n &lt;- dim(wij)[1]

wij@entries &lt;- kernel( wij@entries, h) # for some function kernel
wij &lt;- wij + t(wij) + diag.spam(n)     # adjust from diag=FALSE, upper=TRUE

sumwij &lt;- wij %*% rep(1,n)
    # row scaling:
    #   wij@entries &lt;- wij@entries/sumwij[ wij@colindices]
    # col scaling:
wij@entries &lt;- wij@entries/sumwij[ rep(1:n, diff(wij@rowpointers))]

## End(Not run)
</code></pre>


</div>