<div class="container">

<table style="width: 100%;"><tr>
<td>partition_tiles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partition the study area into rectangular tiles</h2>

<h3>Description</h3>

<p><code>partition_tiles</code> divides the study area into a specified number
of rectangular tiles. Optionally small partitions can be merged with
adjacent tiles to achieve a minimum number or percentage of samples in each
tile.
</p>


<h3>Usage</h3>

<pre><code class="language-R">partition_tiles(
  data,
  coords = c("x", "y"),
  dsplit = NULL,
  nsplit = NULL,
  rotation = c("none", "random", "user"),
  user_rotation,
  offset = c("none", "random", "user"),
  user_offset,
  reassign = TRUE,
  min_frac = 0.025,
  min_n = 5,
  iterate = 1,
  return_factor = FALSE,
  repetition = 1,
  seed1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dsplit</code></td>
<td>
<p>optional vector of length 2: equidistance of splits in
(possibly rotated) x direction (<code>dsplit[1]</code>) and y direction (<code>dsplit[2]</code>)
used to define tiles. If <code>dsplit</code> is of length 1, its value is recycled.
Either <code>dsplit</code> or <code>nsplit</code> must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsplit</code></td>
<td>
<p>optional vector of length 2: number of splits in (possibly
rotated) x direction (<code>nsplit[1]</code>) and y direction (<code>nsplit[2]</code>) used to
define tiles. If <code>nsplit</code> is of length 1, its value is recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p>indicates whether and how the rectangular grid should be
rotated; random rotation is only between <code>-45</code> and <code>+45</code> degrees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_rotation</code></td>
<td>
<p>if <code>rotation='user'</code>, angles (in degrees) by which the
rectangular grid is to be rotated in each repetition. Either a vector of
same length as <code>repetition</code>, or a single number that will be replicated
<code>length(repetition)</code> times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>indicates whether and how the rectangular grid should be
shifted by an offset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_offset</code></td>
<td>
<p>if <code>offset='user'</code>, a list (or vector) of two components
specifying a shift of the rectangular grid in (possibly rotated) x and y
direction. The offset values are relative values, a value of <code>0.5</code>
resulting in a one-half tile shift towards the left, or upward. If this is
a list, its first (second) component refers to the rotated x (y) direction,
and both components must have same length as <code>repetition</code> (or length 1). If
a vector of length 2 (or list components have length 1), the two values
will be interpreted as relative shifts in (rotated) x and y direction,
respectively, and will therefore be recycled as needed
(<code>length(repetition)</code> times each).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reassign</code></td>
<td>
<p>logical (default <code>TRUE</code>): if <code>TRUE</code>, 'small' tiles (as per
<code>min_frac</code> and <code>min_n</code> arguments and get_small_tiles) are merged with
(smallest) adjacent tiles. If <code>FALSE</code>, small tiles are 'eliminated', i.e.
set to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_frac</code></td>
<td>
<p>numeric &gt;=0, &lt;1: minimum relative size of partition as
percentage of sample; argument passed to get_small_tiles. Will be ignored
if <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_n</code></td>
<td>
<p>integer &gt;=0: minimum number of samples per partition; argument
passed to get_small_tiles. Will be ignored if <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterate</code></td>
<td>
<p>argument to be passed to tile_neighbors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a represampling object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by set.seed in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A represampling object. Contains <code>length(repetition)</code> resampling
objects as repetitions. The exact number of folds / test-set tiles within
each resampling objects depends on the spatial configuration of the data
set and possible cleaning steps (see <code>min_frac</code>, <code>min_n</code>).
</p>


<h3>Note</h3>

<p>Default parameter settings may change in future releases. This
function, especially the rotation and shifting part of it and the algorithm
for cleaning up small tiles is still a bit experimental. Use with caution.
For non-zero offsets (<code style="white-space: pre;">⁠offset!='none')⁠</code>), the number of tiles may actually
be greater than <code>nsplit[1]*nsplit[2]</code> because of fractional tiles lurking
into the study region. <code>reassign=TRUE</code> with suitable thresholds is
therefore recommended for non-zero (including random) offsets.
</p>


<h3>See Also</h3>

<p>sperrorest, as.resampling.factor, get_small_tiles,
tile_neighbors
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(ecuador)
set.seed(42)
parti &lt;- partition_tiles(ecuador, nsplit = c(4, 3), reassign = FALSE)
# plot(parti,ecuador)
# tile A4 has only 55 samples
# same partitioning, but now merge tiles with less than 100 samples to
# adjacent tiles:
parti2 &lt;- partition_tiles(ecuador,
  nsplit = c(4, 3), reassign = TRUE,
  min_n = 100
)
# plot(parti2,ecuador)
summary(parti2)
# tile B4 (in 'parti') was smaller than A3, therefore A4 was merged with B4,
# not with A3
# now with random rotation and offset, and tiles of 2000 m length:
parti3 &lt;- partition_tiles(ecuador,
  dsplit = 2000, offset = "random",
  rotation = "random", reassign = TRUE, min_n = 100
)
# plot(parti3, ecuador)
summary(parti3)
</code></pre>


</div>