<div class="container">

<table style="width: 100%;"><tr>
<td>gset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized sets</h2>

<h3>Description</h3>

<p>Creation and manipulation of generalized sets.</p>


<h3>Usage</h3>

<pre><code class="language-R">gset(support, memberships, charfun, elements, universe, bound,
     assume_numeric_memberships)
as.gset(x)
is.gset(x)
gset_support(x)
gset_core(x, na.rm = FALSE)
gset_peak(x, na.rm = FALSE)
gset_height(x, na.rm = FALSE)
gset_universe(x)
gset_bound(x)

gset_memberships(x, filter = NULL)
gset_transform_memberships(x, FUN, ...)
gset_concentrate(x)
gset_dilate(x)
gset_normalize(x, height = 1)
gset_defuzzify(x,
               method = c("meanofmax", "smallestofmax",
                          "largestofmax", "centroid"))

gset_is_empty(x, na.rm = FALSE)
gset_is_subset(x, y, na.rm = FALSE)
gset_is_proper_subset(x, y, na.rm = FALSE)
gset_is_equal(x, y, na.rm = FALSE)
gset_contains_element(x, e)

gset_is_set(x, na.rm = FALSE)
gset_is_multiset(x, na.rm = FALSE)
gset_is_fuzzy_set(x, na.rm = FALSE)
gset_is_set_or_multiset(x, na.rm = FALSE)
gset_is_set_or_fuzzy_set(x, na.rm = FALSE)
gset_is_fuzzy_multiset(x)
gset_is_crisp(x, na.rm = FALSE)
gset_has_missings(x)

gset_cardinality(x, type = c("absolute", "relative"), na.rm = FALSE)
gset_union(...)
gset_sum(...)
gset_difference(...)
gset_product(...)
gset_mean(x, y, type = c("arithmetic", "geometric", "harmonic"))
gset_intersection(...)
gset_symdiff(...)
gset_complement(x, y)
gset_power(x)
gset_cartesian(...)
gset_combn(x, m)

e(x, memberships = 1L)
is_element(e)

## S3 method for class 'gset'
cut(x, level = 1, type = c("alpha", "nu"), strict = FALSE, ...)
## S3 method for class 'gset'
mean(x, ..., na.rm = FALSE)

## S3 method for class 'gset'
## median(x, na.rm = FALSE, ...)     [R &gt;= 3.4.0]
## median(x, na.rm)                  [R &lt; 3.4.0]
## S3 method for class 'gset'
length(x)
## S3 method for class 'gset'
lengths(x, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For <code>e()</code>, <code>as.gset()</code> and <code>is.gset()</code>:
an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object. A (g)set object otherwise. <code>gset_memberships()</code>
also accepts tuple objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A (g)set object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>An object of class <code>element</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>Optional vector of elements to be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>
<p>A set of elements giving the support of the gset
(elements with non-zero memberships). Must be a subset of the
universe, if specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memberships</code></td>
<td>
<p>For an (“ordinary”) set: 1L (or simply missing).
For a fuzzy set: a value between 0 and 1.  For a multiset: a
positive integer.  For a fuzzy multiset: a list of
multisets with elements from the unit interval (or a list of vectors
interpreted as such).
Otherwise, the argument will be transformed using <code>as.gset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>A set (or list) of <code>e</code> objects which are
object/memberships-pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>charfun</code></td>
<td>
<p>A function taking an object and returning the
membership.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>
<p>Integer used to compute the absolute complement for
(fuzzy) multisets. If <code>NULL</code>,
defaults to the value of <code>sets_options("bound")</code>.
If the latter is also <code>NULL</code>, the maximum multiplicity
will be used in computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assume_numeric_memberships</code></td>
<td>
<p>When applying <code>carfun()</code> to
the universe, should numeric memberships (i.e. fuzzy sets or
multisets) be assumed (default)? If <code>FALSE</code>, fuzzy multisets
will be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function, to be applied to a membership vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>For <code>gset_cardinality()</code>:
cardinality type (either <code>"absolute"</code> or
<code>"relative"</code>). For <code>gset_mean()</code>: mean type
(<code>"arithmetic"</code>, <code>"geometric"</code>, or <code>"harmonic"</code>).
For <code>"cut"</code>: either <code>"alpha"</code> or <code>"nu"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Logical indicating whether the cut level must be 
exceeded strictly (“greater than”) or not (“greater
than or equal”).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>Double from the unit interval for scaling memberships.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>universe</code></td>
<td>
<p>An optional set of elements. If <code>NULL</code>,
defaults to the value of <code>sets_options("universe")</code>.
If the latter is also <code>NULL</code>, the support
will be used in computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>"centroid"</code> computes the arithmetic
mean of the set elements, using the membership values as
weights. <code>"smallestofmax"</code> / <code>"meanofmax"</code> /
<code>"largestofmax"</code> returns the minimum/mean/maximum of all
set elements with maximal membership degree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The minimum membership level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be
removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>gset_<var>foo</var>()</code>: (g)set objects.  For
the mean and sort methods: additional parameters internally passed to
<code>mean</code> and <code>order</code>, respectively. For
<code>gset_transform_memberships</code>: further arguments passed to
<code>FUN</code>. For <code>cut</code>: currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions represent basic infrastructure for handling
<em>generalized</em> sets of general (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) objects.
</p>
<p>A generalized set (or gset) is set of pairs <code class="reqn">(e, f)</code>, where
<code class="reqn">e</code> is some set element and <code class="reqn">f</code> is the characteristic (or
membership) function. For (“ordinary”) sets
<code class="reqn">f</code> maps to <code class="reqn">\{0, 1\}</code>,
for fuzzy sets into the unit interval, for multisets into the natural
numbers, and for fuzzy multisets <code class="reqn">f</code> maps to the set of multisets
over the unit interval.
</p>
<p>The <code>gset_is_<var>foo</var>()</code> predicates
are vectorized. In addition
to the methods defined, one can use the following operators:
<code>|</code> for the union, <code>&amp;</code> for the
intersection, <code>+</code> for the sum, <code>-</code> for
the difference,  <code>%D%</code> for the symmetric difference,
<code>*</code> and <code>^<var>n</var></code> for the
(<code class="reqn">n</code>-fold) cartesian product, <code>2^</code> for the power set,
<code>%e%</code> for the element-of predicate,
<code>&lt;</code> and <code>&lt;=</code> for
the (proper) subset predicate, <code>&gt;</code> and <code>&gt;=</code> for
the (proper) superset predicate, and <code>==</code> and <code>!=</code> for
(in)equality.
The <code>Summary</code> methods do also work if
defined for the set elements. 
The <code>mean</code> and <code>median</code>
methods try to convert the object to a numeric vector before calling
the default methods. <code>set_combn</code> returns the gset of all
subsets of specified length. 
</p>
<p><code>gset_support</code>, <code>gset_core</code>, and <code>gset_peak</code>
return the set of elements with memberships greater than zero, equal
to one, and equal to the maximum membership, respectively.
<code>gset_memberships</code> returns the membership
vector(s) of a given (tuple of) gset(s), optionally
restricted to the elements specified by <code>filter</code>.
<code>gset_height</code> returns only
the largest membership degree.
<code>gset_cardinality</code> computes either the absolute or the
relative cardinality, i.e. the memberships sum, or the absolute
cardinality divided by the number of elements, respectively.
The <code>length</code> method for gsets gives the (absolute) cardinality.
The <code>lengths</code> method coerces the set to a list
before applying the <code>length</code> method on its elements.
<code>gset_transform_memberships</code> applies function <code>FOO</code> to 
the membership vector of the supplied gset and returns the transformed
gset. The transformed memberships are guaranteed to be in the unit
interval.
<code>gset_concentrate</code> and <code>gset_dilate</code> are convenience
functions, using the square and the square root,
respectively. <code>gset_normalize</code> divides the memberships by their
maximum and scales with <code>height</code>.
<code>gset_product</code> (<code>gset_mean</code>) of some gsets
compute the gset with the corresponding memberships multiplied (averaged).
</p>
<p>The <code>cut</code> method provides both <code class="reqn">\alpha</code>- and <code class="reqn">\nu</code>-cuts.
<code class="reqn">\alpha</code>-cuts “filter” all elements with memberships
greater than (or equal to) <code>level</code>—the result, thus, is a crisp
(multi)set. <code class="reqn">\nu</code>-cuts select those elements with a
<em>multiplicity</em> exceeding <code>level</code>
(only sensible for (fuzzy) multisets). 
</p>
<p>Because set elements are unordered, it is not allowed to use
<em>positional</em> indexing. However, it is possible to
do indexing using element labels or
simply the elements themselves (useful, e.g., for subassignment).
In addition, it is possible to iterate over
<em>all</em> elements using <code>for</code> and <code>lapply</code>/<code>sapply</code>.
</p>
<p><code>gset_contains_element</code> is vectorized in <code>e</code>, that is, if <code>e</code>
is an atomic vector or list, the is-element operation is performed
element-wise, and a logical vector returned. Note that, however,
objects of class <code>tuple</code> are taken as atomic objects to
correctly handle sets of tuples.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1–27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code>set</code> for “ordinary” sets, 
<code>gset_outer</code>, and
<code>tuple</code> for tuples (“vectors”).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## multisets
(A &lt;- gset(letters[1:5], memberships = c(3, 2, 1, 1, 1)))
(B &lt;- gset(c("a", "c", "e", "f"), memberships = c(2, 2, 1, 2)))
rep(B, 2)
gset_memberships(tuple(A, B), c("a","c"))

gset_union(A, B)
gset_intersection(A, B)
gset_complement(A, B)

gset_is_multiset(A)
gset_sum(A, B)
gset_difference(A, B)

## fuzzy sets
(A &lt;- gset(letters[1:5], memberships = c(1, 0.3, 0.8, 0.6, 0.2)))
(B &lt;- gset(c("a", "c", "e", "f"), memberships = c(0.7, 1, 0.4, 0.9)))
cut(B, 0.5)
A * B
A &lt;- gset(3L, memberships = 0.5, universe = 1:5)
!A

## fuzzy multisets
(A &lt;- gset(c("a", "b", "d"),
         memberships = list(c(0.3, 1, 0.5), c(0.9, 0.1),
                            gset(c(0.4, 0.7), c(1, 2)))))
(B &lt;- gset(c("a", "c", "d", "e"),
         memberships = list(c(0.6, 0.7), c(1, 0.3), c(0.4, 0.5), 0.9)))
gset_union(A, B)
gset_intersection(A, B)
gset_complement(A, B)

## other operations
mean(gset(1:3, c(0.1,0.5,0.9)))
median(gset(1:3, c(0.1,0.5,0.9)))

## vectorization
list(gset(1, 0.5), gset(2, 2L), gset()) &lt;= gset(1, 2L)
</code></pre>


</div>