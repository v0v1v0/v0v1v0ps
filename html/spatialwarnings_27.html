<div class="container">

<table style="width: 100%;"><tr>
<td>raw_clustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clustering of pairs</h2>

<h3>Description</h3>

<p>Compute the number of pairs of neighbor cells in a landscape and derive 
from it clustering indices
</p>


<h3>Usage</h3>

<pre><code class="language-R">raw_clustering(mat, wrap = TRUE, use_8_nb = FALSE)

pair_counts(mat, wrap = TRUE, use_8_nb = FALSE, prop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A matrix, usually with discrete values (logical, integers, etc.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>Whether space should be considered to wrap at the edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_8_nb</code></td>
<td>
<p>Set to <code>TRUE</code> to use an 8-way neighborhood. The default is set
to FALSE, which uses a 4-way neighborhood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>Return the counts for all pairs in the matrix (FALSE), or
the proportions for each pair (out of all possible pairs)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The clustering of pairs is defined as the density of pairs, i.e.
the proportion of all neighboring pairs of cells that share the same state, 
divided by the null expectation given a random, homogeneous spatial structure.
</p>
<p>For example, let's consider a matrix with two states, 'a' and 'b'.
<code>raw_clustering</code> will count all pairs of cells 'a-a' or 'b-b', and
divide this by the total number of pairs. This proportion is then again
divided by the probability of obtaining these proportion of pairs under
the assumption of no spatial structure (random mixing of cells in the
matrix). 
</p>
<p>Clustering is equal to one when there is no spatial structure. It is
above one when two states are found next to each other (i.e. cluster)
more than expected by chance. Values below one means that those two
states tend to be neighbors less frequently than expected by chance. 
</p>
<p>If you are only interested in the proportion of pairs for each combination
of states, you can use the function <code>pair_counts</code>, which returns
a matrix with as many rows and columns as there are states in the matrix, and 
contains the counts for all possible pairs of cells found in the matrix 
(or their relative proportions).
</p>


<h3>Value</h3>

<p>A vector with the requested clutering values for <code>raw_clustering</code>,
whose names are equal to each state (unique value) found in the
original matrix, preceded by 'clust_' (to make sure names are
compatible with other functions).
</p>
<p><code>pair_counts</code> returns the counts of pairs of states in the matrix,
or the proportion of each pair, depending on the value of <code>prop</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# The clustering of a random matrix is close to one
ls &lt;- 100 # lattice size
mm &lt;- matrix(sample(c("sp1", "sp2", "sp3", "sp4"), size = ls^2, replace = TRUE),
             nrow = ls, ncol = ls)
clust &lt;- raw_clustering(mm, wrap = TRUE, use_8_nb = TRUE)
print(clust)

# Compute clustering along the gradient for the serengeti dataset


data(forestgap)
clust_indic &lt;- compute_indicator(serengeti, raw_clustering,
                                 wrap = TRUE, use_8_nb = FALSE)
# The interesting one is the clustering of state 0 (FALSE in the original matrix),
# which corresponds to grassland pixels, which get more and more clustered with 
# increasing rainfall (see also ?generic_sews for how that compares with generic 
# indicators)
plot(clust_indic, along = serengeti.rain)

# Add null trend
clust_test &lt;- indictest(clust_indic, nulln = 19)
plot(clust_test, along = serengeti.rain)

# Show the proportion of each pairs of states in the matrix... 
pair_counts(serengeti[[5]])

# ... or the total count
pair_counts(serengeti[[5]], prop = FALSE)



</code></pre>


</div>