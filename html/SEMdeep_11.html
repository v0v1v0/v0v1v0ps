<div class="container">

<table style="width: 100%;"><tr>
<td>SEMdnn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Layer-wise SEM train with a Deep Neural Netwok (DNN)</h2>

<h3>Description</h3>

<p>The function builds the topological layer (TL) ordering
of the input graph to fit a series of Deep Neural Networks (DNN) 
models, where the nodes in one layer act as response variables (output) 
y and the nodes in the sucessive layers act as predictors (input) x. 
Each fit uses the <code>dnn</code> function of the <span class="pkg">cito</span> R
package, based on the deep learning framework 'torch'.
</p>
<p>The <span class="pkg">torch</span> package is native to R, so it's computationally efficient
and the installation is very simple, as there is no need to install Python
or any other API, and DNNs can be trained on CPU, GPU and MacOS GPUs.
In order to install <span class="pkg">torch</span> please follow these steps:
</p>
<p><code>install.packages("torch")</code>
</p>
<p><code>library(torch)</code>
</p>
<p><code>install_torch(reinstall = TRUE)</code>
</p>
<p>For setup GPU or if you have problems installing <span class="pkg">torch</span> package, check out the
<a href="https://torch.mlverse.org/docs/articles/installation.html/">installation</a>
help from the torch developer.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SEMdnn(
  graph,
  data,
  train = NULL,
  cowt = FALSE,
  thr = NULL,
  loss = "mse",
  hidden = c(10L, 10L, 10L),
  link = "relu",
  validation = 0,
  bias = TRUE,
  lambda = 0,
  alpha = 0.5,
  dropout = 0,
  optimizer = "adam",
  lr = 0.01,
  epochs = 100,
  device = "cpu",
  early_stopping = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An igraph object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix with rows corresponding to subjects, and columns
to graph nodes (variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train</code></td>
<td>
<p>A numeric vector specifying the row indices corresponding to 
the train dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cowt</code></td>
<td>
<p>A logical value. If <code>cowt=TRUE</code> connection weights of the
input node (variables) are computing (default = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr</code></td>
<td>
<p>A numerical value indicating the threshold to apply on the absolute
values of the connection matrix to color the graph (default = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>A character value specifying the loss after which network should 
be optimized. The user can specify: (a) "mse" (mean squared error), "mae" 
(mean absolute error), or "gaussian" (normal likelihood), for regression problems; 
(b) "poisson" (poisson likelihood), or "nbinom" (negative binomial likelihood)
for regression with count data; (c) "binomial" (binomial likelihood) for 
binary classification problems; (d) "softmax" or "cross-entropy" for multi-class
classification (default = "mse").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden</code></td>
<td>
<p>hidden units in layers; the number of layers corresponds with
the length of the hidden units. As a default, <code>hidden = c(10L, 10L, 10L)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>A character value describing the activation function to use, which 
might be a single length or be a vector with many activation functions assigned
to each layer (default = "relu").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validation</code></td>
<td>
<p>A numerical value indicating the proportion of the data set 
that should be used as a validation set (randomly selected, default = 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>A logical vector, indicating whether to employ biases in the layers 
(<code>bias = TRUE</code>), which can be either vectors of logicals for each layer 
(number of hidden layers + 1 (final layer)) or of length one (default = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A numerical value indicating the strength of regularization: 
lambda penalty, <code class="reqn">\lambda * (L1 + L2)</code> (default = 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A numerical vector to add L1/L2 regularization into the training. 
Set the alpha parameter for each layer to <code class="reqn">(1 - \alpha) * ||weights||_1 + 
\alpha ||weights||^2</code>. It must fall between 0 and 1 (default = 0.5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropout</code></td>
<td>
<p>A numerical value for the dropout rate, which is the probability
that a node will be excluded from training (default = 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>A character value indicating the optimizer to use for 
training the network. The user can specify: "adam" (ADAM algorithm), "adagrad"
(adaptive gradient algorithm), "rmsprop" (root mean squared propagation),
"rprop” (resilient backpropagation), "sgd" (stochastic gradient descent).
As a default, <code>optimizer = “adam”</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr</code></td>
<td>
<p>A numerical value indicating the learning rate given to the optimizer 
(default = 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p>A numerical value indicating the epochs during which the training 
is conducted (default = 100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p>A character value describing the CPU/GPU device ("cpu", "cuda", "mps")
on which the  neural network should be trained on (default = "cpu")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping</code></td>
<td>
<p>If set to integer, training will terminate if the loss 
increases over a predetermined number of consecutive epochs and apply validation
loss when available. Default is FALSE, no early stopping is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, the training curves of the DNN models
are displayed as output, comparing the training, validation and baseline 
curves in terms of loss (y) against the number of epochs (x) (default = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By mapping data onto the input graph, <code>SEMdnn()</code> creates a set 
of DNN models based on the topological layer (j=1,…,L) structure of the input
graph. In each iteration, the response (output) variables, y are the nodes in
the j=1,...,(L-1) layer and the predictor (input) variables, x are the nodes
belonging to the successive, (j+1),...,L layers. 
Each DNN model is a Multilayer Perceptron (MLP) network, where every neuron node
is connected to every other neuron node in the hidden layer above and every other
hidden layer below. Each neuron's value is determined by calculating a weighted
summation of its outputs from the hidden layer before it, and then applying an
activation function.  The calculated value of every neuron is used as the input
for the neurons in the layer below it, until the output layer is reached.
</p>


<h3>Value</h3>

<p>An S3 object of class "DNN" is returned. It is a list of 5 objects:
</p>

<ol>
<li>
<p> "fit", a list of DNN model objects, including: the estimated covariance 
matrix (Sigma), the estimated model errors (Psi), the fitting indices (fitIdx),
and the estimated connection weights (parameterEstimates), if cowt=TRUE.
</p>
</li>
<li>
<p> "Yhat", the matrix of continuous predicted values of graph nodes  
(excluding source nodes) based on training samples. 
</p>
</li>
<li>
<p> "model", a list of all j=1,...,(L-1) fitted MLP network models.
</p>
</li>
<li>
<p> "graph", the induced DAG of the input graph mapped on data variables.
If cowt=TRUE, the DAG is colored based on the estimated connection weights, if
abs(W) &gt; thr and W &lt; 0,  the edge is inhibited and it is highlighted in blue;
otherwise, if abs(W) &gt; thr and W &gt; 0, the edge is activated and it is highlighted
in red. 
</p>
</li>
<li>
<p> "data", standardized training data subset mapping graph nodes.
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Amesöder, C., Hartig, F. and Pichler, M. (2024), ‘cito': an R package for training
neural networks using ‘torch'. Ecography, 2024: e07143. https://doi.org/10.1111/ecog.07143
</p>
<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38 (20), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">

if (torch::torch_is_installed()){

# load ALS data
ig&lt;- alsData$graph
data&lt;- alsData$exprs
data&lt;- transformData(data)$data
group&lt;- alsData$group

#...with train-test (0.5-0.5) samples
set.seed(123)
train&lt;- sample(1:nrow(data), 0.5*nrow(data))

start&lt;- Sys.time()
dnn0 &lt;- SEMdnn(ig, data, train, cowt = TRUE, thr = NULL,
			#loss = "mse", hidden = 5*K, link = "selu",
			loss = "mse", hidden = c(10, 10, 10), link = "selu",
			validation = 0, bias = TRUE, lr = 0.01,
			epochs = 32, device = "cpu", verbose = TRUE)
end&lt;- Sys.time()
print(end-start)

#str(dnn0, max.level=2)
dnn0$fit$fitIdx
dnn0$fit$parameterEstimates
gplot(dnn0$graph)
table(E(dnn0$graph)$color)

#...with a binary outcome (1=case, 0=control)

ig1&lt;- mapGraph(ig, type="outcome"); gplot(ig1)
outcome&lt;- ifelse(group == 0, -1, 1); table(outcome)
data1&lt;- cbind(outcome, data); data1[1:5,1:5]

start&lt;- Sys.time()
dnn1 &lt;- SEMdnn(ig1, data1, train, cowt = TRUE, thr = NULL,
			#loss = "mse", hidden = 5*K, link = "selu",
			loss = "mse", hidden = c(10, 10, 10), link = "selu",
			validation = 0, bias = TRUE, lr = 0.01,
			epochs = 32, device = "cpu", verbose = TRUE)
end&lt;- Sys.time()
print(end-start)

#str(dnn1, max.level=2)
dnn1$fit$fitIdx
dnn1$fit$parameterEstimates
gplot(dnn1$graph) 
table(E(dnn1$graph)$color)

#...with input -&gt; hidden structure -&gt; output :
# source nodes -&gt; graph layer structure -&gt; sink nodes

#Topological layer (TL) ordering
K&lt;- c(12,  5,  3,  2,  1,  8)
K&lt;- rev(K[-c(1,length(K))]);K

ig2&lt;- mapGraph(ig, type="source"); gplot(ig2)

start&lt;- Sys.time()
dnn2 &lt;- SEMdnn(ig2, data, train, cowt = TRUE, thr = NULL,
			loss = "mse", hidden = 5*K, link = "selu",
			#loss = "mse", hidden = c(10, 10, 10), link = "selu",
			validation = 0, bias = TRUE, lr = 0.01,
			epochs = 32, device = "cpu", verbose = TRUE)
end&lt;- Sys.time()
print(end-start)

#Visualization of the neural network structure
nplot(dnn2$model[[1]], bias=FALSE)

#str(dnn2, max.level=2)
dnn2$fit$fitIdx
mean(dnn2$fit$Psi)
dnn2$fit$parameterEstimates
gplot(dnn2$graph)
table(E(dnn2$graph)$color)
}


</code></pre>


</div>