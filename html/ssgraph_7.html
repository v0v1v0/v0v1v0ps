<div class="container">

<table style="width: 100%;"><tr>
<td>ssgraph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>	Algorithm for graphical models using spike-and-slab priors  </h2>

<h3>Description</h3>

<p>This function has a sampling algorithm for Bayesian model determination in undirected graphical models, based on spike-and-slab priors. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssgraph( data, n = NULL, method = "ggm", not.cont = NULL, 
         iter = 5000, burnin = iter / 2, var1 = 4e-04, 
         var2 = 1, lambda = 1, g.prior = 0.2, g.start = "full", 
         sig.start = NULL, save = FALSE, cores = NULL, verbose = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>There are two options: (1) an (<code class="reqn">n \times p</code>) matrix or a <code>data.frame</code> corresponding to the data, 
(2) an (<code class="reqn">p \times p</code>) covariance matrix as <code class="reqn">S=X'X</code> which <code class="reqn">X</code> is the data matrix 
(<code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of variables). 
It also could be an object of class <code>"sim"</code>, from the <code>bdgraph.sim</code> function of <code>R</code> package <code>BDgraph</code>.
The input matrix is automatically identified by checking the symmetry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations. It is needed if the <code>"data"</code> is a covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>A character with two options <code>"ggm"</code> (default) and <code>"gcgm"</code>. 
Option <code>"ggm"</code> is for Gaussian graphical models based on Gaussianity assumption.
Option <code>"gcgm"</code> is for Gaussian copula graphical models for the data that not follow Gaussianity assumption 
(e.g. continuous non-Gaussian, discrete, or mixed dataset).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>not.cont</code></td>
<td>
<p> For the case <code>method = "gcgm"</code>, a vector with binary values in which <code class="reqn">1</code> indicates not continuous variables. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iteration for the sampling algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iteration for the sampling algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var1</code></td>
<td>
<p> Value for the variance of the the prior of precision matrix for the places that there is no link in the graph. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var2</code></td>
<td>
<p> Value for the variance of the the prior of precision matrix for the places that there is link in the graph. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> Value for the parameter of diagonal element of the prior of precision matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.prior</code></td>
<td>

<p>For determining the prior distribution of each edge in the graph. 
There are two options: a single value between <code class="reqn">0</code> and <code class="reqn">1</code> (e.g. <code class="reqn">0.5</code> as a noninformative prior) 
or an (<code class="reqn">p \times p</code>) matrix with elements between <code class="reqn">0</code> and <code class="reqn">1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.start</code></td>
<td>

<p>Corresponds to a starting point of the graph. It could be an (<code class="reqn">p \times p</code>) matrix, <code>"empty"</code> (default), or <code>"full"</code>. 
Option <code>"empty"</code> means the initial graph is an empty graph and <code>"full"</code> means a full graph. 
It also could be an object with <code>S3</code> class <code>"ssgraph"</code> of package <code>ssgraph</code> or <code>"bdgraph"</code> of package <code>BDgraph</code>; 
this option can be used to run the sampling algorithm from the last objects of previous run (see examples).     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig.start</code></td>
<td>

<p>Corresponds to a starting point of the covariance matrix. It must be positive definite matrix.     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save</code></td>
<td>

<p>Logical: if FALSE (default), the adjacency matrices are NOT saved. 
If TRUE, the adjacency matrices after burn-in are saved.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p> The number of cores to use for parallel execution. 
The default is to use <code>2</code> CPU cores of the computer.
The case <code>cores="all"</code> means all CPU cores to use for parallel execution. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if TRUE (default), report/print the MCMC running time. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with <code>S3</code> class <code>"ssgraph"</code> is returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p_links</code></td>
<td>
<p> An upper triangular matrix which corresponds the estimated posterior probabilities of all possible links. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_hat</code></td>
<td>
<p> The posterior estimation of the precision matrix. </p>
</td>
</tr>
</table>
<p>For the case "save = TRUE" is also returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sample_graphs</code></td>
<td>
<p> A vector of strings which includes the adjacency matrices of visited graphs after burn-in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph_weights</code></td>
<td>
<p> A vector which includes the counted numbers of visited graphs after burn-in. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_graphs</code></td>
<td>
<p>A vector which includes the identity of the adjacency matrices for all iterations after burn-in. 
It is needed for monitoring the convergence of the MCMC sampling algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_weights</code></td>
<td>
<p>A vector which includes the waiting times for all iterations after burn-in. 
It is needed for monitoring the convergence of the MCMC sampling algorithm.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Reza Mohammadi <a href="mailto:a.mohammadi@uva.nl">a.mohammadi@uva.nl</a> </p>


<h3>References</h3>

<p>Wang, H. (2015). Scaling it up: Stochastic search structure learning in graphical models, <em>Bayesian Analysis</em>, 10(2):351-377
</p>
<p>George, E. I. and McCulloch, R. E. (1993). Variable selection via Gibbs sampling. <em>Journal of the American Statistical Association</em>, 88(423):881-889
</p>
<p>Griffin, J. E. and Brown, P. J. (2010) Inference with normal-gamma prior distributions in regression problems. <em>Bayesian Analysis</em>, 5(1):171-188
</p>
<p>Mohammadi, A. et al (2017). Bayesian modelling of Dupuytren disease by using Gaussian copula graphical models, <em>Journal of the Royal Statistical Society: Series C</em>, 66(3):629-645
</p>
<p>Mohammadi, R. and Wit, E. C. (2019). <span class="pkg">BDgraph</span>: An <code>R</code> Package for Bayesian Structure Learning in Graphical Models, <em>Journal of Statistical Software</em>, 89(3):1-30 
</p>
<p>Mohammadi, A. and Wit, E. C. (2015). Bayesian Structure Learning in Sparse Gaussian Graphical Models, <em>Bayesian Analysis</em>, 10(1):109-138
</p>


<h3>See Also</h3>

 <p><code>bdgraph</code>, <code>bdgraph.mpl</code>, <code>summary.ssgraph</code>, <code>compare</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"># Generating multivariate normal data from a 'random' graph
data.sim &lt;- bdgraph.sim( n = 80, p = 6, size = 6, vis = TRUE )

# Running algorithm based on GGMs
ssgraph.obj &lt;- ssgraph( data = data.sim, iter = 1000 )

summary( ssgraph.obj )

# To compare the result with true graph
compare( pred = ssgraph.obj, actual = data.sim, 
         main = c( "Target", "ssgraph" ), vis = TRUE )

plotroc( pred = ssgraph.obj, actual = data.sim )
         
## Not run: 

# Running algorithm with starting points from previous run
ssgraph.obj2 &lt;- ssgraph( data = data.sim, iter=5000, g.start = ssgraph.obj )
    
compare( pred = list( ssgraph.obj, ssgraph.obj2 ), actual = data.sim, 
         main = c( "Target", "Frist run", "Second run" ), vis = TRUE )
         
plotroc( pred = list ( ssgraph.obj, ssgraph.obj2 ), actual = data.sim, 
         label = c( "Frist run", "Second run" ) )

## End(Not run)
</code></pre>


</div>