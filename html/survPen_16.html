<div class="container">

<table style="width: 100%;"><tr>
<td>model.cons</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Design and penalty matrices for the model</h2>

<h3>Description</h3>

<p>Sets up the model before optimization. Builds the design matrix, the penalty matrix and all the design matrices needed for Gauss-Legendre quadrature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">model.cons(
  formula,
  lambda,
  data.spec,
  t1,
  t1.name,
  t0,
  t0.name,
  event,
  event.name,
  expected,
  expected.name,
  type,
  n.legendre,
  cl,
  beta.ini
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula object identifying the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>vector of smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.spec</code></td>
<td>
<p>data frame that represents the environment from which the covariate values and knots are to be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1</code></td>
<td>
<p>vector of follow-up times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1.name</code></td>
<td>
<p>name of <code>t1</code> in <code>data.spec</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0</code></td>
<td>
<p>vector of origin times (usually filled with zeros)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0.name</code></td>
<td>
<p>name of <code>t0</code> in <code>data.spec</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event</code></td>
<td>
<p>vector of censoring indicators</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event.name</code></td>
<td>
<p>name of event in <code>data.spec</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expected</code></td>
<td>
<p>vector of expected hazard</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expected.name</code></td>
<td>
<p>name of expected in <code>data.spec</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"net" or "overall"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.legendre</code></td>
<td>
<p>number of nodes for Gauss-Legendre quadrature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>original <code>survPen</code> call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.ini</code></td>
<td>
<p>initial set of regression parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of objects with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>original <code>survPen</code> call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>"net" or "overall"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.legendre</code></td>
<td>
<p>number of nodes for Gauss-Legendre quadrature. If is.pwcst is TRUE, for simplicity of implementation, n.legendre actually corresponds to the number of sub-intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>number of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.para</code></td>
<td>
<p>design matrix associated with fully parametric parameters (unpenalized)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.smooth</code></td>
<td>
<p>design matrix associated with the penalized parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>design matrix for the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.pwcst</code></td>
<td>
<p>TRUE if there is a piecewise constant (excess) hazard specification. In that case the cumulative hazard can be derived without Gauss-Legendre quadrature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pwcst.breaks</code></td>
<td>
<p>if is.pwcst is TRUE, vector of breaks defining the sub-intervals on which the hazard is constant. Otherwise NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pwcst.weights</code></td>
<td>
<p>if is.pwcst is TRUE, matrix of weights giving the time contribution of each individual on each sub-interval. Otherwise NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leg</code></td>
<td>
<p>list of nodes and weights for Gauss-Legendre integration on [-1;1] as returned by <code>gauss.quad</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.GL</code></td>
<td>
<p>list of matrices (<code>length(X.GL)=n.legendre</code>) for Gauss-Legendre quadrature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>penalty matrix for the model. Sum of the elements of <code>S.list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.scale</code></td>
<td>
<p>vector of rescaling factors for the penalty matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank.S</code></td>
<td>
<p>rank of the penalty matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.F</code></td>
<td>
<p>balanced penalty matrix as described in section 3.1.2 of (Wood,2016). Sum of the elements of <code>S.F.list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.F</code></td>
<td>
<p>Eigen vectors of S.F, useful for the initial reparameterization to separate penalized ad unpenalized subvectors. Allows stable evaluation of the log determinant of S and its derivatives</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.smf</code></td>
<td>
<p>List of penalty matrices associated with all "smf" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.tensor</code></td>
<td>
<p>List of penalty matrices associated with all "tensor" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.tint</code></td>
<td>
<p>List of penalty matrices associated with all "tint" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.rd</code></td>
<td>
<p>List of penalty matrices associated with all "rd" calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.smf</code></td>
<td>
<p>List of names for the "smf" calls associated with S.smf</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.tensor</code></td>
<td>
<p>List of names for the "tensor" calls associated with S.tensor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.tint</code></td>
<td>
<p>List of names for the "tint" calls associated with S.tint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.name.rd</code></td>
<td>
<p>List of names for the "rd" calls associated with S.rd</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.pen</code></td>
<td>
<p>List of all the rescaled penalty matrices redimensioned to df.tot size. Every element of <code>pen</code> noted <code>pen[[i]]</code> is made from a penalty matrix returned by
<code>smooth.cons</code> and is multiplied by the factor 
S.scale=norm(X,type="I")^2/norm(pen[[i]],type="I")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.list</code></td>
<td>
<p>Equivalent to S.pen but with every element multiplied by its associated smoothing parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.F.list</code></td>
<td>
<p>Equivalent to S.pen but with every element divided by its Frobenius norm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>vector of smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.para</code></td>
<td>
<p>degrees of freedom associated with fully parametric terms (unpenalized)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.smooth</code></td>
<td>
<p>degrees of freedom associated with penalized terms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.tot</code></td>
<td>
<p><code>df.para + df.smooth</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.smf</code></td>
<td>
<p>List of all <code>smf.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.tensor</code></td>
<td>
<p>List of all <code>tensor.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.tint</code></td>
<td>
<p>List of all <code>tint.smooth.spec</code> objects contained in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.smooth</code></td>
<td>
<p>number of smoothing parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.smf</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraints to apply for <code>smf</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.tensor</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraints to apply for <code>tensor</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.tint</code></td>
<td>
<p>List of matrices that represents the sum-to-zero constraints to apply for <code>tint</code> splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.ini</code></td>
<td>
<p>initial set of regression parameters</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
library(survPen)

# standard spline of time with 4 knots

data &lt;- data.frame(time=seq(0,5,length=100),event=1,t0=0)

form &lt;- ~ smf(time,knots=c(0,1,3,5))

t1 &lt;- eval(substitute(time), data)
t0 &lt;- eval(substitute(t0), data)
event &lt;- eval(substitute(event), data)

# The following code sets up everything we need in order to fit the model
model.c &lt;- model.cons(form,lambda=0,data.spec=data,t1=t1,t1.name="time",
t0=rep(0,100),t0.name="t0",event=event,event.name="event",
expected=NULL,expected.name=NULL,type="overall",n.legendre=20,
cl="survPen(form,data,t1=time,event=event)",beta.ini=NULL)

</code></pre>


</div>