<div class="container">

<table style="width: 100%;"><tr>
<td>secrRNG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Random Number Seed </h2>

<h3>Description</h3>

<p>The use of random number seeds in <span class="pkg">secr</span> is explained.
</p>


<h3>Random numbers in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
</h3>

<p><span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> provides several kinds of random number generator (RNG) in the <span class="pkg">base</span> package (see RNG). These are used both explicitly, in functions such as <code>runif</code> and <code>rnorm</code>, and implicitly (<code>sample</code>).
</p>
<p>A seed suitable for any kind of RNG is held in a vector of 626 integers named <code>.Random.seed</code>. The vector is not to be modified directly by users. Instead, to start a reproducible stream of random numbers, the user calls <code>set.seed</code> with a single non-null integer argument. This has the effect of initialising <code>.Random.seed</code>. The value of <code>.Random.seed</code> may nevertheless be stored and restored to reset the RNG state.
</p>
<p><code>set.seed</code> with a NULL argument initialises <code>.Random.seed</code> to an indeterminate (time- and process-dependent) value. The same happens if a random number function is called before <code>.Random.seed</code> has been set.
</p>


<h3>Handling of RNG seed for simulation in package <span class="pkg">stats</span>
</h3>

<p>The ‘official’ approach to setting and storing the RNG seed is shown in code and documentation for the generic function <code>simulate</code> in the <span class="pkg">stats</span> package. 
</p>

<ul>
<li>
<p> The generic has argument ‘seed’ with default NULL. 
</p>
</li>
<li>
<p> If ‘seed’ is non-null then <code>set.seed</code> is called.
</p>
</li>
<li>
<p> The returned value has an attribute “seed” whose value is either (i) if specified, the integer value of the ‘seed’ argument (with its own attribute “kind” from RNGkind), or (ii) the original vector <code>.Random.seed</code>.
</p>
</li>
<li>
<p> On exit the RNG state in <code>.Random.seed</code> is reset to the value that applied when the function was called.
</p>
</li>
</ul>
<p>For NULL seed input, the saved RNGstate may be used to reset .Random.seed (see Examples).
</p>


<h3>Use of random numbers in <span class="pkg">secr</span>
</h3>

<p>Many functions in <span class="pkg">secr</span> call on random numbers, sometimes in unexpected places. For example <code>autoini</code> selects a random sample to thin points and speed computation. In most functions there is no provision for direct control of the random number state: users won't usually care, and if they do then <code>set.seed</code> may be called for the particular <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> session. 
</p>
<p>However, control of the RNG seed is required for reproducible data generation in simulation functions. These functions typically have a ‘seed’ argument that is used internally in a call to <code>set.seed</code>. Handling of seeds in the simulation functions of <span class="pkg">secr</span> largely follows <code>stats::simulate</code> as described in the preceding section.
</p>
<p>The relevant functions are –
</p>

<table>
<tr>
<td style="text-align: left;">
Function </td>
<td style="text-align: left;"> Default </td>
<td style="text-align: left;"> Saved attribute </td>
<td style="text-align: left;"> Note </td>
</tr>
<tr>
<td style="text-align: left;">
<code>randomHabitat</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate</td>
</tr>
<tr>
<td style="text-align: left;">
<code>secr.test</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
<td style="text-align: left;"> calls and retains seed from <code>simulate.secr</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>sim.capthist</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
<td style="text-align: left;">
<code>sim.resight</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
<td style="text-align: left;"> Seed may be passed in ... argument </td>
</tr>
<tr>
<td style="text-align: left;">
<code>sim.popn</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
<td style="text-align: left;">
<code>sim.secr</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
<td style="text-align: left;">
<code>simulate.secr</code> </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> seed or RNGstate </td>
<td style="text-align: left;"> S3 method called by <code>sim.secr</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Setting <code>seed = NULL</code> in any of these functions has the effect of continuing the existing random number stream; it is not the same as calling <code>set.seed(NULL)</code>. 
</p>


<h3>Parallel processing</h3>

<p>Two models are used for parallel processing in <span class="pkg">secr</span>, corresponding to multi-threading with package <span class="pkg">RcppParallel</span> (e.g. <code>secr.fit</code>) and parallel cores in package <span class="pkg">parallel</span> (e.g. <code>chat.nk</code>).
</p>
<p>In the <span class="pkg">parallel</span> model the L'Ecuyer pseudorandom generator is used to provide a separate random number stream for each core (see <code>clusterSetRNGStream</code>).
</p>
<p>When using <span class="pkg">Rcpp</span> the state of the random number generator is set in C++ with the call 
<code>RNGScope scope;</code>that automatically resets the state of the generator on exit (Eddelbuettel 2013 p. 115).
</p>
<p>Random number streams in separate <span class="pkg">RcppParallel</span> threads are (probably) not independent. Thus there are potential issues with RNG calls in multi-threaded code. However, in <span class="pkg">secr</span> 4.0 all RNG calls in C++ code are outside multi-threaded contexts, with the exception of simulations allowing for overdispersion in mark–resight estimates (Rcpp exported function sightingchatcpp). The implications for mark-resight estimates have not been explored, and it is unclear whether more elaborate solutions are needed.
</p>


<h3>References</h3>

<p>Eddelbuettel, D. 2013. Seamless R and C++ integration with Rcpp. Springer.
</p>


<h3>See Also</h3>

<p><code>Parallel</code>,
<code>set.seed</code>, 
<code>simulate</code>, 
<code>sim.capthist</code>, 
<code>sim.popn</code>, 
<code>sim.resight</code>,
<code>secr.test</code>,
<code>simulate.secr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

lmfit &lt;- lm(speed ~ dist, data = cars)

## 1. NULL seed
r1 &lt;- simulate(lmfit, seed = NULL)
r2 &lt;- simulate(lmfit, seed = NULL)
## restore RNGstate, assuming RNGkind unchanged
.Random.seed &lt;- attr(r1, "seed")
r3 &lt;- simulate(lmfit, seed = NULL)
r1[1:6,1]
r2[1:6,1]
r3[1:6,1]

## 2. explicit seed
r4 &lt;- simulate(lmfit, seed = 123)
r5 &lt;- simulate(lmfit, seed = attr(r4, "seed"))
r4[1:6,1]
r5[1:6,1]


## End(Not run)

</code></pre>


</div>