<div class="container">

<table style="width: 100%;"><tr>
<td>MaxEntICABinBin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Use the maximum-entropy approach to compute ICA in the binary-binary setting
</h2>

<h3>Description</h3>

<p>In a surrogate evaluation setting where both <code class="reqn">S</code> and <code class="reqn">T</code> are binary
endpoints, a sensitivity-based approach where multiple 'plausible values' for ICA are retained can be used (see functions <code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Full</code>, or <code>ICA.BinBin.Grid.Sample</code>). Alternatively, the maximum entropy distribution of the vector of potential outcomes
can be considered, based upon which ICA is subsequently computed.
The use of the distribution that maximizes the entropy can be justified
based on the fact that any other distribution would necessarily 
(i) assume information that we do not have, or (ii) contradict information
that we do have. The function <code>MaxEntICABinBin</code> implements the latter approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MaxEntICABinBin(pi1_1_, pi1_0_, pi_1_1,
pi_1_0, pi0_1_, pi_0_1, Method="BFGS", 
Fitted.ICA=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pi1_1_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=1|Z=0)</code>, i.e., the probability that <code class="reqn">S=T=1</code> when under treatment <code class="reqn">Z=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi1_0_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=0|Z=0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_1_1</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=1|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_1_0</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=1,S=0|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi0_1_</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=0,S=1|Z=0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_0_1</code></td>
<td>
<p>A scalar that contains the estimated value for <code class="reqn">P(T=0,S=1|Z=1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>
<p>The maximum entropy frequency vector <code class="reqn">p^{*}</code> is calculated based on the optimal solution to an unconstrained dual convex programming problem (for details, see Alonso et al., 2015). Two different optimization methods can be specified, i.e., <code>Method="BFGS"</code> and <code>Method="CG"</code>, which implement the quasi-Newton BFGS (Broyden, Fletcher, Goldfarb, and Shanno) and the conjugent gradient (CG) methods (for details on these methods, see the help files of the <code>optim()</code> function and the references theirin). 
Alternatively, the <code class="reqn">\pi</code> vector (obtained when the functions <code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Full</code>, or <code>ICA.BinBin.Grid.Sample</code> are executed) that is 'closest' to the vector <code class="reqn">\pi</code> can be retained. Here, the 'closest' vector is defined as the vector where the sum of the squared differences between
the components in the vectors <code class="reqn">\pi</code> and <code class="reqn">\pi</code> is smallest. The latter 'Minimum Difference' method can re requested by specifying the argument <code>Method="MD"</code> in the function call. Default <code>Method="BFGS"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fitted.ICA</code></td>
<td>
<p>A fitted object of class <code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Full</code>, or <code>ICA.BinBin.Grid.Sample</code>. Only required when <code>Method="MD"</code> is used. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>R2_H</code></td>
<td>
<p>The R2_H value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vector_p</code></td>
<td>
<p>The maximum entropy frequency vector <code class="reqn">p^{*}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H_max</code></td>
<td>
<p>The entropy of <code class="reqn">p^{*}</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Wim Van der Elst, Ariel Alonso, &amp; Geert Molenberghs
</p>


<h3>References</h3>

<p>Alonso, A., &amp; Van der Elst, W. (2015). A maximum-entropy approach for the evluation of surrogate endpoints based on causal inference.
</p>


<h3>See Also</h3>

<p><code>ICA.BinBin</code>, <code>ICA.BinBin.Grid.Sample</code>, <code>ICA.BinBin.Grid.Full</code>, <code>plot MaxEntICA BinBin</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sensitivity-based ICA results using ICA.BinBin.Grid.Sample
ICA &lt;- ICA.BinBin.Grid.Sample(pi1_1_=0.341, pi0_1_=0.119, pi1_0_=0.254,
pi_1_1=0.686, pi_1_0=0.088, pi_0_1=0.078, Seed=1, 
Monotonicity=c("No"), M=5000)

# Maximum-entropy based ICA
MaxEnt &lt;- MaxEntICABinBin(pi1_1_=0.341, pi0_1_=0.119, pi1_0_=0.254,
pi_1_1=0.686, pi_1_0=0.088, pi_0_1=0.078)

# Explore maximum-entropy results
summary(MaxEnt)

# Plot results
plot(x=MaxEnt, ICA.Fit=ICA)
</code></pre>


</div>