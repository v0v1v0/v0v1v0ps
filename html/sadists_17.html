<div class="container">

<table style="width: 100%;"><tr>
<td>upsilon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The upsilon distribution.</h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the upsilon distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dupsilon(x, df, t, log = FALSE, order.max=6)

pupsilon(q, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

qupsilon(p, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

rupsilon(n, df, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, q</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the degrees of freedom in the chi square. a vector. we do
<em>not</em> vectorize over this variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>the scaling parameter on the chi. a vector. should be the same
length as <code>df</code>. we do <em>not</em> vectorize over this variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose <code class="reqn">x_i \sim \chi^2\left(\nu_i\right)</code>
independently and independently of <code class="reqn">Z</code>, a standard normal. 
Then 
</p>
<p style="text-align: center;"><code class="reqn">\Upsilon = Z + \sum_i t_i \sqrt{x_i/\nu_i}</code>
</p>

<p>takes an upsilon distribution with parameter vectors
<code class="reqn">[\nu_1, \nu_2, \ldots, \nu_k]', [t_1, t_2, ..., t_k]'</code>.
</p>
<p>The upsilon distribution is used in certain tests of
the Sharpe ratio for independent observations, and generalizes
the lambda prime distribution, which can be written as
<code class="reqn">Z + t \sqrt{x/\nu}</code>.
</p>


<h3>Value</h3>

<p><code>dupsilon</code> gives the density, <code>pupsilon</code> gives the 
distribution function, <code>qupsilon</code> gives the quantile function, 
and <code>rupsilon</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>the PDF and CDF are approximated by an Edgeworth expansion; the
quantile function is approximated by a Cornish-Fisher expansion.
</p>
<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Lecoutre, Bruno. "Another look at confidence intervals for the noncentral t distribution." 
Journal of Modern Applied Statistical Methods 6, no. 1 (2007): 107–116.
<a href="https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm">https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm</a>
</p>
<p>Lecoutre, Bruno. "Two useful distributions for Bayesian predictive procedures under normal models."
Journal of Statistical Planning and Inference 79  (1999): 93–105.
</p>
<p>Pav, Steven. "Inference on the Sharpe ratio via the upsilon distribution.'
Arxiv (2015). 
<a href="https://arxiv.org/abs/1505.00829">https://arxiv.org/abs/1505.00829</a>
</p>


<h3>See Also</h3>

<p>lambda-prime distribution functions, 
<code>dlambdap, plambdap, qlambdap, rlambdap</code>.
Sum of chi-squares to power distribution functions,
<code>dsumchisqpow, psumchisqpow, qsumchisqpow, rsumchisqpow</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">mydf &lt;- c(100,30,50)
myt &lt;- c(-1,3,5)
rv &lt;- rupsilon(500, df=mydf, t=myt)
d1 &lt;- dupsilon(rv, df=mydf, t=myt)

plot(rv,d1)

p1 &lt;- pupsilon(rv, df=mydf, t=myt)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qupsilon(ppoints(length(rv)),df=mydf,t=myt)

qqplot(x=rv,y=q1)


if (require(SharpeR)) {
  ope &lt;- 252
  n.sim &lt;- 500
  n.term &lt;- 3
  set.seed(234234)
  pp &lt;- replicate(n.sim,{
    # these are population parameters 
    a &lt;- rnorm(n.term) 
    psi &lt;- 6 * rnorm(length(a)) / sqrt(ope)
    b &lt;- sum(a * psi)
    df &lt;- 100 + ceiling(200 * runif(length(psi)))
    comm &lt;- 1 / sqrt(sum(a^2 / df))
    cdf &lt;- df - 1
    # now independent draws from the SR distribution:
    x &lt;- rsr(length(df), df, zeta=psi, ope=1)
    # now compute a p-value under the true null
    pupsilon(comm * b,df=cdf,t=comm*a*x) 
  })
  # ought to be uniform:
  plot(ecdf(pp)) 
}

</code></pre>


</div>