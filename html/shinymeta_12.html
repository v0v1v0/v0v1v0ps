<div class="container">

<table style="width: 100%;"><tr>
<td>metaObserve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a meta-reactive observer</h2>

<h3>Description</h3>

<p>Create a <code>observe()</code>r that, when invoked with meta-mode activated
(i.e. called within <code>withMetaMode()</code> or <code>expandChain()</code>), returns a
partially evaluated code expression. Outside of meta-mode,
<code>metaObserve()</code> is equivalent to <code>observe()</code>
(it fully evaluates the given expression).
</p>


<h3>Usage</h3>

<pre><code class="language-R">metaObserve(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  label = NULL,
  domain = getDefaultReactiveDomain(),
  localize = "auto",
  bindToReturn = FALSE
)

metaObserve2(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  label = NULL,
  domain = getDefaultReactiveDomain()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An expression (quoted or unquoted).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>The parent environment for the reactive expression. By default,
this is the calling environment, the same as when defining an ordinary
non-reactive expression. If <code>x</code> is a quosure and <code>quoted</code> is <code>TRUE</code>,
then <code>env</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quoted</code></td>
<td>
<p>If it is <code>TRUE</code>, then the <code>quote()</code>ed value of <code>x</code>
will be used when <code>x</code> is evaluated. If <code>x</code> is a quosure and you
would like to use its expression as a value for <code>x</code>, then you must set
<code>quoted</code> to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>A label for the observer, useful for debugging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>See domains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localize</code></td>
<td>
<p>Whether or not to wrap the returned expression in <code>local()</code>.
The default, <code>"auto"</code>, only wraps expressions with a top-level <code>return()</code>
statement (i.e., return statements in anonymized functions are ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bindToReturn</code></td>
<td>
<p>For non-<code>localize</code>d expressions, should an assignment
of a meta expression be applied to the <em>last child</em> of the top-level <code style="white-space: pre;">⁠\{⁠</code> call?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you wish to capture specific code inside of <code>expr</code> (e.g. ignore code
that has no meaning outside shiny, like <code>req()</code>), use <code>metaObserve2()</code> in combination
with <code>metaExpr()</code>. When using <code>metaObserve2()</code>, <code>expr</code> must return a <code>metaExpr()</code>.
</p>


<h3>Value</h3>

<p>A function that, when called in meta mode (i.e. inside
<code>expandChain()</code>), will return the code in quoted form. If this function is
ever called outside of meta mode, it throws an error, as it is definitely
being called incorrectly.
</p>


<h3>See Also</h3>

<p><code>metaExpr()</code>, <code>..</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# observers execute 'immediately'
x &lt;- 1
mo &lt;- metaObserve({
  x &lt;&lt;- x + 1
})
getFromNamespace("flushReact", "shiny")()
print(x)

# It only makes sense to invoke an meta-observer
# if we're in meta-mode (i.e., generating code)
expandChain(mo())

# Intentionally produces an error
## Not run: mo()

</code></pre>


</div>