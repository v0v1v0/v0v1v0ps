<div class="container">

<table style="width: 100%;"><tr>
<td>twinstim_iafplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot the Spatial or Temporal Interaction Function of a <code>twimstim</code>
</h2>

<h3>Description</h3>

<p>The function plots the fitted temporal or (isotropic) spatial
interaction function of a <code>twinstim</code> object.
The implementation is illustrated in Meyer et al. (2017, Section 3),
see <code>vignette("twinstim")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">iafplot(object, which = c("siaf", "tiaf"), types = NULL,
        scaled = c("intercept", "standardized", "no"), truncated = FALSE,
        log = "", conf.type = if (length(pars) &gt; 1) "MC" else "parbounds",
        conf.level = 0.95, conf.B = 999, xgrid = 101,
        col.estimate = rainbow(length(types)), col.conf = col.estimate,
        alpha.B = 0.15, lwd = c(3,1), lty = c(1,2),
        verticals = FALSE, do.points = FALSE,
        add = FALSE, xlim = NULL, ylim = NULL, xlab = NULL, ylab = NULL,
        legend = !add &amp;&amp; (length(types) &gt; 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>object of class <code>"twinstim"</code> containing the fitted model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p>argument indicating which of the two interaction functions to plot.
Possible values are <code>"siaf"</code> (default) for the spatial interaction
<code class="reqn">f(x)</code> as a function of the distance <code class="reqn">x</code>, and <code>"tiaf"</code>
for the temporal interaction function <code class="reqn">g(t)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>types</code></td>
<td>

<p>integer vector indicating for which event <code>types</code> 
the interaction function should be plotted in case of a marked
<code>"twinstim"</code>. The default <code>types=NULL</code> checks if the interaction
function is type-specific: if so, <code>types=1:nrow(object$qmatrix)</code>
is used, otherwise <code>types=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaled</code></td>
<td>

<p>character string determining if/how the the interaction function
should be scaled. Possible choices are:
</p>

<dl>
<dt>"intercept":</dt>
<dd>
<p>multiplication by the epidemic intercept.</p>
</dd>
<dt>"standardized":</dt>
<dd>
<p>division by the value at 0 distance such
that the function starts at 1.</p>
</dd>
<dt>"no":</dt>
<dd>
<p>no scaling.</p>
</dd>
</dl>
<p>The first one is the default and required for the comparison of
estimated interaction functions from different models.
For backward compatibility, <code>scaled</code> can also be a boolean,
where <code>TRUE</code> refers to <code>"intercept"</code> scaling and
<code>FALSE</code> to <code>"no"</code> scaling.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truncated</code></td>
<td>

<p>logical indicating if the plotted interaction function should
take the maximum range of interaction (<code>eps.t</code>/<code>eps.s</code>)
into account, i.e., drop to zero at that point (if it is finite
after all). If there is no common range of interaction, a
<code>rug</code> indicating the various ranges will 
be added to the plot if <code>truncated=TRUE</code>.
If <code>truncated</code> is a scalar, this value is used as the point
<code>eps</code> where the function drops to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>a character string passed to <code>plot.default</code>
indicating which axes should be logarithmic.
If <code>add=TRUE</code>, <code>log</code> is set according to
<code>par("xlog")</code> and <code>par("ylog")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.type</code></td>
<td>

<p>type of confidence interval to produce.<br>
If <code>conf.type="MC"</code> (or <code>"bootstrap"</code>), <code>conf.B</code>
parameter vectors are sampled from the asymptotic
(multivariate) normal distribution of the ML estimate of the
interaction function parameters; the interaction function is then
evaluated on the <code>xgrid</code> (i.e. temporal or spatial distances
from the host) for each parameter realization to obtain a
<code>conf.level</code> confidence interval at each point of the
<code>xgrid</code> (or to plot the interaction functions of all
Monte-Carlo samples if <code>conf.level=NA</code>).
Note that the resulting plot is <code>.Random.seed</code>-dependent
for the Monte-Carlo type of confidence interval.<br>
If <code>conf.type="parbounds"</code>, the <code>conf.level</code> Wald confidence
intervals for the interaction function parameters are calculated and
the interaction function is evaluated on the <code>xgrid</code>
(distances from the host) for all combinations of the bounds
of the parameters and the point-wise extremes of those functions are
plotted. This type of confidence interval is only valid in case of
a single parameter, i.e. <code>scaled + nsiafpars == 1</code>, but could
also be used as a rough indication if the Monte-Carlo approach takes
too long. A warning is thrown if the <code>"parbounds"</code> type is used
for multiple parameters.<br> 
If <code>conf.type="none"</code> or <code>NA</code> or <code>NULL</code>, no
confidence interval will be calculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level required. For <code>conf.type = "MC"</code> it
may also be specified as <code>NA</code>, in which case all <code>conf.B</code>
sampled functions will be plotted with transparency value given
by <code>alpha.B</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.B</code></td>
<td>

<p>number of samples for the <code>"MC"</code> (Monte Carlo)
confidence interval.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xgrid</code></td>
<td>

<p>either a numeric vector of x-values (distances from the host) where
to evaluate <code>which</code>, or a scalar representing the desired number of
evaluation points in the interval <code>c(0,xlim[2])</code>.<br>
If the interaction function is a step function
(<code>siaf.step</code> or <code>tiaf.step</code>), <code>xgrid</code>
is ignored and internally set to <code>c(0, knots)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.estimate</code></td>
<td>

<p>vector of colours to use for the function point estimates of the different <code>types</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.conf</code></td>
<td>

<p>vector of colours to use for the confidence intervals of the different <code>types</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.B</code></td>
<td>

<p>alpha transparency value (as relative opacity) used for the <code>conf.B</code>
sampled interaction functions in case <code>conf.level = NA</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd, lty</code></td>
<td>

<p>numeric vectors of length two specifying the line width and type of point
estimates (first element) and confidence limits (second element),
respectively. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verticals,do.points</code></td>
<td>
<p>graphical settings for step function
kernels. These can be logical (as in <code>plot.stepfun</code>) or
lists of graphical parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>

<p>add to an existing plot?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim, ylim</code></td>
<td>

<p>vectors of length two containing the x- and y-axis limit of the
plot. The default y-axis range (<code>ylim=NULL</code>) is from 0 to the
value of the (scaled) interaction function at <code class="reqn">x = 0</code>.
The default x-axis (<code>xlim=NULL</code>) starts at 0, and the upper
limit is determined as follows (in decreasing order of precedence):
</p>

<ul>
<li>
<p> If <code>xgrid</code> is a vector of evaluation points, <code>xlim[2]</code> is
set to <code>max(xgrid)</code>.
</p>
</li>
<li> <p><code>eps.t</code>/<code>eps.s</code> if it is unique and finite.
</p>
</li>
<li>
<p> If the interaction function is a step function with
<code>maxRange&lt;Inf</code>, i.e. it drops to 0 at <code>maxRange</code>,
<code>xlim[2]</code> is set to <code>maxRange</code>.
</p>
</li>
<li>
<p> Otherwise, it is set to the length of the observation period
(<code>which="tiaf"</code>) or the diagonal length of the bounding box of
the observation region (<code>which="siaf"</code>), respectively.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>

<p>labels for the axes with <code>NULL</code> providing sensible defaults.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>

<p>logical indicating if a legend for the <code>types</code> should be added.
It can also be a list of arguments passed to <code>legend</code>
to tweak the default settings.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the default <code>plot</code> method.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A plot is created – see e.g. Figure 3(b) in Meyer et al. (2012).
</p>
<p>The function invisibly returns a matrix of the plotted values of the
interaction function (evaluated on <code>xgrid</code>, by type). The first
column of the matrix contains the distance <code class="reqn">x</code>, and the remaining
<code>length(types)</code> columns contain the (scaled) function values for
each type.
</p>
<p>The pointwise confidence intervals of the interaction functions are
returned in similar matrices as attributes: if
<code>length(types)==1</code>, there is a single attribute <code>"CI"</code>,
whereas for multiple types, the attributes are named
<code>paste0("CI.",typeNames)</code> (where the <code>typeNames</code> are
retrieved from <code>object$qmatrix</code>).
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>References</h3>

<p>Meyer, S., Elias, J. and Höhle, M. (2012):
A space-time conditional intensity model for invasive meningococcal
disease occurrence. <em>Biometrics</em>, <b>68</b>, 607-616.
<a href="https://doi.org/10.1111/j.1541-0420.2011.01684.x">doi:10.1111/j.1541-0420.2011.01684.x</a>
</p>
<p>Meyer, S., Held, L. and Höhle, M. (2017):
Spatio-temporal analysis of epidemic phenomena using the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package
<span class="pkg">surveillance</span>.
<em>Journal of Statistical Software</em>, <b>77</b> (11), 1-55.
<a href="https://doi.org/10.18637/jss.v077.i11">doi:10.18637/jss.v077.i11</a>
</p>


<h3>See Also</h3>

<p><code>plot.twinstim</code>, which calls this function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("imdepifit")

iafplot(imdepifit, "tiaf", scaled=FALSE)   # tiaf.constant(), not very exciting
iafplot(imdepifit, "siaf", scaled=FALSE)

# scaled version uses a Monte-Carlo-CI
set.seed(1)  # result depends on .Random.seed
iafplot(imdepifit, "siaf", scaled=TRUE, conf.type="MC", conf.B=199,
        col.conf=gray(0.4), conf.level=NA)  # show MC samples
</code></pre>


</div>