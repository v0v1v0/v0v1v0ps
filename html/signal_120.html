<div class="container">

<table style="width: 100%;"><tr>
<td>sftrans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Transform filter band edges </h2>

<h3>Description</h3>

<p>Transform band edges of a generic lowpass filter to a filter with
different band edges and to other filter types (high pass, band pass, or
band stop).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
sftrans(Sz, Sp, Sg, W, stop = FALSE, ...)

## S3 method for class 'Arma'
sftrans(Sz, W, stop = FALSE, ...)

## S3 method for class 'Zpg'
sftrans(Sz, W, stop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sz</code></td>
<td>
<p> In the generic case, a model to be transformed. In the
default case, a vector containing the zeros in a pole-zero-gain model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p> a vector containing the poles in a pole-zero-gain model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sg</code></td>
<td>
<p> a vector containing the gain in a pole-zero-gain model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p> critical frequencies of the target filter specified in
radians. <code>W</code> must be a
scalar for low-pass and high-pass filters, and <code>W</code> must be a
two-element vector <code>c(low, high)</code> specifying the lower and
upper bands. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop</code></td>
<td>
 <p><code>FALSE</code> for a low-pass or band-pass filter,
<code>TRUE</code> for a high-pass or band-stop filter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments (ignored). </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a low pass filter represented by poles and zeros in the
splane, you can convert it to a low pass, high pass, band pass or 
band stop by transforming each of the poles and zeros individually.
The following summarizes the transformations:
</p>
<p>Low-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C S/Fc</code>
</p>


<table>
<tr>
<td style="text-align: left;">
Zero at x           </td>
<td style="text-align: left;"> Pole at x         </td>
</tr>
<tr>
<td style="text-align: left;">
zero: <code class="reqn">F_c x/C</code>  </td>
<td style="text-align: left;"> <code class="reqn">F_c x/C</code>
</td>
</tr>
<tr>
<td style="text-align: left;"> 
gain: <code class="reqn">C/F_c</code>    </td>
<td style="text-align: left;"> <code class="reqn">F_c/C</code>  </td>
</tr>
<tr>
<td style="text-align: left;"> 
</td>
</tr>
</table>
<p>High-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C F_c/S</code>
</p>


<table>
<tr>
<td style="text-align: left;">
Zero at x           </td>
<td style="text-align: left;"> Pole at x   </td>
</tr>
<tr>
<td style="text-align: left;">
zero: <code class="reqn">F_c C/x</code>  </td>
<td style="text-align: left;"> <code class="reqn">F_c C/x</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
pole: <code class="reqn">0</code>       </td>
<td style="text-align: left;"> <code class="reqn">0</code>     </td>
</tr>
<tr>
<td style="text-align: left;"> 
gain: <code class="reqn">-x</code>      </td>
<td style="text-align: left;"> <code class="reqn">-1/x</code>  </td>
</tr>
<tr>
<td style="text-align: left;"> 
</td>
</tr>
</table>
<p>Band-Pass Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C \frac{S^2+F_hF_l}{S(F_h-F_l)}</code>
</p>


<table>
<tr>
<td style="text-align: left;">
Zero at x                         </td>
<td style="text-align: left;"> Pole at x                 </td>
</tr>
<tr>
<td style="text-align: left;">
zero: <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code>
</td>
<td style="text-align: left;"> <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
pole: <code class="reqn">0</code>                     </td>
<td style="text-align: left;"> <code class="reqn">0</code>                   </td>
</tr>
<tr>
<td style="text-align: left;"> 
gain: <code class="reqn">C/(F_h-F_l)</code>           </td>
<td style="text-align: left;"> <code class="reqn">(F_h-F_l)/C</code>         </td>
</tr>
<tr>
<td style="text-align: left;">
<code class="reqn">b = x/C (F_h-F_l)/2</code>         </td>
<td style="text-align: left;"> <code class="reqn">b=x/C (F_h-F_l)/2</code>   </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Band-Stop Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; C \frac{S(F_h-F_l)}{S^2+F_hF_l}</code>
</p>


<table>
<tr>
<td style="text-align: left;">
Zero at x                         </td>
<td style="text-align: left;"> Pole at x                 </td>
</tr>
<tr>
<td style="text-align: left;">
zero: <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code>
</td>
<td style="text-align: left;"> <code class="reqn">b \pm \sqrt(b^2-F_hF_l)</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
pole: <code class="reqn">\pm \sqrt(-F_hF_l)</code>     </td>
<td style="text-align: left;"> <code class="reqn">\pm \sqrt(-F_hF_l)</code>      </td>
</tr>
<tr>
<td style="text-align: left;"> 
gain: <code class="reqn">-x</code>                    </td>
<td style="text-align: left;"> <code class="reqn">-1/x</code>                </td>
</tr>
<tr>
<td style="text-align: left;">
<code class="reqn">b = C/x (F_h-F_l)/2</code>         </td>
<td style="text-align: left;"> <code class="reqn">b=C/x (F_h-F_l)/2</code>   </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Bilinear Transform         
</p>
<p style="text-align: center;"><code class="reqn">S -&gt; \frac{2}{T} \frac{z-1}{z+1}</code>
</p>


<table>
<tr>
<td style="text-align: left;">
Zero at x                       </td>
<td style="text-align: left;"> Pole at x               </td>
</tr>
<tr>
<td style="text-align: left;">
zero: <code class="reqn">(2+xT)/(2-xT)</code>       </td>
<td style="text-align: left;"> <code class="reqn">(2+xT)/(2-xT)</code>     </td>
</tr>
<tr>
<td style="text-align: left;">
pole: <code class="reqn">-1</code>                  </td>
<td style="text-align: left;"> <code class="reqn">-1</code>                </td>
</tr>
<tr>
<td style="text-align: left;"> 
gain: <code class="reqn">(2-xT)/T</code>            </td>
<td style="text-align: left;"> <code class="reqn">(2-xT)/T</code>          </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>where <code class="reqn">C</code> is the cutoff frequency of the initial lowpass filter, <code class="reqn">F_c</code> is
the edge of the target low/high pass filter and <code class="reqn">[F_l,F_h]</code> are the edges
of the target band pass/stop filter.  With abundant tedious algebra,
you can derive the above formulae yourself by substituting the
transform for <code class="reqn">S</code> into <code class="reqn">H(S)=S-x</code> for a zero at <code class="reqn">x</code> or <code class="reqn">H(S)=1/(S-x)</code> for a
pole at <code class="reqn">x</code>, and converting the result into the form:
</p>
<p style="text-align: center;"><code class="reqn">H(S) = g \mbox{prod}(S-Xi) / \mbox{prod}(S-Xj)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel.
This is significant for High Pass, Band Pass and Band Stop filters
which create numerous extra poles and zeros, most of which cancel.
Those which do not cancel have a ‘fill-in’ effect, extending the 
shorter of the sets to have the same number of as the longer of the
sets of poles and zeros (or at least split the difference in the case
of the band pass filter).  There may be other opportunistic
cancellations, but it does not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in
an unstable filter.  Because of cancellation, this will only happen
if the number of poles is smaller than the number of zeros and the
filter is high pass or band pass.  The analytic design methods all
yield more poles than zeros, so this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for <code>sftrans.Zpg</code>, an object of class
“Zpg”, containing the list elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>zero</code></td>
<td>
<p> complex vector of the zeros of the transformed model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pole</code></td>
<td>
<p> complex vector of the poles of the transformed model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gain</code></td>
<td>
<p> gain of the transformed model</p>
</td>
</tr>
</table>
<p>For <code>sftrans.Arma</code>, an object of class
“Arma”, containing the list elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p> moving average (MA) polynomial coefficients </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p> autoregressive (AR) polynomial coefficients </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

<p> Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New York:
Macmillan Publishing Company.
</p>
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code>Zpg</code>, <code>bilinear</code>,
<code>Arma</code></p>


</div>