<div class="container">

<table style="width: 100%;"><tr>
<td>extract_saccades</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract saccades from samples using votes from selected methods.</h2>

<h3>Description</h3>

<p>Extract saccades from samples using votes from selected methods. Each method votes whether
a given sample belongs to a saccade. Next, saccades are identified via a majority vote using the 
<code>vote_threshold</code> parameter, as well as a minimum duration and minimal temporal separation criteria.
Please note that units of the gaze samples must be in  <strong>degrees of visual angle</strong>. The units are important
as some methods use specific (e.g., physiologically plausible) velocity and acceleration thresholds.
</p>
<p>By default, ensemble includes methods proposed by Engbert &amp; Kliegl (2003) (<code>"ek"</code>),
Otero-Millan et al. (<code>"om"</code>), and Nyström &amp; Holmqvist (2010) (<code>"nh"</code>), 
see <em>Implemented Methods</em> vignette. However, it can be extended
via custom methods, see <em>Using Custom Methods</em> vignette.
</p>
<p>By default, the function returns a table with identified saccades but can return a matrix with methods' votes
per sample instead (<code>return_votes = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">extract_saccades(
  x,
  y,
  sample_rate,
  trial = NULL,
  methods = list(method_ek, method_om, method_nh),
  velocity_function = saccadr::diff_ek,
  options = NULL,
  binocular = "merge",
  vote_threshold = ifelse(length(methods) == 1, 1, (length(methods) - 1)),
  minimal_duration_ms = 12,
  minimal_separation_ms = 12,
  return_votes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Horizontal coordinate, either a vector for monocular data or a two-column matrix for binocular data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vertical coordinate, either a vector for monocular data or a two-column matrix for binocular data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_rate</code></td>
<td>
<p>Sampling rate in Hz. It is assumed to be common for the entire time series.
If the time series contains chunks (trials) that were recorded using different acquisition rate
(e.g., SR Research Eyelink allows to set different acquisition rate for each recording / trial),
you would need to split the time series and analyze them separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trial</code></td>
<td>
<p>Optional vector with trial ID. If omitted, all samples are assumed to belong to a single trial.
Velocity, acceleration, and saccades themselves are computed respecting trial borders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>A list with saccade detection methods, can include external functions that
implement sample classification (see <em>Using Custom Methods</em> vignette). Package methods include
Engbert &amp; Kliegl (2003) (<code>method_ek</code>), Otero-Millan et al. (2014) (<code>method_om</code>), 
Nyström and Holmqvist (2010) (<code>method_nh</code>). Defaults to the list of all internally implemented
methods: <code>list(method_ek, method_om, method_nh)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>velocity_function</code></td>
<td>
<p>A handle to a function to compute velocity and acceleration. Defaults to a method
suggested by Engbert &amp; Kliegl (2003) <code>diff_ek</code>. The package also implements the method proposed
by Nyström and Holmqvist (2010) <code>diff_nh</code>. See vignette "Velocity computation" for details and
information on how to implement a custom method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>A named list with options for saccade detection (see <code>method_ek</code>, <code>method_om</code>,
<code>method_nh</code>) and velocity (<code>diff_ek</code>, <code>diff_nh</code>) computation.
See documentation on specific method for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binocular</code></td>
<td>
<p>Specifies how a binocular data is treated. Options are <code>"cyclopean"</code> (binocular data is
converted to an average cyclopean image before saccades are extracted), <code>"monocular"</code> (saccades
are extracted independently for each eye), <code>"merge"</code> (default, sample votes are obtained from both eyes and
for all methods and then averaged. This way only binocular saccades, i.e., eye movements with a sufficient temporal
overlap between eyes, are detected.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vote_threshold</code></td>
<td>
<p>Value between 1 and N (where N is number of used methods) defining a vote threshold for a
saccade. By default, all but one method <code class="reqn">threshold = N-1</code> must agree for a sample to be considered for a saccade.
Threshold of 1 is applied if a single method is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimal_duration_ms</code></td>
<td>
<p>Minimal duration of a saccade in milliseconds. Shorter candidate saccades are discarded,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimal_separation_ms</code></td>
<td>
<p>Minimal time separation between saccades in milliseconds. Saccades that are
separated by a shorter interval of "not a saccade" votes, will be merged including that period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_votes</code></td>
<td>
<p>Logical. Whether function should return extracted microsaccades (<code>FALSE</code>, default)
or votes per sample (<code>TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Variables that describe saccade
</p>

<ul>
<li>
<p><code>Trial</code> Trial index.
</p>
</li>
<li>
<p><code>Eye</code> <code>"Monocular"</code> for monocular inputs. <code>"Cyclopean"</code> for binocular data that
was averaged <em>before</em> applying algorithms. <code>"Binocular"</code> for binocular data with votes
averaged <em>after</em> applying algorithms. <code>"Left"</code> or <code>"Right"</code> for binocular data
when eyes are processed independently.
</p>
</li>
<li>
<p><code>OnsetSample</code> Index of the first sample.
</p>
</li>
<li>
<p><code>OffsetSample</code> Index of the last sample.
</p>
</li>
<li>
<p><code>Onset</code> Onset time relative to the trial start in milliseconds.
</p>
</li>
<li>
<p><code>Offset</code> Offset time relative to the trial start in milliseconds.
</p>
</li>
<li>
<p><code>Duration</code> Duration in milliseconds.
</p>
</li>
<li>
<p><code>DisplacementX</code> Horizontal displacement measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li>
<p><code>DisplacementY</code> Vertical displacement measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li>
<p><code>Displacement</code> Displacement magnitude measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li>
<p><code>DisplacementPhi</code> Displacement direction measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li>
<p><code>AmplitudeX</code> Horizontal displacement measured from the <em>leftmost</em> to the <em>rightmost</em> sample.
</p>
</li>
<li>
<p><code>AmplitudeY</code> Vertical displacement measured from the <em>lowest</em> to the <em>uppermost</em> sample.
</p>
</li>
<li>
<p><code>Amplitude</code> Displacement magnitude measured from the most extreme samples.
</p>
</li>
<li>
<p><code>AmplitudePhi</code> Displacement direction measured from the most extreme samples.
</p>
</li>
<li>
<p><code>VelocityPeak</code> Peak velocity.
</p>
</li>
<li>
<p><code>VelocityAvg</code> Average velocity.
</p>
</li>
<li>
<p><code>AccelerationPeak</code> Peak acceleration.
</p>
</li>
<li>
<p><code>AccelerationAvg</code> Average acceleration.
</p>
</li>
<li>
<p><code>AccelerationStart</code> Peak acceleration <em>before</em> peak velocity was reached.
</p>
</li>
<li>
<p><code>AccelerationStop</code> Peak acceleration <em>after</em> peak velocity was reached.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>data.frame</code> with saccade properties (see <strong>details</strong>), if <code>return_votes = FALSE</code>.
Alternatively, it returns votes per sample (<code>return_votes = TRUE</code>). For a monocular processing (monocular
input, cyclopean or merged binocular data) it is a matrix with <code>nrow(x)</code> rows and <code>length(methods)</code>
columns with 0/1 votes for each sample and method. For binocular processing, function returns a two element <code>list</code> with
the similar matrices but per eye.
</p>


<h3>See Also</h3>

<p><code>method_ek</code>, <code>method_om</code>, <code>method_nh</code>, <code>diff_ek</code>, <code>diff_nh</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Single trial
data(single_trial)
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500)

# Multiple trials
data(monocular_ten_trials)
saccades &lt;- extract_saccades(monocular_ten_trials$x,
                             monocular_ten_trials$y, 
                             500,
                             trial = monocular_ten_trials$trial)
 
 # binocular saccades                            
 data("single_trial_binocular")
 saccades_b &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                         single_trial_binocular[, c('yL', 'yR')],
                                         sample_rate = 1000)
                                         
 # cyclopean saccades from binocular data
saccades_c &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                        single_trial_binocular[, c('yL', 'yR')],
                                        sample_rate = 1000,
                                        binocular = "cyclopean")

 # monocular saccades from binocular data
saccades_m &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                       single_trial_binocular[, c('yL', 'yR')],
                                       sample_rate = 1000,
                                       binocular = "monocular")
                             
# Using a single method
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, methods = method_om)

# Using two methods
saccades &lt;- extract_saccades(single_trial$x,
                             single_trial$y,
                             500,
                             methods = list(method_ek, method_om))

#  Alternative velocity computation method
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, velocity_function = diff_nh)

# A strict unanimous decision threshold
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, vote_threshold = 3)

# A slacker criterion that at least one of the three methods must label sample as a saccade
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, vote_threshold = 1)

# Only longish saccades are extracted
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, minimal_duration_ms = 20)
</code></pre>


</div>