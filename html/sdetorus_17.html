<div class="container">

<table style="width: 100%;"><tr>
<td>dPsTpd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapped Euler and Shoji–Ozaki pseudo-transition probability densities</h2>

<h3>Description</h3>

<p>Wrapped pseudo-transition probability densities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dPsTpd(x, x0, t, method = c("E", "SO", "SO2"), b, jac.b, sigma2, b1, b2,
  circular = TRUE, maxK = 2, vmApprox = FALSE, twokpi = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>. If a vector is provided, is
assumed that <code>p = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>. If all <code>x0</code> are the
same, a matrix of dimension <code>c(1, p)</code> can be passed for better
performance. If a vector is provided, is assumed that <code>p = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>time step between <code>x</code> and <code>x0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string for choosing <code>"E"</code> (Euler), <code>"SO"</code>
(Shoji–Ozaki) or <code>"SO2"</code> (Shoji–Ozaki with Ito's expansion in the
drift) method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>drift function. Must return a matrix of the same size as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jac.b</code></td>
<td>
<p>jacobian of the drift function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>diagonal of the diffusion matrix (if univariate, this is the
square of the diffusion coefficient). Must return an object of the same
size as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>first derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b2</code></td>
<td>
<p>second derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circular</code></td>
<td>
<p>flag to indicate circular data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vmApprox</code></td>
<td>
<p>flag to indicate von Mises approximation to wrapped normal.
See<br><code>momentMatchWnVm</code> and <code>scoreMatchWnBvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twokpi</code></td>
<td>
<p>optional matrix of winding numbers to avoid its recomputation.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to <code>b</code>, <code>b1</code>, <code>b2</code>,
<code>jac.b</code> and <code>sigma2</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See Section 3.2 in García-Portugués et al. (2019) for details.
<code>"SO2"</code> implements Shoji and Ozai (1998)'s expansion with for
<code>p = 1</code>. <code>"SO"</code> is the same expansion, for arbitrary <code>p</code>, but
considering null second derivatives.
</p>
<p><code>twokpi</code> is <code>repRow(2 * pi * c(-maxK:maxK), n = n)</code> if <code>p = 1</code>
and<br><code>as.matrix(do.call(what = expand.grid,
args = rep(list(2 * pi * c(-maxK:maxK)), p)))</code> otherwise.
</p>


<h3>Value</h3>

<p>Output from <code>mleOptimWrapper</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1–22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>
<p>Shoji, I. and Ozaki, T. (1998) A statistical method of estimation and
simulation for systems of stochastic differential equations.
<em>Biometrika</em>, 85(1):240–243. <a href="https://doi.org/10.1093/biomet/85.1.240">doi:10.1093/biomet/85.1.240</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># 1D
grid &lt;- seq(-pi, pi, l = 501)[-501]
alpha &lt;- 1
sigma &lt;- 1
t &lt;- 0.5
x0 &lt;- pi/2
# manipulate::manipulate({

  # Drifts
  b &lt;- function(x) driftWn1D(x = x, alpha = alpha, mu = 0, sigma = sigma)
  b1 &lt;- function(x, h = 1e-4) {
    l &lt;- length(x)
    res &lt;- driftWn1D(x = c(x + h, x - h), alpha = alpha, mu = 0,
                     sigma = sigma)
    drop(res[1:l] - res[(l + 1):(2 * l)])/(2 * h)
  }
  b2 &lt;- function(x, h = 1e-4) {
    l &lt;- length(x)
    res &lt;- driftWn1D(x = c(x + h, x, x - h), alpha = alpha, mu = 0,
                     sigma = sigma)
    drop(res[1:l] - 2 * res[(l + 1):(2 * l)] +
          res[(2 * l + 1):(3 * l)]) / (h^2)
  }

  # Squared diffusion
  sigma2 &lt;- function(x) rep(sigma^2, length(x))

  # Plot
  plot(grid, dTpdPde1D(Mx = length(grid), x0 = x0, t = t, alpha = alpha,
                       mu = 0, sigma = sigma), type = "l",
       ylab = "Density", xlab = "", ylim = c(0, 0.75), lwd = 2)
  lines(grid, dTpdWou1D(x = grid, x0 = rep(x0, length(grid)), t = t,
                       alpha = alpha, mu = 0, sigma = sigma), col = 2)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "E", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2), col = 3)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2), col = 4)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO2", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2),
        col = 5)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "E", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 6)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 7)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO2", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 8)
  legend("topright", legend = c("PDE", "WOU", "E", "SO1", "SO2", "EvM",
                                "SO1vM", "SO2vM"), lwd = 2, col = 1:8)

# }, x0 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# alpha = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# sigma = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# t = manipulate::slider(0.1, 5, step = 0.1, initial = 1))

# 2D
grid &lt;- seq(-pi, pi, l = 76)[-76]
alpha1 &lt;- 2
alpha2 &lt;- 1
alpha3 &lt;- 0.5
sig1 &lt;- 1
sig2 &lt;- 2
t &lt;- 0.5
x01 &lt;- pi/2
x02 &lt;- -pi/2
# manipulate::manipulate({

  alpha &lt;- c(alpha1, alpha2, alpha3)
  sigma &lt;- c(sig1, sig2)
  x0 &lt;- c(x01, x02)

  # Drifts
  b &lt;- function(x) driftWn2D(x = x, A = alphaToA(alpha = alpha,
                                                 sigma = sigma),
                             mu = rep(0, 2), sigma = sigma)
  jac.b &lt;- function(x, h = 1e-4) {
    l &lt;- nrow(x)
    res &lt;- driftWn2D(x = rbind(cbind(x[, 1] + h, x[, 2]),
                               cbind(x[, 1] - h, x[, 2]),
                               cbind(x[, 1], x[, 2] + h),
                               cbind(x[, 1], x[, 2] - h)),
                     A = alphaToA(alpha = alpha, sigma = sigma),
                     mu = rep(0, 2), sigma = sigma)
    cbind(res[1:l, ] - res[(l + 1):(2 * l), ],
          res[2 * l + 1:l, ] - res[2 * l + (l + 1):(2 * l), ]) / (2 * h)
  }

  # Squared diffusion
  sigma2 &lt;- function(x) matrix(sigma^2, nrow = length(x) / 2L, ncol = 2)

  # Plot
  old_par &lt;- par(mfrow = c(3, 2))
  plotSurface2D(grid, grid, z = dTpdPde2D(Mx = length(grid),
                                          My = length(grid), x0 = x0,
                                          t = t, alpha = alpha,
                                          mu = rep(0, 2), sigma = sigma),
                levels = seq(0, 1, l = 20), main = "Exact")
  plotSurface2D(grid, grid,
                f = function(x) drop(dTpdWou2D(x = x,
                                               x0 = repRow(x0, nrow(x)),
                                               t = t, alpha = alpha,
                                               mu = rep(0, 2),
                                               sigma = sigma)),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "WOU")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "E", b = b, jac.b = jac.b,
                                       sigma2 = sigma2),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "E")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "SO", b = b, jac.b = jac.b,
                                       sigma2 = sigma2),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "SO")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "E", b = b, jac.b = jac.b,
                                       sigma2 = sigma2, vmApprox = TRUE),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "EvM")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "SO", b = b, jac.b = jac.b,
                                       sigma2 = sigma2, vmApprox = TRUE),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "SOvM")
  par(old_par)

# }, x01 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# x02 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# alpha1 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# alpha2 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# alpha3 = manipulate::slider(-5, 5, step = 0.1, initial = 0),
# sig1 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# sig2 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# t = manipulate::slider(0.01, 5, step = 0.01, initial = 1))
</code></pre>


</div>