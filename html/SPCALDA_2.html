<div class="container">

<table style="width: 100%;"><tr>
<td>SPCALDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A New Reduced-Rank Linear Discriminant Analysis Method
</h2>

<h3>Description</h3>

<p>A new reduced-rank LDA method which works for high dimensional multi-class data. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">SPCALDA(X,Y,rho=exp(c((-2):6)),K=min(20,min(dim(X))), folds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Input matrix, of dimension nobs x nvars; each row is an observation vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>Response variable for class label, of dimension nobs x 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>

<p>Tuning parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>The total number of principal components considered.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>

<p>Folds for cross-validation to select tuning parameter.
</p>
</td>
</tr>
</table>
<h3>Value</h3>



<table>
<tr style="vertical-align: top;">
<td><code>ob</code></td>
<td>
<p>lda rule with top PCs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuneRotation</code></td>
<td>
<p>Tuned rotaion matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minerror</code></td>
<td>
<p>Minimal training error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>tuned value of the parameter rho</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>tuned dimension, i.e., number of PCs</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yue S. Niu, Ning Hao and Bin Dong
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(2015)
n = 200;p = 500

X = matrix(rnorm(n*p),n,p)
mu=matrix(0,4,p)
mu[1,1:125]=0.4;mu[2,126:250]=0.4;mu[3,251:375]=0.4;mu[4,376:500]=0.4
Y = rep(1:4,50)

for (g in 1:4) {
        index = which(Y == g)
        n_g = length(index)
        X[index,] = X[index,] + matrix(mu[g,],n_g,p,byrow=TRUE)
}

xtr = X[1:100,]; ytr=Y[1:100] #traning set
xte = X[101:200,]; yte =Y[101:200] # test set
folds = list(1:20,21:40,41:60,61:80,81:100)

spcaldaResult = SPCALDA(X=xtr,Y=ytr,rho=exp(c((-2):6)),K=20, folds = folds)
yhat = predict(spcaldaResult$ob,xte%*%spcaldaResult$tuneRotation)$class
error = sum(yhat != yte) 
 
</code></pre>


</div>