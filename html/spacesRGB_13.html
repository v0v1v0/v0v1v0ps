<div class="container">

<table style="width: 100%;"><tr>
<td>Basic Parameterized TransferFunctions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Basic Parameterized TransferFunctions
</h2>

<h3>Description</h3>

<p>Each of these functions <em>returns</em> a <code>TransferFunction</code> object,
that depends on the argument values passed to it.
The returned object has the parameter values "locked in".
These <code>TransferFunction</code> objects are a mixture of EOTFs, OETFs, OOTFs, and general-purpose transfer functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">power.OETF( gamma )
power.EOTF( gamma )
power.OOTF( gamma )
BT.1886.EOTF( gamma=2.4, Lb=0, Lw=1 )
XYZfromRGB.TF( primaries, white )
affine.TF( y0, y1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>the value of <code class="reqn">\gamma</code>; it must be positive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lb</code></td>
<td>
<p>the black level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lw</code></td>
<td>
<p>the white level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>primaries</code></td>
<td>
<p>a 3x2 or 4x2 matrix; see <b>Details</b></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>white</code></td>
<td>
<p>a vector of length 1, 2, or 3; see <b>Details</b></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y0</code></td>
<td>
<p>the number to which 0 maps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y1</code></td>
<td>
<p>the number to which 1 maps</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are 3 valid combinations of <code>primaries</code> and <code>white</code>, as given in this table:
</p>

<table>
<tr>
<td style="text-align: center;">
<code>dim(primaries)</code>  </td>
<td style="text-align: center;"> <code>length(white)</code> </td>
<td style="text-align: left;"> Description </td>
</tr>
<tr>
<td style="text-align: center;">
4x2 </td>
<td style="text-align: center;"> 1 </td>
<td style="text-align: left;">  <code>primaries</code> is a 4x2 matrix with CIE xy chromaticities of R,G,B,W in the rows</td>
</tr>
<tr>
<td style="text-align: center;">
3x2 </td>
<td style="text-align: center;"> 2 </td>
<td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
<td style="text-align: center;">
3x2 </td>
<td style="text-align: center;"> 3 </td>
<td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
<td style="text-align: center;">
</td>
</tr>
</table>
<p>If <code>length(white)</code> is 1, then <code>white</code> is the whitepoint Y.
If <code>length(white)</code> is 2, then <code>white</code> is the whitepoint xy (CIE chromaticity); 
the whitepoint Y is taken to be 1.
If <code>length(white)</code> is 3, <code>white</code> is the whitepoint XYZ (CIE tristimulus).
<br><code>primaries</code> can also be a plain numeric vector of length 6 or 8,
which is then converted to a 3x2 or 4x2 matrix, by row.
</p>


<h3>Value</h3>

<p><code>power.OETF()</code> returns a <code>TransferFunction</code> with the classical <code class="reqn">1/\gamma</code> power law.
<code>power.EOTF()</code> returns a <code>TransferFunction</code> with the classical <code class="reqn">\gamma</code> power law.
<code>power.OOTF()</code> is the same as <code>power.EOTF()</code>,
but having a different name may make the creation of new RGB spaces clearer.
All three of these map [0,1] to [0,1].
</p>
<p><code>BT.1886.EOTF()</code> returns a <code>TransferFunction</code> that maps [0,1] to
[<code>Lb</code>,<code>Lw</code>], with non-linearity given by <code>gamma</code>.
The BT.1886 standard has details in Annex 1.
</p>
<p><code>XYZfromRGB.TF()</code> returns a 3D <code>TransferFunction</code> that is linear
and maps RGB=(1,1,1) to the XYZ of white.
The domain is set to the ACES cube  <code class="reqn">[-65504, 65504]^3</code> and the range is set to the smallest enclosing box.
For the inverse one can use <code>XYZfromRGB.TF()^-1</code>.
</p>
<p><code>affine.TF()</code> returns a 1D <code>TransferFunction</code> that maps 
0   →  <code class="reqn">y_0</code> and 1   →  <code class="reqn">y_1</code> in an affine way.
One must have <code class="reqn">y_0 \ne y_1</code>, but is is OK to have <code class="reqn">y_0 &gt; y_1</code>.
No quantities are associated with these values; the function is intended for arbitrary 1D scaling.
</p>


<h3>References</h3>

<p>BT.1886.
Reference electro-optical transfer function for flat panel displays used in HDTV studio production.
March 2011.
</p>


<h3>See Also</h3>

<p><code>TransferFunction</code>
</p>


</div>