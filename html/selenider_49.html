<div class="container">

<table style="width: 100%;"><tr>
<td>elem_expect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test one or more conditions on HTML elements</h2>

<h3>Description</h3>

<p><code>elem_expect()</code> waits for a set of conditions to return TRUE. If, after a
certain period of time (by default 4 seconds), this does not happen, an
informative error is thrown. Otherwise, the original element is returned.
</p>
<p><code>elem_wait_until()</code> does the same, but returns a logical value (whether or
not the test passed), allowing you to handle the failure case explicitly.
</p>


<h3>Usage</h3>

<pre><code class="language-R">elem_expect(x, ..., testthat = NULL, timeout = NULL)

elem_wait_until(x, ..., timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>selenider_element</code>/<code>selenider_elements</code> object, or a condition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>&lt;<code>dynamic-dots</code>&gt; Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be <code>TRUE</code> for the test to pass.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testthat</code></td>
<td>
<p>Whether to treat the expectation as a <code>testthat</code> test. You
<em>do not</em> need to explicitly provide this most of the time, since by
default, we can use <code>testthat::is_testing()</code> to figure out whether
<code>elem_expect()</code> is being called from within a <code>testthat</code> test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeout</code></td>
<td>
<p>The number of seconds to wait for a condition to pass. If not
specified, the timeout used for <code>x</code> will be used, or the timeout of the
local session if an element is not given.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>elem_expect()</code> invisibly returns the element(s) <code>x</code>, or <code>NULL</code> if an
element or collection of elements was not given in <code>x</code>.
</p>
<p><code>elem_wait_for()</code> returns a boolean flag: TRUE if the test passes, FALSE
otherwise.
</p>


<h3>Conditions</h3>

<p>Conditions can be supplied as functions or calls.
</p>
<p>Functions allow you to use unary conditions without formatting them as a
call (e.g. <code>is_present</code> rather than <code>is_present()</code>). It also allows you to
make use of R's anonymous function syntax to quickly
create custom conditions. <code>x</code> will be supplied as the first argument of this
function.
</p>
<p>Function calls allow you to use conditions that take multiple arguments
(e.g. <code>has_text()</code>) without the use of an intermediate function. The call
will be modified so that <code>x</code> is the first argument to the function call. For
example, <code>has_text("a")</code> will be modified to become: <code>has_text(x, "a")</code>.
</p>
<p>The and (<code>&amp;&amp;</code>), or (<code>||</code>) and not (<code>!</code>) functions can be used on both types
of conditions. If more than one condition are given in <code>...</code>, they are
combined using <code>&amp;&amp;</code>.
</p>


<h3>Custom conditions</h3>

<p>Any function which takes a selenider element or element collection as its
first argument, and returns a logical value, can be used as a condition.
</p>
<p>Additionally, these functions provide a few features that make creating
custom conditions easy:
</p>

<ul>
<li>
<p> Errors with class <code>expect_error_continue</code> are handled, and
the function is prevented from terminating early. This means that if
an element is not found, the function will retry instead of immediately
throwing an error.
</p>
</li>
<li> <p><code>selenider</code> functions used inside conditions have their timeout, by
default, set to 0, ignoring the local timeout. This is important, since
<code>elem_expect()</code> and <code>elem_wait_until()</code> implement a retry mechanic
manually. To override this default, manually specify a timeout.
</p>
</li>
</ul>
<p>These two features allow you to use functions like <code>elem_text()</code> to access
properties of an element, without needing to worry about the errors that
they throw or the timeouts that they use. See Examples for a few examples of
a custom condition.
</p>
<p>These custom conditions can also be used with <code>elem_filter()</code> and
<code>elem_find()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>is_present()</code> and other conditions for predicates for HTML elements.
(If you scroll down to the <em>See also</em> section, you will find the rest).
</p>
</li>
<li> <p><code>elem_expect_all()</code> and <code>elem_wait_until_all()</code> for an easy way to test a
single condition on multiple elements.
</p>
</li>
<li> <p><code>elem_filter()</code> and <code>elem_find()</code> to use conditions to filter elements.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
html &lt;- "
&lt;div class='class1'&gt;
&lt;button id='disabled-button' disabled&gt;Disabled&lt;/button&gt;
&lt;p&gt;Example text&lt;/p&gt;
&lt;button id='enabled-button'&gt;Enabled&lt;/button&gt;
&lt;/div&gt;

&lt;div class='class3'&gt;
&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

s(".class1") |&gt;
  elem_expect(is_present)

s("#enabled-button") |&gt;
  elem_expect(is_visible, is_enabled)

s("#disabled-button") |&gt;
  elem_expect(is_disabled)

# Error: element is visible but not enabled
s("#disabled-button") |&gt;
  elem_expect(is_visible, is_enabled, timeout = 0.5) |&gt;
  try() # Since this condition will fail

s(".class2") |&gt;
  elem_expect(!is_present, !is_in_dom, is_absent) # All 3 are equivalent

# All other conditions will error if the element does not exist
s(".class2") |&gt;
  elem_expect(is_invisible, timeout = 0.1) |&gt;
  try()

# elem_expect() returns the element, so can be used in chains
s("#enabled-button") |&gt;
  elem_expect(is_visible &amp;&amp; is_enabled) |&gt;
  elem_click()
# Note that elem_click() will do this automatically

s("p") |&gt;
  elem_expect(is_visible, has_exact_text("Example text"))

# Or use an anonymous function
s("p") |&gt;
  elem_expect(\(elem) identical(elem_text(elem), "Example text"))

# If your conditions are not specific to an element, you can omit the `x`
# argument
elem_1 &lt;- s(".class1")
elem_2 &lt;- s(".class2")

elem_expect(is_present(elem_1) || is_present(elem_2))

# We can now use the conditions on their own to figure out which element
# exists
if (is_present(elem_1)) {
  print("Element 1 is visible")
} else {
  print("Element 2 is visible")
}

# Use elem_wait_until() to handle failures manually
elem &lt;- s(".class2")
if (elem_wait_until(elem, is_present)) {
  elem_click(elem)
} else {
  reload()
}

# Creating a custom condition is easiest with an anonymous function
s("p") |&gt;
  elem_expect(
    \(elem) elem |&gt;
      elem_text() |&gt;
      grepl(pattern = "Example .*")
  )

# Or create a function, to reuse the condition multiple times
text_contains &lt;- function(x, pattern) {
  text &lt;- elem_text(x)

  grepl(pattern, text)
}

s("p") |&gt;
  elem_expect(text_contains("Example *"))

# If we want to continue on error, we need to use the
# "expect_error_continue" class.
# This involves making a custom error object.
error_condition &lt;- function() {
  my_condition &lt;- list(message = "Custom error!")
  class(my_condition) &lt;- c("expect_error_continue", "error", "condition")
  stop(my_condition)
}

# This is much easier with rlang::abort() / cli::cli_abort():
error_condition_2 &lt;- function() {
  rlang::abort("Custom error!", class = "expect_error_continue")
}

# This error will not be caught
try(elem_expect(stop("Uncaught error!")))

# These will eventually throw an error, but will wait 0.5 seconds to do so.
try(elem_expect(error_condition(), timeout = 0.5))
try(elem_expect(error_condition_2(), timeout = 0.5))

</code></pre>


</div>