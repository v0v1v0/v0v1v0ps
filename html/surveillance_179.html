<div class="container">

<table style="width: 100%;"><tr>
<td>twinstim_intensity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plotting Intensities of Infection over Time or Space
</h2>

<h3>Description</h3>

<p><code>intensityplot</code> method to plot the evolution of the total infection
intensity, its epidemic proportion or its endemic proportion over time
or space (integrated over the other dimension) of fitted
<code>twinstim</code> models (or <code>simEpidataCS</code>).
The <code>"simEpidataCS"</code>-method is just a wrapper around
<code>intensityplot.twinstim</code> by making the <code>"simEpidataCS"</code> object
<code>"twinstim"</code>-compatible, i.e. enriching it by the
required model components and environment.
</p>
<p>The <code>intensity.twinstim</code> auxiliary function returns functions which
calculate the endemic or epidemic intensity at a specific time point or
location (integrated over the other dimension).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'twinstim'
intensityplot(x,
    which = c("epidemic proportion", "endemic proportion", "total intensity"),
    aggregate = c("time", "space"), types = 1:nrow(x$qmatrix),
    tiles, tiles.idcol = NULL, plot = TRUE, add = FALSE,
    tgrid = 101, rug.opts = list(),
    sgrid = 128, polygons.args = list(), points.args = list(),
    cex.fun = sqrt, ...)

## S3 method for class 'simEpidataCS'
intensityplot(x, ...)

intensity.twinstim(x,
    aggregate = c("time", "space"), types = 1:nrow(x$qmatrix), 
    tiles, tiles.idcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an object of class <code>"twinstim"</code> or <code>"simEpidataCS"</code>, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p><code>"epidemic proportion"</code>, <code>"endemic proportion"</code>,
or <code>"total intensity"</code>.  Partial matching is applied.  Determines
whether to plot the path of the total intensity or its 
epidemic or endemic proportions over time or space (<code>which</code>)
aggregated over the other dimension and <code>types</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>

<p>One of <code>"time"</code> or <code>"space"</code>. The former results in a plot
of the evolution of <code>which</code> as a function of time (integrated
over the observation region <code class="reqn">\bold{W}</code>), whereas the latter
produces a <code>spplot</code> of <code>which</code> over <code class="reqn">\bold{W}</code>
(spanned by <code>tiles</code>). In both cases, <code>which</code> is evaluated
on a grid of values, given by <code>tgrid</code> or <code>sgrid</code>, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>types</code></td>
<td>

<p>event types to aggregate. By default, all types of events are
aggregated, but one could also be interested in only one specific
type or a subset of event types.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiles</code></td>
<td>

<p>object of class <code>"SpatialPolygons"</code> representing
the decomposition of <code class="reqn">\bold{W}</code> into different regions (as used
in the corresponding <code>stgrid</code> of the <code>"epidataCS"</code>.
This is only needed for <code>aggregate = "space"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiles.idcol</code></td>
<td>

<p>either a column index for <code>tiles@data</code> (if <code>tiles</code> is a
<code>"SpatialPolygonsDataFrame"</code>), or <code>NULL</code>
(default), which refers to the <code>"ID"</code> slot of the polygons,
i.e., <code>row.names(tiles)</code>.
The ID's must correspond to the factor levels of
<code>stgrid$tile</code> of the <code>"epidataCS"</code> on which
<code>x</code> was fitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>

<p>logical indicating if a plot is desired, which defaults to <code>TRUE</code>.
Otherwise, a function will be returned, which takes a vector of time
points (if <code>aggregate = "time"</code>) or a matrix of coordinates (if
<code>aggregate = "space"</code>), and returns <code>which</code> on this grid.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>

<p>logical.  If <code>TRUE</code> and <code>aggregate = "time"</code>, paths are
added to the current plot, using <code>lines</code>.  This does not work
for <code>aggregate = "space"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tgrid</code></td>
<td>

<p>either a numeric vector of time points when to evaluate
<code>which</code>, or a scalar representing the desired number of
evaluation points in the observation interval <code class="reqn">[t_0, T]</code>.
This argument is unused for <code>aggregate = "space"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug.opts</code></td>
<td>

<p>if a list, its elements are passed as arguments to the function
<code>rug</code>, which will mark the time points of the events if
<code>aggregate = "time"</code> (it is unused in the spatial case);
otherwise (e.g., <code>NULL</code>), no <code>rug</code> will be produced.
By default, the <code>rug</code> argument <code>ticksize</code> is set to 0.02
and <code>quiet</code> is set to <code>TRUE</code>.  Note that the argument
<code>x</code> of the <code>rug</code> function, which contains the
locations for the <code>rug</code> is fixed internally and can not be
modified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sgrid</code></td>
<td>

<p>either an object of class <code>"SpatialPixels"</code> (or
coercible to that class) representing the locations where to
evaluate <code>which</code>, or a scalar representing the approximate
number of points of a grid constructed on the bounding box of
<code>tiles</code>.
<code>sgrid</code> is internally subsetted to contain only
points inside <code>tiles</code>.
This argument is unused for <code>aggregate = "time"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polygons.args</code></td>
<td>

<p>if a list, its elements are passed as arguments to
<code>sp.polygons</code>, which will add <code>tiles</code> to the plot
if <code>aggregate = "space"</code> (it is unused for the temporal plot).
By default, the fill <code>col</code>our of the tiles is set to
<code>"darkgrey"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points.args</code></td>
<td>

<p>if a list, its elements are passed as arguments to
<code>sp.points</code>, which will add the event locations to the plot
if <code>aggregate = "space"</code> (it is unused for the temporal plot).
By default, the plot symbol is set to <code>pch=1</code>. The sizes
of the points are determined as the product of the argument <code>cex</code>
(default: 0.5) of this list and the sizes obtained from
the function <code>cex.fun</code> which accounts for multiple events at the
same location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.fun</code></td>
<td>

<p>function which takes a vector of counts of events
at each unique location and returns a (vector of) <code>cex</code>
value(s) for the sizes of the points at the event locations used in
<code>points.args</code>.
Defaults to the <code>sqrt()</code> function, which for the default
circular <code>pch=1</code> means that the area of each point is
proportional to the number of events at its location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments passed to <code>plot</code> or <code>lines</code> (if
<code>aggregate = "time"</code>), or to <code>spplot</code> (if
<code>aggregate = "space"</code>).<br>
For <code>intensityplot.simEpidataCS</code>, arguments passed to
<code>intensityplot.twinstim</code>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>plot = FALSE</code> or <code>aggregate = "time"</code>,
a function is returned, which takes a vector of
time points (if <code>aggregate = "time"</code>) or a matrix of coordinates
(if <code>aggregate = "space"</code>), and returns <code>which</code> on this grid.
<code>intensity.twinstim</code> returns a list containing such functions for
the endemic and epidemic intensity (but these are not vectorized).
</p>
<p>If <code>plot = TRUE</code> and <code>aggregate = "space"</code>, the
<code>trellis.object</code> of the spatial plot is returned.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code>plot.twinstim</code>, which calls <code>intensityplot.twinstim</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("imdepi", "imdepifit")

# for the intensityplot we need the model environment, which can be
# easily added by the intelligent update method (no need to refit the model)
imdepifit &lt;- update(imdepifit, model=TRUE)

## path of the total intensity
opar &lt;- par(mfrow=c(2,1))
intensityplot(imdepifit, which="total intensity",
              aggregate="time", tgrid=500)
plot(imdepi, "time", breaks=100)
par(opar)

## time course of the epidemic proportion by event
intensityplot(imdepifit, which="epidemic proportion",
              aggregate="time", tgrid=500, types=1)
intensityplot(imdepifit, which="epidemic proportion",
              aggregate="time", tgrid=500, types=2, add=TRUE, col=2)
legend("topright", legend=levels(imdepi$events$type), lty=1, col=1:2,
       title = "event type")

## endemic and total intensity in one plot
intensity_endprop &lt;- intensityplot(imdepifit, which="endemic proportion",
                                   aggregate="time", plot=FALSE)
intensity_total &lt;- intensityplot(imdepifit, which="total intensity",
                                 aggregate="time", tgrid=501, lwd=2)
curve(intensity_endprop(x) * intensity_total(x), add=TRUE, col=2, lwd=2, n=501)
text(2500, 0.36, labels="total", col=1, pos=2, font=2)
text(2500, 0.08, labels="endemic", col=2, pos=2, font=2)


## spatial shape of the intensity (aggregated over time)

# need a map of the 'stgrid' tiles, here Germany's districts
load(system.file("shapes", "districtsD.RData", package="surveillance"))

# total intensity (using a rather sparse 'sgrid' for speed)
intensityplot(imdepifit, which="total intensity",
              aggregate="space", tiles=districtsD, sgrid=500,
              col.regions=rev(heat.colors(100)))



if (surveillance.options("allExamples")) {
  # epidemic proportion by type
  maps_epiprop &lt;- lapply(1:2, function (type) {
      intensityplot(imdepifit, which="epidemic", aggregate="space",
                    types=type, tiles=districtsD, sgrid=1000,
                    main=rownames(imdepifit$qmatrix)[type],
                    scales=list(draw=FALSE), at=seq(0,1,by=0.1),
                    col.regions=rev(hcl.colors(10,"YlOrRd")),
                    colorkey=list(title=list("Epidemic proportion", cex=1)))
  })
  plot(maps_epiprop[[1]], split=c(1,1,2,1), more=TRUE)
  plot(maps_epiprop[[2]], split=c(2,1,2,1))
}
</code></pre>


</div>