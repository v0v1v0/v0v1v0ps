<div class="container">

<table style="width: 100%;"><tr>
<td>generators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convenience Functions for Generators</h2>

<h3>Description</h3>

<p>These convenience functions facilitate the definition of generators of arrivals
for some common cases.
</p>


<h3>Usage</h3>

<pre><code class="language-R">at(...)

from(start_time, dist, arrive = TRUE)

to(stop_time, dist)

from_to(start_time, stop_time, dist, arrive = TRUE, every = NULL)

when_activated(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a vector or multiple parameters of times at which to initiate an arrival.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_time</code></td>
<td>
<p>the time at which to launch the initial arrival
(numeric or function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>a function modelling the interarrival times. It is supposed to be
an infinite source of values <code>&gt;= 0</code> (e.g., <code>rexp</code> and the like). If
the function provided returns any negative value, the behaviour is undefined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrive</code></td>
<td>
<p>if set to <code>TRUE</code> (default) the first arrival will be
generated at <code>start_time</code> and will follow <code>dist</code> from then on.
If set to <code>FALSE</code>, will initiate <code>dist</code> at <code>start_time</code>
(and the first arrival will most likely start at a time later than
<code>start_time</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop_time</code></td>
<td>
<p>the time at which to stop the generator (numeric or function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>every</code></td>
<td>
<p>repeat with this time cycle (numeric or function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>an integer or a callable object (a function) which must return
a number of arrivals to generate when activated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>at</code> generates arrivals at specific absolute times.
</p>
<p><code>from</code> generates inter-arrivals following a given distribution
with a specified start time.
union of the last two.
</p>
<p><code>to</code> generates inter-arrivals following a given
distribution with a specified stop time.
</p>
<p><code>from_to</code> is the union of <code>from</code> and <code>to</code>.
</p>
<p><code>when_activated</code> sets up an initially inactive generator
which generates <code>n</code> arrivals each time it is activated from any
trajectory using the activity <code>activate</code>.
</p>


<h3>Value</h3>

<p>Returns a generator function (a closure).
</p>


<h3>See Also</h3>

<p><code>add_generator</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## common to all examples below
# some trajectory
t0 &lt;- trajectory() %&gt;%
  timeout(0)
# some distribution
distr &lt;- function() runif(1, 1, 2)

# arrivals at 0, 1, 10, 30, 40 and 43
simmer() %&gt;%
  add_generator("dummy", t0, at(0, c(1,10,30), 40, 43)) %&gt;%
  run(100) %&gt;%
  get_mon_arrivals()

# apply distribution starting at 5 (and no end)
simmer() %&gt;%
  add_generator("dummy", t0, from(5, distr)) %&gt;%
  run(10) %&gt;%
  get_mon_arrivals()

# apply distribution until 5 (starting at 0)
simmer() %&gt;%
  add_generator("dummy", t0, to(5, distr)) %&gt;%
  run(10) %&gt;%
  get_mon_arrivals()

# apply distribution from 8 to 16 h every 24 h:
simmer() %&gt;%
  add_generator("dummy", t0, from_to(8, 16, distr, every=24)) %&gt;%
  run(48) %&gt;%
  get_mon_arrivals()

# triggering arrivals on demand from a trajectory
t1 &lt;- trajectory() %&gt;%
  activate("dummy")

simmer() %&gt;%
  add_generator("dummy", t0, when_activated()) %&gt;%
  add_generator("trigger", t1, at(2)) %&gt;%
  run() %&gt;%
  get_mon_arrivals()

</code></pre>


</div>