<div class="container">

<table style="width: 100%;"><tr>
<td>Toeplitz</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor and methods for Toeplitz matrix objects.</h2>

<h3>Description</h3>

<p>The <code>Toeplitz</code> class contains efficient methods for linear algebra with symmetric positive definite (i.e., variance) Toeplitz matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.Toeplitz(x)

as.Toeplitz(x)

## S3 method for class 'Toeplitz'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An R object.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>An <code style="white-space: pre;">⁠N x N⁠</code> Toeplitz matrix <code>Tz</code> is defined by its length-<code>N</code> "autocorrelation" vector <code>acf</code>, i.e., first row/column <code>Tz</code>.  Thus, for the function <code>stats::toeplitz()</code>, we have <code>Tz = toeplitz(acf)</code>.
</p>
<p>It is assumed that <code>acf</code> defines a valid (i.e., positive definite) variance matrix.  The matrix multiplication methods still work when this is not the case but the other methods do not (return values typically contain <code>NaN</code>s).
</p>
<p><code>as.Toeplitz(x)</code> attempts to convert its argument to a <code>Toeplitz</code> object by calling <code>Toeplitz$new(acf = x)</code>. <code>is.Toeplitz(x)</code> checks whether its argument is a <code>Toeplitz</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Toeplitz$new()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>Toeplitz$print()</code></a>
</p>
</li>
<li> <p><a href="#method-size"><code>Toeplitz$size()</code></a>
</p>
</li>
<li> <p><a href="#method-set_acf"><code>Toeplitz$set_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-get_acf"><code>Toeplitz$get_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-has_acf"><code>Toeplitz$has_acf()</code></a>
</p>
</li>
<li> <p><a href="#method-prod"><code>Toeplitz$prod()</code></a>
</p>
</li>
<li> <p><a href="#method-solve"><code>Toeplitz$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-log_det"><code>Toeplitz$log_det()</code></a>
</p>
</li>
<li> <p><a href="#method-trace_grad"><code>Toeplitz$trace_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-trace_hess"><code>Toeplitz$trace_hess()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Toeplitz$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$new(N, acf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt>
<dd>
<p>Size of Toeplitz matrix.</p>
</dd>
<dt><code>acf</code></dt>
<dd>
<p>Autocorrelation vector of length <code>N</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>Toeplitz</code> object.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$print()</pre></div>


<hr>
<a id="method-size"></a>



<h4>Method <code>size()</code>
</h4>

<p>Get the size of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$size()</pre></div>



<h5>Returns</h5>

<p>Size of the Toeplitz matrix.  <code>ncol()</code>, <code>nrow()</code>, and <code>dim()</code> methods for <code>Toeplitz</code> objects also work as expected.
</p>


<hr>
<a id="method-set_acf"></a>



<h4>Method <code>set_acf()</code>
</h4>

<p>Set the autocorrelation of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$set_acf(acf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf</code></dt>
<dd>
<p>Autocorrelation vector of length <code>N</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-get_acf"></a>



<h4>Method <code>get_acf()</code>
</h4>

<p>Get the autocorrelation of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$get_acf()</pre></div>



<h5>Returns</h5>

<p>The autocorrelation vector of length <code>N</code>.
</p>


<hr>
<a id="method-has_acf"></a>



<h4>Method <code>has_acf()</code>
</h4>

<p>Check whether the autocorrelation of the Toeplitz matrix has been set.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$has_acf()</pre></div>



<h5>Returns</h5>

<p>Logical; <code>TRUE</code> if <code>Toeplitz$set_acf()</code> has been called.
</p>


<hr>
<a id="method-prod"></a>



<h4>Method <code>prod()</code>
</h4>

<p>Toeplitz matrix-matrix product.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$prod(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Vector or matrix with <code>N</code> rows.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The matrix product <code>Tz %*% x</code>. <code>Tz %*% x</code> and <code>x %*% Tz</code> also work as expected.
</p>


<hr>
<a id="method-solve"></a>



<h4>Method <code>solve()</code>
</h4>

<p>Solve a Toeplitz system of equations.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$solve(x, method = c("gschur", "pcg"), tol = 1e-10)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Optional vector or matrix with <code>N</code> rows.</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>Solve method to use.  Choices are: <code>gschur</code> for a modified version of the Generalized Schur algorithm of Ammar &amp; Gragg (1988), or <code>pcg</code> for the preconditioned conjugate gradient method of Chen et al (2006).  The former is faster and obtains the log-determinant as a direct biproduct.  The latter is more numerically stable for long-memory autocorrelations.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>Tolerance level for the <code>pcg</code> method.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The solution in <code>z</code> to the system of equations <code>Tz %*% z = x</code>.  If <code>x</code> is missing, returns the inverse of <code>Tz</code>.  <code>solve(Tz, x)</code> and <code>solve(Tz, x, method, tol)</code> also work as expected.
</p>


<hr>
<a id="method-log_det"></a>



<h4>Method <code>log_det()</code>
</h4>

<p>Calculate the log-determinant of the Toeplitz matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$log_det()</pre></div>



<h5>Returns</h5>

<p>The log-determinant <code>log(det(Tz))</code>.  <code>determinant(Tz)</code> also works as expected.
</p>


<hr>
<a id="method-trace_grad"></a>



<h4>Method <code>trace_grad()</code>
</h4>

<p>Computes the trace-gradient with respect to Toeplitz matrices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$trace_grad(acf2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf2</code></dt>
<dd>
<p>Length-<code>N</code> autocorrelation vector of the second Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Computes the trace of</p>
<pre>solve(Tz, toeplitz(acf2)).
</pre>
<p>This is used in the computation of the gradient of <code>log(det(Tz(theta)))</code> with respect to <code>theta</code>.
</p>


<hr>
<a id="method-trace_hess"></a>



<h4>Method <code>trace_hess()</code>
</h4>

<p>Computes the trace-Hessian with respect to Toeplitz matrices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$trace_hess(acf2, acf3)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acf2</code></dt>
<dd>
<p>Length-<code>N</code> autocorrelation vector of the second Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
<dt><code>acf3</code></dt>
<dd>
<p>Length-<code>N</code> autocorrelation vector of the third Toeplitz matrix.  This matrix must be symmetric but not necessarily positive definite.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Computes the trace of</p>
<pre>solve(Tz, toeplitz(acf2)) %*% solve(Tz, toeplitz(acf3)).
</pre>
<p>This is used in the computation of the Hessian of <code>log(det(Tz(theta)))</code> with respect to <code>theta</code>.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Toeplitz$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># construct a Toeplitz matrix
acf &lt;- exp(-(1:5))
Tz &lt;- Toeplitz$new(acf = acf)
# alternatively, can allocate space first
Tz &lt;- Toeplitz$new(N = length(acf))
Tz$set_acf(acf = acf)

# basic methods
Tz$get_acf() # extract the acf
dim(Tz) # == c(nrow(Tz), ncol(Tz))
Tz # print method

# linear algebra methods
X &lt;- matrix(rnorm(10), 5, 2)
Tz %*% X
t(X) %*% Tz
solve(Tz, X)
determinant(Tz) # log-determinant
</code></pre>


</div>