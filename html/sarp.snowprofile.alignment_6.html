<div class="container">

<table style="width: 100%;"><tr>
<td>clusterSP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster snow profiles</h2>

<h3>Description</h3>

<p>This function is the main gateway to sarp.snowprofile::snowprofile clustering.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clusterSP(
  SPx = NULL,
  k = 2,
  type = c("hclust", "pam", "fanny", "kdba", "fast")[1],
  distmat = NULL,
  config = clusterSPconfig(type),
  centers = "none",
  keepSPx = TRUE,
  keepDistmat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SPx</code></td>
<td>
<p>a sarp.snowprofile::snowprofileSet to be clustered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of desired cluster numbers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>clustering type including <code>hclust</code> (default), <code>pam</code>, <code>fanny</code>, <code>kdba</code> and <code>fast</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distmat</code></td>
<td>
<p>a precomputed distance matrix of class dist. This results in much faster clustering for <code>type %in% c('hclust', 'pam', 'fanny')</code>
as well as faster identification of medoid profiles if <code>centers %in% c('medoids', 'both')</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>config</code></td>
<td>
<p>a list providing the necessary hyperparameters. Use clusterSPconfig functions for convenience!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>compute and return <code>mediods</code>, <code>centroids</code>, <code>both</code>, or <code>none</code> for each cluster. default 'none' will only return centroids/medoids
if they were already calculated with the clustering algorithm, whereas other options could result in extra processing time to calculate additional centroids/medoids</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepSPx</code></td>
<td>
<p>append the snowprofileSet to the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepDistmat</code></td>
<td>
<p>append the distmat to the output?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are several clustering approaches that can be applied to snow profiles. Most rely on computing a pairwise distance matrix between all profiles
in a snowprofileSet. Current implementations with this approach rely on existing R functions:
</p>

<ul>
<li>
<p> agglomerative hierarchical clustering stats::hclust
</p>
</li>
<li>
<p> partitioning around medoids cluster::pam
</p>
</li>
<li>
<p> fuzzy analysis clustering cluster::fanny
</p>
</li>
</ul>
<p>Since computing a pairwise distance matrix matrix can be slow, the recommended way of testing different number of clusters $k$ is precomputing
a single distance matrix with the distanceSP function and providing it as an argument to clusterSP.
</p>
<p>An alternate type of clustering known a k-dimensional barycentric averaging <em>kdba</em> is conceptually similar to kmeans but specifically adapted to
snow profiles clusterSPkdba. That means that an initial clustering condition (which can be random or based on a 'sophisticated guess') is iteratively refined by
assigning individual profiles to the most similar cluster and at the end of every iteration recomputing the cluster centroids. The cluster centroids
are represented by the <em>average</em> snow profile of each cluster (see averageSP). Note that the results of kdba are sensitive to the initial conditions,
which by default are estimated with the 'fast' method below.
</p>
<p>And finally, a much faster 'fast' method is available that computes a pairwise distance matrix without aligning profiles, but instead based on
summary statistics such as snow height, height of new snow, presence or absence of weak layers and crusts, etc. The 'fast' clustering approach
uses the partitioning around medoids clustering approach with the 'fast' distance matrix.
</p>
<p>More details here...
</p>


<h3>Value</h3>

<p>a list of class <code>clusterSP</code> containing:
</p>

<ul>
<li> <p><code>clustering</code>: vector of integers (from 1:k) indicating the cluster to which each point is allocated
</p>
</li>
<li> <p><code>id.med</code>: vector of indices for the medoid profiles of each cluster (if calculated)
</p>
</li>
<li> <p><code>centroids</code>: snowprofileSet containing the centroid profile for each cluster (if calculated)
</p>
</li>
<li> <p><code>tree</code>: object of class 'hclust' describing the tree output by hclust
</p>
</li>
<li> <p><code>...</code>: all other outputs provided by the clustering algorithms (e.g., a membership matrix
from <code>fanny.object</code>, <code>pam.object</code>, iteration history from clusterSPkdba)
</p>
</li>
<li> <p><code>type</code>: type of clustering as provided by input argument
</p>
</li>
<li> <p><code>call</code>: a copy of the clusterSP function call
</p>
</li>
<li> <p><code>SPx</code>: a copy of the input snowprofileSet (if <code>keepSPx = TRUE</code>)
</p>
</li>
<li> <p><code>distmat</code>: the pairwise distance matrix of class dist (if <code>keepDistmat = TRUE</code> and a matrix has been provided or computed)
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>fherla shorton
</p>


<h3>See Also</h3>

<p>clusterSPconfig, clusterSPcenters, clusterSPkdba, plot.clusterSP
</p>


<h3>Examples</h3>

<pre><code class="language-R">this_example_runs_too_long &lt;- TRUE
if (!this_example_runs_too_long) {  # exclude from cran checks

  ## Cluster with SPgroup2, which contains deposition date and p_unstable
  SPx &lt;- SPgroup2
  config &lt;- clusterSPconfig(simType = 'wsum_scaled', ddate = T, pwls = T)

  ## Hierarchical clustering with k = 2
  cl_hclust &lt;- clusterSP(SPx, k = 2, type = 'hclust', config = config)
  plot(cl_hclust)

  ## Precompute a distance matrix and cluster with PAM for k = 2 and 3
  distmat &lt;- do.call('distanceSP', c(list(SPx), config$args_distance))
  cl_pam2 &lt;- clusterSP(SPx, k = 2, type = 'pam', config = config, distmat = distmat)
  cl_pam3 &lt;- clusterSP(SPx, k = 3, type = 'pam', config = config, distmat = distmat)
  print(cl_pam2$clustering)
  print(cl_pam3$clustering)

  ## kdba clustering
  config_kdba &lt;- clusterSPconfig(simType = 'layerwise', type = 'kdba')
  cl_kdba &lt;- clusterSP(SPx = SPgroup2, k = 2, type = 'kdba', config = config_kdba)
  plot(cl_kdba)

}
</code></pre>


</div>