<div class="container">

<table style="width: 100%;"><tr>
<td>griffith_sone</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial weights matrix eigenvalues</h2>

<h3>Description</h3>

<p>The <code>eigenw</code> function returns a numeric vector of eigenvalues of 
the weights matrix generated from the spatial weights object <code>listw</code>. 
The eigenvalues are used to speed the computation of the Jacobian in 
spatial model estimation:
</p>
<p style="text-align: center;"><code class="reqn">\log(\det[I - \rho W]) = \sum_{i=1}^{n}\log(1 - \rho \lambda_i)</code>
</p>

<p>where <code class="reqn">W</code> is the n by n spatial weights matrix, and <code class="reqn">\lambda_i</code> are the
eigenvalues of <code class="reqn">W</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eigenw(listw, quiet=NULL)
griffith_sone(P, Q, type="rook")
subgraph_eigenw(nb, glist=NULL, style="W", zero.policy=NULL, quiet=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>default NULL, use global !verbose option value; set to FALSE for short summary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>number of columns in the grid (number of units in a horizontal axis direction)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>number of rows in the grid (number of units in a vertical axis direction.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>“rook” or “queen”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glist</code></td>
<td>
<p>list of general weights corresponding to neighbours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p><code>style</code> can take values “W”, “B”, “C”, “U”, “minmax” and “S”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>The <code>griffith_sone</code> function function may be used, following Ord and Gasim (for references see Griffith and Sone (1995)), to calculate analytical eigenvalues for binary rook or queen contiguous neighbours where the data are arranged as a regular P times Q grid. The <code>subgraph_eigenw</code> function may be used when there are multiple graph components, of which the largest may be handled as a dense matrix. Here the eigenvalues are computed for each subgraph in turn, and catenated to reconstruct the complete set. The functions may be used to provide pre-computed eigenvalues for spatial regression functions.</p>


<h3>Value</h3>

<p>a numeric or complex vector of eigenvalues of the weights matrix generated from the spatial weights object.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 155;
Ord, J. K. 1975 Estimation methods for models of spatial interaction, Journal
of the American Statistical Association, 70, 120-126.; Griffith, D. A. and Sone, A. (1995). Trade-offs associated with normalizing constant computational simplifications for estimating spatial statistical models. Journal of Statistical Computation and Simulation, 51, 165-183.</p>


<h3>See Also</h3>

<p><code>eigen</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#require(spdep)
data(oldcol, package="spdep")
W.eig &lt;- eigenw(spdep::nb2listw(COL.nb, style="W"))
1/range(W.eig)
S.eig &lt;- eigenw(spdep::nb2listw(COL.nb, style="S"))
1/range(S.eig)
B.eig &lt;- eigenw(spdep::nb2listw(COL.nb, style="B"))
1/range(B.eig)
# cases for intrinsically asymmetric weights
crds &lt;- cbind(COL.OLD$X, COL.OLD$Y)
k3 &lt;- spdep::knn2nb(spdep::knearneigh(crds, k=3))
spdep::is.symmetric.nb(k3)
k3eig &lt;- eigenw(spdep::nb2listw(k3, style="W"))
is.complex(k3eig)
rho &lt;- 0.5
Jc &lt;- sum(log(1 - rho * k3eig))
# complex eigenvalue Jacobian
Jc
# subgraphs
nc &lt;- attr(k3, "ncomp")
if (is.null(nc)) nc &lt;- spdep::n.comp.nb(k3)
nc$nc
table(nc$comp.id)
k3eigSG &lt;- subgraph_eigenw(k3, style="W")
all.equal(sort(k3eig), k3eigSG)
W &lt;- as(spdep::nb2listw(k3, style="W"), "CsparseMatrix")
I &lt;- diag(length(k3))
Jl &lt;- sum(log(abs(diag(slot(lu(I - rho * W), "U")))))
# LU Jacobian equals complex eigenvalue Jacobian
Jl
all.equal(Re(Jc), Jl)
# wrong value if only real part used
Jr &lt;- sum(log(1 - rho * Re(k3eig)))
Jr
all.equal(Jr, Jl)
# construction of Jacobian from complex conjugate pairs (Jan Hauke)
Rev &lt;- Re(k3eig)[which(Im(k3eig) == 0)]
# real eigenvalues
Cev &lt;- k3eig[which(Im(k3eig) != 0)]
pCev &lt;- Cev[Im(Cev) &gt; 0]
# separate complex conjugate pairs
RpCev &lt;- Re(pCev)
IpCev &lt;- Im(pCev)
# reassemble Jacobian
Jc1 &lt;- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2 + (rho^2)*(IpCev^2)))
all.equal(Re(Jc), Jc1)
# impact of omitted complex part term in real part only Jacobian
Jc2 &lt;- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2))
all.equal(Jr, Jc2)
# trace of asymmetric (WW) and crossprod of complex eigenvalues for APLE
sum(diag(W %*% W))
crossprod(k3eig)
# analytical regular grid eigenvalues
rg &lt;- spdep::cell2nb(ncol=7, nrow=7, type="rook")
rg_eig &lt;- eigenw(spdep::nb2listw(rg, style="B"))
rg_GS &lt;- griffith_sone(P=7, Q=7, type="rook")
all.equal(rg_eig, rg_GS)
## Not run: 
run &lt;- FALSE
if (require("RSpectra", quietly=TRUE)) run &lt;- TRUE
if (run) {
B &lt;- as(spdep::nb2listw(rg, style="B"), "CsparseMatrix")
res1 &lt;- eigs(B, k=1, which="LR")$values
resn &lt;- eigs(B, k=1, which="SR")$values
print(Re(c(resn, res1)))
}
if (run) {
print(all.equal(range(Re(rg_eig)), c(resn, res1))) 
}
if (run) {
lw &lt;- spdep::nb2listw(rg, style="W")
rg_eig &lt;- eigenw(similar.listw(lw))
print(range(Re(rg_eig)))
}
if (run) {
W  &lt;- as(lw, "CsparseMatrix")
print(Re(c(eigs(W, k=1, which="SR")$values, eigs(W, k=1, which="LR")$values)))
}
## End(Not run)
</code></pre>


</div>