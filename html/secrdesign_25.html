<div class="container">

<table style="width: 100%;"><tr>
<td>Lambda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expected Detections</h2>

<h3>Description</h3>

<p>Compute the expected number of detections as a function of location (<code>Lambda</code>), and the expected total numbers of individuals <code class="reqn">n</code>, recaptures <code class="reqn">r</code> and movements <code class="reqn">m</code> for a population sampled with an array of detectors (<code>Enrm</code>) or the number of individuals detected at two or more detectors (<code>En2</code>). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">
Lambda(traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", 'HN', 'HR', 'EX'))


Enrm(D, ...)

minnrRSE(D, ..., CF = 1.0, distribution = c("poisson","binomial"))

En2(D, traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", "HN", "HR", "EX"))

Qpm(D, traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", "HN", "HR", "EX"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>traps</code></td>
<td>
 <p><code>traps</code> object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
 <p><code>mask</code> object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectpar</code></td>
<td>
<p> a named list giving a value for each parameter of detection function </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function 
– see detectfn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>population density animals / hectare; may be scalar or vector of length <code>nrow(mask)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>Lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CF</code></td>
<td>
<p>numeric correction factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>character distribution of <code class="reqn">n</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The detector attribute of <code>traps</code> may be ‘multi’, ‘proximity’ or ‘count’. It is assumed that detectpar and detector type do not differ among occasions.
</p>
<p>The calculation is based on an additive hazard model. If <code>detectfn</code> is not a hazard function (‘HHN’, ‘HEX’, ‘HHR’, ‘HAN’ and ‘HCG’) then an attempt is made to approximate one of the hazard functions (HN -&gt; HHN, HR -&gt; HHR, EX -&gt; HEX). The default is ‘HHN’.
</p>
<p>For hazard function <code class="reqn">\lambda(d)</code> and <code class="reqn">S</code> occasions, we define <code class="reqn">\Lambda(x) = \sum_s \sum_k \lambda(d_k(x))</code>.
</p>
<p>Formulae for expected counts are given in <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-Enrm.pdf">secrdesign-Enrm.pdf</a>.
</p>
<p><code>minnrRSE</code> has mostly the same inputs as <code>Enrm</code> but returns sqrt(CF/min(n,r)). The correction factor CF may be used to adjust for systematic bias (e.g., for a line of detectors CF = 1.4 may be appropriate). The default <code>distribution = 'poisson'</code> is for Poisson-distributed <code class="reqn">N</code> and <code class="reqn">n</code>. To adjust the prediction for fixed <code class="reqn">N</code> (binomial <code class="reqn">n</code>) use <code>distribution = 'binomial'</code> (see <a href="../doc/secrdesign-tools.pdf">../doc/secrdesign-tools.pdf</a> Appendix 2).
</p>
<p>From 2.7.0, the first argument of <code>minnrRSE</code> may also be the output from <code>GAoptim</code>.
</p>
<p><code>En2</code> is defined for detectors ‘multi’, ‘proximity’ and ‘count’.
</p>
<p><code>Qpm</code> returns the optimisation criteria <code class="reqn">Q_p</code> and <code class="reqn">Q_{p_m}</code> of Dupont et al. (2021), defined only for ‘proximity’ and ‘count’ detectors. The criteria are mask-dependent, and <code>En2</code> is generally preferred. For ‘proximity’ and ‘count’ detectors the following expressions give the same result:
</p>
<p><code>En2(D, trp, msk, dp)</code>
</p>
<p><code>Qpm(D, trp, msk, dp) * maskarea(msk) * D</code>
</p>
<p>given constant density ‘D’, detectors ‘trp’, mask ‘msk’ and detection parameters ‘dp’.
</p>


<h3>Value</h3>

<p><code>Lambda</code> –
mask object with covariates ‘Lambda’ (<code class="reqn">\Lambda(x)</code>), ‘sumpk’ and ‘sumq2’ (intermediate values for computation of expected counts - see <a href="../doc/expectedcounts.pdf">../doc/expectedcounts.pdf</a>)


</p>
<p><code>Enrm</code> –
numeric vector of length 3, the values of E(<code class="reqn">n</code>), E(<code class="reqn">r</code>) and E(<code class="reqn">m</code>)
</p>
<p><code>minnrRSE</code> – rule-of-thumb RSE(D-hat) Efford and Boulanger (2019)
</p>
<p><code>En2</code> – numeric vector comprising the values E(<code class="reqn">n</code>) and E(number of animals detected at 2 or more sites)
</p>
<p><code>Qpm</code> – numeric vector comprising the criteria <code class="reqn">Q_p</code> and <code class="reqn">Q_{p_m}</code> of Dupont et al. (2021)
</p>


<h3>References</h3>

<p>Dupont, G., Royle, J. A., Nawaz, M. A. and Sutherland, C. (2021) Optimal sampling
design for spatial capture–recapture. <em>Ecology</em> <b>102</b> e03262.
</p>
<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture–recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529–1535. DOI: 10.1111/2041-210X.13239
</p>


<h3>See Also</h3>

<p><code>getdetectpar</code>, 
<code>optimalSpacing</code>, 
<code>scenarioSummary</code>, 
<code>GAoptim</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
tr &lt;- traps(captdata)
detector(tr) &lt;- "multi"
msk &lt;- make.mask(tr, buffer = 100, type = 'trapbuffer')

L &lt;- Lambda(tr, msk, list(lambda0 = 0.2, sigma = 20), 5)
nrm &lt;- Enrm(D = 5, tr, msk, list(lambda0 = 0.2, sigma = 20), 5)
nrm

En2(D = 5, tr, msk, list(lambda0 = 0.2, sigma = 20), 5)

plot(L, cov = "Lambda", dots = FALSE)
plot(tr, add = TRUE)
mtext(side = 3,  paste(paste(names(nrm), round(nrm,1)), collapse = ", "))

</code></pre>


</div>