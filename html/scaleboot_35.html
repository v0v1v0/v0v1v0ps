<div class="container">

<table style="width: 100%;"><tr>
<td>sbfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Models to Bootstrap Probabilities</h2>

<h3>Description</h3>

<p><code>sbfit</code> is used to fit parametric models to multiscale bootstrap
probabilities by the maximum likelihood method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sbfit(x, ...)

## Default S3 method:
sbfit(x,nb,sa,models=NULL,nofit=FALSE,bpm=NULL,sam=NULL,...)

## S3 method for class 'matrix'
sbfit(x,nb,sa,models=NULL,names.hp=rownames(x),
  bpms=NULL,sam=NULL,nofit=FALSE,cluster=NULL,...)

## S3 method for class 'data.frame'
sbfit(x,...)

## S3 method for class 'scaleboot'
sbfit(x,models=names(x$fi),...)

## S3 method for class 'scalebootv'
sbfit(x,models=attr(x,"models"),...)

## S3 method for class 'scaleboot'
print(x,sort.by=c("aic","none"),...)

## S3 method for class 'scalebootv'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object used to select a method. For <code>sbfit.default</code>,
<code>x</code> is denoted by <code>nb</code> and is a vector of bootstrap
probabilities for a hypothesis. For <code>sbfit.matrix</code>, <code>x</code> is
denoted by <code>bps</code> and is a matrix with row vectors of <code>bp</code>
for several hypotheses.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>vector of numbers of bootstrap replicates. A short vector
(or scalar) is cyclically extended to match the size of <code>bp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sa</code></td>
<td>
<p>vector of scales in sigma squared (<code class="reqn">\sigma^2</code>). Should
be the same size as <code>bp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>character vector of model names. Valid model names are
<code>poly.m</code> for m&gt;=1 and <code>sing.m</code> for
m&gt;=3. The default is set by <code>sboptions()$models</code>, whose
default is c("poly.1","poly.2","poly.3","sing.3","sphe.3").
If <code>models</code> is an integer value, <code>sbmodelnames(m=models)</code> is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nofit</code></td>
<td>
<p>logical. If TRUE, fitting is not performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bpm</code></td>
<td>
<p>(experimental: bootstrap probabilities for 2-step bootstrap)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sam</code></td>
<td>
<p>(experimental: scales for 2-step bootstrap)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bpms</code></td>
<td>
<p>(experimental: bootstrap probabilities for 2-step bootstrap)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.hp</code></td>
<td>
<p>character vector of hypotheses names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.by</code></td>
<td>
<p>sort key.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sbfit.default</code> fits parametric models to <code>bp</code>
by maximizing the log-likelihood value of a binomial model.
A set of multiscale bootstrap resampling
should be performed before a call to <code>sbfit</code> for preparing
<code>bp</code>, where <code>bp[i]</code> is a bootstrap probability of a
hypothesis calculated with a number of bootstrap
replicates <code>nb[i]</code> and a scale <code class="reqn">\sigma^2</code>=<code>sa[i]</code>.
The scale is defined as <code class="reqn">\sigma^2=n/n'</code>,
where <code class="reqn">n</code> is the sample size of data, and <code class="reqn">n'</code> is the sample
size of replicated data for bootstrap resampling.
</p>
<p>Each model specifies a <code>psi(beta,s)</code>=<code class="reqn">\psi(\sigma^2 | \beta)</code>
function with a parameter vector <code class="reqn">\beta</code>. The model
may describe how the bootstrap probability changes along the scale.
Let <code>cnt[i]=bp[i]*nb[i]</code> be the frequency indicating how many
times the hypothesis of interest is observed in bootstrap replicates
at scale <code>sa[i]</code>. Then we assume that <code>cnt[i]</code> is binomially
distributed with number of trials <code>nb[i]</code> and success
probability <code>1-pnorm(psi(beta,s=sa[i])/sqrt(sa[i]))</code>. Currently,
<code>sbpsi.poly</code> and <code>sbpsi.sing</code> are available as <code class="reqn">\psi</code>
functions. The estimated model parameters are accessed by the
<code>coef.scaleboot</code> method.
</p>
<p>The model fitting is performed in the order
specified in <code>models</code>, and the initial values for numerical
optimization of the likelihood function are prepared by using
previously estimated model parameters. Thus, "poly.(m-1)"
should be specified before "poly.m", and "poly.(m-1)" and "sing.(m-1)"
should be specified before "sing.m".
</p>
<p><code>sbfit.matrix</code> calls <code>sbfit.default</code> repeatedly, once for each row
vector <code>bp</code> of the matrix <code>bps</code>.  Parallel
computing is performed when <code>cluster</code> is non NULL.
</p>
<p><code>sbfit.scaleboot</code> calls <code>sbfit.default</code> with <code>bp</code>,
<code>nb</code>, and <code>sa</code> components in <code>x</code> object for refitting by
giving another <code>models</code> argument. It discards the previous result
of fitting, and recomputes the model parameters.
</p>
<p><code>sbfit.scalebootv</code> calls <code>sbfit.matrix</code> with the <code>bps</code>,
<code>nb</code>, and <code>sa</code> components in the attributes of <code>x</code>.
</p>


<h3>Value</h3>

<p><code>sbfit.default</code> and <code>sbfit.scaleboot</code> return an object of
class <code>"scaleboot"</code>, and <code>sbfit.matrix</code> and
<code>sbfit.scalebootv</code> return an object of
class <code>"scalebootv"</code>. 
</p>
<p>An object of class <code>"scaleboot"</code> is a list containing at least the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>bp</code></td>
<td>
<p>the vector of bootstrap probabilities used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>the <code>rep(nb,length=length(bp))</code> used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sa</code></td>
<td>
<p>the <code>sa</code> used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fi</code></td>
<td>
<p>list vector of fitted results for <code>models</code> used.  Each
list consists of components <code>"par"</code> (estimated parameter),
<code>"mag"</code> (magnification factor for <code>"par"</code> to make the actual
parameter vector <code>beta=par*mag</code>),
<code>"value"</code> (maximum log-likelihood), <code>"hessian"</code> (hessian
matrix), <code>"var"</code> (variance estimate of <code>"par"</code>),
<code>"mask"</code> (logical vector indicating parameter elements which are
not at boundaries),
<code>"init"</code> (initial values used for optimization),
<code>"psi"</code> (psi function name of the model), <code>"df"</code>
(degrees of freedom), <code>"rss"</code> (equivalent to the residual sum
of squares, but actually defined as 2*(lik0-lik) where lik0 and lik
are the log-likelihood function of the non-restricted model and the
model of interest, respectively), <code>"pfit"</code> (p-value for
<code>"rss"</code>),
<code>"aic"</code> (aic value of the model relative to the non-restricted
model).</p>
</td>
</tr>
</table>
<p>An object of class <code>"scalebootv"</code> is a vector of
<code>"scaleboot"</code> objects, and in addition, it has attributes
<code>"models"</code>, <code>"bps"</code>, <code>"nb"</code>, and <code>"sa"</code>. 
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira &lt;shimo@i.kyoto-u.ac.jp&gt;</p>


<h3>References</h3>

<p>Shimodaira, H. (2002).  An approximately unbiased test of phylogenetic
tree selection, <em>Systematic Biology</em>, 51, 492-508.
</p>
<p>Shimodaira, H. (2004).  Approximately unbiased tests of
regions using multistep-multiscale bootstrap resampling,
<em>Annals of Statistics</em>, 32, 2616-2641. 
</p>
<p>Shimodaira, H. (2008). Testing Regions with Nonsmooth Boundaries via
Multiscale Bootstrap, <em>Journal of Statistical Planning and
Inference</em>, 138, 1227-1241.
(<a href="http://dx.doi.org/10.1016/j.jspi.2007.04.001">http://dx.doi.org/10.1016/j.jspi.2007.04.001</a>).
</p>


<h3>See Also</h3>

<p><code>sbpsi</code>, <code>summary.scaleboot</code>,
<code>plot.scaleboot</code>, <code>coef.scaleboot</code>,
<code>sbaic</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Testing a hypothesis
## Examples of fitting models to a vector of bp's
## mam15.relltest$t4 of data(mam15), but
## using a different set of scales (sigma^2 values).
## In the below, sigma^2 ranges 0.01 to 100 in sa[i]
## This very large range is only for illustration.
## Typically, the range around 0.1 to 10
## is recommended for much better model fitting.
## In other examples, we have used
## sa = 9^seq(-1,1,length=13).

cnt &lt;- c(0,0,0,0,6,220,1464,3565,5430,6477,6754,
         6687,5961) # observed frequencies at scales
nb &lt;- 100000 # number of replicates at each scale
bp &lt;- cnt/nb # bootstrap probabilities (bp's)
sa &lt;- 10^seq(-2,2,length=13) # scales (sigma squared)
## model fitting to bp's 
f &lt;- sbfit(bp,nb,sa) # model fitting ("scaleboot" object)
f # print the result of fitting
plot(f,legend="topleft") # observed bp's and fitted curves
## approximately unbiased p-values
summary(f) # calculate and print p-values
## refitting with models up to "poly.4" and "sing.4"
f &lt;- sbfit(f,models=1:4)
f # print the result of fitting
plot(f,legend="topleft") # observed bp's and fitted curves
summary(f) # calculate and print p-values

## Not run: 
## Testing multiple hypotheses (only two here)
## Examples of fitting models to vectors of bp's
## mam15.relltest[c("t1,t2")]
cnt1 &lt;- c(85831,81087,76823,72706,67946,62685,57576,51682,
       45887,41028,35538,31232,27832)  # cnt for "t1"
cnt2 &lt;- c(2,13,100,376,975,2145,3682,5337,7219,8559,
       10069,10910,11455)  # cnt for "t2"
cnts &lt;- rbind(cnt1,cnt2)
nb &lt;- 100000 # number of replicates at each scale
bps &lt;- cnts/nb # row vectors are bp's
sa &lt;- 9^seq(-1,1,length=13) # scales (sigma squared)
fv &lt;- sbfit(bps,nb,sa) # returns a "scalebootv" object
fv # print the result of fitting
plot(fv) # multiple plots
summary(fv) # calculate and print p-values

## End(Not run)
</code></pre>


</div>