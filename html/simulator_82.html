<div class="container">

<table style="width: 100%;"><tr>
<td>plot_eval_by</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot a metric across multiple values of a model parameter</h2>

<h3>Description</h3>

<p>This function is to be used on simulations in which
<code>generate_model</code> was called using the <code>vary_along</code>
parameter.  When this is a single (scalar) numeric parameter, a single plot
is created in which the x-axis is this parameter.  Eventually, this function
should handle one or two categorical variables (in which facets are used)
and one categorical combined with one continuous variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_eval_by(
  sim,
  metric_name,
  varying,
  type = c("aggregated", "raw"),
  center_aggregator = NULL,
  spread_aggregator = NULL,
  use_ggplot2 = TRUE,
  main,
  xlab,
  ylab,
  xlim,
  ylim,
  include_zero = FALSE,
  legend_location = "topright",
  method_col = seq(num_methods),
  method_lty = rep(1, num_methods),
  method_lwd = rep(1, num_methods),
  method_pch = rep(1, num_methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>an object of class <code>Simulation</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric_name</code></td>
<td>
<p>the name of a metric to plot (ignored if custom
aggregator is provided)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varying</code></td>
<td>
<p>character vector giving the name of a parameter that is
varied across the models in evals. For now, this parameter must be
numeric and there cannot be multiple models having the same value
of this parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>if "aggregated" then shows line with error bars (line represents
center_aggregator and error bars represent spread_aggregator; by
default these are sample mean and estimated standard error); if
<code>type</code> is "raw" then shows the raw data as points (with smoother
overlayed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center_aggregator</code></td>
<td>
<p>ignored if <code>type</code> is "raw".  When NULL (which
is default), the sample mean aggregator is used.  User can write
specialized aggregators (see definition of class
<code>Aggregator</code>) as necessary, for example, when the
evaluated metric is not scalar-valued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spread_aggregator</code></td>
<td>
<p>ignored if <code>type</code> is "raw".  When NULL (which
is default), the sample mean aggregator is used.  User can write
specialized aggregators (see definition of class
<code>Aggregator</code>) as necessary, for example, when the
evaluated metric is not scalar-valued. Set <code>spread_aggregator</code>
to <code>NA</code> to hide error bars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_ggplot2</code></td>
<td>
<p>whether to use <code>ggplot2</code> (requires installation
of <code>ggplot2</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>title of plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>the x-axis label (default is <code>varying</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>the y-axis label (default is <code>metric_label</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>the x-axis limits to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>the y-axis limits to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_zero</code></td>
<td>
<p>whether ylim should include 0.  Ignored if ylim
is passed explicitly</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend_location</code></td>
<td>
<p>location of legend.  Set to NULL to remove legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method_col</code></td>
<td>
<p>color to use for each method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method_lty</code></td>
<td>
<p>line style to use for each method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method_lwd</code></td>
<td>
<p>line thickness to use for each method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method_pch</code></td>
<td>
<p>point style to use for each method (default is that no
points, only lines are drawn)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to pass to <code>plot</code> (only when
<code>use_ggplot2 = FALSE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>type</code> is "raw", the individual evals are shown (one point per
model-draw-method triplet) along with a loess smooth.  When <code>type</code> is
"aggregated", then <code>center_aggregator</code> and <code>spread_aggregator</code>
are used.  <code>center_aggregator</code> is used to draw a single line per method
in which the individual evals computed for each draw has been been
aggregated in some way.  By default, the <code>mean_aggregator</code> is used,
which simply averages the evals computed across all draws.  When
<code>spread_aggregator</code> is non-NULL, "error bars" are drawn with
(half)widths computed using <code>spread_aggregator</code>.  By default, the
<code>se_aggregator</code> is used, which gives an estimate of the standard error
of the sample mean.
</p>
<p>The arguments method_col, method_lty, method_lwd, method_pch only
apply when use_ggplot2 is FALSE.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
 # suppose previously we had run the following:
 sim &lt;- new_simulation(name = "normal-example",
                       label = "Normal Mean Estimation",
                       dir = tempdir()) %&gt;%
   generate_model(make_my_example_model,
                  n = list(10, 20, 30),
                  vary_along = "n") %&gt;%
   simulate_from_model(nsim = 50, index = 1:3) %&gt;%
   run_method(my_example_method) %&gt;%
   evaluate(my_example_loss)
   # then we could plot this
   plot_eval_by(sim, "myloss", varying = "n", include_zero = TRUE)
 
## End(Not run)
</code></pre>


</div>