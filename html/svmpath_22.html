<div class="container">

<table style="width: 100%;"><tr>
<td>svmpath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit the entire regularization path for a 2-class SVM</h2>

<h3>Description</h3>

<p>The SVM has a regularization or cost parameter C, which controls the
amount by which points overlap their soft margins. Typically either a
default large value for C is chosen (allowing minimal overlap),
or else a few values are compared
using a validation set. This algorithm computes the entire
regularization path (i.e. for all possible values of C for which the
solution changes), with a cost a small (~3)  multiple of the cost of fitting a
single model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">svmpath(x, y, K, kernel.function = poly.kernel, param.kernel = 1, trace,
  plot.it, eps = 1e-10, Nmoves = 3 * n, digits = 6, lambda.min = 1e-04,ridge=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the data matrix (n x p) with n rows (observations) on p
variables (columns)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The "-1,+1" valued response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>a n x n kernel matrix, with default value <code>K= kernel.function(x, x)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.function</code></td>
<td>
<p>This is a user-defined function. Provided are
<code>poly.kernel</code> (the default, with parameter set to default to a
linear kernel) and <code>radial.kernel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param.kernel</code></td>
<td>
<p>parameter(s) of the kernels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>if <code>TRUE</code>, a progress report is printed as the
algorithm runs; default is <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>a flag indicating whether a plot should be produced
(default <code>FALSE</code>; only usable with <code>p=2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>a small machine number which is used to identify minimal
step sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nmoves</code></td>
<td>
<p>the maximum number of moves</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of digits in the printout</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The smallest value of <code>lambda = 1/C</code>; default
is <code>lambda=10e-4</code>, or <code>C=10000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge</code></td>
<td>
<p>Sometimes the algorithm encounters singularities; in this
case a small value of ridge, around 1e-12, can help. Default is <code>ridge=0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to some of the functions called by
svmpath. One such argument that can be passed is <code>ridge</code> (default
is 1e-10). This is used to produce "stable" solutions to linear equations.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm used in <code>svmpath()</code> is described in detail in
"The Entire Regularization Path for the Support Vector Machine" by
Hastie, Rosset, Tibshirani and Zhu (2004). It exploits the fact that
the "hinge" loss-function is piecewise linear, and the penalty term is
quadratic. This means that in the dual space, the lagrange multipliers
will be pieceise linear (c.f. <code>lars</code>).
</p>


<h3>Value</h3>

<p>a "svmpath" object is returned, for which there are print, summary, coef
and predict methods.</p>


<h3>Warning</h3>

<p>Currently the algorithm can get into machine errors if
<code>epsilon</code> is too small, or if <code>lambda.min</code> is too
small. Increasing either from their defaults should make the problems
go away, by terminating the algorithm slightly early.</p>


<h3>Note</h3>

<p>This implementation of the algorithm does not use updating to solve the "elbow"
linear equations. This is possible, since the elbow changes by a small
number of points at a time. Future version of the software will do
this. The author has encountered numerical problems with early
attempts at this.</p>


<h3>Author(s)</h3>

<p>Trevor Hastie</p>


<h3>References</h3>

<p>The paper <a href="http://www-stat.stanford.edu/~hastie/Papers/svmpath.pdf">http://www-stat.stanford.edu/~hastie/Papers/svmpath.pdf</a>, as well
as the talk <a href="http://www-stat.stanford.edu/~hastie/TALKS/svmpathtalk.pdf">http://www-stat.stanford.edu/~hastie/TALKS/svmpathtalk.pdf</a>.
</p>


<h3>See Also</h3>

<p>print, coef, summary, predict, and FilmPath</p>


<h3>Examples</h3>

<pre><code class="language-R">data(svmpath)
attach(unbalanced.separated)
svmpath(x,y,trace=TRUE,plot=TRUE)
detach(2)
## Not run: svmpath(x,y,kernel=radial.kernel,param.kernel=.8)
</code></pre>


</div>