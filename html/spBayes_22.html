<div class="container">

<table style="width: 100%;"><tr>
<td>spMvGLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for fitting multivariate Bayesian generalized linear spatial regression models</h2>

<h3>Description</h3>

<p>The function <code>spMvGLM</code> fits multivariate Bayesian
generalized linear spatial regression models. Given a set of knots,
<code>spMvGLM</code> will also fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class="language-R">spMvGLM(formula, family="binomial", weights, data = parent.frame(), coords, knots,
      starting, tuning, priors, cov.model,
      amcmc, n.samples, 
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression model descriptions to be fit. See example below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional <code class="reqn">n \times q</code> matrix of weights
to be used in the fitting process. The order of the
columns correspond to the univariate models in the formula list. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spMvGLM</code> is called.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) or a vector of length two or three with the
first and second elements recording the  number of columns and rows in
the desired knot grid. The third, optional, element sets the offset of
the outermost knots from the extent of the <code>coords</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. Valid tags are <code>beta</code>, <code>A</code>, <code>phi</code>,
<code>nu</code>, and <code>w</code>. The value portion of each tag is a vector
that holds the parameter's starting values and are of length
<code class="reqn">p</code> for <code>beta</code> (where <code class="reqn">p</code> is the total number of regression coefficients in the multivariate model), <code class="reqn">\frac{q(q+1)}{2}</code> for
<code>A</code>, and <code class="reqn">q</code> for <code>phi</code>, and <code>nu</code>. Here, <code>A</code> holds the the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix. If the
<em>predictive process</em> is used then <code>w</code> 
must be of length <code class="reqn">qm</code>; otherwise,
it must be of length <code class="reqn">qn</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with tags <code>beta</code>, <code>A</code>, <code>phi</code>,
<code>nu</code>, and <code>w</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution. The value portion of these tags is of length <code class="reqn">p</code> for <code>beta</code>, <code class="reqn">\frac{q(q+1)}{2}</code> for
<code>A</code>, and <code class="reqn">q</code> for <code>phi</code>, and <code>nu</code>. Here, <code>A</code>
holds the tuning values corresponding to the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix.   If the
<em>predictive process</em> is used then <code>w</code> 
must be of length <code class="reqn">qm</code>; otherwise,
it must be of length <code class="reqn">qn</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.  The tuning value for <code>beta</code> can be a vector of length <code class="reqn">p</code> or, if an adaptive MCMC is not used,
i.e., <code>amcmc</code> is not specified, the lower-triangle of the
<code class="reqn">p\times p</code> Cholesky square-root of the desired proposal
covariance matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta.flat</code>,
<code>beta.norm</code>, <code>K.iw</code>, <code>phi.unif</code>, and
<code>nu.unif</code>. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. The spatial cross-covariance matrix <code>K</code> is assumed to follow an
inverse-Wishart distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Wishart are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively. The hyperparameters of the Uniform are also passed as a list of vectors with the first and second list elements corresponding to the lower and upper
support, respectively. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code>glm</code> <code>offset</code> argument which is passed as the
log of this value.  
</p>
<p>A non-spatial model is fit when <code>coords</code> is not specified. See
example below.  
</p>


<h3>Value</h3>

<p>An object of class <code>spMvGLM</code>, which is a list with the following
tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.w</code></td>
<td>
<p>if this is a non-predictive process model and
<code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.w.knots</code></td>
<td>
<p>if this is a <em>predictive process</em> model and <code>amcmc</code> is used then this will be a matrix of
the Metropolis sampler acceptance rate for each knot's spatial random effect. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.knots.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the knots' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">q\times m</code> knot locations and the columns are the
posterior samples. This is only returned if a <em>predictive process</em> model
is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">q\times n</code> point observations and the columns are the
posterior samples. </p>
</td>
</tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., S. Banerjee, and R.E. McRoberts. (2008) A Bayesian
approach to quantifying uncertainty in multi-source forest area
estimates. <em>Environmental and Ecological Statistics</em>,
15:241–258.
</p>
<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian
Predictive Process Models for Large Spatial Datasets. <em>Journal of
the Royal Statistical Society Series B</em>, 70:825–848.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873-2884.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1–28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006) Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint. 
</p>


<h3>See Also</h3>

<p><code>spGLM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(MBA)

##Some useful functions
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##Generate some data
n &lt;- 25 ##number of locations
q &lt;- 2 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##Parameters for the bivariate spatial random effects
theta &lt;- rep(3/0.5,q)

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,-1,0.25)
K &lt;- A%*%t(A)

Psi &lt;- diag(0,q)

C &lt;- mkSpCov(coords, K, Psi, theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C)

w.1 &lt;- w[seq(1,length(w),q)]
w.2 &lt;- w[seq(2,length(w),q)]

##Covariate portion of the mean
x.1 &lt;- cbind(1, rnorm(n))
x.2 &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.1, x.2))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B &lt;- c(B.1, B.2)

weight &lt;- 10 ##i.e., trials 
p &lt;- 1/(1+exp(-(x%*%B+w)))
y &lt;- rbinom(n*q, size=rep(weight,n*q), prob=p)

y.1 &lt;- y[seq(1,length(y),q)]
y.2 &lt;- y[seq(2,length(y),q)]

##Call spMvLM
fit &lt;- glm((y/weight)~x-1, weights=rep(weight, n*q), family="binomial")
beta.starting &lt;- coefficients(fit)
beta.tuning &lt;- t(chol(vcov(fit)))

A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]

n.batch &lt;- 100
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

starting &lt;- list("beta"=beta.starting, "phi"=rep(3/0.5,q), "A"=A.starting, "w"=0)
tuning &lt;- list("beta"=beta.tuning, "phi"=rep(1,q), "A"=rep(0.1,length(A.starting)),
               "w"=0.5)
priors &lt;- list("beta.Flat", "phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)))

m.1 &lt;- spMvGLM(list(y.1~x.1-1, y.2~x.2-1),
               coords=coords, weights=matrix(weight,n,q),
               starting=starting, tuning=tuning, priors=priors,
               amcmc=list("n.batch"=n.batch,"batch.length"=batch.length,"accept.rate"=0.43),
               cov.model="exponential", n.report=25)

burn.in &lt;- 0.75*n.samples
sub.samps &lt;- burn.in:n.samples

print(summary(window(m.1$p.beta.theta.samples, start=burn.in))$quantiles[,c(3,1,5)])

beta.hat &lt;- t(m.1$p.beta.theta.samples[sub.samps,1:length(B)])
w.hat &lt;- m.1$p.w.samples[,sub.samps]

p.hat &lt;- 1/(1+exp(-(x%*%beta.hat+w.hat)))

y.hat &lt;- apply(p.hat, 2, function(x){rbinom(n*q, size=rep(weight, n*q), prob=p)})

y.hat.mu &lt;- apply(y.hat, 1, mean)

##Unstack to get each response variable fitted values
y.hat.mu.1 &lt;- y.hat.mu[seq(1,length(y.hat.mu),q)]
y.hat.mu.2 &lt;- y.hat.mu[seq(2,length(y.hat.mu),q)]

##Take a look
par(mfrow=c(2,2))
surf &lt;- mba.surf(cbind(coords,y.1),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed y.1 positive trials")
contour(surf, add=TRUE)
points(coords)
zlim &lt;- range(surf[["z"]], na.rm=TRUE)

surf &lt;- mba.surf(cbind(coords,y.hat.mu.1),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, zlim=zlim, main="Fitted y.1 positive trials")
contour(surf, add=TRUE)
points(coords)

surf &lt;- mba.surf(cbind(coords,y.2),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed y.2 positive trials")
contour(surf, add=TRUE)
points(coords)
zlim &lt;- range(surf[["z"]], na.rm=TRUE)

surf &lt;- mba.surf(cbind(coords,y.hat.mu.2),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, zlim=zlim, main="Fitted y.2 positive trials")
contour(surf, add=TRUE)
points(coords)

## End(Not run)
</code></pre>


</div>