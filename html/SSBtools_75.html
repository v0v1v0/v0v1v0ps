<div class="container">

<table style="width: 100%;"><tr>
<td>Mipf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iterative proportional fitting from matrix input</h2>

<h3>Description</h3>

<p>The linear equation, <code>z = t(x) %*% y</code>, is (hopefully)  solved for <code>y</code> by
iterative proportional fitting
</p>


<h3>Usage</h3>

<pre><code class="language-R">Mipf(
  x,
  z = NULL,
  iter = 100,
  yStart = matrix(1, nrow(x), 1),
  eps = 0.01,
  tol = 1e-10,
  reduceBy0 = FALSE,
  reduceByColSums = FALSE,
  reduceByLeverage = FALSE,
  returnDetails = FALSE,
  y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a single column matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yStart</code></td>
<td>
<p>a starting estimate of <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>stopping criterion. Maximum allowed value of <code>max(abs(z - t(x) %*% yHat))</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Another stopping criterion. Maximum absolute difference between two iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduceBy0</code></td>
<td>
<p>When TRUE, <code>Reduce0exact</code> used within the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduceByColSums</code></td>
<td>
<p>Parameter to <code>Reduce0exact</code> (when TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduceByLeverage</code></td>
<td>
<p>Parameter to <code>Reduce0exact</code> (when TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDetails</code></td>
<td>
<p>More output when TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>It is possible to set <code>z</code> to NULL and supply original <code>y</code> instead  (<code>z = t(x) %*% y</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm will work similar to <code>loglin</code> when the input x-matrix is a overparameterized model matrix
– as can be created by <code>ModelMatrix</code> and <code>FormulaSums</code>. See Examples.
</p>


<h3>Value</h3>

<p><code>yHat</code>, the estimate of <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data2 &lt;- SSBtoolsData("z2")
x &lt;- ModelMatrix(data2, formula = ~fylke + kostragr * hovedint - 1)
z &lt;- t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z)

#############################
# loglm comparison  
#############################

if (require(MASS)){

# Increase accuracy
yHat &lt;- Mipf(x, z, eps = 1e-04)

# Run loglm and store fitted values in a data frame
outLoglm &lt;- loglm(ant ~ fylke + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Problem 1: Variable region not in output, but instead the variable .Within.  
# Problem 2: Extra zeros since hierarchy not treated. Impossible combinations in output.

# By sorting data, it becomes clear that the fitted values are the same.
max(abs(sort(dfLoglm$Freq, decreasing = TRUE)[1:nrow(data2)] - sort(yHat, decreasing = TRUE)))

# Modify so that region is in output. Problem 1 avoided.
x &lt;- ModelMatrix(data2, formula = ~region + kostragr * hovedint - 1)
z &lt;- t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z, eps = 1e-04)
outLoglm &lt;- loglm(ant ~ region + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Now it is possible to merge data
merg &lt;- merge(cbind(data2, yHat), dfLoglm)

# Identical output
max(abs(merg$yHat - merg$Freq))

}

## End(Not run)

#############################
# loglin comparison  
#############################


# Generate input data for loglin
n &lt;- 5:9
tab &lt;- array(sample(1:prod(n)), n)

# Input parameters
iter &lt;- 20
eps &lt;- 1e-05

# Estimate yHat by loglin
out &lt;- loglin(tab, list(c(1, 2), c(1, 3), c(1, 4), c(1, 5), c(2, 3, 4), c(3, 4, 5)), 
              fit = TRUE, iter = iter, eps = eps)
yHatLoglin &lt;- matrix(((out$fit)), ncol = 1)

# Transform the data for input to Mipf
df &lt;- as.data.frame.table(tab)
names(df)[1:5] &lt;- c("A", "B", "C", "D", "E")
x &lt;- ModelMatrix(df, formula = ~A:B + A:C + A:D + A:E + B:C:D + C:D:E - 1)
z &lt;- t(x) %*% df$Freq

# Estimate yHat by Mipf
yHatPMipf &lt;- Mipf(x, z, iter = iter, eps = eps)

# Maximal absolute difference
max(abs(yHatPMipf - yHatLoglin))

# Note: loglin reports one iteration extra 

# Another example. Only one iteration needed.
max(abs(Mipf(x = FormulaSums(df, ~A:B + C - 1), 
             z = FormulaSums(df, Freq ~ A:B + C -1)) 
             - matrix(loglin(tab, list(1:2, 3), fit = TRUE)$fit, ncol = 1)))


#########################################
# Examples utilizing Reduce0exact 
#########################################

z3 &lt;- SSBtoolsData("z3")
x &lt;- ModelMatrix(z3, formula = ~region + kostragr * hovedint + region * mnd2 + fylke * mnd + 
                     mnd * hovedint + mnd2 * fylke * hovedint - 1)

# reduceBy0, but no iteration improvement. Identical results.
t &lt;- 360
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 0.1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 0.1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 0.1)
max(abs(a1 - a2))
max(abs(a1 - a3))


## Not run: 
# Improvement by reduceByColSums. Changing eps and iter give more similar results.
t &lt;- 402
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))


# Improvement by ReduceByLeverage. Changing eps and iter give more similar results.
t &lt;- 378
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
a4 &lt;- Mipf(x, z, reduceByLeverage = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))
max(abs(a1 - a4))


# Example with small eps and "Iteration stopped since tol reached"
t &lt;- 384
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1e-14)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1e-14)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1e-14)
max(abs(a1 - a2))
max(abs(a1 - a3))

## End(Not run)

# All y-data found by reduceByColSums (0 iterations). 
t &lt;- 411
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE)
max(abs(a1 - y))
max(abs(a2 - y))
max(abs(a3 - y))
</code></pre>


</div>