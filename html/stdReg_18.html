<div class="container">

<table style="width: 100%;"><tr>
<td>stdParfrailty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regression standardization in shared frailty gamma-Weibull models
</h2>

<h3>Description</h3>

<p><code>stdParfrailty</code> performs regression standardization in shared frailty gamma-Weibull models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival outcome, the exposure, and a
vector of covariates, respectively. <code>stdParfrailty</code> uses a fitted Cox 
proportional hazards model to estimate the standardized 
survival function <code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code>, where <code class="reqn">t</code> is a specific value of <code class="reqn">T</code>, 
<code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, and the expectation is over the marginal 
distribution of <code class="reqn">Z</code>.     
</p>


<h3>Usage</h3>

<pre><code class="language-R">stdParfrailty(fit, data, X, x, t, clusterid, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>an object of class <code>"parfrailty"</code>, as returned by the <code>parfrailty</code> function 
in the <span class="pkg">stdReg</span> package.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized survival function. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal survival 
function <code class="reqn">S(t)=E\{S(t|X,Z)\}</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">T</code> at which to estimate 
the standardized survival function. It defaults to all the observed event times
in <code>data</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterid</code></td>
<td>

<p>a string containing the name of the cluster identification variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stdParfrailty</code> assumes that a shared frailty gamma-Weibull model 
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|X_{ij},Z_{ij})=\lambda(t_{ij};\alpha,\eta)U_iexp\{h(X_{ij},Z_{ij};\beta)\}</code>
</p>

<p>has been fitted, with parametrization as descibed in the help section for <code>parfrailty</code>.
Integrating out the gamma frailty gives the survival function
</p>
<p style="text-align: center;"><code class="reqn">S(t|X,Z)=[1+\phi\Lambda_0(t;\alpha,\eta)exp\{h(X,Z;\beta)\}]^{-1/\phi},</code>
</p>

<p>where <code class="reqn">\Lambda_0(t;\alpha,\eta)</code> is the cumulative baseline hazard
</p>
<p style="text-align: center;"><code class="reqn">(t/\alpha)^{\eta}.</code>
</p>

<p>The ML estimates of <code class="reqn">(\alpha,\eta,\phi,\beta)</code> are used to obtain 
estimates of the survival function <code class="reqn">S(t|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=[1+\hat{\phi}\Lambda_0(t;\hat{\alpha},\hat{\eta})exp\{h(X,Z;\hat{\beta})\}]^{-1/\hat{\phi}}.</code>
</p>
 
<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the <code>x</code> argument, 
these estimates are averaged across all subjects (i.e. all observed values of <code class="reqn">Z</code>)
to produce estimates 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n.</code>
</p>
 
<p>The variance for <code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdParfrailty"</code> is a list containing 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>

<p>a matrix with <code>length(t)</code> rows and <code>length(x)</code> columns, where the element 
on row <code>i</code> and column <code>j</code> is equal to <code class="reqn">\hat{\theta}</code>(<code>t[i],x[j]</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>

<p>a list with <code>length(t)</code> elements. Each element is a square matrix with 
<code>length(x)</code> rows. In the <code>k:th</code> matrix, the element on row <code>i</code> 
and column <code>j</code> is the (estimated) covariance of <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[i]</code>) 
and <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[j]</code>).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct) adjusted
survival functions in the literature.
</p>
<p><code>stdParfrailty</code> does not currently handle time-varying exposures or covariates. 
</p>
<p><code>stdParfrailty</code> internally loops over all values in the <code>t</code> argument. Therefore,
the function will usually be considerably faster if <code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>stdParfrailty</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that the 
term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance decomposition 
for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, <code class="reqn">\theta(t,x)</code> depends 
on <code class="reqn">\bar{Z}</code> through the average over the sample distribution for <code class="reqn">Z</code>, 
and thus the term <code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> is not 0, unless one 
conditions on <code class="reqn">\bar{Z}</code>. The variance calculation by Gail and Byar (1986) ignores this term,
and thus effectively conditions on <code class="reqn">\bar{Z}</code>.      
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>, 669-674.
</p>
<p>Dahlqwist E., Pawitan Y., Sjolander A. (2019). Regression standardization 
and attributable fraction estimation with between-within frailty models for 
clustered survival data. <em>Statistical Methods in Medical Research</em> 
<b>28</b>(2), 462-485.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted survival
curves, with applications to testing for no treatement effect. <em>Biometrical Journal</em>
<b>28</b>(5), 587-599. 
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

require(survival)

#simulate data
n &lt;- 1000
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each=m)
U &lt;- rep(rgamma(n, shape=1/phi, scale=phi), each=m)
X &lt;- rnorm(n*m)
#reparametrize scale as in rweibull function
weibull.scale &lt;- alpha/(U*exp(beta*X))^(1/eta)
T &lt;- rweibull(n*m, shape=eta, scale=weibull.scale)

#right censoring
C &lt;- runif(n*m, 0, 10)
D &lt;- as.numeric(T&lt;C)
T &lt;- pmin(T, C)
  
#strong left-truncation
L &lt;- runif(n*m, 0, 2)
incl &lt;- T&gt;L
incl &lt;- ave(x=incl, id, FUN=sum)==m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]  
 
fit &lt;- parfrailty(formula=Surv(L, T, D)~X, data=dd, clusterid="id")
fit.std &lt;- stdParfrailty(fit=fit, data=dd, X="X", x=seq(-1,1,0.5), t=1:5, clusterid="id")
print(summary(fit.std, t=3))
plot(fit.std)


## End(Not run)

</code></pre>


</div>