<div class="container">

<table style="width: 100%;"><tr>
<td>kcores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute the k-Core Structure of a Graph
</h2>

<h3>Description</h3>

<p><code>kcores</code> calculates the k-core structure of the input network, using the centrality measure indicated in <code>cmode</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kcores(dat, mode = "digraph", diag = FALSE, cmode = "freeman",
    ignore.eval = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>one or more (possibly valued) graphs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>

<p><code>"digraph"</code> for directed data, otherwise <code>"graph"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>

<p>logical; should self-ties be included in the degree calculations?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmode</code></td>
<td>

<p>the <code>degree</code> centrality mode to use when constructing the cores.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.eval</code></td>
<td>

<p>logical; should edge values be ignored when computing degree?
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">G=(V,E)</code> be a graph, and let <code class="reqn">f(v,S,G)</code> for <code class="reqn">v \in V, S\subseteq V</code> be a real-valued <em>vertex property function</em> (in the language of Batagelj and Zaversnik).  Then some set <code class="reqn">H \subseteq V</code> is a <em>generalized k-core</em> for <code class="reqn">f</code> if <code class="reqn">H</code> is a maximal set such that <code class="reqn">f(v,H,G)\ge k</code> for all <code class="reqn">v \in H</code>.  Typically, <code class="reqn">f</code> is chosen to be a degree measure with respect to <code class="reqn">S</code> (e.g., the number of ties to vertices in <code class="reqn">S</code>).  In this case, the resulting k-cores have the intuitive property of being maximal sets such that every set member is tied (in the appropriate manner) to at least k others within the set.
</p>
<p>Degree-based k-cores are a simple tool for identifying well-connected structures within large graphs.  Let the <em>core number</em> of vertex <code class="reqn">v</code> be the value of the highest-value core containing <code class="reqn">v</code>.  Then, intuitively, vertices with high core numbers belong to relatively well-connected sets (in the sense of sets with high minimum internal degree).  It is important to note that, while a given k-core need not be connected, it is composed of subsets which are themselves well-connected; thus, the k-cores can be thought of as unions of relatively cohesive subgroups.  As k-cores are nested, it is also natural to think of each k-core as representing a “slice” through a hypothetical “cohesion surface” on <code class="reqn">G</code>.  (Indeed, k-cores are often visualized in exactly this manner.)
</p>
<p>The <code>kcores</code> function produces degree-based k-cores, for various degree measures (with or without edge values).  The return value is the vector of core numbers for <code class="reqn">V</code>, based on the selected degree measure.  Missing (i.e., <code>NA</code>) edge are removed for purposes of the degree calculation.
</p>


<h3>Value</h3>

<p>A vector containing the maximum core membership for each vertex.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Batagelj, V. and Zaversnik, M.  (2002).  “An <code class="reqn">O(m)</code> Algorithm for Cores Decomposition of Networks.”  arXiv:cs/0310049v1
</p>
<p>Batagelj, V. and Zaversnik, M.  (2002).  “Generalized Cores.” 	arXiv:cs/0202039v1
</p>
<p>Wasserman, S. and Faust,K.  (1994).  <em>Social Network Analysis: Methods and Applications</em>.  Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code>degree</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate a graph with core-periphery structure
cv&lt;-runif(30)
g&lt;-rgraph(30,tp=cv%o%cv)

#Compute the k-cores based on total degree
kc&lt;-kcores(g)
kc

#Plot the result
gplot(g,vertex.col=kc)
</code></pre>


</div>