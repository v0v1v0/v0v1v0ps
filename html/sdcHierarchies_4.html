<div class="container">

<table style="width: 100%;"><tr>
<td>hier_compute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute a nested hierarchy</h2>

<h3>Description</h3>

<p>This function allows to compute a nested hierarchy from an character
vector or a (named) list.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hier_compute(inp, dim_spec = NULL, root = NULL, method = "len", as = "network")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>inp</code></td>
<td>
<p>a character vector (for methods <code>"len"</code> and <code>"endpos"</code>
containing codes of a hierarchical variables or a list for
method <code>list</code>. In the latter case, the input is expected to be a
named list where each list-element contains the codes belonging to the
node that has the name of this specific list element. In the examples
below, the required input formats are further explained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim_spec</code></td>
<td>
<p>an (integerish) vector containing either the length
(in terms of characters) for each level or the end-positions of
these levels. In the latter-case, one needs to set argument
<code>method</code> to <code>"endpos"</code>. This argument is ignored in case the
hierarchy should be created from a named list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p><code>NULL</code> or a scalar characer specifying the name
of the overall total in case it is not encoded at the first
positions of <code>dim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either <code>"len"</code> (the default) or <code>"endpos"</code>
</p>

<ul>
<li> <p><code>"len"</code>: the number of characters for each of the levels
needs to be specified
</p>
</li>
<li> <p><code>"endpos"</code>: the end-positions for each levels need to be fixed
</p>
</li>
<li> <p><code>"list"</code>: the end-positions for each levels need to be fixed
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as</code></td>
<td>
<p>(character) specifies the type of the return object. Possible
choices are:
</p>

<ul>
<li> <p><code>"network"</code>: the default; a <code>data.table</code> as network. The
table consists of two columns where the <code>"root"</code> column defines the
name of parent node to the label in the <code>"leaf"</code> column.
</p>
</li>
<li> <p><code>"df"</code>: a <code>data.frame</code> in <code>"@; label"</code>-format.
</p>
</li>
<li> <p><code>"dt"</code>: a <code>data.table</code> in <code>"@; label"</code>-format.
</p>
</li>
<li> <p><code>"code"</code>: returns the R-code that is required to build
the tree
</p>
</li>
<li> <p><code>"sdc"</code>: the tree is structured as a list
</p>
</li>
<li> <p><code>"argus"</code>: suitable input for <code>hier_export()</code> to
write <code>"hrc"</code>-files for tau argus.
</p>
</li>
<li> <p><code>"json"</code>: a character-vector encoded as json-string.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a hierarchical data structure depending on choice of
argument <code>as</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example Regional Codes (NUTS)
# digits 1-2 (len=2, endpos=2) --&gt; level 1
# digit 3 (len=1, endpos=3) --&gt; level 2
# digits 4-5 (len=2, endpos=5) -&gt; level 3

# all strings have equal length but total is not encoded in these values
geo_m &lt;- c(
  "01051", "01053", "01054", "01055",
  "01056", "01057", "01058", "01059", "01060",
  "01061", "01062",
  "02000",
  "03151", "03152", "03153", "03154", "03155", "03156", "03157", "03158",
  "03251", "03252", "03254", "03255", "03256", "03257",
  "03351", "03352", "03353", "03354", "03355",
  "03356", "03357", "03358", "03359",
  "03360", "03361",
  "03451", "03452", "03453", "03454", "03455", "03456",
  "10155")

a &lt;- hier_compute(
  inp = geo_m,
  dim_spec = c(2, 3, 5),
  root = "Tot",
  method = "endpos"
)
b &lt;- hier_compute(
  inp = geo_m,
  dim_spec = c(2, 1, 2),
  root = "Tot",
  method = "len"
)
identical(
  hier_convert(a, as = "df"),
  hier_convert(b, as = "df")
)

# total is contained in the first 3 positions of the input values
# --&gt; we need to set name of the overall total (argument "root")
# to NULL (the default)
geo_m_with_tot &lt;- paste0("Tot", geo_m)
a &lt;- hier_compute(
  inp = geo_m_with_tot,
  dim_spec = c(3, 2, 1, 2),
  method = "len"
)
b &lt;- hier_compute(
  inp = geo_m_with_tot,
  dim_spec = c(3, 5, 6, 8),
  method = "endpos"
)
identical(a, b)

# example where inputs have unequal length
# the overall total is not included in input vector
yae_h &lt;- c(
  "1.1.1.", "1.1.2.",
  "1.2.1.", "1.2.2.", "1.2.3.", "1.2.4.", "1.2.5.", "1.3.1.",
  "1.3.2.", "1.3.3.", "1.3.4.", "1.3.5.",
  "1.4.1.", "1.4.2.", "1.4.3.", "1.4.4.", "1.4.5.",
  "1.5.", "1.6.", "1.7.", "1.8.", "1.9.", "2.", "3.")

a &lt;- hier_compute(
  inp = yae_h,
  dim_spec = c(2, 4, 6),
  root = "Tot",
  method = "endpos"
)
b &lt;- hier_compute(
  inp = yae_h,
  dim_spec = c(2, 2, 2),
  root = "Tot",
  method = "len"
)
identical(
  hier_convert(a, as = "df"),
  hier_convert(b, as = "df")
)

# Same example, but overall total is contained in the first 3 positions
# of the input values --&gt; argument "root" needs to be
# set to NULL (the default)
yae_h_with_tot &lt;- paste0("Tot", yae_h)
a &lt;- hier_compute(
  inp = yae_h_with_tot,
  dim_spec = c(3, 2, 2, 2),
  method = "len",
)
b &lt;- hier_compute(
  inp = yae_h_with_tot,
  dim_spec = c(3, 5, 7, 9),
  method = "endpos"
)
identical(a, b)

# An example using a list as input (same as above)
# Hierarchy: digits 1-2 (nuts1), digit 3 (nut2), digits 4-5 (nuts3)
# The order of the list-elements is not important but the
# names of input-list correspond to (subtotal/level) names
geo_ll &lt;- list()
geo_ll[["Total"]] &lt;- c("01", "02", "03", "10")
geo_ll[["010"]]   &lt;- c(
  "01051", "01053", "01054", "01055",
  "01056", "01057", "01058", "01059",
  "01060", "01061", "01062"
)
geo_ll[["031"]]   &lt;- c(
  "03151", "03152", "03153", "03154",
  "03155", "03156", "03157", "03158"
)
geo_ll[["032"]]   &lt;- c(
  "03251", "03252", "03254",
  "03255", "03256", "03257"
)
geo_ll[["033"]]   &lt;- c(
  "03351", "03352", "03353", "03354", "03355",
  "03356", "03357", "03358", "03359",
  "03360", "03361"
)
geo_ll[["034"]]   &lt;- c(
  "03451", "03452", "03453",
  "03454", "03455","03456"
)
geo_ll[["01"]]    &lt;- "010"
geo_ll[["02"]]    &lt;- "020"
geo_ll[["020"]]   &lt;- "02000"
geo_ll[["03"]]    &lt;- c("031", "032", "033", "034")
geo_ll[["10"]]    &lt;- "101"
geo_ll[["101"]]   &lt;- "10155"

d &lt;- hier_compute(
  inp = geo_ll,
  root = "Total",
  method = "list"
); d

## Reproduce example from above with input defined as named list
yae_ll &lt;- list()
yae_ll[["Total"]] &lt;- c("1.", "2.", "3.")
yae_ll[["1."]] &lt;- paste0("1.", 1:9, ".")
yae_ll[["1.1."]] &lt;- paste0("1.1.", 1:2, ".")
yae_ll[["1.2."]] &lt;- paste0("1.2.", 1:5, ".")
yae_ll[["1.3."]] &lt;- paste0("1.3.", 1:5, ".")
yae_ll[["1.4."]] &lt;- paste0("1.4.", 1:6, ".")

# return result as data.frame
d &lt;- hier_compute(
  inp = yae_ll,
  root = "Total",
  method = "list",
  as = "df"
); d
</code></pre>


</div>