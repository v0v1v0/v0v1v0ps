<div class="container">

<table style="width: 100%;"><tr>
<td>execute_js_fn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Execute a JavaScript function</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Execute a JavaScript function on zero or more arguments.
</p>
<p><code>execute_js_expr()</code> is a simpler version of <code>execute_js_fn()</code> that can
evaluate simple expressions (e.g. "alert()"). To return a value, you must
do so explicitly using "return".
</p>
<p>These functions are experimental because their names and parameters are
liable to change. Additionally, their behaviour can be inconsistent between
different session types (chromote and selenium) and different browsers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">execute_js_fn(fn, ..., .timeout = NULL, .session = NULL, .debug = FALSE)

execute_js_expr(expr, ..., .timeout = NULL, .session = NULL, .debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A string defining the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to the function/expression. These must be unnamed, since
JavaScript does not support named arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.timeout</code></td>
<td>
<p>How long to wait for any elements to exist in the DOM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.session</code></td>
<td>
<p>The session to use, if <code>...</code> does not contain any
selenider elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.debug</code></td>
<td>
<p>Whether to print the final expression that is executed. Mostly
used for debugging the functions themselves, but can also be used to
identify problems in your own JavaScript code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An expression to execute.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>...</code> can contain <code>selenider_element</code>/<code>selenider_elements</code> objects,
which will be collected and then passed into the function. However,
more complex objects (e.g. lists of selenider elements) will not be
moved into the JavaScript world correctly.
</p>
<p>Similarly, nodes and lists of nodes returned from a JavaScript function will
be converted into their corresponding
<code>selenider_element</code>/<code>selenider_elements</code> objects, while more complex objects
will not. These elements are not lazy (see <code>elem_cache()</code>), so make sure you
only use them while you are sure they are still on the page.
</p>


<h3>Value</h3>

<p>The return value of the JavaScript function, turned back into an R object.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code>back()</code>,
<code>current_url()</code>,
<code>get_page_source()</code>,
<code>open_url()</code>,
<code>reload()</code>,
<code>take_screenshot()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
html &lt;- "
&lt;button class='mybutton'&gt;Click me&lt;/button&gt;
"
session &lt;- minimal_selenider_session(html)

execute_js_fn("(x, y) =&gt; x + y", 1, 1)

execute_js_expr("arguments[0] + arguments[1]", 1, 1)

execute_js_fn("x =&gt; x.click()", s(".mybutton"))

execute_js_expr("arguments[0].click()", s(".mybutton"))

</code></pre>


</div>