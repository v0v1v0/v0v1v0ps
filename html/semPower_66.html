<div class="container">

<table style="width: 100%;"><tr>
<td>semPower.powerCLPM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>semPower.powerCLPM</h2>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in a cross-lagged panel model (CLPM).
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">semPower.powerCLPM(
  type,
  comparison = "restricted",
  nWaves = NULL,
  autoregEffects = NULL,
  crossedEffects = NULL,
  rXY = NULL,
  waveEqual = NULL,
  nullEffect = NULL,
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  standardizedResidualCovariances = TRUE,
  metricInvariance = TRUE,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoregEffects</code></td>
<td>
<p>vector of the autoregressive effects of X and Y (constant across waves), or a list of vectors of autoregressive effects for X and Y from wave to wave, e.g. <code>list(c(.7, .6), c(.5, .5))</code> for a autoregressive effect of .7 for <code>X1 -&gt; X2</code> and .6 for <code>X2 -&gt; X3</code> and autoregressive effects of .5 for <code>Y1 -&gt; Y2</code> and <code>Y2 -&gt; Y3</code>. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossedEffects</code></td>
<td>
<p>vector of crossed effects of X on Y <code>(X -&gt; Y)</code> and vice versa (both constant across waves), or a list of vectors of crossed effects giving the crossed effect of X on Y (and vice versa) for each wave, e.g. <code>list(c(.2, .3), c(.1, .1))</code> for <code style="white-space: pre;">⁠X1 - &gt; Y2⁠</code> = .2, <code>X2 -&gt; Y3</code> = .3, <code>Y1 -&gt; Y2</code> = .1, and <code>Y2 -&gt; Y3</code> = .1. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rXY</code></td>
<td>
<p>vector of (residual-)correlations between X and Y for each wave. If <code>NULL</code>, all (residual-)correlations are zero. Can be a list for multiple groups models, otherwise no group differences are assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>waveEqual</code></td>
<td>
<p>parameters that are assumed to be equal across waves in both the H0 and the H1 model. Valid are <code>'autoregX'</code> and <code>'autoregY'</code> for autoregressive effects, <code>'crossedX'</code> and <code>'crossedY'</code> for crossed effects, <code>'corXY'</code> for residual correlations, or <code>NULL</code> for none (so that all parameters are freely estimated, subject to the constraints defined in <code>nullEffect</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. Valid are the same arguments as in <code>waveEqual</code> and additionally <code>'autoregX = 0'</code>, <code>'autoregY = 0'</code>, <code>'crossedX = 0'</code>, <code>'crossedY = 0'</code> to constrain the X or Y autoregressive effects or the crossed effects to zero, <code>'autoregX = autoregY'</code> and <code>'crossedX = crossedY'</code> to constrain them to be equal for X and Y, and <code>'autoregXA = autoregXB'</code>, <code>'autoregYA = autoregYB'</code>, <code>'crossedXA = crossedXB'</code>, <code>'crossedYA = crossedYB'</code> to constrain them to be equal across groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullWhich</code></td>
<td>
<p>used in conjunction with <code>nullEffect</code> to identify which parameter to constrain when there are &gt; 2 waves and parameters are not constant across waves. For example, <code>nullEffect = 'autoregX = 0'</code> with <code>nullWhich = 2</code> would constrain the second autoregressive effect for X to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>whether all parameters should be treated as standardized (<code>TRUE</code>, the default), implying that unstandardized and standardized regression relations have the same value. If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardizedResidualCovariances</code></td>
<td>
<p>whether the residual covariances provided in <code>rXY</code> should be interpreted as correlations. When <code>TRUE</code> (the default) the unstandardized residual covariances differ from the those provided in <code>rXY</code>. When <code>FALSE</code>, the values provided in <code>rXY</code> are the unstandardized residual covariances, and the standardized residual correlations differ.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metricInvariance</code></td>
<td>
<p>whether metric invariance over waves is assumed (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code>semPower.aPriori()</code>, <code>semPower.postHoc()</code>, and <code>semPower.compromise()</code>, and parameters specifying the factor model. The order of factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves). See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in crossed-lagged panel models (CLPM). In a standard CLPM implemented here,
two variables X and Y are repeatedly assessed at two or more different time points (<code>nWaves</code>), yielding
autoregressive effects (stabilities; X1 -&gt; X2 and Y1 -&gt; Y2),
synchronous effects (X1 &lt;-&gt; Y1, X2 &lt;-&gt; Y2), and cross-lagged effects (X1 -&gt; Y2 and Y1 -&gt; X2).
CLPM including more than two waves are typically implemented assuming that the parameters are constant across waves (<code>waveEqual</code>), and usually omit lag-2 effects (e.g., X1 -&gt; Y3).
CLPM based on latent factors usually assume at least metric invariance of the factors over waves (<code>metricInvariance</code>).
</p>
<p>Relevant hypotheses in arising in a CLPM are:
</p>

<ul>
<li> <p><code>autoregX = 0</code> and <code>autoregY = 0</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is zero.
</p>
</li>
<li> <p><code>crossedX = 0</code> and <code>crossedY = 0</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>), respectively, is zero.
</p>
</li>
<li> <p><code>autoregX = autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y are equal.
</p>
</li>
<li> <p><code>crossedX = crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>) are equal.
</p>
</li>
<li> <p><code>autoregX</code> and <code>autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is equal across waves.
</p>
</li>
<li> <p><code>crossedX</code> and <code>crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>), respectively, is equal across waves.
</p>
</li>
<li> <p><code>corXY</code>: Tests the hypothesis that the (residual-)correlations between X and Y are equal across waves.
</p>
</li>
<li> <p><code>autoregXA = autoregXB</code> and <code>autoregYA = autoregYB</code>: Tests the hypothesis that the autoregressive effect of either X or Y are equal across groups.
</p>
</li>
<li> <p><code>crossedXA = crossedXB</code> and <code>crossedYA = crossedYB</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) or of Y on X (<code>crossedY</code>), respectively, is equal across groups.
</p>
</li>
</ul>
<p>For hypotheses regarding the random-intercept CLPM, see <code>semPower.powerRICLPM()</code>. For hypothesis in autoregressive models, see <code>semPower.powerAutoreg()</code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li>
</ul>
<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that the order of the factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves), i. e., the first factor is treated as the first measurement of X, the second as the first measurement of Y, the third as the second measurement of X, etc..
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li>
<p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li>
</ul>
<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li>
</ul>
<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>semPower.genSigma()</code> <code>semPower.aPriori()</code> <code>semPower.postHoc()</code> <code>semPower.compromise()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Determine required N in a 2-wave CLPM
# to detect a crossed-effect of X (X1 -&gt; Y2) of &gt;= .2 
# with a power of 95% on alpha = 5%, where
# X1 and X2 are measured by 5 indicators loading by .5 each, and
# Y1 and Y2 are measured by 3 indicators loading by .6 each, and
# there is no synchronous correlation between X and Y (rXY = NULL), 
# the stability of X is .8,
# the stability of Y is .7, and
# the crossed-effect of Y (Y1 -&gt; X2) is .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# show summary
summary(powerCLPM)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerCLPM$modelH1, sample.cov = powerCLPM$Sigma,
            sample.nobs = powerCLPM$requiredN, 
            sample.cov.rescale = FALSE)
lavaan::sem(powerCLPM$modelH0, sample.cov = powerCLPM$Sigma,
            sample.nobs = powerCLPM$requiredN, 
            sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, N = 500)

# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powerCLPM &lt;- semPower.powerCLPM(type = 'compromise',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                abratio = 1, N = 500)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerCLPM &lt;- semPower.powerCLPM(type = 'compromise',
                                comparison = 'saturated',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                abratio = 1, N = 500)

# same as above, but assume only observed variables
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                Lambda = diag(4),
                                alpha = .05, beta = .05)

# same as above, but provide reduced loadings matrix to define that
# X1 and X2 are measured by 5 indicators each loading by .4, .5, .6, .5, .4 
# Y1 and Y2 are measured by 3 indicators each loading by .8, .6, .7
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                loadings = list(
                                  c(.4, .5, .6, .5, .4),    # X1
                                  c(.8, .6, .7),            # Y1
                                  c(.4, .5, .6, .5, .4),    # X2
                                  c(.8, .6, .7)             # Y2
                                ),
                                alpha = .05, beta = .05)

# same as above, but do not assume metric invariance across waves
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                metricInvariance = FALSE,
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the crossed-effect of Y (Y1 -&gt; X2) is &gt;= .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the stability of X (X1 -&gt; X2) is &gt;= .8.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the stability of Y (Y1 -&gt; Y2) is &gt;= .7.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the crossed effect of X (X1 -&gt; Y2) of .2 differs from 
# the crossed effect of Y (Y1 -&gt; X2) of .1  
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = crossedY',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the autoregressive effect of X (X1 -&gt; X2) of .8 differs from 
# the autoregressive effect of Y (Y1 -&gt; Y2) of .7  
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregX = autoregY',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but assume that the synchronous correlation between X and Y 
# is .3 at the first wave, and the respective residual correlation is .2 at the second wave, 
# and determine N to detect that synchronous residual correlation (at wave 2) is =&gt; .2.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = c(.3, .2),
                                nullEffect = 'corXY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# Determine required N in a 3-wave CLPM
# to detect a crossed-effect of X (X1 -&gt; Y2 and X2 -&gt; Y3) of &gt;= .2 
# with a power of 95% on alpha = 5%, where
# the crossed, autoregressive, and synchronous effects of X and Y are equal over waves,
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .6 each, and
# the synchronous correlation between X and Y are .2 across all three waves, and
# the stability of X is .8 across all three waves,
# the stability of Y is .7 across all three waves, and
# the crossed-effect of Y (Y1 -&gt; X2, and Y2 -&gt; Y3) is .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = c(.2, .2, .2),
                                waveEqual = c('autoregX', 'autoregY', 
                                              'crossedX', 'crossedY'),
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# Determine required N in a 3-wave CLPM to detect that 
# the crossed-effect of X in wave 1 (X1 -&gt; Y2) of .20 is equal to the 
# the crossed-effect of X in wave 2 (X2 -&gt; Y3) of .10 
# with a power of 95% on alpha = 5%, where
# the autoregressive effects of X and Y are equal over waves,
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .6 each, and
# the synchronous correlation between X and Y are .2, .3, and .4 at the first, 
# second, and third wave, and
# the stability of X is .8 across all three waves,
# the stability of Y is .7 across all three waves, and
# the crossed-effects of Y (Y1 -&gt; X2, and Y2 -&gt; X3) are both .1 
# (but freely estimated for each wave).
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'crossedX',
                                waveEqual = c('autoregX', 'autoregY'),
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the crossed-effect of X at wave 2 is &gt;= .10.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'crossedX',
                                nullWhich = 2,
                                waveEqual = c('autoregX', 'autoregY'),
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the residual correlation between X and Y at wave 2 (of .3) differs from 
# the residual correlation between X and Y at wave 3 (of .4)
# and define unstandardized parameters
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'corXY',
                                waveEqual = c('autoregX', 'autoregY'),
                                standardized = FALSE,
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)


# multiple group example
# determine power in a 3-wave CLPM to detect that 
# the autoregressive effect of X in group 1 (of .8) differs from the 
# autoregressive effect of X in group 2 (of .6)
# with a 500 observations in both groups on alpha = 5%, where
# the autoregressive effects of X and Y are equal over waves (but not across groups),
# the cross-lagged effects of X and Y are equal over waves (and also across groups),
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .4 each, and
# there are no synchronous correlation between X and Y.
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc', alpha = .05, N = list(500, 500),
                                nWaves = 3,
                                autoregEffects = list(
                                # group 1
                                list(c(.8, .8),    # X1 -&gt; X2, X2 -&gt; X3 
                                     c(.7, .7)),   # Y1 -&gt; Y2, Y2 -&gt; Y3
                                # group 2
                                list(c(.6, .6),    # X1 -&gt; X2, X2 -&gt; X3 
                                     c(.7, .7))    # Y1 -&gt; Y2, Y2 -&gt; Y3
                                ),
                                crossedEffects = c(.2, .1),
                                waveEqual = c('autoregX', 'autoregY', 'crossedX', 'crossedY'),
                                rXY = NULL,
                                nullEffect = 'autoregxa=autoregxb',
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .4, .5, .4, .5, .4))
                                

# request a simulated post-hoc power analysis with 500 replications.
set.seed(300121)
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                Lambda = diag(4),
                                alpha = .05, N = 500, 
                                simulatedPower = TRUE, 
                                simOptions = list(nReplications = 500))

## End(Not run)
</code></pre>


</div>