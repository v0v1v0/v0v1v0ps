<div class="container">

<table style="width: 100%;"><tr>
<td>Jinhom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Inhomogeneous J-function
</h2>

<h3>Description</h3>

<p>Estimates the inhomogeneous <code class="reqn">J</code> function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  Jinhom(X, lambda = NULL, lmin = NULL, ...,
        sigma = NULL, varcov = NULL,
        r = NULL, breaks = NULL, ratio=FALSE, 
        update = TRUE, warn.bias=TRUE, savelambda=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>The observed data point pattern,
from which an estimate of the inhomogeneous <code class="reqn">J</code> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code>as.ppp()</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>) or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lmin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the spatial domain. A positive numerical value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma,varcov</code></td>
<td>

<p>Optional arguments passed to  <code>density.ppp</code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Extra arguments passed to <code>as.mask</code> to control
the pixel resolution, or passed to <code>density.ppp</code>
to control the smoothing bandwidth.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>vector of values for the argument <code class="reqn">r</code> at which
the inhomogeneous <code class="reqn">K</code> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>

<p>Logical. If <code>lambda</code> is a fitted model
(class <code>"ppm"</code> or <code>"kppm"</code>)
and <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code>update.ppm</code> or <code>update.kppm</code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without fitting it to <code>X</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.bias</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when the inhomogeneity correction factor takes extreme values,
which can often lead to biased results. This usually occurs
when insufficient smoothing is used to estimate the intensity.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savelambda</code></td>
<td>

<p>Logical value specifying whether to save the values of
<code>lmin</code> and <code>lambda</code> as attributes of the result.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This command computes estimates of the 
inhomogeneous <code class="reqn">J</code>-function (Van Lieshout, 2010)
of a point pattern. It is the counterpart, for inhomogeneous
spatial point patterns, of the <code class="reqn">J</code> function
for homogeneous point patterns computed by <code>Jest</code>.
</p>
<p>The argument <code>X</code> should be a point pattern
(object of class <code>"ppp"</code>).
</p>
<p>The inhomogeneous <code class="reqn">J</code> function is computed as
<code class="reqn">Jinhom(r) = (1 - Ginhom(r))/(1-Finhom(r))</code>
where <code class="reqn">Ginhom, Finhom</code> are the inhomogeneous <code class="reqn">G</code> and <code class="reqn">F</code>
functions computed using the border correction
(equations (7) and (6) respectively in Van Lieshout, 2010).
</p>
<p>The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <code class="reqn">\lambda</code>
of the point process. It may be either
</p>

<dl>
<dt>a numeric vector</dt>
<dd>
<p>containing the values
of the intensity function at the points of the pattern <code>X</code>.
</p>
</dd>
<dt>a pixel image</dt>
<dd>
<p>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window. 
</p>
</dd>
<dt>a fitted point process model</dt>
<dd>
<p>(object of class <code>"ppm"</code> or <code>"kppm"</code>)
whose fitted <em>trend</em> can be used as the fitted intensity.
(If <code>update=TRUE</code> the model will first be refitted to the
data <code>X</code> before the trend is computed.)
</p>
</dd>
<dt>a function</dt>
<dd>
<p>which can be evaluated to give values of the intensity at
any locations.
</p>
</dd>
<dt>omitted:</dt>
<dd>
<p>if <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother.
</p>
</dd>
</dl>
<p>If <code>lambda</code> is a numeric vector, then its length should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<code class="reqn">\lambda(x_i)</code> for
the point <code class="reqn">x_i</code> of the pattern <code class="reqn">X</code>.
Each value must be a positive number; <code>NA</code>'s are not allowed.
</p>
<p>If <code>lambda</code> is a pixel image, the domain of the image should
cover the entire window of the point pattern. If it does not (which
may occur near the boundary because of discretisation error),
then the missing pixel values 
will be obtained by applying a Gaussian blur to <code>lambda</code> using
<code>blur</code>, then looking up the values of this blurred image
for the missing locations. 
(A warning will be issued in this case.)
</p>
<p>If <code>lambda</code> is a function, then it will be evaluated in the
form <code>lambda(x,y)</code> where <code>x</code> and <code>y</code> are vectors
of coordinates of the points of <code>X</code>. It should return a numeric
vector with length equal to the number of points in <code>X</code>.
</p>
<p>If <code>lambda</code> is omitted, then it will be estimated using
a ‘leave-one-out’ kernel smoother.
The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code>density.ppp</code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code>density.ppp</code> along with any extra arguments.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code>, see <code>fv.object</code>,
which can be plotted directly using <code>plot.fv</code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Marie-Colette van Lieshout.
C implementation and R adaptation by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>van Lieshout, M.N.M. and Baddeley, A.J. (1996)
A nonparametric measure of spatial interaction in point patterns.
<em>Statistica Neerlandica</em> <b>50</b>, 344–361.
</p>
<p>van Lieshout, M.N.M. (2010)
A J-function for inhomogeneous point processes.
<em>Statistica Neerlandica</em> <b>65</b>, 183–201.
</p>


<h3>See Also</h3>

<p><code>Ginhom</code>,
<code>Finhom</code>,
<code>Jest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  online &lt;- interactive()
  if(online) {
    plot(Jinhom(swedishpines, sigma=10))
    plot(Jinhom(swedishpines, sigma=bw.diggle, adjust=2))
  } else {
    ## use a coarse grid for faster computation and package testing
    plot(Jinhom(swedishpines, sigma=10, dimyx=32))
  }

</code></pre>


</div>