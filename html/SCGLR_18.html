<div class="container">

<table style="width: 100%;"><tr>
<td>scglr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function that fits the scglr model</h2>

<h3>Description</h3>

<p>Calculates the components to predict all the dependent variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scglr(formula, data, family, K = 1, size = NULL, weights = NULL,
  offset = NULL, subset = NULL, na.action = na.omit, crit = list(),
  method = methodSR())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>MultivariateFormula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame to be modeled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a vector of character of the same length as the number of dependent variables:
"bernoulli", "binomial", "poisson" or "gaussian" is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of components, default is one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>describes the number of trials for the binomial dependent variables.
A (number of statistical units * number of binomial dependent variables) matrix is expected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights on individuals (not available for now)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set to <code>na.omit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>a list of two elements : maxit and tol, describing respectively the maximum number of iterations and
the tolerance convergence criterion for the Fisher scoring algorithm. Default is set to 50 and 10e-6 respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>structural relevance criterion. Object of class "method.SCGLR"
built by  <code>methodSR</code> for Structural Relevance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of the SCGLR class.
</p>
<p>The function <code>summary</code> (i.e., <code>summary.SCGLR</code>) can be used to obtain or print a summary of the results.
</p>
<p>The generic accessor functions <code>coef</code> can be used to extract various useful features of the value returned by <code>scglr</code>.
</p>
<p>An object of class "<code>SCGLR</code>" is a list containing following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>matrix of size (number of regressors * number of components), contains the component-loadings,
i.e. the coefficients of the regressors in the linear combination giving each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp</code></td>
<td>
<p>matrix of size (number of statistical units * number of components) having the components as column vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compr</code></td>
<td>
<p>matrix of size (number of statistical units * number of components) having the standardized components as column vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>list of length number of dependant variables. Each element is a matrix of coefficients, standard errors, z-values and p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>matrix of size (number of regressors + 1 (intercept) * number of dependent variables), contains the coefficients
of the regression on the original regressors X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lin.pred</code></td>
<td>
<p>data.frame of size (number of statistical units * number of dependent variables), the fitted linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xFactors</code></td>
<td>
<p>data.frame containing the nominal regressors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xNumeric</code></td>
<td>
<p>data.frame containing the quantitative regressors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inertia</code></td>
<td>
<p>matrix of size (number of components * 2), contains the percentage and cumulative percentage
of the overall regressors' variance, captured by each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLik</code></td>
<td>
<p>vector of length (number of dependent variables), gives the likelihood of the model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance.null</code></td>
<td>
<p>vector of length (number of dependent variables), gives the deviance  of the null model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance.residual</code></td>
<td>
<p>vector of length (number of dependent variables), gives the deviance  of the model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bry X., Trottier C., Verron T. and Mortier F. (2013) Supervised Component Generalized Linear Regression using a PLS-extension of the Fisher scoring algorithm. <em>Journal of Multivariate Analysis</em>, 119, 47-60.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx
# as surface is offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),A=c("geology"))

# define family
fam &lt;- rep("poisson",length(ny))

genus.scglr &lt;- scglr(formula=form,data = genus,family=fam, K=4,
 offset=genus$surface)

summary(genus.scglr)

## End(Not run)
</code></pre>


</div>