<div class="container">

<table style="width: 100%;"><tr>
<td>graphneigh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graph based spatial weights</h2>

<h3>Description</h3>

<p>Functions return a graph object containing a list with the vertex
coordinates and the to and from indices defining the edges. Some/all of these functions assume that the coordinates are not exactly regularly spaced. The helper
function <code>graph2nb</code> converts a graph
object into a neighbour list. The plot functions plot the graph objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gabrielneigh(coords, nnmult=3)
relativeneigh(coords, nnmult=3)

soi.graph(tri.nb, coords, quadsegs=10)
graph2nb(gob, row.names=NULL,sym=FALSE)
## S3 method for class 'Gabriel'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col), ...)
## S3 method for class 'relative'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>matrix of region point coordinates or SpatialPoints object or <code>sfc</code> points object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnmult</code></td>
<td>
<p>scaling factor for memory allocation, default 3; if higher values are required, the function will exit with an error; example below thanks to Dan Putler</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tri.nb</code></td>
<td>
<p>a neighbor list created from tri2nb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadsegs</code></td>
<td>
<p>number of line segments making a quarter circle buffer, see the <code>nQuadSegs</code> argument in <code>geos_unary</code></p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>gob</code></td>
<td>
<p>a graph object created from any of the graph funtions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>character vector of region ids to be added to the
neighbours list as attribute <code>region.id</code>, default <code>seq(1,
      nrow(x))</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sym</code></td>
<td>
<p>a logical argument indicating whether or not neighbors
should be symetric (if i-&gt;j then j-&gt;i)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object to be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.points</code></td>
<td>
<p>(logical) add points to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>(logical) add to existing plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linecol</code></td>
<td>
<p>edge plotting colour</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further graphical parameters as in <code>par(..)</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The graph functions produce graphs on a 2d point set that



are all subgraphs of the Delaunay triangulation. The
relative neighbor graph is defined by the relation, x and y are neighbors if
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) \le min(max(d(x,z),d(y,z))| z \in S)</code>
</p>

<p>where d() is the distance, S is the set of points and z is an arbitrary
point in S. The Gabriel graph is a subgraph of the delaunay
triangulation and has the relative neighbor graph as a sub-graph. The
relative neighbor graph is defined by the relation x and y are Gabriel
neighbors if
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) \le min((d(x,z)^2 + d(y,z)^2)^{1/2} |z \in S)</code>
</p>

<p>where x,y,z and S are as before. The sphere of influence graph is
defined for a finite point set S, let <code class="reqn">r_x</code> be the distance from point x
to its nearest neighbor in S, and <code class="reqn">C_x</code> is the circle centered on x. Then
x and y are SOI neigbors iff <code class="reqn">C_x</code> and <code class="reqn">C_y</code> intersect in at
least 2 places. From 2016-05-31, Computational Geometry in C code replaced by calls to functions in <span class="pkg">dbscan</span> and <span class="pkg">sf</span>; with a large <code>quadsegs=</code> argument, the behaviour of the function is the same, otherwise buffer intersections only closely approximate the original function.
</p>

<p>See <code>card</code> for details of “nb” objects.
</p>


<h3>Value</h3>

<p>A list of class <code>Graph</code> with the following elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>np</code></td>
<td>
<p>number of input points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>array of origin ids</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>array of destination ids</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nedges</code></td>
<td>
<p>number of edges in graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input x coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>input y coordinates</p>
</td>
</tr>
</table>
<p>The helper functions return an <code>nb</code> object with a list of integer
vectors containing neighbour region number ids.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>References</h3>

<p>Matula, D. W. and Sokal R. R. 1980, Properties of Gabriel
graphs relevant to geographic variation research and the clustering of
points in the plane, Geographic Analysis, 12(3), pp. 205-222.
</p>
<p>Toussaint, G. T. 1980, The relative neighborhood graph of a finite
planar set, Pattern Recognition, 12(4), pp. 261-268.
</p>
<p>Kirkpatrick, D. G. and Radke, J. D. 1985, A framework for
computational morphology. In Computational Geometry,
Ed. G. T. Toussaint, North Holland.
</p>


<h3>See Also</h3>

<p><code>knearneigh</code>, <code>dnearneigh</code>,
<code>knn2nb</code>, <code>card</code></p>


<h3>Examples</h3>

<pre><code class="language-R">columbus &lt;- st_read(system.file("shapes/columbus.gpkg", package="spData")[1], quiet=TRUE)
sf_obj &lt;- st_centroid(st_geometry(columbus), of_largest_polygon)
sp_obj &lt;- as(sf_obj, "Spatial")
coords &lt;- st_coordinates(sf_obj)
suppressMessages(col.tri.nb &lt;- tri2nb(coords))
col.gab.nb &lt;- graph2nb(gabrielneigh(coords), sym=TRUE)
col.rel.nb &lt;- graph2nb(relativeneigh(coords), sym=TRUE)
par(mfrow=c(2,2))
plot(st_geometry(columbus), border="grey")
plot(col.tri.nb,coords,add=TRUE)
title(main="Delaunay Triangulation", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
plot(col.gab.nb, coords, add=TRUE)
title(main="Gabriel Graph", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
plot(col.rel.nb, coords, add=TRUE)
title(main="Relative Neighbor Graph", cex.main=0.6)
plot(st_geometry(columbus), border="grey")
if (require("dbscan", quietly=TRUE)) {
  col.soi.nb &lt;- graph2nb(soi.graph(col.tri.nb,coords), sym=TRUE)
  plot(col.soi.nb, coords, add=TRUE)
  title(main="Sphere of Influence Graph", cex.main=0.6)
}
par(mfrow=c(1,1))
col.tri.nb_sf &lt;- tri2nb(sf_obj)
all.equal(col.tri.nb, col.tri.nb_sf, check.attributes=FALSE)
col.tri.nb_sp &lt;- tri2nb(sp_obj)
all.equal(col.tri.nb, col.tri.nb_sp, check.attributes=FALSE)
if (require("dbscan", quietly=TRUE)) {
  col.soi.nb_sf &lt;- graph2nb(soi.graph(col.tri.nb, sf_obj), sym=TRUE)
  all.equal(col.soi.nb, col.soi.nb_sf, check.attributes=FALSE)
  col.soi.nb_sp &lt;- graph2nb(soi.graph(col.tri.nb, sp_obj), sym=TRUE)
  all.equal(col.soi.nb, col.soi.nb_sp, check.attributes=FALSE)
}
col.gab.nb_sp &lt;- graph2nb(gabrielneigh(sp_obj), sym=TRUE)
all.equal(col.gab.nb, col.gab.nb_sp, check.attributes=FALSE)
col.gab.nb_sf &lt;- graph2nb(gabrielneigh(sf_obj), sym=TRUE)
all.equal(col.gab.nb, col.gab.nb_sf, check.attributes=FALSE)
col.rel.nb_sp &lt;- graph2nb(relativeneigh(sp_obj), sym=TRUE)
all.equal(col.rel.nb, col.rel.nb_sp, check.attributes=FALSE)
col.rel.nb_sf &lt;- graph2nb(relativeneigh(sf_obj), sym=TRUE)
all.equal(col.rel.nb, col.rel.nb_sf, check.attributes=FALSE)
dx &lt;- rep(0.25*0:4,5)
dy &lt;- c(rep(0,5),rep(0.25,5),rep(0.5,5), rep(0.75,5),rep(1,5))
m &lt;- cbind(c(dx, dx, 3+dx, 3+dx), c(dy, 3+dy, dy, 3+dy))
cat(try(res &lt;- gabrielneigh(m), silent=TRUE), "\n")
res &lt;- gabrielneigh(m, nnmult=4)
summary(graph2nb(res))
grd &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) #gridded data
r2 &lt;- gabrielneigh(grd)
set.seed(1)
grd1 &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) + matrix(runif(50, .0001, .0006), nrow=25)
r3 &lt;- gabrielneigh(grd1)
opar &lt;- par(mfrow=c(1,2))
plot(r2, show=TRUE, linecol=2)
plot(r3, show=TRUE, linecol=2)
par(opar)
# example of reading points with readr::read_csv() yielding a tibble
load(system.file("etc/misc/coords.rda", package="spdep"))
class(coords)
graph2nb(gabrielneigh(coords))
graph2nb(relativeneigh(coords))
</code></pre>


</div>