<div class="container">

<table style="width: 100%;"><tr>
<td>nncross.lpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nearest Neighbours on a Linear Network</h2>

<h3>Description</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> on a linear network,
finds the nearest neighbour in <code>Y</code> of each point of <code>X</code>
using the shortest path in the network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'lpp'
nncross(X, Y,
          iX=NULL, iY=NULL,
          what = c("dist", "which"),
          ...,
          k = 1,
          method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X,Y</code></td>
<td>

<p>Point patterns on a linear network (objects of class <code>"lpp"</code>).
They must lie on the <em>same</em> linear network.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iX, iY</code></td>
<td>

<p>Optional identifiers, used to determine whether a point in
<code>X</code> is identical to a point in <code>Y</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the identifier of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour, for each value of <code>k</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Internal use only.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> on the same linear
network, this function finds, for each point of <code>X</code>, 
the nearest point of <code>Y</code>, measuring distance by the shortest path
in the network. The distance between these points
is also computed.
</p>
<p>The return value is a data frame, with rows corresponding to
the points of <code>X</code>.  The first column gives the nearest neighbour
distances (i.e. the <code>i</code>th entry is the distance 
from the <code>i</code>th point of <code>X</code> to the nearest element of
<code>Y</code>). The second column gives the indices of the nearest
neighbours (i.e.\ the <code>i</code>th entry is the index of
the nearest element in <code>Y</code>.)
If <code>what="dist"</code> then only the vector of distances is returned.
If <code>what="which"</code> then only the vector of indices is returned.
</p>
<p>Note that this function is not symmetric in <code>X</code> and <code>Y</code>.
To find the nearest neighbour in <code>X</code> of each point in <code>Y</code>,
use <code>nncross(Y,X)</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> have some points in
common.  In this situation <code>nncross(X, Y)</code> would return some zero
distances. To avoid this, attach a unique integer identifier to
each point, such that two points are identical if their
identifying numbers are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. See the Examples.
</p>
<p>The <code>k</code>th nearest neighbour may be undefined, for example
if there are fewer than <code>k+1</code> points in the dataset, or if
the linear network is not connected.
In this case, the <code>k</code>th nearest neighbour distance is infinite.
</p>


<h3>Value</h3>

<p>By default (if <code>what=c("dist", "which")</code> and <code>k=1</code>)
a data frame with two columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Nearest neighbour distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Nearest neighbour index in <code>Y</code></p>
</td>
</tr>
</table>
<p>If <code>what="dist"</code>, a vector of nearest neighbour distances.
</p>
<p>If <code>what="which"</code>, a vector of nearest neighbour indices.
</p>
<p>If <code>k</code> is a vector of integers, the result is a matrix
with one row for each point in <code>X</code>,
giving the distances and/or indices of the <code>k</code>th nearest
neighbours in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>nndist.lpp</code> for nearest neighbour
distances in a single point pattern.
</p>
<p><code>nnwhich.lpp</code> to identify which points are nearest
neighbours in a single point pattern.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # two different point patterns
  X &lt;- runiflpp(3, simplenet)
  Y &lt;- runiflpp(5, simplenet)
  nn &lt;- nncross(X,Y)
  nn
  plot(simplenet, main="nncross")
  plot(X, add=TRUE, cols="red")
  plot(Y, add=TRUE, cols="blue", pch=16)
  XX &lt;- as.ppp(X)
  YY &lt;- as.ppp(Y)
  i &lt;- nn$which
  arrows(XX$x, XX$y, YY[i]$x, YY[i]$y, length=0.15)

  # nearest and second-nearest neighbours
  nncross(X, Y, k=1:2)

  # two patterns with some points in common
  X &lt;- Y[1:2]
  iX &lt;- 1:2
  iY &lt;- 1:5
  nncross(X,Y, iX, iY)
</code></pre>


</div>