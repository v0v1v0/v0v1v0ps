<div class="container">

<table style="width: 100%;"><tr>
<td>MappingScore</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metric for evaluating mapping success</h2>

<h3>Description</h3>

<p>This metric was designed to help identify query cells that aren't well
represented in the reference dataset. The intuition for the score is that we
are going to project the query cells into a reference-defined space and then
project them back onto the query. By comparing the neighborhoods before and
after projection, we identify cells who's local neighborhoods are the most
affected by this transformation. This could be because there is a population
of query cells that aren't present in the reference or the state of the cells
in the query is significantly different from the equivalent cell type in the
reference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MappingScore(anchors, ...)

## Default S3 method:
MappingScore(
  anchors,
  combined.object,
  query.neighbors,
  ref.embeddings,
  query.embeddings,
  kanchors = 50,
  ndim = 50,
  ksmooth = 100,
  ksnn = 20,
  snn.prune = 0,
  subtract.first.nn = TRUE,
  nn.method = "annoy",
  n.trees = 50,
  query.weights = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'AnchorSet'
MappingScore(
  anchors,
  kanchors = 50,
  ndim = 50,
  ksmooth = 100,
  ksnn = 20,
  snn.prune = 0,
  subtract.first.nn = TRUE,
  nn.method = "annoy",
  n.trees = 50,
  query.weights = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>anchors</code></td>
<td>
<p>AnchorSet object or just anchor matrix from the
Anchorset object returned from FindTransferAnchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Reserved for internal use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combined.object</code></td>
<td>
<p>Combined object (ref + query) from the
Anchorset object returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.neighbors</code></td>
<td>
<p>Neighbors object computed on query cells</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref.embeddings</code></td>
<td>
<p>Reference embeddings matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.embeddings</code></td>
<td>
<p>Query embeddings matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kanchors</code></td>
<td>
<p>Number of anchors to use in projection steps when computing
weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>Number of dimensions to use when working with low dimensional
projections of the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ksmooth</code></td>
<td>
<p>Number of cells to average over when computing transition
probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ksnn</code></td>
<td>
<p>Number of cells to average over when determining the kernel
bandwidth from the SNN graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snn.prune</code></td>
<td>
<p>Amount of pruning to apply to edges in SNN graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subtract.first.nn</code></td>
<td>
<p>Option to the scoring function when computing
distances to subtract the distance to the first nearest neighbor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.method</code></td>
<td>
<p>Nearest neighbor method to use (annoy or RANN)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query.weights</code></td>
<td>
<p>Query weights matrix for reuse</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Display messages/progress</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a vector of cell scores
</p>


</div>