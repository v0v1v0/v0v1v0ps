<div class="container">

<table style="width: 100%;"><tr>
<td>modindices.mi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modification Indices for Multiple Imputations</h2>

<h3>Description</h3>

<p>Modification indices (1-<em>df</em> Lagrange multiplier tests) from a
latent variable model fitted to multiple imputed data sets. Statistics
for releasing one or more fixed or constrained parameters in model can
be calculated by pooling the gradient and information matrices
across imputed data sets in a method proposed by Mansolf, Jorgensen, &amp;
Enders (2020)—analogous to the "D1" Wald test proposed by Li, Meng,
Raghunathan, &amp; Rubin (1991)—or by pooling the complete-data score-test
statistics across imputed data sets (i.e., "D2"; Li et al., 1991).
</p>


<h3>Usage</h3>

<pre><code class="language-R">modindices.mi(object, test = c("D2", "D1"), omit.imps = c("no.conv",
  "no.se"), standardized = TRUE, cov.std = TRUE,
  information = "expected", power = FALSE, delta = 0.1, alpha = 0.05,
  high.power = 0.75, sort. = FALSE, minimum.value = 0,
  maximum.number = nrow(LIST), na.remove = TRUE, op = NULL)

modificationIndices.mi(object, test = c("D2", "D1"),
  omit.imps = c("no.conv", "no.se"), standardized = TRUE, cov.std = TRUE,
  information = "expected", power = FALSE, delta = 0.1, alpha = 0.05,
  high.power = 0.75, sort. = FALSE, minimum.value = 0,
  maximum.number = nrow(LIST), na.remove = TRUE, op = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>lavaan.mi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p><code>character</code> indicating which pooling method to use.
<code>"D1"</code> requests Mansolf, Jorgensen, &amp; Enders' (2020) proposed
Wald-like test for pooling the gradient and information, which are then
used to calculate score-test statistics in the usual manner. <code>"D2"</code>
(default because it is less computationall intensive) requests to pool the
complete-data score-test statistics from each imputed data set, then pool
them across imputations, described by Li et al. (1991) and Enders (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit.imps</code></td>
<td>
<p><code>character</code> vector specifying criteria for omitting
imputations from pooled results.  Can include any of
<code>c("no.conv", "no.se", "no.npd")</code>, the first 2 of which are the
default setting, which excludes any imputations that did not
converge or for which standard errors could not be computed.  The
last option (<code>"no.npd"</code>) would exclude any imputations which
yielded a nonpositive definite covariance matrix for observed or
latent variables, which would include any "improper solutions" such
as Heywood cases. Specific imputation numbers can also be included in this
argument, in case users want to  apply their own custom omission criteria
(or simulations can use different numbers of imputations without
redundantly refitting the model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, two extra columns
(<code>$sepc.lv</code> and <code>$sepc.all</code>) will contain standardized values
for the EPCs. In the first column (<code>$sepc.lv</code>), standardizization is
based on the variances of the (continuous) latent variables. In the second
column (<code>$sepc.all</code>), standardization is based on both the variances
of both (continuous) observed and latent variables. (Residual) covariances
are standardized using (residual) variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.std</code></td>
<td>
<p><code>logical</code>. <code>TRUE</code> if <code>test == "D2"</code>.
If <code>TRUE</code> (default), the (residual)
observed covariances are scaled by the square-root of the diagonal elements
of the <code class="reqn">\Theta</code> matrix, and the (residual) latent covariances are
scaled by the square-root of the diagonal elements of the <code class="reqn">\Psi</code>
matrix. If <code>FALSE</code>, the (residual) observed covariances are scaled by
the square-root of the diagonal elements of the model-implied covariance
matrix of observed variables (<code class="reqn">\Sigma</code>), and the (residual) latent
covariances are scaled by the square-root of the diagonal elements of the
model-implied covariance matrix of the latent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>information</code></td>
<td>
<p><code>character</code> indicating the type of information
matrix to use (check <code>lavInspect</code> for available options).
<code>"expected"</code> information is the default, which provides better
control of Type I errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the (post-hoc) power is
computed for each modification index, using the values of <code>delta</code>
and <code>alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The value of the effect size, as used in the post-hoc power
computation, currently using the unstandardized metric of the <code>$epc</code>
column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The significance level used for deciding if the modification
index is statistically significant or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>high.power</code></td>
<td>
<p>If the computed power is higher than this cutoff value,
the power is considered 'high'. If not, the power is considered 'low'.
This affects the values in the <code>$decision</code> column in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, sort the output using the
values of the modification index values. Higher values appear first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimum.value</code></td>
<td>
<p><code>numeric</code>. Filter output and only show rows with a
modification index value equal or higher than this minimum value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum.number</code></td>
<td>
<p><code>integer</code>. Filter output and only show the first
maximum number rows. Most useful when combined with the <code>sort.</code> option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.remove</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (default), filter output by
removing all rows with <code>NA</code> values for the modification indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>op</code></td>
<td>
<p><code>character</code> string. Filter the output by selecting only those
rows with operator <code>op</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.frame</code> containing modification indices and (S)EPCs.
</p>


<h3>Note</h3>

<p>When <code>test = "D2"</code>, each (S)EPC will be pooled by taking its
average across imputations. When <code>test = "D1"</code>, EPCs will be
calculated in the standard way using the pooled gradient and information,
and SEPCs will be calculated by standardizing the EPCs using model-implied
(residual) variances.
</p>


<h3>Author(s)</h3>

<p>Terrence D. Jorgensen (University of Amsterdam; <a href="mailto:TJorgensen314@gmail.com">TJorgensen314@gmail.com</a>)
</p>
<p>Adapted from <span class="pkg">lavaan</span> source code, written by
Yves Rosseel (Ghent University; <a href="mailto:Yves.Rosseel@UGent.be">Yves.Rosseel@UGent.be</a>)
</p>
<p><code>test = "D1"</code> method proposed by
Maxwell Mansolf (University of California, Los Angeles;
<a href="mailto:mamansolf@gmail.com">mamansolf@gmail.com</a>)
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>.
New York, NY: Guilford.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991).
Significance levels from repeated <em>p</em>-values with multiply-imputed
data.<em>Statistica Sinica, 1</em>(1), 65–92. Retrieved from
<a href="https://www.jstor.org/stable/24303994">https://www.jstor.org/stable/24303994</a>
</p>
<p>Mansolf, M., Jorgensen, T. D., &amp; Enders, C. K. (2020). A multiple
imputation score test for model modification in structural equation
models. <em>Psychological Methods, 25</em>(4), 393–411.
<a href="https://doi.org/10.1037/met0000243">doi:10.1037/met0000243</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> ## Not run: 
## impose missing data for example
HSMiss &lt;- HolzingerSwineford1939[ , c(paste("x", 1:9, sep = ""),
                                      "ageyr","agemo","school")]
set.seed(12345)
HSMiss$x5 &lt;- ifelse(HSMiss$x5 &lt;= quantile(HSMiss$x5, .3), NA, HSMiss$x5)
age &lt;- HSMiss$ageyr + HSMiss$agemo/12
HSMiss$x9 &lt;- ifelse(age &lt;= quantile(age, .3), NA, HSMiss$x9)

## impute missing data
library(Amelia)
set.seed(12345)
HS.amelia &lt;- amelia(HSMiss, m = 20, noms = "school", p2s = FALSE)
imps &lt;- HS.amelia$imputations

## specify CFA model from lavaan's ?cfa help page
HS.model &lt;- '
  visual  =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
'

out &lt;- cfa.mi(HS.model, data = imps)

modindices.mi(out) # default: Li et al.'s (1991) "D2" method
modindices.mi(out, test = "D1") # Li et al.'s (1991) "D1" method


## End(Not run)

</code></pre>


</div>