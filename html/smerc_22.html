<div class="container">

<table style="width: 100%;"><tr>
<td>tango.weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance-based weights for <code>tango.test</code>
</h2>

<h3>Description</h3>

<p><code>tango.weights</code> constructs a distance-based weights
matrix. The <code>tango.weights</code> function can be used to
construct a weights matrix <code>w</code> using the method of
Tango (1995), Rogerson (1999), or a basic style.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tango.weights(coords, kappa = 1, longlat = FALSE, type = "basic", pop = NULL)

dweights(coords, kappa = 1, longlat = FALSE, type = "basic", pop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>A positive constant related to strength of
spatial autocorrelation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of weights matrix to construct.
Current options are <code>"basic"</code>, <code>"tango"</code>, and
<code>"rogerson"</code>.  Default is <code>"basic"</code>.  See
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>coords</code> is used to construct an <code class="reqn">n \times n</code>
distance matrix <code>d</code>.
</p>
<p>If <code>type = "basic"</code>, then <code class="reqn">w_{ij} =
exp(-d_{ij}/\kappa)</code>.
</p>
<p>If <code>type = "rogerson"</code>, then <code class="reqn">w_{ij} =
exp(-d_{ij}/\kappa)/\sqrt(pop_i/pop * pop_j/pop)</code>.
</p>
<p>If <code>type = "tango"</code>, then <code class="reqn">w_{ij} = exp(-4 *
d_{ij}^2/\kappa^2)</code>.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">n \times n</code> matrix of weights.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T.  (1995) A class of tests for
detecting "general" and "focused" clustering of rare
diseases.  Statistics in Medicine.  14:2323-2334.
</p>
<p>Rogerson, P. (1999) The Detection of Clusters Using A
Spatial Version of the Chi-Square Goodness-of-fit Test.
Geographical Analysis. 31:130-147
</p>


<h3>See Also</h3>

<p><code>tango.test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
w &lt;- tango.weights(coords, kappa = 1, longlat = TRUE)
</code></pre>


</div>