<div class="container">

<table style="width: 100%;"><tr>
<td>sim.popn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Simulate 2-D Population </h2>

<h3>Description</h3>

<p>Simulate a point process representing the locations of individual animals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
sim.popn (D, core, buffer = 100, model2D = c("poisson", "cluster",
  "IHP", "coastal", "hills", "linear", "even", "rLGCP", "rThomas"), 
  buffertype = c("rect", "concave", "convex"), poly = NULL, 
  covariates = list(sex = c(M = 0.5, F = 0.5)), number.from = 1, 
  Ndist = c("poisson", "fixed", "specified"), nsessions = 1, details = NULL, 
  seed = NULL, keep.mask = model2D %in% c("IHP", "linear"), 
  Nbuffer = NULL, age = FALSE, ...)

tile(popn, method = "reflect")

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p> density animals / hectare (10 000 m^2) (see Details for
IHP case) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>core</code></td>
<td>
<p> data frame of points defining the core area </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p> buffer radius about core area </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model2D</code></td>
<td>
<p> character string for 2-D distribution </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffertype</code></td>
<td>
<p> character string for buffer type </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p> bounding polygon (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p> list of named covariates or function to generate covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number.from</code></td>
<td>
<p> integer ID for animal </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ndist</code></td>
<td>
<p> character string for distribution of number of individuals </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsessions</code></td>
<td>
<p> number of sessions to simulate </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p> optional list with additional parameters </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.mask</code></td>
<td>
<p>logical; if TRUE and model2D %in% c('IHP','linear')
then <code>core</code> is saved as the attribute "mask"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nbuffer</code></td>
<td>
<p>integer number of individuals to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>age</code></td>
<td>
<p>logical; if TRUE then age covariate added for multisession popn with turnover</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments passed to subset if poly is not NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popn</code></td>
<td>
<p> popn object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> character string "reflect" or "copy"</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>core</code> must contain columns ‘x’ and ‘y’; a <code>traps</code> object is
suitable. For <code>buffertype = "rect"</code>, animals are simulated in the
rectangular area obtained by extending the bounding box of <code>core</code>
by <code>buffer</code> metres to top and bottom, left and right. This box has
area <code class="reqn">A</code>. If <code>model2D = 'poisson'</code> the buffer type may also be ‘convex’ (points within a buffered convex polygon) or ‘concave’ (corresponding to a mask of type ‘trapbuffer’); these buffer types use <code>bufferContour</code>.
</p>
<p>Covariates may be specified in either of two ways. In the first, each element of <code>covariates</code> defines a categorical (factor) covariate with the given probabilities of membership in each class. In the second, the 'covariates' argument is a function (or a character value naming a function) that takes a dataframe of x and y coordinates as its sole argument; the function should return a dataframe with the same number of rows that will be used as the covariates attribute (<span class="pkg">secr</span> &gt;= 4.6.7).
</p>
<p>A notional random covariate ‘sex’ is generated by default.
</p>
<p>Ndist should usually be ‘poisson’ or ‘fixed’. The number of individuals <code class="reqn">N</code> has
expected value <code class="reqn">DA</code>. If <code class="reqn">DA</code> is non-integer then Ndist = "fixed"
results in <code class="reqn">N \in \{ \mathrm{trunc}(DA), \mathrm{trunc}(DA)+1 \} </code>, with probabilities set to yield
<code class="reqn">DA</code> individuals on average. The option ‘specified’ is undocumented;
it is used in some open-population simulations.
</p>
<p>If <code>model2D = "cluster"</code> then the simulated population approximates a Neyman-Scott
clustered Poisson distribution. Ancillary parameters are passed as
components of <code>details</code>: details$mu is the expected number of
individuals per cluster and details$hsigma is the spatial scale
(<code class="reqn">\sigma</code>) of a 2-D kernel for location within each cluster.
The algorithm is
</p>

<ol>
<li>
<p> Determine the number of clusters (parents) as a random Poisson variate
with <code class="reqn">\lambda = DA/\mu</code>
</p>
</li>
<li>
<p> Locate each parent by drawing uniform random x- and y-coordinates
</p>
</li>
<li>
<p> Determine number of offspring for each parent by drawing from a Poisson distribution with mean mu
</p>
</li>
<li>
<p> Locate offspring by adding random normal error to each parent coordinate
</p>
</li>
<li>
<p> Apply toroidal wrapping to ensure all offspring locations are
inside the buffered area
</p>
</li>
</ol>
<p>A special cluster option is selected if details$clone = "constant": then each parent is cloned exactly details$mu times.
</p>
<p>Toroidal wrapping is a compromise. The result is more faithful to the
Neyman-Scott distribution if the buffer is large enough that only a
small proportion of the points are wrapped.
</p>
<p>If <code>model2D = "IHP"</code> then an inhomogeneous Poisson distribution is
simulated.  <code>core</code> should be a habitat mask and <code>D</code>
should be one of –
</p>

<ul>
<li>
<p> a vector of length equal to the number of cells (rows)
in <code>core</code>, 
</p>
</li>
<li>
<p> the name of a covariate in <code>core</code> that contains
cell-specific densities (animals / hectare),
</p>
</li>
<li>
<p> a function to generate the intensity of the distribution at each mask point, or
</p>
</li>
<li>
<p> a constant. 
</p>
</li>
</ul>
<p>If a function, <code>D</code> should take two arguments, a habitat mask and a list of parameter values ('core' and 'details' are passed internally as these arguments).
</p>
<p>The number
of individuals in each cell is either (i) Poisson-distributed with mean
<code class="reqn">DA</code> where <code class="reqn">A</code> is the cell area (an attribute of the mask)
(<code>Ndist = "poisson"</code>) or (ii) multinomial with size <code class="reqn">DA</code> and
relative cell probabilities given by D (<code>Ndist =
"fixed"</code>). <code>buffertype</code> and <code>buffer</code> are ignored, as the
extent of the population is governed entirely by the mask in
<code>core</code>.
</p>
<p>If <code>model2D = "linear"</code> then a linear population is simulated as
for <code>model2D = "IHP"</code>, except that <code>core</code> should be a
linearmask object from package <span class="pkg">secrlinear</span>, and density (D) is
expressed in animals per km. The documentation of <span class="pkg">secrlinear</span>
should be consulted for further detail (e.g. the wrapper function
<code>sim.linearpopn</code>).
</p>
<p>If <code>model2D = "coastal"</code> then a form of inhomogeneous Poisson
distribution is simulated in which the x- and y-coordinates are drawn from
independent Beta distributions. Default parameters generate the
‘coastal’ distribution used by Fewster and Buckland (2004) for
simulations of line-transect distance sampling (x ~ Beta(1, 1.5), y ~
Beta(5, 1), which places 50% of the population in the ‘northern’ 13%
of the rectangle). The four Beta parameters may be supplied in the
vector component Beta of the ‘details’ list (see Examples). The Beta
parameters (1,1) give a uniform distribution. Coordinates are scaled to
fit the limits of a sampled rectangle, so this method assumes buffertype
= "rect".
</p>
<p>If <code>model2D = "hills"</code> then a form of inhomogeneous Poisson
distribution is simulated in which intensity is a sine curve in the x-
and y- directions (density varies symmetrically between 0 and 2 x D
along each axis). The number of hills in each direction (default 1) is
determined by the ‘hills’ component of the ‘details’ list (e.g. details
= list(hills=c(2,3)) for 6 hills). If either number is negative then
alternate rows will be offset by half a hill. Displacements of the
entire pattern to the right and top are indicated by further elements of
the ‘hills’ component (e.g. details = list(hills=c(1,1,0.5,0.5)) for 1
hill shifted half a unit to the top right; coordinates are wrapped, so
the effect is to split the hill into the four corners). Negative
displacements are replaced by runif(1). Density is zero at the edge when
the displacement vector is (0,0) and rows are not offset.
</p>
<p>If <code>model2D = "even"</code> then the buffered area is divided into square cells with side sqrt(10000/D) and one animal is located at a random uniform location within each cell. If the height or width is not an exact multiple of the cell side then one whole extra row or column of cells is added; animals located at random in these cells are discarded if they fall outside the original area.
</p>
<p>From <span class="pkg">secr</span> 4.6.2, <code>sim.popn</code> provides an interface to two simulation functions from <span class="pkg">spatstat</span> (Baddeley et al. 2015): <code>rLGCP</code> and <code>rThomas</code>.
</p>
<p>If <code>model2D = "rLGCP"</code> then a log-gaussian Cox process is simulated within the buffered area. Function <code>rLGCP</code> in <span class="pkg">spatstat</span> calls functions from <span class="pkg">RandomFields</span> (Schlather et al. 2015; see Notes). Certain options are fixed: the correlation function is RMexp from RandomFields, and there is no provision for covariate effects. Clipping to a polygon (poly) and fixed-N (Ndist = "fixed") are not supported. The algorithm first constructs the log spatial intensity as a realisation of a Gaussian random field; one realisation of an IHP with that intensity is then simulated. 
</p>
<p>The parameters for <code>model2D = "rLGCP"</code> are the scalar density (D) and the variance and spatial scale of the random field (passed as details arguments ‘var’ and ‘scale’). The variance is on the log scale; the mean on the log scale is computed internally as mu = log(D) - var/2. var = 0 results in a random uniform (Poisson) distribution. When details$saveLambda = TRUE, the discretized intensity function is saved as the attribute "Lambda", a habitat mask with covariate "Lambda" that may be used to construct further IHP realisations (see Examples). 
</p>
<p>If <code>model2D = "rThomas"</code> then a Thomas process is simulated. This is a special case of the Neyman-Scott process in which each parent gives rise to a Poisson number of offspring (see Notes). The expected number of offspring per parent and the spatial scatter about each parent are specified by the details arguments ‘mu’ and ‘scale’. Argument ‘kappa’ of <code>rThomas</code> (density of parent process) is computed as D/mu/1e4. Other arguments remain at their defaults, including ‘expand’ (4 * scale). A dataframe of parent locations is saved in attribute ‘parents’. The intensity surface for each realisation is saved in attribute 'Lambda' when details$saveLambda = TRUE.
</p>
<p>If <code>poly</code> is specified, points outside <code>poly</code> are
dropped. <code>poly</code> may be one of the types descrbed in 
<code>boundarytoSF</code>.
</p>
<p>The <code>subset</code> method is called internally when <code>poly</code> is used;
the ... argument may be used to pass values for <code>keep.poly</code> and
<code>poly.habitat</code>.
</p>
<p>Multi-session populations may be generated with <code>nsessions &gt; 1</code>. 
Multi-session populations may be independent or generated by per capita 
turnover from a starting population. In the ‘independent’ case
(<code>details$lambda</code> not specified) D or Nbuffer may be a vector of length equal to
<code>nsessions</code>. Turnover is controlled by survival, growth rate and movement
parameters provided as components of <code>details</code> and described in turnover. 
The optional covariate 'age' is the number of sessions from the session of recruitment.
</p>
<p>The random number seed is managed as in <code>simulate.lm</code>.
</p>
<p>Function <code>tile</code> replicates a popn pattern by either reflecting or
copying and translating it to fill a 3 x 3 grid.
</p>


<h3>Value</h3>

<p>An object of class <code>c("popn", "data.frame")</code> a data frame with columns ‘x’ and ‘y’. Rows correspond to individuals. Individual covariates (optional) are stored
as a data frame attribute. The initial state of the R random number generator is
stored in the ‘seed’ attribute.
</p>
<p>If <code>model2D = "linear"</code> the output is of class <code>c("linearpopn",
  "popn", "data.frame")</code>.
</p>
<p>If <code>model2D = "IHP"</code> or <code>model2D = "linear"</code> the value of
<code>core</code> is stored in the ‘mask’ attribute.
</p>


<h3>Notes</h3>

<p>Package RandomFields is not currently on CRAN. It may be installed with this code:
</p>
<p><code>install.packages("RandomFields", repos = c("https://spatstat.r-universe.dev", 
   "https://cloud.r-project.org"))</code>
</p>
<p><code>model2D = "rThomas"</code> and <code>model2D = "cluster"</code> (the builtin Neyman-Scott implementation) are equivalent. There may be some subtle differences. The <span class="pkg">spatstat</span> implementation is usually to be preferred.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., and Turner, R. 2015. Spatial Point Patterns: Methodology and Applications with R. Chapman and Hall/CRC Press, London. ISBN 9781482210200, https://www.routledge.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/p/book/9781482210200/. 
</p>
<p>Fewster, R. M. and Buckland, S. T. 2004. Assessment of distance
sampling estimators. In: S. T. Buckland, D. R. Anderson,
K. P. Burnham, J. L. Laake, D. L. Borchers and L. Thomas (eds)
<em>Advanced distance sampling</em>. Oxford University Press, Oxford,
U. K. Pp. 281–306.
</p>
<p>Schlather, M., Malinowski, A., Menck, P. J., Oesting, M. and Strokorb, K. 2015. Analysis, simulation and prediction of multivariate random fields with package RandomFields. <em>Journal of Statistical Software</em>, <b>63</b>, 1–25. URL
https://www.jstatsoft.org/v63/i08/.
</p>


<h3>See Also</h3>

 <p><code>popn</code>, <code>plot.popn</code>,
<code>randomHabitat</code>, turnover, 
<code>simulate</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
temppop &lt;- sim.popn (D = 10, expand.grid(x = c(0,100), y =
    c(0,100)), buffer = 50)

## plot, distinguishing "M" and "F"
plot(temppop, pch = 1, cex= 1.5,
    col = c("green","red")[covariates(temppop)$sex])

## add a continuous covariate
## assumes covariates(temppop) is non-null
covariates(temppop)$size &lt;- rnorm (nrow(temppop), mean = 15, sd = 3)
summary(covariates(temppop))

## Neyman-Scott cluster distribution (see also rThomas)
par(xpd = TRUE, mfrow=c(2,3))
for (h in c(5,15))
for (m in c(1,4,16)) {
    temppop &lt;- sim.popn (D = 10, expand.grid(x = c(0,100),
        y = c(0,100)), model2D = "cluster", buffer = 100,
        details = list(mu = m, hsigma = h))
    plot(temppop)
    text (50,230,paste(" mu =",m, "hsigma =",h))
}
par(xpd = FALSE, mfrow=c(1,1))   ## defaults

## Inhomogeneous Poisson distribution
xy &lt;- secrdemo.0$mask$x + secrdemo.0$mask$y - 900
tempD &lt;- xy^2 / 1000
plot(sim.popn(tempD, secrdemo.0$mask, model2D = "IHP"))

## Coastal distribution in 1000-m square, homogeneous in
## x-direction
arena &lt;- data.frame(x = c(0, 1000, 1000, 0),
    y = c(0, 0, 1000, 1000))
plot(sim.popn(D = 5, core = arena, buffer = 0, model2D =
    "coastal", details = list(Beta = c(1, 1, 5, 1))))

## Hills
plot(sim.popn(D = 100, core = arena, model2D = "hills",
    buffer = 0, details = list(hills = c(-2,3,0,0))), 
    cex = 0.4)

## tile demonstration
pop &lt;- sim.popn(D = 100, core = make.grid(), model2D = "coastal")
par(mfrow = c(1,2), mar = c(2,2,2,2))
plot(tile(pop, "copy"))
polygon(cbind(-100,200,200,-100), c(-100,-100,200,200),
    col = "red", density = 0)
title("copy")
plot(tile(pop, "reflect"))
polygon(cbind(-100,200,200,-100), c(-100,-100,200,200),
    col = "red", density = 0)
title("reflect")

## Not run: 

## simulate from inhomogeneous fitted density model

regionmask &lt;- make.mask(traps(possumCH), type = "polygon",
    spacing = 20, poly = possumremovalarea)
dts &lt;- distancetotrap(regionmask, possumarea)
covariates(regionmask) &lt;- data.frame(d.to.shore = dts)
dsurf &lt;- predictDsurface(possum.model.Ds, regionmask)
possD &lt;- covariates(dsurf)$D.0
posspop &lt;- sim.popn(D = possD, core = dsurf, model = "IHP")
plot(regionmask, dots = FALSE, ppoly = FALSE)
plot(posspop, add = TRUE, frame = FALSE)
plot(traps(possumCH), add = TRUE)

## randomHabitat demonstration
## - assumes igraph has been installed

# The wrapper function randomDensity may be passed to generate
# a new habitat map each time sim.popn is called. The `details' argument
# of sim.popn is passed to randomDensity as the `parm' argument.

tempmask &lt;- make.mask(nx = 100, ny = 100, spacing = 20)
pop &lt;- sim.popn(D = randomDensity, core = tempmask, model2D = "IHP",
    details = list(D = 10, p = 0.4, A = 0.5))
plot(attr(pop, 'mask'), cov = 'D', dots = FALSE)
plot(pop, add = TRUE)

## rLGCP demonstration
## - assumes spatstat and RandomFields have been installed

if (requireNamespace("spatstat") &amp;&amp; requireNamespace("RandomFields")) {
    msk &lt;- make.mask(traps(captdata))
    # details argument 'spacing' ensures core matches Lambda below
    pop &lt;- sim.popn(D = 20, core = msk, buffer = 0, 
        model2D = "rLGCP", details = list(var=1, scale = 30, saveLambda = TRUE), 
        seed = 1234)
    plot(pop)
    plot(traps(captdata), add = TRUE)

    # another IHP realisation from same LGCP intensity surface
    lgcp &lt;- attr(pop, 'Lambda')
    pop2 &lt;- sim.popn(D = 'Lambda', core = lgcp, model2D = "IHP")
    plot (lgcp, covariate = "Lambda", dots = FALSE)
    plot (pop2, add = TRUE, frame = FALSE)
    
    # check input and output masks match
    summary(lgcp)
    summary(msk)
}


## End(Not run)

</code></pre>


</div>