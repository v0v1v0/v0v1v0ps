<div class="container">

<table style="width: 100%;"><tr>
<td>sox</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Time-dependent) Cox model with structured variable selection</h2>

<h3>Description</h3>

<p>Fit a (time-dependent) Cox model with overlapping (including nested) group lasso penalty. The regularization path is computed at a grid of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sox(
  x,
  ID,
  time,
  time2,
  event,
  penalty,
  lambda,
  group,
  group_variable,
  own_variable,
  no_own_variable,
  penalty_weights,
  par_init,
  stepsize_init = 1,
  stepsize_shrink = 0.8,
  tol = 1e-05,
  maxit = 1000L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Predictor matrix with dimension <code class="reqn">nm * p</code>, where <code class="reqn">n</code> is the number of subjects, <code class="reqn">m</code> is the maximum observation time, and <code class="reqn">p</code> is the number of predictors. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID</code></td>
<td>
<p>The ID of each subjects, each subject has one ID (multiple rows in <code>x</code> can share one <code>ID</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>Represents the start of each time interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time2</code></td>
<td>
<p>Represents the stop of each time interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event</code></td>
<td>
<p>Indicator of event. <code>event = 1</code> when event occurs and <code>event = 0</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Character string, indicating whether "<code>overlapping</code>" or "<code>nested</code>" group lasso penalty is imposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Sequence of regularization coefficients <code class="reqn">\lambda</code>'s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A <code class="reqn">G * G</code> integer matrix required to describe the structure of the <code>overlapping</code> and <code>nested</code> groups. We recommend that the users generate it automatically using <code>overlap_structure()</code> and <code>nested_structure()</code>. See Examples and Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_variable</code></td>
<td>
<p>A <code class="reqn">p * G</code> integer matrix required to describe the structure of the <code>overlapping</code> groups. We recommend that the users generate it automatically using <code>overlap_structure()</code>. See Examples and Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>own_variable</code></td>
<td>
<p>A non-decreasing integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code>nested_structure()</code>. See Examples and Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_own_variable</code></td>
<td>
<p>An integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code>nested_structure()</code>. See Examples and Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty_weights</code></td>
<td>
<p>Optional, vector of length <code class="reqn">G</code> specifying the group-specific penalty weights. We recommend that the users generate it automatically using <code>overlap_structure()</code> or <code>nested_structure()</code>. If not specified, <code class="reqn">\mathbf{1}_G</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_init</code></td>
<td>
<p>Optional, vector of initial values of the optimization algorithm. Default initial value is zero for all <code class="reqn">p</code> variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepsize_init</code></td>
<td>
<p>Initial value of the stepsize of the optimization algorithm. Default is 1.0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepsize_shrink</code></td>
<td>
<p>Factor in <code class="reqn">(0,1)</code> by which the stepsize shrinks in the backtracking linesearch. Default is 0.8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Convergence criterion. Algorithm stops when the <code class="reqn">l_2</code> norm of the difference between two consecutive updates is smaller than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, whether progress is printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The predictor matrix should be of dimension <code class="reqn">nm * p</code>. Each row records the values of covariates for one subject at one time, for example, the values at the day from <code>time</code> (Start) to <code>time2</code> (Stop). An example dataset <code>sim</code> is provided. The dataset has the format produced by the <code>R</code> package <span class="pkg">PermAlgo</span>. 
The specification of the arguments <code>group</code>, <code>group_variable</code>, <code>own_variable</code> and <code>no_own_variable</code> for the grouping structure can be found in <a href="https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec26">https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec26</a> and <a href="https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec27">https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec27</a>.
</p>
<p>In the Examples below, <code class="reqn">p=9,G=5</code>, the group structure is: </p>
<p style="text-align: center;"><code class="reqn">g_1 = \{A_{1}, A_{2}, A_{1}B, A_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_2  = \{B, A_{1}B, A_{2}B, C_{1}B, C_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_3  = \{A_{1}B, A_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_4  = \{C_1, C_2, C_{1}B, C_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_5  = \{C_{1}B, C_{2}B\}.</code>
</p>

<p>where <code class="reqn">g_3</code> is a subset of <code class="reqn">g_1</code> and <code class="reqn">g_2</code>, and <code class="reqn">g_5</code> is a subset of <code class="reqn">g_2</code> and <code class="reqn">g_4</code>.
</p>


<h3>Value</h3>

<p>A list with the following three elements.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>The user-specified regularization coefficients <code>lambda</code> sorted in decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>A matrix, with each column corresponding to the coefficient estimates at each <code class="reqn">\lambda</code> in <code>lambdas</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>A vector of number of iterations it takes to converge at each <code class="reqn">\lambda</code> in <code>lambdas</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">x &lt;- as.matrix(sim[, c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B")])
lam.seq &lt;- exp(seq(log(1e0), log(1e-3), length.out = 20))

# Variables:
## 1: A1
## 2: A2
## 3: C1
## 4: C2
## 5: B
## 6: A1B
## 7: A2B
## 8: C1B
## 9: C2B

# Overlapping groups:
## g1: A1, A2, A1B, A2B
## g2: B, A1B, A2B, C1B, C2B
## g3: A1B, A2B
## g4: C1, C2, C1B, C2B
## g5: C1B, C2B

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)

fit.overlapping &lt;- sox(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(fit.overlapping)

# Nested groups (misspecified, for the demonstration of the software only.)
## g1: A1, A2, C1, C2, B, A1B, A2B, C1B, C2B
## g2: A1B, A2B, A1B, A2B
## g3: C1, C2, C1B, C2B
## g4: 1
## g5: 2
## ...
## G12: 9

nested.groups &lt;- list(1:9,
                      c(1, 2, 6, 7),
                      c(3, 4, 8, 9),
                      1, 2, 3, 4, 5, 6, 7, 8, 9)

pars.nested &lt;- nested_structure(nested.groups)

fit.nested &lt;- sox(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "nested",
  lambda = lam.seq,
  group = pars.nested$groups,
  own_variable = pars.nested$own_variables,
  no_own_variable = pars.nested$N_own_variables,
  penalty_weights = pars.nested$group_weights,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(fit.nested)

</code></pre>


</div>