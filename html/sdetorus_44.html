<div class="container">

<table style="width: 100%;"><tr>
<td>periodicTrapRule1D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quadrature rules in 1D, 2D and 3D</h2>

<h3>Description</h3>

<p>Quadrature rules for definite integrals over intervals in 1D,
<code class="reqn">\int_{x_1}^{x_2} f(x)dx</code>, rectangles in 2D,<br><code class="reqn">\int_{x_1}^{x_2}\int_{y_1}^{y_2} f(x,y)dydx</code> and cubes in 3D,
<code class="reqn">\int_{x_1}^{x_2}\int_{y_1}^{y_2}\int_{z_1}^{z_2} f(x,y,z)dzdydx</code>.
The trapezoidal rules assume that the function is periodic, whereas the
Simpson rules work for arbitrary functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">periodicTrapRule1D(fx, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = 2 * pi)

periodicTrapRule2D(fxy, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = rep(2 * pi, 2))

periodicTrapRule3D(fxyz, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = rep(2 * pi, 3))

integrateSimp1D(fx, lengthInterval = 2 * pi, na.rm = TRUE)

integrateSimp2D(fxy, lengthInterval = rep(2 * pi, 2), na.rm = TRUE)

integrateSimp3D(fxyz, lengthInterval = rep(2 * pi, 3), na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fx</code></td>
<td>
<p>vector containing the evaluation of the function to integrate over
a uniform grid in <code class="reqn">[x_1,x_2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endsMatch</code></td>
<td>
<p>flag to indicate whether the values of the last entries of
<code>fx</code>, <code>fxy</code> or <code>fxyz</code> are the ones in the first entries
(elements, rows, columns, slices). See examples for usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical.  Should missing values (including <code>NaN</code>) be
removed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lengthInterval</code></td>
<td>
<p>vector containing the lengths of the intervals of
integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fxy</code></td>
<td>
<p>matrix containing the evaluation of the function to integrate
over a uniform grid in <code class="reqn">[x_1,x_2]\times[y_1,y_2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fxyz</code></td>
<td>
<p>three dimensional array containing the evaluation of the
function to integrate over a uniform grid in
<code class="reqn">[x_1,x_2]\times[y_1,y_2]\times[z_1,z_2]</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The simple trapezoidal rule has a very good performance for
periodic functions in 1D and 2D(order of error ). The higher dimensional
extensions are obtained by iterative usage of the 1D rules.
</p>


<h3>Value</h3>

<p>The value of the integral.
</p>


<h3>References</h3>

<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T., Flannery, B. P. (1996).
<em>Numerical Recipes in Fortran 77: The Art of Scientific Computing
(Vol. 1 of Fortran Numerical Recipes)</em>. Cambridge University Press,
Cambridge.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># In 1D. True value: 3.55099937
N &lt;- 21
grid &lt;- seq(-pi, pi, l = N)
fx &lt;- sin(grid)^2 * exp(cos(grid))
periodicTrapRule1D(fx = fx, endsMatch = TRUE)
periodicTrapRule1D(fx = fx[-N], endsMatch = FALSE)
integrateSimp1D(fx = fx, lengthInterval = 2 * pi)
integrateSimp1D(fx = fx[-N]) # Worse, of course

# In 2D. True value: 22.31159
fxy &lt;- outer(grid, grid, function(x, y) (sin(x)^2 * exp(cos(x)) +
                                         sin(y)^2 * exp(cos(y))) / 2)
periodicTrapRule2D(fxy = fxy, endsMatch = TRUE)
periodicTrapRule2D(fxy = fxy[-N, -N], endsMatch = FALSE)
periodicTrapRule1D(apply(fxy[-N, -N], 1, periodicTrapRule1D))
integrateSimp2D(fxy = fxy)
integrateSimp1D(apply(fxy, 1, integrateSimp1D))

# In 3D. True value: 140.1878
fxyz &lt;- array(fxy, dim = c(N, N, N))
for (i in 1:N) fxyz[i, , ] &lt;- fxy
periodicTrapRule3D(fxyz = fxyz, endsMatch = TRUE)
integrateSimp3D(fxyz = fxyz)
</code></pre>


</div>