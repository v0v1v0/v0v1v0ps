<div class="container">

<table style="width: 100%;"><tr>
<td>plotPatchesRGB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot Patches defined by RGB</h2>

<h3>Description</h3>

<p>RGB patches are a very common way of comparing color renderings.
This function draws rectangular patches,
and can also draw triangles formed by omitting one vertex from the rectangle.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotPatchesRGB( obj, space='sRGB', which='signal', maxColorValue=1,
                     background='gray50', shape='full', add=FALSE, labels=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>

<p>an Nx3 matrix of RGBs for N patches, preferably with assigned <code>rownames</code>.
<code>obj</code> can also be a <code>data.frame</code> containing a unique matrix column whose name
starts with the string <code>'RGB'</code>.
If <code>obj</code> has columns <code>LEFT,TOP,WIDTH,HEIGHT</code> then these are used to place the patches,
with the Y coordinate increasing going <em>down</em> the page.
If <code>obj</code> has columns <code>LEFT,BOTTOM,WIDTH,HEIGHT</code> then these are used to place the patches,
with the Y coordinate increasing going <em>up</em> the page.
If there are no columns defining the location and size of the patches,
then defaults are supplied, see <b>Details</b>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>space</code></td>
<td>
<p>the name of an installed RGB space.
When the input RGB is linear, a transfer function of this RGB space is used
to convert linear RGB to signal RGB, see <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>the meaning of the RGB values in <code>obj</code>.
Valid values are <code>'signal'</code>, <code>'scene'</code>, and <code>'display'</code>.
See the Figure on page 2.
Partial matching is used.
For the RGB processing, see <b>Details</b>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxColorValue</code></td>
<td>
<p>a positive number used for input RGB scaling, see <b>Details</b></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>background</code></td>
<td>

<p>the color for the background behind all the patches.
If it is a character string, it is passed directly to <code>par()</code> as parameter <code>bg</code>.
If it is a numeric vector of length 3, it is processed just like the input RGB in <code>obj</code>,
see  <b>Details</b>.
If it is a number, it is interpreted as graylevel,
replicated to length 3, and treated as in the previous sentence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>

<p>If <code>shape='full'</code> (the default) then the full rectangle is drawn.
<br>
If <code>shape='half'</code> then the rectangle is shrunk to 1/2 size, and with the same center.
<br>
If <code>shape</code> is one of <code>'left'</code>, <code>'right'</code>, <code>'bottom'</code>, or <code>'top'</code>
then only a  half-rectangle is drawn, and keeping the specified side.
<br>
If <code>shape</code> is one of <code>'topleft'</code>, <code>'topright'</code>, <code>'bottomleft'</code>, or <code>'bottomright'</code>,
then only a triangular half of the rectangle is drawn, 
and keeping the specified vertex.
<br>
If <code>shape='hhex'</code> then a hexagon is drawn inscribed in the rectangle with 2 horizontal
opposite sides (in contact with the rectangle sides).
And if the aspect ratio of the rectangle is <code class="reqn"> 2:\sqrt{3} </code> the hexagon is regular.
If <code>shape='vhex'</code> then the inscribed rectangle has 2 vertical opposite sides.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>if <code>TRUE</code> then the patches are added to an existing plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>controls how the patches are labeled, using <code>rownames(obj)</code>,
or 1:N if <code>rownames(obj)</code> is <code>NULL</code>.
The function used is <code>graphics::text()</code>.
If <code>labels=FALSE</code> then no labels are plotted.
If <code>labels=TRUE</code> then labels are plotted in the center of the patch when there are
columns defining the location and size of the patches, and to the right of the patch otherwise.
<br><code>labels</code> can also be a character string defining the location where the labels are drawn.
It can be the side of the patches, i.e. <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code>,
or the corner of the patches, i.e. <code>bottomleft</code>, <code>bottomright</code>, <code>topleft</code>, or <code>topright</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>graphics::text()</code>.
For example: <code>adj</code>, <code>cex</code>, etc.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>which='signal'</code> then the input RGBs are converted to hex codes using
<code>rgb()</code> using the <code>maxColorValue</code> argument,
and the <code>space</code> argument is ignored.
<br>
If <code>which='scene'</code> or  <code>which='display'</code> then the input linear RGBs are normalized
by division by <code>maxColorValue</code>, and then converted to signal RGB using
<code>SignalRGBfromLinearRGB()</code> with the <code>space</code> argument.
The signal RGB is then converted to hex codes using <code>rgb()</code>.
</p>
<p>If <code>obj</code> is a matrix, or a data.frame without columns <code>LEFT,TOP,WIDTH,HEIGHT</code>,
then the patches are drawn vertically stacked and abutting from top to bottom.
</p>


<h3>Value</h3>

 <p><code>TRUE</code> if successful, and <code>FALSE</code> otherwise</p>


<h3>See Also</h3>

<p><code>SignalRGBfromLinearRGB()</code>,
<code>installRGB()</code>,
<code>rgb()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(0)
RGB = round( 255 * matrix( runif(6*3), 6, 3 ) )
plotPatchesRGB( RGB, max=255 )
</code></pre>


</div>