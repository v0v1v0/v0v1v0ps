<div class="container">

<table style="width: 100%;"><tr>
<td>solve_cg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve Systems of Equations Using Iterative Methods</h2>

<h3>Description</h3>

<p>Iterative solvers using the Conjugate Gradient method for sparse systems of
equations <code class="reqn">Ax = b</code>. Three different types are available: (1)
stabilized bi-conjugate gradient (BiCGSTAB) for square matrices, (2)
conjugate gradient for rectangular least-squares (LSCG), and (3) classic
conjugate gradient (CG) for symmetric positive definite matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">solve_cg(
  a,
  b,
  x0,
  type = c("BiCGSTAB", "LSCG", "CG"),
  iter,
  tol,
  precond = 1L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Square numeric matrix with the coefficients of the linear system.
Dense and sparse matrices are supported, but the format must be sparse (see
<code>sparsify</code>). Dense matrices are coerced automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Numeric vector or matrix at the right-hand side of the linear
system. If missing, 'b' is set to an identity matrix and 'a' is
inverted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>Numeric vector or matrix with an initial guess. Must be of the
same dimension as 'b'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character scalar. Whether to use the BiCGSTAB, least squares
CG or classic CG method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Integer scalar with the maximum number of iterations. Defaults
to the theoretical maximum, i.e. the number of columns in 'a'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric scalar with the desired tolerance. Defaults to the
machine precision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precond</code></td>
<td>
<p>Integer scalar indicating the type of preconditioner to be
used. Defaults to diagonal preconditioning. See the Details for further
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical scalar. Whether to print iterations and tolerance.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Preconditioners can be set to <code>0</code> for no / identity preconditioning,
<code>1</code> (default) for Jacobi / diagonal preconditioning, or <code>2</code> for
incomplete factorisation. Not all schemes are available for every type:
</p>
<p>* <code>type = "BiCGSTAB"</code> The default is <code>precond = 1</code> for diagonal
preconditioning. Set <code>precond = 0</code> for no preconditioning, or
<code>precond = 2</code> for an incomplete LUT preconditioner.
* <code>type = "LSCG"</code> The default is <code>precond = 1</code> for diagonal least
squares preconditioning. Set <code>precond = 0</code> for no preconditioning.
* <code>type = "CG"</code> The default is <code>precond = 1</code> for diagonal
preconditioning. Set <code>precond = 0</code> for no preconditioning, or
<code>precond = 2</code> for an incomplete Cholesky preconditioner.
</p>


<h3>Value</h3>

<p>Solves for <code class="reqn">x</code> and returns a numeric matrix with the results.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)
x &lt;- rnorm(3)

# Solve via BiCGSTAB for square matrices
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
b &lt;- A %*% x
norm(solve_cg(A, b, type = "B") - x)

# Solve via LSCG for rectangular matrices
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
b &lt;- A %*% x
norm(solve_cg(A, b, type = "LS") - x)

# Solve via classic CG for symmetric matrices
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_cg(A, b, type = "CG") - x)

# The input matrix A should always be in sparse format
A &lt;- sparsify(crossprod(matrix(rnorm(9), nrow = 3, ncol = 3)))
# The right-hand side should be a dense matrix
b &lt;- as.matrix(A %*% x)

# We can check the speed of convergence and quality directly
solve_cg(A, b, verbose = TRUE)
# And provide guesses as starting value
solve_cg(A, b, x0 = x, verbose = TRUE)

</code></pre>


</div>