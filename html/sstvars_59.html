<div class="container">

<table style="width: 100%;"><tr>
<td>loglikelihood</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Log-likelihood function</h2>

<h3>Description</h3>

<p><code>loglikelihood</code> log-likelihood function of a smooth transition VAR model
</p>


<h3>Usage</h3>

<pre><code class="language-R">loglikelihood(
  data,
  p,
  M,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  other_constraints = NULL,
  to_return = c("loglik", "tw", "loglik_and_tw", "terms", "regime_cmeans",
    "total_cmeans", "total_ccovs", "B_t"),
  check_params = TRUE,
  indt_R = FALSE,
  alt_par = FALSE,
  minval = NULL,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li>
<p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li>
<p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>
</li>
<li>
<p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt>
<dd>
<p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt>
<dd>
<p><code class="reqn">\nu = (\nu_1,...,\nu_M)</code> <code class="reqn">(M \times 1)</code>, <code class="reqn">nu_m &gt; 2</code>.</p>
</dd>
</dl>
</li>
</ul>
<p>For models with...
</p>

<dl>
<dt>
<code>weight_function="relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt>
<code>weight_function="logistic"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>
<code>weight_function="exponential"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>
<code>weight_function="threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt>
<code>weight_function="exogenous"</code>:</dt>
<dd>
<p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt>
<dd>
<p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt>
<dd>
<p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt>
<code>identification="heteroskedasticity"</code>:</dt>
<dd>
<p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints (only for structural models identified by heteroskedasticity):</dt>
<dd>
<p>Replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector
so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt>
<code>"relative_dens"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt>
<code>"logistic"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"mlogit"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt>
<code>"exponential"</code>:</dt>
<dd>
<p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt>
<code>"threshold"</code>:</dt>
<dd>
<p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt>
<code>"exogenous"</code>:</dt>
<dd>
<p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>
<p>See the vignette for more details about the weight functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt>
<dd>
<p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt>
<dd>
<p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt>
<dd>
<p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt>
<dd>
<p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt>
<dd>
<p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt>
<dd>
<p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, or <code>"ind_Student"</code>,
where the latest is the Student's <code class="reqn">t</code> distribution with independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt>
<code>"reduced_form"</code>:</dt>
<dd>
<p>Reduced form model.</p>
</dd>
<dt>
<code>"recursive"</code>:</dt>
<dd>
<p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt>
<code>"heteroskedasticity"</code>:</dt>
<dd>
<p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt>
<code>"non-Gaussianity"</code>:</dt>
<dd>
<p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 x 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> in order to constrain the
the weight parameter to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt>
<dd>
<p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt>
<dd>
<p>set to the string "fixed_sign_and_order"
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_return</code></td>
<td>
<p>should the returned object be the log-likelihood, which is the default, or something else?
See the section "Value" for all the options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_params</code></td>
<td>
<p>should it be checked that the parameter vector satisfies the model assumptions? Can be skipped to save
computation time if it does for sure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indt_R</code></td>
<td>
<p>If <code>TRUE</code> calculates the independent Student's t density in R instead of C++ without any approximations
employed for speed-up.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt_par</code></td>
<td>
<p>If <code>TRUE</code> assumes that models identified by non-Gaussianiaty (or <code>cond_dist="Student"</code>) are
parametrized as <code class="reqn">B_{y,t}=B_1 + \sum_{m=2}^M\alpha_{m,t}B_m^*</code>, where <code class="reqn">B_m^* = B_m - B_1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the "bold A" matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be "outside" the parameter space.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates the log-likelihood of the specified model.
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return="loglik"</code>:</dt>
<dd>
<p>the log-likelihood of the specified model.</p>
</dd>
<dt>If <code>to_return=="tw"</code>:</dt>
<dd>
<p>a size <code>[n_obs-p, M]</code> matrix containing the transition weights: for m:th component
in m:th column.</p>
</dd>
<dt>If <code>to_return=="loglik_and_tw"</code>:</dt>
<dd>
<p>a list of two elements. The first element (<code>$loglik</code>) contains the
log-likelihood and the second element (<code>$tw</code>) contains the transition weights.</p>
</dd>
<dt>If <code>to_return=="terms"</code>:</dt>
<dd>
<p>a length <code>n_obs-p</code> numeric vector containing the terms <code class="reqn">l_{t}</code>.</p>
</dd>
<dt>If <code>to_return=="regime_cmeans"</code>:</dt>
<dd>
<p>an <code>[n_obs-p, d, M]</code> array containing the regimewise conditional means.</p>
</dd>
<dt>If <code>to_return=="total_cmeans"</code>:</dt>
<dd>
<p>a <code>[n_obs-p, d]</code> matrix containing the conditional means of the process.</p>
</dd>
<dt>If <code>to_return=="total_ccovs"</code>:</dt>
<dd>
<p>an <code>[d, d, n_obs-p]</code> array containing the conditional covariance matrices of
the process.</p>
</dd>
<dt>If <code>to_return=="B_t"</code>:</dt>
<dd>
<p>an <code>[d, d, n_obs-p]</code> array containing the impact matrices <code class="reqn">B_t</code> of
the process. Available only for models with <code>cond_dist="ind_Student"</code>.</p>
</dd>
</dl>
<h3>References</h3>


<ul>
<li>
<p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li>
<p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li>
<p> Lanne M., Virolainen S. 2024. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li>
<p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li>
<p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li>
<p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li>
<p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li>
<p> Virolainen S. 2024. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li>
</ul>
</div>