<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate_multiple_fun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapper to <code>aggregate</code>
</h2>

<h3>Description</h3>

<p>Wrapper to <code>aggregate</code> that allows multiple functions and functions of several variables
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregate_multiple_fun(
  data,
  by,
  vars,
  fun = NULL,
  ind = NULL,
  ...,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  forward_dots = FALSE,
  dots2dots = FALSE,
  do_unmatrix = TRUE,
  do_unlist = TRUE,
  inc_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>A data frame defining grouping</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li>
<p> Parameter <code>vars</code> will converted to an internal standard by the function <code>fix_vars_amf</code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code>fix_vars_amf</code>. Indices instead of variable names are allowed.
</p>
</li>
<li>
<p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li>
<p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code>fix_fun_amf</code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>
<p>When non-NULL, a data frame of indices.
When NULL, this variable will be generated internally as <code>data.frame(ind = seq_len(nrow(data)))</code>.
The parameter is useful for advanced use involving model/dummy matrices.
For special use (<code>dummy = FALSE</code> in <code>dummy_aggregate</code>) <code>ind</code> can also be a two-column data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>aggregate</code> and,
depending on <code>forward_dots</code>/<code>dots2dots</code>, forwarded to the functions in <code>fun</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name_sep</code></td>
<td>
<p>A character string used when output variable names are generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seve_sep</code></td>
<td>
<p>A character string used when output variable names are generated from functions of several variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multi_sep</code></td>
<td>
<p>A character string used when multiple output variable names are sent as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forward_dots</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of <code>fun</code> that determines whether <code>...</code> should be forwarded (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dots2dots</code></td>
<td>
<p>Logical vector (possibly recycled) specifying the behavior when <code>forward_dots = TRUE</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_unmatrix</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code>unmatrix</code> before returning output.
For special use this can be omitted (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_unlist</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code>unlist</code> to combine output from multiple functions.
For special use this can be omitted (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inc_progress</code></td>
<td>
<p>logigal, <code>NULL</code> (same as <code>FALSE</code>) or a  progress indicator function taking two parameters (i and n).
<code>TRUE</code> means the same as <code>inc_default</code>. Note that this feature is implemented in a
hacky manner as internal/hidden variables are grabbed from <code>aggregate</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One intention of <code>aggregate_multiple_fun</code> is to be a true generalization of <code>aggregate</code>.
However, when many functions are involved, passing extra parameters can easily lead to errors.
Therefore <code>forward_dots</code> and <code>dots2dots</code> are set to <code>FALSE</code> by default.
When <code>forward_dots = TRUE</code> and <code>dots2dots = FALSE</code>, parameters will be forwarded,
but only parameters that are explicitly defined in the specific <code>fun</code> function.
For the <code>sum</code> function, this means that a possible <code>na.rm</code> parameter is forwarded but not others.
When <code>forward_dots = TRUE</code> and <code>dots2dots = TRUE</code>, other parameters will also be forwarded to <code>fun</code> functions where <code>...</code> is included.
For the <code>sum</code> function, this means that such extra parameters will, probably erroneously, be included in the summation (see examples).
</p>
<p>For the function to work with <code>dummy_aggregate</code>,
the data is subject to <code>unlist</code> before the <code>fun</code> functions are called.
This does not apply in the special case where <code>ind</code> is a two-column data frame.
Then, in the case of list data, the <code>fun</code> functions have to handle this themselves.
</p>
<p>A limitation when default output, when <code>do_unlist = TRUE</code>, is that variables in output are forced to have the same class.
This is caused by the <code>unlist</code> function being run on the output. This means, for example,
that all the variables will become numeric when they should have been both integer and numeric.
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class="language-R">d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c("freq", "y", median = "freq", median = "y", e1 = "freq"),
   fun = c(sum, median = median, e1 = function(x) x[1])  
)

# With functions as named strings 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", med = "freq", med = "y"),
   fun = c(sum = "sum", med = "median")
)

# Without specifying functions 
# - equivalent to `fun = c("sum", "median")` 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", median = "freq", median = "y")
)

# The single unnamed variable feature. Also functions as strings. 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = "y",
   fun = c("sum", "median", "min", "max")
) 

# with multiple outputs (function my_range)
# and with function of two variables (weighted.mean(y, freq))
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", ra = "freq", wmean  = c("y", "freq")),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)


# To illustrate forward_dots and dots2dots
q &lt;- d[1, ]
q$w &lt;- 100 * rnorm(1)
for (dots2dots in c(FALSE, TRUE)) for (forward_dots in c(FALSE, TRUE)) {
  cat("\n=======================================\n")
  cat("forward_dots =", forward_dots, ", dots2dots =", dots2dots)
  out &lt;- aggregate_multiple_fun(
    data = q, by = q["k_group"], 
    vars = c(sum = "freq", round = "w"), fun = c("sum", "round"),  
    digits = 3, forward_dots = forward_dots, dots2dots = dots2dots)
  cat("\n")
  print(out)
}
# In last case digits forwarded to sum (as ...) 
# and wrongly included in the summation
 
</code></pre>


</div>