<div class="container">

<table style="width: 100%;"><tr>
<td>Pn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utilities for projected-ecdf statistics of spherical uniformity</h2>

<h3>Description</h3>

<p>Computation of the kernels
</p>
<p style="text-align: center;"><code class="reqn">\psi_p^W(\theta) := \int_{-1}^1 A_x(\theta)\,\mathrm{d}W(F_p(x)),</code>
</p>

<p>where <code class="reqn">A_x(\theta)</code> is the proportion of area surface of
<code class="reqn">S^{p - 1}</code> covered by the
intersection of two hyperspherical caps with common solid
angle <code class="reqn">\pi - \cos^{-1}(x)</code> and centers separated by
an angle <code class="reqn">\theta \in [0, \pi]</code>, <code class="reqn">F_p</code> is the distribution function
of the projected spherical uniform distribution,
and <code class="reqn">W</code> is a measure on <code class="reqn">[0, 1]</code>.
</p>
<p>Also, computation of the Gegenbauer coefficients of
<code class="reqn">\psi_p^W</code>:
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p}^W := \frac{1}{c_{k, p}}\int_0^\pi \psi_p^W(\theta)
C_k^{p / 2 - 1}(\cos\theta)\,\mathrm{d}\theta.</code>
</p>

<p>These coefficients can also be computed via
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p}^W = \int_{-1}^1 a_{k, p}^x\,\mathrm{d}W(F_p(x))</code>
</p>

<p>for a certain function <code class="reqn">x\rightarrow a_{k, p}^x</code>. They serve to define
projected alternatives to uniformity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">psi_Pn(theta, q, type, Rothman_t = 1/3, tilde = FALSE, psi_Gauss = TRUE,
  psi_N = 320, tol = 1e-06)

Gegen_coefs_Pn(k, p, type, Rothman_t = 1/3, Gauss = TRUE, N = 320,
  tol = 1e-06, verbose = FALSE)

akx(x, p, k, sqr = FALSE)

f_locdev_Pn(p, type, K = 1000, N = 320, K_max = 10000, thre = 0.001,
  Rothman_t = 1/3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector with values in <code class="reqn">[0, \pi]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>integer giving the dimension of the sphere <code class="reqn">S^q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of projected-ecdf test statistic. Must be either
<code>"PCvM"</code> (Cramér–von Mises), <code>"PAD"</code> (Anderson–Darling), or
<code>"PRt"</code> (Rothman).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tilde</code></td>
<td>
<p>include the constant and bias term? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi_Gauss</code></td>
<td>
<p>use a Gauss–Legendre quadrature
rule with <code>psi_N</code> nodes in the computation of the kernel function?
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi_N</code></td>
<td>
<p>number of points used in the Gauss–Legendre quadrature for
computing the kernel function. Defaults to <code>320</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance passed to <code>integrate</code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>vector with the index of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gauss</code></td>
<td>
<p>use a Gauss–Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code>integrate</code>. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of points used in the 
Gauss–Legendre quadrature for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>flag to print informative messages. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>evaluation points for <code class="reqn">a_{k, p}^x</code>, a vector with values in
<code class="reqn">[-1, 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqr</code></td>
<td>
<p>return the <em>signed</em> square root of <code class="reqn">a_{k, p}^x</code>?
Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">f</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_max</code></td>
<td>
<p>integer giving the truncation of the series. Defaults to
<code>1e4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thre</code></td>
<td>
<p>proportion of norm <em>not</em> explained by the first terms of the
truncated series. Defaults to <code>1e-3</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The evaluation of <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code> depends on the type of
projected-ecdf statistic:
</p>

<ul>
<li>
<p> PCvM: closed-form expressions for <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code>
with <code class="reqn">p = 2, 3, 4</code>, numerical integration required for <code class="reqn">p \ge 5</code>.
</p>
</li>
<li>
<p> PAD: closed-form expressions for <code class="reqn">\psi_2^W</code> and <code class="reqn">b_{k, 3}^W</code>,
numerical integration required for <code class="reqn">\psi_p^W</code> with <code class="reqn">p \ge 3</code> and
<code class="reqn">b_{k, p}^W</code> with <code class="reqn">p = 2</code> and <code class="reqn">p \ge 4</code>.
</p>
</li>
<li>
<p> PRt: closed-form expressions for <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code>
for any <code class="reqn">p \ge 2</code>.
</p>
</li>
</ul>
<p>See García-Portugués et al. (2023) for more details.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>psi_Pn</code>: a vector of size <code>length(theta)</code> with the
evaluation of <code class="reqn">\psi</code>.
</p>
</li>
<li> <p><code>Gegen_coefs_Pn</code>: a vector of size <code>length(k)</code> containing
the coefficients <code class="reqn">b_{k, p}^W</code>.
</p>
</li>
<li> <p><code>akx</code>: a matrix of size <code>c(length(x), length(k))</code>
containing the coefficients <code class="reqn">a_{k, p}^x</code>.
</p>
</li>
<li> <p><code>f_locdev_Pn</code>: the projected alternative <code class="reqn">f</code> as a function
ready to be evaluated.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Paula Navarro-Esteban.
</p>


<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181–204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Kernels in the projected-ecdf test statistics
k &lt;- 0:10
coefs &lt;- list()
(coefs$PCvM &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PCvM"))))
(coefs$PAD &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PAD"))))
(coefs$PRt &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PRt"))))

# Gegenbauer expansion
th &lt;- seq(0, pi, length.out = 501)[-501]
old_par &lt;- par(mfrow = c(3, 4))
for (type in c("PCvM", "PAD", "PRt")) {

  for (p in 2:5) {

    plot(th, psi_Pn(theta = th, q = p - 1, type = type), type = "l",
         main = paste0(type, ", p = ", p), xlab = expression(theta),
         ylab = expression(psi(theta)), axes = FALSE, ylim = c(-1.5, 1))
    axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
         labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
    axis(2); box()
    lines(th, Gegen_series(theta = th, coefs = coefs[[type]][p - 1, ],
                           k = k, p = p), col = 2)

  }

}
par(old_par)

# Analytical coefficients vs. numerical integration
test_coef &lt;- function(type, p, k = 0:20) {

  plot(k, log1p(abs(Gegen_coefs_Pn(k = k, p = p, type = type))),
       ylab = "Coefficients", main = paste0(type, ", p = ", p))
  points(k, log1p(abs(Gegen_coefs(k = k, p = p, psi = psi_Pn, type = type,
                                  q = p - 1))), col = 2)
  legend("topright", legend = c("log(1 + Gegen_coefs_Pn))",
                                "log(1 + Gegen_coefs(psi_Pn))"),
         lwd = 2, col = 1:2)

}

# PCvM statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PCvM", p = p)
par(old_par)

# PAD statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PAD", p = p)
par(old_par)

# PRt statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PRt", p = p)
par(old_par)

# akx
akx(x = seq(-1, 1, l = 5), k = 1:4, p = 2)
akx(x = 0, k = 1:4, p = 3)

# PRt alternative to uniformity
z &lt;- seq(-1, 1, l = 1e3)
p &lt;- c(2:5, 10, 15, 17)
col &lt;- viridisLite::viridis(length(p))
plot(z, f_locdev_Pn(p = p[1], type = "PRt")(z), type = "s",
     col = col[1], ylim = c(0, 0.6), ylab = expression(f[Rt](z)))
for (k in 2:length(p)) {
  lines(z, f_locdev_Pn(p = p[k], type = "PRt")(z), type = "s", col = col[k])
}
legend("topleft", legend = paste("p =", p), col = col, lwd = 2)
</code></pre>


</div>