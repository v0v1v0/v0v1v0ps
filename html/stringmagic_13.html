<div class="container">

<table style="width: 100%;"><tr>
<td>string_extract</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extracts a pattern from a character vector</h2>

<h3>Description</h3>

<p>Extracts the first, or several, patterns from a character vector.
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_extract(
  x,
  pattern,
  single = FALSE,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  unlist = FALSE,
  envir = parent.frame()
)

stextract(
  x,
  pattern,
  single = FALSE,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  unlist = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>A character scalar. It represents the pattern
to be extracted from <code>x</code>. By default
this is a regular expression. You can use flags in the pattern in
the form <code style="white-space: pre;">⁠flag1, flag2/pattern⁠</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
single (select only the first element), and magic (add interpolation with <code>{}</code>) . Example:
if <code>"ignore/hello"</code> and <code style="white-space: pre;">⁠x = "Hello world⁠</code> extracted text is <code>"Hello"</code>.
Shortcut: use the first letters of the flags. Ex: "iw/one" will extract the word
"one" (flags 'ignore' + 'word').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>single</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, only the first pattern
that is detected will be returned. Note that in that case, a character vector is returned
of the same length as the vector in input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If <code>TRUE</code>, then when the vector input <code>x</code>
is of length 1, a character vector is returned instead of a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unlist</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, the function <code>unlist</code> is applied
to the resulting list, leading to a character vector in output (instead of a list).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The object returned by this functions can be a list or a character vector.
</p>
<p>If <code>single = TRUE</code>, a character vector is returned, containing the value of the first match.
If no match is found, an empty string is returned.
</p>
<p>If <code>single = FALSE</code> (the default) and <code>simplify = TRUE</code> (default), the object returned is:
</p>

<ul>
<li>
<p> a character vector if <code>x</code>, the vector in input, is of length 1: the character vector contains
all the matches and is of length 0 if no match is found.
</p>
</li>
<li>
<p> a list of the same length as <code>x</code>. The ith element of the list is a character vector
of the matches for the ith element of <code>x</code>.
</p>
</li>
</ul>
<p>If <code>single = FALSE</code> (default) and <code>simplify = FALSE</code>, the object returned is always a list.
</p>


<h3>Functions</h3>


<ul><li> <p><code>stextract()</code>: Alias to <code>string_extract</code>
</p>
</li></ul>
<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is "flag1, flag2/pattern". That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag "fixed" removes the regular expression meaning of "." which would have otherwise meant <em>"any character"</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: "if/dt[" will apply the flags "ignore" and "fixed" to the pattern "dt[".
</p>
<p>The four flags always available are: "ignore", "fixed", "word" and "magic".
</p>

<ul>
<li>
<p> "ignore" instructs to ignore the case. Technically, it adds the perl-flag "(?i)"
at the beginning of the pattern.
</p>
</li>
<li>
<p> "fixed" removes the regular expression interpretation, so that the characters ".", "$", "^", "["
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li>
<p> "word" adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, "word/one, two" is treated as "\b(one|two)\b". Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to " I ambushed?" thanks to the flags "ignore" and "word".
</p>
</li>
<li>
<p> "magic" allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
cars = head(row.names(mtcars))

# Let's extract the first word:
string_extract(cars, "\\w+", single = TRUE)

# same using flags
string_extract(cars, "s/\\w+")

# extract all words composed on only letters
# NOTE: we use the flag word (`w/`)
string_extract(cars, "w/[[:alpha:]]+")

# version without flag:
string_extract(cars, "\\b[[:alpha:]]+\\b")

# If a vector of length 1 =&gt; a vector is returned
greet = "Hi Tom, how's Mary doing?"
string_extract(greet, "w/[[:upper:]]\\w+")

# version with simplify = FALSE =&gt; a list is returned
string_extract(greet, "w/[[:upper:]]\\w+", simplify = FALSE)

</code></pre>


</div>