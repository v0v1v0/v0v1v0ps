<div class="container">

<table style="width: 100%;"><tr>
<td>gramian</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gramian matrix, norms, and inner products of splines</h2>

<h3>Description</h3>

<p>The function performs evaluation of the matrix of the inner products 
<code class="reqn">\int S(t) \cdot T(t) dt </code> of all the pairs of splines <code class="reqn">S</code>, <code class="reqn">T</code> from the input object.
The program utilizes the Taylor expansion of splines, see the reference for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gramian(Sp, norm_only = FALSE, sID = NULL, Sp2 = NULL, s2ID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p><code>Splinets</code> object;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_only</code></td>
<td>
<p>logical, indicates if only the square norm of the 
elements in the input object is calculated; The default is <code>norm_only=FALSE</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sID</code></td>
<td>
<p>vector of integers, the indicies specifying splines in the <code>Splinets</code> 
list <code>Sp</code> to be evaluated; If <code>sID=NULL</code> (default), then the inner products for all the pairs taken from the object are evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp2</code></td>
<td>
<p><code>Splinets</code> object, the optional second  <code>Splinets</code>-object; The inner products between 
splines in <code>Sp</code> and in <code>Sp2</code> are evaluated, i.e. the cross-gramian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2ID</code></td>
<td>
<p>vector of integers, the indicies specifying splines in the <code>Sp2</code> to be considered in the cross-gramian;</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If there is only one input <code>Splinet</code>-object, then the non-negative symmetrix matrix of the splines in this object is returned. 
If there are two input <code>Splinet</code>-objects, then the <code class="reqn">m \times r</code> matrix of the cross-inner product is returned, where <code class="reqn">m</code> is 
the number of splines in the first object and <code class="reqn">r</code> is their number in the second one. 
If only the norms are evaluated (<code>norm_only= TRUE</code>) it is always evaluating the norms of the first object. 
In the case of two input <code>Splinets</code>-objects, they should be over the same set of knots and of the same smoothness order.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>norm_only=FALSE</code> – the Gram matrix of inner products of the splines within the input <code>Splinets</code>-objects is returned, 
</p>
</li>
<li> <p><code>Sp2 = NULL</code> – the non-negative definite matrix of the inner products of splines in <code>Sp</code> is returned,
</p>
</li>
<li>
<p> both <code>Sp</code> and <code>Sp2</code> are non-<code>NULL</code> and contain splines <code class="reqn">S_i</code>'s and <code class="reqn">T_j</code>'s, respectively == 
the cross-gramian matris of the inner products for the pairs of splines <code class="reqn">(S_i,T_j)</code> is returned,
</p>
</li>
<li> <p><code>norm_only=FALSE</code>– the vector of the norms of <code>Sp</code> is returned.
</p>
</li>
</ul>
<h3>References</h3>

<p>Liu, X., Nassar, H., Podg<code class="reqn">\mbox{\'o}</code>rski, K. "Dyadic diagonalization of positive definite band matrices and efficient B-spline orthogonalization." Journal of Computational and Applied Mathematics (2022) &lt;https://doi.org/10.1016/j.cam.2022.114444&gt;.
</p>
<p>Podg<code class="reqn">\mbox{\'o}</code>rski, K. (2021) 
"<code>Splinets</code> – splines through the Taylor expansion, their support sets and orthogonal bases." &lt;arXiv:2102.00733&gt;.
</p>
<p>Nassar, H., Podg<code class="reqn">\mbox{\'o}</code>rski, K. (2023) "Splinets 1.5.0 – Periodic Splinets." &lt;arXiv:2302.07552&gt;
</p>


<h3>See Also</h3>

<p><code>lincomb</code> for evaluation of a linear combination of splines;
<code>project</code> for projections to the spaces of Splines;
</p>


<h3>Examples</h3>

<pre><code class="language-R">#---------------------------------------#
#---- Simple three splines example -----# 
#---------------------------------------#
n=25; k=3
xi=sort(runif(n+2)); xi[1]=0; xi[n+2]=1
#Defining support ranges for three splines
supp=matrix(c(2,12,4,20,6,25),byrow=TRUE,ncol=2)
#Initial random matrices of the derivative for each spline
SS1=matrix(rnorm((supp[1,2]-supp[1,1]+1)*(k+1)),ncol=(k+1)) 
SS2=matrix(rnorm((supp[2,2]-supp[2,1]+1)*(k+1)),ncol=(k+1)) 
SS3=matrix(rnorm((supp[3,2]-supp[3,1]+1)*(k+1)),ncol=(k+1)) 
spl=construct(xi,k,SS1,supp[1,]) #constructing the first correct spline
nspl=construct(xi,k,SS2,supp[2,])
spl=gather(spl,nspl) #the second and the first ones
nspl=construct(xi,k,SS3,supp[3,])
spl=gather(spl,nspl) #the third is added

plot(spl)
gramian(spl)
gramian(spl, norm_only = TRUE)
gramian(spl, sID = c(1,3))
gramian(spl,sID=c(2,3),Sp2=spl,s2ID=c(1)) #the cross-Gramian matrix  

#-----------------------------------------#
#--- Example with varying support sets ---#
#-----------------------------------------#
n=40; xi=seq(0,1,by=1/(n+1)); k=2; 
support=list(matrix(c(2,9,15,24,30,37),ncol=2,byrow = TRUE))
sp=new("Splinets",knots=xi,smorder=k,supp=support) 
m=sum(sp@supp[[1]][,2]-sp@supp[[1]][,1]+1) #the number of knots in the support
sp@der=list(matrix(rnorm(m*(k+1)),ncol=(k+1))) #the derivative matrix at random
sp1 = is.splinets(sp)[[2]] #the correction of 'der' matrices

support=list(matrix(c(5,12,17,29),ncol=2,byrow = TRUE))
sp=new("Splinets",knots=xi,smorder=k,supp=support) 
m=sum(sp@supp[[1]][,2]-sp@supp[[1]][,1]+1) #the number of knots in the support
sp@der=list(matrix(rnorm(m*(k+1)),ncol=(k+1))) #the derivative matrix at random
sp2 = is.splinets(sp)[[2]] 

spp = gather(sp1,sp2)

support=list(matrix(c(3,10,14,21,27,34),ncol=2,byrow = TRUE))
sp=new("Splinets",knots=xi,smorder=k,supp=support) 
m=sum(sp@supp[[1]][,2]-sp@supp[[1]][,1]+1) #the number of knots in the support
sp@der=list(matrix(rnorm(m*(k+1)),ncol=(k+1))) #the derivative matrix at random
sp3 = is.splinets(sp)[[2]] 

spp = gather(spp, sp3)

plot(spp)
gramian(spp) #the regular gramian matrix
spp2=subsample(spp,sample(1:3,size=3,rep=TRUE))
gramian(Sp=spp,Sp2=spp2) #cross-Gramian matrix


#-----------------------------------------#
#--------- Grammian for B-splines --------#
#-----------------------------------------#

n=25; xi=seq(0,1,by=1/(n+1)); k=2; 
Sp=splinet(xi) #B-splines and corresponding splinet

gramian(Sp$bs) #band grammian matrix for B-splines
gramian(Sp$os) #diagonal gramian matrix for the splinet
A=gramian(Sp=Sp$bs,Sp2=Sp$os) #cross-Gramian matrix, the coefficients of
                              #the decomposition of the B-splines

plot(Sp$bs)
plot(lincomb(Sp$os,A))
</code></pre>


</div>