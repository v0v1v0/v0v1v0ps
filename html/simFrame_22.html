<div class="container">

<table style="width: 100%;"><tr>
<td>clusterRunSimulation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a simulation experiment on a cluster</h2>

<h3>Description</h3>

<p>Generic function for running a simulation experiment on a cluster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clusterRunSimulation(cl, x, setup, nrep, control,
                     contControl = NULL, NAControl = NULL,
                     design = character(), fun, ...,
                     SAE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster as generated by <code>makeCluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>data.frame</code> (for design-based simulation or simulation based
on real data) or a control object for data generation inheriting from
<code>"VirtualDataControl"</code> (for model-based simulation or mixed simulation
designs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setup</code></td>
<td>
<p>an object of class <code>"SampleSetup"</code>, containing previously
set up samples, or a control class for setting up samples inheriting
from <code>"VirtualSampleControl"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>a non-negative integer giving the number of repetitions of the
simulation experiment (for model-based simulation, mixed simulation designs
or simulation based on real data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a control object of class <code>"SimControl"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contControl</code></td>
<td>
<p>an object of a class inheriting from
<code>"VirtualContControl"</code>, controlling contamination in the simulation
experiment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAControl</code></td>
<td>
<p>an object of a class inheriting from
<code>"VirtualNAControl"</code>, controlling the insertion of missing values in
the simulation experiment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>a character vector specifying variables (columns) to be used
for splitting the data into domains.  The simulations, including
contamination and the insertion of missing values (unless <code>SAE=TRUE</code>),
are then performed on every domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function to be applied in each simulation run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>runSimulation</code>, additional arguments to be passed
to <code>fun</code>.  For <code>runSim</code>, arguments to be passed to
<code>runSimulation</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAE</code></td>
<td>
<p>a logical indicating whether small area estimation will be used in
the simulation experiment.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Statistical simulation is embarrassingly parallel, hence computational
performance can be increased by parallel computing.  Since version 0.5.0,
parallel computing in <code>simFrame</code> is implemented using the package
<code>parallel</code>, which is part of the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> base distribution since version
2.14.0 and builds upon work done for the contributed packages
<code>multicore</code> and <code>snow</code>.  Note that all objects and packages
required for the computations (including <code>simFrame</code>) need to be made
available on every worker process unless the worker processes are created by
forking (see <code>makeCluster</code>).
</p>
<p>In order to prevent problems with random numbers and to ensure
reproducibility, random number streams should be used.  With
<code>parallel</code>, random number streams can be created via the
function <code>clusterSetRNGStream()</code>.
</p>
<p>There are some requirements for slot <code>fun</code> of the control object
<code>control</code>.  The function must return a numeric vector, or a list with
the two components <code>values</code> (a numeric vector) and <code>add</code>
(additional results of any class, e.g., statistical models).  Note that the
latter is computationally slightly more expensive.  A <code>data.frame</code> is
passed to <code>fun</code> in every simulation run.  The corresponding argument
must be called <code>x</code>.  If comparisons with the original data need to be
made, e.g., for evaluating the quality of imputation methods, the function
should have an argument called <code>orig</code>.  If different domains are used
in the simulation, the indices of the current domain can be passed to the
function via an argument called <code>domain</code>.
</p>
<p>For small area estimation, the following points have to be kept in mind.  The
slot <code>design</code> of <code>control</code> for splitting the data must be supplied
and the slot <code>SAE</code> must be set to <code>TRUE</code>.  However, the data are
not actually split into the specified domains.  Instead, the whole data set
(sample) is passed to <code>fun</code>.  Also contamination and missing values are
added to the whole data (sample).  Last, but not least, the function must
have a <code>domain</code> argument so that the current domain can be extracted
from the whole data (sample).
</p>
<p>In every simulation run, <code>fun</code> is evaluated using <code>try</code>.  Hence
no results are lost if computations fail in any of the simulation runs.
</p>


<h3>Value</h3>

<p>An object of class <code>"SimResults"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>cl = "ANY", x = "ANY", setup = "ANY", nrep = "ANY",
    control = "missing"</code></dt>
<dd>
<p>convenience wrapper that allows the slots of
<code>control</code> to be supplied as arguments</p>
</dd>
<dt><code>cl = "ANY", x = "data.frame", setup = "missing", nrep = "numeric",
    control = "SimControl"</code></dt>
<dd>
<p>run a simulation experiment based on real data
with repetitions on a cluster.</p>
</dd>
<dt><code>cl = "ANY", x = "data.frame", setup = "SampleSetup",
    nrep = "missing", control = "SimControl"</code></dt>
<dd>
<p>run a design-based simulation
experiment with previously set up samples on a cluster.</p>
</dd>
<dt><code>cl = "ANY", x = "data.frame", setup = "VirtualSampleControl",
    nrep = "missing", control = "SimControl"</code></dt>
<dd>
<p>run a design-based simulation
experiment on a cluster.</p>
</dd>
<dt><code>cl = "ANY", x = "VirtualDataControl", setup = "missing",
    nrep = "numeric", control = "SimControl"</code></dt>
<dd>
<p>run a model-based simulation
experiment with repetitions on a cluster.</p>
</dd>
<dt><code>cl = "ANY", x = "VirtualDataControl",
    setup = "VirtualSampleControl", nrep = "numeric",
    control = "SimControl"</code></dt>
<dd>
<p>run a simulation experiment using a mixed
simulation design with repetitions on a cluster.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Andreas Alfons</p>


<h3>References</h3>

<p>Alfons, A., Templ, M. and Filzmoser, P. (2010) An Object-Oriented Framework for
Statistical Simulation: The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> Package <span class="pkg">simFrame</span>. <em>Journal of
Statistical Software</em>, <b>37</b>(3), 1–36. doi: <a href="https://doi.org/10.18637/jss.v037.i03">10.18637/jss.v037.i03</a>.
</p>
<p>L'Ecuyer, P., Simard, R., Chen E and Kelton, W. (2002) An Object-Oriented
Random-Number Package with Many Long Streams and Substreams. <em>Operations
Research</em>, <b>50</b>(6), 1073–1075.
</p>
<p>Rossini, A., Tierney L. and Li, N. (2007) Simple Parallel Statistical Computing
in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>. <em>Journal of Computational and Graphical Statistics</em>, <b>16</b>(2),
399–420.
</p>
<p>Tierney, L., Rossini, A. and Li, N. (2009) <code>snow</code>: A Parallel Computing
Framework for the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> System. <em>International Journal of Parallel
Programming</em>, <b>37</b>(1), 78–90.
</p>


<h3>See Also</h3>

<p><code>makeCluster</code>,
<code>clusterSetRNGStream</code>,
<code>runSimulation</code>, <code>"SimControl"</code>,
<code>"SimResults"</code>, <code>simBwplot</code>,
<code>simDensityplot</code>, <code>simXyplot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## these examples requires at least a dual core processor


## design-based simulation
data(eusilcP)  #load data

# start cluster
cl &lt;- makeCluster(2, type = "PSOCK")

# load package and data on workers
clusterEvalQ(cl, {
    library(simFrame)
    data(eusilcP)
})

# set up random number stream
clusterSetRNGStream(cl, iseed = "12345")

# control objects for sampling and contamination
sc &lt;- SampleControl(size = 500, k = 50)
cc &lt;- DARContControl(target = "eqIncome", epsilon = 0.02,
    fun = function(x) x * 25)

# function for simulation runs
sim &lt;- function(x) {
    c(mean = mean(x$eqIncome), trimmed = mean(x$eqIncome, 0.02))
}

# export objects to workers
clusterExport(cl, c("sc", "cc", "sim"))

# run simulation on cluster
results &lt;- clusterRunSimulation(cl, eusilcP,
    sc, contControl = cc, fun = sim)

# stop cluster
stopCluster(cl)

# explore results
head(results)
aggregate(results)
tv &lt;- mean(eusilcP$eqIncome)  # true population mean
plot(results, true = tv)



## model-based simulation

# start cluster
cl &lt;- makeCluster(2, type = "PSOCK")

# load package on workers
clusterEvalQ(cl, library(simFrame))

# set up random number stream
clusterSetRNGStream(cl, iseed = "12345")

# function for generating data
rgnorm &lt;- function(n, means) {
    group &lt;- sample(1:2, n, replace=TRUE)
    data.frame(group=group, value=rnorm(n) + means[group])
}

# control objects for data generation and contamination
means &lt;- c(0, 0.25)
dc &lt;- DataControl(size = 500, distribution = rgnorm,
    dots = list(means = means))
cc &lt;- DCARContControl(target = "value",
    epsilon = 0.02, dots = list(mean = 15))

# function for simulation runs
sim &lt;- function(x) {
    c(mean = mean(x$value),
        trimmed = mean(x$value, trim = 0.02),
        median = median(x$value))
}

# export objects to workers
clusterExport(cl, c("rgnorm", "means", "dc", "cc", "sim"))

# run simulation on cluster
results &lt;- clusterRunSimulation(cl, dc, nrep = 100,
    contControl = cc, design = "group", fun = sim)

# stop cluster
stopCluster(cl)

# explore results
head(results)
aggregate(results)
plot(results, true = means)

## End(Not run)
</code></pre>


</div>