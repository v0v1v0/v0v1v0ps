<div class="container">

<table style="width: 100%;"><tr>
<td>getSmoothContour</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Smooth contour from anchors</h2>

<h3>Description</h3>

<p>Returns a smooth contour based on an arbitrary number of anchors. Used by
<code>soundgen</code> for generating intonation contour, mouth opening, etc.
This function is mostly intended to be used internally by soundgen, more
precisely to construct (upsample) smooth curves from a number of anchors. For
general upsampling or downsampling of audio, use <code>resample</code>. Note
that pitch contours are treated as a special case: values are log-transformed
prior to smoothing, so that with 2 anchors we get a linear transition on a
log scale (as if we were operating with musical notes rather than frequencies
in Hz). Pitch plots have two Y axes: one showing Hz and the other showing
musical notation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getSmoothContour(
  anchors = data.frame(time = c(0, 1), value = c(0, 1)),
  len = NULL,
  thisIsPitch = FALSE,
  normalizeTime = TRUE,
  interpol = c("approx", "spline", "loess")[3],
  loessSpan = NULL,
  discontThres = 0.05,
  jumpThres = 0.01,
  valueFloor = NULL,
  valueCeiling = NULL,
  plot = FALSE,
  xlim = NULL,
  ylim = NULL,
  xlab = "Time, ms",
  ylab = ifelse(thisIsPitch, "Frequency, Hz", "Amplitude"),
  main = ifelse(thisIsPitch, "Pitch contour", ""),
  samplingRate = 16000,
  voiced = NULL,
  contourLabel = NULL,
  NA_to_zero = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>anchors</code></td>
<td>
<p>a numeric vector of values or a list/dataframe with one column
(value) or two columns (time and value). <code>achors$time</code> can be in ms
(with len=NULL) or in arbitrary units, eg 0 to 1 (with duration determined
by len, which must then be provided in ms). So anchors$time is assumed to
be in ms if len=NULL and relative if len is specified. <code>anchors$value</code>
can be on any scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>the required length of the output contour. If NULL, it will be
calculated based on the maximum time value (in ms) and <code>samplingRate</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thisIsPitch</code></td>
<td>
<p>(boolean) is this a pitch contour? If true, log-transforms
before smoothing and plots in both Hz and musical notation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalizeTime</code></td>
<td>
<p>if TRUE, normalizes anchors$time values to range from 0 to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpol</code></td>
<td>
<p>method of interpolation between anchors: "approx" = linear
with <code>approx</code>, "spline" = cubic splines with
<code>spline</code>, "loess" = local polynomial regression with
<code>loess</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loessSpan</code></td>
<td>
<p>controls the amount of smoothing when interpolating between
anchors with <code>loess</code>, so only has an effect if interpol
= 'loess' (1 = strong, 0.5 = weak smoothing)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discontThres</code></td>
<td>
<p>if two anchors are closer in time than
<code>discontThres</code> (on a 0-1 scale, ie specified as proportion of total
length), the contour is broken into segments with a linear transition
between these segments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jumpThres</code></td>
<td>
<p>if anchors are closer than <code>jumpThres</code>, a new section
starts with no transition at all (e.g. for adding pitch jumps)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valueFloor, valueCeiling</code></td>
<td>
<p>lowser/upper bounds for the contour</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>(boolean) produce a plot?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim, ylim, xlab, ylab, main</code></td>
<td>
<p>plotting options</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingRate</code></td>
<td>
<p>sampling rate used to convert time values to points (Hz)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>voiced, contourLabel</code></td>
<td>
<p>graphical pars for plotting breathing contours
(see examples below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NA_to_zero</code></td>
<td>
<p>if TRUE, all NAs are replaced with zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other plotting options passed to <code>plot()</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a numeric vector of length <code>len</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># long format: anchors are a dataframe
a = getSmoothContour(anchors = data.frame(
  time = c(50, 137, 300), value = c(0.03, 0.78, 0.5)),
  normalizeTime = FALSE,
  voiced = 200, valueFloor = 0, plot = TRUE, main = '',
  samplingRate = 16000) # breathing

# short format: anchors are a vector (equal time steps assumed)
a = getSmoothContour(anchors = c(350, 800, 600),
  len = 5500, thisIsPitch = TRUE, plot = TRUE,
  samplingRate = 3500) # pitch

# a single anchor gives constant value
a = getSmoothContour(anchors = 800,
  len = 500, thisIsPitch = TRUE, plot = TRUE, samplingRate = 500)

# two pitch anchors give loglinear F0 change
a = getSmoothContour(anchors = c(220, 440),
  len = 500, thisIsPitch = TRUE, plot = TRUE, samplingRate = 500)

## Two closely spaced anchors produce a pitch jump
# one loess for the entire contour
a1 = getSmoothContour(anchors = list(time = c(0, .15, .2, .7, 1),
    value = c(360, 116, 550, 700, 610)), len = 500, thisIsPitch = TRUE,
    plot = TRUE, samplingRate = 500)
# two segments with a linear transition
a2 = getSmoothContour(anchors = list(time = c(0, .15, .17, .7, 1),
    value = c(360, 116, 550, 700, 610)), len = 500, thisIsPitch = TRUE,
    plot = TRUE, samplingRate = 500)
# two segments with an abrupt jump
a3 = getSmoothContour(anchors = list(time = c(0, .15, .155, .7, 1),
    value = c(360, 116, 550, 700, 610)), len = 500, thisIsPitch = TRUE,
    plot = TRUE, samplingRate = 500)
# compare:
plot(a2)
plot(a3)  # NB: the segment before the jump is upsampled to compensate

## Control the amount of smoothing
getSmoothContour(c(1, 3, 9, 10, 9, 9, 2), len = 100, plot = TRUE,
  loessSpan = NULL)  # default amount of smoothing (depends on dur)
getSmoothContour(c(1, 3, 9, 10, 9, 9, 2), len = 100, plot = TRUE,
  loessSpan = .85)   # more smoothing than default
getSmoothContour(c(1, 3, 9, 10, 9, 9, 2), len = 100, plot = TRUE,
  loessSpan = .5)    # less smoothing
getSmoothContour(c(1, 3, 9, 10, 9, 9, 2), len = 100, plot = TRUE,
  interpol = 'approx')  # linear interpolation (no smoothing)

## Upsample preserving leading and trailing NAs
anchors = data.frame(time =  c(1,  4,  5,  7,  10, 20, 23, 25, 30),
                     value = c(NA, NA, 10, 15, 12, NA, 17, 15, NA))
plot(anchors, type = 'b')
anchors_ups = getSmoothContour(
  anchors, len = 200,
  interpol = 'approx',  # only approx can propagate NAs
  NA_to_zero = FALSE,   # preserve NAs
  discontThres = 0)     # don't break into sub-contours
plot(anchors_ups, type = 'b')
</code></pre>


</div>