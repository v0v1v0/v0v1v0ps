<div class="container">

<table style="width: 100%;"><tr>
<td>infiniteSum_batches</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximates the sum of a positive discrete infinite series with a single
maximum using the batches algorithm</h2>

<h3>Description</h3>

<p>A simple method to perform the summation. It adds the values in batches and
stops when the accumulated batch is smaller than the desired threshold. There
is an implementation purely in <code>R</code> and one in <code>C</code>. The one in R is
usually slightly faster due to vectorized computing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">infiniteSum_batches(
  logFunction,
  parameters = numeric(),
  batch_size = 40,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0
)

infiniteSum_batches_C(
  logFunction,
  parameters = numeric(),
  batch_size = 40,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>logFunction</code></td>
<td>
<p>The function that returns the series value
a<sub>n</sub> in
the log scale. Can either be an <code>R</code> function or a string indicating one
of the pre-coded functions. See <code>precompiled()</code> for a list of
available functions. If defined in <code>R</code>, the function's definition must
have two arguments. The first argument must be the integer argument
equivalent to <code class="reqn">n</code> in a<sub>n</sub> and
the second must be a vector of numeric parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A numeric vector with parameters used in logFunction.
Vectorized summation over various parameter values sets is not implemented.
Use <code>apply()</code> or their variants to achieve this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p>The batch size at which point convergence checking is
performed. The algorithm perform at least twice this number of function
evaluations. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>The desired error margin for the approximation. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>The maximum number of iterations for the approximation. In
most cases, this number will not be reached unless it is very small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n0</code></td>
<td>
<p>The sum will be approximated for the series starting at this value.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The series a<sub>n</sub> must pass
the ratio convergence test, meaning that the ratio
a<sub>n+1</sub>/a<sub>n</sub> must
converge to a number <code class="reqn">L &lt; 1</code> when <code class="reqn">n</code> goes to infinity.
</p>
<p>The batches algorithm consists of evaluating the function a fixed number of
times for two checkpoints. If the difference between the sum at these
checkpoints is smaller than <code>epsilon</code>, the code stops and the later
checkpoint sum is returned. Else, continue summing until the next checkpoint.
All checkpoints are <code>batch_size</code> long.
</p>
<p>This function's efficiency is reliant on the choice of <code>batch_size</code>.
If it is set too large, the algorithm overshoots the necessary
number of function evaluations too much. If it is set too small, the
algorithm will need to process too many partial summations which slows it
down. However, if they are well calibrated for the series, they can
potentially be very efficient.
</p>
<p>Since the batch sizes are known before the calculations are made,
function evaluations can be vectorized. This is why there are two functions
available. <code>infiniteSum_batches</code> does the calculations at the <code>R</code>
level, while <code>infiniteSum_batches_C</code> interfaces the low level <code>C</code>
code. However, the <code>C</code> code does not use vectorization since it isn't
available on long double precision type, and therefore the <code>R</code> level
function should be faster in most cases.
</p>
<p>Another difference is that the low level code uses double precision for the
calculations. This means that it is less prone to rounding errors. But this
also means that the two functions can sometimes require a different number
of iterations and function evaluations to reach the stop criteria. This
is shown in the examples.
</p>
<p>Another requirement in the current installment of this function is that the
series must have only a single maximum. This is the case for most discrete
probability distributions and marginalization problems. This limitation
will be addressed in the future.
</p>


<h3>Value</h3>

<p>A <code>summed-objects()</code> object.
</p>


<h3>See Also</h3>

<p><code>precompiled()</code> provides a list with precompiled functions
that can be used for the summation. <code>infiniteSum()</code> is a more
efficient algorithm.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Define some function that is known to pass the ratio test.
param = 0.1
funfun &lt;- function(k, p) return(k * log1p(-p[1]))
result &lt;- infiniteSum_batches(funfun, parameters = param)

## This series is easy to verify analytically
TrueSum = -log(param)
TrueSum - result$sum
# Notice that it required 400 function evaluations for the approximation.
result$n

# If we use the C function, it reaches a lower error, but requires more
# iterations
result_C &lt;- infiniteSum_batches_C(funfun, parameters = param)
TrueSum - result_C$sum
result_C$n

## A common problem is finding the normalizing constant for the
## Conway-Maxwell-Poisson distribution. It has already been included
## in the precompiled list of functions.
comp_params = c(lambda = 5, nu = 3)
result &lt;- infiniteSum_batches("COMP", comp_params)
# With a specifically chosen argument value, the summation can be done with
# fewer iterations. But it is usually hard to know the ideal choice for
# applications beforehand
result$n
infiniteSum_batches("COMP", comp_params, batch_size = 11)$n
# A small batch_size ensures a small number of iterations, but slows the
# method due to multiple checking.
infiniteSum_batches("COMP", comp_params, batch_size = 2)$n
</code></pre>


</div>