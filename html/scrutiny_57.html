<div class="container">

<table style="width: 100%;"><tr>
<td>subset-superset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test for subsets, supersets, and equal sets</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>
</p>
<p>All of these functions are deprecated and will be removed in a future
version. They are a poor fit for the problem they try to solve, and they
are far out of scope for the package.
</p>


<h4>Original documentation</h4>

<p>Predicate functions that take a vector and test whether it has some
particular relation to another vector. That second vector is entered in
either of three ways –
</p>
<p><strong>Enter it directly (basic functions):</strong>
</p>
<p><code>is_subset_of()</code> tests if a vector is a subset of another vector; i.e., if
all its elements are contained in the second one. <code>is_superset_of()</code> does
the reverse: It tests if the first vector contains all elements of the
second one. <code>is_equal_set()</code> tests if both vectors have exactly the same
values.
</p>
<p><strong>Enter its values:</strong>
</p>
<p><code>is_subset_of_vals()</code>, <code>is_superset_of_vals()</code>, and <code>is_equal_set_vals()</code>
are variants that each take a single vector plus any number of other
arguments. These are treated like elements of the second vector in the
basic functions above.
</p>
<p><strong>Enter multiple vectors that jointly contain its values:</strong>
</p>
<p>Finally, <code>is_subset_of_vecs()</code>, <code>is_superset_of_vecs()</code>, and
<code>is_equal_set_vecs()</code> take one vector plus any number of other vectors and
treat their elements (!) like elements of a second vector in the basic
functions above.
</p>
<p>Each <code style="white-space: pre;">⁠is_subset*()⁠</code> function has an <code style="white-space: pre;">⁠is_proper_subset*()⁠</code> variant. These
variants also test whether the sets are unequal, so that <code>x</code> is a subset of
<code>y</code> but <code>y</code> is not a subset of <code>x</code>. The same applies to <code style="white-space: pre;">⁠is_superset*()⁠</code>
functions and their <code style="white-space: pre;">⁠is_proper_superset*()⁠</code> variants.
</p>



<h3>Usage</h3>

<pre><code class="language-R">is_subset_of(x, y)

is_superset_of(x, y)

is_equal_set(x, y)

is_proper_subset_of(x, y)

is_proper_superset_of(x, y)

is_subset_of_vals(x, ...)

is_superset_of_vals(x, ...)

is_equal_set_vals(x, ...)

is_proper_subset_of_vals(x, ...)

is_proper_superset_of_vals(x, ...)

is_subset_of_vecs(x, ...)

is_superset_of_vecs(x, ...)

is_equal_set_vecs(x, ...)

is_proper_subset_of_vecs(x, ...)

is_proper_superset_of_vecs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector. Only in the basic functions, not those with <code style="white-space: pre;">⁠*_vals()⁠</code> or
<code style="white-space: pre;">⁠*_vecs()⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In the <code style="white-space: pre;">⁠*_vals()⁠</code> functions, any number of values <code>x</code> might
contain; in the <code style="white-space: pre;">⁠*_vecs()⁠</code> functions, any number of vectors the elements of
which <code>x</code> might contain.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code style="white-space: pre;">⁠*_vals()⁠</code> variants are meant for flexible, interactive
subset/superset testing. That is, in order to test whether certain values
collectively fulfill the role of the second vector, you can just add them
to the function call.
</p>
<p>The <code style="white-space: pre;">⁠*_vecs()⁠</code> variants likewise offer flexibility, but also bridge the gap
between vectors and values contained in them.
</p>
<p>All functions simply check if values are present, regardless of how often a
value occurs. In other words, they look for types but don't count tokens.
</p>


<h3>Value</h3>

<p>A single logical value. <code>TRUE</code> if the respective test was passed,
<code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define example vectors:
ab &lt;- c("a", "b")
abc &lt;- c("a", "b", "c")
abcde &lt;- c("a", "b", "c", "d", "e")

# `is_subset_of()` tests if a vector is
# completely covered by another one:
abc %&gt;% is_subset_of(ab)
abc %&gt;% is_subset_of(abc)
abc %&gt;% is_subset_of(abcde)

# To the contrary, `is_superset_of()` tests if the
# first vector completely covers the second one:
abc %&gt;% is_superset_of(ab)
abc %&gt;% is_superset_of(abc)
abc %&gt;% is_superset_of(abcde)

# `is_equal_set()` tests both of the above --
# i.e., if both vectors have exactly the
# same values:
abc %&gt;% is_equal_set(ab)
abc %&gt;% is_equal_set(abc)
abc %&gt;% is_equal_set(abcde)

# Each of the three functions has a `*_vals()` variant
# that doesn't take a second vector like the first
# one, but any number of other arguments. These are
# jointly treated like the elements of the second
# vector in the basic functions:
abc %&gt;% is_subset_of_vals("a", "b")
abc %&gt;% is_subset_of_vals("a", "b", "c")
abc %&gt;% is_subset_of_vals("a", "b", "c", "d", "e")

# (... and likewise for supersets and equal sets.)
</code></pre>


</div>