<div class="container">

<table style="width: 100%;"><tr>
<td>SOAs2plus_regular</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>function to create SOAs of strength 2+ from regular s-level designs</h2>

<h3>Description</h3>

<p>creates an array in s^k runs with columns in s^2 levels for prime or prime power s
</p>


<h3>Usage</h3>

<pre><code class="language-R">SOAs2plus_regular(
  s,
  k,
  m = NULL,
  orth = TRUE,
  old = FALSE,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>prime or prime power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>array will have n=s^k runs; for s=2, k&gt;=4 is needed, for s&gt;2, k&gt;=3 is sufficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>optional integer: number of columns requested; if <code>NULL</code>,
the maximum possible number of columns is created, which is (s^k-1)/(s-1) - ((s-1)^k-1)/(s-2)
for s&gt;2 and s^k-s^k1 - s^(k-k1) + 2, with k1=floor(k/2), for s=2; specifying a
smaller m is beneficial not only for run time but also for possibly achieving a
column-orthogonal array (see Details section)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orth</code></td>
<td>
<p>logical: if FALSE, suppresses attempts for orthogonal columns and selects the first permissible column for each column of B (see Details section)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>old</code></td>
<td>
<p>logical, relevant for <code>orth=TRUE</code> only: if TRUE, limits possible columns for B to the columns not eligible for A (instead of the columns not used in A); should only be used for reproducing designs created by version 1.1 or earlier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize</code></td>
<td>
<p>logical: should optimization be applied? default <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmethod</code></td>
<td>
<p>method for the distance in <code>phi_p</code>, "manhattan" (default) or "euclidean"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>p for <code>phi_p</code> (the larger, the closer to maximin distance)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The construction is by He, Cheng and Tang (2018), Prop.1 (C2) / Theorem 2
for s=2 and Theorem 4 for s&gt;2. <br>
B is chosen as an OA of strength 2, if possible, which yields orthogonal
columns according to Zhou and Tang (2019). This is implemented using a matching
algorithm for bipartite graphs from package <span class="pkg">igraph</span>; the smaller m, the
more likely that orthogonality can be achieved. However, strength 2+ SOAs are
not usually advisable for m small enough that a strength 3 OA exists.<br>
Optimization according to Weng has been added (separate level permutations
in columns of A and B, <code>noptim.rounds</code> times). Limited tests suggest
that a single round (<code>noptim.rounds=1</code>) often does a very good job
(e.g. for s=2 and k=4), and
further rounds do not yield too much improvement; there are also cases
(e.g. s=5 with k=3), for which the unoptimized array has a better phi_p than
what can be achieved by most optimization attempts from a random start.
</p>
<p>The search for orthogonal columns can take a long time for larger arrays,
even without optimization. If this is prohibitive (or not considered valuable),
<code>orth=FALSE</code> causes the function to create the matrix B for equation D=2A+B
with less computational effort.<br>
The subsequent optimization, if not switched off,
is of the same complexity, regardless of the value for <code>orth</code>. Its
duration heavily depends on the number of optimization steps that are needed
before the algorithm stops. This has not been systematically investigated;
cases for which the total run time with optimization
is shorter for <code>orth=TRUE</code> than for <code>orth=FALSE</code> have been observed.
</p>
<p>With package version 1.2, the creation of SOAs has changed: Up to version 1.1,
the columns of B were chosen only from those columns that were <em>not eligible</em> for A,
whereas the new version chooses them from those columns that are <em>not used</em> for A.
This increases the chance to achieve geometrically orthogonal columns.<br>
Users who want to reproduce a design from an earlier version
can use argument <code>old</code>.
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code>attributes</code>, or individual attributes can be accessed using function <code>attr</code>. These are the attributes:
</p>

<dl>
<dt>type</dt>
<dd>
<p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt>
<dd>
<p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt>
<dd>
<p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt>
<dd>
<p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt>
<dd>
<p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt>
<dd>
<p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt>
<dd>
<p>the call that created the object</p>
</dd>
</dl>
<h3>Note</h3>

<p>Strength 2+ SOAs can accommodate a large number of factors with
reasonable stratified balance behavior. Note that their use is not usually
advisable for m small enough that a strength 3 OA with s^2 level factors exists.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code>SOAs-package</code>.
</p>
<p>Groemping (2023a)
He, Cheng and Tang (2018)<br>
Weng (2014)<br>
Zhou and Tang (2019)
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## unoptimized OSOA with 8 16-level columns in 64 runs
## (maximum possible number of columns)
plan64 &lt;- SOAs2plus_regular(4, 3, optimize=FALSE)
ocheck(plan64)   ## the array has orthogonal columns

## optimized SOA with 20 9-level columns in 81 runs
## (up to 25 columns are possible)
plan &lt;- SOAs2plus_regular(3, 4, 20)
## many column pairs have only 27 level pairs covered
count_npairs(plan)
## an OA would exist for 10 9-level factors (DoE.base::L81.9.10)
## it would cover all pairs
## (SOAs are not for situations for which pair coverage
## is of primary interest)

</code></pre>


</div>