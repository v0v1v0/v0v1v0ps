<div class="container">

<table style="width: 100%;"><tr>
<td>GetMaybeRel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find Putative Relatives</h2>

<h3>Description</h3>

<p>Identify pairs of individuals likely to be related, but not
assigned as such in the provided pedigree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GetMaybeRel(
  GenoM = NULL,
  SeqList = NULL,
  Pedigree = NULL,
  LifeHistData = NULL,
  AgePrior = NULL,
  Module = "par",
  Complex = "full",
  Herm = "no",
  Err = 1e-04,
  ErrFlavour = "version2.9",
  Tassign = 0.5,
  Tfilter = -2,
  MaxPairs = 7 * nrow(GenoM),
  quiet = FALSE,
  ParSib = NULL,
  MaxMismatch = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>GenoM</code></td>
<td>
<p>numeric matrix with genotype data: One row per individual,
one column per SNP, coded as 0, 1, 2, missing values as a negative number
or NA. You can reformat data with <code>GenoConvert</code>, or use other
packages to get it into a genlight object and then use <code>as.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SeqList</code></td>
<td>
<p>list with output from <code>sequoia</code>.
<code>SeqList$Pedigree</code> is used if present, and <code>SeqList$PedigreePar</code>
otherwise, and overrides the input parameter <code>Pedigree</code>. If 'Specs' is
present, its elements override all input parameters with the same name. The
list elements  ‘LifeHist’, ‘AgePriors’, and ‘ErrM’ are also used if
present, and similarly override the corresponding input parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire in columns 1-3. May include
non-genotyped individuals, which will be treated as dummy individuals. When
provided, all likelihoods (and thus all maybe-relatives) are conditional on
this pedigree. Note: <code>SeqList$Pedigree</code> or <code>SeqList$PedigreePar</code> take
precedent (for this function only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt>
<dd>
<p>max. 30 characters long</p>
</dd>
<dt>Sex</dt>
<dd>
<p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt>
<dd>
<p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt>
<dd>
<p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt>
<dd>
<p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt>
<dd>
<p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>
<p>"Birth year" may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in ‘GenoM’, nor do all genotyped individuals
need to be included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AgePrior</code></td>
<td>
<p>Agepriors matrix, as generated by <code>MakeAgePrior</code>
and included in the <code>sequoia</code> output. Affects which
relationships are considered possible (only those where <code class="reqn">P(A|R) / P(A)
&gt; 0</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Module</code></td>
<td>
<p>type of relatives to check for. One of
</p>

<dl>
<dt>par</dt>
<dd>
<p>parent - offspring pairs</p>
</dd>
<dt>ped</dt>
<dd>
<p>all first and second degree relatives</p>
</dd>
</dl>
<p>When 'par', all pairs are returned that are more likely parent-offspring
than unrelated, potentially including pairs that are even more likely to
be otherwise related.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Complex</code></td>
<td>
<p>Breeding system complexity. Either "full" (default), "simp"
(simplified, no explicit consideration of inbred relationships), "mono"
(monogamous).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Herm</code></td>
<td>
<p>Hermaphrodites, either "no", "A" (distinguish between dam and
sire role, default if at least 1 individual with sex=4), or "B" (no
distinction between dam and sire role). Both of the latter deal with
selfing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or a length 3
vector with P(hom|hom), P(het|hom), P(hom|het), or a 3x3 matrix. See
details below. The error rate is presumed constant across SNPs, and
missingness is presumed random with respect to actual genotype. Using
<code>Err</code> &gt;5% is not recommended, and <code>Err</code> &gt;10% strongly
discouraged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> (single number) as input,
and returns a length 3 vector or 3x3 matrix, or choose from inbuilt options
'version2.9', 'version2.0', 'version1.3', or 'version1.1', referring to the
sequoia version in which they were the default. Ignored if <code>Err</code> is a
vector or matrix. See <code>ErrToM</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tassign</code></td>
<td>
<p>minimum LLR required for acceptance of proposed relationship,
relative to next most likely relationship. Higher values result in more
conservative assignments. Must be zero or positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tfilter</code></td>
<td>
<p>threshold log10-likelihood ratio (LLR) between a proposed
relationship versus unrelated, to select candidate relatives. Typically a
negative value, related to the fact that unconditional likelihoods are
calculated during the filtering steps. More negative values may decrease
non-assignment, but will increase computational time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxPairs</code></td>
<td>
<p>the maximum number of putative pairs to return.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical, suppress messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ParSib</code></td>
<td>
<p><strong>DEPRECATED, use <code>Module</code></strong> either 'par' to check
for putative parent-offspring pairs only, or 'sib' to check for all types
of first and second degree relatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxMismatch</code></td>
<td>
<p><strong>DEPRECATED AND IGNORED</strong>. Now calculated
automatically using <code>CalcMaxMismatch</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>Module="par"</code>, the age difference of the putative pair is
temporarily set to NA so that genetic parent-offspring pairs declared to be
born in the same year may be discovered. When <code>Module="ped"</code>, only
relationships possible given the age difference, if known from the
LifeHistData, are considered.
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr style="vertical-align: top;">
<td><code>MaybePar</code></td>
<td>
<p>A dataframe with non-assigned likely parent-offspring pairs,
with columns:
</p>

<ul>
<li>
<p> ID1
</p>
</li>
<li>
<p> ID2
</p>
</li>
<li>
<p> TopRel: the most likely relationship, using abbreviations listed
below
</p>
</li>
<li>
<p> LLR: Log10-Likelihood Ratio between most likely and next most
likely relationship
</p>
</li>
<li>
<p> OH: Number of loci at which the two individuals are opposite
homozygotes
</p>
</li>
<li>
<p> BirthYear1: Birth year of ID1 (copied from LifeHistData)
</p>
</li>
<li>
<p> BirthYear2
</p>
</li>
<li>
<p> AgeDif: Age difference; BirthYear1 - BirthYear2
</p>
</li>
<li>
<p> Sex1: Sex of ID1 (copied from LifeHistData)
</p>
</li>
<li>
<p> Sex2
</p>
</li>
<li>
<p> SnpdBoth: Number of loci at which the two individuals are both
successfully genotyped
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaybeRel</code></td>
<td>
<p>A dataframe with non-assigned likely pairs of relatives,
with columns identical to <code>MaybePar</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaybeTrio</code></td>
<td>
<p>A dataframe with non-assigned parent-parent-offspring
trios, with columns:
</p>

<ul>
<li>
<p> ID
</p>
</li>
<li>
<p> parent1
</p>
</li>
<li>
<p> parent2
</p>
</li>
<li>
<p> TopRel: the most likely relationship, using abbreviations listed
below
</p>
</li>
<li>
<p> LLRparent1: Log10-Likelihood Ratio between parent1 being a
parent of ID vs the next most likely relationship between the pair,
ignoring parent2
</p>
</li>
<li>
<p> LLRparent2: as LLRparent1
</p>
</li>
<li>
<p> LLRpair: LLR for the parental pair, versus the next most likely
configuration between the three individuals (with one or neither
parent assigned)
</p>
</li>
<li>
<p> OHparent1: Number of loci at which ID and parent1 are opposite
homozygotes
</p>
</li>
<li>
<p> OHparent2: as OHparent1
</p>
</li>
<li>
<p> MEpair: Number of Mendelian errors between the offspring and the
parent pair, includes OH as well as e.g. parents being opposing
homozygotes, but the offspring not being a heterozygote. The offspring
being OH with both parents is counted as 2 errors.
</p>
</li>
<li>
<p> SNPd.id.parent1: Number of loci at which ID and parent1 are both
successfully genotyped
</p>
</li>
<li>
<p> SNPd.id.parent2: as SNPd.id.parent1
</p>
</li>
</ul>
</td>
</tr>
</table>
<p>The following categories are used in column 'TopRel', indicating the most
likely relationship category:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>PO</code></td>
<td>
<p>Parent-Offspring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FS</code></td>
<td>
<p>Full Siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HS</code></td>
<td>
<p>Half Siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GP</code></td>
<td>
<p>GrandParent - grand-offspring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FA</code></td>
<td>
<p>Full Avuncular (aunt/uncle)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>2nd</code></td>
<td>
<p>2nd degree relatives, not enough information to distinguish
between HS,GP and FA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>Unclear, but probably 1st, 2nd or 3rd degree relatives</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>sequoia</code> to identify likely pairs of duplicate
genotypes and for pedigree reconstruction; <code>GetRelM</code> to
identify all pairs of relatives in a pedigree; <code>CalcPairLL</code> for
the likelihoods underlying the LLR.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# without conditioning on pedigree
MaybeRel_griffin &lt;- GetMaybeRel(GenoM=Geno_griffin, Err=0.001, Module='par')

## End(Not run)
names(MaybeRel_griffin)

# conditioning on pedigree
MaybePO &lt;- GetMaybeRel(GenoM = Geno_griffin, SeqList = SeqOUT_griffin,
                      Module = 'par')
head(MaybePO$MaybePar)

# instead of providing the entire SeqList, one may specify the relevant
# elements separately
Maybe &lt;- GetMaybeRel(GenoM = Geno_griffin,
                     Pedigree = SeqOUT_griffin$PedigreePar,
                     LifeHistData = LH_griffin,
                     Err=0.0001, Complex = "full",
                     Module = "ped")
head(Maybe$MaybeRel)

# visualise results, turn dataframe into matrix first:
MaybeM &lt;- GetRelM(Pairs = Maybe$MaybeRel)
PlotRelPairs(MaybeM)
# or combine with pedigree (note suffix '?')
RelM &lt;- GetRelM(Pedigree =SeqOUT_griffin$PedigreePar, Pairs = Maybe$MaybeRel)
PlotRelPairs(RelM)

</code></pre>


</div>