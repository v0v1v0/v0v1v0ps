<div class="container">

<table style="width: 100%;"><tr>
<td>ContextualMenu</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ContextualMenu</h2>

<h3>Description</h3>

<p>ContextualMenus are lists of commands that are based on the context of selection, mouse hover or keyboard focus. They are one of the most effective and highly used command surfaces, and can be used in a variety of places.
</p>
<p>There are variants that originate from a command bar, or from cursor or focus. Those that come from CommandBars use a beak that is horizontally centered on the button. Ones that come from right click and menu button do not have a beak, but appear to the right and below the cursor. ContextualMenus can have submenus from commands, show selection checks, and icons.
</p>
<p>Organize commands in groups divided by rules. This helps users remember command locations, or find less used commands based on proximity to others. One should also group sets of mutually exclusive or multiple selectable options. Use icons sparingly, for high value commands, and don’t mix icons with selection checks, as it makes parsing commands difficult. Avoid submenus of submenus as they can be difficult to invoke or remember.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/ContextualMenu">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ContextualMenu(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr></table>
<h3>Details</h3>


<ul>
<li> <p><b> className </b> <code>string</code> <br> Additional css class to apply to the ContextualMenuItem
</p>
</li>
<li> <p><b> classNames </b> <code>IMenuItemClassNames</code> <br> Classnames for different aspects of a menu item
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;IContextualMenuRenderItem&gt;⁠</code> <br> Optional callback to access the IContextualMenuRenderItem interface. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> dismissMenu </b> <code style="white-space: pre;">⁠(ev?: any, dismissAll?: boolean) =&gt; void⁠</code> <br> This prop will get set by ContextualMenu and can be called to close the menu this item belongs to. If dismissAll is true, all menus will be closed.
</p>
</li>
<li> <p><b> dismissSubMenu </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> This prop will get set by ContextualMenu and can be called to close this item's subMenu, if present.
</p>
</li>
<li> <p><b> getSubmenuTarget </b> <code style="white-space: pre;">⁠() =&gt; HTMLElement | undefined⁠</code> <br> This prop will get set by the wrapping component and will return the element that wraps this ContextualMenuItem. Used for openSubMenu.
</p>
</li>
<li> <p><b> hasIcons </b> <code>boolean | undefined</code> <br> If this item has icons
</p>
</li>
<li> <p><b> index </b> <code>number</code> <br> Index of the item
</p>
</li>
<li> <p><b> item </b> <code>IContextualMenuItem</code> <br> The item to display
</p>
</li>
<li> <p><b> onCheckmarkClick </b> <code style="white-space: pre;">⁠(item: IContextualMenuItem, ev: React.MouseEvent&lt;HTMLElement&gt;) =&gt; void⁠</code> <br> Click handler for the checkmark
</p>
</li>
<li> <p><b> openSubMenu </b> <code style="white-space: pre;">⁠(item: any, target: HTMLElement) =&gt; void⁠</code> <br> This prop will get set by ContextualMenu and can be called to open this item's subMenu, if present.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;IContextualMenuItemStyleProps, IContextualMenuItemStyles&gt;⁠</code> <br> Call to provide customized styling that will layer on top of the variant rules.
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme provided by High-Order Component.
</p>
</li>
<li> <p><b> focusableElementIndex </b> <code>number</code> <br></p>
</li>
<li> <p><b> hasCheckmarks </b> <code>boolean</code> <br></p>
</li>
<li> <p><b> hasIcons </b> <code>boolean</code> <br></p>
</li>
<li> <p><b> index </b> <code>number</code> <br></p>
</li>
<li> <p><b> totalItemCount </b> <code>number</code> <br></p>
</li>
<li> <p><b> defaultMenuItemRenderer </b> <code style="white-space: pre;">⁠(item: IContextualMenuItemRenderProps) =&gt; React.ReactNode⁠</code> <br></p>
</li>
<li> <p><b> hasCheckmarks </b> <code>boolean</code> <br></p>
</li>
<li> <p><b> hasIcons </b> <code>boolean</code> <br></p>
</li>
<li> <p><b> items </b> <code>IContextualMenuItem[]</code> <br></p>
</li>
<li> <p><b> role </b> <code>string</code> <br></p>
</li>
<li> <p><b> totalItemCount </b> <code>number</code> <br></p>
</li>
<li> <p><b> alignTargetEdge </b> <code>boolean</code> <br> If true the positioning logic will prefer to flip edges rather than to nudge the rectangle to fit within bounds, thus making sure the element aligns perfectly with target's alignment edge
</p>
</li>
<li> <p><b> ariaLabel </b> <code>string</code> <br> Accessible label for the ContextualMenu's root element (inside the callout).
</p>
</li>
<li> <p><b> beakWidth </b> <code>number</code> <br> The width of the beak.
</p>
</li>
<li> <p><b> bounds </b> <code style="white-space: pre;">⁠IRectangle | ((target?: Target, targetWindow?: Window) =&gt; IRectangle | undefined)⁠</code> <br> The bounding rectangle (or callback that returns a rectangle) which the contextual menu can appear in.
</p>
</li>
<li> <p><b> calloutProps </b> <code>ICalloutProps</code> <br> Additional custom props for the Callout.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> Additional CSS class to apply to the ContextualMenu.
</p>
</li>
<li> <p><b> componentRef </b> <code style="white-space: pre;">⁠IRefObject&lt;IContextualMenu&gt;⁠</code> <br> Optional callback to access the IContextualMenu interface. Use this instead of ref for accessing the public methods and properties of the component.
</p>
</li>
<li> <p><b> contextualMenuItemAs </b> <code style="white-space: pre;">⁠React.ComponentClass&lt;IContextualMenuItemProps&gt; | React.FunctionComponent&lt;IContextualMenuItemProps&gt;⁠</code> <br> Custom component to use for rendering individual menu items.
</p>
</li>
<li> <p><b> coverTarget </b> <code>boolean</code> <br> If true, the menu will be positioned to cover the target. If false, it will be positioned next to the target.
</p>
</li>
<li> <p><b> delayUpdateFocusOnHover </b> <code>boolean</code> <br> If true, the contextual menu will not be updated until focus enters the menu via other means. This will only result in different behavior when <code>shouldFocusOnMount = false</code>.
</p>
</li>
<li> <p><b> directionalHint </b> <code>DirectionalHint</code> <br> How the menu should be positioned
</p>
</li>
<li> <p><b> directionalHintFixed </b> <code>boolean</code> <br> If true the position will not change sides in an attempt to fit the ContextualMenu within bounds. It will still attempt to align it to whatever bounds are given.
</p>
</li>
<li> <p><b> directionalHintForRTL </b> <code>DirectionalHint</code> <br> How the menu should be positioned in RTL layouts. If not specified, a mirror of <code>directionalHint</code> will be used.
</p>
</li>
<li> <p><b> doNotLayer </b> <code>boolean</code> <br> If true do not render on a new layer. If false render on a new layer.
</p>
</li>
<li> <p><b> focusZoneProps </b> <code>IFocusZoneProps</code> <br> Props to pass down to the FocusZone. NOTE: the default FocusZoneDirection will be used unless a direction is specified in the focusZoneProps (even if other focusZoneProps are defined)
</p>
</li>
<li> <p><b> gapSpace </b> <code>number</code> <br> The gap between the ContextualMenu and the target
</p>
</li>
<li> <p><b> getMenuClassNames </b> <code style="white-space: pre;">⁠(theme: ITheme, className?: string) =&gt; IContextualMenuClassNames⁠</code> <br> Method to provide the classnames to style the contextual menu.
</p>
</li>
<li> <p><b> hidden </b> <code>boolean</code> <br> If true, renders the ContextualMenu in a hidden state. Use this flag, rather than rendering a ContextualMenu conditionally based on visibility, to improve rendering performance when it becomes visible. Note: When ContextualMenu is hidden its content will not be rendered. It will only render once the ContextualMenu is visible.
</p>
</li>
<li> <p><b> id </b> <code>string</code> <br> ID for the ContextualMenu's root element (inside the callout). Should be used for <code>aria-owns</code> and other such uses, rather than direct reference for programmatic purposes.
</p>
</li>
<li> <p><b> isBeakVisible </b> <code>boolean</code> <br> If true then the beak is visible. If false it will not be shown.
</p>
</li>
<li> <p><b> isSubMenu </b> <code>boolean</code> <br> Whether this menu is a submenu of another menu.
</p>
</li>
<li> <p><b> items </b> <code>IContextualMenuItem[]</code> <br> Menu items to display.
</p>
</li>
<li> <p><b> labelElementId </b> <code>string</code> <br> Used as <code>aria-labelledby</code> for the menu element inside the callout.
</p>
</li>
<li> <p><b> onDismiss </b> <code style="white-space: pre;">⁠(ev?: React.MouseEvent | React.KeyboardEvent, dismissAll?: boolean) =&gt; void⁠</code> <br> Callback when the ContextualMenu tries to close. If <code>dismissAll</code> is true then all submenus will be dismissed.
</p>
</li>
<li> <p><b> onItemClick </b> <code style="white-space: pre;">⁠(ev?: React.MouseEvent&lt;HTMLElement&gt; | React.KeyboardEvent&lt;HTMLElement&gt;, item?: IContextualMenuItem) =&gt; boolean | void⁠</code> <br> Click handler which is invoked if <code>onClick</code> is not passed for individual contextual menu item. Returning true will dismiss the menu even if <code>ev.preventDefault()</code> was called.
</p>
</li>
<li> <p><b> onMenuDismissed </b> <code style="white-space: pre;">⁠(contextualMenu?: IContextualMenuProps) =&gt; void⁠</code> <br> Callback for when the menu is being closed (removing from the DOM).
</p>
</li>
<li> <p><b> onMenuOpened </b> <code style="white-space: pre;">⁠(contextualMenu?: IContextualMenuProps) =&gt; void⁠</code> <br> Callback for when the menu has been opened.
</p>
</li>
<li> <p><b> onRenderMenuList </b> <code style="white-space: pre;">⁠IRenderFunction&lt;IContextualMenuListProps&gt;⁠</code> <br> Method to override the render of the list of menu items.
</p>
</li>
<li> <p><b> onRenderSubMenu </b> <code style="white-space: pre;">⁠IRenderFunction&lt;IContextualMenuProps&gt;⁠</code> <br> Custom render function for a submenu.
</p>
</li>
<li> <p><b> onRestoreFocus </b> <code style="white-space: pre;">⁠(options: { originalElement?: HTMLElement | Window; containsFocus: boolean; }) =&gt; void⁠</code> <br> Called when the component is unmounting, and focus needs to be restored. Argument passed down contains two variables, the element that the underlying popup believes focus should go to and whether or not the popup currently contains focus. If this prop is provided, focus will not be restored automatically, you'll need to call originalElement.focus()
</p>
</li>
<li> <p><b> shouldFocusOnContainer </b> <code>boolean</code> <br> Whether to focus on the contextual menu container (as opposed to the first menu item).
</p>
</li>
<li> <p><b> shouldFocusOnMount </b> <code>boolean</code> <br> Whether to focus on the menu when mounted.
</p>
</li>
<li> <p><b> shouldUpdateWhenHidden </b> <code>boolean</code> <br> If true, the menu will be updated even when <code>hidden=true</code>. Note that this will consume resources to update even when nothing is being shown to the user. This might be helpful if your updates are small and you want the menu to display quickly when <code>hidden</code> is set to false.
</p>
</li>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;IContextualMenuStyleProps, IContextualMenuStyles&gt;⁠</code> <br> Call to provide customized styling that will layer on top of the variant rules.
</p>
</li>
<li> <p><b> subMenuHoverDelay </b> <code>number</code> <br> Delay (in milliseconds) to wait before expanding / dismissing a submenu on mouseEnter or mouseLeave
</p>
</li>
<li> <p><b> target </b> <code>Target</code> <br> The target that the ContextualMenu should try to position itself based on. It can be either an element, a query selector string resolving to a valid element, or a MouseEvent. If a MouseEvent is given, the origin point of the event will be used.
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Theme provided by higher-order component.
</p>
</li>
<li> <p><b> title </b> <code>string</code> <br> Title to be displayed at the top of the menu, above the items.
</p>
</li>
<li> <p><b> useTargetAsMinWidth </b> <code>boolean</code> <br> If true the context menu will have a minimum width equal to the width of the target element
</p>
</li>
<li> <p><b> useTargetWidth </b> <code>boolean</code> <br> If true the context menu will render as the same width as the target element
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(shiny)
library(shiny.fluent)

ui &lt;- function(id) {
  ns &lt;- NS(id)
  div(
    DefaultButton.shinyInput(
      ns("toggleContextualMenu"),
      id = "target",
      text = "Toggle menu"
    ),
    reactOutput(ns("contextualMenu"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    ns &lt;- session$ns

    showContextualMenu &lt;- reactiveVal(FALSE)
    observeEvent(input$toggleContextualMenu, {
      showContextualMenu(!showContextualMenu())
    })

    output$contextualMenu &lt;- renderReact({
      menuItems &lt;- JS("[
        {
          key: 'newItem',
          text: 'New',
          onClick: () =&gt; console.log('New clicked'),
        },
        {
          key: 'divider_1',
          itemType: 1,
        },
        {
          key: 'rename',
          text: 'Rename',
          onClick: () =&gt; console.log('Rename clicked'),
        },
        {
          key: 'edit',
          text: 'Edit',
          onClick: () =&gt; console.log('Edit clicked'),
        },
        {
          key: 'properties',
          text: 'Properties',
          onClick: () =&gt; console.log('Properties clicked'),
        },
        {
          key: 'linkNoTarget',
          text: 'Link same window',
          href: 'http://bing.com',
        },
        {
          key: 'linkWithTarget',
          text: 'Link new window',
          href: 'http://bing.com',
          target: '_blank',
        },
        {
          key: 'linkWithOnClick',
          name: 'Link click',
          href: 'http://bing.com',
          onClick: function(){
            alert('Link clicked');
            ev.preventDefault();
          },
          target: '_blank',
        },
        {
          key: 'disabled',
          text: 'Disabled item',
          disabled: true,
          onClick: () =&gt; console.error('Disabled item should not be clickable.'),
        },
      ]")

      ContextualMenu(
        items = menuItems,
        hidden = !showContextualMenu(),
        target = "#target",
        onItemClick = JS(paste0(
          "function() {",
          "  Shiny.setInputValue('", ns("toggleContextualMenu"), "', Math.random());",
          "}"
        )),
        onDismiss = JS(paste0(
          "function() {",
          "  Shiny.setInputValue('", ns("toggleContextualMenu"), "', Math.random());",
          "}"
        ))
      )
    })
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>