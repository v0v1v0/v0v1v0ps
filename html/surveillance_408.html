<div class="container">

<table style="width: 100%;"><tr>
<td>hhh4_update</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>update</code> a fitted <code>"hhh4"</code> model
</h2>

<h3>Description</h3>

<p>Re-fit a <code>"hhh4"</code> model with a modified <code>control</code> list.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'hhh4'
update(object, ..., S = NULL, subset.upper = NULL,
       use.estimates = object$convergence, evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a fitted <code>"hhh4"</code> model.
Non-convergent fits can be updated as well.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>components modifying the original control list for
<code>hhh4</code>. Modifications are performed by
<code>modifyList(object$control, list(...))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>

<p>a named list of numeric vectors serving as argument for
<code>addSeason2formula</code>, or <code>NULL</code> (meaning no
modification of seasonal terms). This argument provides a convenient
way of changing the number of harmonics in the <code>f</code>ormulae of
the model components <code>"ar"</code>, <code>"ne"</code> and <code>"end"</code> (to be
used as names of the list). Non-specified components are not touched.
Updating the <code>f</code>ormula of component <code><var>comp</var></code> works by first
dropping all sine and cosine terms and then applying
<code>addSeason2formula</code> with arguments <code>S = S[[<var>comp</var>]]</code> and
<code>period = frequency(object$stsObj)</code>, unless the component was
originally disabled (<code>f = ~ -1</code>) when the harmonics are added
to a simple intercept model and a warning is given.<br>
Note that this step of updating
seasonality is processed after modification of the <code>control</code>
list by the <code>...</code> arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset.upper</code></td>
<td>

<p>if a scalar value, refit the model to the data up to the time index
given by <code>subset.upper</code>. The lower time index remains
unchanged, i.e., <code>control$subset[1]:subset.upper</code> is used as
the new <code>subset</code>.
This argument is used by <code>oneStepAhead</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.estimates</code></td>
<td>

<p>logical specifying if <code>coef(object)</code> should be used as
starting values for the new fit (which is the new default since
<span class="pkg">surveillance</span> 1.8-2, in case the original fit has converged).
This works by matching names
against the coefficients of the new model. Extra coefficients no
longer in the model are silently ignored. Setting
<code>use.estimates = FALSE</code> means to re-use the previous start
specification <code>object$control$start</code>.<br>
Note that coefficients can also receive initial values from an extra
<code>start</code> argument in the update call (as in <code>hhh4</code>),
which then takes precedence over <code>coef(object)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate</code></td>
<td>

<p>logical indicating if the updated model should be fitted directly
(defaults to <code>TRUE</code>). Otherwise, the updated <code>control</code> list
is returned.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>evaluate = TRUE</code> the re-fitted object, otherwise the updated
<code>control</code> list for <code>hhh4</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code>hhh4</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("salmonella.agona")
## convert to sts class
salmonella &lt;- disProg2sts(salmonella.agona)

## fit a basic model
fit0 &lt;- hhh4(salmonella,
            list(ar = list(f = ~1), end = list(f = addSeason2formula(~1))))

## the same, updating the minimal endemic-only model via 'S' (with a warning):
fit0.2 &lt;- update(hhh4(salmonella), # has no AR component
                 S = list(ar = 0, end = 1))
local({
  fit0$control$start &lt;- fit0.2$control$start &lt;- NULL # obviously different
  stopifnot(all.equal(fit0, fit0.2))
})

## multiple updates: Poisson -&gt; NegBin1, more harmonics
fit1 &lt;- update(fit0, family = "NegBin1", S = list(end=2, ar=2))

## compare fits
AIC(fit0, fit1)
opar &lt;- par(mfrow=c(2,2))
plot(fit0, type="fitted", names="fit0", par.settings=NULL)
plot(fit1, type="fitted", names="fit1", par.settings=NULL)
plot(fit0, fit1, type="season", components=c("end", "ar"), par.settings=NULL)
par(opar)
</code></pre>


</div>