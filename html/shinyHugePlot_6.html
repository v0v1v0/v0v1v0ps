<div class="container">

<table style="width: 100%;"><tr>
<td>downsampler</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class for down-sampling data</h2>

<h3>Description</h3>

<p>A class for down-sampling data with a large number of samples.
An instance contains (the reference of) original data, layout of the figure,
and options for aggregating the original data.
An interactive plot for displaying large-sized data can be obtained using
the figure, down-sampler and its options included in the instance,
while making the plot using <code>shiny_hugeplot</code> function is easier (see examples).
See the super class (<code>plotly_datahandler</code>) to find more members
to handle the data in <code>plotly</code>.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::plotly_datahandler</code> -&gt; <code>downsampler</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>downsample_options</code></dt>
<dd>
<p>Options for aggregating (down-sampling) data
registered in this instance.</p>
</dd>
<dt><code>n_out_default</code></dt>
<dd>
<p>Default sample size.</p>
</dd>
<dt><code>aggregator_default</code></dt>
<dd>
<p>Default aggregator instance.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-downsampler-new"><code>downsampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-add_trace"><code>downsampler$add_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-update_trace"><code>downsampler$update_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-set_downsample_options"><code>downsampler$set_downsample_options()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-clone"><code>downsampler$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="plotly_datahandler" data-id="plotly_data_to_df"><a href="../../shinyHugePlot/html/plotly_datahandler.html#method-plotly_datahandler-plotly_data_to_df"><code>shinyHugePlot::plotly_datahandler$plotly_data_to_df()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="plotly_datahandler" data-id="set_trace_data"><a href="../../shinyHugePlot/html/plotly_datahandler.html#method-plotly_datahandler-set_trace_data"><code>shinyHugePlot::plotly_datahandler$set_trace_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="plotly_datahandler" data-id="srcs_to_df"><a href="../../shinyHugePlot/html/plotly_datahandler.html#method-plotly_datahandler-srcs_to_df"><code>shinyHugePlot::plotly_datahandler$srcs_to_df()</code></a></span></li>
</ul></details><hr>
<a id="method-downsampler-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>To construct an instance, original data, layout of the figure, and options
for aggregating the original data are necessary.
The original data and the layout of the figure can be given by providing
a <code>plotly</code> object (<code>figure</code> argument).
The options for aggregating the original data can be given by providing
an aggregator (<code>aggregator</code> argument) and the number of samples
(<code>n_out</code> argument).
See the constructor of the <code>plotly_datahandler</code> class for more
information on other arguments.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$new(
  figure = NULL,
  formula = NULL,
  srcs = NULL,
  srcs_ext = list(),
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  tz = Sys.timezone(),
  use_light_build = TRUE,
  legend_options = list(name_prefix = "&lt;b style=\"color:sandybrown\"&gt;[S]&lt;/b&gt; ",
    name_suffix = "", xdiff_prefix = "&lt;i style=\"color:#fc9944\"&gt; ~", xdiff_suffix =
    "&lt;/i&gt;"),
  verbose = F
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>figure, srcs, srcs_ext, formula, legend_options, tz, use_light_build</code></dt>
<dd>
<p>Arguments passed to <code>plotly_datahandler$new</code>.</p>
</dd>
<dt><code>n_out</code></dt>
<dd>
<p>Integer or numeric.
The number of samples shown after down-sampling. By default 1000.</p>
</dd>
<dt><code>aggregator</code></dt>
<dd>
<p>An instance of an R6 class for aggregation.
Select an aggregation function. The list of the functions are obtained
using <code>list_aggregators</code>.
By default, <code>min_max_aggregator$new()</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Boolean.
Whether detailed messages to check the procedures are shown. By default, <code>FALSE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-downsampler-add_trace"></a>



<h4>Method <code>add_trace()</code>
</h4>

<p>Add a new series to the data registered in the instance.
If a data frame (<code>traces_df</code> argument) compliant with
<code>self$orig_data</code> is given, it will be added to <code>self$orig_data</code>.
If attributes to construct a <code>plotly</code> object (<code>...</code> argument)
are given, a data frame is constructed and added.
Options for aggregating data can be set using
<code>aggregator</code> and <code>n_out</code> arguments.
It is a wrapper of <code>self$set_trace_data</code> and
<code>self$set_downsample_options</code>. See these methods for more information.
Note that the traces of the figure are not updated with this method and
<code>self$update_trace</code> is necessary.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$add_trace(..., traces_df = NULL, n_out = NULL, aggregator = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>..., traces_df</code></dt>
<dd>
<p>Arguments passed to <code>self$set_trace_data</code>
(see the super class of <code>plotly_datahandler</code>)</p>
</dd>
<dt><code>n_out, aggregator</code></dt>
<dd>
<p>Arguments passed to <code>self$set_downsample_options</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-downsampler-update_trace"></a>



<h4>Method <code>update_trace()</code>
</h4>

<p>Update traces of the figure registered in the instance
(<code>self$figure$x$data</code>) according to
re-layout order (<code>relayout_order</code> argument).
Using <code>reset</code> and <code>reload</code> arguments, traces are updated
without re-layout orders.
It just registers the new traces and returns nothing by default.
It returns the new traces if <code>send_trace</code> is <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$update_trace(
  relayout_order = list(NULL),
  reset = FALSE,
  reload = FALSE,
  send_trace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>relayout_order</code></dt>
<dd>
<p>Named list.
A list generated by <code>plotlyjs_relayout</code>,
which is obtained using <code>plotly::event_data</code>.
e.g.,
If you would like set the range of the 2nd x axis to [10.0, 21.5],
<code>list(`xaxis2.range[0]` = 10.0, `xaxis2.range[1]` = 21.5)</code>.
If you would like reset the range of the 1st x axis,
<code>list(xaxis.autorange = TRUE, xaxis.showspike = TRUE)</code>.</p>
</dd>
<dt><code>reset</code></dt>
<dd>
<p>Boolean.
If it is <code>TRUE</code>, all other arguments are neglected and
the figure will be reset (all the ranges of x axes are initialized).
By default, <code>FALSE</code>.</p>
</dd>
<dt><code>reload</code></dt>
<dd>
<p>Boolean.
If it is <code>TRUE</code>, the ranges of the figure are preserved but
the aggregation will be conducted with the current settings.
By default, <code>FALSE</code>.</p>
</dd>
<dt><code>send_trace</code></dt>
<dd>
<p>Boolean.
If it is <code>TRUE</code>, a named list will be returned,
which contains the indexes of the traces that will be updated
(<code>trace_idx_update</code>) and the updated traces (<code>new_trace</code>).
By default, <code>FALSE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-downsampler-set_downsample_options"></a>



<h4>Method <code>set_downsample_options()</code>
</h4>

<p>In the instance, options for aggregating data are registered as data frame.
(see <code>self$downsample_options</code>.)
Using this method, the options can be set.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$set_downsample_options(uid = NULL, n_out = NULL, aggregator = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uid</code></dt>
<dd>
<p>Character, optional.
The unique id of the trace.
If <code>NULL</code>, all the options registered in this instance are updated.
By default, <code>NULL</code>.</p>
</dd>
<dt><code>n_out</code></dt>
<dd>
<p>Numeric or integer, optional.
The number of samples output by the aggregator.
If <code>NULL</code>, the default value registered in this instance is used.
By default, <code>NULL</code>.</p>
</dd>
<dt><code>aggregator</code></dt>
<dd>
<p><code>aggregator</code> object, optional.
An instance that aggregate the data.
If <code>NULL</code>, the default value registered in this instance is used.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-downsampler-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
data(noise_fluct)

# example 1 : Easy method using shiny_hugeplot
shiny_hugeplot(noise_fluct$time, noise_fluct$f500)

# example 2 : Manual method using a downsampler object
fig &lt;- plot_ly(
  x = noise_fluct$time,
  y = noise_fluct$f500,
  type = "scatter",
  mode = "lines"
  ) %&gt;%
  layout(xaxis = list(type = "date")) %&gt;%
  shinyHugePlot::plotly_build_light()

ds &lt;- downsampler$new(
  figure = fig,
  aggregator = min_max_aggregator$new(interleave_gaps = TRUE)
)

ui &lt;- fluidPage(
  plotlyOutput(outputId = "hp", width = "800px", height = "600px")
)

server &lt;- function(input, output, session) {

  output$hp &lt;- renderPlotly(ds$figure)

  observeEvent(plotly::event_data("plotly_relayout"),{
    updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
  })

}

shinyApp(ui = ui, server = server)


# example 3 : Add another series of which aggregator is different

noise_events &lt;- tibble(
  time = c("2022-11-09 12:25:50", "2022-11-09 12:26:14"),
  level = c(60, 60)
)

ds$add_trace(
  x = noise_events$time, y = noise_events$level, name = "event",
  type = "scatter", mode = "markers",
  aggregator = null_aggregator$new()
)
ds$update_trace(reset = TRUE)

server &lt;- function(input, output, session) {

  output$hp &lt;- renderPlotly(ds$figure)

  observeEvent(plotly::event_data("plotly_relayout"),{
    updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
  })

}

shinyApp(ui = ui, server = server)



</code></pre>


</div>