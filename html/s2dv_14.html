<div class="container">

<table style="width: 100%;"><tr>
<td>Cluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>K-means Clustering</h2>

<h3>Description</h3>

<p>Compute cluster centers and their time series of occurrences, with the 
K-means clustering method using Euclidean distance, of an array of input data
with any number of dimensions that at least contain time_dim. 
Specifically, it partitions the array along time axis in K groups or clusters
in which each space vector/array belongs to (i.e., is a member of) the 
cluster with the nearest center or centroid. This function is a wrapper of 
kmeans() and relies on the NbClust package (Charrad et al., 2014 JSS) to 
determine the optimal number of clusters used for K-means clustering if it is
not provided by users.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Cluster(
  data,
  weights = NULL,
  time_dim = "sdate",
  space_dim = NULL,
  nclusters = NULL,
  index = "sdindex",
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A numeric array with named dimensions that at least have 
'time_dim' corresponding to time and 'space_dim' (optional) corresponding 
to either area-averages over a series of domains or the grid points for any
sptial grid structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A numeric array with named dimension of multiplicative weights
based on the areas covering each domain/region or grid-cell of 'data'. The 
dimensions must be equal to the 'space_dim' in 'data'. The default value is
NULL which means no weighting is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_dim</code></td>
<td>
<p>A character string indicating the name of time dimension in 
'data'. The default value is 'sdate'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>space_dim</code></td>
<td>
<p>A character vector indicating the names of spatial dimensions
in 'data'. The default value is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclusters</code></td>
<td>
<p>A positive integer K that must be bigger than 1 indicating
the number of clusters to be computed, or K initial cluster centers to be 
used in the method. The default value is NULL, which means that the number
of clusters will be determined by NbClust(). The parameter 'index' 
therefore needs to be specified for NbClust() to find the optimal number of 
clusters to be used for K-means clustering calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A character string of the validity index from NbClust package 
that can be used to determine optimal K if K is not specified with 
'nclusters'. The default value is 'sdindex' (Halkidi et al. 2001, JIIS). 
Other indices available in NBClust are "kl", "ch", "hartigan", "ccc", 
"scott", "marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db",
"silhouette", "duda", "pseudot2", "beale", "ratkowsky", "ball", 
"ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", 
"hubert", "sdindex", and "sdbw".
One can also use all of them with the option 'alllong' or almost all indices
except gap, gamma, gplus and tau with 'all', when the optimal number of
clusters K is detremined by the majority rule (the maximum of histogram of 
the results of all indices with finite solutions). Use of some indices on 
a big and/or unstructured dataset can be computationally intense and/or 
could lead to numerical singularity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>An integer indicating the number of cores to use for parallel 
computation. The default value is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$cluster</code></td>
<td>

<p>An integer array of the occurrence of a cluster along time, i.e., when
certain data member in time is allocated to a specific cluster. The dimensions
are same as 'data' without 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$centers</code></td>
<td>

<p>A numeric array of cluster centres or centroids (e.g. [1:K, 1:spatial degrees 
of freedom]). The rest dimensions are same as 'data' except 'time_dim' 
and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$totss</code></td>
<td>

<p>A numeric array of the total sum of squares. The dimensions are same as 'data'
except 'time_dim' and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$withinss</code></td>
<td>

<p>A numeric array of within-cluster sum of squares, one component per cluster. 
The first dimenion is the number of cluster, and the rest dimensions are 
same as 'data' except 'time_dim' and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$tot.withinss</code></td>
<td>

<p>A numeric array of the total within-cluster sum of squares, i.e., 
sum(withinss). The dimensions are same as 'data' except 'time_dim' and 
'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$betweenss</code></td>
<td>

<p>A numeric array of the between-cluster sum of squares, i.e. totss-tot.withinss.
The dimensions are same as 'data' except 'time_dim' and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$size</code></td>
<td>

<p>A numeric array of the number of points in each cluster. The first dimenion 
is the number of cluster, and the rest dimensions are same as 'data' except
'time_dim' and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$iter</code></td>
<td>

<p>A numeric array of the number of (outer) iterations. The dimensions are 
same as 'data' except 'time_dim' and 'space_dim'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$ifault</code></td>
<td>

<p>A numeric array of an indicator of a possible algorithm problem. The 
dimensions are same as 'data' except 'time_dim' and 'space_dim'.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wilks, 2011, Statistical Methods in the Atmospheric Sciences, 3rd ed., Elsevire, pp 676.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generating synthetic data
a1 &lt;- array(dim = c(200, 4))
mean1 &lt;- 0
sd1 &lt;- 0.3 

c0 &lt;- seq(1, 200)
c1 &lt;- sort(sample(x = 1:200, size = sample(x = 50:150, size = 1), replace = FALSE))
x1 &lt;- c(1, 1, 1, 1)
for (i1 in c1) {
 a1[i1, ] &lt;- x1 + rnorm(4, mean = mean1, sd = sd1)
}

c1p5 &lt;- c0[!(c0 %in% c1)]
c2 &lt;- c1p5[seq(1, length(c1p5), 2)] 
x2 &lt;- c(2, 2, 4, 4)
for (i2 in c2) {
 a1[i2, ] &lt;- x2 + rnorm(4, mean = mean1, sd = sd1)
}

c3 &lt;- c1p5[seq(2, length(c1p5), 2)]
x3 &lt;- c(3, 3, 1, 1)
for (i3 in c3) {
 a1[i3, ] &lt;- x3 + rnorm(4, mean = mean1, sd = sd1)
}

# Computing the clusters
names(dim(a1)) &lt;- c('sdate', 'space')
res1 &lt;- Cluster(data = a1, weights = array(1, dim = dim(a1)[2]), nclusters = 3)
res2 &lt;- Cluster(data = a1, weights = array(1, dim = dim(a1)[2]))

</code></pre>


</div>