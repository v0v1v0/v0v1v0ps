<div class="container">

<table style="width: 100%;"><tr>
<td>gplot.layout</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Vertex Layout Functions for gplot </h2>

<h3>Description</h3>

<p>Various functions which generate vertex layouts for the <code>gplot</code> visualization routine.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gplot.layout.adj(d, layout.par)
gplot.layout.circle(d, layout.par)
gplot.layout.circrand(d, layout.par)
gplot.layout.eigen(d, layout.par)
gplot.layout.fruchtermanreingold(d, layout.par)
gplot.layout.geodist(d, layout.par)
gplot.layout.hall(d, layout.par)
gplot.layout.kamadakawai(d, layout.par)
gplot.layout.mds(d, layout.par)
gplot.layout.princoord(d, layout.par)
gplot.layout.random(d, layout.par)
gplot.layout.rmds(d, layout.par)
gplot.layout.segeo(d, layout.par)
gplot.layout.seham(d, layout.par)
gplot.layout.spring(d, layout.par)
gplot.layout.springrepulse(d, layout.par)
gplot.layout.target(d, layout.par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p> an adjacency matrix, as passed by <code>gplot</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layout.par</code></td>
<td>
<p> a list of parameters. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Vertex layouts for network visualization pose a difficult problem – there is no single, “good” layout algorithm, and many different approaches may be valuable under different circumstances.  With this in mind, <code>gplot</code> allows for the use of arbitrary vertex layout algorithms via the <code>gplot.layout.*</code> family of routines.  When called, <code>gplot</code> searches for a <code>gplot.layout</code> function whose third name matches its <code>mode</code> argument (see <code>gplot</code> help for more information); this function is then used to generate the layout for the resulting plot.  In addition to the routines documented here, users may add their own layout functions as needed.  The requirements for a <code>gplot.layout</code> function are as follows:
</p>

<ol>
<li>
<p> the first argument, <code>d</code>, must be the (dichotomous) graph adjacency matrix;
</p>
</li>
<li>
<p> the second argument, <code>layout.par</code>, must be a list of parameters (or <code>NULL</code>, if no parameters are specified); and
</p>
</li>
<li>
<p> the return value must be a real matrix of dimension <code>c(2,NROW(d))</code>, whose rows contain the vertex coordinates.
</p>
</li>
</ol>
<p>Other than this, anything goes.  (In particular, note that <code>layout.par</code> could be used to pass additional matrices, if needed.)  
</p>
<p>The <code>graph.layout</code> functions currently supplied by default are as follows:
</p>

<dl>
<dt>circle</dt>
<dd>
<p> This function places vertices uniformly in a circle; it takes no arguments.</p>
</dd>
<dt>eigen</dt>
<dd>
<p> This function places vertices based on the eigenstructure of the adjacency matrix.  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$var</code></dt>
<dd>
<p> This argument controls the matrix to be used for the eigenanalysis.  <code>"symupper"</code>, <code>"symlower"</code>, <code>"symstrong"</code>, <code>"symweak"</code> invoke <code>symmetrize</code> on <code>d</code> with the respective symmetrizing rule.  <code>"user"</code> indicates a user-supplied matrix (see below), while <code>"raw"</code> indicates that <code>d</code> should be used as-is.  (Defaults to <code>"raw"</code>.)</p>
</dd>
<dt><code>layout.par$evsel</code></dt>
<dd>
<p> If <code>"first"</code>, the first two eigenvectors are used; if <code>"size"</code>, the two eigenvectors whose eigenvalues have the largest magnitude are used instead. Note that only the real portion of the associated eigenvectors is used.  (Defaults to <code>"first"</code>.)</p>
</dd>
<dt><code>layout.par$mat</code></dt>
<dd>
<p>  If <code>layout.par$var=="user"</code>, this matrix is used for the eigenanalysis. (No default.)</p>
</dd>
</dl>
</dd>
<dt>fruchtermanreingold</dt>
<dd>
<p> This function generates a layout using a variant of Fruchterman and Reingold's force-directed placement algorithm.  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$niter</code></dt>
<dd>
<p> This argument controls the number of iterations to be employed.  Larger values take longer, but will provide a more refined layout.  (Defaults to 500.) </p>
</dd>
<dt><code>layout.par$max.delta</code></dt>
<dd>
<p> Sets the maximum change in position for any given iteration.   (Defaults to <code>n</code>.)</p>
</dd>
<dt><code>layout.par$area</code></dt>
<dd>
<p>  Sets the “area” parameter for the F-R algorithm. (Defaults to <code>n^2</code>.)</p>
</dd>
<dt><code>layout.par$cool.exp</code></dt>
<dd>
<p>  Sets the cooling exponent for the annealer. (Defaults to 3.)</p>
</dd>
<dt><code>layout.par$repulse.rad</code></dt>
<dd>
<p>  Determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices.  (Defaults to <code>area*log(n)</code>.)</p>
</dd>
<dt><code>layout.par$ncell</code></dt>
<dd>
<p>  To speed calculations on large graphs, the plot region is divided at each iteration into <code>ncell</code> by <code>ncell</code> “cells”, which are used to define neighborhoods for force calculation.  Moderate numbers of cells result in fastest performance; too few cells (down to 1, which produces “pure” F-R results) can yield odd layouts, while too many will result in long layout times.  (Defaults to <code>n^0.5</code>.)</p>
</dd>
<dt><code>layout.par$cell.jitter</code></dt>
<dd>
<p>  Jitter factor (in units of cell width) used in assigning vertices to cells.  Small values may generate “grid-like” anomalies for graphs with many isolates.  (Defaults to <code>0.5</code>.)</p>
</dd>
<dt><code>layout.par$cell.pointpointrad</code></dt>
<dd>
<p>  Squared “radius” (in units of cells) such that exact point interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart.  Higher values approximate the true F-R solution, but increase computational cost.  (Defaults to <code>0</code>.)</p>
</dd>
<dt><code>layout.par$cell.pointcellrad</code></dt>
<dd>
<p>  Squared “radius” (in units of cells) such that approximate point/cell interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart (and not within the point/point radius).  Higher values provide somewhat better approximations to the true F-R solution at slightly increased computational cost.  (Defaults to <code>18</code>.)</p>
</dd>
<dt><code>layout.par$cell.cellcellrad</code></dt>
<dd>
<p>  Squared “radius” (in units of cells) such that approximate cell/cell interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart (and not within the point/point or point/cell radii).  Higher values provide somewhat better approximations to the true F-R solution at slightly increased computational cost.  Note that cells beyond this radius (if any) do not interact, save through edge attraction. (Defaults to <code>ncell^2</code>.)</p>
</dd>
<dt><code>layout.par$seed.coord</code></dt>
<dd>
<p> A two-column matrix of initial vertex coordinates.  (Defaults to a random circular layout.) </p>
</dd>  
</dl>
</dd>
<dt>hall</dt>
<dd>
<p> This function places vertices based on the last two eigenvectors of the Laplacian of the input matrix (Hall's algorithm).  It takes no arguments.</p>
</dd>
<dt>kamadakawai</dt>
<dd>
<p> This function generates a vertex layout using a version of the Kamada-Kawai force-directed placement algorithm.  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$niter</code></dt>
<dd>
<p> This argument controls the number of iterations to be employed.  (Defaults to 1000.) </p>
</dd>
<dt><code>layout.par$sigma</code></dt>
<dd>
<p> Sets the base standard deviation of position change proposals.   (Defaults to <code>NROW(d)/4</code>.)</p>
</dd>
<dt><code>layout.par$initemp</code></dt>
<dd>
<p>  Sets the initial "temperature" for the annealing algorithm. (Defaults to 10.)</p>
</dd>
<dt><code>layout.par$cool.exp</code></dt>
<dd>
<p>  Sets the cooling exponent for the annealer. (Defaults to 0.99.)</p>
</dd>
<dt><code>layout.par$kkconst</code></dt>
<dd>
<p>  Sets the Kamada-Kawai vertex attraction constant.  (Defaults to <code>NROW(d)^2</code>.)</p>
</dd>
<dt><code>layout.par$elen</code></dt>
<dd>
<p>  Provides the matrix of interpoint distances to be approximated.  (Defaults to the geodesic distances of <code>d</code> after symmetrizing, capped at <code>sqrt(NROW(d))</code>.)</p>
</dd>
<dt><code>layout.par$seed.coord</code></dt>
<dd>
<p> A two-column matrix of initial vertex coordinates.  (Defaults to a gaussian layout.) </p>
</dd>  
</dl>
</dd>
<dt>mds</dt>
<dd>
<p> This function places vertices based on a metric multidimensional scaling of a specified distance matrix.  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$var</code></dt>
<dd>
<p> This argument controls the raw variable matrix to be used for the subsequent distance calculation and scaling.  <code>"rowcol"</code>, <code>"row"</code>, and <code>"col"</code> indicate that the rows and columns (concatenated), rows, or columns (respectively) of <code>d</code> should be used.  <code>"rcsum"</code> and <code>"rcdiff"</code> result in the sum or difference of <code>d</code> and its transpose being employed.  <code>"invadj"</code> indicates that <code>max{d}-d</code> should be used, while <code>"geodist"</code> uses <code>geodist</code> to generate a matrix of geodesic distances from <code>d</code>. Alternately, an arbitrary matrix can be provided using <code>"user"</code>.  (Defaults to <code>"rowcol"</code>.)</p>
</dd>
<dt><code>layout.par$dist</code></dt>
<dd>
<p> The distance function to be calculated on the rows of the variable matrix.  This must be one of the <code>method</code> parameters to <code>dist</code> (<code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>, or <code>"canberra"</code>), or else <code>"none"</code>.  In the latter case, no distance function is calculated, and the matrix in question must be square (with dimension <code>dim(d)</code>) for the routine to work properly.  (Defaults to <code>"euclidean"</code>.)</p>
</dd>
<dt><code>layout.par$exp</code></dt>
<dd>
<p> The power to which distances should be raised prior to scaling.  (Defaults to 2.)</p>
</dd>
<dt><code>layout.par$vm</code></dt>
<dd>
<p> If <code>layout.par$var=="user"</code>, this matrix is used for the distance calculation. (No default.)</p>
</dd>
</dl>
<p>Note: the following layout functions are based on <code>mds</code>:
</p>

<dl>
<dt>adj</dt>
<dd>
<p> scaling of the raw adjacency matrix, treated as similarities (using <code>"invadj"</code>).</p>
</dd>
<dt>geodist</dt>
<dd>
<p> scaling of the matrix of geodesic distances.</p>
</dd>
<dt>rmds</dt>
<dd>
<p> euclidean scaling of the rows of <code>d</code>.</p>
</dd>
<dt>segeo</dt>
<dd>
<p> scaling of the squared euclidean distances between row-wise geodesic distances (i.e., approximate structural equivalence).</p>
</dd>
<dt>seham</dt>
<dd>
<p> scaling of the Hamming distance between rows/columns of <code>d</code> (i.e., another approximate structural equivalence scaling).</p>
</dd>
</dl>
</dd>
<dt>princoord</dt>
<dd>
<p> This function places vertices based on the eigenstructure of a given correlation/covariance matrix. It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$var</code></dt>
<dd>
<p> The matrix of variables to be used for the correlation/covariance calculation.  <code>"rowcol"</code>, <code>"col"</code>, and <code>"row"</code> indicate that the rows/cols, columns, or rows (respectively) of <code>d</code> should be employed.  <code>"rcsum"</code> <code>"rcdiff"</code> result in the sum or difference of <code>d</code> and <code>t(d)</code> being used.  <code>"user"</code> allows for an arbitrary variable matrix to be supplied.  (Defaults to <code>"rowcol"</code>.)</p>
</dd>
<dt><code>layout.par$cor</code></dt>
<dd>
<p> Should the correlation matrix (rather than the covariance matrix) be used?  (Defaults to <code>TRUE</code>.)</p>
</dd>
<dt><code>layout.par$vm</code></dt>
<dd>
<p> If <code>layout.par$var=="user"</code>, this matrix is used for the correlation/covariance calculation. (No default.)</p>
</dd>
</dl>
</dd>
<dt>random</dt>
<dd>
<p> This function places vertices randomly.  It takes the following argument:
</p>

<dl>
<dt><code>layout.par$dist</code></dt>
<dd>
<p> The distribution to be used for vertex placement.  Currently, the options are <code>"unif"</code> (for uniform distribution on the square), <code>"uniang"</code> (for a “gaussian donut” configuration), and <code>"normal"</code> (for a straight Gaussian distribution).  (Defaults to <code>"unif"</code>.)</p>
</dd>
</dl>
<p>Note: <code>circrand</code>, which is a frontend to the <code>"uniang"</code> option, is based on this function.
</p>
</dd>
<dt>spring</dt>
<dd>
<p> This function places vertices using a spring embedder.  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$mass</code></dt>
<dd>
<p> The vertex mass (in “quasi-kilograms”).  (Defaults to <code>0.1</code>.)</p>
</dd>
<dt><code>layout.par$equil</code></dt>
<dd>
<p> The equilibrium spring extension (in “quasi-meters”). (Defaults to <code>1</code>.)</p>
</dd>
<dt><code>layout.par$k</code></dt>
<dd>
<p> The spring coefficient (in “quasi-Newtons per quasi-meter”). (Defaults to <code>0.001</code>.)</p>
</dd>
<dt><code>layout.par$repeqdis</code></dt>
<dd>
<p> The point at which repulsion (if employed) balances out the spring extension force (in “quasi-meters”). (Defaults to <code>0.1</code>.)</p>
</dd>
<dt><code>layout.par$kfr</code></dt>
<dd>
<p> The base coefficient of kinetic friction (in “quasi-Newton quasi-kilograms”). (Defaults to <code>0.01</code>.)</p>
</dd>
<dt><code>layout.par$repulse</code></dt>
<dd>
<p> Should repulsion be used?  (Defaults to <code>FALSE</code>.)</p>
</dd>
</dl>
<p>Note: <code>springrepulse</code> is a frontend to <code>spring</code>, with repulsion turned on.
</p>
</dd>
<dt>target</dt>
<dd>
<p> This function produces a "target diagram" or "bullseye" layout, using a Brandes et al.'s force-directed placement algorithm.  (See also <code>gplot.target</code>.)  It takes the following arguments:
</p>

<dl>
<dt><code>layout.par$niter</code></dt>
<dd>
<p> This argument controls the number of iterations to be employed.  (Defaults to 1000.) </p>
</dd>
<dt><code>layout.par$radii</code></dt>
<dd>
<p> This argument should be a vector of length <code>NROW(d)</code> containing vertex radii.  Ideally, these should lie in the [0,1] interval (and odd behavior may otherwise result).  (Defaults to the affine-transformed Freeman <code>degree</code> centrality scores of <code>d</code>.) </p>
</dd>
<dt><code>layout.par$minlen</code></dt>
<dd>
<p> Sets the minimum edge length, below which edge lengths are to be adjusted upwards.  (Defaults to 0.05.) </p>
</dd>
<dt><code>layout.par$area</code></dt>
<dd>
<p>  Sets the initial "temperature" for the annealing algorithm. (Defaults to 10.)</p>
</dd>
<dt><code>layout.par$cool.exp</code></dt>
<dd>
<p>  Sets the cooling exponent for the annealer. (Defaults to 0.99.)</p>
</dd>
<dt><code>layout.par$maxdelta</code></dt>
<dd>
<p>  Sets the maximum angular distance for vertex moves.  (Defaults to <code>pi</code>.)</p>
</dd>
<dt><code>layout.par$periph.outside</code></dt>
<dd>
<p>  Boolean; should "peripheral" vertices (in the Brandes et al. sense) be placed together outside the main target area?  (Defaults to <code>FALSE</code>.)</p>
</dd>
<dt><code>layout.par$periph.outside.offset</code></dt>
<dd>
<p>  Radius at which to place "peripheral" vertices if <code>periph.outside==TRUE</code>.  (Defaults to 1.2.)</p>
</dd>
<dt><code>layout.par$disconst</code></dt>
<dd>
<p>  Multiplier for the Kamada-Kawai-style distance potential.  (Defaults to 1.)</p>
</dd>
<dt><code>layout.par$crossconst</code></dt>
<dd>
<p>  Multiplier for the edge crossing potential.  (Defaults to 1.)</p>
</dd>
<dt><code>layout.par$repconst</code></dt>
<dd>
<p>  Multiplier for the vertex-edge repulsion potential.  (Defaults to 1.)</p>
</dd>
<dt><code>layout.par$minpdis</code></dt>
<dd>
<p>  Sets the "minimum distance" parameter for vertex repulsion.   (Defaults to 0.05.)</p>
</dd>
</dl>
</dd>
</dl>
<h3>Value</h3>

<p>A matrix whose rows contain the x,y coordinates of the vertices of <code>d</code>.
</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p>Brandes, U.; Kenis, P.; and Wagner, D.  (2003).  “Communicating Centrality in Policy Network Drawings.” <em>IEEE Transactions on Visualization and Computer Graphics,</em> 9(2):241-253.
</p>
<p>Fruchterman, T.M.J. and Reingold, E.M.  (1991).  “Graph Drawing by Force-directed Placement.” <em>Software - Practice and Experience,</em> 21(11):1129-1164.
</p>
<p>Kamada, T. and Kawai, S.  (1989).  “An Algorithm for Drawing General Undirected Graphs.” <em>Information Processing Letters,</em> 31(1):7-15.
</p>


<h3>See Also</h3>

 <p><code>gplot</code>, <code>gplot.target</code>, <code>gplot3d.layout</code>, <code>cmdscale</code>, <code>eigen</code> </p>


</div>