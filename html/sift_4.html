<div class="container">

<table style="width: 100%;"><tr>
<td>kluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Automatically cluster 1-dimensional continuous data.</h2>

<h3>Description</h3>

<p>Automatically cluster 1-dimensional continuous data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kluster(x, bw = "SJ", fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector to be clustered. Must contain at least 1 non-missing value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>kernel bandwidth. Default "SJ" should suffice more application, however you can supply a custom numeric value. See ?stats::density for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>logical; if <code>TRUE</code>, performs simple 1-dimensional clustering without kernel density estimation. default FALSE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An integer vector identifying the cluster corresponding to each element in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Below vector clearly has 2 groups.
# kluster will identify these groups using kernel density estimation.
kluster(c(0.1, 0.2, 1))

# kluster shines in cases where manually assigning groups via "eyeballing" is impractical.
# Suppose we obtained vector 'x' without knowing how it was generated.
set.seed(1)
nodes &lt;- runif(10, min = 0, max = 100)
x &lt;- lapply(nodes, function(x) rnorm(10, mean = x, sd = 0.1))
x &lt;- unlist(x)

kluster(x) # kluster reveals the natural grouping

kluster(x, bw = 10) # adjust bandwidth depending on application

# Example with faithful dataset
faithful$k &lt;- kluster(faithful$eruptions)
library(ggplot2)
ggplot(faithful, aes(eruptions)) +
  geom_density() +
  geom_rug(aes(color = factor(k))) +
  theme_minimal() +
  scale_color_discrete(name = "k")
</code></pre>


</div>