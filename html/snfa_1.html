<div class="container">

<table style="width: 100%;"><tr>
<td>allocative.efficiency</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Allocative efficiency estimation</h2>

<h3>Description</h3>

<p>Fits frontier to data and estimates technical and allocative efficiency
</p>


<h3>Usage</h3>

<pre><code class="language-R">allocative.efficiency(X, y, X.price, y.price, X.constrained = NA,
  H.inv = NA, H.mult = 1, model = "br", method = "u",
  scale.constraints = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of inputs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of outputs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.price</code></td>
<td>
<p>Matrix of input prices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.price</code></td>
<td>
<p>Vector of output prices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.constrained</code></td>
<td>
<p>Matrix of inputs where constraints apply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.inv</code></td>
<td>
<p>Inverse of the smoothing matrix (must be positive definite); defaults to rule of thumb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.mult</code></td>
<td>
<p>Scaling factor for rule of thumb smoothing matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Type of frontier to use; "br" for boundary regression, "sf" for stochastic frontier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Constraints to apply; "u" for unconstrained, "m" for monotonically increasing, and "mc" for monotonically increasing and concave</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.constraints</code></td>
<td>
<p>Boolean, whether to scale constraints by their average value, can help with convergence</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function estimates allocative inefficiency using the methodology in McKenzie
(2018). The estimation process is a non-parametric analogue of Schmidt and Lovell
(1979). First, the frontier is fit using either a boundary regression or stochastic
frontier as in Racine et al. (2009), from which technical efficiency is estimated.
Then, gradients and price ratios are computed for each observation and compared to 
determine the extent of misallocation. Specifically, log-overallocation is computed as
</p>
<p style="text-align: center;"><code class="reqn">\log\left(\frac{w_i^j}{p_i}\right) - \log\left(\phi_i\frac{\partial f(x_i)}{\partial x^j}\right),</code>
</p>

<p>where <code class="reqn">\phi_i</code> is the efficiency of observation <code class="reqn">i</code>,
<code class="reqn">\partial f(x_i) / \partial x^j</code> is the marginal productivity of input <code class="reqn">j</code>
at observation <code class="reqn">i</code>, <code class="reqn">w_i^j</code> is the cost of input <code class="reqn">j</code> for observation
<code class="reqn">i</code>, and <code class="reqn">p_i</code> is the price of output for observation <code class="reqn">i</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>y.fit</code></td>
<td>
<p>Estimated value of the frontier at X.fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient.fit</code></td>
<td>
<p>Estimated gradient of the frontier at X.fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>technical.efficiency</code></td>
<td>
<p>Estimated technical efficiency</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.overallocation</code></td>
<td>
<p>Estimated log-overallocation of each input for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.eval</code></td>
<td>
<p>Matrix of inputs used for fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.constrained</code></td>
<td>
<p>Matrix of inputs where constraints apply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.inv</code></td>
<td>
<p>Inverse smoothing matrix used in fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method used to fit frontier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling.factor</code></td>
<td>
<p>Factor by which constraints are multiplied before quadratic programming</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Aigner D, Lovell CK, Schmidt P (1977).
“Formulation and estimation of stochastic frontier production function models.”
<em>Journal of econometrics</em>, <b>6</b>(1), 21–37.<br><br>
McKenzie T (2018).
“Semi-Parametric Estimation of Allocative Inefficiency Using Smooth Non-Parametric Frontier Analysis.”
Working Paper.<br><br>
Racine JS, Parmeter CF, Du P (2009).
“Constrained nonparametric kernel regression: Estimation and inference.”
Working paper.<br><br>
Schmidt P, Lovell CK (1979).
“Estimating technical and allocative inefficiency relative to stochastic production and cost frontiers.”
<em>Journal of econometrics</em>, <b>9</b>(3), 343–366.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(USMacro)

USMacro &lt;- USMacro[complete.cases(USMacro),]

#Extract data
X &lt;- as.matrix(USMacro[,c("K", "L")])
y &lt;- USMacro$Y

X.price &lt;- as.matrix(USMacro[,c("K.price", "L.price")])
y.price &lt;- rep(1e9, nrow(USMacro)) #Price of $1 billion of output is $1 billion

#Run model
efficiency.model &lt;- allocative.efficiency(X, y,
                                         X.price, y.price,
                                         X.constrained = X,
                                         model = "br",
                                         method = "mc")

#Plot technical/allocative efficiency over time
library(ggplot2)

technical.df &lt;- data.frame(Year = USMacro$Year,
                          Efficiency = efficiency.model$technical.efficiency)

ggplot(technical.df, aes(Year, Efficiency)) +
  geom_line()

allocative.df &lt;- data.frame(Year = rep(USMacro$Year, times = 2),
                            log.overallocation = c(efficiency.model$log.overallocation[,1],
                                                   efficiency.model$log.overallocation[,2]),
                            Variable = rep(c("K", "L"), each = nrow(USMacro)))

ggplot(allocative.df, aes(Year, log.overallocation)) +
  geom_line(aes(color = Variable))

#Estimate average overallocation across sample period
lm.model &lt;- lm(log.overallocation ~ 0 + Variable, allocative.df)
summary(lm.model)
  
</code></pre>


</div>