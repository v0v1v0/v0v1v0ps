<div class="container">

<table style="width: 100%;"><tr>
<td>DSC_DBSTREAM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>DBSTREAM Clustering Algorithm</h2>

<h3>Description</h3>

<p>Micro Clusterer with reclustering.
Implements a simple density-based stream clustering algorithm that assigns
data points to micro-clusters with a given radius and implements
shared-density-based reclustering.
</p>


<h3>Usage</h3>

<pre><code class="language-R">DSC_DBSTREAM(
  formula = NULL,
  r,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  metric = "Euclidean",
  noise_multiplier = 1,
  shared_density = FALSE,
  alpha = 0.1,
  k = 0,
  minweight = 0
)

get_shared_density(x, use_alpha = TRUE)

change_alpha(x, alpha)

## S3 method for class 'DSC_DBSTREAM'
plot(
  x,
  dsd = NULL,
  n = 500,
  col_points = NULL,
  dim = NULL,
  method = "pairs",
  type = c("auto", "micro", "macro", "both", "none"),
  shared_density = FALSE,
  use_alpha = TRUE,
  assignment = FALSE,
  ...
)

DSOutlier_DBSTREAM(
  formula = NULL,
  r,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  metric = "Euclidean",
  outlier_multiplier = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model formula of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The radius of micro-clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambda used in the fading function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gaptime</code></td>
<td>
<p>weak micro-clusters (and weak shared density entries) are
removed every <code>gaptime</code> points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cm</code></td>
<td>
<p>minimum weight for a micro-cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>metric used to calculate distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_multiplier, outlier_multiplier</code></td>
<td>
<p>multiplier for radius <code>r</code> to declare noise or outliers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shared_density</code></td>
<td>
<p>Record shared density information. If set to
<code>TRUE</code> then shared density is used for reclustering, otherwise
reachability is used (overlapping clusters with less than <code class="reqn">r * (1 - alpha)</code>
distance are clustered together).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>For shared density: The minimum proportion of shared points
between to clusters to warrant combining them (a suitable value for 2D data
is .3).  For reachability clustering it is a distance factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of macro clusters to be returned if macro is true.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minweight</code></td>
<td>
<p>The proportion of the total weight a macro-cluster needs to
have not to be noise (between 0 and 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A DSC_DBSTREAM object to get the shared density information from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_alpha</code></td>
<td>
<p>only return shared density if it exceeds alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dsd</code></td>
<td>
<p>a data stream object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of plots taken from the dsd to plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_points</code></td>
<td>
<p>color used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>an integer vector with the dimensions to plot. If NULL then for methods "pairs" and "pc" all dimensions are used and for "scatter" the first two dimensions are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>plot method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Plot micro clusters (<code>type="micro"</code>), macro clusters (<code>type="macro"</code>), both micro and macro clusters (<code>type="both"</code>), outliers(<code>type="outliers"</code>), or everything together (<code>type="all"</code>). <code>type="auto"</code> leaves to the class of DSC to decide.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignment</code></td>
<td>
<p>logical; show assignment area of micro-clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments are passed on to plot or pairs in graphics.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The DBSTREAM algorithm checks for each new data point in the incoming
stream, if it is below the threshold value of dissimilarity value of any
existing micro-clusters, and if so, merges the point with the micro-cluster.
Otherwise, a new micro-cluster is created to accommodate the new data point.
</p>
<p>Although DSC_DBSTREAM is a micro clustering algorithm, macro clusters and
weights are available.
</p>
<p><code>update()</code>  invisibly return the assignment of the data points to clusters.
The columns are <code>.class</code> with the index of the strong micro-cluster and <code>.mc_id</code>
with the permanent id of the strong micro-cluster.
</p>
<p><code>plot()</code> for DSC_DBSTREAM has two extra logical parameters called
<code>assignment</code> and <code>shared_density</code> which show the assignment area
and the shared density graph, respectively.
</p>
<p><code>predict()</code> can be used to assign new points to clusters. Points are assigned to a micro-cluster if
they are within its assignment area (distance is less then <code>r</code> times <code>noise_multiplier</code>).
</p>
<p><code>DSOutlier_DBSTREAM</code> classifies points as outlier/noise if they that cannot be assigned to a micro-cluster
representing a dense region as a outlier/noise. Parameter <code>outlier_multiplier</code> specifies
how far a point has to be away from a micro-cluster as a multiplier for the radius <code>r</code>.
A larger value means that outliers have to be farther away from dense
regions and thus reduce the chance of misclassifying a regular point as an outlier.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_DBSTREAM</code> (subclass of DSC,
DSC_R, DSC_Micro).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Matthew Bolanos
</p>


<h3>References</h3>

<p>Michael Hahsler and Matthew Bolanos. Clustering data streams
based on shared density between micro-clusters. <em>IEEE Transactions on
Knowledge and Data Engineering,</em> 28(6):1449â€“1461, June 2016
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code>DSC_BICO()</code>,
<code>DSC_BIRCH()</code>,
<code>DSC_DStream()</code>,
<code>DSC_Micro()</code>,
<code>DSC_Sample()</code>,
<code>DSC_Window()</code>,
<code>DSC_evoStream()</code>
</p>
<p>Other DSC_TwoStage: 
<code>DSC_DStream()</code>,
<code>DSC_TwoStage()</code>,
<code>DSC_evoStream()</code>
</p>
<p>Other DSOutlier: 
<code>DSC_DStream()</code>,
<code>DSOutlier()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1000)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# create clusterer with r = .05
dbstream &lt;- DSC_DBSTREAM(r = .05)
update(dbstream, stream, 500)
dbstream

# check micro-clusters
nclusters(dbstream)
head(get_centers(dbstream))
plot(dbstream, stream)

# plot micro-clusters with assignment area
plot(dbstream, stream, type = "none", assignment = TRUE)


# DBSTREAM with shared density
dbstream &lt;- DSC_DBSTREAM(r = .05, shared_density = TRUE, Cm = 5)
update(dbstream, stream, 500)
dbstream

plot(dbstream, stream)
# plot the shared density graph (several options)
plot(dbstream, stream, type = "micro", shared_density = TRUE)
plot(dbstream, stream, type = "none", shared_density = TRUE, assignment = TRUE)

# see how micro and macro-clusters relate
# each micro-cluster has an entry with the macro-cluster id
# Note: unassigned micro-clusters (noise) have an NA
microToMacro(dbstream)

# do some evaluation
evaluate_static(dbstream, stream, measure = "purity")
evaluate_static(dbstream, stream, measure = "cRand", type = "macro")

# use DBSTREAM also returns the cluster assignment
# later retrieve the cluster assignments for each point)
data("iris")
dbstream &lt;- DSC_DBSTREAM(r = 1)
cl &lt;- update(dbstream, iris[,-5], return = "assignment")
dbstream

head(cl)

# micro-clusters
plot(iris[,-5], col = cl$.class, pch = cl$.class)

# macro-clusters (2 clusters since reachability cannot separate two of the three species)
plot(iris[,-5], col = microToMacro(dbstream, cl$.class))

# use DBSTREAM with a formula (cluster all variables but X2)
stream &lt;- DSD_Gaussians(k = 3, d = 4, noise = 0.05)
dbstream &lt;- DSC_DBSTREAM(formula = ~ . - X2, r = .2)

update(dbstream, stream, 500)
get_centers(dbstream)

# use DBSTREAM for outlier detection
stream &lt;- DSD_Gaussians(k = 3, d = 4, noise = 0.05)
outlier_detector &lt;- DSOutlier_DBSTREAM(r = .2)

update(outlier_detector, stream, 500)
outlier_detector

plot(outlier_detector, stream)

points &lt;- get_points(stream, 20)
points
which(is.na(predict(outlier_detector, points)))
</code></pre>


</div>