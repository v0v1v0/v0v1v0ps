<div class="container">

<table style="width: 100%;"><tr>
<td>sieve.sgd.solver</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit sieve-SGD estimators, using progressive validation for hyperparameter tuning.</h2>

<h3>Description</h3>

<p>Fit sieve-SGD estimators, using progressive validation for hyperparameter tuning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sieve.sgd.solver(sieve.model, X, Y, cv_weight_rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sieve.model</code></td>
<td>
<p>a list initiated using sieve.sgd.preprocess. Check the documentation of sieve.sgd.preprocess for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a data frame containing prediction features/ independent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>training outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_weight_rate</code></td>
<td>
<p>this governs the divergence rate of rolling validation statistics. Default is set to be 1 and in general does not need to be changed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list. It contains the fitted regression coefficients and progressive validation statistics for each hyperparameter combination.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s.size.sofar</code></td>
<td>
<p>a number. Number of samples has been processed so far.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a string. The type of basis funtion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyper.para.list</code></td>
<td>
<p>a list of hyperparameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.matrix</code></td>
<td>
<p>a matrix. Identifies the multivariate basis functions used in fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.row.prod</code></td>
<td>
<p>the index product for each basis function. It is used in calculating basis function - specific learning rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inf.list</code></td>
<td>
<p>a list storing the fitted results. It has a length of "number of unique combinations of the hyperparameters". The component of inf.list is itself a list, it has a hyper.para.index domain to specify its corresponding hyperparameters (need to be used together with hyper.para.list). Its rolling.cv domain is the progressive validation statistics for hyperparameter tuning; beta.f is the regression coefficients for the first length(beta.f) basis functions, the rest of the basis have 0 coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_para</code></td>
<td>
<p>a matrix. It records how each dimension of the feature/predictor is rescaled, which is useful when rescaling the testing sample's predictors.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">frho.para &lt;- xdim &lt;- 1 ##predictor dimension
frho &lt;- 'additive' ###truth is a sum of absolute functions 
type &lt;- 'cosine' ###use cosine functions as the basis functions
#generate training data
TrainData &lt;- GenSamples(s.size = 1e3, xdim = xdim, 
                                frho.para = frho.para, 
                                frho = frho, noise.para = 0.1)
#preprocess the model
sieve.model &lt;- sieve.sgd.preprocess(X = TrainData[,2:(xdim+1)], 
                                    type = type,
                                    s = c(1,2),
                                    r0 = c(0.5, 2, 4),
                                    J = c(1, 4, 8))

##train the model
sieve.model &lt;- sieve.sgd.solver(sieve.model = sieve.model, 
                                X = TrainData[,2:(xdim+1)], 
                                Y  = TrainData[,1])

##sieve-SGD can do multiple passes over the data, just like other SGD methods.
##usually a second pass can still improve the prediction accuracy
##watch out overfitting when performing multiple passes!
sieve.model &lt;- sieve.sgd.solver(sieve.model = sieve.model, 
                              X = TrainData[,2:(xdim+1)], 
                              Y  = TrainData[,1])
</code></pre>


</div>