<div class="container">

<table style="width: 100%;"><tr>
<td>st_join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>spatial join, spatial filter</h2>

<h3>Description</h3>

<p>spatial join, spatial filter
</p>


<h3>Usage</h3>

<pre><code class="language-R">st_join(x, y, join, ...)

## S3 method for class 'sf'
st_join(
  x,
  y,
  join = st_intersects,
  ...,
  suffix = c(".x", ".y"),
  left = TRUE,
  largest = FALSE
)

st_filter(x, y, ...)

## S3 method for class 'sf'
st_filter(x, y, ..., .predicate = st_intersects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>sf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>object of class <code>sf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join</code></td>
<td>
<p>geometry predicate function with the same profile as st_intersects; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for <code>st_join</code>: arguments passed on to the <code>join</code> function or to <code>st_intersection</code> when <code>largest</code> is <code>TRUE</code>; for <code>st_filter</code> arguments passed on to the <code>.predicate</code> function, e.g. <code>prepared</code>, or a pattern for st_relate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>length 2 character vector; see merge</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>logical; if <code>TRUE</code> return the left join, otherwise an inner join; see details.
see also left_join</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>largest</code></td>
<td>
<p>logical; if <code>TRUE</code>, return <code>x</code> features augmented with the fields of <code>y</code> that have the largest overlap with each of the features of <code>x</code>; see https://github.com/r-spatial/sf/issues/578</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.predicate</code></td>
<td>
<p>geometry predicate function with the same profile as st_intersects; see details</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>alternative values for argument <code>join</code> are:
</p>

<ul>
<li> <p>st_contains_properly,
</p>
</li>
<li> <p>st_contains,
</p>
</li>
<li> <p>st_covered_by,
</p>
</li>
<li> <p>st_covers,
</p>
</li>
<li> <p>st_crosses,
</p>
</li>
<li> <p>st_disjoint,
</p>
</li>
<li> <p>st_equals_exact,
</p>
</li>
<li> <p>st_equals,
</p>
</li>
<li> <p>st_is_within_distance,
</p>
</li>
<li> <p>st_nearest_feature,
</p>
</li>
<li> <p>st_overlaps,
</p>
</li>
<li> <p>st_touches,
</p>
</li>
<li> <p>st_within,
</p>
</li>
<li> <p>st_relate (which will require <code>pattern</code> to be set),
</p>
</li>
<li>
<p> or any user-defined function of the same profile as the above
</p>
</li>
</ul>
<p>A left join returns all records of the <code>x</code> object with <code>y</code> fields for non-matched records filled with <code>NA</code> values; an inner join returns only records that spatially match.
</p>
<p>To replicate the results of <code>st_within(x, y)</code> you will need to use <code>st_join(x, y, join = "st_within", left = FALSE)</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sf</code>, joined based on geometry
</p>


<h3>Examples</h3>

<pre><code class="language-R">a = st_sf(a = 1:3,
 geom = st_sfc(st_point(c(1,1)), st_point(c(2,2)), st_point(c(3,3))))
b = st_sf(a = 11:14,
 geom = st_sfc(st_point(c(10,10)), st_point(c(2,2)), st_point(c(2,2)), st_point(c(3,3))))
st_join(a, b)
st_join(a, b, left = FALSE)
# two ways to aggregate y's attribute values outcome over x's geometries:
st_join(a, b) %&gt;% aggregate(list(.$a.x), mean)
if (require(dplyr, quietly = TRUE)) {
 st_join(a, b) %&gt;% group_by(a.x) %&gt;% summarise(mean(a.y))
}
# example of largest = TRUE:
nc &lt;- st_transform(st_read(system.file("shape/nc.shp", package="sf")), 2264)                
gr = st_sf(
    label = apply(expand.grid(1:10, LETTERS[10:1])[,2:1], 1, paste0, collapse = " "),
    geom = st_make_grid(st_as_sfc(st_bbox(nc))))
gr$col = sf.colors(10, categorical = TRUE, alpha = .3)
# cut, to check, NA's work out:
gr = gr[-(1:30),]
nc_j &lt;- st_join(nc, gr, largest = TRUE)
# the two datasets:
opar = par(mfrow = c(2,1), mar = rep(0,4))
plot(st_geometry(nc_j))
plot(st_geometry(gr), add = TRUE, col = gr$col)
text(st_coordinates(st_centroid(gr)), labels = gr$label)
# the joined dataset:
plot(st_geometry(nc_j), border = 'black', col = nc_j$col)
text(st_coordinates(st_centroid(nc_j)), labels = nc_j$label, cex = .8)
plot(st_geometry(gr), border = 'green', add = TRUE)
par(opar)
# st_filter keeps the geometries in x where .predicate(x,y) returns any match in y for x
st_filter(a, b)
# for an anti-join, use the union of y
st_filter(a, st_union(b), .predicate = st_disjoint)
</code></pre>


</div>