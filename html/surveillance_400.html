<div class="container">

<table style="width: 100%;"><tr>
<td>twinstim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a Two-Component Spatio-Temporal Point Process Model
</h2>

<h3>Description</h3>

<p>A <code>twinstim</code> model as described in Meyer et al. (2012) is fitted to
marked spatio-temporal point process data. This constitutes a
regression approach for conditional intensity function modelling.
The implementation is illustrated in Meyer et al. (2017, Section 3),
see <code>vignette("twinstim")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">twinstim(endemic, epidemic, siaf, tiaf, qmatrix = data$qmatrix, data,
         subset, t0 = data$stgrid$start[1], T = tail(data$stgrid$stop,1),
         na.action = na.fail, start = NULL, partial = FALSE,
         epilink = "log", control.siaf = list(F = list(), Deriv = list()),
         optim.args = list(), finetune = FALSE,
         model = FALSE, cumCIF = FALSE, cumCIF.pb = interactive(),
         cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>endemic</code></td>
<td>

<p>right-hand side formula for the exponential (Cox-like
multiplicative) endemic component. May contain offsets (to be marked
by the special function <code>offset</code>).  If omitted or <code>~0</code>
there will be no endemic component in the model.  A type-specific
endemic intercept can be requested by including the term
<code>(1|type)</code> in the formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epidemic</code></td>
<td>

<p>formula representing the epidemic model for the event-specific
covariates (marks) determining infectivity. Offsets are not
implemented here. If omitted or <code>~0</code> there will be no epidemic
component in the model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>siaf</code></td>
<td>

<p>spatial interaction function. Possible specifications are:
</p>

<ul>
<li> <p><code>NULL</code> or missing, corresponding to
<code>siaf.constant()</code>, i.e. spatially homogeneous 
infectivity independent of the distance from the host
</p>
</li>
<li>
<p> a list as returned by <code>siaf</code> or, more commonly,
generated by a predefined interaction function such as
<code>siaf.gaussian</code> as in Meyer et al. (2012) or
<code>siaf.powerlaw</code> as in Meyer and Held (2014).
The latter requires unique event locations, possibly after random
tie-breaking (<code>untie</code>) or imputation of
interval-censored locations.
<code>siaf.exponential</code> is a simpler alternative.
</p>
</li>
<li>
<p> a numeric vector corresponding to the knots of a step
function, i.e. the same as <code>siaf.step(knots)</code>
</p>
</li>
</ul>
<p>If you run into “false convergence” with a non-constant
<code>siaf</code> specification, the numerical accuracy of the cubature
methods is most likely too low (see the <code>control.siaf</code>
argument).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiaf</code></td>
<td>

<p>temporal interaction function. Possible specifications are:
</p>

<ul>
<li> <p><code>NULL</code> or missing, corresponding to
<code>tiaf.constant()</code>, i.e. time-constant infectivity
</p>
</li>
<li>
<p> a list as returned by <code>tiaf</code> or by a
predefined interaction function such as
<code>tiaf.exponential</code>
</p>
</li>
<li>
<p> a numeric vector corresponding to the knots of a step
function, i.e. the same as <code>tiaf.step(knots)</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmatrix</code></td>
<td>

<p>square indicator matrix (0/1 or <code>FALSE</code>/<code>TRUE</code>) for
possible transmission between the event types. The matrix will be
internally converted to <code>logical</code>. Defaults to the <code class="reqn">Q</code> matrix
specified in <code>data</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an object of class <code>"epidataCS"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>an optional vector evaluating to logical indicating a subset of
<code>data$events</code> to keep. Missing values are
taken as <code>FALSE</code>. The expression is evaluated in the context of the
<code>data$events@data</code> <code>data.frame</code>, i.e. columns of this
<code>data.frame</code> may be referenced directly by name.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0, T</code></td>
<td>

<p>events having occurred during (-Inf;t0] are regarded as part of the
prehistory <code class="reqn">H_0</code> of the process. Only events that occurred in the
interval (t0; T] are considered in the likelihood.
The time point <code>t0</code> (<code>T</code>) must
be an element of <code>data$stgrid$start</code> (<code>data$stgrid$stop</code>).
The default time range covers the whole spatio-temporal grid
of endemic covariates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>how to deal with missing values in <code>data$events</code>? Do not use
<code>na.pass</code>. Missing values in the spatio-temporal grid
<code>data$stgrid</code> are not accepted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>a named vector of initial values for (a subset of) the parameters.
The names must conform to the conventions of <code>twinstim</code> to be
assigned to the correct model terms. For instance,
<code>"h.(Intercept)"</code> = endemic intercept,
<code>"h.I(start/365)"</code> = coefficient of a linear time
trend in the endemic component, <code>"h.factorB"</code> =
coefficient of the level B of the factor variable <code>factor</code> in
the endemic predictor, <code>"e.(Intercept)"</code> = epidemic intercept,
<code>"e.VAR"</code> = coefficient of the epidemic term <code>VAR</code>,
<code>"e.siaf.2"</code> = second <code>siaf</code> parameter,
<code>"e.tiaf.1"</code> = first <code>tiaf</code> parameter.
Elements which don't match any of the model parameters are ignored.
</p>
<p>Alternatively, <code>start</code> may also be a named list with elements
<code>"endemic"</code> or <code>"h"</code>, <code>"epidemic"</code> or <code>"e"</code>,
<code>"siaf"</code> or <code>"e.siaf"</code>, and <code>"tiaf"</code> or <code>"e.tiaf"</code>,
each of which containing a named numeric vector with the term labels
as names (i.e. without the prefix <code>"h."</code>, <code>"e."</code>, etc).
Thus, <code>start=list(endemic=c("(Intercept)"=-10))</code> is equivalent
to <code>start=c("h.(Intercept)"=-10)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>

<p>logical indicating if a partial likelihood similar to the approach
by Diggle et al. (2010) should be used (default is <code>FALSE</code>).
Note that the partial likelihood implementation is not well tested.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epilink</code></td>
<td>

<p>a character string determining the link function to be used for the
<code>epidemic</code> linear predictor of event marks. By default, the
log-link is used. The experimental alternative
<code>epilink = "identity"</code> (for use by <code>epitest</code>) does
not guarantee the force of infection to be positive. If this leads
to a negative total intensity (endemic + epidemic), the point
process is not well defined (the log-likelihood will be
<code>NaN</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.siaf</code></td>
<td>

<p>a list with elements <code>"F"</code> and <code>"Deriv"</code>, which are lists
of extra arguments passed to the functions <code>siaf$F</code> and
<code>siaf$Deriv</code>, respectively.<br>
These arguments control the accuracy of the cubature routines from
package <span class="pkg">polyCub</span> involved in non-constant <code>siaf</code>
specifications, e.g., the bandwidth of the midpoint rule
<code>polyCub.midpoint</code>, the number of Gaussian
quadrature points for <code>polyCub.SV</code>, or the relative
tolerance of <code>integrate</code> in <code>polyCub.iso</code>.<br>
For instance, <code>siaf.gaussian(F.adaptive = TRUE)</code> uses the
midpoint-cubature <code>polyCub.midpoint</code> with an
adaptive bandwidth of <code>eps=adapt*sd</code> to numerically integrate the
kernel <code class="reqn">f(\bold{s})</code>, and the default <code>adapt</code> value (0.1)
can be overwritten by setting <code>control.siaf$F$adapt</code>.
However, the default version <code>siaf.gaussian()</code>
as well as <code>siaf.powerlaw()</code> and friends use
<code>polyCub.iso</code> and thus accept control arguments for the
standard <code>integrate</code> routine (such as <code>rel.tol</code>)
via <code>control.siaf$F</code> and <code>control.siaf$Deriv</code>.<br>
This argument list is ignored in the case
<code>siaf=siaf.constant()</code> (which is the default if <code>siaf</code> is
unspecified).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.args</code></td>
<td>

<p>an argument list passed to <code>optim</code>, or <code>NULL</code>, in
which case no optimization will be performed
but the necessary functions will be returned in a list (similar to
what is returned if <code>model = TRUE</code>).
</p>
<p>Initial values for the parameters may be given as list element
<code>par</code> in the order <code>(endemic, epidemic, siaf, tiaf)</code>.
If no initial values are provided, crude estimates will be used for
the endemic intercept and the Gaussian kernel, -9 for the epidemic
intercept, and zeroes for the remaining parameters.
Any initial values given in the <code>start</code> argument
take precedence over those in <code>par</code>.
</p>
<p>Note that <code>optim</code> receives the negative log-likelihood for 
minimization (thus, if used, <code>optim.args$control$fnscale</code> should be
positive). The <code>hessian</code> argument defaults to <code>TRUE</code>, and
in the <code>control</code> list, <code>trace</code>ing is enabled with
<code>REPORT=1</code> by default. By setting
<code>optim.args$control$trace = 0</code>, all output from the
optimization routine is suppressed.
</p>
<p>For the <code>partial</code> likelihood, the analytic score function and
the Fisher information are not implemented and the default is to use
robust <code>method="Nelder-Mead"</code> optimization.
</p>
<p>There may be an extra component <code>fixed</code> in the
<code>optim.args</code> list, which determines which parameters should stick
to their initial values. This can be specified by a
logical vector of the same length as the <code>par</code> component, by an
integer vector indexing <code>par</code> or by a character vector following
the <code>twinstim</code> naming conventions. Furthermore, if
<code>isTRUE(fixed)</code>, then all parameters are fixed at their initial
values and no optimization is performed.
</p>
<p>Importantly, the <code>method</code> argument in the <code>optim.args</code>
list may also be <code>"nlminb"</code>, in 
which case the <code>nlminb</code> optimizer is used. This is also the
default for full likelihood inference.
In this case, not only the score function but also the
<em>expected</em> Fisher information can be used during optimization (as
estimated by what Martinussen and Scheike (2006, p. 64) call the
“optional variation process”, or see Rathbun (1996, equation
(4.7))). In our experience this gives better convergence than
<code>optim</code>'s methods.
For <code>method="nlminb"</code>, the following parameters of the
<code>optim.args$control</code> list may be named like for
<code>optim</code> and are renamed appropriately:
<code>maxit</code> (-&gt; <code>iter.max</code>), <code>REPORT</code> (-&gt; <code>trace</code>,
default: 1), <code>abstol</code> (-&gt; <code>abs.tol</code>), and
<code>reltol</code> (-&gt; <code>rel.tol</code>, default: <code>1e-6</code>).
For <code>nlminb</code>, a logical <code>hessian</code> argument (default:
<code>TRUE</code>) indicates if the negative <em>expected</em> Fisher
information matrix should be used as the Hessian during optimization
(otherwise a numerical approximation is used).
</p>
<p>Similarly, <code>method="nlm"</code> should also work but is not
recommended here.    
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finetune</code></td>
<td>

<p>logical indicating if a second maximisation should be performed with
robust Nelder-Mead <code>optim</code> using the resulting
parameters from the first maximisation as starting point. This
argument is only considered if <code>partial = FALSE</code> and the
default is to not conduct a second maximization (in most cases this
does not improve upon the MLE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>logical indicating if the model environment should be kept with the
result, which is required for
<code>intensityplot</code>s and
<code>R0(..., trimmed = FALSE)</code>.
Specifically, if <code>model=TRUE</code>, the return value will have the
evaluation environment set as its <code>environment</code>,
and the returned <code>functions</code> element will contain the
log-likelihood function (or partial log-likelihood function, if
<code>partial = TRUE</code>), and optionally the score and the expected
Fisher information functions (not for the partial likelihood, and
only if <code>siaf</code> and <code>tiaf</code> provide the necessary
derivatives).<br>
Note that fitted objects with a model environment might consume
quite a lot of memory since they contain the <code>data</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumCIF</code></td>
<td>

<p>logical (default: <code>FALSE</code>) indicating whether to
calculate the fitted cumulative ground intensity at event times.
This is the residual process, see <code>residuals.twinstim</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumCIF.pb</code></td>
<td>

<p>logical indicating if a progress bar should be shown
during the calculation of <code>cumCIF</code>. Defaults to do so in an
interactive <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> session, and will be <code>FALSE</code> if <code>cores != 1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>

<p>number of processes to use in parallel operation. By default
<code>twinstim</code> runs in single-CPU mode. Currently, only the
<span class="pkg">multicore</span>-type of parallel computing via forking is
supported, which is not available on Windows, see
<code>mclapply</code> in package <span class="pkg">parallel</span>.
Note that for a <span class="pkg">memoise</span>d <code>siaf.step</code> kernel,
<code>cores=1</code> is fixed internally since parallelization would slow
down model fitting significantly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical indicating if information should be printed during
execution. Defaults to <code>TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function performs maximum likelihood inference
for the additive-multiplicative spatio-temporal intensity model
described in Meyer et al. (2012). It uses <code>nlminb</code> as the
default optimizer and returns an object of class <code>"twinstim"</code>.
Such objects have <code>print</code>, <code>plot</code> and
<code>summary</code> methods.
The <code>summary</code> output can be converted via corresponding
<code>xtable</code> or
<code>toLatex</code> methods.
Furthermore, the usual accessor methods are implemented, including
<code>coef</code>, <code>vcov</code>, <code>logLik</code>,
<code>residuals</code>, and
<code>update</code>.
Additional functionality is provided by the <code>R0</code> and
<code>simulate</code> methods.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>"twinstim"</code>, which is a list with
the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>vector containing the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>value of the log-likelihood function at the MLE with a
logical attribute <code>"partial"</code> indicating if the partial
likelihood was used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>number of log-likelihood and score evaluations during
optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>either <code>TRUE</code> (if the optimizer converged) or a
character string containing a failure message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fisherinfo</code></td>
<td>
<p><em>expected</em> Fisher information evaluated at the
MLE. Only non-<code>NULL</code> for full likelihood inference
(<code>partial = FALSE</code>) and if spatial and temporal interaction
functions are provided with their derivatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fisherinfo.observed</code></td>
<td>
<p>observed Fisher information matrix
evaluated at the value of the MLE. Obtained as the negative Hessian.
Only non-<code>NULL</code> if <code>optim.args$method</code> is not
<code>"nlminb"</code> and if it was requested by setting
<code>hessian=TRUE</code> in <code>optim.args</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>fitted values of the conditional intensity function at the events.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fittedComponents</code></td>
<td>
<p>two-column matrix with columns <code>"h"</code> and
<code>"e"</code> containing the fitted values of the endemic and epidemic
components, respectively.<br>
(Note that <code>rowSums(fittedComponents) == fitted</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>fitted cumulative ground intensities at the event times.
Only non-<code>NULL</code> if <code>cumCIF = TRUE</code>.
This is the “residual process” of the model, see
<code>residuals.twinstim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R0</code></td>
<td>
<p>estimated basic reproduction number for each event. This
equals the spatio-temporal integral of the epidemic intensity over
the observation domain (t0;T] x W for each event.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npars</code></td>
<td>
<p>vector describing the lengths of the 5 parameter
subvectors: endemic intercept(s) <code class="reqn">\beta_0(\kappa)</code>, endemic
coefficients <code class="reqn">\beta</code>, epidemic coefficients <code class="reqn">\gamma</code>,
parameters of the <code>siaf</code> kernel, and parameters of the
<code>tiaf</code> kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmatrix</code></td>
<td>
<p>the <code>qmatrix</code> associated with the epidemic
<code>data</code> as supplied in the model call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bbox</code></td>
<td>
<p>the bounding box of <code>data$W</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeRange</code></td>
<td>
<p>the time range used for fitting: <code>c(t0,T)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a list containing the four main parts of the model
specification: <code>endemic</code>, <code>epidemic</code>, <code>siaf</code>, and
<code>tiaf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>a record of the levels of the factors used in fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.siaf</code></td>
<td>
<p>see the “Arguments” section above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.args</code></td>
<td>
<p>input optimizer arguments used to determine the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>functions</code></td>
<td>
<p>if <code>model=TRUE</code> this is a <code>list</code> with
components <code>ll</code>, <code>sc</code> and <code>fi</code>, which are functions
evaluating the log-likelihood, the score function and the expected
Fisher information for a parameter vector <code class="reqn">\theta</code>. The
<code>environment</code> of these function is the model environment, which
is thus retained in the workspace if <code>model=TRUE</code>. Otherwise,
the <code>functions</code> component is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runtime</code></td>
<td>
<p>the <code>proc.time</code>-queried time taken
to fit the model, i.e., a named numeric vector of length 5 of class
<code>"proc_time"</code>, with the number of <code>cores</code> set as
additional attribute.</p>
</td>
</tr>
</table>
<p>If <code>model=TRUE</code>, the model evaluation environment is assigned to
this list and can thus be queried by calling <code>environment()</code> on
the result.
</p>


<h3>Note</h3>

<p><code>twinstim</code> makes use of the <span class="pkg">memoise</span> package if it is
available – and that is highly recommended for non-constant
<code>siaf</code> specifications to speed up calculations. Specifically, the
necessary numerical integrations of the spatial interaction function
will be cached such that they are only calculated once for every
state of the <code>siaf</code> parameters during optimization.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>
<p>Contributions to this documentation by
Michael Höhle and Mayeul Kauffmann.
</p>


<h3>References</h3>

<p>Diggle, P. J., Kaimi, I. &amp; Abellana, R. (2010):
Partial-likelihood analysis of spatio-temporal point-process data.
<em>Biometrics</em>, <b>66</b>, 347-354.
</p>
<p>Martinussen, T. and Scheike, T. H. (2006):
Dynamic Regression Models for Survival Data.
Springer.
</p>
<p>Meyer, S. (2010):
Spatio-Temporal Infectious Disease Epidemiology based on Point Processes.
Master's Thesis, Ludwig-Maximilians-Universität
München.<br>
Available as <a href="https://epub.ub.uni-muenchen.de/11703/">https://epub.ub.uni-muenchen.de/11703/</a>
</p>
<p>Meyer, S., Elias, J. and Höhle, M. (2012):
A space-time conditional intensity model for invasive meningococcal
disease occurrence. <em>Biometrics</em>, <b>68</b>, 607-616.
<a href="https://doi.org/10.1111/j.1541-0420.2011.01684.x">doi:10.1111/j.1541-0420.2011.01684.x</a>
</p>
<p>Meyer, S. and Held, L. (2014):
Power-law models for infectious disease spread.
<em>The Annals of Applied Statistics</em>, <b>8</b> (3), 1612-1639.
<a href="https://doi.org/10.1214/14-AOAS743">doi:10.1214/14-AOAS743</a>
</p>
<p>Meyer, S., Held, L. and Höhle, M. (2017):
Spatio-temporal analysis of epidemic phenomena using the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package
<span class="pkg">surveillance</span>.
<em>Journal of Statistical Software</em>, <b>77</b> (11), 1-55.
<a href="https://doi.org/10.18637/jss.v077.i11">doi:10.18637/jss.v077.i11</a>
</p>
<p>Rathbun, S. L. (1996):
Asymptotic properties of the maximum likelihood estimator for
spatio-temporal point processes.
<em>Journal of Statistical Planning and Inference</em>, <b>51</b>, 55-74.
</p>


<h3>See Also</h3>

<p><code>vignette("twinstim")</code>.
</p>
<p>There is a <code>simulate.twinstim</code> method,
which simulates the point process based on the fitted <code>twinstim</code>.
</p>
<p>A discrete-space alternative is offered by the <code>twinSIR</code>
modelling framework.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load invasive meningococcal disease data
data("imdepi")


### first, fit a simple endemic-only model

m_noepi &lt;- twinstim(
    endemic = addSeason2formula(~ offset(log(popdensity)) + I(start/365-3.5),
                                S=1, period=365, timevar="start"),
    data = imdepi, subset = !is.na(agegrp)
)

## look at the model summary
summary(m_noepi)

## there is no evidence for a type-dependent endemic intercept (LR test)
m_noepi_type &lt;- update(m_noepi, endemic = ~(1|type) + .)
pchisq(2*c(logLik(m_noepi_type)-logLik(m_noepi)), df=1, lower.tail=FALSE)


### add an epidemic component with just the intercept, i.e.
### assuming uniform dispersal in time and space up to a distance of
### eps.s = 200 km and eps.t = 30 days (see summary(imdepi))

m0 &lt;- update(m_noepi, epidemic=~1, model=TRUE)

## summarize the model fit
summary(m0, correlation = TRUE, symbolic.cor = TRUE)

## the default confint-method can be used for Wald-CI's
confint(m0, level=0.95)

## same "untrimmed" R0 for every event (simple epidemic intercept model)
summary(R0(m0, trimmed=FALSE))

## plot the path of the fitted total intensity
plot(m0, "total intensity", tgrid=500)

if (surveillance.options("allExamples")) {
## extract "residual process" integrating over space (takes some seconds)
res &lt;- residuals(m0)
# if the model describes the true CIF well _in the temporal dimension_,
# then this residual process should behave like a stationary Poisson
# process with intensity 1
plot(res, type="l"); abline(h=c(0, length(res)), lty=2)
# easier, with CI and serial correlation:
checkResidualProcess(m0)
}

## Not run: 
  ## NB: in contrast to nlminb(), optim's BFGS would miss the
  ##     likelihood maximum wrt the epidemic intercept
  m0_BFGS &lt;- update(m_noepi, epidemic=~1, optim.args = list(method="BFGS"))
  format(cbind(nlminb=coef(m0), BFGS=coef(m0_BFGS)), digits=3, scientific=FALSE)
  m0_BFGS$fisherinfo   # singular Fisher information matrix here
  m0$fisherinfo
  logLik(m0_BFGS)
  logLik(m0)
  ## nlminb is more powerful since we make use of the analytical fisherinfo
  ## as estimated by the model during optimization, which optim cannot

## End(Not run)


### an epidemic-only model?
## for a purely epidemic model, all events must have potential source events
## (otherwise the intensity at the observed event would be 0)

## let's focus on the C-type for this example
imdepiC &lt;- subset(imdepi, type == "C")
table(summary(imdepiC)$nSources)
## 106 events have no prior, close events (in terms of eps.s and eps.t)
try(twinstim(epidemic = ~1, data = imdepiC))  # detects this problem
## let's assume spatially unbounded interaction
imdepiC_infeps &lt;- update(imdepiC, eps.s = Inf)
(s &lt;- summary(imdepiC_infeps))
table(s$nSources)
## for 11 events, there is no prior event within eps.t = 30 days
## (which is certainly true for the first event)
plot(s$counter, main = "Number of infectious individuals over time (eps.t = 30)")
rug(imdepiC_infeps$events$time)
rug(imdepiC_infeps$events$time[s$nSources == 0], col = 2, lwd = 3)
## An endemic component would catch such events (from unobserved sources),
## otherwise a longer infectious period would need to be assumed and
## for the first event to happen, a prehistory is required (e.g., t0 = 31).
## As an example, we fit the data only until T = 638 (all events have ancestors)
m_epi &lt;- twinstim(epidemic = ~1, data = imdepiC_infeps, t0 = 31, T = 638)
summary(m_epi)


if (surveillance.options("allExamples")) withAutoprint({

### full model with interaction functions (time-consuming)
## estimate an exponential temporal decay of infectivity
m1_tiaf &lt;- update(m0, tiaf=tiaf.exponential())
plot(m1_tiaf, "tiaf", scaled=FALSE)

## estimate a step function for spatial interaction
summary(sourceDists &lt;- getSourceDists(imdepi, "space"))
(knots &lt;- quantile(sourceDists, c(5,10,20,40)/100))
m1_fstep &lt;- update(m0, siaf=knots)
plot(m1_fstep, "siaf", scaled=FALSE)
rug(sourceDists, ticksize=0.02)

## estimate a continuously decreasing spatial interaction function,
## here we use the kernel of an isotropic bivariate Gaussian
m1 &lt;- update(m0, siaf = siaf.gaussian())
AIC(m_noepi, m0, m1_fstep, m1)
summary(m1)  # e.siaf.1 is log(sigma), no test for H0: log(sigma) = 0
exp(confint(m1, "e.siaf.1"))  # a confidence interval for sigma
plot(m1, "siaf", scaled=FALSE)
## alternative: siaf.powerlaw() with eps.s=Inf and untie()d data,
##              see vignette("twinstim")

## add epidemic covariates
m2 &lt;- update(m1, epidemic = ~ 1 + type + agegrp)
AIC(m1, m2)   # further improvement
summary(m2)
  
## look at estimated R0 values by event type
tapply(R0(m2), imdepi$events@data[names(R0(m2)), "type"], summary)

})
</code></pre>


</div>