<div class="container">

<table style="width: 100%;"><tr>
<td>recomb_fam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw recombination breaks for autosomes from a pedigree</h2>

<h3>Description</h3>

<p>Create random recombination breaks for all autosomes of all individuals in the provided pedigree FAM table.
Recombination lengths follow an exponential distribution with mean of 100 centiMorgans (cM).
The output specifies identical-by-descent (IBD) blocks as ranges per chromosome (per individual) and the founder chromosome they arose from (are IBD with).
All calculations are in terms of genetic distance (not base pairs), and no genotypes are constructed/drawn in this step.
</p>


<h3>Usage</h3>

<pre><code class="language-R">recomb_fam(founders, fam, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>founders</code></td>
<td>
<p>The named list of founders with their chromosomes.
For unstructured founders, initialize with <code>recomb_init_founders()</code>.
Each element of this list is a diploid individual, which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (always identified by number, but may also be named arbitrarily), each of which is a data.frame/tibble with implicit ranges (<code>posg</code> is end coordinates in cM; start is the end of the previous block, zero for the first block) and ancestors <code>anc</code> as strings.
For true founders each chromosome may be trivial (each chromosome is a single block with ID equal to itself but distinguishing maternal from paternal copy), but input itself can be recombined (for iterating).
This list must have names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>founders</code> but absent in <code>fam$id</code> will be silently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (‚Äù) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The list of individuals with recombined chromosomes of the entire <code>fam</code> table, in the same format as <code>founders</code> above.
The names of this list correspond to <code>fam$id</code> in that order.
</p>


<h3>See Also</h3>

<p><code>recomb_init_founders()</code> to initialize <code>founders</code> for this function.
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The smallest pedigree, two parents and a child.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while "child" does not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)

# initialize parents with this other function
# Name the parents with same codes as in `fam`
# (order can be different)
ids &lt;- c('mother', 'father')
# simulate three chromosomes with these lengths in cM
lengs &lt;- c(50, 100, 150)
founders &lt;- recomb_init_founders( ids, lengs )

# draw recombination breaks for the whole fam table now:
inds &lt;- recomb_fam( founders, fam )

# This is a length-3 list with names matching fam$id.
# The parent data equals the input (reordered),
# but now there's data to the child too
inds

</code></pre>


</div>