<div class="container">

<table style="width: 100%;"><tr>
<td>poisthin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply Poisson thinning to a matrix of count data.</h2>

<h3>Description</h3>

<p>This is now defunct. Please try out <code>select_counts</code> and
<code>thin_2group</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">poisthin(
  mat,
  nsamp = nrow(mat),
  ngene = ncol(mat),
  gselect = c("max", "random", "rand_max", "custom", "mean_max"),
  gvec = NULL,
  skip_gene = 0L,
  signal_fun = stats::rnorm,
  signal_params = list(mean = 0, sd = 1),
  prop_null = 1,
  alpha = 0,
  group_assign = c("frac", "random", "cor"),
  group_prop = 0.5,
  corvec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A matrix of count data. The rows index the individuals and
the columns index the genes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsamp</code></td>
<td>
<p>The number of samples to select from <code>mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngene</code></td>
<td>
<p>The number of genes to select from <code>mat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gselect</code></td>
<td>
<p>How should we select the subset of genes? Should we choose
the <code>ngene</code> most median expressed genes (<code>"max"</code>), a random sample
of the genes (<code>"random"</code>), a random sample of the most expressed
genes (<code>"rand_max"</code>), a user-provided list (<code>"custom"</code>), or by maximum
mean expression level (<code>"mean_max"</code>)?
If <code>"custom"</code>, then <code>gvec</code> should be specified. Expression levels
of a gene are measured by median expression across individuals with ties broken
by mean expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gvec</code></td>
<td>
<p>A logical of length <code>ncol(mat)</code>. A <code>TRUE</code> in position <code class="reqn">i</code>
indicates inclusion into the smaller dataset. Hence, <code>sum(gvec)</code> should
equal <code>ngene</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_gene</code></td>
<td>
<p>The number of maximally expressed genes to skip.
Not used if <code>gselect = "custom"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal_fun</code></td>
<td>
<p>A function that returns the signal. This should take as
input <code>n</code> for the number of samples to return and then return only
a vector of samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal_params</code></td>
<td>
<p>A list of additional arguments to pass to <code>signal_fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop_null</code></td>
<td>
<p>The proportion of genes that are null.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>If <code class="reqn">b</code> is an effect and <code class="reqn">s</code> is an empirical standard deviation, then
we model <code class="reqn">b/s^\alpha</code> as being exchangeable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_assign</code></td>
<td>
<p>How should we assign groups? Exactly specifying the
proportion of individuals in each group (<code>"frac"</code>), with a
Bernoulli distribution (<code>"random"</code>), or correlated with latent factors
(<code>"cor"</code>)? If <code>group_assign = "cor"</code>, then you have to specify
<code>corvec</code>. If <code>group_assign = "frac"</code> or
<code>group_assign = "random"</code>, then the proportion of samples in each
group is specified with the <code>group_prop</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_prop</code></td>
<td>
<p>The proportion of individuals that are in group 1.
This proportion is deterministic if <code>group_assign = "frac"</code>, and
is the expected proportion if <code>group_assign = "random"</code>. This
argument is not used if <code>group_assign = "cor"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corvec</code></td>
<td>
<p>A vector of correlations. <code>corvec[i]</code> is the correlation
of the latent group assignment vector with the ith latent confounder.
Only used if <code>group_assign = "cor"</code>. This vector is constrained
so that <code>crossprod(corvec) &lt; 1</code>. The number of latent factors
is taken to be the length of corvec. Note that the correlations of the
latent factors with the observed group-assignment vector (instead of the
latent group-assignment vector) will be <code>corvec * sqrt(2 / pi)</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a matrix of RNA-seq counts, this function will randomly select two groups of
samples and add signal to a known proportion of the genes. This signal
is the log (base 2) effect size of the group indicator in a linear model.
The user may specify the distribution of the effects.
</p>
<p>The Poisson thinning approach first randomly assigns samples to be in one of two groups. Then,
given this assignment, will Binomially sample counts with a sample size of the gene expression
counts and a probability that is a function of the effect size. For details, see
Gerard and Stephens (2021).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>Y</code></dt>
<dd>
<p>A matrix of altered counts with <code>nsamp</code> rows
and <code>ngene</code> columns.</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>A design matrix. The first column contains a vector ones (for an
intercept term) and the second column contains an indicator for group membership.</p>
</dd>
<dt><code>beta</code></dt>
<dd>
<p>The approximately true effect sizes of <code class="reqn">log(Y) ~ X\beta</code>.</p>
</dd>
<dt><code>corassign</code></dt>
<dd>
<p>The output from the call to <code>corassign</code>.
Only returned if <code>group_assign = "cor"</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul><li>
<p>Gerard, D., and Stephens, M. (2021). "Unifying and Generalizing Methods for Removing Unwanted Variation Based on Negative Controls." <em>Statistica Sinica</em>, 31(3), 1145-1166 <a href="https://doi.org/10.5705/ss.202018.0345">doi:10.5705/ss.202018.0345</a>.
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 10
ngene &lt;- 1000
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 50), nrow = ngene)


## Apply thinning
poisout &lt;- poisthin(mat           = t(Y),
                    nsamp         = 9,
                    ngene         = 999,
                    signal_fun    = stats::rnorm,
                    signal_params = list(mean = 0, sd = 1),
                    prop_null     = 0.9)

## Dimension of count matrix is smaller.
dim(poisout$Y)

## Can verify signal was added by estimating it with lm().
betahat &lt;- coef(lm(log2(poisout$Y + 1) ~ poisout$X[, 2]))[2, ]
plot(poisout$beta, betahat, xlab = "Coefficients", ylab = "Estimates")
abline(0, 1, col = 2, lty = 2)

</code></pre>


</div>