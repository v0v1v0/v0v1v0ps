<div class="container">

<table style="width: 100%;"><tr>
<td>predict.sigfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicted probabilities and comparative statics for signaling games</h2>

<h3>Description</h3>

<p>This method uses a fitted model of class <code>sigfit</code> to compute
predicted probabilities or comparative statics. 
Users can provide either new data or a new parameters to generate 
counterfactuals of interest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sigfit'
predict(
  object,
  newdata,
  new.theta,
  type = c("actions", "outcomes"),
  na.action = na.pass,
  control = list(),
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted model of class <code>sigfit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>data frame of covariates used to produce the predicted probabilities.
If this is left empty, the entire original data set is used.
When <code>newdata</code> is specified, <code>new.theta</code> should be either missing (use the coefficients
from the <code>sigfit</code> object) or a one row data frame. See "Details" for more information.
As with other <code>predict</code> methods, variable names must match those used to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.theta</code></td>
<td>
<p>a data frame of alternative parameters for comparative statics.
When missing, the coefficients from the <code>object</code> are used.
When specified, each row should be a complete parameter vector. 
If <code>new.theta</code> is specified, then <code>newdata</code> must be a data frame with only one row.
Unlike other <code>predict</code> methods, column names do not matter here.
Instead, the columns must be the same order as the coefficients in <code>object</code>.
See "Details" and "Examples" for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>whether to provide probabilities over actions 
(default, returns <code class="reqn">p_C</code>, <code class="reqn">p_R</code>, and <code class="reqn">p_F</code>) 
or outcomes (returns <code class="reqn">SQ</code>, <code class="reqn">CD</code>, <code class="reqn">SF</code>, and  <code class="reqn">BD</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>how to deal with <code>NA</code>s in <code>newdata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of options describing the grid search method. See "Details" for more information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. Should the comparative statics be computed in parallel, requires the
<code>parallel</code>
package be installed. Parallelization is done using <code>parSapply</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments (not currently used)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is used to consider comparative statics in the crisis signaling game.
The model of interest is fit using <code>sigint</code>.
How this function behaves largely depends on  how <code>newdata</code> and <code>new.theta</code> are
specified.
</p>
<p>When both <code>newdata</code> and <code>new.theta</code> are missing, all equilibria for every
observation used to fit the model are computed.
These equilibria are then used to calculated either choice probabilities (default,
<code>type = "action"</code>) the distribution over outcomes (<code>type = "outcomes"</code>).
</p>
<p>When only <code>newdata</code> is specified, then all equilibria are computed using the
data frame in <code>newdata</code> and the coefficients from <code>object</code>. This produces
standard comparative statics with respect to observed covariates.
</p>
<p>When <code>newdata</code> is specified and <code>new.theta</code> is a one row data frame,
then all equilibria are computed using the data frame in <code>newdata</code> and the
coefficients from <code>new.theta</code>.
</p>
<p>When <code>newdata</code> is a one row data frame and <code>new.theta</code> is specified,
then all equilibria are computed using the data frame in <code>newdata</code> and the
coefficients from <code>new.theta</code>. This is a comparative static on changing a
structural parameter in the model.
</p>
<p>If <code>new.theta</code> has more than one row, then <code>newdata</code> must be specified as a
data frame with only one row.  Anything else returns an error.
</p>
<p>Equilibria are computed using a line search method.
The <code>control</code> argument allows for user control over this process.
Users can specify a list with the following named elements
</p>

<dl>
<dt>gridsize</dt>
<dd>
<p>Integer. The number of points considered in the line search (default, 1e4).
More points makes it more likely that all equilibria are discovered, but can slow down the
search. </p>
</dd>
<dt>comp</dt>
<dd>
<p>Logical. Should an equilibrium be computed when discovered?
When <code>comp = FALSE</code> (default), the mean of the grid points surrounding the
equilibrium is used as an approximate solution.
When <code>comp = TRUE</code> the function <code>uniroot</code>
is called to find a more precise solution to the equilibrium constraint problem.</p>
</dd>
<dt>tol</dt>
<dd>
<p>Numeric. When <code>comp = TRUE</code>, this is the tolerance used by
<code>uniroot</code></p>
</dd>
</dl>
<p>.

</p>
<p>When dealing with a larger problem, such as computing all equilibria for every observation,
it can be helpful to parallelize process.  If the user has the
(suggested) <code>parallel</code> package, then the option <code>parallel = TRUE</code>
will use the function <code>parSapply</code> is used.
</p>


<h3>Value</h3>

<p>An object of class <code>sigProb</code> containing three elements:
</p>

<dl>
<dt><code>predicted</code></dt>
<dd>
<p>data frame of predicted probabilities. The first column of this data frame is 
called <code>Row</code>, which corresponds to the rows in either <code>model</code> or <code>par</code>.
In the event of multiple equilibria, this column allows for mapping data and parameters to 
all computed equilibria.
</p>
</dd>
<dt><code>model</code></dt>
<dd>
<p>data frame of covariates used to produce the predicted probabilities.</p>
</dd>
<dt><code>par</code></dt>
<dd>
<p>data frame of parameters used to produce the predicted probabilities.</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>plot.sigProb</code>, <code>generate.eq</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(sanctionsData)

f1 &lt;- sq+cd+sf+bd ~ sqrt(senderecondep) + senderdemocracy + contig + ally -1|#SA
                    anticipatedsendercosts|#VA
                    sqrt(targetecondep) + anticipatedtargetcosts + contig + ally|#CB
                    sqrt(senderecondep) + senderdemocracy + lncaprat | #barWA
                    targetdemocracy + lncaprat| #barWB
                    senderdemocracy| #bara
                    -1#VB
## Using Nested-Pseudo Likelihood  with default first stage    
## Not run:              
fit1 &lt;- sigint(f1, data=sanctionsData, npl.trace=TRUE)
p.out &lt;- predict(fit2, parallel=TRUE) #fitted choice probabilites for all observations

## End(Not run)

## Outcome probabilities for first five using PL method
Phat &lt;- list(PRhat=sanctionsData$PRhat, PFhat=sanctionsData$PFhat)
fit2 &lt;- sigint(f1, data=sanctionsData, method="pl", phat=Phat)
p1 &lt;- predict(fit2, newdata=sanctionsData[1:5,], type="outcome")

## comparative static on \bar{a}, compute more precise equilibria with uniroot
new.theta &lt;- data.frame(t(replicate(25, coef(fit2))))
new.theta[,19] &lt;- seq(-6, 0, length=25)
p2 &lt;- predict(fit2, newdata=sanctionsData[1,], new.theta=new.theta, control=list(comp=TRUE))


</code></pre>


</div>