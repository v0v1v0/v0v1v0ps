<div class="container">

<table style="width: 100%;"><tr>
<td>som.nn.continue</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Continue hexagonal som training</h2>

<h3>Description</h3>

<p>An existing self-organising map with hexagonal tolology is further trained and
a model created for prediction of unknown samples.
In contrast to a "normal" som, class-labels for all samples of
the training set are required to build the model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">som.nn.continue(
  model,
  x,
  kernel = "internal",
  len = 0,
  alpha = 0.2,
  radius = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model of type <code>SOMnn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data.fame with training data. Samples are requested as rows and taken randomly for the
training steps. All
columns except of the class lables are considered to be attributes and parts of
the training vector.
<code>x</code> must include the same columns as the data.frame with which the model
have been trained originally.
One column is needed as class labels. The column with class
lables is selected by the slot <code>class.idx</code> of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>Kernel for som training. One of the predefined kernels
<code>"bubble"</code> and <code>"gaussian"</code> == train with the R-implementation or
<code>"SOM"</code> == train with <code>SOM</code> or
<code>"kohonen"</code> == train with <code>som</code> (<code>kohonen::som</code>) or
<code>"som"</code> == train with <code>som</code> (<code>som::som</code>).
If a function is specified (as closure, not as character)
the specified custom function is used for training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>number of steps to be trained (steps - not epochs!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>initial training rate; default 0.02.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>inital radius for SOM training.
If Gaussian distance function is used, radius corresponds to sigma.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Any specified custom kernel function is used for som training. The function must match the
signature <code>kernel(data, grid, rlen, alpha, radius, init, toroidal)</code>, with
arguments:
</p>

<ul>
<li> <p><code>data</code> <code>numeric</code> matrix of training data; one sample per row
</p>
</li>
<li> <p><code>classes:</code> optional <code>charater</code> vector of classes for training data
</p>
</li>
<li> <p><code>grid</code> somgrid, generated with <code>somgrid</code>
</p>
</li>
<li> <p><code>rlen</code> number of training steps
</p>
</li>
<li> <p><code>alpha</code> training rate
</p>
</li>
<li> <p><code>radius</code> training radius
</p>
</li>
<li> <p><code>init</code> <code>numeric</code> matrix of initial codebook vectors; one code per row
</p>
</li>
<li> <p><code>toroidal</code> <code>logical</code>; TRUE, if the topology of grid is toroidal
</p>
</li>
</ul>
<p>The returned value must be a list with at minimum one element
</p>

<ul><li> <p><code>codes:</code> <code>numeric</code> matrix of result codebook vectors; one code per row
</p>
</li></ul>
<h3>Value</h3>

<div class="sourceCode"><pre>    S4 object of type \code{\link{SOMnn}} with the trained model
</pre></div>


<h3>Examples</h3>

<pre><code class="language-R">## get example data and add class labels:
data(iris)
species &lt;- iris$Species

## train with default radius = diagonal / 2:
rlen &lt;- 500
som &lt;- som.nn.train(iris, class.col = "Species", kernel = "internal",
                    xdim = 15, ydim = 9, alpha = 0.2, len = rlen, 
                    norm = TRUE, toroidal = FALSE)


## continue training with different alpha and radius;
som &lt;- som.nn.continue(som, iris, alpha = 0.02, len=500, radius = 5)
som &lt;- som.nn.continue(som, iris, alpha = 0.02, len=500, radius = 2)

## predict some samples:
unk &lt;- iris[,!(names(iris) %in% "Species")]

setosa &lt;- unk[species=="setosa",]
setosa &lt;- setosa[sample(nrow(setosa), 20),]

versicolor &lt;- unk[species=="versicolor",]
versicolor &lt;- versicolor[sample(nrow(versicolor), 20),]

virginica &lt;- unk[species=="virginica",]
virginica &lt;- virginica[sample(nrow(virginica), 20),]

p &lt;- predict(som, unk)
head(p)

## plot:
plot(som)
dev.off()
plot(som, predict = predict(som, setosa))
plot(som, predict = predict(som, versicolor), add = TRUE, pch.col = "magenta", pch = 17)
plot(som, predict = predict(som, virginica), add = TRUE, pch.col = "white", pch = 8)

</code></pre>


</div>