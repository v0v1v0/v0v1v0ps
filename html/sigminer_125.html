<div class="container">

<table style="width: 100%;"><tr>
<td>sig_fit_bootstrap_batch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Exposure Instability Analysis of Signature Exposures with Bootstrapping</h2>

<h3>Description</h3>

<p>Read sig_fit_bootstrap for more option setting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sig_fit_bootstrap_batch(
  catalogue_matrix,
  methods = c("QP"),
  n = 100L,
  min_count = 1L,
  p_val_thresholds = c(0.05),
  use_parallel = FALSE,
  seed = 123456L,
  job_id = NULL,
  result_dir = tempdir(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>catalogue_matrix</code></td>
<td>
<p>a numeric matrix <code>V</code> with row representing components and
columns representing samples, typically you can get <code>nmf_matrix</code> from <code>sig_tally()</code> and
transpose it by <code>t()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>
<p>a subset of <code>c("NNLS", "QP", "SA")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_count</code></td>
<td>
<p>minimal exposure in a sample, default is 1. Any patient has total exposure less
than this value will be filtered out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_val_thresholds</code></td>
<td>
<p>a vector of relative exposure threshold for calculating p values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel computation based on <strong>furrr</strong> package.
It can also be an integer for specifying cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>random seed to reproduce the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>job_id</code></td>
<td>
<p>a job ID, default is <code>NULL</code>, can be a string. When not <code>NULL</code>, all bootstrapped results
will be saved to local machine location defined by <code>result_dir</code>. This is very useful for running
more than 10 times for more than 100 samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result_dir</code></td>
<td>
<p>see above, default is temp directory defined by R.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other common parameters passing to sig_fit_bootstrap, including
<code>sig</code>, <code>sig_index</code>, <code>sig_db</code>, <code>db_type</code>, <code>mode</code>, <code>auto_reduce</code> etc.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>list</code> of <code>data.table</code>.
</p>


<h3>See Also</h3>

<p>sig_fit, sig_fit_bootstrap
</p>


<h3>Examples</h3>

<pre><code class="language-R"># For mutational signatures ----------------
# SBS is used for illustration, similar
# operations can be applied to DBS, INDEL, CN, RS, etc.

# Load simulated data
data("simulated_catalogs")
data = simulated_catalogs$set1
data[1:5, 1:5]

# Fitting with COSMIC reference signatures

# Generally set n = 100
rv = sig_fit_bootstrap_batch(data,
  sig_index = c(1, 5, 9, 2, 13),
   sig_db = "SBS", n = 10)
rv


# For general purpose --------------------
W &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)
colnames(W) &lt;- c("sig1", "sig2")
W &lt;- apply(W, 2, function(x) x / sum(x))

H &lt;- matrix(c(2, 5, 3, 6, 1, 9, 1, 2), ncol = 4)
colnames(H) &lt;- paste0("samp", 1:4)

V &lt;- W %*% H
V

if (requireNamespace("quadprog")) {
  z10 &lt;- sig_fit_bootstrap_batch(V, sig = W, n = 10)
  z10
}
</code></pre>


</div>