<div class="container">

<table style="width: 100%;"><tr>
<td>pco_sropt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The 'confidence distribution' for maximal Sharpe ratio.</h2>

<h3>Description</h3>

<p>Distribution function and quantile function for the 'confidence
distribution' of the maximal Sharpe ratio. This is just an inversion
to perform inference on <code class="reqn">\zeta_*</code> given observed statistic 
<code class="reqn">z_*</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pco_sropt(q,df1,df2,z.s,ope,lower.tail=TRUE,log.p=FALSE) 

qco_sropt(p,df1,df2,z.s,ope,lower.tail=TRUE,log.p=FALSE,lb=0,ub=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df1</code></td>
<td>
<p>the number of assets in the portfolio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df2</code></td>
<td>
<p>the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.s</code></td>
<td>
<p>an observed Sharpe ratio statistic, annualized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ope</code></td>
<td>
<p>the number of observations per 'epoch'. For convenience of
interpretation, The Sharpe ratio is typically quoted in 'annualized' 
units for some epoch, that is, 'per square root epoch', though returns 
are observed at a frequency of <code>ope</code> per epoch. 
The default value is 1, meaning the code will not attempt to guess
what the observation frequency is, and no annualization adjustments
will be made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as <code class="reqn">\mbox{log}(p)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>the lower bound for the output of <code>qco_sropt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>the upper bound for the output of <code>qco_sropt</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose <code class="reqn">z_*</code> follows a <em>Maximal Sharpe ratio</em> distribution
(see <code>SharpeR-package</code>) for known degrees of freedom, and 
unknown non-centrality parameter <code class="reqn">\zeta_*</code>. The 
'confidence distribution' views <code class="reqn">\zeta_*</code> as a random
quantity once <code class="reqn">z_*</code> is observed. As such, the CDF of
the confidence distribution is the same as that of the 
Maximal Sharpe ratio (up to a flip of <code>lower.tail</code>);
while the quantile function is used to compute confidence
intervals on <code class="reqn">\zeta_*</code> given <code class="reqn">z_*</code>.
</p>


<h3>Value</h3>

<p><code>pco_sropt</code> gives the distribution function, and
<code>qco_sropt</code> gives the quantile function.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>When <code>lower.tail</code> is true, <code>pco_sropt</code> is monotonic increasing 
with respect to <code>q</code>, and decreasing in <code>sropt</code>; these are reversed
when <code>lower.tail</code> is false. Similarly, <code>qco_sropt</code> is increasing
in <code>sign(as.double(lower.tail) - 0.5) * p</code> and
<code>- sign(as.double(lower.tail) - 0.5) * sropt</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>reannualize</code>
</p>
<p><code>dsropt,psropt,qsropt,rsropt</code>
</p>
<p>Other sropt: 
<code>as.sropt()</code>,
<code>confint.sr()</code>,
<code>dsropt()</code>,
<code>is.sropt()</code>,
<code>power.sropt_test()</code>,
<code>reannualize()</code>,
<code>sropt_test()</code>,
<code>sropt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
zeta.s &lt;- 2.0
ope &lt;- 253
ntest &lt;- 50
df1 &lt;- 4
df2 &lt;- 6 * ope
rvs &lt;- rsropt(ntest,df1=df1,df2=df2,zeta.s=zeta.s)
qvs &lt;- seq(0,10,length.out=51)
pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope)

if (require(txtplot))
 txtplot(qvs,pps)

pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope,lower.tail=FALSE)

if (require(txtplot))
 txtplot(qvs,pps)


svs &lt;- seq(0,4,length.out=51)
pps &lt;- pco_sropt(2,df1,df2,svs,ope)
pps &lt;- pco_sropt(2,df1,df2,svs,ope,lower.tail=FALSE)

pps &lt;- pco_sropt(qvs,df1,df2,rvs[1],ope,lower.tail=FALSE)
pco_sropt(-1,df1,df2,rvs[1],ope)

qvs &lt;- qco_sropt(0.05,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
qvs &lt;- qco_sropt(0.5,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
qvs &lt;- qco_sropt(0.95,df1=df1,df2=df2,z.s=rvs)
mean(qvs &gt; zeta.s)
# test vectorization:
qv &lt;- qco_sropt(0.1,df1,df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),df1,df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),c(df1,2*df1),df2,rvs)
qv &lt;- qco_sropt(c(0.1,0.2),c(df1,2*df1),c(df2,2*df2),rvs)

</code></pre>


</div>