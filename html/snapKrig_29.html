<div class="container">

<table style="width: 100%;"><tr>
<td>sk_nLL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Negative log-likelihood for parameter vector <code>p</code>
</h2>

<h3>Description</h3>

<p>Returns the negative log-likelihood of covariance model <code>pars_fix</code>, given the observations
in data grid <code>g_obs</code>. Parameter values are copied from the first argument, vector <code>p</code>, so
that the function can be passed to numerical optimizers (etc).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_nLL(p, g_obs, pars_fix, X = 0, iso = FALSE, quiet = TRUE, log_scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>numeric vector of covariance parameters accepted by <code>sk_pars_update</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g_obs</code></td>
<td>
<p>sk object or list with entries 'gdim', 'gres', 'gval'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars_fix</code></td>
<td>
<p>list of form returned by <code>sk_pars</code> (with entries 'y', 'x', 'eps', 'psill')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>numeric, vector, matrix, or NA, the mean or its linear predictors, passed to <code>sk_LL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iso</code></td>
<td>
<p>logical, indicates to use identical kernels for x and y (<code>pars$x</code> is ignored)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical indicating to suppress console output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_scale</code></td>
<td>
<p>logical, indicates that <code>pars_fix</code> contains log-parameter values</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a wrapper for <code>sk_LL</code> (times -1) that allows parameters to be passed as a numeric
vector instead of a list. Parameters in <code>p</code> are copied to <code>pars_fix</code> and passed to the
likelihood computer.
</p>
<p><code>p</code> is the vector of covariance parameters to test. Names in <code>p</code> are ignored; Its length
and order should correspond with the pattern of NAs in <code>pars_fix</code>. Users should check that
the desired parameter list is being constructed correctly by testing with:
<code>sk_pars_update(pars_fix, p, iso=iso, na_omit=TRUE)</code>.
</p>


<h3>Value</h3>

<p>numeric, the negative log-likelihood of <code>p</code> given data <code>g_obs</code>
</p>


<h3>See Also</h3>

<p>sk sk_GLS sk_var sk_pars_update
</p>
<p>Other likelihood functions: 
<code>sk_LL()</code>
</p>
<p>Other variance-related functions: 
<code>sk_GLS()</code>,
<code>sk_LL()</code>,
<code>sk_cmean()</code>,
<code>sk_sim()</code>,
<code>sk_var()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># set up example grid and data
g = sk(gdim=10, gval=stats::rnorm(10^2))

# get some default parameters and vectorize them
pars = sk_pars(g, 'gau')
p = sk_pars_update(pars)
sk_nLL(p, g, pars)

# change a parameter in the numeric vector and re-evaluate
p_compare = p
p_compare[1] = 2 * p_compare[1]
sk_nLL(p_compare, g, pars)

# repeat by calling sk_LL directly with modified parameters list
pars_compare = pars
pars_compare[['eps']] = 2 * pars_compare[['eps']]
-sk_LL(pars_compare, g)

# set up a subset of parameters to replace - eg when fitting those parameters
pars_fix = pars
pars_fix[['eps']] = NA
pars_fix[['y']][['kp']] = NA

# names in p_fit are for illustration only (only the order matters)
p_fit = c(eps=1, y.rho=1)

# replace NA parameter values in pars_fix to get completed parameters list
sk_pars_update(pars_fix, p_fit, na_omit=TRUE)

# make the replacement and evaluate likelihood in one call
sk_nLL(p_fit, g, pars_fix)

# equivalently:
pars_fit = pars
pars_fit[['eps']] = p_fit[1]
pars_fit[['y']][['kp']] = p_fit[2]
-sk_LL(pars_fit, g)

</code></pre>


</div>