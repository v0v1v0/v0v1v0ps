<div class="container">

<table style="width: 100%;"><tr>
<td>TSVMSSLR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General Interface for TSVM (Transductive SVM classifier using the convex concave procedure) model</h2>

<h3>Description</h3>

<p>model from RSSL package
Transductive SVM using the CCCP algorithm as proposed by Collobert et al. (2006)
implemented in R using the quadprog package. The implementation does not handle large
datasets very well, but can be useful for smaller datasets and visualization purposes.
C is the cost associated with labeled objects, while Cstar is the cost for the
unlabeled objects. s control the loss function used for the unlabeled objects: it
controls the size of the plateau for the symmetric ramp loss function. The balancing
constraint makes sure the label assignments of the unlabeled objects are similar to the
prior on the classes that was observed on the labeled data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">TSVMSSLR(
  C = 1,
  Cstar = 0.1,
  kernel = kernlab::vanilladot(),
  balancing_constraint = TRUE,
  s = 0,
  x_center = TRUE,
  scale = FALSE,
  eps = 1e-09,
  max_iter = 20,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>numeric; Cost parameter of the SVM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cstar</code></td>
<td>
<p>numeric; Cost parameter of the unlabeled objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>kernlab::kernel to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balancing_constraint</code></td>
<td>
<p>logical; Whether a balancing constraint should be enfored that causes the fraction of objects assigned to each label in the unlabeled data to be similar to the label fraction in the labeled data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>numeric; parameter controlling the loss function of the unlabeled objects (generally values between -1 and 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_center</code></td>
<td>
<p>logical;  Should the features be centered?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If TRUE, apply a z-transform to all observations in X and X_u before running the regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric; Stopping criterion for the maximinimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>integer; Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; print debugging messages, only works for vanilladot() kernel (default: FALSE)</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Collobert, R. et al., 2006. Large scale transductive SVMs.
Journal of Machine Learning Research, 7, pp.1687-1712.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(tidyverse)
library(caret)
library(tidymodels)
library(SSLR)

data(breast)

set.seed(1)
train.index &lt;- createDataPartition(breast$Class, p = .7, list = FALSE)
train &lt;- breast[ train.index,]
test  &lt;- breast[-train.index,]

cls &lt;- which(colnames(breast) == "Class")

#% LABELED
labeled.index &lt;- createDataPartition(breast$Class, p = .2, list = FALSE)
train[-labeled.index,cls] &lt;- NA

library(kernlab)
m &lt;- TSVMSSLR(kernel = kernlab::vanilladot()) %&gt;% fit(Class ~ ., data = train)


#Accesing model from RSSL
model &lt;- m$model

</code></pre>


</div>