<div class="container">

<table style="width: 100%;"><tr>
<td>make.mask</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Build Habitat Mask </h2>

<h3>Description</h3>

<p>Construct a habitat mask object for spatially explicit capture-recapture. 
A mask object is a set of points with optional attributes. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">
make.mask(traps, buffer = 100, spacing = NULL, nx = 64, ny = 64, type =
    c("traprect", "trapbuffer", "pdot", "polygon", "clusterrect",
    "clusterbuffer", "rectangular", "polybuffer"), poly = NULL, poly.habitat = TRUE,
    cell.overlap = c("centre","any","all"), keep.poly = TRUE, check.poly = TRUE, 
    pdotmin = 0.001, random.origin = FALSE,
    ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>traps</code></td>
<td>
<p> object of class <code>traps</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer</code></td>
<td>
<p> width of buffer in metres </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacing</code></td>
<td>
<p> spacing between grid points (metres) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p> number of grid points in ‘x’ direction </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ny</code></td>
<td>
<p> number of grid points in ‘y’ direction (type = ‘rectangular’) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> character string for method </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p> bounding polygon to which mask should be clipped (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly.habitat</code></td>
<td>
<p> logical for whether poly represents habitat or
its inverse (non-habitat)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.overlap</code></td>
<td>
<p>character string for cell vertices used to determine overlap with ‘poly’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.poly</code></td>
<td>
<p> logical; if TRUE any bounding polygon is saved as the
attribute ‘polygon’ </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.poly</code></td>
<td>
<p> logical; if TRUE a warning is given for traps that
lie outside a bounding polygon </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdotmin</code></td>
<td>
<p> minimum detection probability for inclusion in mask when <code>type = "pdot"</code> (optional) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.origin</code></td>
<td>
<p> logical; if TRUE the mask coordinates are jittered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments passed to <code>pdot</code> when <code>type = "pdot"</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ‘traprect’ method constructs a grid of points in the rectangle
formed by adding a buffer strip to the minimum and maximum x-y
coordinates of the detectors in <code>traps</code>. Both ‘trapbuffer’ and
‘pdot’ start with a ‘traprect’ mask and drop some points.
</p>
<p>The ‘trapbuffer’ method restricts the grid to points within distance
<code>buffer</code> of any detector.
</p>
<p>The ‘pdot’ method restricts the grid to points for which the net
detection probability <code class="reqn">p.(\mathbf{X})</code> (see
<code>pdot</code>) is at least <code>pdotmin</code>. Additional parameters
are used by <code>pdot</code> (detectpar, noccasions). Set these with the
... argument; otherwise <code>make.mask</code> will silently use the
arbitrary defaults. <code>pdot</code> is currently limited to a halfnormal
detection function.
</p>
<p>The ‘clusterrect’ method constructs a grid of rectangular submasks
centred on ‘clusters’ of detectors generated with
<code>trap.builder</code> (possibly indirectly by
<code>make.systematic</code>). The ‘clusterbuffer’ method resembles
‘trapbuffer’, but is usually faster when traps are arranged in clusters
because it starts with a ‘clusterrect’ mask.
</p>
<p>The ‘rectangular’ method constructs a simple rectangular mask with the
given nx, ny and spacing. 
</p>
<p>The ‘polybuffer’ method constructs a mask by buffering around the polygon specified in the ‘poly’ argument. If that inherits from ‘SpatialPolygons’ or ‘sfc’ then the buffering is performed with sf::st_buffer. Otherwise, buffering is approximate, based on the distance to points on an initial discretized mask enclosed by ‘poly’ (points at half the current ‘spacing’).
</p>
<p>If <code>poly</code> is specified, points outside <code>poly</code> are dropped (unless type = "polybuffer"). The default is to require only the centre to lie within <code>poly</code>; use <code>cell.overlap = "all"</code> to require all cell corners to lie within <code>poly</code>, or <code>cell.overlap = "any"</code> to accept cells with any corner in <code>poly</code>. The ‘polygon’ method places points on a rectangular grid clipped to the
polygon (<code>buffer</code> is not used). Thus ‘traprect’ is equivalent to
‘polygon’ when <code>poly</code> is supplied. <code>poly</code> may be either
</p>

<ul>
<li>
<p> a matrix or dataframe of two columns interpreted as x and y
coordinates, or
</p>
</li>
<li>
<p> an object from package ‘sf’ with polygon geometries, or
</p>
</li>
<li>
<p> a SpatialPolygons or SpatialPolygonsDataFrame object as defined in the package ‘sp’,
possibly imported by reading a shapefile.
</p>
</li>
</ul>
<p>If <code>spacing</code> is not specified then it is determined by dividing the
range of the x coordinates (including any buffer) by <code>nx</code>.
</p>
<p><code>random.origin</code> shifts the origin of the mask by a uniform random displacement within a spacing x spacing grid cell, while ensuring that the mask also satisfies the buffer requirement. <code>random.origin</code> is available only for ‘traprect’, ‘trapbuffer’, ‘polygon’, and ‘rectangular’ types, and <code>spacing</code> 
must be specified.
</p>


<h3>Value</h3>

<p>An object of class <code>mask</code>.  When <code>keep.poly = TRUE</code>,
<code>poly</code> and <code>poly.habitat</code> are saved as attributes of the
mask.
</p>


<h3>Note</h3>

<p>A warning is displayed if <code>type = "pdot"</code> and the buffer is too small to
include all points with <code class="reqn">p.</code> &gt; pdotmin.
</p>
<p>A habitat mask is needed to fit an SECR model and for some related
computations. The default mask settings in <code>secr.fit</code> may be good
enough, but it is preferable to use <code>make.mask</code> to construct a mask
in advance and to pass that mask as an argument to <code>secr.fit</code>.
</p>
<p>The function <code>bufferContour</code> displays the extent of one or more
‘trapbuffer’ zones - i.e. the effect of buffering the detector array
with varying strip widths. 
</p>


<h3>See Also</h3>

<p><code>mask</code>, <code>read.mask</code>, <code>subset.mask</code>,
<code>pdot</code>, <code>bufferContour</code>, <code>deleteMaskPoints</code>,
<code>as.mask</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
temptrap &lt;- make.grid(nx = 10, ny = 10, spacing = 30)

## default method: traprect
tempmask &lt;- make.mask(temptrap, spacing = 5)
plot(tempmask)
summary (tempmask)

## make irregular detector array by subsampling 
## form mask by `trapbuffer' method
temptrap &lt;- subset (temptrap, sample(nrow(temptrap), size = 30))
tempmask &lt;- make.mask (temptrap, spacing = 5, type = "trapbuffer")
plot (tempmask)
plot (temptrap, add = TRUE)

## Not run: 

## form mask by "pdot" method
temptrap &lt;- make.grid(nx = 6, ny = 6)
tempmask &lt;- make.mask (temptrap, buffer = 150, type = "pdot", 
    pdotmin = 0.0001, detectpar = list(g0 = 0.1, sigma = 30),
    noccasions = 4)
plot (tempmask)
plot (temptrap, add = TRUE)

## Using an ESRI polygon shapefile for clipping (shapefile
## polygons may include multiple islands and holes).

library(sf)
shpfilename &lt;- system.file("extdata/possumarea.shp", package = "secr")
possumarea &lt;- st_read(shpfilename)

possummask2 &lt;- make.mask(traps(possumCH), spacing = 20,
    buffer = 250, type = "trapbuffer", poly = possumarea)
par(mar = c(1,6,6,6), xpd = TRUE)
plot (possummask2, ppoly = TRUE)
plot(traps(possumCH), add = TRUE)
par(mar = c(5,4,4,2) + 0.1, xpd = FALSE)

## if the polygon delineates non-habitat ...
seaPossumMask &lt;- make.mask(traps(possumCH), buffer = 1000, 
    type = "traprect", poly = possumarea, poly.habitat = FALSE)
plot(seaPossumMask)
plot(traps(possumCH), add = TRUE)
## this mask is not useful!


## End(Not run)






</code></pre>


</div>