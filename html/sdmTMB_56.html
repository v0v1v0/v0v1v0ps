<div class="container">

<table style="width: 100%;"><tr>
<td>sdmTMB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a spatial or spatiotemporal GLMM with TMB</h2>

<h3>Description</h3>

<p>Fit a spatial or spatiotemporal generalized linear mixed effects model (GLMM)
with the TMB (Template Model Builder) R package and the SPDE (stochastic
partial differential equation) approximation to Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sdmTMB(
  formula,
  data,
  mesh,
  time = NULL,
  family = gaussian(link = "identity"),
  spatial = c("on", "off"),
  spatiotemporal = c("iid", "ar1", "rw", "off"),
  share_range = TRUE,
  time_varying = NULL,
  time_varying_type = c("rw", "rw0", "ar1"),
  spatial_varying = NULL,
  weights = NULL,
  offset = NULL,
  extra_time = NULL,
  reml = FALSE,
  silent = TRUE,
  anisotropy = FALSE,
  control = sdmTMBcontrol(),
  priors = sdmTMBpriors(),
  knots = NULL,
  bayesian = FALSE,
  previous_fit = NULL,
  do_fit = TRUE,
  do_index = FALSE,
  predict_args = NULL,
  index_args = NULL,
  experimental = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula. IID random intercepts are possible using
<span class="pkg">lme4</span> syntax, e.g., <code>+ (1 | g)</code> where <code>g</code> is a column of class
character or factor representing groups. Penalized splines are possible via
<span class="pkg">mgcv</span> with <code>s()</code>. Optionally a list for delta (hurdle) models.  See
examples and details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>An object from <code>make_mesh()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>An optional time column name (as character). Can be left as
<code>NULL</code> for a model with only spatial random fields; however, if the data
are actually spatiotemporal and you wish to use <code>get_index()</code> or <code>get_cog()</code>
downstream, supply the time argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family and link. Supports <code>gaussian()</code>, <code>Gamma()</code>,
<code>binomial()</code>, <code>poisson()</code>, <code>Beta()</code>,
<code>nbinom2()</code>,
<code>truncated_nbinom2()</code>,
<code>nbinom1()</code>,
<code>truncated_nbinom1()</code>,
<code>censored_poisson()</code>,
<code>gamma_mix()</code>,
<code>lognormal_mix()</code>,
<code>student()</code>,
<code>tweedie()</code>, and
<code>gengamma()</code>.
Supports the delta/hurdle models:
<code>delta_beta()</code>,
<code>delta_gamma()</code>,
<code>delta_gamma_mix()</code>,
<code>delta_lognormal_mix()</code>,
<code>delta_lognormal()</code>, and
<code>delta_truncated_nbinom2()</code>,
For binomial family options, see 'Binomial families' in the Details
section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial</code></td>
<td>
<p>Estimate spatial random fields? Options are <code>'on'</code> / <code>'off'</code>
or <code>TRUE</code> / <code>FALSE</code>. Optionally, a list for delta models, e.g. <code>list('on', 'off')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatiotemporal</code></td>
<td>
<p>Estimate the spatiotemporal random fields as <code>'iid'</code>
(independent and identically distributed; default), stationary <code>'ar1'</code>
(first-order autoregressive), a random walk (<code>'rw'</code>), or fixed at 0
<code>'off'</code>. Will be set to <code>'off'</code> if <code>time = NULL</code>. If a delta model, can be
a list. E.g., <code>list('off', 'ar1')</code>. Note that the spatiotemporal standard
deviation represents the marginal steady-state standard deviation of the
process in the case of the AR1. I.e., it is scaled according to the
correlation. See the <a href="https://kaskr.github.io/adcomp/classdensity_1_1AR1__t.html">TMB documentation</a>.
If the AR1 correlation coefficient (rho) is estimated close to 1,
say &gt; 0.99, then you may wish to switch to the random walk <code>'rw'</code>.
Capitalization is ignored. <code>TRUE</code> gets converted to <code>'iid'</code> and <code>FALSE</code>
gets converted to <code>'off'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>share_range</code></td>
<td>
<p>Logical: estimate a shared spatial and spatiotemporal
range parameter (<code>TRUE</code>, default) or independent range parameters
(<code>FALSE</code>). If a delta model, can be a list. E.g., <code>list(TRUE, FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_varying</code></td>
<td>
<p>An optional one-sided formula describing covariates
that should be modelled as a time-varying process. Set the type of
process with <code>time_varying_type</code>. See the help for <code>time_varying_type</code>
for warnings about modelling the first time step. Structure shared in
delta models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_varying_type</code></td>
<td>
<p>Type of time-varying process to apply to
<code>time_varying</code> formula. <code>'rw'</code> indicates a random walk with the first
time step estimated independently (included for legacy reasons), <code>'rw0'</code>
indicates a random walk with the first time step estimated with
a mean-zero normal prior, <code>'ar1'</code> indicates a <a href="https://kaskr.github.io/adcomp/classdensity_1_1AR1__t.html">stationary first-order autoregressive process</a>
with the first time step estimated with a mean-zero prior. In the case of
<code>'rw'</code>, be careful not to include covariates (including the intercept) in
both the main and time-varying formula since the first time step is
estimated independently. I.e., in this case, at least one should have <code>~ 0</code> or <code>~ -1</code>. Structure shared in delta models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial_varying</code></td>
<td>
<p>An optional one-sided formula of coefficients that
should vary in space as random fields. Note that you likely want to include
a fixed effect for the same variable to improve interpretability since the
random field is assumed to have a mean of 0. If a (scaled) time column is
used, it will represent a local-time-trend model. See
<a href="https://doi.org/10.1111/ecog.05176">doi:10.1111/ecog.05176</a> and the <a href="https://pbs-assess.github.io/sdmTMB/articles/spatial-trend-models.html">spatial trends vignette</a>.
Note this predictor should usually be centered to have mean zero and have a
standard deviation of approximately 1.
<strong>The spatial intercept is controlled by the <code>spatial</code> argument</strong>; therefore,
include or exclude the spatial intercept by setting <code>spatial = 'on'</code> or
<code>'off'</code>. The only time when it matters whether <code>spatial_varying</code> excludes
an intercept is in the case of factor predictors. In this case, if
<code>spatial_varying</code> excludes the intercept (<code>~ 0</code> or <code>~ -1</code>), you should set
<code>spatial = 'off'</code> to match.  Structure must be shared in delta models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A numeric vector representing optional likelihood weights for
the conditional model. Implemented as in <span class="pkg">glmmTMB</span>: weights do not have
to sum to one and are not internally modified. Can also be used for trials
with the binomial family; the <code>weights</code> argument needs to be a vector and not
a name of the variable in the data frame. See the Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A numeric vector representing the model offset <em>or</em> a character
value representing the column name of the offset. In delta/hurdle models,
this applies only to the positive component. Usually a log transformed
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra_time</code></td>
<td>
<p>Optional extra time slices (e.g., years) to include for
interpolation or forecasting with the predict function. See the Details
section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reml</code></td>
<td>
<p>Logical: use REML (restricted maximum likelihood) estimation
rather than maximum likelihood? Internally, this adds the fixed effects to
the list of random effects to integrate over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Silent or include optimization details? Helpful to set to
<code>FALSE</code> for models that take a while to fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anisotropy</code></td>
<td>
<p>Logical: allow for anisotropy (spatial correlation that is
directionally dependent)? See <code>plot_anisotropy()</code>.
Must be shared across delta models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Optimization control options via <code>sdmTMBcontrol()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>Optional penalties/priors via <code>sdmTMBpriors()</code>. Must currently
be shared across delta models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>Optional named list containing knot values to be used for basis
construction of smoothing terms. See <code>mgcv::gam()</code> and <code>mgcv::gamm()</code>.
E.g., <code style="white-space: pre;">⁠s(x, bs = 'cc', k = 4), knots = list(x = c(1, 2, 3, 4))⁠</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bayesian</code></td>
<td>
<p>Logical indicating if the model will be passed to
<span class="pkg">tmbstan</span>. If <code>TRUE</code>, Jacobian adjustments are applied to account for
parameter transformations when priors are applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>previous_fit</code></td>
<td>
<p>A previously fitted sdmTMB model to initialize the
optimization with. Can greatly speed up fitting. Note that the model must
be set up <em>exactly</em> the same way. However, the data and <code>weights</code> arguments
can change, which can be useful for cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_fit</code></td>
<td>
<p>Fit the model (<code>TRUE</code>) or return the processed data without
fitting (<code>FALSE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_index</code></td>
<td>
<p>Do index standardization calculations while fitting? Saves
memory and time when working with large datasets or projection grids since
the TMB object doesn't have to be rebuilt with <code>predict.sdmTMB()</code> and
<code>get_index()</code>. If <code>TRUE</code>, then <code>predict_args</code> must have a <code>newdata</code> element
supplied and <code>area</code> can be supplied to <code>index_args</code>.
Most users can ignore this option. The fitted object can be passed directly
to <code>get_index()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_args</code></td>
<td>
<p>A list of arguments to pass to <code>predict.sdmTMB()</code> <strong>if</strong>
<code>do_index = TRUE</code>. Most users can ignore this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_args</code></td>
<td>
<p>A list of arguments to pass to <code>get_index()</code> <strong>if</strong>
<code>do_index = TRUE</code>. Currently, only <code>area</code> is supported. Bias correction
can be done when calling <code>get_index()</code> on the resulting fitted object.
Most users can ignore this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>experimental</code></td>
<td>
<p>A named list for esoteric or in-development options. Here
be dragons.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Model description</strong>
</p>
<p>See the <a href="https://pbs-assess.github.io/sdmTMB/articles/model-description.html">model description</a>
vignette or the relevant appendix of the preprint on sdmTMB:
<a href="https://doi.org/10.1101/2022.03.24.485545">doi:10.1101/2022.03.24.485545</a>
</p>
<p><strong>Binomial families</strong>
</p>
<p>Following the structure of <code>stats::glm()</code> and <span class="pkg">glmmTMB</span>, a binomial
family can be specified in one of 4 ways: (1) the response may be a factor
(and the model classifies the first level versus all others), (2) the
response may be binomial (0/1), (3) the response can be a matrix of form
<code>cbind(success, failure)</code>, and (4) the response may be the observed
proportions, and the 'weights' argument is used to specify the Binomial size
(N) parameter (<code style="white-space: pre;">⁠prob ~ ..., weights = N⁠</code>).
</p>
<p><strong>Smooth terms</strong>
</p>
<p>Smooth terms can be included following GAMs (generalized additive models)
using <code>+ s(x)</code>, which implements a smooth from <code>mgcv::s()</code>. <span class="pkg">sdmTMB</span> uses
penalized smooths, constructed via <code>mgcv::smooth2random()</code>. This is a similar
approach implemented in <span class="pkg">gamm4</span> and <span class="pkg">brms</span>, among other packages.
Within these smooths, the same syntax commonly used in <code>mgcv::s()</code> or
<code>mgcv::t2()</code> can be applied, e.g. 2-dimensional smooths may be constructed
with <code>+ s(x, y)</code> or <code>+ t2(x, y)</code>; smooths can be specific to various factor
levels, <code>+ s(x, by = group)</code>; the basis function dimensions may be specified,
e.g. <code>+ s(x, k = 4)</code>; and various types of splines may be constructed such as
cyclic splines to model seasonality (perhaps with the <code>knots</code> argument also
be supplied).
</p>
<p><strong>Threshold models</strong>
</p>
<p>A linear break-point relationship for a covariate can be included via
<code>+ breakpt(variable)</code> in the formula, where <code>variable</code> is a single covariate
corresponding to a column in <code>data</code>. In this case, the relationship is linear
up to a point and then constant (hockey-stick shaped).
</p>
<p>Similarly, a logistic-function threshold model can be included via
<code>+ logistic(variable)</code>. This option models the relationship as a logistic
function of the 50% and 95% values. This is similar to length- or size-based
selectivity in fisheries, and is parameterized by the points at which f(x) =
0.5 or 0.95. See the
<a href="https://pbs-assess.github.io/sdmTMB/articles/threshold-models.html">threshold vignette</a>.
</p>
<p>Note that only a single threshold covariate can be included and the same covariate
is included in both components for the delta families.
</p>
<p><strong>Extra time: forecasting or interpolating</strong>
</p>
<p>Extra time slices (e.g., years) can be included for interpolation or
forecasting with the predict function via the <code>extra_time</code> argument. The
predict function requires all time slices to be defined when fitting the
model to ensure the various time indices are set up correctly. Be careful if
including extra time slices that the model remains identifiable. For example,
including <code>+ as.factor(year)</code> in <code>formula</code> will render a model with no data
to inform the expected value in a missing year. <code>sdmTMB()</code> makes no attempt
to determine if the model makes sense for forecasting or interpolation. The
options <code>time_varying</code>, <code>spatiotemporal = "rw"</code>, <code>spatiotemporal = "ar1"</code>,
or a smoother on the time column provide mechanisms to predict over missing
time slices with process error.
</p>
<p><code>extra_time</code> can also be used to fill in missing time steps for the purposes
of a random walk or AR(1) process if the gaps between time steps are uneven.
</p>
<p><code>extra_time</code> can include only extra time steps or all time steps including
those found in the fitted data. This latter option may be simpler.
</p>
<p><strong>Regularization and priors</strong>
</p>
<p>You can achieve regularization via penalties (priors) on the fixed effect
parameters. See <code>sdmTMBpriors()</code>. You can fit the model once without
penalties and look at the output of <code>print(your_model)</code> or <code>tidy(your_model)</code>
or fit the model with <code>do_fit = FALSE</code> and inspect
<code>head(your_model$tmb_data$X_ij[[1]])</code> if you want to see how the formula is
translated to the fixed effect model matrix. Also see the
<a href="https://pbs-assess.github.io/sdmTMB/articles/bayesian.html">Bayesian vignette</a>.
</p>
<p><strong>Delta/hurdle models</strong>
</p>
<p>Delta models (also known as hurdle models) can be fit as two separate models
or at the same time by using an appropriate delta family. E.g.:
<code>delta_gamma()</code>,
<code>delta_beta()</code>,
<code>delta_lognormal()</code>, and
<code>delta_truncated_nbinom2()</code>.
If fit with a delta family, by default the formula, spatial, and spatiotemporal
components are shared. Some elements can be specified independently for the two models
using a list format. These include <code>formula</code>, <code>spatial</code>, <code>spatiotemporal</code>,
and <code>share_range</code>. The first element of the list is for the binomial component
and the second element is for the positive component (e.g., Gamma).
Other elements must be shared for now (e.g., spatially varying coefficients,
time-varying coefficients). Furthermore, there are currently limitations if
specifying two formulas as a list: the two formulas cannot have smoothers,
threshold effects, or random intercepts. For now, these must be specified
through a single formula that is shared across the two models.
</p>
<p>The main advantage of specifying such models using a delta family (compared
to fitting two separate models) is (1) coding simplicity and (2) calculation
of uncertainty on derived quantities such as an index of abundance with
<code>get_index()</code> using the generalized delta method within TMB. Also, selected
parameters can be shared across the models.
</p>
<p>See the <a href="https://pbs-assess.github.io/sdmTMB/articles/delta-models.html">delta-model vignette</a>.
</p>
<p><strong>Index standardization</strong>
</p>
<p>For index standardization, you may wish to include <code>0 + as.factor(year)</code>
(or whatever the time column is called) in the formula. See a basic
example of index standardization in the relevant
<a href="https://pbs-assess.github.io/sdmTMB/articles/index-standardization.html">package vignette</a>.
You will need to specify the <code>time</code> argument. See <code>get_index()</code>.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>sdmTMB</code>. Useful elements include:
</p>

<ul>
<li> <p><code>sd_report</code>: output from <code>TMB::sdreport()</code>
</p>
</li>
<li> <p><code>gradients</code>: marginal log likelihood gradients with respect to each fixed effect
</p>
</li>
<li> <p><code>model</code>: output from <code>stats::nlminb()</code>
</p>
</li>
<li> <p><code>data</code>: the fitted data
</p>
</li>
<li> <p><code>mesh</code>: the object that was supplied to the <code>mesh</code> argument
</p>
</li>
<li> <p><code>family</code>: the family object, which includes the inverse link function as <code>family$linkinv()</code>
</p>
</li>
<li> <p><code>tmb_params</code>: The parameters list passed to <code>TMB::MakeADFun()</code>
</p>
</li>
<li> <p><code>tmb_map</code>: The 'map' list passed to <code>TMB::MakeADFun()</code>
</p>
</li>
<li> <p><code>tmb_data</code>: The data list passed to <code>TMB::MakeADFun()</code>
</p>
</li>
<li> <p><code>tmb_obj</code>: The TMB object created by <code>TMB::MakeADFun()</code>
</p>
</li>
</ul>
<h3>References</h3>

<p><strong>Main reference introducing the package to cite when using sdmTMB:</strong>
</p>
<p>Anderson, S.C., E.J. Ward, P.A. English, L.A.K. Barnett. 2022. sdmTMB: an R
package for fast, flexible, and user-friendly generalized linear mixed effects
models with spatial and spatiotemporal random fields.
bioRxiv 2022.03.24.485545; <a href="https://doi.org/10.1101/2022.03.24.485545">doi:10.1101/2022.03.24.485545</a>.
</p>
<p><em>Reference for local trends:</em>
</p>
<p>Barnett, L.A.K., E.J. Ward, S.C. Anderson. 2021. Improving estimates of species
distribution change by incorporating local trends. Ecography. 44(3):427-439.
<a href="https://doi.org/10.1111/ecog.05176">doi:10.1111/ecog.05176</a>.
</p>
<p><em>Further explanation of the model and application to calculating climate
velocities:</em>
</p>
<p>English, P., E.J. Ward, C.N. Rooper, R.E. Forrest, L.A. Rogers, K.L. Hunter,
A.M. Edwards, B.M. Connors, S.C. Anderson. 2021. Contrasting climate velocity
impacts in warm and cool locations show that effects of marine warming are
worse in already warmer temperate waters. Fish and Fisheries. 23(1) 239-255.
<a href="https://doi.org/10.1111/faf.12613">doi:10.1111/faf.12613</a>.
</p>
<p><em>Discussion of and illustration of some decision points when fitting these
models:</em>
</p>
<p>Commander, C.J.C., L.A.K. Barnett, E.J. Ward, S.C. Anderson, T.E.
Essington. 2022. The shadow model: how and why small choices in
spatially explicit species distribution models affect predictions. PeerJ 10:
e12783. <a href="https://doi.org/10.7717/peerj.12783">doi:10.7717/peerj.12783</a>.
</p>
<p><em>Application and description of threshold/break-point models:</em>
</p>
<p>Essington, T.E., S.C. Anderson, L.A.K. Barnett, H.M. Berger, S.A. Siedlecki,
E.J. Ward. 2022. Advancing statistical models to reveal the effect of
dissolved oxygen on the spatial distribution of marine taxa using thresholds
and a physiologically based index. Ecography. 2022: e06249
<a href="https://doi.org/10.1111/ecog.06249">doi:10.1111/ecog.06249</a>.
</p>
<p><em>Application to fish body condition:</em>
</p>
<p>Lindmark, M., S.C. Anderson, M. Gogina, M. Casini. Evaluating drivers of
spatiotemporal individual condition of a bottom-associated marine fish.
bioRxiv 2022.04.19.488709. <a href="https://doi.org/10.1101/2022.04.19.488709">doi:10.1101/2022.04.19.488709</a>.
</p>
<p><em>Several sections of the original TMB model code were adapted from the
VAST R package:</em>
</p>
<p>Thorson, J.T. 2019. Guidance for decisions using the Vector Autoregressive
Spatio-Temporal (VAST) package in stock, ecosystem, habitat and climate
assessments. Fish. Res. 210:143–161.
<a href="https://doi.org/10.1016/j.fishres.2018.10.013">doi:10.1016/j.fishres.2018.10.013</a>.
</p>
<p><em>Code for the <code>family</code> R-to-TMB implementation, selected parameterizations of
the observation likelihoods, general package structure inspiration, and the
idea behind the TMB prediction approach were adapted from the glmmTMB R
package:</em>
</p>
<p>Brooks, M.E., K. Kristensen, K.J. van Benthem, A. Magnusson,
C.W. Berg, A. Nielsen, H.J. Skaug, M. Maechler, B.M. Bolker.
2017. glmmTMB Balances Speed and Flexibility Among Packages for
Zero-inflated Generalized Linear Mixed Modeling. The R Journal, 9(2):378-400.
<a href="https://doi.org/10.32614/rj-2017-066">doi:10.32614/rj-2017-066</a>.
</p>
<p><em>Implementation of geometric anisotropy with the SPDE and use of random
field GLMMs for index standardization</em>:
</p>
<p>Thorson, J.T., A.O. Shelton, E.J. Ward, H.J. Skaug. 2015.
Geostatistical delta-generalized linear mixed models improve precision for
estimated abundance indices for West Coast groundfishes. ICES J. Mar. Sci.
72(5): 1297–1310. <a href="https://doi.org/10.1093/icesjms/fsu243">doi:10.1093/icesjms/fsu243</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(sdmTMB)

# Build a mesh to implement the SPDE approach:
mesh &lt;- make_mesh(pcod_2011, c("X", "Y"), cutoff = 20)

# - this example uses a fairly coarse mesh so these examples run quickly
# - 'cutoff' is the minimum distance between mesh vertices in units of the
#   x and y coordinates
# - 'cutoff = 10' might make more sense in applied situations for this dataset
# - or build any mesh in 'fmesher' and pass it to the 'mesh' argument in make_mesh()`
# - the mesh is not needed if you will be turning off all
#   spatial/spatiotemporal random fields

# Quick mesh plot:
plot(mesh)

# Fit a Tweedie spatial random field GLMM with a smoother for depth:
fit &lt;- sdmTMB(
  density ~ s(depth),
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Extract coefficients:
tidy(fit, conf.int = TRUE)
tidy(fit, effects = "ran_par", conf.int = TRUE)

# Perform several 'sanity' checks:
sanity(fit)

# Predict on the fitted data; see ?predict.sdmTMB
p &lt;- predict(fit)

# Predict on new data:
p &lt;- predict(fit, newdata = qcs_grid)
head(p)


# Visualize the depth effect with ggeffects:
ggeffects::ggpredict(fit,  "depth [all]") |&gt; plot()

# Visualize depth effect with visreg: (see ?visreg_delta)
visreg::visreg(fit, xvar = "depth") # link space; randomized quantile residuals
visreg::visreg(fit, xvar = "depth", scale = "response")
visreg::visreg(fit, xvar = "depth", scale = "response", gg = TRUE, rug = FALSE)

# Add spatiotemporal random fields:
fit &lt;- sdmTMB(
  density ~ 0 + as.factor(year),
  time = "year", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Make the fields AR1:
fit &lt;- sdmTMB(
  density ~ s(depth),
  time = "year",
  spatial = "off",
  spatiotemporal = "ar1", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Make the fields a random walk:
fit &lt;- sdmTMB(
  density ~ s(depth),
  time = "year",
  spatial = "off",
  spatiotemporal = "rw", #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Depth smoothers by year:
fit &lt;- sdmTMB(
  density ~ s(depth, by = as.factor(year)), #&lt;
  time = "year",
  spatial = "off",
  spatiotemporal = "rw",
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# 2D depth-year smoother:
fit &lt;- sdmTMB(
  density ~ s(depth, year), #&lt;
  spatial = "off",
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Turn off spatial random fields:
fit &lt;- sdmTMB(
  present ~ poly(log(depth)),
  spatial = "off", #&lt;
  data = pcod_2011, mesh = mesh,
  family = binomial()
)
fit

# Which, matches glm():
fit_glm &lt;- glm(
  present ~ poly(log(depth)),
  data = pcod_2011,
  family = binomial()
)
summary(fit_glm)
AIC(fit, fit_glm)

# Delta/hurdle binomial-Gamma model:
fit_dg &lt;- sdmTMB(
  density ~ poly(log(depth), 2),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = delta_gamma() #&lt;
)
fit_dg

# Delta model with different formulas and spatial structure:
fit_dg &lt;- sdmTMB(
  list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)), #&lt;
  data = pcod_2011, mesh = mesh,
  spatial = list("off", "on"), #&lt;
  family = delta_gamma()
)
fit_dg

# Delta/hurdle truncated NB2:
pcod_2011$count &lt;- round(pcod_2011$density)
fit_nb2 &lt;- sdmTMB(
  count ~ s(depth),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = delta_truncated_nbinom2() #&lt;
)
fit_nb2

# Regular NB2:
fit_nb2 &lt;- sdmTMB(
  count ~ s(depth),
  data = pcod_2011, mesh = mesh,
  spatial = "off",
  family = nbinom2() #&lt;
)
fit_nb2

# IID random intercepts by year:
pcod_2011$fyear &lt;- as.factor(pcod_2011$year)
fit &lt;- sdmTMB(
  density ~ s(depth) + (1 | fyear), #&lt;
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log")
)
fit

# Spatially varying coefficient of year:
pcod_2011$year_scaled &lt;- as.numeric(scale(pcod_2011$year))
fit &lt;- sdmTMB(
  density ~ year_scaled,
  spatial_varying = ~ 0 + year_scaled, #&lt;
  data = pcod_2011, mesh = mesh, family = tweedie(), time = "year"
)
fit

# Time-varying effects of depth and depth squared:
fit &lt;- sdmTMB(
  density ~ 0 + as.factor(year),
  time_varying = ~ 0 + depth_scaled + depth_scaled2, #&lt;
  data = pcod_2011, time = "year", mesh = mesh,
  family = tweedie()
)
print(fit)
# Extract values:
est &lt;- as.list(fit$sd_report, "Estimate")
se &lt;- as.list(fit$sd_report, "Std. Error")
est$b_rw_t[, , 1]
se$b_rw_t[, , 1]

# Linear break-point effect of depth:
fit &lt;- sdmTMB(
  density ~ breakpt(depth_scaled), #&lt;
  data = pcod_2011,
  mesh = mesh,
  family = tweedie()
)
fit


</code></pre>


</div>