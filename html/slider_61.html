<div class="container">

<table style="width: 100%;"><tr>
<td>slide_index2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Slide along multiples inputs simultaneously relative to an index</h2>

<h3>Description</h3>

<p><code>slide_index2()</code> and <code>pslide_index()</code> represent the combination
of <code>slide2()</code> and <code>pslide()</code> with <code>slide_index()</code>, allowing you to iterate
over multiple vectors at once relative to an <code>.i</code>-ndex.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slide_index2(.x, .y, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index2_vec(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_index2_dbl(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_int(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_lgl(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_chr(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_dfr(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_index2_dfc(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

pslide_index(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_vec(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

pslide_index_dbl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_int(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_lgl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_chr(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_dfr(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

pslide_index_dfc(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x, .y</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.i</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li>
<p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li>
<p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li>
<p> The index cannot have missing values.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p><code style="white-space: pre;">⁠[function / formula]⁠</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.before, .after</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(1) / function / Inf]⁠</code>
</p>

<ul>
<li>
<p> If a vector of size 1, these represent the number of values before or
after the current element of <code>.i</code> to include in the sliding window.
Negative values are allowed, which allows you to "look forward" from the
current element if used as the <code>.before</code> value, or "look backwards" if used
as <code>.after</code>. Boundaries are computed from these elements as <code>.i - .before</code>
and <code>.i + .after</code>. Any object that can be added or subtracted from <code>.i</code>
with <code>+</code> and <code>-</code> can be used. For example, a lubridate period, such as
<code>lubridate::weeks()</code>.
</p>
</li>
<li>
<p> If <code>Inf</code>, this selects all elements before or after the current element.
</p>
</li>
<li>
<p> If a function, or a one-sided formula which can be coerced to a function,
it is applied to <code>.i</code> to compute the boundaries. Note that this function
will only be applied to the <em>unique</em> values of <code>.i</code>, so it should not rely
on the original length of <code>.i</code> in any way. This is useful for applying a
complex arithmetic operation that can't be expressed with a single <code>-</code> or
<code>+</code> operation. One example would be to use <code>lubridate::add_with_rollback()</code>
to avoid invalid dates at the end of the month.
</p>
</li>
</ul>
<p>The ranges that result from applying <code>.before</code> and <code>.after</code> have the same
3 restrictions as <code>.i</code> itself.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.complete</code></td>
<td>
<p><code style="white-space: pre;">⁠[logical(1)]⁠</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ptype</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(0) / NULL]⁠</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li>
<p> By default, input names are zapped.
</p>
</li>
<li>
<p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li>
<p> If <code>NULL</code>, the input names are used as row names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code>vec_as_names()</code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse recycling rules.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.l</code></td>
<td>
<p><code style="white-space: pre;">⁠[list]⁠</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_index2()</code></h4>


<ul>
<li> <p><code>vec_size(slide_index2(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index2(.x, .y)) == list()</code>
</p>
</li>
</ul>
<h4>
<code>slide_index2_vec()</code> and <code style="white-space: pre;">⁠slide_index2_*()⁠</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_index2_vec(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_size(slide_index2_vec(.x, .y)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index2_vec(.x, .y, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h4><code>pslide_index()</code></h4>


<ul>
<li> <p><code>vec_size(pslide_index(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_index(.l)) == list()</code>
</p>
</li>
</ul>
<h4>
<code>pslide_index_vec()</code> and <code style="white-space: pre;">⁠pslide_index_*()⁠</code> variants</h4>


<ul>
<li> <p><code>vec_size(pslide_index_vec(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_size(pslide_index_vec(.l)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_index_vec(.l, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>slide2()</code>, <code>hop_index2()</code>, <code>slide_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Notice that `i` is an irregular index!
x &lt;- 1:5
y &lt;- 6:10
i &lt;- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# When we slide over `i` looking back 1 day, the irregularity is respected.
# When there is a gap in dates, only 2 values are returned (one from
# `x` and one from `y`), otherwise, 4 values are returned.
slide_index2(x, y, i, ~c(.x, .y), .before = 1)

</code></pre>


</div>