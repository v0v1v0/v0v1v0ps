<div class="container">

<table style="width: 100%;"><tr>
<td>summary-index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specialized sliding functions relative to an index</h2>

<h3>Description</h3>

<p>These functions are specialized variants of the most common ways that
<code>slide_index()</code> is generally used. Notably, <code>slide_index_sum()</code> can be used
for rolling sums relative to an index (like a Date column), and
<code>slide_index_mean()</code> can be used for rolling averages.
</p>
<p>These specialized variants are <em>much</em> faster and more memory efficient than
using an otherwise equivalent call constructed with <code>slide_index_dbl()</code>
or <code>slide_index_lgl()</code>, especially with a very wide window.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slide_index_sum(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_prod(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_mean(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_min(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_max(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_all(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_any(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>A vector to compute the sliding function on.
</p>

<ul>
<li>
<p> For sliding sum, mean, prod, min, and max, <code>x</code> will be cast to a double
vector with <code>vctrs::vec_cast()</code>.
</p>
</li>
<li>
<p> For sliding any and all, <code>x</code> will be cast to a logical vector with
<code>vctrs::vec_cast()</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li>
<p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li>
<p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li>
<p> The index cannot have missing values.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before, after</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(1) / function / Inf]⁠</code>
</p>

<ul>
<li>
<p> If a vector of size 1, these represent the number of values before or
after the current element of <code>.i</code> to include in the sliding window.
Negative values are allowed, which allows you to "look forward" from the
current element if used as the <code>.before</code> value, or "look backwards" if used
as <code>.after</code>. Boundaries are computed from these elements as <code>.i - .before</code>
and <code>.i + .after</code>. Any object that can be added or subtracted from <code>.i</code>
with <code>+</code> and <code>-</code> can be used. For example, a lubridate period, such as
<code>lubridate::weeks()</code>.
</p>
</li>
<li>
<p> If <code>Inf</code>, this selects all elements before or after the current element.
</p>
</li>
<li>
<p> If a function, or a one-sided formula which can be coerced to a function,
it is applied to <code>.i</code> to compute the boundaries. Note that this function
will only be applied to the <em>unique</em> values of <code>.i</code>, so it should not rely
on the original length of <code>.i</code> in any way. This is useful for applying a
complex arithmetic operation that can't be expressed with a single <code>-</code> or
<code>+</code> operation. One example would be to use <code>lubridate::add_with_rollback()</code>
to avoid invalid dates at the end of the month.
</p>
</li>
</ul>
<p>The ranges that result from applying <code>.before</code> and <code>.after</code> have the same
3 restrictions as <code>.i</code> itself.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p><code style="white-space: pre;">⁠[logical(1)]⁠</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p><code style="white-space: pre;">⁠[logical(1)]⁠</code>
</p>
<p>Should missing values be removed from the computation?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For more details about the implementation, see the help page of
<code>slide_sum()</code>.
</p>


<h3>Value</h3>

<p>A vector the same size as <code>x</code> containing the result of applying the
summary function over the sliding windows.
</p>

<ul>
<li>
<p> For sliding sum, mean, prod, min, and max, a double vector will be
returned.
</p>
</li>
<li>
<p> For sliding any and all, a logical vector will be returned.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>slide_sum()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(1, 5, 3, 2, 6, 10)
i &lt;- as.Date("2019-01-01") + c(0, 1, 3, 4, 6, 8)

# `slide_index_sum()` can be used for rolling sums relative to an index,
# allowing you to "respect gaps" in your series. Notice that the rolling
# sum in row 3 is only computed from `2019-01-04` and `2019-01-02` since
# `2019-01-01` is more than two days before the current date.
data.frame(
  i = i,
  x = x,
  roll = slide_index_sum(x, i, before = 2)
)

# `slide_index_mean()` can be used for rolling averages
slide_index_mean(x, i, before = 2)

# Only evaluate the sum on windows that have the potential to be complete
slide_index_sum(x, i, before = 2, after = 1, complete = TRUE)
</code></pre>


</div>