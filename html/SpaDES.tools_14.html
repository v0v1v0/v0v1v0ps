<div class="container">

<table style="width: 100%;"><tr>
<td>move</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Move</h2>

<h3>Description</h3>

<p>Wrapper for selecting different animal movement methods.
</p>
<p>This version uses just turn angles and step lengths to define the correlated random walk.
</p>


<h3>Usage</h3>

<pre><code class="language-R">move(hypothesis = "crw", ...)

crw(
  agent,
  extent,
  stepLength,
  stddev,
  lonlat = FALSE,
  torus = FALSE,
  returnMatrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>hypothesis</code></td>
<td>
<p>Character vector, length one, indicating which movement
hypothesis/method to test/use. Currently defaults to
'crw' (correlated random walk) using <code>crw</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to the function in <code>hypothesis</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agent</code></td>
<td>
<p>A <code>SpatVector</code> points geometry or a <code style="white-space: pre;">⁠SpatialPoints*⁠</code> (deprecated) object.
If is has attributes, e.g., <code>SpatialPointsDataFrame</code>,
2 of the columns must
be <code>x1</code> and <code>y1</code>, indicating the previous location.
If it does not have these columns as attributes, <code>x1</code> and
<code>y1</code> will be assigned randomly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extent</code></td>
<td>
<p>An optional <code>Extent</code> object that will be used for <code>torus</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepLength</code></td>
<td>
<p>Numeric vector of length 1 or number of agents describing
step length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stddev</code></td>
<td>
<p>Numeric vector of length 1 or number of agents describing
standard deviation of wrapped normal turn angles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lonlat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, coordinates should be in degrees.
If <code>FALSE</code> coordinates represent planar ('Euclidean')
space (e.g. units of meters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>torus</code></td>
<td>
<p>Logical. Should the movement be wrapped to the opposite
side of the map, as determined by the <code>extent</code> argument.
Default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnMatrix</code></td>
<td>
<p>If <code>TRUE</code> then the return object will be a <code>matrix</code>. This will
be MUCH faster than retaining the <code>sp</code> or <code>SpatVector</code> class,
and thus will be much more effective for iterative <code>crw</code> calls</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This simple version of a correlated random walk is largely the version that
was presented in Turchin 1998, but it was also used with bias modifications
in McIntire, Schultz, Crone 2007.
</p>


<h3>Value</h3>

<p>A <code>SpatVector</code> points object with updated spatial position defined
by a single occurrence of step length(s) and turn angle(s).
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>References</h3>

<p>Turchin, P. 1998. Quantitative analysis of movement: measuring and
modeling population redistribution in animals and plants.
Sinauer Associates, Sunderland, MA.
</p>
<p>McIntire, E. J. B., C. B. Schultz, and E. E. Crone. 2007.
Designing a network for butterfly habitat restoration: where
individuals, populations and landscapes interact.
Journal of Applied Ecology 44:725-736.
</p>


<h3>See Also</h3>

<p><code>terra::distance()</code>
</p>
<p><code>wrap()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

# using just matrix
N &lt;- 10
xrange &lt;- yrange &lt;- c(-50, 50)
starts &lt;- cbind(x = stats::runif(N, xrange[1], xrange[2]),
                y = stats::runif(N, yrange[1], yrange[2]))
moved &lt;- crw(starts, stepLength = 5, stddev = 10)
plot(starts, col = rainbow(10), pch = 19)
points(moved, col = rainbow(10))

# as SpatVector
agent &lt;- terra::vect(starts)
moved &lt;- crw(agent, stepLength = 5, stddev = 10)
movedAgain &lt;- crw(moved, stepLength = 5, stddev = 10)
terra::plot(agent)
terra::plot(moved, add = TRUE, col = "red")
terra::plot(movedAgain, add = TRUE, col = "green")

# 1000x faster!! -- returnMatrix = TRUE
agentOrig &lt;- agent
reps &lt;- 1e2
system.time({
  for (i in 1:reps) agent &lt;- crw(agent, stepLength = 5, stddev = 10, returnMatrix = TRUE)
})
agent &lt;- agentOrig
system.time({
  for (i in 1:reps) agent &lt;- crw(agent, stepLength = 5, stddev = 10)
})

# as sp
if (requireNamespace("sp")) {
  agent &lt;- sp::SpatialPoints(starts)
  spdf &lt;- crw(agent, stepLength = 5, stddev = 10)
  spdfNew &lt;- crw(spdf, stepLength = 5, stddev = 10)
  terra::plot(spdf, pch = 19)
  terra::points(spdfNew, col = "blue", pch = 19)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>


</div>