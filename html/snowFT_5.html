<div class="container">

<table style="width: 100%;"><tr>
<td>snowFT-cluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cluster-Level Functions</h2>

<h3>Description</h3>

<p>Functions that extend the collection of cluster-level functions of the
<span class="pkg">parallel</span>/<span class="pkg">snow</span> package while providing additional features, including reproducibility and dynamic cluster resizing. The heart of the package is the function
<code>performParallel</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">performParallel(count, x, fun, initfun = NULL, initexpr = NULL, 
                export = NULL, exitfun = NULL, 
                printfun = NULL, printargs = NULL, 
                printrepl = max(length(x)/10,1), 
                cltype = getClusterOption("type"),
                cluster.args = NULL,
                gentype = "RNGstream", seed = sample(1:9999999,6), 
                prngkind = "default", para = 0, 
                mngtfiles = c(".clustersize",".proc",".proc_fail"),
                ft_verbose = FALSE, ...)

clusterApplyFT(cl, x, fun, initfun = NULL, initexpr = NULL, 
               export = NULL, exitfun = NULL, 
               printfun = NULL, printargs = NULL, 
               printrepl = max(length(x)/10,1), gentype = "None", 
               seed = rep(123456,6), prngkind = "default", para = 0, 
               mngtfiles = c(".clustersize",".proc",".proc_fail"), 
               ft_verbose = FALSE, ...)
               
clusterCallpart(cl, nodes, fun, ...)

clusterEvalQpart(cl, nodes, expr)

printClusterInfo(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>Number of cluster nodes. If <code>count=0</code>, the process runs sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>Cluster object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of values to be passed to function <code>fun</code>. 
Its length determines how many times <code>fun</code> is to
be called. <code>x[i]</code> is passed to <code>fun</code> (as its first argument)
in the i-th call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function or character string naming a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initfun</code></td>
<td>
<p>Function or character string naming a
function with no
arguments that is to
be called on each node prior to the computation. It is passed to workers using <code>clusterCall</code>. 
It can be used for example for loading required libraries or sourcing data files. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initexpr</code></td>
<td>
<p>Expression evaluated on workers at the time of node initialization. It corresponds to what would be passed to <code>clusterEvalQ</code> before the computation. <code>initfun</code> and <code>initexpr</code> can be used for the same purpose, but <code>initexpr</code> does not need to have a form of a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export</code></td>
<td>
<p>Character vector naming objects to be exported to workers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exitfun</code></td>
<td>
<p>Function or character string naming a function with no
arguments that is to
be called on each node after the computation is completed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printfun, printargs, printrepl</code></td>
<td>
<p><code>printfun</code> is a function or
character string naming a function that is to be called on the master
node after each
<code>printrepl</code> completed replicates, and thus it can be used for accessing
intermediate results. Arguments passed to
<code>printfun</code> are: a list (of length <code>|x|</code>) of results (including
the non-finished
ones), the number of finished results,
and <code>printargs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cltype</code></td>
<td>
<p>Character string that specifies cluster type (see
<code>makeClusterFT</code>). Possible values are 'MPI' and 'SOCK' ('PVM' is currently not available).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.args</code></td>
<td>
<p>List of arguments passed to the function <code>makeClusterFT</code>. For the ‘SOCK’ layer, the most useful argument in this list is <code>names</code> which can contain a vector of host names, or a list containing specification for each host (see Example in <code>makeCluster</code>). Due to the dynamic resizing feature, the length of this vector (or list) does not need to match the size of the cluster - it is used as a pool from which hosts are taken as they are needed. Another useful argument is <code>outfile</code>, specifying name of a file to which slave node output is to be directed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gentype</code></td>
<td>
<p>Character string that specifies the type of the random number generator (RNG). 
Possible values: "RNGstream" (L'Ecuyer's RNG),
"SPRNG", or "None", see
<code>clusterSetupRNG.FT</code>. If
<code>gentype="None"</code>, no RNG action is taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed, prngkind, para</code></td>
<td>
<p>Seed, kind and parameters for the RNG (see
<code>clusterSetupRNG.FT</code>). Seed can be an integer or a vector of six integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mngtfiles</code></td>
<td>
<p>A character vector of length 3 containing names of
management files: <code>mngtfiles[1]</code> for managing the
cluster size, <code>mngtfiles[2]</code> for monitoring replicates
as they are processed, <code>mngtfiles[3]</code> for monitoring failed
replicates. If any of these files equals an empty string, the
corresponding management actions (i.e. dynamic cluster resizing, outputting processed replicates, and cluster repair in case of failures) are not performed. If the files
already exist, their content
is overwritten. Note that the cluster repair action was only available for PVM which is switched off. Furthermore, the dynamic cluster resizing is not available for MPI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ft_verbose</code></td>
<td>
<p>If TRUE, debugging messages are sent to standard output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>Indices of cluster nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>Expression to evaluate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to function <code>fun</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>clusterApplyFT</code> is a version of
<code>clusterApplyLB</code> of the <span class="pkg">parallel</span>/<span class="pkg">snow</span> package with additional features, such as results
reproducibility, computation transparency and dynamic cluster
resizing. The master process does the management in its
waiting time. 
</p>
<p>The file <code>mngtfiles[1]</code> (which defaults to ‘.clustersize’) is initially written by the master
prior to the computation and it contains a single integer value corresponding
to the number of cluster nodes. The value can be arbitrarily changed by
the user (but should remain in the same format). The master reads the
file  in its waiting time. If the value in this file is larger than
the current
cluster size, new nodes are created and the computation is expanded on
them. If on the other hand the value is smaller, nodes are
successively discarded after they finish their current
computation.
The arguments <code>initfun, initexpr, export</code> and <code>exitfun</code> in the 
<code>clusterApplyFT</code> function are only used, if there are
changes in the cluster, i.e. if new nodes are added or if nodes are
removed from cluster.
</p>
<p>The RNG uses
the scheme 'one stream per replicate', in contrary to 'one stream per
node' used by <code>clusterApplyLB</code>. Therefore with each replicate, the
RNG is reset to the corresponding stream (identified by the replicate
number). Thus, the final results are reproducible regardless of how many nodes were used. 
</p>
<p><code>performParallel</code> is a wrapper function for
<code>clusterApplyFT</code> and we recommend using this function rather than
using <code>clusterApplyFT</code> directly. It creates a cluster of
<code>count</code> nodes;
on all nodes it
calls <code>initfun</code>, evaluates <code>initexpr</code> and <code>export</code>, and initializes the RNG. Then it calls
<code>clusterApplyFT</code>. After the computation is finished, it calls
<code>exitfun</code> on all nodes and stops the cluster. If <code>count=0</code>, function <code>fun</code> is invoked sequentially with the same settings (including random numbers) as it would in parallel. This mode can be used for debugging purposes.
</p>
<p><code>clusterCallpart</code> calls a function <code>fun</code> with identical arguments 
<code>...</code> on nodes
specified by indices <code>nodes</code> in the cluster <code>cl</code> and returns a list
of the results.
</p>
<p><code>clusterEvalQpart</code> evaluates a literal expression on nodes
specified by indices <code>nodes</code>. 
</p>
<p><code>printClusterInfo</code> prints out some basic information about the cluster.
</p>


<h3>Value</h3>

<p><code>clusterApplyFT</code> returns a list of two elements. The first
one is a list (of length <code>|x|</code>) of results, the second one is the
(possibly updated)
cluster object.
</p>
<p><code>performParallel</code> returns a list of results.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# generates n normally distributed random numbers in r replicates
# on p nodes and prints their mean after each r/10 replicate.

printfun &lt;- function(res, n, args = NULL) {
  res &lt;- unlist(res)
  res &lt;- res[!is.null(res)]
  print(paste("mean after:", n, "replicates:", mean(res),
           "(from", length(res), "RNs)"))
  }

r &lt;- 1000; n &lt;- 100; p &lt;- 5
res &lt;- performParallel(p, rep(n,r), fun = rnorm, seed = 1, 
                printfun = printfun)

# Setting p &lt;- 0 will run the rnorm call above sequentially and  
# should give exactly the same results
res.seq &lt;- performParallel(0, rep(n,r), fun = rnorm, seed = 1, 
                printfun = printfun)
identical(res, res.seq)

# Example with worker initialization
mean &lt;- 20
sd &lt;- 10
myfun &lt;- function(r) rdnorm(r, mean = mean, sd = sd)

res &lt;- unlist(performParallel(p, rep(1000, 100), fun = myfun, seed = 123,
         initexpr = library(extraDistr), export = c("mean", "sd")))
hist(res)

# See example in ?snowFT for plotting cluster usage.

## End(Not run)

</code></pre>


</div>