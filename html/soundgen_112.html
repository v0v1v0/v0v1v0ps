<div class="container">

<table style="width: 100%;"><tr>
<td>getPitchZc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Zero-crossing rate</h2>

<h3>Description</h3>

<p>A less precise, but very quick method of pitch tracking based on measuring
zero-crossing rate in low-pass-filtered audio. Recommended for processing
long recordings with typical pitch values well below the first formant
frequency, such as speech. Calling this function is considerably faster than
using the same pitch-tracking method in <code>analyze</code>. Note that,
unlike analyze(), it returns the times of individual zero crossings
(hopefully corresponding to glottal cycles) instead of pitch values at fixed
time intervals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getPitchZc(
  x,
  samplingRate = NULL,
  scale = NULL,
  from = NULL,
  to = NULL,
  pitchFloor = 50,
  pitchCeiling = 400,
  zcThres = 0.1,
  zcWin = 5,
  silence = 0.04,
  envWin = 5,
  summaryFun = c("mean", "sd"),
  reportEvery = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>path to a folder, one or more wav or mp3 files c('file1.wav',
'file2.mp3'), Wave object, numeric vector, or a list of Wave objects or
numeric vectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingRate</code></td>
<td>
<p>sampling rate of <code>x</code> (only needed if <code>x</code> is a
numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>maximum possible amplitude of input used for normalization of
input vector (only needed if <code>x</code> is a numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from, to</code></td>
<td>
<p>if NULL (default), analyzes the whole sound, otherwise
from...to (s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pitchFloor, pitchCeiling</code></td>
<td>
<p>absolute bounds for pitch candidates (Hz)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zcThres</code></td>
<td>
<p>pitch candidates with certainty below this value are treated
as noise and set to NA (0 = anything goes, 1 = pitch must be perfectly
stable over <code>zcWin</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zcWin</code></td>
<td>
<p>certainty in pitch candidates depends on how stable pitch is
over <code>zcWin</code> glottal cycles (odd integer &gt; 3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silence</code></td>
<td>
<p>minimum root mean square (RMS) amplitude, below which pitch
candidates are set to NA (NULL = don't consider RMS amplitude)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envWin</code></td>
<td>
<p>window length for calculating RMS envelope, ms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summaryFun</code></td>
<td>
<p>functions used to summarize each acoustic characteristic;
see <code>analyze</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reportEvery</code></td>
<td>
<p>when processing multiple inputs, report estimated time
left every ... iterations (NULL = default, NA = don't report)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithm: the audio is bandpass-filtered from <code>pitchFloor</code> to <code>pitchCeiling</code>, and the timing of all zero crossings is saved. This is not enough, however, because unvoiced sounds like white noise also have plenty of zero crossings. Accordingly, an attempt is made to detect voiced segments (or steady musical tones, etc.) by looking for stable regions, with several zero-crossings at relatively regular intervals (see parameters <code>zcThres</code> and <code>zcWin</code>). Very quiet parts of audio are also treated as not having a pitch.
</p>


<h3>Value</h3>

<p>Returns a dataframe containing </p>
<dl>
<dt>time</dt>
<dd>
<p>time stamps of
all zero crossings except the last one, after bandpass-filtering</p>
</dd>
<dt>pitch</dt>
<dd>
<p>pitch calculated from the time between consecutive zero
crossings</p>
</dd> <dt>cert</dt>
<dd>
<p>certainty in each pitch candidate calculated from
local pitch stability, 0 to 1</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>analyze</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(sheep, package = 'seewave')
# spectrogram(sheep)
zc = getPitchZc(sheep, pitchCeiling = 250)
plot(zc$detailed[, c('time', 'pitch')], type = 'b')

# Convert to a standard pitch contour sampled at regular time intervals:
pitch = getSmoothContour(
  anchors = data.frame(time = zc$detailed$time, value = zc$detailed$pitch),
  len = 1000, NA_to_zero = FALSE, discontThres = 0)
spectrogram(sheep, extraContour = pitch, ylim = c(0, 2))

## Not run: 
# process all files in a folder
zc = getPitchZc('~/Downloads/temp')
zc$summary

## End(Not run)
</code></pre>


</div>