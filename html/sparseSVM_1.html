<div class="container">

<table style="width: 100%;"><tr>
<td>sparseSVM-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution Paths for Sparse High-dimensional Support Vector Machine with Lasso or Elastic-Net Regularization</h2>

<h3>Description</h3>

<p>Fast algorithm for fitting solution paths for sparse SVM regularized by lasso or elastic-net that generate sparse solutions.</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> sparseSVM</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.1-7</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2024-09-23</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Accepts <code>X,y</code> data for binary classification and
produces the solution path over a grid of values of the regularization parameter <code>lambda</code>. Also provides functions for plotting, prediction and parallelized cross-validation.
</p>


<h3>Author(s)</h3>

<p>Congrui Yi and Yaohui Zeng <br>
Maintainer: Congrui Yi &lt;eric.ycr@gmail.com&gt;
</p>


<h3>References</h3>

<p>Yi, C. and Huang, J. (2017) 
<em>Semismooth Newton Coordinate Descent Algorithm for 
Elastic-Net Penalized Huber Loss Regression and Quantile Regression</em>,
doi: <a href="https://doi.org/10.1080/10618600.2016.1256816">10.1080/10618600.2016.1256816</a> <br><em>Journal of Computational and Graphical Statistics</em> <br></p>


<h3>Examples</h3>

<pre><code class="language-R">X = matrix(rnorm(1000*100), 1000, 100)
b = 3
w = 5*rnorm(10)
eps = rnorm(1000)
y = sign(b + drop(X[,1:10] %*% w + eps))

fit = sparseSVM(X, y)
coef(fit, 0.05)
predict(fit, X[1:5,], lambda = c(0.2, 0.1))
plot(fit)

cv.fit &lt;- cv.sparseSVM(X, y, ncores = 2, seed = 1234)
predict(cv.fit, X)
coef(cv.fit)
plot(cv.fit)
</code></pre>


</div>