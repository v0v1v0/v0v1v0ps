<div class="container">

<table style="width: 100%;"><tr>
<td>structdist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Find the Structural Distances Between Two or More Graphs </h2>

<h3>Description</h3>

<p><code>structdist</code> returns the structural distance between the labeled graphs <code>g1</code> and <code>g2</code> in stack <code>dat</code> based on Hamming distance for dichotomous data, or else the absolute (manhattan) distance.  If <code>normalize</code> is true, this distance is divided by its dichotomous theoretical maximum (conditional on |V(G)|).
</p>


<h3>Usage</h3>

<pre><code class="language-R">structdist(dat, g1=NULL, g2=NULL, normalize=FALSE, diag=FALSE,
    mode="digraph", method="anneal",  reps=1000, prob.init=0.9,
    prob.decay=0.85, freeze.time=25, full.neighborhood=TRUE,
    mut=0.05, pop=20, trials=5, exchange.list=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> one or more input graphs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g1</code></td>
<td>
<p> a vector indicating which graphs to compare (by default, all elements of <code>dat</code>).  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g2</code></td>
<td>
<p> a vector indicating against which the graphs of <code>g1</code> should be compared (by default, all graphs). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> divide by the number of available dyads? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p> boolean indicating whether or not the diagonal should be treated as valid data.  Set this true if and only if the data can contain loops.  <code>diag</code> is <code>FALSE</code> by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p> string indicating the type of graph being evaluated.  <code>"digraph"</code> indicates that edges should be interpreted as directed; <code>"graph"</code> indicates that edges are undirected.  <code>mode</code> is set to <code>"digraph"</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> method to be used to search the space of accessible permutations; must be one of <code>"none"</code>, <code>"exhaustive"</code>, <code>"anneal"</code>, <code>"hillclimb"</code>, or <code>"mc"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reps</code></td>
<td>
<p> number of iterations for Monte Carlo method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.init</code></td>
<td>
<p> initial acceptance probability for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.decay</code></td>
<td>
<p> cooling multiplier for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freeze.time</code></td>
<td>
<p> freeze time for the annealing routine. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.neighborhood</code></td>
<td>
<p> should the annealer evaluate the full neighborhood of pair exchanges at each iteration? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mut</code></td>
<td>
<p> GA Mutation rate (currently ignored). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p> GA population (currently ignored). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trials</code></td>
<td>
<p> number of GA populations (currently ignored). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exchange.list</code></td>
<td>
<p> information on which vertices are exchangeable (see below); this must be a single number, a vector of length n, or a nx2 matrix. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The structural distance between two graphs G and H is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_S\left(G,H \left| L_G,L_H\right.\right) = \min_{L_G,L_H} d\left(\ell\left(G\right),\ell\left(H\right)\right)</code>
</p>

<p>where <code class="reqn">L_G</code> is the set of accessible permutations/labelings of G, and <code class="reqn">\ell(G)</code> is a permuation/relabeling of the vertices of G (<code class="reqn">\ell(G) \in L_G</code>).  The set of accessible permutations on a given graph is determined by the <em>theoretical exchangeability</em> of its vertices; in a  nutshell, two vertices are considered to be theoretically exchangeable for a given problem if all predictions under the conditioning theory are invariant to a relabeling of the vertices in question (see Butts and Carley (2001) for a more formal exposition).  Where no vertices are exchangeable, the structural distance becomes the its labeled counterpart (here, the Hamming distance).  Where <em>all</em> vertices are exchangeable, the structural distance reflects the distance between unlabeled graphs; other cases correspond to distance under partial labeling.  
</p>
<p>The accessible permutation set is determined by the <code>exchange.list</code> argument, which is dealt with in the following manner. First, <code>exchange.list</code> is expanded to fill an nx2 matrix.  If <code>exchange.list</code> is a single number, this is trivially accomplished by replication; if <code>exchange.list</code> is a vector of length n, the matrix is formed by <code>cbind</code>ing two copies together.  If <code>exchange.list</code> is already an nx2 matrix, it is left as-is.  Once the nx2 exchangeabiliy matrix has been formed, it is interpreted as follows: columns refer to graphs 1 and 2, respectively; rows refer to their corresponding vertices in the original adjacency matrices; and vertices are taken to be theoretically exchangeable iff their corresponding exchangeability matrix values are identical.  To obtain an unlabeled distance (the default), then, one could simply let <code>exchange.list</code> equal any single number.  To obtain the Hamming distance, one would use the vector <code>1:n</code>.
</p>
<p>Because the set of accessible permutations is, in general, very large (<code class="reqn">o(n!)</code>), searching the set for the minimum distance is a non-trivial affair.  Currently supported methods for estimating the structural distance are hill climbing, simulated annealing, blind monte carlo search, or exhaustive search (it is also possible to turn off searching entirely).  Exhaustive search is not recommended for graphs larger than size 8 or so, and even this may take days; still, this is a valid alternative for small graphs.  Blind monte carlo search and hill climbing tend to be suboptimal for this problem and are not, in general recommended, but they are available if desired.  The preferred (and default) option for permutation search is simulated annealing, which seems to work well on this problem (though some tinkering with the annealing parameters may be needed in order to get optimal performance).  See the help for <code>lab.optimize</code> for more information regarding these options.
</p>
<p>Structural distance matrices may be used in the same manner as any other distance matrices (e.g., with multidimensional scaling, cluster analysis, etc.)  Classical null hypothesis tests should not be employed with structural distances, and QAP tests are almost never appropriate (save in the uniquely labeled case).  See <code>cugtest</code> for a more reasonable alternative.
</p>


<h3>Value</h3>

<p>A structural distance matrix
</p>


<h3>Warning </h3>

<p>The search process can be <em>very slow</em>, particularly for large graphs.  In particular, the <em>exhaustive</em> method is order factorial, and will take approximately forever for unlabeled graphs of size greater than about 7-9.</p>


<h3>Note</h3>

<p> Consult Butts and Carley (2001) for advice and examples on theoretical exchangeability. </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p>Butts, C.T. and Carley, K.M.  (2005).  “Some Simple Algorithms for Structural Comparison.”  <em>Computational and Mathematical Organization Theory,</em> 11(4), 291-305.
</p>
<p>Butts, C.T., and Carley, K.M.  (2001).  “Multivariate Methods for Interstructural Analysis.”  CASOS Working Paper, Carnegie Mellon University. 
</p>


<h3>See Also</h3>

 <p><code>hdist</code>, <code>sdmat</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate two random graphs
g&lt;-array(dim=c(3,5,5))
g[1,,]&lt;-rgraph(5)
g[2,,]&lt;-rgraph(5)

#Copy one of the graphs and permute it
g[3,,]&lt;-rmperm(g[2,,])

#What are the structural distances between the labeled graphs?
structdist(g,exchange.list=1:5)

#What are the structural distances between the underlying unlabeled 
#graphs?
structdist(g,method="anneal", prob.init=0.9, prob.decay=0.85, 
    freeze.time=50, full.neighborhood=TRUE)
</code></pre>


</div>