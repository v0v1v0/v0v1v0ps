<div class="container">

<table style="width: 100%;"><tr>
<td>rmhmodel.default</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build Point Process Model for Metropolis-Hastings Simulation.</h2>

<h3>Description</h3>

<p>Builds a description of a point process model
for use in simulating the model by the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## Default S3 method:
rmhmodel(..., 
         cif=NULL, par=NULL, w=NULL, trend=NULL, types=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cif</code></td>
<td>
<p>Character string specifying the choice of model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Parameters of the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Spatial window in which to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>Specification of the trend in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>types</code></td>
<td>
<p>A vector of factor levels defining the possible
marks, for a multitype process.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The generic function <code>rmhmodel</code> takes a
description of a point process model in some format, and
converts it into an object of class <code>"rmhmodel"</code>
so that simulations of the model can be generated using
the Metropolis-Hastings algorithm <code>rmh</code>. 
</p>
<p>This function <code>rmhmodel.default</code> is the default method.
It builds a description of the point process model
from the simple arguments listed.
</p>
<p>The argument <code>cif</code> is a character string specifying the choice of
interpoint interaction for the point process. The current options are
</p>

<dl>
<dt><code>'areaint'</code></dt>
<dd>
<p>Area-interaction process.</p>
</dd>
<dt><code>'badgey'</code></dt>
<dd>
<p>Baddeley-Geyer (hybrid Geyer) process.</p>
</dd>
<dt><code>'dgs'</code></dt>
<dd>
<p>Diggle, Gates and Stibbard (1987) process</p>
</dd>
<dt><code>'diggra'</code></dt>
<dd>
<p>Diggle and Gratton (1984) process</p>
</dd>
<dt><code>'fiksel'</code></dt>
<dd>
<p>Fiksel double exponential process (Fiksel, 1984).</p>
</dd>
<dt><code>'geyer'</code></dt>
<dd>
<p>Saturation process (Geyer, 1999).</p>
</dd>
<dt><code>'hardcore'</code></dt>
<dd>
<p>Hard core process</p>
</dd>
<dt><code>'lennard'</code></dt>
<dd>
<p>Lennard-Jones process</p>
</dd>
<dt><code>'lookup'</code></dt>
<dd>
<p>General isotropic pairwise interaction process,
with the interaction function specified via a “lookup table”.</p>
</dd>
<dt><code>'multihard'</code></dt>
<dd>
<p>Multitype hardcore process</p>
</dd>
<dt><code>'penttinen'</code></dt>
<dd>
<p>The Penttinen process</p>
</dd>
<dt><code>'strauss'</code></dt>
<dd>
<p>The Strauss process</p>
</dd>
<dt><code>'straush'</code></dt>
<dd>
<p>The Strauss process with hard core</p>
</dd>
<dt><code>'sftcr'</code></dt>
<dd>
<p>The Softcore process</p>
</dd>
<dt><code>'straussm'</code></dt>
<dd>
<p> The multitype Strauss process</p>
</dd>
<dt><code>'straushm'</code></dt>
<dd>
<p>Multitype Strauss process with hard core</p>
</dd>
<dt><code>'triplets'</code></dt>
<dd>
<p>Triplets process (Geyer, 1999).</p>
</dd>
</dl>
<p>It is also possible to specify a <em>hybrid</em> of these interactions
in the sense of Baddeley et al (2013).
In this case, <code>cif</code> is a character vector containing names from
the list above. For example, <code>cif=c('strauss', 'geyer')</code> would
specify a hybrid of the Strauss and Geyer models.
</p>
<p>The argument <code>par</code> supplies parameter values appropriate to
the conditional intensity function being invoked.
For the interactions listed above, these parameters are:
</p>

<dl>
<dt>areaint:</dt>
<dd>
<p>(Area-interaction process.) A <b>named</b> list with components
<code>beta,eta,r</code> which are respectively the “base”
intensity, the scaled interaction parameter and the
interaction radius.  
</p>
</dd>
<dt>badgey:</dt>
<dd>
<p>(Baddeley-Geyer process.)
A <b>named</b> list with components
<code>beta</code> (the “base” intensity), <code>gamma</code> (a vector
of non-negative interaction parameters), <code>r</code> (a vector
of interaction radii, of the same length as <code>gamma</code>,
in <em>increasing</em> order), and <code>sat</code> (the saturation
parameter(s); this may be a scalar, or a vector of the same
length as <code>gamma</code> and <code>r</code>; all values should be at
least 1).  Note that because of the presence of “saturation”
the <code>gamma</code> values are permitted to be larger than 1.
</p>
</dd>
<dt>dgs:</dt>
<dd>
<p>(Diggle, Gates, and Stibbard process.
See Diggle, Gates, and Stibbard (1987))
A <b>named</b> list with components
<code>beta</code> and <code>rho</code>.  This process has pairwise interaction
function equal to
</p>
<p style="text-align: center;"><code class="reqn">
	e(t) = \sin^2\left(\frac{\pi t}{2\rho}\right)
      </code>
</p>

<p>for <code class="reqn">t &lt; \rho</code>, and equal to 1
for <code class="reqn">t \ge \rho</code>.
</p>
</dd>
<dt>diggra:</dt>
<dd>
<p>(Diggle-Gratton process. See Diggle and Gratton (1984)
and Diggle, Gates and Stibbard (1987).)
A <b>named</b> list with components <code>beta</code>,
<code>kappa</code>, <code>delta</code> and <code>rho</code>.  This process has
pairwise interaction function <code class="reqn">e(t)</code> equal to 0
for <code class="reqn">t &lt; \delta</code>, equal to
</p>
<p style="text-align: center;"><code class="reqn">
	\left(\frac{t-\delta}{\rho-\delta}\right)^\kappa
      </code>
</p>

<p>for <code class="reqn">\delta \le t &lt; \rho</code>,
and equal to 1 for <code class="reqn">t \ge  \rho</code>.
Note that here we use the symbol
<code class="reqn">\kappa</code> where Diggle, Gates, and Stibbard use
<code class="reqn">\beta</code> since we reserve the symbol <code class="reqn">\beta</code>
for an intensity parameter.
</p>
</dd>
<dt>fiksel:</dt>
<dd>
<p>(Fiksel double exponential process, see Fiksel (1984))
A <b>named</b> list with components <code>beta</code>,
<code>r</code>, <code>hc</code>, <code>kappa</code> and <code>a</code>.  This process has
pairwise interaction function <code class="reqn">e(t)</code> equal to 0
for <code class="reqn">t &lt; hc</code>, equal to
</p>
<p style="text-align: center;"><code class="reqn">
	\exp(a \exp(- \kappa t))
      </code>
</p>

<p>for <code class="reqn">hc \le t &lt; r</code>,
and equal to 1 for <code class="reqn">t \ge  r</code>.
</p>
</dd>
<dt>geyer:</dt>
<dd>
<p>(Geyer's saturation process. See Geyer (1999).)
A <b>named</b> list
with components <code>beta</code>, <code>gamma</code>, <code>r</code>, and <code>sat</code>.
The components <code>beta</code>, <code>gamma</code>, <code>r</code> are as for
the Strauss model, and <code>sat</code> is the “saturation”
parameter.  The model is Geyer's “saturation” point process
model, a modification of the Strauss process in which
we effectively impose an upper limit (<code>sat</code>) on the number of
neighbours which will be counted as close to a given point.
</p>
<p>Explicitly, a saturation point process with interaction
radius <code class="reqn">r</code>, saturation threshold <code class="reqn">s</code>, and
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
is the point process in which each point <code class="reqn">x_i</code>
in the pattern <code class="reqn">X</code> contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">\beta \gamma^{\min(s, t(x_i,X))}</code>
</p>

<p>to the probability density of the point pattern,
where <code class="reqn">t(x_i,X)</code> denotes the number of
“<code class="reqn">r</code>-close neighbours” of <code class="reqn">x_i</code> in the
pattern <code class="reqn">X</code>.
</p>
<p>If the saturation threshold <code class="reqn">s</code> is infinite,
the Geyer process reduces to a Strauss process
with interaction parameter <code class="reqn">\gamma^2</code>
rather than <code class="reqn">\gamma</code>.
</p>
</dd>
<dt>hardcore:</dt>
<dd>
<p>(Hard core process.) A <b>named</b> list
with components <code>beta</code> and <code>hc</code>
where <code>beta</code> is the base intensity and <code>hc</code> is the
hard core distance.
This process has pairwise interaction function <code class="reqn">e(t)</code>
equal to 1 if <code class="reqn">t &gt; hc</code> and 0 if <code class="reqn">t &lt;= hc</code>.
</p>
</dd>
<dt>lennard:</dt>
<dd>
<p>(Lennard-Jones process.) A <b>named</b> list
with components <code>sigma</code> and <code>epsilon</code>,
where <code>sigma</code> is the characteristic diameter
and <code>epsilon</code> is the well depth.
See <code>LennardJones</code> for explanation.
</p>
</dd>
<dt>multihard:</dt>
<dd>
<p>(Multitype hard core process.) A <b>named</b> list
with components <code>beta</code> and <code>hradii</code>,
where <code>beta</code> is a vector of base intensities for each type
of point, and <code>hradii</code> is a matrix of hard core radii
between each pair of types. 
</p>
</dd>
<dt>penttinen:</dt>
<dd>
<p>(Penttinen process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the “base”
intensity, the pairwise interaction parameter, and the disc radius.
Note that <code>gamma</code> must be less than or equal to 1.
See <code>Penttinen</code> for explanation.
(Note that there is also an algorithm for perfect simulation
of the Penttinen process, <code>rPenttinen</code>)
</p>
</dd>
<dt>strauss:</dt>
<dd>
<p>(Strauss process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the “base”
intensity, the pairwise interaction parameter and the
interaction radius.  Note that <code>gamma</code> must be less than
or equal to 1.
(Note that there is also an algorithm for perfect simulation
of the Strauss process, <code>rStrauss</code>)
</p>
</dd>
<dt>straush:</dt>
<dd>
<p>(Strauss process with hardcore.) A <b>named</b> list with
entries <code>beta,gamma,r,hc</code> where <code>beta</code>, <code>gamma</code>,
and <code>r</code> are as for the Strauss process, and <code>hc</code> is
the hardcore radius.  Of course <code>hc</code> must be less than
<code>r</code>.
</p>
</dd>
<dt>sftcr:</dt>
<dd>
<p>(Softcore process.) A <b>named</b> list with components
<code>beta,sigma,kappa</code>.  Again <code>beta</code> is a “base”
intensity. The pairwise interaction between two points
<code class="reqn">u \neq v</code> is
</p>
<p style="text-align: center;"><code class="reqn">
	\exp \left \{
	- \left ( \frac{\sigma}{||u-v||} \right )^{2/\kappa}
	\right \}
      </code>
</p>

<p>Note that it is necessary that <code class="reqn">0 &lt; \kappa &lt; 1</code>.
</p>
</dd>
<dt>straussm:</dt>
<dd>
<p>(Multitype Strauss process.) A <b>named</b> list with components
</p>

<ul>
<li>
<p><code>beta</code>: 
A vector of “base” intensities, one for each possible type.
</p>
</li>
<li>
<p><code>gamma</code>:
A <b>symmetric</b> matrix of interaction parameters,
with <code class="reqn">\gamma_{ij}</code> pertaining to the interaction between
type <code class="reqn">i</code> and type <code class="reqn">j</code>.
</p>
</li>
<li>
<p><code>radii</code>:
A <b>symmetric</b> matrix of interaction radii, with
entries <code class="reqn">r_{ij}</code> pertaining to the interaction between type
<code class="reqn">i</code> and type <code class="reqn">j</code>.
</p>
</li>
</ul>
</dd>
<dt>straushm:</dt>
<dd>
<p>(Multitype Strauss process with hardcore.)
A <b>named</b> list with components <code>beta</code> and <code>gamma</code>
as for <code>straussm</code> and
<b>two</b> “radii” components:
</p>

<ul>
<li> <p><code>iradii</code>: the interaction radii
</p>
</li>
<li> <p><code>hradii</code>: the hardcore radii
</p>
</li>
</ul>
<p>which are both symmetric matrices of nonnegative numbers.
The entries of <code>hradii</code> must be less than the
corresponding entries
of <code>iradii</code>.
</p>
</dd>
<dt>triplets:</dt>
<dd>
<p>(Triplets process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the “base”
intensity, the triplet interaction parameter and the
interaction radius.  Note that <code>gamma</code> must be less than
or equal to 1.
</p>
</dd>
<dt>lookup:</dt>
<dd>
<p>(Arbitrary pairwise interaction process with isotropic interaction.)
A <b>named</b> list with components
<code>beta</code>, <code>r</code>, and <code>h</code>, or just with components
<code>beta</code> and <code>h</code>.
</p>
<p>This model is the pairwise interaction process
with an isotropic interaction given by any chosen function <code class="reqn">H</code>.
Each pair of points <code class="reqn">x_i, x_j</code> in the
point pattern contributes
a factor <code class="reqn">H(d(x_i, x_j))</code>
to the probability density, where <code class="reqn">d</code> denotes distance
and <code class="reqn">H</code> is the pair interaction function.
</p>
<p>The component <code>beta</code> is a
(positive) scalar which determines the “base” intensity
of the process.
</p>
<p>In this implementation, <code class="reqn">H</code> must be a step function.
It is specified by the user in one of two ways.
</p>

<ul>
<li>
<p><b>as a vector of values:</b>
If <code>r</code> is present, then <code>r</code> is assumed to 
give the locations of jumps in the function <code class="reqn">H</code>,
while the vector <code>h</code> gives the corresponding
values of the function.
</p>
<p>Specifically, the interaction function
<code class="reqn">H(t)</code> takes the value <code>h[1]</code>
for distances <code class="reqn">t</code> in the interval 
<code>[0, r[1])</code>; takes the value <code>h[i]</code>
for distances <code class="reqn">t</code> in the interval 
<code>[r[i-1], r[i])</code> where
<code class="reqn">i = 2,\ldots, n</code>;
and takes the value 1 for <code class="reqn">t \ge r[n]</code>.
Here <code class="reqn">n</code> denotes the length of <code>r</code>.
</p>
<p>The components <code>r</code> and <code>h</code>
must be numeric vectors of equal length.
The <code>r</code> values must be strictly positive, and 
sorted in increasing order.
</p>
<p>The entries of <code>h</code> must be non-negative. 
If any entry of <code>h</code> is greater than 1,
then the entry <code>h[1]</code> must be 0 (otherwise the specified
process is non-existent).
</p>
<p>Greatest efficiency is achieved if the values of
<code>r</code> are equally spaced.
</p>
<p>[<b>Note:</b> The usage of <code>r</code> and <code>h</code>
has <em>changed</em> from the previous usage in <span class="pkg">spatstat</span>
versions 1.4-7 to 1.5-1, in which ascending order was not required,
and in which the first entry of <code>r</code> had to be 0.]
</p>
</li>
<li>
<p><b>as a stepfun object:</b>
If <code>r</code> is absent, then <code>h</code> must be
an object of class <code>"stepfun"</code> specifying
a step function. Such objects are created by
<code>stepfun</code>. 
</p>
<p>The stepfun object <code>h</code> must be right-continuous
(which is the default using <code>stepfun</code>.)
</p>
<p>The values of the step function must all be nonnegative.
The values must all be less than 1
unless the function is identically zero on some initial
interval <code class="reqn">[0,r)</code>. The rightmost value (the value of
<code>h(t)</code> for large <code>t</code>) must be equal to 1.
</p>
<p>Greatest efficiency is achieved if the jumps (the
“knots” of the step function) are equally spaced.
</p>
</li>
</ul>
</dd>
</dl>
<p>For a hybrid model, the argument <code>par</code> should be a list,
of the same length as <code>cif</code>, such that <code>par[[i]]</code>
is a list of the parameters required for the interaction
<code>cif[i]</code>. See the Examples.
</p>
<p>The optional argument <code>trend</code> determines the spatial trend in the model,
if it has one. It should be a function or image
(or a list of such, if the model is multitype)
to provide the value of the trend at an arbitrary point.
</p>

<dl>
<dt>trend given as a function:</dt>
<dd>
<p>A trend
function may be a function of any number of arguments,
but the first two must be the <code class="reqn">x,y</code> coordinates of
a point.  Auxiliary arguments may be passed
to the <code>trend</code> function at the time of simulation,
via the <code>...</code> argument to <code>rmh</code>.
</p>
<p>The function <b>must</b> be <b>vectorized</b>.
That is, it must be capable of accepting vector valued
<code>x</code> and <code>y</code> arguments.  Put another way,
it must be capable of calculating the trend value at a
number of points, simultaneously, and should return the
<b>vector</b> of corresponding trend values.
</p>
</dd>
<dt>trend given as an image:</dt>
<dd>
<p>An image (see <code>im.object</code>)
provides the trend values at a grid of
points in the observation window and determines the trend
value at other points as the value at the nearest grid point.
</p>
</dd>
</dl>
<p>Note that the trend or trends must be <b>non-negative</b>;
no checking is done for this.
</p>
<p>The optional argument <code>w</code> specifies the window
in which the pattern is to be generated.  If specified, it must be in
a form which can be coerced to an object of class <code>owin</code>
by <code>as.owin</code>.
</p>
<p>The optional argument <code>types</code> specifies the possible
types in a multitype point process. If the model being simulated
is multitype, and <code>types</code> is not specified, then this vector
defaults to <code>1:ntypes</code> where <code>ntypes</code> is the number of
types.
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhmodel"</code>, which is essentially
a list of parameter values for the model.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the model chosen.
</p>


<h3>Warnings in Respect of “lookup”</h3>

<p>For the <code>lookup</code> cif, 
the entries of the <code>r</code> component of <code>par</code>
must be <em>strictly positive</em> and sorted into ascending order.
</p>
<p>Note that if you specify the <code>lookup</code> pairwise interaction
function via <code>stepfun()</code> the arguments <code>x</code>
and <code>y</code> which are passed to <code>stepfun()</code> are slightly
different from <code>r</code> and <code>h</code>:  <code>length(y)</code> is equal
to <code>1+length(x)</code>; the final entry of <code>y</code> must be equal
to 1 — i.e. this value is explicitly supplied by the user rather
than getting tacked on internally.
</p>
<p>The step function returned by <code>stepfun()</code> must be right
continuous (this is the default behaviour of <code>stepfun()</code>)
otherwise an error is given.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 1–43.
<code>DOI: 10.18637/jss.v055.i11</code>
</p>
<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 – 212.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 – 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359–373.
</p>
<p>Fiksel, T. (1984)
Estimation of parameterized pair potentials
of marked and non-marked Gibbsian point processes.
<em>Electronische Informationsverabeitung und Kybernetika</em>
<b>20</b>, 270–278.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79–140.
</p>


<h3>See Also</h3>

<p><code>rmh</code>,
<code>rmhcontrol</code>,
<code>rmhstart</code>,
<code>ppm</code>,
<code>AreaInter</code>, <code>BadGey</code>, <code>DiggleGatesStibbard</code>, <code>DiggleGratton</code>, <code>Fiksel</code>, <code>Geyer</code>, <code>Hardcore</code>, <code>Hybrid</code>, <code>LennardJones</code>, <code>MultiStrauss</code>, <code>MultiStraussHard</code>, <code>PairPiece</code>, <code>Penttinen</code>, <code>Poisson</code>, <code>Softcore</code>, <code>Strauss</code>, <code>StraussHard</code> and <code>Triplets</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">   # Strauss process:
   mod01 &lt;- rmhmodel(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))
   mod01
   # The above could also be simulated using 'rStrauss'

   # Strauss with hardcore:
   mod04 &lt;- rmhmodel(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
                w=owin(c(0,10),c(0,5)))

   # Hard core:
   mod05 &lt;- rmhmodel(cif="hardcore",par=list(beta=2,hc=0.3),
              w=square(5))

   # Soft core:
   w    &lt;- square(10)
   mod07 &lt;- rmhmodel(cif="sftcr",
                     par=list(beta=0.8,sigma=0.1,kappa=0.5),
                     w=w)
   
   # Penttinen process:
   modpen &lt;- rmhmodel(cif="penttinen",par=list(beta=2,gamma=0.6,r=1),
                 w=c(0,10,0,10))

   # Area-interaction process:
   mod42 &lt;- rmhmodel(cif="areaint",par=list(beta=2,eta=1.6,r=0.7),
                 w=c(0,10,0,10))

   # Baddeley-Geyer process:
   mod99 &lt;- rmhmodel(cif="badgey",par=list(beta=0.3,
                     gamma=c(0.2,1.8,2.4),r=c(0.035,0.07,0.14),sat=5),
                     w=unit.square())

   # Multitype Strauss:
   beta &lt;- c(0.027,0.008)
   gmma &lt;- matrix(c(0.43,0.98,0.98,0.36),2,2)
   r    &lt;- matrix(c(45,45,45,45),2,2)
   mod08 &lt;- rmhmodel(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250))
   # specify types
   mod09 &lt;- rmhmodel(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250),
                     types=c("A", "B"))

   # Multitype Hardcore:
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   mod08hard &lt;- rmhmodel(cif="multihard",
                     par=list(beta=beta,hradii=rhc),
                     w=square(250),
                     types=c("A", "B"))

   
   # Multitype Strauss hardcore with trends for each type:
   beta  &lt;- c(0.27,0.08)
   ri    &lt;- matrix(c(45,45,45,45),2,2)
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   tr3   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
   			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
   tr4   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                         exp(-0.6*x+0.5*y)}
                        # log linear trend
   mod10 &lt;- rmhmodel(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=ri,hradii=rhc),w=c(0,250,0,250),
                 trend=list(tr3,tr4))

   # Triplets process:
   mod11 &lt;- rmhmodel(cif="triplets",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))

   # Lookup (interaction function h_2 from page 76, Diggle (2003)):
      r &lt;- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
      h &lt;- 20*(r-0.05)
      h[r&lt;0.05] &lt;- 0
      h[r&gt;0.10] &lt;- 1
      mod17 &lt;- rmhmodel(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))

  # hybrid model
  modhy &lt;- rmhmodel(cif=c('strauss', 'geyer'),
                    par=list(list(beta=100,gamma=0.5,r=0.05),
                             list(beta=1, gamma=0.7,r=0.1, sat=2)),
                    w=square(1))
  modhy
</code></pre>


</div>