<div class="container">

<table style="width: 100%;"><tr>
<td>predict.spIntPGOcc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for prediction at new locations for single-species integrated spatial occupancy models</h2>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples for a set of new locations given an object of class 'spIntPGOcc'. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'spIntPGOcc'
predict(object, X.0, coords.0, n.omp.threads = 1, verbose = TRUE, 
        n.report = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>spIntPGOcc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.0</code></td>
<td>
<p>the design matrix for prediction locations. This should include a column of 1s for the intercept. Covariates should have the same column names as those used when fitting the model with <code>spIntPGOcc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to <code>X.0</code>. Note that <code>spOccupancy</code> assumes coordinates are specified 
in a projected coordinate system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. 
Note, <code>n.omp.threads</code> &gt; 1 might not work on some systems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the 
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report sampling progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>predict.spIntPGOcc</code> that is a list comprised of: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>psi.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence probability values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior predictive samples for the
latent occurrence values.</p>
</td>
</tr>
</table>
<p>The return object will include additional objects used for standard 
extractor functions. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey W. Doser <a href="mailto:doserjef@msu.edu">doserjef@msu.edu</a>, <br>
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Hooten, M. B., and Hefley, T. J. (2019). Bringing Bayesian models to life. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(400)

# Simulate Data -----------------------------------------------------------
# Number of locations in each direction. This is the total region of interest
# where some sites may or may not have a data source. 
J.x &lt;- 8
J.y &lt;- 8
J.all &lt;- J.x * J.y
# Number of data sources.
n.data &lt;- 4
# Sites for each data source. 
J.obs &lt;- sample(ceiling(0.2 * J.all):ceiling(0.5 * J.all), n.data, replace = TRUE)
# Replicates for each data source.
n.rep &lt;- list()
for (i in 1:n.data) {
  n.rep[[i]] &lt;- sample(1:4, size = J.obs[i], replace = TRUE)
}
# Occupancy covariates
beta &lt;- c(0.5, 0.5)
p.occ &lt;- length(beta)
# Detection covariates
alpha &lt;- list()
alpha[[1]] &lt;- runif(2, 0, 1)
alpha[[2]] &lt;- runif(3, 0, 1)
alpha[[3]] &lt;- runif(2, -1, 1)
alpha[[4]] &lt;- runif(4, -1, 1)
p.det.long &lt;- sapply(alpha, length)
p.det &lt;- sum(p.det.long)
sigma.sq &lt;- 2
phi &lt;- 3 / .5
sp &lt;- TRUE

# Simulate occupancy data. 
dat &lt;- simIntOcc(n.data = n.data, J.x = J.x, J.y = J.y, J.obs = J.obs, 
                 n.rep = n.rep, beta = beta, alpha = alpha, sp = sp, 
                 phi = phi, sigma.sq = sigma.sq, cov.model = 'spherical')

y &lt;- dat$y
X &lt;- dat$X.obs
X.p &lt;- dat$X.p
sites &lt;- dat$sites
X.0 &lt;- dat$X.pred
psi.0 &lt;- dat$psi.pred
coords &lt;- as.matrix(dat$coords.obs)
coords.0 &lt;- as.matrix(dat$coords.pred)

# Package all data into a list
occ.covs &lt;- X[, 2, drop = FALSE]
colnames(occ.covs) &lt;- c('occ.cov')
det.covs &lt;- list()
# Add covariates one by one
det.covs[[1]] &lt;- list(det.cov.1.1 = X.p[[1]][, , 2])
det.covs[[2]] &lt;- list(det.cov.2.1 = X.p[[2]][, , 2], 
                      det.cov.2.2 = X.p[[2]][, , 3])
det.covs[[3]] &lt;- list(det.cov.3.1 = X.p[[3]][, , 2])
det.covs[[4]] &lt;- list(det.cov.4.1 = X.p[[4]][, , 2], 
                      det.cov.4.2 = X.p[[4]][, , 3], 
                      det.cov.4.3 = X.p[[4]][, , 4])
data.list &lt;- list(y = y, 
                  occ.covs = occ.covs,
                  det.covs = det.covs, 
                  sites = sites, 
                  coords = coords)

J &lt;- length(dat$z.obs)

# Initial values
inits.list &lt;- list(alpha = list(0, 0, 0, 0), 
                   beta = 0, 
                   phi = 3 / .5, 
                   sigma.sq = 2, 
                   w = rep(0, J), 
                   z = rep(1, J))
# Priors
prior.list &lt;- list(beta.normal = list(mean = 0, var = 2.72), 
                   alpha.normal = list(mean = list(0, 0, 0, 0), 
                                       var = list(2.72, 2.72, 2.72, 2.72)),
                   phi.unif = c(3/1, 3/.1), 
                   sigma.sq.ig = c(2, 2))
# Tuning
tuning.list &lt;- list(phi = 1) 

# Number of batches
n.batch &lt;- 40
# Batch length
batch.length &lt;- 25

out &lt;- spIntPGOcc(occ.formula = ~ occ.cov, 
                  det.formula = list(f.1 = ~ det.cov.1.1, 
                                     f.2 = ~ det.cov.2.1 + det.cov.2.2, 
                                     f.3 = ~ det.cov.3.1, 
                                     f.4 = ~ det.cov.4.1 + det.cov.4.2 + det.cov.4.3), 
                  data = data.list,  
                  inits = inits.list, 
                  n.batch = n.batch, 
                  batch.length = batch.length, 
                  accept.rate = 0.43, 
                  priors = prior.list, 
                  cov.model = "spherical", 
                  tuning = tuning.list, 
                  n.omp.threads = 1, 
                  verbose = TRUE, 
                  NNGP = TRUE, 
                  n.neighbors = 5, 
                  search.type = 'cb', 
                  n.report = 10, 
                  n.burn = 500, 
                  n.thin = 1)
summary(out)

# Predict at new locations ------------------------------------------------
out.pred &lt;- predict(out, X.0, coords.0, verbose = FALSE)
</code></pre>


</div>