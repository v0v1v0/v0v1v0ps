<div class="container">

<table style="width: 100%;"><tr>
<td>scribeCommandArgs-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>scribe command arguments</h2>

<h3>Description</h3>

<p>Reference class object for managing command line arguments.
</p>


<h3>Details</h3>

<p>This class manages the command line argument inputs when passed via
the Rscript utility.  Take the simple script below which adds two
numbers, which we will save in an executable file called <code>add.R</code>,
</p>
<div class="sourceCode sh"><pre>#!/usr/bin/env Rscript

library(scribe)
ca &lt;- command_args()
ca$add_argument("--value1", default = 0L)
ca$add_argument("--value2", default = 0L)
args &lt;- ca$parse()
writeLines(args$value1 + args$value2)
</pre></div>
<p>When called by a terminal, we can pass arguments and return a function.
</p>
<div class="sourceCode sh"><pre>add.R --value1 10 --value2 1
11
</pre></div>
<p>When testing, you can simulate command line arguments by passing them into
the <code>input</code> field. By default, this will grab values from
<code>base::commandArgs()</code>, so use with the Rscript utility doesn't require
any extra steps.
</p>
<p>Most methods are designed to return <code>.self</code>, or the scribeCommandArgs
class. The exceptions to these are the the <code style="white-space: pre;">⁠$get_*()⁠</code> methods, which return
their corresponding values, and <code style="white-space: pre;">⁠$parse()⁠</code> which returns a named <code>list</code> of
the parsed input values.
</p>


<h3>Fields</h3>


<dl>
<dt><code>input</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> A character vector of command line arguments.
See also <code>command_args()</code></p>
</dd>
<dt><code>values</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[list]⁠</code><br> A named <code>list</code> of values.  Empty on initialization
and populated during argument resolving.</p>
</dd>
<dt><code>args</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[list]⁠</code><br> a List of scribeArgs</p>
</dd>
<dt><code>description</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> Additional help information</p>
</dd>
<dt><code>included</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> Default scribeArgs to include</p>
</dd>
<dt><code>examples</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> Examples to print with help</p>
</dd>
<dt><code>comments</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> Comments printed with</p>
</dd>
<dt><code>resolved</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[logical]⁠</code><br> A <code>logical</code> value indicated if the
<code style="white-space: pre;">⁠$resolve()⁠</code> method has been successfully executed.</p>
</dd>
<dt><code>working</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> A copy of <code>input</code>.  Note: this is used to
track parsing progress and is not meant to be accessed directly.</p>
</dd>
<dt><code>stop</code></dt>
<dd>
<p><code style="white-space: pre;">⁠[character]⁠</code><br> Determines parsing</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt><code>add_argument(
  ...,
  action = arg_actions(),
  options = NULL,
  convert = scribe_convert(),
  default = NULL,
  n = NA_integer_,
  info = NULL,
  execute = invisible
)</code></dt>
<dd>
<p>Add a scribeArg to <code>args</code>
</p>

<dl>
<dt><code>...</code></dt>
<dd>
<p>Either aliases or a scribeArg.  If the latter,
all other arguments are ignored.  Note that only the first value
(..1) is used.</p>
</dd>
<dt>
<code>action</code>, <code>options</code>, <code>convet</code>, <code>default</code>,
<code>n</code>, <code>info</code>
</dt>
<dd>
<p>See <code>new_arg()</code></p>
</dd>
</dl>
</dd>
<dt><code>add_description(..., sep = "")</code></dt>
<dd>
<p>Add a value to <code>description</code>
</p>

<dl>
<dt><code>...</code></dt>
<dd>
<p>Information to paste into the description</p>
</dd>
<dt><code>sep</code></dt>
<dd>
<p><code>character</code> separate for <code>...</code></p>
</dd>
</dl>
</dd>
<dt><code>add_example(x, comment = "", prefix = "$ ")</code></dt>
<dd>
<p>Add a value to <code>examples</code>
</p>

<dl>
<dt><code>x</code></dt>
<dd>
<p>A code example as a <code>character</code></p>
</dd>
<dt><code>comment</code></dt>
<dd>
<p>An optional comment to append</p>
</dd>
<dt><code>prefix</code></dt>
<dd>
<p>An optional prefix for the example</p>
</dd>
</dl>
</dd>
<dt><code>get_args(included = TRUE)</code></dt>
<dd>
<p>Retrieve <code>args</code>
</p>

<dl>
<dt><code>included</code></dt>
<dd>
<p>If <code>TRUE</code> also returns included default
scribeArgs defined in <code>$initialize()</code></p>
</dd>
</dl>
</dd>
<dt><code>get_description()</code></dt>
<dd>
<p>Retrieve <code>description</code></p>
</dd>
<dt><code>get_examples()</code></dt>
<dd>
<p>Retrieve <code>examples</code></p>
</dd>
<dt><code>get_input()</code></dt>
<dd>
<p>Retrieve <code>input</code></p>
</dd>
<dt><code>get_values()</code></dt>
<dd>
<p>Retrieve <code>values</code></p>
</dd>
<dt><code>help()</code></dt>
<dd>
<p>Print the help information</p>
</dd>
<dt><code>initialize(input = "", include = c("help", "version", NA_character_))</code></dt>
<dd>
<p>Initialize the scribeCommandArgs object.  The wrapper
<code>command_args()</code> is recommended rather than
calling this method directly.
</p>

<dl>
<dt><code>input</code></dt>
<dd>
<p>A <code>character</code> vector of command line arguments
to parse</p>
</dd>
<dt><code>include</code></dt>
<dd>
<p>A character vector denoting which default
scribeArgs to include in <code>args</code></p>
</dd>
</dl>
</dd>
<dt><code>parse()</code></dt>
<dd>
<p>Return a named <code>list</code> of parsed values of from each scribeArg
in <code>args</code></p>
</dd>
<dt><code>resolve()</code></dt>
<dd>
<p>Resolve the values of each scribeArg in <code>args</code>.  This method
is called prior to $parse()</p>
</dd>
<dt><code>set_description(..., sep = "")</code></dt>
<dd>
<p>Set the value of <code>description</code>
</p>

<dl>
<dt><code>...</code></dt>
<dd>
<p>Information to paste into the description</p>
</dd>
<dt><code>sep</code></dt>
<dd>
<p><code>character</code> separate for <code>...</code></p>
</dd>
</dl>
</dd>
<dt><code>set_example(x = character(), comment = "", prefix = "$ ")</code></dt>
<dd>
<p>Set the value of <code>examples</code>
</p>

<dl>
<dt><code>x</code></dt>
<dd>
<p>A code example as a <code>character</code></p>
</dd>
<dt><code>comment</code></dt>
<dd>
<p>An optional comment to append</p>
</dd>
<dt><code>prefix</code></dt>
<dd>
<p>An optional prefix for the example</p>
</dd>
</dl>
</dd>
<dt><code>set_input(value)</code></dt>
<dd>
<p>Set <code>input</code>.  Note: when called, <code>resolved</code> is (re)set to
<code>FALSE</code> and values need to be parsed again.
</p>

<dl>
<dt><code>value</code></dt>
<dd>
<p>Value to set</p>
</dd>
</dl>
</dd>
<dt><code>set_values(i = TRUE, value)</code></dt>
<dd>
<p>Set <code>values</code>
</p>

<dl>
<dt><code>i</code></dt>
<dd>
<p>Index value of <code>working</code> to set</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>The value to set</p>
</dd>
</dl>
</dd>
<dt><code>version()</code></dt>
<dd>
<p>Print the scribe-package version</p>
</dd>
</dl>
<h3>See Also</h3>

<p>Other scribe: 
<code>command_args()</code>,
<code>new_arg()</code>,
<code>scribeArg-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># command_args() is recommended over direct use of scribeCommandArgs$new()

ca &lt;- command_args(c(1, 2, 3, "--verbose"))
ca$add_argument("--verbose", action = "flag")
ca$add_argument("...", "values", info = "values to add", default = 0.0)
args &lt;- ca$parse()

if (args$verbose) {
  message("Adding ", length(args$values), " values")
}

sum(args$values)

# $parse() returns a named list, which means scribeCommandArgs can function
# as a wrapper for calling R functions inside Rscript

ca &lt;- command_args(c("mean", "--size", 20, "--absolute"))
ca$add_argument("fun", action = "list")
ca$add_argument("--size", default = 5L)
ca$add_argument("--absolute", action = "flag")
args &lt;- ca$parse()

my_function &lt;- function(fun, size, absolute = FALSE) {
  fun &lt;- match.fun(fun)
  x &lt;- sample(size, size, replace = TRUE)
  res &lt;- fun(x)
  if (absolute) res &lt;- abs(res)
  res
}

do.call(my_function, args)
</code></pre>


</div>