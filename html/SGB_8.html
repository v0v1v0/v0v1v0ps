<div class="container">

<table style="width: 100%;"><tr>
<td>InitialParameters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Initial parameters estimates and comparison
</h2>

<h3>Description</h3>

<p><code>initpar.SGB</code> computes an initial vector of parameters. <br><code>condshape2</code> computes the <code>shape2</code> parameters by the same method as <code>initpar.SGB</code>, but from an arbitrary set of parameters (<code>shape1</code>,<code>coefi</code>)  (e.g. the result of a SGB regression fit). These approximations are compared with the <code>shape2</code> estimates. <br><code>compushape2</code> is internally called by <code>initpar.SGB</code> and <code>condshape2</code>. It computes <code>shape2</code> parameters in function of <code>shape1</code> and given regression parameters <code>coefi</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">initpar.SGB(d, u, V, weight = rep(1, dim(u)[1]), shape1 = 1, Mean2 = TRUE) 
condshape2(x,d,u,V)
compushape2(shape1, coefi, d, u, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>data matrix of explanatory variables (without constant vector) <code class="reqn">(n \times m)</code>;  <code class="reqn">n</code>: sample size, <code class="reqn">m</code>: number of auxiliary variables
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>data matrix of compositions (independent variables) <code class="reqn">(n \times D)</code>; <code class="reqn">D</code>: number of parts
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>

<p>full rank transformation of log(parts) into log-ratios, matrix <code class="reqn">D \times (D-1)</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>vector of length <code class="reqn">n</code>;  positive observation weights, default <code>rep(1,n)</code>. Should be scaled to sum to <code class="reqn">n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape1</code></td>
<td>

<p>positive number, overall shape parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mean2</code></td>
<td>

<p>logical, if TRUE (default), the computed <code>shape2</code> parameters are each replaced by their average.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefi</code></td>
<td>

<p>vector of regression coefficients of length <code class="reqn">(m+1)*(D-1)</code>, resp.  <code class="reqn">D-1</code> constants, then <code class="reqn">D-1</code> coef. of the 1st expl. variable,..., <code class="reqn">D-1</code> coef. of the <code class="reqn">m</code>-th expl. variable
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>fitted SGB regression parameters, see <code>regSGB</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main function here is <code>initpar.SGB</code>. The initial value of <code>shape1</code> must be specified by the user; by default, it takes the value 1.
In the initial regression model, each column of 
<code>log(u) % * % V</code>  
is regressed by OLS on the columns of <code>d</code>. <code>coefi</code> is the vector of regression parameters, first the <code class="reqn">D-1</code> terms associated with the first explanatory variable in <code>d</code>, and so on similarily for each explanatory variable. The initial scale compositions are computed by back-transforming the predicted values to the simplex and used to compute the vector <code class="reqn"> z=C[(u/scale)^{shape1}]</code>, where <code class="reqn">C[.]</code> is the closure operation. Wicker et al. (2008), see also Ng et al. (2011) p.74-75, describe a procedure to find initial values for the shape parameters in a Dirichlet distribution. Their method is used on the (approximate) Dirichlet vector <code class="reqn"> z</code>. <br></p>


<h3>Value</h3>

<p><code>initpar.SGB</code>:  <br>
vector of length <code class="reqn">(1+ (D-1)*(m+1) + D)</code> containing initial  values for (<code>shape1</code>,<code>coefi</code>,<code>shape2</code>). <br><code>condshape2</code>: <br>
list with two components: 1. title and 2. data-frame with 2 columns: fitted <code>shape2</code> and Wicker's  approximation.
</p>


<h3>References</h3>

<p>Wicker, N., J. Muller, R. K. R. Kalathur, and O. Poch (2008). A maximum likelihood approximation method for Dirichlet's parameter estimation. <em>Computational Statistics &amp; Data Analysis</em> <b>52</b> (3), 1315-1322.
</p>
<p>Kai Wang Ng, Guo-Liang Tian, Man-Lai Tang (2011). <em>Dirichlet and Related Distributions: Theory, Methods and Applications</em>. Wiley Series in Probability and Statistics.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Explanatory variable
da &lt;- data.frame(l.depth=log(arc[["depth"]]))  
damat &lt;- as.matrix(da)
## Compositions
ua &lt;- arc[,1:3]

## alr transforms
Va &lt;- matrix(c(1,0,-1,0,1,-1),nrow=3)   
colnames(Va) &lt;- c("alr1","alr2")
Va

## Initial values
initpar.SGB(damat,ua,Va)
initpar.SGB(damat,ua,Va,Mean2=FALSE)

## Conditional shape2 values; same as parameters computed with initpar
condshape2(initpar.SGB(damat,ua,Va,Mean2=FALSE),damat,ua,Va)

## Comparison with fitted parameters
oa &lt;- regSGB(damat, as.matrix(ua), Va)
condshape2(oa[["par"]],damat,ua,Va)

</code></pre>


</div>