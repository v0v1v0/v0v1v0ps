<div class="container">

<table style="width: 100%;"><tr>
<td>mapMM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Colorful plots of predictions in two-dimensional space. 
</h2>

<h3>Description</h3>

<p>These functions provide either a map of predicted response in analyzed locations, or a predicted surface. <code>mapMM</code> is a straightforward representation of the analysis of the data, while <code>filled.mapMM</code> uses interpolation to cope with the fact that all predictor variables may not be known in all locations on a fine spatial grid.  <code>map_ranef</code> maps a single spatial random effect. These three functions takes an <code>HLfit</code> object as input. <code>mapMM</code> calls <code>spaMMplot2D</code>, which is similar but takes a more conventional (x,y,z) input. 
</p>
<p>Using <code>filled.mapMM</code> may involve questionable choices. Plotting a filled contour generally requires prediction in non-observed locations, where predictor variables used in the original data analysis may be missing. In that case, the original model formula cannot be used and an alternative model (controlled by the <code>map.formula</code> argument) must be used to interpolate (not smooth) the predicted values in observed locations (these predictions still resulting from the original analysis based on predictor variables). <code>filled.mapMM</code> always performs such interpolation (it does not allow one to provide values for the predictor variables). As a result (1) <code>filled.mapMM</code> will be slower than a mere plotting function, since it involves the analysis of spatial data; (2) the results may have little useful meaning if the effect of the original predictor variables is not correctly represented by this interpolation step. For example, prediction by interpolation may be biased in a way analogous to prediction of temperature in non-observed locations while ignoring effect of variation in altitude in such locations. Likewise, the <code>variance</code> argument of <code>filled.mapMM</code> allows one only to plot the prediction variance of its own interpolator, rather than that of the input object. 
</p>
<p><code>map_ranef</code> is free of the limitations of <code>filled.mapMM</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">spaMMplot2D(x, y, z, xrange=range(x, finite = TRUE),
  yrange=range(y, finite = TRUE), margin=1/20, add.map= FALSE, 
  nlevels = 20, color.palette = spaMM.colors, map.asp=NULL,
  col = color.palette(length(levels) - 1), plot.title=NULL, plot.axes=NULL, 
  decorations=NULL, key.title=NULL, key.axes=NULL, xaxs = "i", 
  yaxs = "i", las = 1, axes = TRUE, frame.plot = axes, ...) 

mapMM(fitobject,Ztransf=NULL,coordinates,
  add.points,decorations=NULL,plot.title=NULL,plot.axes=NULL,envir=-3, ...)

filled.mapMM(
  fitobject, Ztransf = NULL, coordinates, xrange = NULL, yrange = NULL, 
  margin = 1/20, map.formula, phi = 1e-05, gridSteps = 41, 
  decorations = quote(points(pred[, coordinates], cex = 1, lwd = 2)),
  add.map = FALSE, axes = TRUE, plot.title = NULL, plot.axes = NULL, 
  map.asp = NULL, variance = NULL, var.contour.args = list(), 
  smoothObject = NULL, return.="smoothObject", ...)

map_ranef(fitobject, re.form, Ztransf=NULL, xrange = NULL, yrange = NULL, 
  margin = 1/20, gridSteps = 41, 
  decorations = quote(points(fitobject$data[, coordinates], cex = 1, lwd = 2)), 
  add.map = FALSE, axes = TRUE, plot.title=NULL, plot.axes=NULL, 
  map.asp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitobject</code></td>
<td>

<p>The return object of a corrHLfit or fitme call.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y,z</code></td>
<td>

<p>Three vectors of coordinates, with <code>z</code> being expectedly the response.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re.form</code></td>
<td>

<p>A model formula giving the single random effect term to plot, needed only if there are several spatial random effects in the fitted model. In that case, it must be formatted as <code> . ~ &lt;term&gt;</code>, as for the <code>re.form</code> argument of <code>predict.HLfit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ztransf</code></td>
<td>

<p>A transformation of the predicted response, given as a function whose only required argument can be a one-column matrix. The name of this argument must be 
<code>Z</code> (not <code>x</code>), as is appropriate for use in <code>do.call(Ztransf,list(Z=Zvalues))</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordinates</code></td>
<td>

<p>The geographical coordinates. By default they are deduced from the model formula. For example if this formula is <code>resp ~ 1 + Matern(1| x + y )</code> the default coordinates are c("x","y"). If this formula is <code>resp ~ 1 + Matern(1| x + y + z )</code>, the user must choose two of the three coordinates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xrange</code></td>
<td>

<p>The x range of the plot (a vector of length 2); by default defined to cover all analyzed points.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yrange</code></td>
<td>

<p>The y range of the plot (a vector of length 2); by default defined to cover all analyzed points.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>

<p>This controls how far (in relative terms) the plot extends beyond the x and y ranges of the analyzed points, and is overriden by explicit <code>xrange</code> and <code>yrange</code> arguments.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map.formula</code></td>
<td>
<p>NULL, or a formula whose left-hand side is ignored. Provides the formula used for interpolation. If NULL, a default formula with the same spatial effect(s) as in the input <code>fitobject</code> is used.     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
  
<p>This controls the phi value assumed in the interpolation step. Ideally <code>phi</code> would be zero, but problems with numerically singular matrices may arise when <code>phi</code> is too small.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridSteps</code></td>
<td>
<p>The number of levels of the grid of x and y values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>Either NULL, or the name of a component of variance of prediction <em>by the interpolator</em> to be plotted. Must name one of the components that can be returned by <code>predict.HLfit</code>. <code>variance="predVar"</code> is suitable for uncertainty in point prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.contour.args</code></td>
<td>
<p>A list of control parameters for rendering of prediction variances. See <code>contour</code> for possible arguments (except <code>x</code>, <code>y</code>, <code>z</code> and <code>add</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.map</code></td>
<td>

<p>Either a boolean or an explicit expression, enclosed in <code>quote</code> (see Examples).
If <code>TRUE</code>, the <code>map</code> function from the <code>maps</code> package (which much therefore the loaded) is used to add a map from its default <code>world</code> database. <code>xrange</code> and <code>yrange</code> are used to select the area, so it is most convenient if the <code>coordinates</code> are longitude and latitude (in this order and in standard units). An explicit expression can also be used for further control.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
  
<p>a set of levels which are used to partition the range of z. Must be strictly increasing (and finite). Areas with z values between consecutive levels are painted with the same color.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevels</code></td>
<td>
	
<p>if <code>levels</code> is not specified, the range of z, values is divided into *approximately* this many levels (a call to <code>pretty</code> determines the actual number of levels).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color.palette</code></td>
<td>
	
<p>a color palette function to be used to assign colors in the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map.asp</code></td>
<td>
  
<p>the y/x aspect ratio of the 2D plot area (not of the full figure including the scale). By default, the scales for x and y are identical unless the x and y ranges are too different. Namely, the scales are identical if (plotted y range)/(plotted x range) is 1/4 &lt; . &lt; 4, and map.asp is 1 otherwise. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
	
<p>an explicit set of colors to be used in the plot. This argument overrides any palette function specification. There should be one less color than levels
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.title</code></td>
<td>
	
<p>statements which add titles to the main plot. See Details for differences between functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.axes</code></td>
<td>
	
<p>statements which draw axes (and a box) on the main plot. See Details for differences between functions. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decorations</code></td>
<td>
<p> Either NULL or Additional graphic statements (<code>points</code>, <code>polygon</code>, etc.), enclosed in <code>quote</code> (the default value illustrates the latter syntax).
.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.points</code></td>
<td>
<p>Obsolete, use <code>decorations</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Controls the environment in which <code>plot.title</code>, <code>plot.axes</code>, and 
<code>decorations</code> are evaluated. <code>mapMM</code> calls <code>spaMM2Dplot</code> from where these graphic arguments are evaluated, and the default value -3 means that they are evaluated within the environment from where <code>mapMM</code> was called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.title</code></td>
<td>
	
<p>statements which add titles for the plot key.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.axes</code></td>
<td>
	
<p>statements which draw axes on the plot key. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xaxs</code></td>
<td>
<p>the x axis style. The default is to use internal labeling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yaxs</code></td>
<td>
<p>the y axis style. The default is to use internal labeling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>las</code></td>
<td>
<p>the style of labeling to be used. The default is to use horizontal labeling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes, frame.plot</code></td>
<td>
<p>logicals indicating if axes and a box should be drawn, as in plot.default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothObject</code></td>
<td>
<p>Either NULL, or an object inheriting from class <code>HLfit</code> (hence, an object on which <code>predict.HLfit</code> can be called), predicting the response surface in any coordinates. See Details for typical usages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.</code></td>
<td>
<p>character string: see Value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments passed to or from other methods. For <code>mapMM</code>, all such arguments are passed to <code>spaMMplot2D</code>; for <code>spaMMplot2D</code>, currently only additional graphical parameters passed to <code>title()</code> (see Details).  For <code>filled.mapMM</code> and <code>map_ranef</code>, these parameters are those that can be passed to <code>spaMM.filled.contour</code>. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>smoothObject</code> argument may be used to redraw a figure faster by recycling the predictor of the response surface returned invisibly by a previous call to <code>filled.mapMM</code>.   
</p>
<p>For <code>smoothObject=NULL</code> (the default), <code>filled.mapMM</code> interpolates the predicted response, with sometimes unpleasant effects. For example, if one interpolates probabilities, the result may not be within [0,1], and then (say) a logarithmic <code>Ztransf</code> may generate NaN values that would otherwise not occur. The <code>smoothObject</code> argument may be used to overcome the default behaviour, by providing an alternative predictor. 
</p>
<p>If you have values for all predictor variables in all locations of a fine spatial grid, <code>filled.mapMM</code> may not be a good choice, since it will ignore that information (see <code>map.formula</code> argument). Rather, one should use <code>predict(&lt;fitobject&gt;,newdata= &lt;all predictor variables &gt;)</code> to generate all predictions, and then either 
<code>spaMM.filled.contour</code> or some other raster functions.
</p>

<p>The different functions are (currently) inconsistent among themselves in the way they handle the <code>plot.title</code> and <code>plot.axes</code> argument:
</p>
<p><b>spaMM.filled.contour</b> behaves like <code>graphics::filled.contour</code>, which (1) handles arguments which are calls such as <code>title(.)</code> or <code>{axis(1);axis(2)}</code>; (2) ignores <code>...</code> arguments if <code>plot.title</code> is missing; and (3) draws axes by default when <code>plot.axes</code> is missing, given <code>axes = TRUE</code>.
</p>
<p>By contrast, <b>filled.mapMM</b> handles arguments which are language expressions such as produced by <code>quote(.)</code> or <code>substitute(.)</code> (see Examples). 
</p>
<p><b>mapMM</b> can handles language expressions, but also accepts at least some calls.
</p>


<h3>Value</h3>

<p><code>filled.mapMM</code> by default returns invisibly the fit object predicting the interpolated response surface; however, for any non-default <code>return.</code> argument (<code>return.="raster"</code> would be recommended to ensure future back-compatibility), it will return a raster of values as a list with elements <code>x</code>, <code>y</code> and <code>z</code>. <code>map_ranef</code> returns invisibly a 3-column matrix containing the spatial coordinates, and the predicted effect <code>z</code> on the linear predictor scale (which is also the scale of the plot, unless a <code>Ztransf</code> is used). <code>mapMM</code> returns invisibly a list with elements <code>x</code>, <code>y</code> and <code>z</code>. Plots are produced as side-effects. 
</p>


<h3>See Also</h3>

<p><code>seaMask</code> for masking areas in a filled map;
<a href="https://gitlab.mbb.univ-montp2.fr/francois/spamm-ref/-/blob/master/vignettePlus/example_raster.html">https://gitlab.mbb.univ-montp2.fr/francois/spamm-ref/-/blob/master/vignettePlus/example_raster.html</a> for more elaborate plot procedures.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("blackcap")
bfit &lt;- fitme(migStatus ~ means+ Matern(1|longitude+latitude),data=blackcap,
              fixed=list(lambda=0.5537,phi=1.376e-05,rho=0.0544740,nu=0.6286311))
mapMM(bfit,color.palette = function(n){spaMM.colors(n,redshift=1/2)},add.map=TRUE)
map_ranef(bfit) # providing argument re.form= . ~ Matern(1|longitude+latitude)

if (spaMM.getOption("example_maxtime")&gt;1) {
  ## filled.mapMM takes a bit longer
  # showing 'add.map', 'nlevels', and contour lines for 'variance'
  filled.mapMM(bfit, nlevels=30, add.map=TRUE, plot.axes=quote({axis(1);axis(2)}),
             variance="respVar",
             plot.title=title(main="Inferred migration propensity of blackcaps",
                               xlab="longitude",ylab="latitude"))
                               
  ## Similar plots by ggplot2:
  ## Not run: 
   library(rnaturalearth) # provides sea mask through 'ne_download' function
   library(ggplot2)
   library(sp)
  
   # sea mask 
   sea &lt;- ne_download(scale = 10, type = 'ocean', category = "physical", returnclass = "sf")
   
   # Generation of data.frame for ggplot:
   rastr &lt;- filled.mapMM(bfit, return.="raster")
   spdf &lt;- data.frame(Long=rep(rastr$x, nc), Lat=rastr$y[gl(nr,nc)], z = as.vector(rastr$z))

   ggplot(spdf) + 
     geom_contour_filled(aes(Long,Lat,z=z), bins = 20) +
     guides(fill = "none") +
     geom_sf(data = sea, fill = "black") +
     coord_sf(ylim = range(rastr$y), xlim = range(rastr$x), expand = FALSE)
  
## End(Not run)
                               
}

if (spaMM.getOption("example_maxtime")&gt;3) {
 data("Loaloa")  
 lfit &lt;- fitme(cbind(npos,ntot-npos)~elev1+elev2+elev3+elev4+maxNDVI1+seNDVI
                  +Matern(1|longitude+latitude), method="PQL", data=Loaloa,
                  family=binomial(), fixed=list(nu=0.5,rho=2.255197,lambda=1.075))   

 ## longer computation requiring interpolation of 197 points 
 ## Also illustrating effect of 'return.' argument
 res &lt;- filled.mapMM(lfit,add.map=TRUE,plot.axes=quote({axis(1);axis(2)}),
    decorations=quote(points(pred[,coordinates],pch=15,cex=0.3)),
    return.="raster", # so that 'res' is a list representing a raster. 
    plot.title=title(main="Inferred prevalence, North Cameroon",
                     xlab="longitude",ylab="latitude"))
}

</code></pre>


</div>