<div class="container">

<table style="width: 100%;"><tr>
<td>pois.ewma.ad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute steady-state ARLs of Poisson EWMA control charts</h2>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL) at given mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">pois.ewma.ad(lambda, AL, AU, mu0, mu, sided="two", rando=FALSE, gL=0, gU=0,
mcdesign="classic", N=101)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AL, AU</code></td>
<td>
<p>factors to build the lower and upper control limit, respectively, of the Poisson EWMA control chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu0</code></td>
<td>
<p>in-control mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>actual mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing
<code>"upper"</code>, <code>"lower"</code>, and <code>"two"</code>, and <code>"zwei"</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rando</code></td>
<td>
<p>Switch between the standard limit treatment, <code>FALSE</code>,
and an additional randomisation (to allow ‘perfect’ ARL calibration) by setting <code>TRUE</code>.
If randomisation is used, then set the corresponding probailities, <code>gL</code> and <code>gU</code>, appropriately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gL, gU</code></td>
<td>
<p>If the EWMA statistic is at the limit (approximately), then an alarm is triggered with probability
<code>gL</code> and <code>gU</code> for the lower and upper limit, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcdesign</code></td>
<td>
<p>choose either <code>"classic"</code> which follows Borror, Champ and Rigdon (1998), or the more
sophisticated <code>"transfer"</code> which improves the accuracy heavily.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of states of the approximating Markov chain; is equal to the dimension of the
resulting linear equation system.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code>.
The ARL values of the resulting EWMA control chart are determined by Markov chain approximation.
We follow the algorithm given in Borror, Champ and Rigdon (1998). The function is in an early development phase.
</p>


<h3>Value</h3>

<p>Return single value which resembles the steady-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. M. Borror, C. W. Champ and S. E. Rigdon (1998)
Poisson EWMA control charts,
<em>Journal of Quality Technonlogy</em> 30(4), 352-361.
</p>
<p>M. C. Morais and S. Knoth (2020)
Improving the ARL profile and the accuracy of its calculation for Poisson EWMA charts,
<em>Quality and Reliability Engineering International</em> 36(3), 876-889.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Borror, Champ and Rigdon (1998), Table 2, PEWMA column
mu0 &lt;- 20
lambda &lt;- 0.27
A &lt;- 3.319
mu1  &lt;- c(2*(3:15), 35)
ARL1 &lt;- AD1 &lt;- rep(NA, length(mu1))
for ( i in 1:length(mu1) ) {
  ARL1[i] &lt;- round(pois.ewma.arl(lambda,A,A,mu0,mu0,mu1[i],mcdesign="classic"),digits=1)
  AD1[i]  &lt;- round(pois.ewma.ad(lambda,A,A,mu0,mu1[i],mcdesign="classic"),digits=1)
}
print( cbind(mu1, ARL1, AD1) )

## Morais and Knoth (2020), Table 2, lambda = 0.27 column
## randomisation not implemented for pois.ewma.ad()
lambda &lt;- 0.27
AL &lt;- 3.0870
AU &lt;- 3.4870
gL &lt;- 0.001029
gU &lt;- 0.000765
mu2  &lt;- c(16, 18, 19.99, mu0, 20.01, 22, 24)
ARL2 &lt;- AD2 &lt;- rep(NA, length(mu2))
for ( i in 1:length(mu2) ) {
  ARL2[i] &lt;- round(pois.ewma.arl(lambda,AL,AU,mu0,mu0,mu2[i],rando=FALSE), digits=1)
  AD2[i] &lt;- round(pois.ewma.ad(lambda,AL,AU,mu0,mu2[i],rando=FALSE), digits=1)
}
print( cbind(mu2, ARL2, AD2) )
</code></pre>


</div>