<div class="container">

<table style="width: 100%;"><tr>
<td>sento_lexicons</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set up lexicons (and valence word list) for use in sentiment analysis</h2>

<h3>Description</h3>

<p>Structures provided lexicon(s) and optionally valence words. One can for example combine (part of) the
built-in lexicons from <code>data("list_lexicons")</code> with other lexicons, and add one of the built-in valence word lists
from <code>data("list_valence_shifters")</code>. This function makes the output coherent, by converting all words to
lowercase and checking for duplicates. All entries consisting of more than one word are discarded, as required for
bag-of-words sentiment analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sento_lexicons(lexiconsIn, valenceIn = NULL, do.split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lexiconsIn</code></td>
<td>
<p>a named <code>list</code> of (raw) lexicons, each element as a <code>data.table</code> or a <code>data.frame</code> with
respectively a <code>character</code> column (the words) and a <code>numeric</code> column (the polarity scores). This argument can be
one of the built-in lexicons accessible via <code>sentometrics::list_lexicons</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valenceIn</code></td>
<td>
<p>a single valence word list as a <code>data.table</code> or a <code>data.frame</code> with respectively a <code>"x"</code>
and a <code>"y"</code> or <code>"t"</code> column. The first column has the words, <code>"y"</code> has the values for bigram
shifting, and <code>"t"</code> has the types of the valence shifter for a clustered approach to sentiment calculation
(supported types: <code>1</code> = negators, <code>2</code> = amplifiers, <code>3</code> = deamplifiers, <code>4</code> = adversative conjunctions).
Type <code>4</code> is only used in a clusters-based sentence-level sentiment calculation.
If three columns are provided, only the first two will be considered. This argument can be one of the
built-in valence word lists accessible via <code>sentometrics::list_valence_shifters</code>. A word that appears in both a
lexicon and the valence word list is prioritized as a lexical entry during sentiment calculation. If
<code>NULL</code>, valence shifting is not applied in the sentiment analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.split</code></td>
<td>
<p>a <code>logical</code> that if <code>TRUE</code> splits every lexicon into a separate positive polarity and negative
polarity lexicon.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>list</code> of class <code>sento_lexicons</code> with each lexicon as a separate element according to its name, as a
<code>data.table</code>, and optionally an element named <code>valence</code> that comprises the valence words. Every <code>"x"</code> column
contains the words, every <code>"y"</code> column contains the scores. The <code>"t"</code> column for valence shifters
contains the different types.
</p>


<h3>Author(s)</h3>

<p>Samuel Borms
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("list_lexicons", package = "sentometrics")
data("list_valence_shifters", package = "sentometrics")

# lexicons straight from built-in word lists
l1 &lt;- sento_lexicons(list_lexicons[c("LM_en", "HENRY_en")])

# including a self-made lexicon, with and without valence shifters
lexIn &lt;- c(list(myLexicon = data.table::data.table(w = c("nice", "boring"), s = c(2, -1))),
           list_lexicons[c("GI_en")])
valIn &lt;- list_valence_shifters[["en"]]
l2 &lt;- sento_lexicons(lexIn)
l3 &lt;- sento_lexicons(lexIn, valIn)
l4 &lt;- sento_lexicons(lexIn, valIn[, c("x", "y")], do.split = TRUE)
l5 &lt;- sento_lexicons(lexIn, valIn[, c("x", "t")], do.split = TRUE)
l6 &lt;- l5[c("GI_en_POS", "valence")] # preserves sento_lexicons class

## Not run: 
# include lexicons from lexicon package
lexIn2 &lt;- list(hul = lexicon::hash_sentiment_huliu, joc = lexicon::hash_sentiment_jockers)
l7 &lt;- sento_lexicons(c(lexIn, lexIn2), valIn)
## End(Not run)

## Not run: 
# faulty extraction, no replacement allowed
l5["valence"]
l2[0]
l3[22]
l4[1] &lt;- l2[1]
l4[[1]] &lt;- l2[[1]]
l4$GI_en_NEG &lt;- l2$myLexicon
## End(Not run)

</code></pre>


</div>