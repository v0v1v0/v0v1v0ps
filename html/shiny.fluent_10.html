<div class="container">

<table style="width: 100%;"><tr>
<td>Callout</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Callout</h2>

<h3>Description</h3>

<p>A callout is an anchored tip that can be used to teach people or guide them through the app without blocking them.
</p>
<p>For more details and examples visit the <a href="https://developer.microsoft.com/en-us/fluentui#/controls/web/Callout">official docs</a>.
The R package cannot handle each and every case, so for advanced use cases
you need to work using the original docs to achieve the desired result.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Callout(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Props to pass to the component.
The allowed props are listed below in the <b>Details</b> section.</p>
</td>
</tr></table>
<h3>Details</h3>


<ul>
<li> <p><b> alignTargetEdge </b> <code>boolean</code> <br> If true the positioning logic will prefer to flip edges rather than to nudge the rectangle to fit within bounds, thus making sure the element aligns perfectly with target's alignment edge
</p>
</li>
<li> <p><b> ariaDescribedBy </b> <code>string</code> <br> Defines the element id referencing the element containing the description for the callout.
</p>
</li>
<li> <p><b> ariaLabel </b> <code>string</code> <br> Accessible label text for callout.
</p>
</li>
<li> <p><b> ariaLabelledBy </b> <code>string</code> <br> Defines the element id referencing the element containing label text for callout.
</p>
</li>
<li> <p><b> backgroundColor </b> <code>string</code> <br> The background color of the Callout in hex format ie. #ffffff.
</p>
</li>
<li> <p><b> beakWidth </b> <code>number</code> <br> The width of the beak.
</p>
</li>
<li> <p><b> bounds </b> <code style="white-space: pre;">⁠IRectangle | ((target?: Target, targetWindow?: Window) =&gt; IRectangle | undefined)⁠</code> <br> The bounding rectangle (or callback that returns a rectangle) for which the contextual menu can appear in.
</p>
</li>
<li> <p><b> calloutMaxHeight </b> <code>number</code> <br> Set max height of callout When not set the callout will expand with contents up to the bottom of the screen
</p>
</li>
<li> <p><b> calloutMaxWidth </b> <code>number</code> <br> Custom width for callout including borders. If value is 0, no width is applied.
</p>
</li>
<li> <p><b> calloutWidth </b> <code>number</code> <br> Custom width for callout including borders. If value is 0, no width is applied.
</p>
</li>
<li> <p><b> className </b> <code>string</code> <br> CSS class to apply to the callout.
</p>
</li>
<li> <p><b> coverTarget </b> <code>boolean</code> <br> If true the position returned will have the menu element cover the target. If false then it will position next to the target;
</p>
</li>
<li> <p><b> directionalHint </b> <code>DirectionalHint</code> <br> How the element should be positioned
</p>
</li>
<li> <p><b> directionalHintFixed </b> <code>boolean</code> <br> If true the position will not change sides in an attempt to fit the callout within bounds. It will still attempt to align it to whatever bounds are given.
</p>
</li>
<li> <p><b> directionalHintForRTL </b> <code>DirectionalHint</code> <br> How the element should be positioned in RTL layouts. If not specified, a mirror of the <code>directionalHint</code> alignment edge will be used instead. This means that <code>DirectionalHint.BottomLeft</code> will change to <code>DirectionalHint.BottomRight</code> but <code>DirectionalHint.LeftAuto</code> will not change.
</p>
</li>
<li> <p><b> doNotLayer </b> <code>boolean</code> <br> If true do not render on a new layer. If false render on a new layer.
</p>
</li>
<li> <p><b> finalHeight </b> <code>number</code> <br> Specify the final height of the content. To be used when expanding the content dynamically so that callout can adjust its position.
</p>
</li>
<li> <p><b> gapSpace </b> <code>number</code> <br> The gap between the Callout and the target
</p>
</li>
<li> <p><b> hidden </b> <code>boolean</code> <br> If specified, renders the Callout in a hidden state. Use this flag, rather than rendering a callout conditionally based on visibility, to improve rendering performance when it becomes visible. Note: When callout is hidden its content will not be rendered. It will only render once the callout is visible.
</p>
</li>
<li> <p><b> hideOverflow </b> <code>boolean</code> <br> Manually set OverflowYHidden style prop to true on calloutMain element A variety of callout load animations will need this to hide the scollbar that can appear
</p>
</li>
<li> <p><b> isBeakVisible </b> <code>boolean</code> <br> If true then the beak is visible. If false it will not be shown.
</p>
</li>
<li> <p><b> layerProps </b> <code>ILayerProps</code> <br> Optional props to pass to the Layer component hosting the panel.
</p>
</li>
<li> <p><b> minPagePadding </b> <code>number</code> <br> The minimum distance the callout will be away from the edge of the screen.
</p>
</li>
<li> <p><b> onDismiss </b> <code style="white-space: pre;">⁠(ev?: any) =&gt; void⁠</code> <br> Callback when the Callout tries to close.
</p>
</li>
<li> <p><b> onLayerMounted </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Optional callback when the layer content has mounted.
</p>
</li>
<li> <p><b> onPositioned </b> <code style="white-space: pre;">⁠(positions?: ICalloutPositionedInfo) =&gt; void⁠</code> <br> Optional callback that is called once the callout has been correctly positioned.
</p>
</li>
<li> <p><b> onRestoreFocus </b> <code style="white-space: pre;">⁠(options: { originalElement?: HTMLElement | Window; containsFocus: boolean; }) =&gt; void⁠</code> <br> Called when the component is unmounting, and focus needs to be restored. Argument passed down contains two variables, the element that the underlying popup believes focus should go to * and whether or not the popup currently contains focus. If this is provided, focus will not be restored automatically, you'll need to call originalElement.focus()
</p>
</li>
<li> <p><b> onScroll </b> <code style="white-space: pre;">⁠() =&gt; void⁠</code> <br> Callback when the Callout body is scrolled.
</p>
</li>
<li> <p><b> preventDismissOnLostFocus </b> <code>boolean</code> <br> If true then the callout will not dismiss when it loses focus
</p>
</li>
<li> <p><b> preventDismissOnResize </b> <code>boolean</code> <br> If true then the callout will not dismiss on resize
</p>
</li>
<li> <p><b> preventDismissOnScroll </b> <code>boolean</code> <br> If true then the callout will not dismiss on scroll
</p>
</li>
<li> <p><b> role </b> <code>string</code> <br> Aria role assigned to the callout (Eg. dialog, alertdialog).
</p>
</li>
<li> <p><b> setInitialFocus </b> <code>boolean</code> <br> If true then the callout will attempt to focus the first focusable element that it contains. If it doesn't find an element, no focus will be set and the method will return false. This means that it's the contents responsibility to either set focus or have focusable items.
</p>
</li>
<li> <p><b> shouldRestoreFocus </b> <code>boolean</code> <br> If true, when this component is unmounted, focus will be restored to the element that had focus when the component first mounted.
</p>
</li>
<li> <p><b> shouldUpdateWhenHidden </b> <code>boolean</code> <br> If true, the component will be updated even when hidden=true. Note that this would consume resources to update even though nothing is being shown to the user. This might be helpful though if your updates are small and you want the callout to be revealed fast to the user when hidden is set to false.
</p>
</li>
<li> <p><b> style </b> <code>React.CSSProperties</code> <br> CSS style to apply to the callout.
</p>
</li>
</ul>
<p>If you set <code>overflowY</code> in this object, it provides a performance optimization by preventing Popup (underlying component of Callout) from calculating whether it needs a scroll bar.
</p>

<ul>
<li> <p><b> styles </b> <code style="white-space: pre;">⁠IStyleFunctionOrObject&lt;ICalloutContentStyleProps, ICalloutContentStyles&gt;⁠</code> <br> Optional styles for the component.
</p>
</li>
<li> <p><b> target </b> <code>Target</code> <br> The target that the Callout should try to position itself based on. It can be either an Element a querySelector string of a valid Element or a MouseEvent. If MouseEvent is given then the origin point of the event will be used.
</p>
</li>
<li> <p><b> theme </b> <code>ITheme</code> <br> Optional theme for component
</p>
</li>
</ul>
<h3>Value</h3>

<p>Object with <code>shiny.tag</code> class suitable for use in the UI of a Shiny app.
</p>


<h3>Best practices</h3>



<h4>Layout</h4>


<ul>
<li>
<p> Don’t use a callout to ask for action confirmation; use a dialog instead.
</p>
</li>
<li>
<p> Place a callout near the object being described. At the pointer’s tail or head, if possible.
</p>
</li>
<li>
<p> Don't use large, unformatted blocks of text in your callout. They're difficult to read and overwhelming.
</p>
</li>
<li>
<p> Don’t block important UI with the placement of your callout. It's a poor user experience that will lead to frustration.
</p>
</li>
<li>
<p> Don’t open a callout from within another callout.
</p>
</li>
<li>
<p> Don’t show callouts on hidden elements.
</p>
</li>
<li>
<p> Don’t overuse callouts. Too many callouts opening automatically can be perceived as interrupting someone's workflow.
</p>
</li>
<li>
<p> For a particularly complex concept that needs explanation, place an info icon (<code>iconClassNames.info</code>) next to the concept to indicate there's more helpful information available. When someone hovers over or selects the icon, the callout should appear.
</p>
</li>
</ul>
<h4>Content</h4>


<ul>
<li>
<p> Because the content inside of a callout isn't always visible, don't put required information in a callout.
</p>
</li>
<li>
<p> Short sentences or sentence fragments are best.
</p>
</li>
<li>
<p> Don't use obvious tip text or text that simply repeats what is already on the screen. Limit the information inside of a callout to supplemental information.
</p>
</li>
<li>
<p> When additional context or a more advanced description is necessary, consider placing a link to "Learn more" at the bottom of the callout. When clicked, open the additional content in a new window or panel.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(shiny)
library(shiny.fluent)

ui &lt;- function(id) {
  ns &lt;- NS(id)
  div(
    DefaultButton.shinyInput(ns("toggleCallout"), text = "Toggle Callout"),
    reactOutput(ns("callout"))
  )
}

server &lt;- function(id) {
  moduleServer(id, function(input, output, session) {
    show &lt;- reactiveVal(FALSE)
    observeEvent(input$toggleCallout, show(!show()))
    output$callout &lt;- renderReact({
      if (show()) {
        Callout(
          tags$div(
            style = "margin: 10px",
            "Callout contents"
          )
        )
      }
    })
  })
}

if (interactive()) {
  shinyApp(ui("app"), function(input, output) server("app"))
}
</code></pre>


</div>