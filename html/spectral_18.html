<div class="container">

<table style="width: 100%;"><tr>
<td>spec.fft</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>1D/2D/nD (multivariate) spectrum of the Fourier transform</h2>

<h3>Description</h3>

<p>This function calculates the Fourier spectrum and power spectral density
of a given data object. The dimension of the array can be of arbitary size
e. g. 3D or 4D.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spec.fft(y = NULL, x = NULL, z = NULL, center = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>1D data vector, y coordinate of a 2D matrix, nD (even 2D) array
or object of class <code>fft</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>x-coordinate of the data in <code>y</code> or <code>z</code>. If <code>y</code> is an array, <code>x</code> must be a named list <code>x = list(x = ..., y = ...)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>optional 2D matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>logical vector, indicating which axis to center in frequency space</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function returns an user friendly object, which contains as much frequency
vectors as ordinates of the array. <code>spec.fft</code> provides the
ability to center the spectrum along multiple axis. The amplitude output is already
normalized to the sample count and the frequencies are given in terms of
<code class="reqn">1/\Delta x</code>-units.
</p>


<h3>Value</h3>

<p>An object of the type <code>fft</code> is returned. It contains the
spectrum <code>A</code>, with "reasonable" frequency vectors along each ordinate. <code>psd</code> represents
the standardized power spectral density, [0,1]. The false alarm probability (FAP)
<code>p</code> is given similar to the Lomb-Scargle method, see spec.lomb.
</p>


<h3>Missing Values</h3>

<p>Given a regualar grid <code class="reqn">x_i = \delta x \cdot i</code> there might be missing values
marked with <code>NA</code>, which are treated by the function as 0's.
This "zero-padding" leads to a loss of signal energy being
roughly proportional to the number of missing values.
The correction factor is then <code class="reqn">(1 - Nna/N)</code> as long as <code class="reqn">Nna / N &lt; 0.2</code>.
If the locations of missing values are randomly
distributed the implemented procedure workes quite robust. If correalted
gaps are present, the proposed correction is faulty and
scales wrong. This is because a convolution of the incomplete
sampling vector with the the signal takes place. An aliasing effect
takes place distorting the spectral content.
</p>
<p>To be compatible with the underlying Fourier transform, the amplitudes
are not affected by this rescaling.
Only the power spectral density (PSD) is corrected in terms of the energy
content, which is experimental for the moment.
</p>


<h3>See Also</h3>

<p>plot.fft
</p>


<h3>Examples</h3>

<pre><code class="language-R"># 1D Example with two frequencies
#################################

x &lt;- seq(0, 1, length.out = 1e3)
y &lt;- sin(4 * 2 * pi * x) + 0.5 * sin(20 * 2 * pi * x)
FT &lt;- spec.fft(y, x)
par(mfrow = c(2, 1))
plot(x, y, type = "l", main = "Signal")
plot(
  FT,
  ylab = "Amplitude",
  xlab = "Frequency",
  type = "l",
  xlim = c(-30, 30),
  main = "Spectrum"
)
summary(FT)

# 2D example with a propagating wave
####################################

x &lt;- seq(0, 1, length.out = 50)
y &lt;- seq(0, 1, length.out = 50)

# calculate the data
m &lt;- matrix(0, length(x), length(y))
for (i in 1:length(x))
  for (j in 1:length(y))
    m[i, j] &lt;- sin(4 * 2 * pi * x[i] + 10 * 2 * pi * y[j])

# calculate the spectrum
FT &lt;- spec.fft(x = x, y = y, z = m)

# plot
par(mfrow = c(2, 1))
rasterImage2(x = x,
           y = y,
           z = m,
           main = "Propagating Wave")
plot(
  FT,
  main = "2D Spectrum",
  palette = "wb"
  ,
  xlim = c(-20, 20),
  ylim = c(-20, 20),
  zlim = c(0, 0.51)
  ,
  xlab = "fx",
  ylab = "fy",
  zlab = "A",
  ndz = 3,
  z.adj = c(0, 0.5)
  ,
  z.cex = 1
)
summary(FT)

# 3D example with a propagating wave
####################################

# sampling vector
x &lt;- list(x = seq(0,2,by = 0.1)[-1]
          ,y = seq(0,1, by = 0.1)[-1]
          ,z = seq(0,1, by = 0.1)[-1]
)

# initializing array
m &lt;- array(data = 0,dim = sapply(x, length))

for(i in 1:length(x$x))
  for(j in 1:length(x$y))
    for(k in 1:length(x$z))
      m[i,j,k] &lt;- cos(2*pi*(1*x$x[i] + 2*x$y[j] + 2*x$z[k])) + sin(2*pi*(1.5*x$x[i]))^2

FT &lt;- spec.fft(x = x, y = m, center = c(TRUE,TRUE,FALSE))

par(mfrow = c(2,2))
# plotting m = 0
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,1])
              ,zlim = c(0,0.5)
              ,main="m = 0"
              )

# plotting m = 1
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,2])
              ,zlim = c(0,0.5)
              ,main="m = 1"
)

# plotting m = 2
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,3])
              ,zlim = c(0,0.5)
              ,main="m = 2"
)
rasterImage2( x = FT$fx
              ,y = FT$fy
              ,z = abs(FT$A[,,4])
              ,zlim = c(0,0.5)
              ,main="m = 3"
)

summary(FT)


# calculating the derivative with the help of FFT
################################################
#
# Remember, a signal has to be band limited.
# !!! You must use a window function !!!
#

# preparing the data
x &lt;- seq(-2, 2, length.out = 1e4)
dx &lt;- mean(diff(x))
y &lt;- win.tukey(x) * (-x ^ 3 + 3 * x)

# calcualting spectrum
FT &lt;- spec.fft(y = y, center = TRUE)
# calculating the first derivative
FT$A &lt;- FT$A * 2 * pi * 1i * FT$fx
# back transform
dm &lt;- spec.fft(FT)

# plot
par(mfrow=c(1,1))
plot(
  x,
  c(0, diff(y) / dx),
  type = "l",
  col = "grey",
  lty = 2,
  ylim = c(-4, 3)
)
# add some points to the line for the numerical result
points(approx(x, Re(dm$y) / dx, n = 100))
# analytical result
curve(-3 * x ^ 2 + 3,
      add = TRUE,
      lty = 3,
      n = length(x))

legend(
  "topright",
  c("analytic", "numeric", "spectral"),
  title = "diff",
  lty = c(3, 2, NA),
  pch = c(NA, NA, 1),
  col=c("black","grey","black")
)
title(expression(d / dx ~ (-x ^ 3 + 3 * x)))
</code></pre>


</div>