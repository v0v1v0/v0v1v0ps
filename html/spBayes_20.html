<div class="container">

<table style="width: 100%;"><tr>
<td>spMisalignGLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for fitting multivariate generalized linear Bayesian spatial regression models to misaligned data</h2>

<h3>Description</h3>

<p>The function <code>spMisalignGLM</code> fits Gaussian multivariate Bayesian
generalized linear spatial regression models to misaligned data. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">spMisalignGLM(formula, family="binomial", weights, data = parent.frame(), coords, 
      starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression models to be fit. See example below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional list of weight vectors associated with each model
in the formula list. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>spMisalignGLM</code> is called.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>a list of <code class="reqn">q</code> <code class="reqn">n_i \times 2</code>
matrices of the observation coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) where <code class="reqn">i=(1,2,\ldots,q)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a list with tags corresponding to <code>A</code>,
<code>phi</code>, and <code>nu</code>. The value portion of each tag is a vector
that holds the parameter's starting values. <code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and holds the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix <code class="reqn">K=AA'</code>. <code>phi</code> and <code>nu</code> are
of length <code class="reqn">q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with tags <code>A</code>, <code>phi</code>, and <code>nu</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution.
<code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and <code>phi</code>
and <code>nu</code> are of length <code class="reqn">q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta.flat</code>,
<code>beta.norm</code>, <code>K.iw</code>, <code>phi.unif</code>, and
<code>nu.unif</code>. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. The spatial cross-covariance matrix <code class="reqn">K=AA'</code> is assumed to follow an
inverse-Wishart distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Wishart are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively. The hyperparameters of the Uniform are also passed as a list of vectors with the first and second list elements corresponding to the lower and upper
support, respectively. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis acceptance and MCMC progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code>glm</code> <code>offset</code> argument which is passed as the
log of this value.  
</p>


<h3>Value</h3>

<p>An object of class <code>spMisalignGLM</code>, which is a list with the following
tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.w</code></td>
<td>
<p>if <code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. Posterior samples are organized with the first response variable
<code class="reqn">n_1</code> locations held in rows <code class="reqn">1\ldots,n_1</code> rows, then the
next response variable samples held in the
<code class="reqn">(n_1+1),\ldots,(n_1+n_2)</code>, etc.</p>
</td>
</tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825–848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and B.D. Cook. (2014) Bayesian hierarchical models for spatially misaligned data. <em>Methods in Ecology and Evolution</em>, 5:514–523.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873–2884.
</p>
<p>Finley, A.O., S. Banerjee, A.R. Ek, and R.E. McRoberts. (2008) Bayesian multivariate process modeling for prediction of forest attributes. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 13:60–83.
</p>


<h3>See Also</h3>

<p><code>spMvGLM</code> <code>spMisalignLM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##generate some data
n &lt;- 100 ##number of locations
q &lt;- 3 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##parameters for generating a multivariate spatial GP covariance matrix
theta &lt;- rep(3/0.5,q) ##spatial decay

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,1,-1,1,0.5,0.25)
K &lt;- A%*%t(A)
K ##spatial cross-covariance
cov2cor(K) ##spatial cross-correlation

C &lt;- mkSpCov(coords, K, diag(0,q), theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C) ##spatial random effects

w.a &lt;- w[seq(1,length(w),q)]
w.b &lt;- w[seq(2,length(w),q)]
w.c &lt;- w[seq(3,length(w),q)]

##covariate portion of the mean
x.a &lt;- cbind(1, rnorm(n))
x.b &lt;- cbind(1, rnorm(n))
x.c &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.a, x.b, x.c))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B.3 &lt;- c(-1,-1)
B &lt;- c(B.1, B.2, B.3)

y &lt;- rpois(nrow(C), exp(x%*%B+w))

y.a &lt;- y[seq(1,length(y),q)]
y.b &lt;- y[seq(2,length(y),q)]
y.c &lt;- y[seq(3,length(y),q)]

##subsample to make spatially misaligned data
sub.1 &lt;- 1:50
y.1 &lt;- y.a[sub.1]
w.1 &lt;- w.a[sub.1]
coords.1 &lt;- coords[sub.1,]
x.1 &lt;- x.a[sub.1,]

sub.2 &lt;- 25:75
y.2 &lt;- y.b[sub.2]
w.2 &lt;- w.b[sub.2]
coords.2 &lt;- coords[sub.2,]
x.2 &lt;- x.b[sub.2,]

sub.3 &lt;- 50:100
y.3 &lt;- y.c[sub.3]
w.3 &lt;- w.c[sub.3]
coords.3 &lt;- coords[sub.3,]
x.3 &lt;- x.c[sub.3,]

##call spMisalignGLM
q &lt;- 3
A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]

n.batch &lt;- 200
batch.length &lt;- 25
n.samples &lt;- n.batch*batch.length

starting &lt;- list("beta"=rep(0,length(B)), "phi"=rep(3/0.5,q), "A"=A.starting, "w"=0)
                 
tuning &lt;- list("beta"=rep(0.1,length(B)), "phi"=rep(1,q), "A"=rep(0.1,length(A.starting)), "w"=1)

priors &lt;- list("phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)),  rep(0.1,q))

m.1 &lt;- spMisalignGLM(list(y.1~x.1-1, y.2~x.2-1, y.3~x.3-1), family="poisson",
                     coords=list(coords.1, coords.2, coords.3),
                     starting=starting, tuning=tuning, priors=priors,
                     amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                     cov.model="exponential", n.report=10)

burn.in &lt;- floor(0.75*n.samples)

plot(m.1$p.beta.theta.samples, density=FALSE)

##predict for all locations, i.e., observed and not observed
out &lt;- spPredict(m.1, start=burn.in, thin=10, pred.covars=list(x.a, x.b, x.c), 
                 pred.coords=list(coords, coords, coords))

##summary and check
quants &lt;- function(x){quantile(x, prob=c(0.5,0.025,0.975))}

y.hat &lt;- apply(out$p.y.predictive.samples, 1, quants)

##unstack and plot
y.a.hat &lt;- y.hat[,1:n]
y.b.hat &lt;- y.hat[,(n+1):(2*n)]
y.c.hat &lt;- y.hat[,(2*n+1):(3*n)]

par(mfrow=c(1,3))
plot(y.a ,y.a.hat[1,], xlab="Observed y.a", ylab="Fitted &amp; predicted y.a")
plot(y.b, y.b.hat[1,], xlab="Observed y.b", ylab="Fitted &amp; predicted y.b")
plot(y.c, y.c.hat[1,], xlab="Observed y.c", ylab="Fitted &amp; predicted y.c")

  
## End(Not run)
</code></pre>


</div>