<div class="container">

<table style="width: 100%;"><tr>
<td>predict.msel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict method for msel function</h2>

<h3>Description</h3>

<p>Predicted values based on the object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'msel'
predict(
  object,
  ...,
  newdata = NULL,
  given_ind = numeric(),
  group = NA,
  group2 = NA,
  group3 = NA,
  type = ifelse(any(is.na(group2)), "prob", "val"),
  me = NULL,
  eps = NULL,
  control = list(),
  test = FALSE,
  exogenous = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class "msel".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used.
This data frame should contain values of dependent variables even if
they are not actually needed for prediction 
(simply assign them with 0 values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>given_ind</code></td>
<td>
<p>a numeric vector of indexes of conditioned components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>a numeric vector which i-th element represents a value of the
i-th dependent variable. If this value equals -1 then this component
will be ignored (useful for estimation of marginal probabilities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group2</code></td>
<td>
<p>a numeric vector which i-th element represents a value of the
i-th dependent variable of the continuous equation. 
If this value equals -1 then this component will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group3</code></td>
<td>
<p>an integer representing the index of the alternative of the
multinomial equation. If this value equals -1 then this component will be 
ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a string representing a type of the prediction.
See 'Details' for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>me</code></td>
<td>
<p>a string representing the name of the variable for which marginal
effect should be estimated. See 'Details' for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>a numeric vector of length 1 or 2 used for calculation of
the marginal effects. See 'Details' for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of additional arguments. Currently is not intended
for the users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>a logical, function or integer. If <code>test = TRUE</code> then the 
output of the function is supplied to 
<code>test_msel</code> before return to perform a t-test.
If <code>test</code> is a function it will be applied to the output of the 
<code>predict</code> before <code>test_msel</code> is called.
If <code>test</code> is an integer then <code>test_msel</code>
will be applied only to the <code>test</code>-th column of the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exogenous</code></td>
<td>
<p>a list such that <code>exogenous[[i]]</code> represents the value 
(or a vector of values of the same size as <code>nrow(newdata)</code>) which will 
be exogenously assigned to the variable <code>names(exogenous)[[i]]</code> in 
<code>newdata</code> i.e., <code>newdata[, names(exogenous)[i]] &lt;- exogenous[[i]]</code>.
If <code>newdata</code> is <code>NULL</code> and <code>exogenous</code> is not <code>NULL</code> then
<code>newdata</code> is set to <code>object$data</code>.
This argument is especially useful for the casual inference when some 
endogenous (dependent) variables should be exogenously assigned with some 
values i.e., in the right hand side of the <code>formula</code>, <code>formula2</code> 
and <code>formula3</code>. The purpose of <code>exogeneous</code> argument is just a 
convenience so equivalently it is possible to exogenously provide the values
to variables via the <code>newdata</code> argument.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See 'Examples' section of <code>msel</code>
for the examples of this function application.
</p>
<p><strong>Probabilities of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "prob"</code> then the function returns a joint probability that 
the ordinal outcomes will have values assigned in <code>group</code>. To calculate
marginal probabilities set unnecessary <code>group</code> values to <code>-1</code>. 
</p>
<p>To estimate conditional probabilities provide indexes of the conditioned 
outcomes through the <code>given_ind</code> argument. 
</p>
<p>For example, if <code class="reqn">z_{1i}</code>, <code class="reqn">z_{2i}</code> and <code class="reqn">z_{3i}</code> are the ordinal
outcomes then to estimate 
<code class="reqn">P(z_{1i}=2 | z_{3i} = 0, w_{1i}, w_{2i}, w_{3i})</code> set 
<code>given_ind = 3</code> and <code>groups = c(2, -1, 0)</code>.
</p>
<p><strong>Linear predictors (indexes) of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "li"</code> or <code>type = "lp"</code> then the function returns a 
matrix which columns are linear predictors (indexes) of the corresponding 
equations. If <code>group[j] = -1</code> then linear predictors (indexes) 
associated with the <code>j</code>-th ordinal equation will be omitted from the 
output.
</p>
<p>For example, if <code>group = c(0, -1, 1)</code> then the function returns a
matrix which first column is <code class="reqn">w_{1i}\hat{\gamma}_{1}</code> and the second 
column is <code class="reqn">w_{3i}\hat{\gamma}_{3}</code>.
</p>
<p><strong>Standard deviations of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "sd"</code> then the function returns a matrix which columns are
the estimates of the standard deviations of the random errors for 
the corresponding equations. 
If <code>group[j] = -1</code> then the standard deviations associated with the 
<code>j</code>-th ordinal equation will be omitted from the output.
</p>
<p>For example, if <code>group = c(0, -1, 1)</code> then the function returns a
matrix which first column is <code class="reqn">\hat{\sigma}_{1i}^{*}</code> and the second 
column is <code class="reqn">\hat{\sigma}_{3i}^{*}</code>.
</p>
<p><strong>Predictions of the continuous outcomes</strong>
</p>
<p>If <code>type = "val"</code> then the function returns the predictions of the 
conditional (on <code>group</code>) expectation of the continuous outcomes in the 
regimes determined by the <code>group2</code> argument. To predict unconditional 
expectations set <code>group</code> to a vector of <code>-1</code> values.
</p>
<p>For example, suppose that there is a single continuous equation <code class="reqn">y_{i}</code> 
and two ordinal equations <code class="reqn">z_{1i}</code> and <code class="reqn">z_{2i}</code>. 
To estimate <code class="reqn">E(y_{2i}|x_{i})</code> set <code>group = c(-1, -1)</code> and 
<code>group2 = 2</code>. 
To estimate <code class="reqn">E(y_{1i}|x_{i}, z_{1i} = 2, z_{2i} = 0)</code> set 
<code>group = c(2, 0)</code> and <code>group2 = 1</code>.
To estimate <code class="reqn">E(y_{0i}|x_{i}, z_{2i} = 1)</code> set 
<code>group = c(-1, 1)</code> and <code>group2 = 0</code>.
</p>
<p>Suppose that there are two continuous <code class="reqn">y_{i}^{(1)}</code>,
<code class="reqn">y_{i}^{(2)}</code> and two ordinal <code class="reqn">z_{1i}</code>, <code class="reqn">z_{2i}</code> equations.
If <code>group2 = c(1, 3)</code> and <code>group = c(3, 0)</code> then the function 
returns a matrix which first column are the estimates of 
<code class="reqn">E(y_{1i}^{(1)}|z_{1i} = 3, z_{2i} = 0, x_{i}^{(1)})</code> and the second 
column are the estimates of 
<code class="reqn">E(y_{3i}^{(2)}|z_{1i} = 3, z_{2i} = 0, x_{i}^{(2)})</code>.
</p>
<p><strong>Selectivity terms</strong>
</p>
<p>If <code>type = "lambda"</code> then the function returns a matrix which 
<code>j</code>-th column is a numeric vector of estimates of the selectivity terms 
<code class="reqn">\lambda_{ji}</code> associated with the ordinal equations. 
Similarly if <code>type = "lambda_mn"</code> then the
function returns a numeric matrix with the selectivity terms of the 
multinomial equations.
</p>
<p><strong>Probabilities of the multinomial equation</strong>
</p>
<p>If <code>type = "prob_mn"</code> and <code>group3 = j</code> then the function returns 
a vector of the estimates of the probabilities 
<code class="reqn">P(\tilde{z}_{i}=j|\tilde{w}_{i})</code>.
</p>
<p><strong>Linear indexes (predictors) of the multinomial equation</strong>
</p>
<p>If <code>type = "li_mn"</code> or <code>type = "lp_mn"</code> then the function returns a 
numeric matrix which <code>j</code>-th column is a numeric vector of estimates of 
the linear predictor (index) associated with the <code>(j-1)</code>-th alternative 
<code class="reqn">\tilde{w}_{i}\tilde{\gamma}_{(j-1)}</code>.
</p>
<p><strong>Estimation of the marginal effects</strong>
</p>
<p>If <code>me</code> is provided then the function returns marginal effect
of variable <code>me</code> respect to the statistic determined by the <code>type</code>
argument. 
</p>
<p>For example, if <code>me = "x1"</code> and <code>type = "prob"</code> then the function 
returns a marginal effect of <code>x1</code> on the corresponding probability 
i.e., one that would be estimated if <code>me</code> is <code>NULL</code>.
</p>
<p>If <code>length(eps) = 1</code> then <code>eps</code> is an increment in 
numeric differentiation procedure. 
If <code>eps</code> is <code>NULL</code> then this increment will be selected 
automatically taking into account scaling of variables. 
If <code>length(eps) = 2</code> then marginal effects will be estimated as the
difference of predicted value when variable <code>me</code> equals <code>eps[2]</code>
and <code>eps[1]</code> correspondingly. 
</p>
<p>For example, suppose that 
<code>type = "prob"</code>, <code>me = "x1"</code>, <code>given_ind = 3</code> and
<code>groups = c(2, -1, 0)</code>. Then if <code>eps</code> is a <code>NULL</code> or a 
small number (something like <code>eps = 0.0001</code>) then the following marginal
effect will be estimated (via the numeric differentiation):
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial P(z_{1i}=2 | z_{3i} = 0)}{\partial x_{1i}}.</code>
</p>

<p>If <code>eps = c(1, 3)</code> then the function estimates the following difference
(useful for estimation of marginal effects of ordered covariates):
</p>
<p style="text-align: center;"><code class="reqn">P(z_{1i}=2 | z_{3i} = 0, x_{1i} = 3) - 
      P(z_{1i}=2 | z_{3i} = 0, x_{1i} = 1).</code>
</p>

<p>Notice that the conditioning on <code class="reqn">w_{ji}</code> has been omitted for brevity.
</p>
<p><strong>Causal inference</strong>
</p>
<p>Argument <code>exogenous</code> is useful for the causal inference. 
For example, suppose that there are two binary outcomes <code class="reqn">z_{1i}</code> and
<code class="reqn">z_{2i}</code>. Also <code class="reqn">z_{1i}</code> is the endogenous regressor for <code class="reqn">z_{2i}</code>.
That is <code class="reqn">z_{1i}</code> appears both on the left hand side of
<code>formula[[1]]</code> and on the right hand side of <code>formula[[2]]</code>. 
Consider the estimation of the average treatment effect:
</p>
<p style="text-align: center;"><code class="reqn">ATE = P(z_{2i} = 1|do(z_{1i}) = 1) - 
P(z_{2i} = 1|do(z_{1i}) = 0),</code>
</p>

<p>where <code class="reqn">do</code> is a do-calculus operator.
The estimate of the average treatment effect is as follows:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{ATE} = \frac{1}{n}\sum\limits_{i=1}^{n}p_{1i}-p_{0i},</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">p_{1i} = \hat{P}(z_{2i} = 1|do(z_{1i}) = 1, w_{1i}, w_{2i}^{(*)}),</code>
</p>

<p style="text-align: center;"><code class="reqn">p_{0i} = \hat{P}(z_{2i} = 1|do(z_{1i}) = 0, w_{1i}, w_{2i}^{(*)}).</code>
</p>

<p>Vector <code class="reqn">w_{2i}^{(*)}</code> denotes all the regressors <code class="reqn">w_{2i}</code> except
the endogenous one <code class="reqn">z_{1i}</code>.
</p>
<p>To get <code class="reqn">\widehat{ATE}</code> it is sufficient to make the following steps. 
First, calculate <code class="reqn">p_{1i}</code> by setting <code>type = "prob"</code>, 
<code>group = c(-1, 1)</code> and providing the value <code>1</code> to <code class="reqn">z_{1i}</code> 
through the <code>exogenous</code> argument. 
Second, calculate <code class="reqn">p_{0i}</code> by setting <code>type = "prob"</code>, 
<code>group = c(-1, 0)</code> and providing the value <code>0</code> to <code class="reqn">z_{1i}</code> 
through the <code>exogenous</code> argument. Third, take the average value of 
<code class="reqn">p_{1i}-p_{0i}</code>.
</p>


<h3>Value</h3>

<p>This function returns predictions for each row of <code>newdata</code>
or for each observation in the model if <code>newdata</code> is <code>NULL</code>.
Structure of the output depends on the <code>type</code> argument
(see 'Details' section).
</p>


</div>