<div class="container">

<table style="width: 100%;"><tr>
<td>substr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract or Replace Substrings</h2>

<h3>Description</h3>

<p><code>substr</code> and <code>substrl</code> extract
contiguous parts of given character strings.
The former operates based on start and end positions
while the latter is fed with substring lengths.
</p>
<p>Their replacement versions allow for substituting parts of strings
with new content.
</p>
<p><code>gsubstr</code> and <code>gsubstrl</code> allow for extracting or replacing
multiple chunks from each string.
</p>


<h3>Usage</h3>

<pre><code class="language-R">substr(x, start = 1L, stop = -1L)

substrl(
  x,
  start = 1L,
  length = attr(start, "match.length"),
  ignore_negative_length = FALSE
)

substr(x, start = 1L, stop = -1L) &lt;- value

substrl(x, start = 1L, length = attr(start, "match.length")) &lt;- value

gsubstr(x, start = list(1L), stop = list(-1L))

gsubstrl(
  x,
  start = list(1L),
  length = lapply(start, attr, "match.length"),
  ignore_negative_length = TRUE
)

gsubstr(x, start = list(1L), stop = list(-1L)) &lt;- value

gsubstrl(x, start = list(1L), length = lapply(start, attr, "match.length")) &lt;- value

substring(text, first = 1L, last = -1L)

substring(text, first = 1L, last = -1L) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, text</code></td>
<td>
<p>character vector
whose parts are to be extracted/replaced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start, first</code></td>
<td>
<p>numeric vector (for <code>substr</code>)
or list of numeric vectors (for <code>gsubstr</code>)
giving the start indexes;
e.g., 1 denotes the first code point;
negative indexes
count from the end of a string, i.e., -1 is the last character</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop, last</code></td>
<td>
<p>numeric vector (for <code>substr</code>)
or list of numeric vectors (for <code>gsubstr</code>)
giving the end indexes (inclusive);
note that if the start position is farther than the
end position, this indicates an empty substring therein (see Examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>numeric vector  (for <code>substr</code>)
or list of numeric vectors (for <code>gsubstr</code>)
giving the substring lengths;
negative lengths result in a missing value or empty vector
(see <code>ignore_negative_length</code>) or the corresponding
substring being unchanged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_negative_length</code></td>
<td>
<p>single logical value;
whether negative lengths should be ignored or yield missing values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>character vector  (for <code>substr</code>)
or list of character vectors  (for <code>gsubstr</code>)
defining the replacements strings</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Not to be confused with <code>sub</code>.
</p>
<p><code>substring</code> is a [DEPRECATED] synonym for <code>substr</code>.
</p>
<p>Note that these functions can break some meaningful Unicode code point
sequences, e.g., when inputs are not normalised. For extracting
initial parts of strings based on character width, see <code>strtrim</code>.
</p>
<p>Note that <code>gsubstr</code> (and related functions) expect
<code>start</code>, <code>stop</code>, <code>length</code>, and <code>value</code>
to be lists. Non-list arguments will be converted by calling
<code>as.list</code>. This is different from the default policy
applied by <code>stri_sub_all</code>, which calls
<code>list</code>.
</p>
<p>Note that <code>substrl</code> and <code>gsubstrl</code> are
interoperable with <code>regexpr2</code> and <code>gregexpr2</code>,
respectively, and hence can be considered as substituted for the
[DEPRECATED] <code>regmatches</code> (which is more specialised).
</p>


<h3>Value</h3>

<p><code>substr</code> and <code>substrl</code> return a character vector (in UTF-8).
<code>gsubstr</code> and <code>gsubstrl</code> return a list of character vectors.
</p>
<p>Their replacement versions modify <code>x</code> 'in-place' (see Examples).
</p>
<p>The attributes are copied from the longest arguments (similar to
binary operators).
</p>


<h3>Differences from Base R</h3>

<p>Replacements for and enhancements of base <code>substr</code>
and <code>substring</code>
implemented with <code>stri_sub</code> and
<code>stri_sub_all</code>,
</p>

<ul>
<li> <p><code>substring</code> is "for compatibility with S", but this should
no longer matter
<b>[here, <code>substring</code> is equivalent to <code>substr</code>; in a
future version, using the former may result in a warning]</b>
</p>
</li>
<li> <p><code>substr</code> is not vectorised with respect to all the arguments
(and <code>substring</code> is not fully vectorised wrt <code>value</code>)
<b>[fixed here]</b>
</p>
</li>
<li>
<p> not all attributes are taken from the longest of the inputs
<b>[fixed here]</b>
</p>
</li>
<li>
<p> partial recycling with no warning
<b>[fixed here]</b>
</p>
</li>
<li>
<p> the replacement must be of the same length as the chunk
being substituted <b>[fixed here]</b>
</p>
</li>
<li>
<p> negative indexes are silently treated as 1
<b>[changed here: negative indexes count from the end of the string]</b>
</p>
</li>
<li>
<p> replacement of different length than the extracted substring
never changes the length of the string
<b>[changed here â€“ output length is input length minus
length of extracted plus length of replacement]</b>
</p>
</li>
<li> <p><code>regexpr</code> (amongst others) return start positions
and lengths of matches, but base <code>substr</code> only uses
start and end
<b>[fixed by introducing <code>substrl</code>]</b>
</p>
</li>
<li>
<p> there is no function to extract or replace multiple
chunks in each string (other than <code>regmatches</code>
that works on outputs generated by <code>gregexpr</code> et al.)
<b>[fixed by introducing <code>gsubstrl</code>]</b>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringx</span> at <a href="https://stringx.gagolewski.com/">https://stringx.gagolewski.com/</a>
</p>
<p>Related function(s): <code>strtrim</code>, <code>nchar</code>,
<code>startsWith</code>, <code>endsWith</code>,
<code>gregexpr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- "spam, spam, bacon, and spam"
base::substr(x, c(1, 13), c(4, 17))
base::substring(x, c(1, 13), c(4, 17))
substr(x, c(1, 13), c(4, 17))
substrl(x, c(1, 13), c(4, 5))

# replacement function used as an ordinary one - return a copy of x:
base::`substr&lt;-`(x, 1, 4, value="jam")
`substr&lt;-`(x, 1, 4, value="jam")
base::`substr&lt;-`(x, 1, 4, value="porridge")
`substr&lt;-`(x, 1, 4, value="porridge")

# interoperability with gregexpr2:
p &lt;- "[\\w&amp;&amp;[^a]][\\w&amp;&amp;[^n]][\\w&amp;&amp;[^d]]\\w+"  # regex: all words but 'and'
gsubstrl(x, gregexpr2(x, p))
`gsubstrl&lt;-`(x, gregexpr2(x, p), value=list(c("a", "b", "c", "d")))

# replacement function modifying x in-place:
substr(x, 1, 4) &lt;- "eggs"
substr(x, 1, 0) &lt;- "porridge, "        # prepend (start&lt;stop)
substr(x, nchar(x)+1) &lt;- " every day"  # append (start&lt;stop)
print(x)



</code></pre>


</div>