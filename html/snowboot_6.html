<div class="container">

<table style="width: 100%;"><tr>
<td>lsmi_cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation to Select an Optimal Combination of n.seed and n.wave</h2>

<h3>Description</h3>

<p>From the vector of specified <code>n.seeds</code> and possible waves <code>1:n.wave</code> around each
seed, the function selects a single number <code>n.seed</code> and an <code>n.wave</code>
(optimal seed-wave combination) that produce
a labeled snowball with multiple inclusions (LSMI) sample with desired
bootstrap confidence intervals for a parameter of interest. Here by ‘desired’
we mean that the interval (and corresponding seed-wave combination) are selected
as having the best coverage (closest to the specified level <code>prob</code>), based on
a cross-validation procedure with proxy estimates of the parameter.
See Algorithm 2 by Gel et al. (2017) and Details
below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lsmi_cv(
  net,
  n.seeds,
  n.wave,
  seeds = NULL,
  B = 100,
  prob = 0.95,
  cl = 1,
  param = c("mu"),
  method = c("percentile", "basic"),
  proxyRep = 19,
  proxySize = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt>
<dd>
<p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt>
<dd>
<p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>
<p>The network object can be simulated by <code>random_network</code>,
selected from the networks available in <code>artificial_networks</code>,
converged from an <code>igraph</code> object with <code>igraph_to_network</code>,
etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.seeds</code></td>
<td>
<p>an integer vector of numbers of seeds for snowball sampling
(cf. a single integer <code>n.seed</code> in <code>lsmi</code>). Only
<code>n.seeds &lt;= n</code> are retained. If <code>seeds</code> is
specified, only values <code>n.seeds &lt; length(unique(seeds))</code> are retained
and automatically supplemented by <code>length(unique(seeds))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.wave</code></td>
<td>
<p>an integer defining the number of waves (order of the neighborhood)
to be recorded around the seed in the LSMI. For example, <code>n.wave = 1</code> corresponds to
an LSMI with the seed and its first neighbors. Note that the algorithm allows for
multiple inclusions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>a vector of numeric IDs of pre-specified seeds. If specified,
LSMIs are constructed around each such seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>a positive integer, the number of bootstrap replications to perform.
Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>confidence level for the intervals. Default is 0.95
(i.e., 95% confidence).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>parameter to specify computer cluster for bootstrapping, passed to
the package <code>parallel</code> (default is <code>1</code>, meaning no cluster is used).
Possible values are:
</p>

<ul>
<li>
<p> cluster object (list) produced by makeCluster.
In this case, new cluster is not started nor stopped;
</p>
</li>
<li> <p><code>NULL</code>. In this case, the function will attempt to detect
available cores (see detectCores) and, if there are
multiple cores (<code class="reqn">&gt;1</code>), a cluster will be started with
makeCluster. If started, the cluster will be stopped
after computations are finished;
</p>
</li>
<li>
<p> positive integer defining the number of cores to start a cluster.
If <code>cl = 1</code>, no attempt to create a cluster will be made.
If <code>cl &gt; 1</code>, cluster will be started (using makeCluster)
and stopped afterwards (using stopCluster).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>The parameter of interest for which to run a cross-validation
and select optimal <code>n.seed</code> and <code>n.wave</code>. Currently, only one
selection is possible: <code>"mu"</code> (the network mean degree).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method for calculating the bootstrap intervals. Default is
<code>"percentile"</code> (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proxyRep</code></td>
<td>
<p>The number of times to repeat proxy sampling. Default is 19.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proxySize</code></td>
<td>
<p>The size of the proxy sample. Default is 30.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Currently, the bootstrap intervals can be calculated with two alternative
methods: <code>"percentile"</code> or <code>"basic"</code>. The <code>"percentile"</code>
intervals correspond to Efron's <code class="reqn">100\cdot</code><code>prob</code>% intervals
(see Efron 1979, also Equation 5.18 by Davison and Hinkley 1997 and Equation 3 by Gel et al. 2017, Chen et al. 2018):
</p>
<p style="text-align: center;"><code class="reqn">(\theta^*_{[B\alpha/2]}, \theta^*_{[B(1-\alpha/2)]}),</code>
</p>

<p>where <code class="reqn">\theta^*_{[B\alpha/2]}</code> and <code class="reqn">\theta^*_{[B(1-\alpha/2)]}</code>
are empirical quantiles of the bootstrap distribution with <code>B</code> bootstrap
replications for parameter <code class="reqn">\theta</code>
(<code class="reqn">\theta</code> can be the <code class="reqn">f(k)</code> or <code class="reqn">\mu</code>),
and <code class="reqn">\alpha = 1 -</code> <code>prob</code>.
</p>
<p>The <code>"basic"</code> method produces intervals
(see Equation 5.6 by Davison and Hinkley 1997):
</p>
<p style="text-align: center;"><code class="reqn">(2\hat{\theta} - \theta^*_{[B(1-\alpha/2)]}, 2\hat{\theta} - \theta^*_{[B\alpha/2]}),</code>
</p>

<p>where <code class="reqn">\hat{\theta}</code> is the sample estimate of the parameter.
Note that this method can lead to negative confidence bounds, especially
when <code class="reqn">\hat{\theta}</code> is close to 0.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>bci</code></td>
<td>
<p>A numeric vector of length 2 with the bootstrap confidence interval
(lower bound, upper bound) for the parameter of interest. This interval is
obtained by bootstrapping node degrees in an LSMI with the optimal combination
of <code>n.seed</code> and <code>n.wave</code>
(the combination is reported in <code>best_combination</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>Point estimate of the parameter of interest
(based on the LSMI with <code>n.seed</code> seeds and <code>n.wave</code> waves
reported in the <code>best_combination</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best_combination</code></td>
<td>
<p>An integer vector of lenght 2 containing the optimal
<code>n.seed</code> and <code>n.wave</code> selected via cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>A vector of numeric IDs of the seeds that were used
in the LSMI with the optimal combination of <code>n.seed</code> and <code>n.wave</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
“Snowboot: bootstrap methods for network inference.”
<em>The R Journal</em>, <b>10</b>(2), 95–113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br><br> Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and Their Application</em>.
Cambridge University Press, Cambridge.<br><br> Efron B (1979).
“Bootstrap methods: Another look at the jackknife.”
<em>The Annals of Statistics</em>, <b>7</b>(1), 1–26.
doi: <a href="https://doi.org/10.1214/aos/1176344552">10.1214/aos/1176344552</a>.<br><br> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
“Bootstrap quantification of estimation uncertainties in network degree distributions.”
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.
</p>


<h3>See Also</h3>

<p><code>lsmi</code>, <code>lsmi_union</code>, <code>boot_dd</code>, <code>boot_ci</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">net &lt;- artificial_networks[[1]]
a &lt;- lsmi_cv(net, n.seeds = c(10, 20, 30), n.wave = 5, B = 100)

</code></pre>


</div>