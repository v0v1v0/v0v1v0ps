<div class="container">

<table style="width: 100%;"><tr>
<td>svmidwpred</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate spatial predictions using the hybrid method of support vector machine ('svm')
regression and inverse distance weighted ('IDW') ('svmidw')</h2>

<h3>Description</h3>

<p>This function is for generating spatial predictions using the hybrid
method of 'svm' and 'idw' ('svmidw').
</p>


<h3>Usage</h3>

<pre><code class="language-R">svmidwpred(
  formula = NULL,
  longlat,
  trainxy,
  y,
  longlatpredx,
  predx,
  scale = TRUE,
  type = NULL,
  kernel = "radial",
  degree = 3,
  gamma = if (is.vector(trainxy)) 1 else 1/ncol(trainxy),
  coef0 = 0,
  cost = 1,
  nu = 0.5,
  tolerance = 0.001,
  epsilon = 0.1,
  idp = 2,
  nmaxidw = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula defining the response variable and predictive variables
for 'svm'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>a dataframe contains longitude and latitude of point samples. The
location information must be named as 'long' and 'lat'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainxy</code></td>
<td>
<p>a dataframe contains longitude (long), latitude (lat),
predictive variables and the response variable of point samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector of the response variable in the formula, that is, the left
part of the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlatpredx</code></td>
<td>
<p>a dataframe contains longitude and latitude of point locations
(i.e., the centers of grids) to be predicted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predx</code></td>
<td>
<p>a dataframe or matrix contains columns of predictive variables
for the grids to be predicted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A logical vector indicating the variables to be scaled (default: TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the default setting is 'NULL'. See '?svm' for various options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>the default setting is 'radial'. See '?svm' for other options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>a parameter needed for kernel of type polynomial (default: 3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>a parameter needed for all 'kernels' except 'linear'
(default: 1/(data dimension)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef0</code></td>
<td>
<p>a parameter needed for kernels of type 'polynomial' and 'sigmoid'(default: 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>cost of constraints violation (default: 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>a parameter needed for 'nu-classification', 'nu-regression', and 'one-classification' (default: 0.5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>tolerance of termination criterion (default: 0.001).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>'epsilon' in the insensitive-loss function (default: 0.1).
See '?svm' for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idp</code></td>
<td>
<p>a numeric number specifying the inverse distance weighting power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmaxidw</code></td>
<td>
<p>for a local predicting: the number of nearest observations that
should be used for a prediction or simulation, where nearest is defined in
terms of the space of the spatial locations. By default, 12 observations
are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to 'svm'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A dataframe of longitude, latitude, and predictions.
</p>


<h3>Author(s)</h3>

<p>Jin Li
</p>


<h3>References</h3>

<p>Li, J., Potter, A., Huang, Z., and Heap, A. (2012). Predicting Seabed
Sand Content across the Australian Margin Using Machine Learning and Geostatistical
Methods, Geoscience Australia, Record 2012/48, 115pp.
</p>
<p>Li, J., Heap, A., Potter, A., and Danilel, J.J. (2011). Predicting Seabed Mud Content
across the Australian Margin II: Performance of Machine Learning Methods and Their
Combination with Ordinary Kriging and Inverse Distance Squared, Geoscience Australia,
Record 2011/07, 69pp.
</p>
<p>David Meyer, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel and Friedrich
Leisch (2020). e1071: Misc Functions of the Department of Statistics, Probability
Theory Group (Formerly: E1071), TU Wien. R package version 1.7-4.
https://CRAN.R-project.org/package=e1071.
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers &amp; Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(spm)
data(petrel)
data(petrel.grid)

gravel &lt;- petrel[, c(1, 2, 6:9, 5)]
longlat &lt;- petrel[, c(1, 2)]
model &lt;- log(gravel + 1) ~  lat +  bathy + I(long^3) + I(lat^2) + I(lat^3)
y &lt;- log(gravel[, 7] +1)

svmidwpred1 &lt;- svmidwpred(formula = model, longlat = longlat, trainxy =  gravel,
y = y, longlatpredx = petrel.grid[, c(1:2)], predx = petrel.grid, idp = 2,
 nmaxidw = 12)

names(svmidwpred1)

# Back transform 'svmidwpred$predictions' to generate the final predictions
svmidw.predictions &lt;- exp(svmidwpred1$predictions) - 1
range(svmidw.predictions)


</code></pre>


</div>