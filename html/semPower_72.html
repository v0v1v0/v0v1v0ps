<div class="container">

<table style="width: 100%;"><tr>
<td>semPower.powerPath</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>semPower.powerPath</h2>

<h3>Description</h3>

<p>Convenience function for performing power analyses for hypothesis arising
in a generic path model.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">semPower.powerPath(
  type,
  comparison = "restricted",
  Beta,
  Psi = NULL,
  nullEffect = "beta = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta</code></td>
<td>
<p>matrix of regression slopes between latent variables (all-Y notation). A list for multiple group models. Exogenous variables must occupy the first rows in <code>Beta</code> when <code>standardized = TRUE</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Psi</code></td>
<td>
<p>variance-covariance matrix of latent (residual) factors. If <code>standardized = TRUE</code>, the diagonal is ignored and all off-diagonal elements are treated as correlations. If <code>NULL</code>, an identity matrix is assumed. A list for multiple group models. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'beta = 0'</code> (the default) to test whether a regression slope is zero, <code>'betaX = betaZ'</code> to test for the equality of slopes, and <code>'betaX = betaZ'</code> to test for the equality of a slope across groups. Define the slopes to be set to equality in <code>nullWhich</code> and the groups in <code>nullWhichGroups</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullWhich</code></td>
<td>
<p>vector of size 2 indicating which slope in <code>Beta</code> is hypothesized to equal zero when <code>nullEffect = 'beta = 0'</code>, or to restrict to equality across groups when <code>nullEffect = 'betaA = betaB'</code>, or list of vectors defining which correlations to restrict to equality when <code>nullEffect = 'betaX = betaZ'</code>. Can also contain more than two slopes, e.g., <code>list(c(2, 1), c(3, 1), c(3, 2))</code> to set <code>Beta[2, 1] = Beta[3, 1] = Beta[3, 2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'betaA = betaB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>whether all parameters should be standardized (<code>TRUE</code>, the default). If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code>semPower.aPriori()</code>, <code>semPower.postHoc()</code>, and <code>semPower.compromise()</code>, and parameters specifying the factor model. See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs a power analysis to reject a hypothesis arising
in a generic structural equation model specifying regression relations between the factors via the Beta matrix:
</p>

<ul>
<li> <p><code>nullEffect = 'beta = 0'</code>: Tests the hypothesis that a slope is zero.
</p>
</li>
<li> <p><code>nullEffect = 'betaX = betaZ'</code>: Tests the hypothesis that two or more slopes are equal to each other.
</p>
</li>
<li> <p><code>nullEffect = 'betaA = betaB'</code>: Tests the hypothesis that a slope is equal in two or more groups (always assuming metric invariance).
</p>
</li>
</ul>
<p>This function provides a generic way to perform power analyses (as compared to other functions covering special cases in a more accessible manner).
</p>
<p>A specific hypothesis is defined by setting <code>nullEffect</code> to define the hypothesis type,
<code>nullWhich</code> to define the slope(s) that are targeted, and by providing
the <code>Beta</code> (and optionally the <code>Psi</code>) matrix to define the population structure.
</p>
<p>To understand the structure of <code>Beta</code> and <code>Psi</code>, consider the general structural equation model,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \Lambda (I - B)^{-1} \Psi [(I - B)^{-1}]'  \Lambda' + \Theta </code>
</p>

<p>where <code class="reqn">B</code> is the <code class="reqn">m \cdot m</code> matrix containing the regression slopes and <code class="reqn">\Psi</code> is the (residual) variance-covariance matrix of the <code class="reqn">m</code> factors.
</p>
<p>As an example, suppose there are four factors (X1, X2, X3, X4), and Beta is defined as follows:
</p>
<p><code class="reqn">
\begin{array}{lrrrr} 
    &amp; X_1 &amp; X_2 &amp; X_3 &amp; X_4\\ 
X_1 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 \\ 
X_2 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0  \\ 
X_3 &amp; 0.2 &amp; 0.3 &amp; 0.0 &amp; 0.0  \\ 
X_4 &amp; 0.3 &amp; 0.5 &amp; 0.0 &amp; 0.0  \\ 
\end{array}
</code>
</p>
<p>Each row specifies how a particular factor is predicted by the available factors,
so the above implies the following regression relations:
</p>
<p><code class="reqn">
X_1 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_2 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_3 = 0.2 \cdot X_1 +  0.3 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_4 = 0.3 \cdot X_1 +  0.5 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 
</code>
</p>
<p>which simplifies to
</p>
<p><code class="reqn">
X_3 = 0.2 \cdot X_1 + 0.3 \cdot X_2 \\
X_4 = 0.3 \cdot X_1 + 0.5 \cdot X_2 
</code>
</p>
<p>Further suppose that Psi is
</p>
<p><code class="reqn">
\begin{array}{lrrrr} 
    &amp; X_1 &amp; X_2 &amp; X_3 &amp; X_4\\ 
X_1 &amp; 1.0 &amp; 0.3 &amp; 0.0 &amp; 0.0 \\ 
X_2 &amp; 0.3 &amp; 1.0 &amp; 0.0 &amp; 0.0 \\ 
X_3 &amp; 0.0 &amp; 0.0 &amp; 1.0 &amp; 0.2 \\ 
X_4 &amp; 0.0 &amp; 0.0 &amp; 0.2 &amp; 1.0 \\ 
\end{array}
</code>
</p>
<p>which implies a correlation between X1 and X2 of .3 and a residual correlation
between X3 and X4 of .2.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li>
</ul>
<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> always need to be defined.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li>
<p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li>
</ul>
<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li>
</ul>
<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>semPower.aPriori()</code> <code>semPower.postHoc()</code> <code>semPower.compromise()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set up pathmodel in the form of
# f2 = .2*f1
# f3 = .3*f2
# f4 = .1*f1 + .4*f3
# obtain the required N to detect that the 
# slope f1 -&gt; f4 is &gt;= .10 
# with a power of 95% on alpha = 5%
# where f1 is measured by 3, f2 by 4, f3 by 5, and f4 by 6 indicators, 
# and all loadings are .5
Beta &lt;- matrix(c(
  c(.00, .00, .00, .00),       # f1
  c(.20, .00, .00, .00),       # f2
  c(.00, .30, .00, .00),       # f3
  c(.10, .00, .40, .00)        # f4
), byrow = TRUE, ncol = 4)
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullWhich = c(4, 1),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)
# show summary
summary(powerPath)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerPath$modelH1, sample.cov = powerPath$Sigma,
sample.nobs = powerPath$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powerPath$modelH0, sample.cov = powerPath$Sigma,
sample.nobs = powerPath$requiredN, sample.cov.rescale = FALSE)

# same as above, but detect that the slope f3 -&gt; f4 is &gt;= .30 
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullWhich = c(4, 3),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)

# same as above, but detect that 
# the slope f1 -&gt; f2 (of .20) differs from the slope f2 -&gt; f3 (of .30) 
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullEffect = 'betaX = betaZ',
                                nullWhich = list(c(2, 1), c(3, 2)),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)

# same as above, but consider a multiple group model with equally sized groups, 
# and obtain the required N to detect that the slope 
# in group 1 (of .20) differs from the one in group 2 (of .40)
Beta1 &lt;- Beta2 &lt;- matrix(c(
  c(.00, .00, .00, .00),       # f1
  c(.20, .00, .00, .00),       # f2
  c(.00, .30, .00, .00),       # f3
  c(.10, .00, .40, .00)        # f4
), byrow = TRUE, ncol = 4)
Beta2[2, 1] &lt;- .40
Beta &lt;- list(Beta1, Beta2)
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullEffect = 'betaA = betaB',
                                nullWhich = c(2, 1),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05, N = list(1, 1))

## End(Not run)
</code></pre>


</div>