<div class="container">

<table style="width: 100%;"><tr>
<td>s2_closest_feature</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix Functions</h2>

<h3>Description</h3>

<p>These functions are similar to accessors and predicates, but instead of
recycling <code>x</code> and <code>y</code> to a common length and returning a vector of that
length, these functions return a vector of length <code>x</code> with each element
<code>i</code> containing information about how the entire vector <code>y</code> relates to
the feature at <code>x[i]</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">s2_closest_feature(x, y)

s2_closest_edges(
  x,
  y,
  k,
  min_distance = -1,
  max_distance = Inf,
  radius = s2_earth_radius_meters()
)

s2_farthest_feature(x, y)

s2_distance_matrix(x, y, radius = s2_earth_radius_meters())

s2_max_distance_matrix(x, y, radius = s2_earth_radius_meters())

s2_contains_matrix(x, y, options = s2_options(model = "open"))

s2_within_matrix(x, y, options = s2_options(model = "open"))

s2_covers_matrix(x, y, options = s2_options(model = "closed"))

s2_covered_by_matrix(x, y, options = s2_options(model = "closed"))

s2_intersects_matrix(x, y, options = s2_options())

s2_disjoint_matrix(x, y, options = s2_options())

s2_equals_matrix(x, y, options = s2_options())

s2_touches_matrix(x, y, options = s2_options())

s2_dwithin_matrix(x, y, distance, radius = s2_earth_radius_meters())

s2_may_intersect_matrix(x, y, max_edges_per_cell = 50, max_feature_cells = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>Geography vectors, coerced using <code>as_s2_geography()</code>.
<code>x</code> is considered the source, where as <code>y</code> is considered the target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of closest edges to consider when searching. Note
that in S2 a point is also considered an edge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_distance</code></td>
<td>
<p>The minimum distance to consider when searching for
edges. This filter is applied after the search is complete (i.e.,
may cause fewer than <code>k</code> values to be returned).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_distance</code></td>
<td>
<p>The maximum distance to consider when searching for
edges. This filter is applied before the search.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code>s2_earth_radius_meters()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>An <code>s2_options()</code> object describing the polygon/polyline
model to use and the snap level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>A distance on the surface of the earth in the same units
as <code>radius</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_edges_per_cell</code></td>
<td>
<p>For <code>s2_may_intersect_matrix()</code>,
this values controls the nature of the index on <code>y</code>, with higher values
leading to coarser index. Values should be between 10 and 50; the default
of 50 is adequate for most use cases, but for specialized operations users
may wish to use a lower value to increase performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_feature_cells</code></td>
<td>
<p>For <code>s2_may_intersect_matrix()</code>, this value
controls the approximation of <code>x</code> used to identify potential intersections
on <code>y</code>. The default value of 4 gives the best performance for most operations,
but for specialized operations users may wish to use a higher value to increase
performance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of length <code>x</code>.
</p>


<h3>See Also</h3>

<p>See pairwise predicate functions (e.g., <code>s2_intersects()</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">city_names &lt;- c("Vatican City", "San Marino", "Luxembourg")
cities &lt;- s2_data_cities(city_names)
country_names &lt;- s2_data_tbl_countries$name
countries &lt;- s2_data_countries()

# closest feature returns y indices of the closest feature
# for each feature in x
country_names[s2_closest_feature(cities, countries)]

# farthest feature returns y indices of the farthest feature
# for each feature in x
country_names[s2_farthest_feature(cities, countries)]

# use s2_closest_edges() to find the k-nearest neighbours
nearest &lt;- s2_closest_edges(cities, cities, k = 2, min_distance = 0)
city_names
city_names[unlist(nearest)]

# predicate matrices
country_names[s2_intersects_matrix(cities, countries)[[1]]]

# distance matrices
s2_distance_matrix(cities, cities)
s2_max_distance_matrix(cities, countries[1:4])

</code></pre>


</div>