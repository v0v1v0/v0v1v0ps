<div class="container">

<table style="width: 100%;"><tr>
<td>ordering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract the permutation</h2>

<h3>Description</h3>

<p>Extract the (inverse) permutation used by the Cholesky
decomposition</p>


<h3>Usage</h3>

<pre><code class="language-R">ordering( x, inv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>spam.chol.</code><em>method</em> returned by the function
<code>chol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv</code></td>
<td>
<p>Return the permutation (default) or inverse thereof.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Recall that calculating a Cholesky factor from a sparse matrix
consists of finding a permutation first, then calculating the factors
of the permuted matrix. The ordering is important when working with
the factors themselves.<br></p>
<p>The ordering from a full/regular matrix is <code>1:n</code>.<br></p>
<p>Note that there exists many different algorithms to find
orderings.  
<br></p>
<p>See the examples, they speak more than 10 lines.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code>chol.spam</code>, <code>solve.spam</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Construct a pd matrix S to work with (size n)
n &lt;- 100    # dimension
S &lt;- .25^abs(outer(1:n,1:n,"-"))
S &lt;- as.spam( S, eps=1e-4)
I &lt;- diag(n)  # Identity matrix

cholS &lt;- chol( S)
ord &lt;- ordering(cholS)
iord &lt;- ordering(cholS, inv=TRUE)

R &lt;- as.spam( cholS ) # R'R = P S P', with P=I[ord,],
  # a permutation matrix (rows permuted).
RtR &lt;- t(R) %*% R

# the following are equivalent:
as.spam( RtR -            S[ord,ord],    eps=1e-15)
as.spam( RtR[iord,iord] - S,             eps=1e-15)
as.spam( t(R[,iord]) %*% R[,iord] - S, eps=1e-15)
# we use 'eps' to avoid issues close to machine precision

# trivially:
as.spam( t(I[iord,]) - I[ord,])  # (P^-1)' = P  
as.spam( t(I[ord,]) - I[,ord])  # 
as.spam( I[iord,] - I[,ord])
as.spam( I[ord,]%*%S%*%I[,ord] - S[ord,ord] )
   # pre and post multiplication with P and P' is ordering
</code></pre>


</div>