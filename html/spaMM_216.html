<div class="container">

<table style="width: 100%;"><tr>
<td>inits</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Controlling optimization strategy through initial values
</h2>

<h3>Description</h3>

<p>Several parameters (notably the dispersion parameters: the variance of random effects and the residual variance parameter, if any) can be estimated either by iterative algorithms, or by generic optimization methods. The development of the <code>fitme</code> function aims to provide full control of the selection of algorithms. For example, if two random effects are fitted, then<br><code>init=list(lambda=c(NA,NaN))</code> enforces generic optimization for the first variance and iterative algorithms for the second.<br><code>init=list(lambda=c(0.1,NaN))</code> has the same effect and additionally provides control of the initial value for optimization (whereas <code>init.HLfit=list(lambda=c(NA,0.1))</code> will provide control of the initial value for iterations).
</p>
<p>How to know which algorithm has been selected for each parameter? <code>fitme(., verbose=c(TRACE=TRUE))</code> shows successive values of the variables estimated by optimization (See Examples; if no value appears, then all are estimated by iterative methods). The first lines of the summary of a fit object should tell which variances are estimated by the “outer” method.
</p>
<p><code>corrHLfit</code>, which uses inner optimization by default, can be forced to perform outer optimization. Its control is more limited, as <code>NA</code>s and <code>NaN</code>s are not allowed. Instead, only numeric values as in <code>init=list(lambda=0.1)</code> are allowed. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
air &lt;- data.frame(passengers = as.numeric(AirPassengers),
                  year_z = scale(rep(1949:1960, each = 12)),
                  month = factor(rep(1:12, 12)))
air$time &lt;- 1:nrow(air)
# Use verbose to find that lambda is estimated by optimization
fitme(passengers ~ month * year_z + AR1(1|time), data = air, 
      verbose=c(TRACE=TRUE)) 
# Use init to enforce iterative algorithm for lambda estimation:      
fitme(passengers ~ month * year_z + AR1(1|time), data = air, 
      verbose=c(TRACE=TRUE), init=list(lambda=NaN))
# (but then it may be better to enforce it also for phi: init=list(lambda=NaN, phi=NaN))
#
# Use init to enforce generic optimization for lambda estimation,
#   and control initial value:      
fitme(passengers ~ month * year_z + AR1(1|time), data = air, 
      verbose=c(TRACE=TRUE), init=list(lambda=0.1))
      
# See help("multinomial") for more examples of control by initial values.       

## End(Not run)
</code></pre>


</div>