<div class="container">

<table style="width: 100%;"><tr>
<td>cpMajorityComparison</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CP-Majority relation</h2>

<h3>Description</h3>

<p>The Ceteris Paribus-majority relation compares the relative success between two players joining a coalition.
</p>
<p><code>cpMajorityComparisonScore()</code> only returns two numbers, a positive number of coalitions where <code>e1</code> beats <code>e2</code>,
and a negative number of coalitions where <code>e1</code> is beaten by <code>e2</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cpMajorityComparison(
  powerRelation,
  e1,
  e2,
  strictly = FALSE,
  includeEmptySet = TRUE
)

cpMajorityComparisonScore(
  powerRelation,
  e1,
  e2,
  strictly = FALSE,
  includeEmptySet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strictly</code></td>
<td>
<p>Only include <code class="reqn">D_{ij}(\succ)</code> and <code class="reqn">D_{ji}(\succ)</code>, i.e., coalitions
<code class="reqn">S \in 2^{N \setminus \lbrace i,j\rbrace}</code> where
<code class="reqn">S \cup \lbrace i\rbrace \succ S \cup \lbrace j\rbrace</code> and
vice versa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeEmptySet</code></td>
<td>
<p>If <code>TRUE</code>, check <code class="reqn">\lbrace i \rbrace \succsim \lbrace j \rbrace</code> even if
empty set is not part of the power relation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given two elements <code class="reqn">i</code> and <code class="reqn">j</code>, go through each coalition <code class="reqn">S \in 2^{N \setminus \lbrace i, j \rbrace}</code>.
<code class="reqn">D_{ij}(\succsim)</code> then contains all coalitions <code class="reqn">S</code> where
<code class="reqn">S \cup \lbrace i \rbrace \succsim S \cup \lbrace j \rbrace</code> and <code class="reqn">D_{ji}(\succsim)</code> contains all coalitions where
<code class="reqn">S \cup \lbrace j \rbrace \succsim S \cup \lbrace i \rbrace</code>.
</p>
<p>The cardinalities
<code class="reqn">d_{ij}(\succsim) = |D_{ij}|</code> and
<code class="reqn">d_{ji}(\succsim) = |D_{ji}|</code> represent the score of the two elements, where
<code class="reqn">i \succ j</code>    if <code class="reqn">d_{ij}(\succsim)   &gt;  d_{ji}(\succsim)</code> and
<code class="reqn">i \sim  j</code>    if <code class="reqn">d_{ij}(\succsim)  ==  d_{ji}(\succsim)</code>.
</p>
<p><code>cpMajorityComparison()</code> tries to retain all that information. The list returned contains the following information.
Note that in this context the two elements <code class="reqn">i</code> and <code class="reqn">j</code> refer to element 1 and element 2 respectively.
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$e1⁠</code>: list of information about element 1
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$e1$name⁠</code>: name of element 1
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$e1$score⁠</code>: score <code class="reqn">d_{ij}(\succsim)</code>. <code class="reqn">d_{ij}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$e1$winningCoalitions⁠</code>: list of coalition <code>vectors</code> <code class="reqn">S \in D_{ij}(\succsim)</code>. <code class="reqn">S \in D_{ij}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
</ul>
</li>
<li> <p><code style="white-space: pre;">⁠$e2⁠</code>: list of information about element 2
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$e2$name⁠</code>: name of element 2
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$e1$score⁠</code>: score <code class="reqn">d_{ji}(\succsim)</code>. <code class="reqn">d_{ji}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$e1$winningCoalitions⁠</code>: list of coalition <code>vectors</code> <code class="reqn">S \in D_{ji}(\succsim)</code>.  <code class="reqn">S \in D_{ji}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
</ul>
</li>
<li> <p><code style="white-space: pre;">⁠$winner⁠</code>: name of higher scoring element. <code>NULL</code> if they are indifferent.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$loser⁠</code>: name of lower scoring element. <code>NULL</code> if they are indifferent.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$tuples⁠</code>: a list of coalitions <code class="reqn">S \in 2^{N \setminus \lbrace i, j \rbrace }</code> with:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$tuples[[x]]$coalition⁠</code>: <code>vector</code>, the coalition <code class="reqn">S</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$tuples[[x]]$included⁠</code>: logical, <code>TRUE</code> if <code class="reqn">S \cup \lbrace i \rbrace</code> and <code class="reqn">S \cup \lbrace j \rbrace</code> are in the power relation
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$tuples[[x]]$winner⁠</code>: name of the winning element <code class="reqn">i</code> where <code class="reqn">S \cup \lbrace i \rbrace \succ S \cup \lbrace j \rbrace</code>. It is <code>NULL</code> if <code class="reqn">S \cup \lbrace i \rbrace \sim S \cup \lbrace j \rbrace</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$tuples[[x]]$e1⁠</code>: index <code class="reqn">x_1</code> at which <code class="reqn">S \cup \lbrace i \rbrace \in \sum_{x_1}</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$tuples[[x]]$e2⁠</code>: index <code class="reqn">x_2</code> at which <code class="reqn">S \cup \lbrace j \rbrace \in \sum_{x_2}</code>
</p>
</li>
</ul>
</li>
</ul>
<p>The much more efficient <code>cpMajorityComparisonScore()</code> only calculates <code style="white-space: pre;">⁠$e1$score⁠</code>.
</p>
<p>Unlike Lexcel, Ordinal Banzhaf, etc., this power relation can introduce cycles. For this reason the function
<code>cpMajorityComparison()</code> and <code>cpMajorityComparisonScore()</code> only offers direct comparisons between two elements
and not a ranking of all players. See the other CP-majority based functions that offer a way to rank all players.
</p>


<h3>Value</h3>

<p><code>cpMajorityComparison()</code> returns a list with elements described in the details.
</p>
<p><code>cpMajorityComparisonScore()</code> returns a vector of two numbers, a positive number of coalitions where <code>e1</code> beats <code>e2</code>
(<code class="reqn">d_{ij}(\succsim)</code>), and a negative number of coalitions where <code>e1</code> is beaten by <code>e2</code> (<code class="reqn">-d_{ji}(\succsim)</code>).
</p>


<h3>References</h3>

<p>Haret A, Khani H, Moretti S, Öztürk M (2018).
“Ceteris paribus majority for social ranking.”
In <em>27th International Joint Conference on Artificial Intelligence (IJCAI-ECAI-18)</em>, 303–309.
</p>
<p>Fayard N, Escoffier MÖ (2018).
“Ordinal Social ranking: simulation for CP-majority rule.”
In <em>DA2PL'2018 (From Multiple Criteria Decision Aid to Preference Learning)</em>.
</p>


<h3>See Also</h3>

<p>Other CP-majority based functions: 
<code>copelandScores()</code>,
<code>kramerSimpsonScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("ac &gt; (a ~ b) &gt; (c ~ bc)")

scores &lt;- cpMajorityComparison(pr, "a", "b")
scores
# a &gt; b
# D_ab = {c, {}}
# D_ba = {{}}
# Score of a = 2
# Score of b = 1

stopifnot(scores$e1$name == "a")
stopifnot(scores$e2$name == "b")
stopifnot(scores$e1$score == 2)
stopifnot(scores$e2$score == 1)
stopifnot(scores$e1$score == length(scores$e1$winningCoalitions))
stopifnot(scores$e2$score == length(scores$e2$winningCoalitions))

# get tuples with coalitions S in 2^(N - {i,j})
emptySetTuple &lt;- Filter(function(x) identical(x$coalition, c()), scores$tuples)[[1]]
playerCTuple  &lt;- Filter(function(x) identical(x$coalition, "c"), scores$tuples)[[1]]

# because {}u{a} ~ {}u{b}, there is no winner
stopifnot(is.null(emptySetTuple$winner))
stopifnot(emptySetTuple$e1 == emptySetTuple$e2)

# because {c}u{a} &gt; {c}u{b}, player "a" gets the score
stopifnot(playerCTuple$winner == "a")
stopifnot(playerCTuple$e1 &lt; playerCTuple$e2)
stopifnot(playerCTuple$e1 == 1L)
stopifnot(playerCTuple$e2 == 3L)

cpMajorityComparisonScore(pr, "a", "b") # c(1,0)
cpMajorityComparisonScore(pr, "b", "a") # c(0,-1)

</code></pre>


</div>