<div class="container">

<table style="width: 100%;"><tr>
<td>sk_sub_find</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find complete regular sub-grids in a sk grid object</h2>

<h3>Description</h3>

<p>If a sk grid <code>g</code> has missing values (<code>NA</code>s) but the set of non-<code>NA</code> points form a
complete (regular) sub-grid, this function finds its grid lines, resolution, and
dimensions. If no eligible sub-grids are found, the function returns <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_sub_find(g, gdim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>logical vector, sk grid, or any grid object accepted by <code>sk</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gdim</code></td>
<td>
<p>integer vector, the grid dimensions (in order 'y', 'x')</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A sub-grid is only eligible if it contains ALL of the non-<code>NA</code> points in <code>g</code> and none
of the <code>NA</code>s. For example if a single point missing from the sub-grid, or a single non-<code>NA</code>
point lies outside the sub-grid, the function will fail to detect any sub-grids and return
<code>NULL</code>. If no points are <code>NA</code>, the function returns indices for the full grid.
</p>
<p>The returned list contains the following named elements:
</p>

<ul>
<li> <p><code>ij</code> the grid line numbers of the sub-grid with respect to <code>g</code>
</p>
</li>
<li> <p><code>res_scale</code> the resolution scaling factor (relative increase in grid line spacing of <code>g</code>)
</p>
</li>
<li> <p><code>gdim</code> the number of y and x grid lines in the sub-grid
</p>
</li>
</ul>
<p>As in <code>sk</code>, each of these is given in the 'y', 'x' order.
</p>
<p>Users can also pass the logical vector returned by <code>!is.na(g)</code> instead of <code>g</code>, in which
case argument <code>gdim</code> must also be specified. This can be much faster with large grids.
</p>


<h3>Value</h3>

<p><code>NULL</code> or list of information about the location and spacing of the sub-grid
within <code>g</code> (see details)
</p>


<h3>See Also</h3>

<p>Other indexing functions: 
<code>sk_mat2vec()</code>,
<code>sk_rescale()</code>,
<code>sk_sub_idx()</code>,
<code>sk_vec2mat()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# define a grid and example data
gdim = c(50, 53)
pars = utils::modifyList(sk_pars(gdim), list(eps=1e-12))
g = sk_sim(gdim, pars)
plot(g)

# define a super-grid containing the original data and make sure we can find it
g_big = sk_rescale(g, down=3)
plot(g_big)
print(sk_sub_find(g_big))

# define a smaller sub-grid at random
spacing = sapply(floor(gdim/10), function(x) 1 + sample.int(x, 1))
gdim_sg = sapply(floor( (gdim - 1) / spacing), function(x) sample.int(x, 1))
ij_first = sapply(gdim - ( spacing * gdim_sg ), function(x) sample.int(x, 1))

# find index of sub-grid lines and vectorized index of points
ij_sg = Map(function(idx, r, n) seq(idx, by=r, length.out=n), idx=ij_first, r=spacing, n=gdim_sg)
names(ij_sg) = c('i', 'j')
is_sg = sk_sub_idx(gdim, ij_sg, idx=FALSE)

# assign values to the sub-grid points
g_sub = sk(gdim)
g_sub[is_sg] = g[is_sg]
plot(g_sub, zlab='sub-grid')

# call the function and check for expected results
sub_result = sk_sub_find(g_sub)
all.equal(unname(sub_result[['gdim']]), gdim_sg)
all.equal(unname(sub_result[['ij']]), unname(ij_sg))

# sub grids with side length 1 have no spacing defined along that dimension
spacing[gdim_sg==1] = NA

# check consistency in spacing
all.equal(unname(sub_result[['res_scale']]), spacing)

# can also call on the vector and supply gdim separately
identical(sub_result, sk_sub_find(!is.na(g_sub), dim(g_sub)))

</code></pre>


</div>