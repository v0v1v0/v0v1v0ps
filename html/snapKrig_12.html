<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.sk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Operations group generics</h2>

<h3>Description</h3>

<p>Applies the operation point-wise to grid data values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sk'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>a "sk" object, vector or matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>a "sk" object, vector or matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function extracts the grid data <code>x[]</code> from all sk class arguments <code>x</code>, prior to
calling the default method. Before returning, the result is copied back to the grid object
of the second argument (or the first, if the second is not of class "sk").
</p>
<p>Note that the compatibility of the two arguments is not checked beyond matching
dimension (with vectors recycled as needed). This means for example you can do
operations on two grids representing different areas, so long as they have the
same <code>gdim</code>.
</p>


<h3>Value</h3>

<p>a "sk" object (a copy of <code>e1</code> or <code>e2</code>) with modified data values
</p>


<h3>Examples</h3>

<pre><code class="language-R">g = sk_validate(list(gval=stats::rnorm(4^2), gdim=4, gres=0.5))

# verify a trig identity using Ops and Math
summary( cos(g)^2 + sin(g)^2 )

# create a logical grid indicating points satisfying a condition
plot(g &lt; 0)
all( !(g &gt; 0) == (g[] &lt; 0) )

# test negation
all( (-g)[] == -(g[]) )

</code></pre>


</div>