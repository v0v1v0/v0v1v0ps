<div class="container">

<table style="width: 100%;"><tr>
<td>densityQuick.lpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Kernel Estimation of Intensity on a Network using a 2D Kernel
</h2>

<h3>Description</h3>

<p>Estimates the intensity of a point process on a linear network
using a two-dimensional smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">densityQuick.lpp(x, sigma=NULL, ...,
         kernel="gaussian",
         at = c("pixels", "points"),
         what = c("estimate", "se", "var"),
         leaveoneout = TRUE,
         diggle = FALSE,
         edge2D = FALSE,
         weights = NULL,
         positive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Smoothing bandwidth. A single numeric value,
in the same units as the coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>x</code>,
for example, <code>bw.scott.iso</code> or <code>bw.lppl</code>.
There is a sensible default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments passed to <code>as.mask</code>
to determine the pixel resolution, or arguments passed to
<code>sigma</code> if it is a function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>String (partially matched) specifying the smoothing kernel.
Current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>

<p>String (partially matched)
specifying whether to compute the intensity values
at a fine grid of locations on the network
(<code>at="pixels"</code>, the default) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>

<p>String (partially matched)
specifying whether to calculate the intensity estimate,
or its estimated standard error, or its estimated variance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diggle</code></td>
<td>

<p>Logical value specifying whether to use the ‘Diggle’
correction. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge2D</code></td>
<td>

<p>Logical value specifying whether to apply the usual
two-dimensional edge correction procedure to the numerator and
denominator of the estimate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional weights to be attached to the points.
A numeric vector, an <code>expression</code>, or a pixel image.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positive</code></td>
<td>

<p>Logical value indicating whether to force the resulting values to be
positive. Default is <code>FALSE</code> for the sake of speed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>x</code>
using a two-dimensional Gaussian kernel, as described in Rakshit et al (2019).
The result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
</p>
<p>Other techniques for kernel smoothing on a network are implemented in
<code>density.lpp</code>. The main advantages of using a
two-dimensional kernel are very fast computation and
insensitivity to changes in the network geometry. The main
disadvantage is that it ignores the connectivity of the network.
See Rakshit et al (2019) for further explanation.
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default),
a pixel image on the linear network (object of class <code>"linim"</code>).
</p>
<p>If <code>at="points"</code>, a numeric vector with one entry for each point
of <code>x</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Suman Rakshit and Tilman Davies
</p>


<h3>References</h3>

<p>Rakshit, S., Davies, T., Moradi, M., 
McSwiggan, G., Nair, G., Mateu, J. and Baddeley, A. (2019)
Fast kernel smoothing of point patterns on a large
network using 2D convolution.
<em>International Statistical Review</em> <b>87</b> (3) 531–556.
DOI: 10.1111/insr.12327.
</p>


<h3>See Also</h3>

<p><code>density.lpp</code>, the main function for density estimation
on a network.
</p>
<p><code>bw.scott</code>, <code>bw.scott.iso</code>,
<code>bw.lppl</code>for bandwidth selection.
</p>


<h3>Examples</h3>

<pre><code class="language-R">   X &lt;- unmark(chicago)
   plot(densityQuick.lpp(X, 500))
   plot(densityQuick.lpp(X, 500, diggle=TRUE))
   plot(densityQuick.lpp(X, bw.scott.iso))
   plot(densityQuick.lpp(X, 500, what="se"))
</code></pre>


</div>