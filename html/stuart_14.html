<div class="container">

<table style="width: 100%;"><tr>
<td>mmas</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subtest construction using the Max-Min-Ant-System</h2>

<h3>Description</h3>

<p>Construct subtests from a given pool of items using the classical Max-Min Ant-System (St√ºtzle, 1998). Allows for multiple constructs, occasions, and groups.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mmas(
  data,
  factor.structure,
  capacity = NULL,
  item.weights = NULL,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  burnin = 5,
  ants = 16,
  colonies = 256,
  evaporation = 0.95,
  alpha = 1,
  beta = 1,
  pheromones = NULL,
  heuristics = NULL,
  deposit = "ib",
  localization = "nodes",
  pbest = 0.005,
  tolerance = 0.5,
  schedule = "run",
  analysis.options = NULL,
  suppress.model = FALSE,
  seed = NULL,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item.weights</code></td>
<td>
<p>A placeholder. Currently all weights are assumed to be one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default) or 'Mplus'. Each option requires the software to be installed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code>detectCores</code> will be used. On Unix-y machines parallel processing is implemented via <code>mclapply</code>, on Windows machines it is realized via <code>parLapply</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See 'details' for... details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of colonies for which to use fixed objective function before switching to empirical objective. Ignored if <code>objective</code> is not of class <code>stuartEmpiricalObjetive</code>. Defaults to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ants</code></td>
<td>
<p>The number of ants per colony to be estimated. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colonies</code></td>
<td>
<p>The maximum number of colonies estimated since finding the latest global-best solution before aborting the process. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaporation</code></td>
<td>
<p>The evaporation coefficient. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The nonlinearity coefficient of the pheromone-trail's contribution to determining selection probabilities. Defaults to 1 (linear). Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The nonlinearity coefficient of the heuristics' contribution to determining selection probabilities. Defaults to 1 (linear). Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pheromones</code></td>
<td>
<p>A list of pheromones as created by <code>mmas</code>. This can be used to continue previous runs of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heuristics</code></td>
<td>
<p>An object of the class <code>stuartHeuristic</code> as provided by <code>heuristics</code> which contains heuristic information to be used in determining selection probabilities. If <code>NULL</code> (the default) selection probabilities are determined solely by the pheromones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deposit</code></td>
<td>
<p>Which deposit rule to use. Can be either 'ib' (the default) for an iteration-best deposit rule, or 'gb' for a global-best deposit rule.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localization</code></td>
<td>
<p>Which localization to use when depositing pheromones. Can be either 'nodes' (the default) for depositing pheromones on selected nodes or 'arcs' for depositing on selection arcs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbest</code></td>
<td>
<p>The desired overall probability of constructing the global-best solution when the algorithm convergels.  Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>The tolerance of imprecision when comparing the pheromones to the upper and lower limits. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>schedule</code></td>
<td>
<p>The counter which the scheduling of parameters pertains to. Can be either 'run' (the default), for a continuous schedule, 'colony', for a schedule that is restarted every time a new global best is found, or 'mixed' for a schedule that restarts its current phase every time a new global best is found. See 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A random seed for the generation of random samples. See <code>Random</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The pheromone function provided via <code>objective</code> is used to assess the quality of the solutions. These functions can contain any combination of the fit indices provided by the estimation software. When using Mplus these fit indices are 'rmsea', 'srmr', 'cfi', 'tli', 'chisq' (with 'df' and 'pvalue'), 'aic', 'bic', and 'abic'. With lavaan any fit index provided by <code>inspect</code> can be used. Additionally 'crel' provides an aggregate of composite reliabilites, 'rel' provides a vector or a list of reliability coefficients for the latent variables, 'con' provides an aggregate consistency estimate for MTMM analyses, and 'lvcor' provides a list of the latent variable correlation matrices. For more detailed objective functions 'lambda', 'theta', 'psi', 'alpha', and 'nu' provide the model-implied matrices. Per default a pheromone function using 'crel', 'rmsea', and 'srmr' is used. Please be aware that the <code>objective</code> must be a function with the required fit indices as (correctly named) arguments.
</p>
<p>Using model comparisons via the <code>comparisons</code> argument compares the target model to a model with one less degree of assumed invariance (e.g. if your target model contains strong invariance, the comparison model contain weak invariance). Adding comparisons will change the preset for the objective function to include model differences. With comparisons, a custom objective function (the recommended approach) can also include all model fit indices with a preceding <code>delta.</code> to indicate the difference in this index between the two models. If more than one type of comparison is used, the argument of the objective function should end in the type of comparison requested (e.g. <code>delta.cfi.group</code> to use the difference in CFI between the model comparison of invariance across groups).
</p>
<p>The scheduling of parameters is possible for the arguments <code>ants</code>, <code>colonies</code>, <code>evaporation</code>, <code>pbest</code>, <code>alpha</code>, <code>beta</code>, <code>tolerance</code>, and <code>deposit</code>. For all of these parameter scheduling is done when an array with two columns is provided. The first column of the array contains the timer, i.e. when to switch between parameter settings, the second column contains the values. The argument <code>schedule</code> can be used to select an absolute schedule (<code>schedule='run'</code>), a relative schedule which resets completely after a new global best is found (<code>schedule='colony'</code>), or a mixed version which resets the current phase of the schedule after a new global best is found (<code>schedule='mixed'</code>). When providing a parameter schedule for iterations 0, 3, and 10 using 'run' will result in a change after the third and the tenth iteration - irrespective of whether global best solutions were found. In contrast, using 'colony' will result in the first setting being used again once a new global best is found. This setting will then be used until iteration 3 (if no new best solution is found) before a switch occurs. If a new global best is found the setting will begin the sequence from the beginning. Using 'mixed' will result in the first setting being used until three consecutive iterations cannot produce a new global best. After this the second setting is used. If a new global best is found, the second setting is kept, but for the purpose of the schedule it is now iteration 3 again, meaning that the third setting will be used later than in a 'run' schedule.
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartOutput</code> for which specific <code>summary</code> and <code>plot</code> methods are available. The results are a list.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p>The called function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>software</code></td>
<td>
<p>The software used to fit the CFA models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A list of the ACO parameters used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analysis.options</code></td>
<td>
<p>A list of the additional arguments passed to the estimation software.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timer</code></td>
<td>
<p>An object of the class <code>proc_time</code> which contains the time used for the analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>A <code>data.frame</code> containing the optimization history.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_mat</code></td>
<td>
<p>A <code>list</code> of matrices (e.g. lvcor) relevant to the estimation history, if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution</code></td>
<td>
<p>A list of matrices with the choices made in the global-best solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pheromones</code></td>
<td>
<p>A list of matrices with the pheromones of each choice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final</code></td>
<td>
<p>The results of the estimation of the global-best solution.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>References</h3>

<p>St√ºtzle, T. (1998). Local search algorithms for combinatorial problems: Analysis, improvements, and new applications. Unpublished doctoral dissertation. Darmstadt: Fachbereich Informatik, Universit√§t Darmstadt.
</p>


<h3>See Also</h3>

<p><code>bruteforce</code>, <code>gene</code>, <code>randomsamples</code>, <code>heuristics</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># MMAS in a simple situation
# requires lavaan
# number of cores set to 1 in all examples
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

# minimal example
sel &lt;- mmas(fairplayer, fs, 4, 
  colonies = 0, ants = 10,  # minimal runtime, remove for application
  seed = 55635, cores = 1)
summary(sel)


# longitudinal example
data(fairplayer)
fs &lt;- list(si1 = names(fairplayer)[83:92],
  si2 = names(fairplayer)[93:102],
  si3 = names(fairplayer)[103:112])

repe &lt;- list(si = c('si1', 'si2', 'si3'))

# change evaporation rate after 10 and 20 colonies
sel &lt;- mmas(fairplayer, fs, 4, 
  repeated.measures = repe, long.invariance = 'strong',
  evaporation = cbind(c(0, 10, 20), c(.95, .8, .5)),
  seed = 55635, cores = 1)


</code></pre>


</div>