<div class="container">

<table style="width: 100%;"><tr>
<td>subsetBins</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a SQM object containing only the requested bins, and the contigs and ORFs contained in them.</h2>

<h3>Description</h3>

<p>Create a SQM object containing only the requested bins, and the contigs and ORFs contained in them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">subsetBins(
  SQM,
  bins,
  trusted_functions_only = FALSE,
  ignore_unclassified_functions = FALSE,
  rescale_tpm = TRUE,
  rescale_copy_number = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SQM</code></td>
<td>
<p>SQM object to be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>character. Vector of bins to be selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trusted_functions_only</code></td>
<td>
<p>logical. If <code>TRUE</code>, only highly trusted functional annotations (best hit + best average) will be considered when generating aggregated function tables. If <code>FALSE</code>, best hit annotations will be used (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_unclassified_functions</code></td>
<td>
<p>logical. If <code>FALSE</code>, ORFs with no functional classification will be aggregated together into an "Unclassified" category. If <code>TRUE</code>, they will be ignored (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_tpm</code></td>
<td>
<p>logical. If <code>TRUE</code>, TPMs for KEGGs, COGs, and PFAMs will be recalculated (so that the TPMs in the subset actually add up to 1 million). Otherwise, per-function TPMs will be calculated by aggregating the TPMs of the ORFs annotated with that function, and will thus keep the scaling present in the parent object. By default it is set to <code>TRUE</code>, which means that the returned TPMs will be scaled <em>by million of reads of the selected bins</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_copy_number</code></td>
<td>
<p>logical. If <code>TRUE</code>, copy numbers with be recalculated using the RecA/RadA coverages in the subset. Otherwise, RecA/RadA coverages will be taken from the parent object. By default it is set to <code>TRUE</code>, which means that the returned copy numbers for each function will represent the average copy number of that function <em>per genome of the selected bins</em>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>SQM object containing only the requested bins.
</p>


<h3>See Also</h3>

<p><code>subsetContigs</code>, <code>subsetORFs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Hadza)
# Which are the most complete bins?
topBinNames = rownames(Hadza$bins$table)[order(Hadza$bins$table[,"Completeness"],
                                         decreasing=TRUE)][1:2]
# Subset with the most complete bin.
topBin = subsetBins(Hadza, topBinNames[1])
</code></pre>


</div>