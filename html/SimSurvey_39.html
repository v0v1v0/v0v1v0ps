<div class="container">

<table style="width: 100%;"><tr>
<td>sim_survey_parallel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate stratified random surveys using parallel computation</h2>

<h3>Description</h3>

<p>This function is a wrapper for <code>sim_survey</code> except it allows for
many more total iterations to be run than <code>sim_survey</code> before running
into RAM limitations. Unlike <code>test_surveys</code>, this function retains
the full details of the survey and it may therefore be more useful for testing
alternate approaches to a stratified analysis for obtaining survey indices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_survey_parallel(
  sim,
  n_sims = 1,
  n_loops = 100,
  cores = 1,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>Simulation from <code>sim_distribution</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sims</code></td>
<td>
<p>Number of times to simulate a survey over the simulated population.
Requesting a large number of simulations here may max out your RAM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_loops</code></td>
<td>
<p>Number of times to run the <code>sim_survey</code> function. Total
simulations run will be the product of <code>n_sims</code> and <code>n_loops</code>
arguments. Low numbers of <code>n_sims</code> and high numbers of <code>n_loops</code>
will be easier on RAM, but may be slower.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores to use in parallel. More cores should speed up the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>Print message on what to expect for duration?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>sim_survey</code>
</p>

<dl>
<dt><code>q</code></dt>
<dd>
<p>Closure, such as <code>sim_logistic</code>, for simulating catchability at age
(returned values must be between 0 and 1)</p>
</dd>
<dt><code>trawl_dim</code></dt>
<dd>
<p>Trawl width and distance (same units as grid)</p>
</dd>
<dt><code>resample_cells</code></dt>
<dd>
<p>Allow resampling of sampling units (grid cells)? Setting to TRUE may introduce bias
because depletion is imposed at the cell level.</p>
</dd>
<dt><code>binom_error</code></dt>
<dd>
<p>Impose binomial error? Setting to FALSE may introduce bias in stratified estimates
at older ages because of more frequent rounding to zero.</p>
</dd>
<dt><code>min_sets</code></dt>
<dd>
<p>Minimum number of sets per strat</p>
</dd>
<dt><code>set_den</code></dt>
<dd>
<p>Set density (number of sets per grid unit squared). WARNING:
may return an error if <code>set_den</code> is high and
<code>resample_cells = FALSE</code> because the number of sets allocated may
exceed the number of cells in a strata.</p>
</dd>
<dt><code>lengths_cap</code></dt>
<dd>
<p>Maximum number of lengths measured per set</p>
</dd>
<dt><code>ages_cap</code></dt>
<dd>
<p>If <code>age_sampling = "stratified"</code>, this cap represents the maximum
number of ages to sample per length group (defined using the <code>age_length_group</code>
argument) per division or strat (defined using the <code>age_space_group</code> argument)
per year. If <code>age_sampling = "random"</code>, it is the maximum number of ages to sample
from measured fish per set.</p>
</dd>
<dt><code>age_sampling</code></dt>
<dd>
<p>Should age sampling be "stratified" (default) or "random"?</p>
</dd>
<dt><code>age_length_group</code></dt>
<dd>
<p>Numeric value indicating the size of the length bins for stratified
age sampling. Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>age_space_group</code></dt>
<dd>
<p>Should age sampling occur at the "division" (default), "strat" or "set" spatial scale?
That is, age sampling can be spread across each "division", "strat" or "set"
in each year to a maximum number within each length bin (cap is defined using
the <code>age_cap</code> argument). Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>custom_sets</code></dt>
<dd>
<p>Supply an object of the same structure as returned by <code>sim_sets</code> which
specifies a custom series of set locations to be sampled. Set locations are
automated if <code>custom_sets = NULL</code>.</p>
</dd>
<dt><code>light</code></dt>
<dd>
<p>Drop some objects from the output to keep object size low?</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sim_survey</code> is hard-wired here to be "light" to minimize object size.
</p>


<h3>Value</h3>

<p>Returns an object of the same structure as <code>sim_survey</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

## This call runs a total of 25 simulations of the same survey over
## the same population (Note: total number of simulations are low to
## decrease computation time for the example)
sim &lt;- sim_abundance(ages = 1:20, years = 1:5) %&gt;%
           sim_distribution(grid = make_grid(res = c(10, 10))) %&gt;%
           sim_survey_parallel(n_sims = 5, n_loops = 5, cores = 1,
                               q = sim_logistic(k = 2, x0 = 3),
                               quiet = FALSE)



</code></pre>


</div>