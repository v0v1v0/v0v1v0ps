<div class="container">

<table style="width: 100%;"><tr>
<td>smoothSurvReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regression for a Survival Model with Smoothed Error Distribution
</h2>

<h3>Description</h3>

<p>Regression for a survival model. These are all
time-transformed location models, with the most useful case being the
accelerated failure models that use a log transformation.
Error distribution is assumed to be a mixture of G-splines.
Parameters are estimated by the penalized maximum likelihood
method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smoothSurvReg(formula = formula(data), logscale = ~1, 
   data = parent.frame(), subset, na.action = na.fail,
   init.beta, init.logscale, init.c, init.dist = "best",
   update.init = TRUE, aic = TRUE, lambda = exp(2:(-9)),
   model = FALSE, control = smoothSurvReg.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A formula expression as for other regression models.
See the documentation for <code>lm</code> and <code>formula</code> for details.
Use <code>Surv</code> on the left hand side of the formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logscale</code></td>
<td>

<p>A formula expression to determine a possible dependence of the
log-scale on covariates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Optional data frame in which to interpret the variables occurring in the
formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>Subset of the observations to be used in the fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>Function to be used to handle any NAs in the data. It's default
value is <code>na.fail</code>. It is not recommended to change it in the
case when <code>logscale</code> depends on covariates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.beta</code></td>
<td>

<p>Optional vector of the initial values of the regression parameter <code class="reqn">\beta</code>
(intercept and regression itself).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.logscale</code></td>
<td>

<p>Optional value of the initial value of the parameters that
determines the log-scale parameter <code class="reqn">\log(\sigma)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.c</code></td>
<td>

<p>Optional vector of the initial values for the G-spline
coefficients c, all values must lie between 0 and 1
and must sum up to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.dist</code></td>
<td>

<p>A character string specifying the distribution used by <code>survreg</code>
to find the initial values for parameters (if not given by the user).
It is assumed to name <code>"best"</code> or an
element from <code>survreg.distributions</code>. These include
<code>"weibull"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"logistic"</code>, <code>"lognormal"</code> and <code>"loglogistic"</code>.
If "best" is specified one of <code>"lognormal"</code>,
<code>"weibull"</code> and <code>"loglogistic"</code> giving the highest
likelihood is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.init</code></td>
<td>

<p>If TRUE, the initial values are updated during the grid search for the lambda
parameter giving the optimal AIC. Otherwise, fits with all lambdas during the
grid search start with same initials determine at the beginning either
from the values of <code>init.beta, init.scale, init.c</code> or from the initial
<code>survreg</code> fit as determined by the parameter
<code>init.dist</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>

<p>If TRUE the optimal value of the tuning parameter <code class="reqn">\lambda</code>
is determined via a grid search through the values specified
by the parameter <code>lambda</code>. If FALSE, only the model with
<code class="reqn">\lambda = </code> <code>lambda[1]</code> is fitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A grid of values of the tuning parameter <code class="reqn">\lambda</code> searched
for the optimal value if <code>aic</code> = TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>If TRUE, the model frame is returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>A list of control values, in the format producted by <code>smoothSurvReg.control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments which will be passed to <code>smoothSurvReg.control</code>. See its help
page for more options to control the fit and for the possibility to fix some values
and not to estimate them.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Read the papers referred below.
</p>
<p>There is a slight difference in the definition of the penalty used by the R function compared
to what is written in the paper.
The penalized log-likelihood given in the paper has a form
</p>
<p style="text-align: center;"><code class="reqn">\ell_P(\theta) = \ell(\theta) - \frac{\lambda}{2}\sum_{j=m+1}^g(\Delta^m a_j)^2,</code>
</p>

<p>while the penalized log-likelihood used in the R function multiplies the tuning parameter
<code class="reqn">\lambda</code> given by <code>lambda</code> by a sample size <code class="reqn">n</code> to keep default values
more or less useful for samples of different sizes. So that the penalized log-likelihood
which is maximized by the R function has the form
</p>
<p style="text-align: center;"><code class="reqn">\ell_P(\theta) = \ell(\theta) - \frac{\lambda\cdot n}{2}\sum_{j=m+1}^g(\Delta^m a_j)^2.</code>
</p>



<h3>Value</h3>

<p>An object of class <code>smoothSurvReg</code> is returned.
See <code>smoothSurvReg.object</code> for details.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A., Lesaffre, E., and Hilton, J. F. (2005).
Accelerated failure time model for arbitrarily censored data with smoothed error distribution. 
<em>Journal of Computational and Graphical Statistics</em>, <b>14</b>,
726–745.
</p>
<p>Lesaffre, E., Komárek, A., and Declerck, D. (2005).
An overview of methods for interval-censored data with an emphasis on applications in dentistry.
<em>Statistical Methods in Medical Research</em>, <b>14</b>, 
539–552.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">##### EXAMPLE 1:  Common scale
##### ========================
### We generate interval censored data and fit a model with few artificial covariates
set.seed(221913282)
x1 &lt;- rbinom(50, 1, 0.4)                                         ## binary covariate
x2 &lt;- rnorm(50, 180, 10)                                         ## continuous covariate
y1 &lt;- 0.5*x1 - 0.01*x2 + 0.005 *x1*x2 + 1.5*rnorm(50, 0, 1)      ## generate log(T), left limit
t1 &lt;- exp(y1)                                                    ## left limit of the survival time
t2 &lt;- t1 + rgamma(50, 1, 1)                                      ## right limit of the survival time
surv &lt;- Surv(t1, t2, type = "interval2")                         ## survival object

## Fit the model with an interaction
fit1 &lt;- smoothSurvReg(surv ~ x1 * x2, logscale = ~1, info = FALSE, lambda = exp(2:(-1)))

## Print the summary information
summary(fit1, spline = TRUE)

## Plot the fitted error distribution
plot(fit1)

## Plot the fitted error distribution with its components
plot(fit1, components = TRUE)

## Plot the cumulative distribution function corresponding to the error density
survfit(fit1, cdf = TRUE)

## Plot survivor curves for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
survfit(fit1, cov = cov)

## Plot hazard curves for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
hazard(fit1, cov = cov)

## Plot densities for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
fdensity(fit1, cov = cov)

## Compute estimates expectations of survival times for persons with
## (x1, x2) = (0, 180), (1, 180), (0, 190), (1, 190), (0, 200), (1, 200)
## and estimates of a difference of these expectations:
## T(0, 180) - T(1, 180), T(0, 190) - T(1, 190), T(0, 200) - T(1, 200),
cov1 &lt;- matrix(c(0, 180, 0,   0, 190, 0,   0, 200, 0), ncol = 3, byrow = TRUE)
cov2 &lt;- matrix(c(1, 180, 180,   1, 190, 190,   1, 200, 200), ncol = 3, byrow = TRUE)
print(estimTdiff(fit1, cov1 = cov1, cov2 = cov2))


##### EXAMPLE 2:  Scale depends on covariates
##### =======================================
### We generate interval censored data and fit a model with few artificial covariates
set.seed(221913282)
x1 &lt;- rbinom(50, 1, 0.4)                                        ## binary covariate
x2 &lt;- rnorm(50, 180, 10)                                        ## continuous covariate
x3 &lt;- runif(50, 0, 1)                                           ## covariate for the scale parameter
logscale &lt;- 1 + x3
scale &lt;- exp(logscale)
y1 &lt;- 0.5*x1 - 0.01*x2 + 0.005 *x1*x2 + scale*rnorm(50, 0, 1)    ## generate log(T), left limit
t1 &lt;- exp(y1)                                                    ## left limit of the survival time
t2 &lt;- t1 + rgamma(50, 1, 1)                                      ## right limit of the survival time
surv &lt;- Surv(t1, t2, type = "interval2")                         ## survival object

## Fit the model with an interaction
fit2 &lt;- smoothSurvReg(surv ~ x1 * x2, logscale = ~x3, info = FALSE, lambda = exp(2:(-1)))

## Print the summary information
summary(fit2, spline = TRUE)

## Plot the fitted error distribution
plot(fit2)

## Plot the fitted error distribution with its components
plot(fit2, components = TRUE)

## Plot survivor curves for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
survfit(fit2, cov = cov, logscale.cov = logscale.cov)

## Plot hazard curves for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
hazard(fit2, cov = cov, logscale.cov=c(0.8, 0.9))

## Plot densities for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
fdensity(fit2, cov = cov, logscale.cov = logscale.cov)


## More involved examples can be found in script files
## used to perform analyses  and draw pictures 
## presented in above mentioned references.
## These scripts and some additional files can be found as *.tar.gz files
## in the /inst/doc directory of this package.
##
</code></pre>


</div>