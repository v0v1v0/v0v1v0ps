<div class="container">

<table style="width: 100%;"><tr>
<td>unstack2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Unstack one Set of Variables from Long to Wide</h2>

<h3>Description</h3>

<p><code>unstack2</code> converts one set of variables in a data.frame from long to wide format.
(If you want to convert multiple sets of variables from long to wide, see
<code>reshape</code>.) It is a modified version of <code>unstack</code> that 1) requires a
column for the rownames of the data.frame (or equivalently an id column with
unique values for each row in the wide format) before it was stacked, 2) can
retain additional columns not being unstacked, and 3) can order by rownames
original positions rather than their alphanumerical order.
</p>


<h3>Usage</h3>

<pre><code class="language-R">unstack2(
  data,
  rownames.nm = "row_names",
  vrbnames.nm = "vrb_names",
  el.nm = "el",
  keep.nm = pick(x = names(data), val = c(rownames.nm, vrbnames.nm, el.nm), not = TRUE),
  add.missing = TRUE,
  rownamesAsColumn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.frame of data containing stacked variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in
<code>data</code> for whom its unique values correspond to the rows in the return object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vrbnames.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in
<code>`data`</code> that contains the names of the variables to be unstacked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>el.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in <code>data</code>
containing the elements from the variable to be unstacked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.nm</code></td>
<td>
<p>optional argument containing a character vector of colnames from
<code>data</code> specifying the additional columns to be included in the return object.
The default is all the other columns in the data.frame besides <code>rownames.nm</code>,
<code>vrbnames.nm</code>, and <code>el.nm</code>. If NULL, then no additional columns are retained.
The <code>keep.nm</code> columns will be the last (aka most right) columns in the return object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.missing</code></td>
<td>
<p>logical vector of length 1 specifying whether missing values
should be added when unstacking. This will occur if there are unequal number of
rows for each variable in the set. If FALSE, an error will be returned when
there are an unequal number of rows and missing values would need to be added
to create the returned data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownamesAsColumn</code></td>
<td>
<p>logical vector of length 1 specifying whether the unique
values in <code>rownames.nm</code> column should be a column in the return object (TRUE)
or the rownames of the return object (FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>unstack2</code> is also very similar to <code>reshape::cast.data.frame</code>. The
differences are that it 1) can return the rownames as rownames of the returned
data.frame rather than an id column, 2) can retain additional columns not being
unstacked, and 3) can order by rownames original positions rather than the variable
names being stacked call order.
</p>


<h3>Value</h3>

<p>data.frame with nrow = <code>length(unique(data[[rownames.nm]]))</code> from
unstacking the elements of <code>el.nm</code> alongside one another. New columns are
created for each unique value in <code>vrbnames.nm</code> as well as columns for any
colnames additional specified by <code>keep.nm</code>. If <code>rownamesAsColumn</code> = TRUE,
then the first column is the unique values in <code>rownames.nm</code>; otherwise,
they are the rownames of the return object (default).
</p>


<h3>See Also</h3>

<p><code>stack2</code>
<code>unstack</code>
<code>cast</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# ordered by rownames
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), order.by.rownames = TRUE)
x &lt;- unstack2(stacked)
# ordered by vrbnames
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), order.by.rownames = FALSE)
y &lt;- unstack2(stacked)
identical(x, y)

# rownames as a column
z &lt;- unstack2(data = stacked, rownamesAsColumn = TRUE)

# compare to utils:::unstack.data.frame and reshape::cast
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"))
x &lt;- unstack(x = stacked, form = el ~ vrb_names) # automatically sorts the colnames alphabetically
y &lt;- reshape::cast(data = stacked, formula = row_names ~ vrb_names,
   value = "el") # automatically sorts the rownames alphabetically
z &lt;- unstack2(stacked) # is able to keep additional variables
head(x); head(y); head(z)

# unequal number of rows for each unique value in `data`[[`vrbnames.nm`]]
# this can occur if you are using unstack2 without having called stack2 right before
row_keep &lt;- sample(1:nrow(stacked), size = nrow(stacked) / 2)
stacked_rm &lt;- stacked[row_keep, ]
unstack2(data = stacked_rm, rownames.nm = "row_names", vrbnames.nm = "vrb_names", el.nm = "el")
## Not run:  # error when `add.missing` = FALSE
   unstack2(data = stacked_rm, rownames.nm = "row_names", vrbnames.nm = "vrb_names",
      el.nm = "el", add.missing = FALSE)

## End(Not run)

</code></pre>


</div>