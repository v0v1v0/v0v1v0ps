<div class="container">

<table style="width: 100%;"><tr>
<td>bws3.response</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generating artificial responses to Case 3 best-worst scaling questions
</h2>

<h3>Description</h3>

<p>This function synthesizes responses to Case 3 best-worst scaling (BWS) questions on the basis of a maximum difference model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bws3.response(design, categorical.attributes = NULL, 
  continuous.attributes = NULL, asc = NULL, common = NULL,
  optout = FALSE, b, n, detail = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>

<p>An object of the S3 class <code>"cedes"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categorical.attributes</code></td>
<td>

<p>A vector containing the names of the attributes that are treated as dummy-coded variables in the model. If there are no categorical variables, it is set as <code>NULL</code> (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous.attributes</code></td>
<td>

<p>A vector containing the names of the attributes that are treated as continuous variables in the model. If there are no continuous variables, it is set as <code>NULL</code> (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asc</code></td>
<td>

<p>A vector containing binary values, which takes the value of 1 when an alternative specific constant (ASC) is included in the utility function of an alternative and 0 otherwise. The <code class="reqn">i</code>-th element in the vector corresponds to the <code class="reqn">i</code>-th alternative. If there are no ASCs, it is set as <code>NULL</code> (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>

<p>A named vector containing a fixed combination of levels corresponding to a common alternative (base/reference) in the choice sets. If the common alternative is an opt-out (no choice) option, use the argument <code>optout</code> instead. If there is no common option, it is set as <code>NULL</code> (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optout</code></td>
<td>

<p>A logical variable describing whether the opt-out option is included in the BWS questions. If <code>TRUE</code> (default), the opt-out option is included; if <code>FALSE</code>, it is not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>

<p>A vector containing parameters of independent variables in the model. The vector is used to calculate utilities for alternatives.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>An integer value showing the number of respondents in the resultant dataset.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>

<p>A logical variable: if <code>TRUE</code>, the dataset is returned in a detailed format; and if <code>FALSE</code> (default), the dataset is returned in a simple format.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>Seed for a random number generator.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function synthesizes responses to Case 3 BWS questions on the basis of a maximum difference model. The model assumes that an alternative consists of <code class="reqn">k</code> attribute-levels, and that <code class="reqn">m</code> alternatives exist in a choice set (a question). The number of possible pairs where alternative <code class="reqn">i</code> is selected as the best and alternative <code class="reqn">j</code> is selected as the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">m</code> alternatives is given by <code class="reqn">m \times (m - 1)</code>. The model also assumes that the respondents select alternative <code class="reqn">i</code> as the best and alternative <code class="reqn">j</code> as the worst because the difference in utility between alternatives <code class="reqn">i</code> and <code class="reqn">j</code> is the highest among all of the <code class="reqn">m \times (m - 1)</code> differences in utility. The systematic component of the utility is assumed to be a linear additive function of the attribute and/or level variables. If the error component of the utility is assumed to be an independently, identically distributed type I extreme value, the probability of selecting alternative <code class="reqn">i</code> as the best and alternative <code class="reqn">j</code> as the worst is expressed as a conditional logit model.
</p>
<p>Given the parameter values assigned to the argument <code>b</code>, the choice sets assigned to the argument <code>design</code>, and the classifications of attributes (categorical or continuous) assigned to the arguments <code>categorical.attributes</code> and/or <code>continuous.attributes</code>, the function <code>bws3.response</code> calculates the utility for the alternatives. The parameter values assigned to the argument <code>b</code> are set as a numerical vector where the elements correspond to the parameters of attribute and/or level variables. As an example, assume that three attributes A, B, and C are the first, second, and third continuous attribute, respectively, in alternatives, and their corresponding attribute variables <code class="reqn">X_{A}</code>, <code class="reqn">X_{B}</code>, and <code class="reqn">X_{C}</code> have parameter values of <code class="reqn">0.1</code>, <code class="reqn">0.4</code>, and <code class="reqn">-0.5</code>, respectively. A vector assigned to the argument <code>b</code> is <code>c(0.1, 0.4, -0.5)</code>. As another example, assume that the three attributes A, B, and C are categorical attributes with three levels each (e.g., levels A1, A2, and A3 for attribute A) and that the first level for each attribute (i.e., A1, B1, and C1) is treated as the base (reference) level. If the parameters for the dummy-coded level variables corresponding to levels A2, A3, B2, B3, C2, and C3 are <code class="reqn">0.2</code>, <code class="reqn">0.4</code>, <code class="reqn">0.4</code>, <code class="reqn">0.8</code>, <code class="reqn">-0.7</code>, and <code class="reqn">-1.4</code>, respectively, a vector assigned to the argument <code>b</code> is given as <code>c(0, 0.2, 0.4, 0, 0.4, 0.8, 0, -0.7, -1.4)</code>, where the first, fourth, and seventh elements correspond to the reference level for each attribute, and thus have a value of 0. After calculating the utility values (by adding the calculated values of the systematic component of the utility and random numbers generated from a type I extreme value distribution), the function <code>bws3.response</code> finds the pair with the highest difference in utility from the <code class="reqn">m \times (m - 1)</code> differences in utility.
</p>
<p>If the systematic component of the utility includes ASCs, the argument <code>asc</code> is set: the <code class="reqn">i</code>-th element of a binary vector assigned to the argument <code>asc</code> takes a value of 1 if the <code class="reqn">i</code>-th alternative has an ASC, and takes a value of 0 otherwise. As an example, if a choice set consists of four alternatives and only the fourth alternative has an ASC, a vector <code>c(0, 0, 0, 1)</code> is assigned to the argument <code>asc</code>. Although this creates four ASCs (i.e., <code>ASC1</code>, <code>ASC2</code>, <code>ASC3</code>, and <code>ASC4</code>) corresponding to the four alternatives in the resultant dataset, only the fourth ASC (<code>ASC4</code>) is used in the analysis (the remaining <code>ASC1</code>, <code>ASC2</code>, and <code>ASC3</code> are ignored). As another example, if a choice set consists of three alternatives and the first and second alternatives have ASCs, a vector <code>c(1, 1, 0)</code> is assigned to the argument <code>asc</code>: this results in three ASCs in the resultant dataset; only the first and second ASCs (<code>ASC1</code> and <code>ASC2</code>) are used in the analysis.
</p>
<p>If BWS questions include an opt-out option, the argument <code>optout</code> is set as <code>TRUE</code>; otherwise it is set as <code>FALSE</code>. The function <code>bws3.response</code> assumes that the opt-out option is the last alternative in each choice set and that all of the attribute and/or level variables associated with the opt-out option have a value of 0.
</p>


<h3>Value</h3>

<p>This function returns a data frame that contains synthesized responses to Case 3 BWS questions, in either a detailed or a simple format. The detailed format dataset contains the following variables, as well as independent variables according to the arguments <code>categorical.attributes</code> and/or <code>continuous.attributes</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BLOCK</code></td>
<td>

<p>A serial number of blocks in the choice sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>QES</code></td>
<td>

<p>A serial number of questions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BEST</code></td>
<td>

<p>An alternative number treated as the best in the possible pairs of the best and worst alternatives.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WORST</code></td>
<td>

<p>An alternative number treated as the worst in the possible pairs of the best and worst alternatives.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PAIR</code></td>
<td>

<p>A serial number of possible pairs of the best and worst alternatives for each question.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RES</code></td>
<td>

<p>Responses to BWS questions, taking the value of 1 if a possible pair of the best and worst alternative is selected by the synthesized respondents and 0 otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STR</code></td>
<td>

<p>A stratification variable used to identify each combination of respondent and question.
</p>
</td>
</tr>
</table>
<p>The simple format dataset contains the following variables.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BLOCK</code></td>
<td>

<p>A serial number of blocks in the choice sets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bi</code></td>
<td>

<p>A variable describing the alternative number that is selected as the best in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>B1</code> for the first question, <code>B2</code> for the second question, and <code>B3</code> for the third question).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wi</code></td>
<td>

<p>A variable describing the alternative number that is selected as the worst in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>W1</code> for the first question, <code>W2</code> for the second question, and <code>W3</code> for the third question).
</p>
</td>
</tr>
</table>
<p>The detailed format dataset includes a dependent variable and independent variables for the analysis, and thus is available for discrete choice analysis functions such as the function <code>clogit</code> in the <b>survival</b> package. On the other hand, the simple format dataset only contains variables that correspond to responses to BWS questions, as well as <code>id</code> and <code>BLOCK</code> variables. It must be converted using the function <code>bws3.dataset</code> in the package for the analysis. For details, see the Examples section.
</p>


<h3>See Also</h3>

<p><code>support.BWS3-package</code>, <code>rotation.design</code>, <code>clogit</code>, <code>oa.design</code>, <code>find.BIB</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The following lines of code synthesize responses to Case 3 BWS questions,
# return them in detailed and simple format, and then fit the models using
# the function clogit in the survival package. The choice sets include 
# three alternatives that are expressed by three attributes (A, B, and C)
# with three levels each. The function bws3.design creates the choice sets
# from a three-level fractional factorial design with 3 factors that is
# generated using the function oa.design in the DoE.base package and a BIBD
# with 9 treatments, 12 blocks, and size 3 that is generated using
# the function find.BIB in the crossdes package. The systematic component
# of the utility for alternatives where all of the three attributes are
# treated as categorical attributes is the same as that explained in 
# the Details section.

## Not run: 
# Load packages
library(DoE.base)
library(survival)
library(crossdes)

# Create design matrix
set.seed(987)
bibd &lt;- find.BIB(trt = 9, b = 12, k = 3)
isGYD(bibd)
oa &lt;- oa.design(nl = c(3, 3, 3), randomize = FALSE)
atr &lt;- list(
  A = c("A1", "A2", "A3"), B = c("B1", "B2", "B3"),
  C = c("C1", "C2", "C3"))
dsgn &lt;- bws3.design(bibd = bibd, ffd = oa, attribute.levels = atr)

# Synthesize responses to Case 3 BWS questions 
param &lt;- c(0, 0.2, 0.4, 0, 0.4, 0.8, 0, -0.7, -1.4)
atr.names &lt;- c("A", "B", "C")
## dataset in detailed format
dat.detail &lt;- bws3.response(
  design = dsgn, b = param, n = 100,
  categorical.attributes = atr.names,
  detail = TRUE, seed = 987)
str(dat.detail)
## dataset in simple format
dat.simple &lt;- bws3.response(
  design = dsgn, b = param, n = 100,
  categorical.attributes = atr.names,
  detail = FALSE, seed = 987)
str(dat.simple)

# Convert dat.simple into dataset for the analysis
dat.simple.md &lt;- bws3.dataset(
  data = dat.simple,
  response = list(
    c("B1", "W1"), c("B2", "W2"), c("B3", "W3"),
    c("B4", "W4"), c("B5", "W5"), c("B6", "W6"),
    c("B7", "W7"), c("B8", "W8"), c("B9", "W9"),
    c("B10", "W10"), c("B11", "W11"), c("B12", "W12")),
  choice.sets = dsgn,
  categorical.attributes = atr.names,
  model = "maxdiff")

# Fit conditional logit models
mf &lt;- RES ~ A2 + A3 + B2 + B3 + C2 + C3  + strata(STR)
out.detail &lt;- clogit(mf, dat.detail)
out.simple &lt;- clogit(mf, dat.simple.md)
out.simple
all.equal(coef(out.detail), coef(out.simple))

## End(Not run)
</code></pre>


</div>