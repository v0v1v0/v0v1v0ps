<div class="container">

<table style="width: 100%;"><tr>
<td>convolve.im</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convolution of Pixel Images</h2>

<h3>Description</h3>

<p>Computes the convolution of two pixel images.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> convolve.im(X, Y=X, ..., reflectX=FALSE, reflectY=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>Optional. Another pixel image.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reflectX,reflectY</code></td>
<td>

<p>Logical values specifying whether the images <code>X</code> and <code>Y</code>
(respectively) should be reflected in the origin before computing
the convolution.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <em>convolution</em> of two pixel images <code class="reqn">X</code> and <code class="reqn">Y</code> in the plane
is the function <code class="reqn">C(v)</code> defined for each vector <code class="reqn">v</code> as
</p>
<p style="text-align: center;"><code class="reqn">
    C(v) = \int X(u)Y(v-u)\, {\rm d}u
  </code>
</p>

<p>where the integral is
over all spatial locations <code class="reqn">u</code>, and where <code class="reqn">X(u)</code> and
<code class="reqn">Y(u)</code> denote the pixel values of <code class="reqn">X</code> and <code class="reqn">Y</code> respectively
at location <code class="reqn">u</code>.
</p>
<p>This command computes a discretised approximation to
the convolution, using the Fast Fourier Transform.
The return value is
another pixel image (object of class <code>"im"</code>) whose greyscale values
are values of the convolution.
</p>
<p>If <code>reflectX = TRUE</code> then the pixel image <code>X</code> is reflected
in the origin (see <code>reflect</code>)
before the convolution is computed, so that
<code>convolve.im(X,Y,reflectX=TRUE)</code> is mathematically
equivalent to <code>convolve.im(reflect(X), Y)</code>. (These two commands
are not exactly equivalent, because the reflection is performed
in the Fourier domain in the first command, and reflection is
performed in the spatial domain in the second command).
</p>
<p>Similarly if <code>reflectY = TRUE</code> then the pixel image <code>Y</code> is reflected
in the origin before the convolution is computed, so that
<code>convolve.im(X,Y,reflectY=TRUE)</code> is mathematically
equivalent to <code>convolve.im(X, reflect(Y))</code>.
</p>


<h3>Value</h3>

<p>A pixel image (an object of class <code>"im"</code>) representing the
convolution of <code>X</code> and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>imcov</code>,
<code>reflect</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  if(interactive()) {
    X &lt;- as.im(letterR)
    Y &lt;- as.im(square(1))
  } else {
    ## coarser image for testing
    X &lt;- as.im(letterR, dimyx=32)
    Y &lt;- as.im(square(1), dimyx=32)
  }
  plot(convolve.im(X, Y))
  plot(convolve.im(X, Y, reflectX=TRUE))
  plot(convolve.im(X))
</code></pre>


</div>