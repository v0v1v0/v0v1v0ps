<div class="container">

<table style="width: 100%;"><tr>
<td>3. Solve an Elastic-Net problem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coordinate Descent algorithm to solve Elastic-Net-type problems</h2>

<h3>Description</h3>

<p>Computes the entire Elastic-Net solution for the regression coefficients for all
values of the penalization parameter, via the Coordinate Descent (CD) algorithm (Friedman, 2007). It uses as inputs a variance matrix among predictors and a covariance vector between response and predictors
</p>


<h3>Usage</h3>

<pre><code class="language-R">solveEN(Sigma, Gamma, alpha = 1, lambda = NULL, nlambda = 100,
        lambda.min = .Machine$double.eps^0.5, lambda.max = NULL,
        common.lambda = TRUE, beta0 = NULL, nsup.max = NULL,
        scale = TRUE, sdx = NULL, tol = 1E-5, maxiter = 1000,
        mc.cores = 1L, save.at = NULL, fileID = NULL,
        precision.format = c("double","single"), sparse = FALSE,
        eps = .Machine$double.eps*100, verbose = FALSE)
        
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>(numeric matrix) Variance-covariance matrix of predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gamma</code></td>
<td>
<p>(numeric matrix) Covariance between response variable and predictors. If it contains more than one column, the algorithm is applied to each column separately as different response variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>(numeric vector) Penalization parameter sequence. Default is <code>lambda = NULL</code>, in this case a decreasing grid of
<code>'nlambda'</code> lambdas will be generated starting from a maximum equal to
</p>
<p style="text-align:center;font-family:courier">max(abs(Gamma)/alpha)</p>
<p>to a minimum equal to zero. If <code>alpha = 0</code> the grid is generated starting from a maximum equal to 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>(integer) Number of lambdas generated when <code>lambda = NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min, lambda.max</code></td>
<td>
<p>(numeric) Minimum and maximum value of lambda that are generated when <code>lambda = NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common.lambda</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether computing the coefficients for a grid of lambdas common to all columns of <code>Gamma</code>
or for a grid of lambdas specific to each column of <code>Gamma</code>. Default is <code>common.lambda = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>(numeric vector) Initial value for the regression coefficients that will be updated. If <code>beta0 = NULL</code> a vector of zeros will be considered. These values will be used as starting values for the first lambda value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(numeric) Value between 0 and 1 for the weights given to the L1 and L2-penalties</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to scale matrix <code>Sigma</code> for variables with unit variance and scale <code>Gamma</code> by the standard deviation (<code>sdx</code>) of the corresponding predictor
taken from the diagonal of <code>Sigma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdx</code></td>
<td>
<p>(numeric vector) Scaling factor that will be used to scale the regression coefficients. When <code>scale = TRUE</code> this scaling factor vector is set to the squared root of the diagonal of <code>Sigma</code>, otherwise a provided value is used assuming that <code>Sigma</code> and <code>Gamma</code> are scaled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>(numeric) Maximum error between two consecutive solutions of the CD algorithm to declare convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>(integer) Maximum number of iterations to run the CD algorithm at each lambda step before convergence is reached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsup.max</code></td>
<td>
<p>(integer) Maximum number of non-zero coefficients in the last solution.
Default <code>nsup.max = NULL</code> will calculate solutions for the entire lambda grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>(integer) Number of cores used. When <code>mc.cores</code> &gt; 1, the analysis is run in parallel for each column of <code>Gamma</code>. Default is <code>mc.cores = 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.at</code></td>
<td>
<p>(character) Path where regression coefficients are to be saved (this may include a prefix added to the files). Default <code>save.at = NULL</code> will no save the regression coefficients and they are returned in the output object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fileID</code></td>
<td>
<p>(character) Suffix added to the file name where regression coefficients are to be saved. Default <code>fileID = NULL</code> will automatically add sequential integers from 1 to the number of columns of <code>Gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.format</code></td>
<td>
<p>(character) Either 'single' or 'double' for numeric precision and memory occupancy (4 or 8 bytes, respectively) of the regression coefficients. This is only used when <code>save.at</code> is not <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether matrix <code>Sigma</code> is sparse with entries being zero or near-zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>(numeric) A numerical zero to determine if entries are near-zero. Default is the machine precision</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether printing progress</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Finds solutions for the regression coefficients in a linear model
</p>
<p style="text-align:center">y<sub>i</sub> = <b>x</b>'<sub>i</sub><b>β</b> + e<sub>i</sub></p>
<p>where
y<sub>i</sub> is the response for the i<sup>th</sup> observation,
<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>ip</sub>)'
is a vector of <code class="reqn">p</code> predictors assumed to have unit variance,
<b>β</b> = (β<sub>1</sub>,...,β<sub>p</sub>)'
is a vector of regression coefficients, and
e<sub>i</sub>
is a residual.
</p>
<p>The regression coefficients
<b>β</b>
are estimated as function of the variance matrix among
predictors (<b>Σ</b>) and the covariance vector between response and predictors (<b>Γ</b>) by minimizing the penalized mean squared error function
</p>
<p style="text-align:center">-<b>Γ</b>' <b>β</b> + 1/2 <b>β</b>' <b>Σ</b> <b>β</b> + λ J(<b>β</b>)</p>
<p>where λ
is the penalization parameter and
J(<b>β</b>)
is a penalty function given by
</p>
<p style="text-align:center">1/2(1-α)||<b>β</b>||<sub>2</sub><sup>2</sup> + α||<b>β</b>||<sub>1</sub></p>
<p>where 0 ≤ α ≤ 1, and
||<b>β</b>||<sub>1</sub> = ∑<sub>j=1</sub>|β<sub>j</sub>| and
||<b>β</b>||<sub>2</sub><sup>2</sup> = ∑<sub>j=1</sub>β<sub>j</sub><sup>2</sup> are the L1 and (squared) L2-norms, respectively.
</p>
<p>The "partial residual" excluding the contribution of the predictor
x<sub>ij</sub> is
</p>
<p style="text-align:center">e<sub>i</sub><sup>(j)</sup> = y<sub>i</sub> - <b>x</b>'<sub>i</sub><b>β</b> + x<sub>ij</sub>β<sub>j</sub></p>
<p>then the ordinary least-squares (OLS) coefficient of
x<sub>ij</sub>
on this residual is (up-to a constant)
</p>
<p style="text-align:center">β<sub>j</sub><sup>(ols)</sup> = Γ<sub>j</sub> - <b>Σ</b>'<sub>j</sub><b>β</b> + β<sub>j</sub></p>
<p>where
Γ<sub>j</sub>
is the j<sup>th</sup> element of
<b>Γ</b> and
<b>Σ</b><sub>j</sub>
is the j<sup>th</sup> column of the matrix
<b>Σ</b>.
</p>
<p>Coefficients are updated for each <code class="reqn">j=1,...,p</code> from their current value
β<sub>j</sub>
to a new value
β<sub>j</sub>(α,λ),
given α and
λ,
by "soft-thresholding" their OLS estimate until convergence as fully described in Friedman (2007).
</p>


<h3>Value</h3>

<p>Returns a list object containing the elements:
</p>

<ul>
<li> <p><code>lambda</code>: (vector) all the sequence of values of the penalty.
</p>
</li>
<li> <p><code>beta</code>: (matrix) regression coefficients for each predictor (in rows) associated to each value of the penalization parameter lambda (in columns).
</p>
</li>
<li> <p><code>nsup</code>: (vector) number of non-zero predictors associated to each value of lambda.
</p>
</li>
</ul>
<p>The returned object is of the class 'LASSO' for which methods <code>coef</code> and <code>fitted</code> exist. Function 'path.plot' can be also used
</p>


<h3>References</h3>

<p>Friedman J, Hastie T, Höfling H, Tibshirani R (2007). Pathwise coordinate optimization. <em>The Annals of Applied Statistics</em>, <b>1</b>(2), 302–332.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  require(SFSI)
  data(wheatHTP)
  
  y = as.vector(Y[,"E1"])  # Response variable
  X = scale(X_E1)          # Predictors

  # Training and testing sets
  tst = which(Y$trial %in% 1:10)
  trn = seq_along(y)[-tst]

  # Calculate covariances in training set
  XtX = var(X[trn,])
  Xty = cov(X[trn,],y[trn])
  
  # Run the penalized regression
  fm = solveEN(XtX,Xty,alpha=0.5,nlambda=100) 
  
  # Regression coefficients
  dim(coef(fm))
  dim(coef(fm, ilambda=50)) # Coefficients associated to the 50th lambda
  dim(coef(fm, nsup=25))    # Coefficients with around nsup=25 are non-zero

  # Predicted values
  yHat1 = predict(fm, X=X[trn,])  # training data
  yHat2 = predict(fm, X=X[tst,])  # testing data
  
  # Penalization vs correlation
  plot(-log(fm$lambda[-1]),cor(y[trn],yHat1[,-1]), main="training", type="l")
  plot(-log(fm$lambda[-1]),cor(y[tst],yHat2[,-1]), main="testing", type="l")
</code></pre>


</div>