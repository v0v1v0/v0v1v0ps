<div class="container">

<table style="width: 100%;"><tr>
<td>triTraining</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tri-training method</h2>

<h3>Description</h3>

<p>Tri-training is a semi-supervised learning algorithm with a co-training 
style. This algorithm trains three classifiers with the same learning scheme from a 
reduced set of labeled examples. For each iteration, an unlabeled example is labeled 
for a classifier if the other two classifiers agree on the labeling proposed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">triTraining(x, y, x.inst = TRUE, learner, learner.pars = NULL,
  pred = "predict", pred.pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A object that can be coerced as matrix. This object has two possible 
interpretations according to the value set in the <code>x.inst</code> argument:
a matrix with the training instances where each row represents a single instance
or a precomputed (distance or kernel) matrix between the training examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector with the labels of the training instances. In this vector 
the unlabeled instances are specified with the value <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.inst</code></td>
<td>
<p>A boolean value that indicates if <code>x</code> is or not an instance matrix.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>either a function or a string naming the function for 
training a supervised base classifier, using a set of instances
(or optionally a distance matrix) and it's corresponding classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner.pars</code></td>
<td>
<p>A list with additional parameters for the
<code>learner</code> function if necessary.
Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>either a function or a string naming the function for
predicting the probabilities per classes,
using the base classifiers trained with the <code>learner</code> function.
Default is <code>"predict"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.pars</code></td>
<td>
<p>A list with additional parameters for the
<code>pred</code> function if necessary.
Default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Tri-training initiates the self-labeling process by training three models from the 
original labeled set, using the <code>learner</code> function specified. 
In each iteration, the algorithm detects unlabeled examples on which two classifiers 
agree with the classification and includes these instances in the enlarged set of the 
third classifier under certain conditions. The generation of the final hypothesis is 
produced via the majority voting. The iteration process ends when no changes occur in 
any model during a complete iteration.
</p>


<h3>Value</h3>

<p>A list object of class "triTraining" containing:
</p>

<dl>
<dt>model</dt>
<dd>
<p>The final three base classifiers trained using the enlarged labeled set.</p>
</dd>
<dt>model.index</dt>
<dd>
<p>List of three vectors of indexes related to the training instances 
used per each classifier. These indexes are relative to the <code>y</code> argument.</p>
</dd>
<dt>instances.index</dt>
<dd>
<p>The indexes of all training instances used to
train the three models. These indexes include the initial labeled instances
and the newly labeled instances. These indexes are relative to the <code>y</code> argument.</p>
</dd>
<dt>model.index.map</dt>
<dd>
<p>List of three vectors with the same information in <code>model.index</code>
but the indexes are relative to <code>instances.index</code> vector.</p>
</dd>
<dt>classes</dt>
<dd>
<p>The levels of <code>y</code> factor.</p>
</dd>
<dt>pred</dt>
<dd>
<p>The function provided in the <code>pred</code> argument.</p>
</dd>
<dt>pred.pars</dt>
<dd>
<p>The list provided in the <code>pred.pars</code> argument.</p>
</dd>
<dt>x.inst</dt>
<dd>
<p>The value provided in the <code>x.inst</code> argument.</p>
</dd>
</dl>
<h3>References</h3>

<p>ZhiHua Zhou and Ming Li.<br><em>Tri-training: exploiting unlabeled data using three classifiers.</em><br>
IEEE Transactions on Knowledge and Data Engineering, 17(11):1529-1541, Nov 2005. ISSN 1041-4347. doi: 10.1109/TKDE.2005. 186.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(ssc)

## Load Wine data set
data(wine)

cls &lt;- which(colnames(wine) == "Wine")
x &lt;- wine[, -cls] # instances without classes
y &lt;- wine[, cls] # the classes
x &lt;- scale(x) # scale the attributes

## Prepare data
set.seed(20)
# Use 50% of instances for training
tra.idx &lt;- sample(x = length(y), size = ceiling(length(y) * 0.5))
xtrain &lt;- x[tra.idx,] # training instances
ytrain &lt;- y[tra.idx]  # classes of training instances
# Use 70% of train instances as unlabeled set
tra.na.idx &lt;- sample(x = length(tra.idx), size = ceiling(length(tra.idx) * 0.7))
ytrain[tra.na.idx] &lt;- NA # remove class information of unlabeled instances

# Use the other 50% of instances for inductive testing
tst.idx &lt;- setdiff(1:length(y), tra.idx)
xitest &lt;- x[tst.idx,] # testing instances
yitest &lt;- y[tst.idx] # classes of testing instances

## Example: Training from a set of instances with 1-NN as base classifier.
set.seed(1)
m1 &lt;- triTraining(x = xtrain, y = ytrain, 
                  learner = caret::knn3, 
                  learner.pars = list(k = 1),
                  pred = "predict")
pred1 &lt;- predict(m1, xitest)
table(pred1, yitest)

## Example: Training from a distance matrix with 1-NN as base classifier.
dtrain &lt;- proxy::dist(x = xtrain, method = "euclidean", by_rows = TRUE)
set.seed(1)
m2 &lt;- triTraining(x = dtrain, y = ytrain, x.inst = FALSE,
                  learner = ssc::oneNN, 
                  pred = "predict",
                  pred.pars = list(distance.weighting = "none"))
ditest &lt;- proxy::dist(x = xitest, y = xtrain[m2$instances.index,],
                      method = "euclidean", by_rows = TRUE)
pred2 &lt;- predict(m2, ditest)
table(pred2, yitest)

## Example: Training from a set of instances with SVM as base classifier.
learner &lt;- e1071::svm
learner.pars &lt;- list(type = "C-classification", kernel="radial", 
                     probability = TRUE, scale = TRUE)
pred &lt;- function(m, x){
  r &lt;- predict(m, x, probability = TRUE)
  prob &lt;- attr(r, "probabilities")
  prob
}
set.seed(1)
m3 &lt;- triTraining(x = xtrain, y = ytrain, 
                  learner = learner, 
                  learner.pars = learner.pars, 
                  pred = pred)
pred3 &lt;- predict(m3, xitest)
table(pred3, yitest)

## Example: Training from a set of instances with Naive-Bayes as base classifier.
set.seed(1)
m4 &lt;- triTraining(x = xtrain, y = ytrain, 
                  learner = function(x, y) e1071::naiveBayes(x, y), 
                  pred.pars = list(type = "raw"))
pred4 &lt;- predict(m4, xitest)
table(pred4, yitest)

## Example: Training from a set of instances with C5.0 as base classifier.
set.seed(1)
m5 &lt;- triTraining(x = xtrain, y = ytrain, 
                  learner = C50::C5.0, 
                  pred.pars = list(type = "prob"))
pred5 &lt;- predict(m5, xitest)
table(pred5, yitest)


</code></pre>


</div>