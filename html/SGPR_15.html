<div class="container">

<table style="width: 100%;"><tr>
<td>sgp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a sparse group regularized regression path</h2>

<h3>Description</h3>

<p>A function that determines the regularization paths for models with
sparse group penalties at a grid of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgp(
  X,
  y,
  group = 1:ncol(X),
  penalty = c("sgl", "sgs", "sgm", "sge"),
  alpha = 1/3,
  type = c("linear", "logit"),
  Z = NULL,
  nlambda = 100,
  lambda.min = {
     if (nrow(X) &gt; ncol(X)) 
         1e-04
     else 0.05
 },
  log.lambda = TRUE,
  lambdas,
  prec = 1e-04,
  ada_mult = 2,
  max.iter = 10000,
  standardize = TRUE,
  vargamma = ifelse(pvar == "scad" | penalty == "sgs", 4, 3),
  grgamma = ifelse(pgr == "scad" | penalty == "sgs", 4, 3),
  vartau = 1,
  grtau = 1,
  pvar = c("lasso", "scad", "mcp", "exp"),
  pgr = c("lasso", "scad", "mcp", "exp"),
  group.weight = rep(1, length(unique(group))),
  returnX = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The design matrix without intercept with the variables to be selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector indicating the group membership of each variable in X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>A string that specifies the sparse group penalty to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Tuning parameter for the mixture of penalties at group and variable level.
A value of 0 results in a selection at group level, a value of 1
results in a selection at variable level and everything in between
is bi-level selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A string indicating the type of regression model (linear or binomial).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The design matrix of the variables to be included in the model without penalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>An integer that specifies the length of the lambda sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>An integer multiplied by the maximum lambda to define the end of the lambda sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.lambda</code></td>
<td>
<p>A Boolean value that specifies whether the values of the lambda
sequence should be on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>A user supplied vector with values for lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>The convergence threshold for the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ada_mult</code></td>
<td>
<p>An integer that defines the multiplier for adjusting the convergence threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>The convergence threshold for the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>An integer that defines the multiplier for adjusting the convergence threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vargamma</code></td>
<td>
<p>An integer that defines the value of gamma for the penalty at the variable level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grgamma</code></td>
<td>
<p>An integer that specifies the value of gamma for the penalty at the group level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vartau</code></td>
<td>
<p>An integer that defines the value of tau for the penalty at the variable level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grtau</code></td>
<td>
<p>An integer that specifies the value of tau for the penalty at the group level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvar</code></td>
<td>
<p>A string that specifies the penalty used at the variable level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pgr</code></td>
<td>
<p>A string that specifies the penalty used at the group level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.weight</code></td>
<td>
<p>A vector specifying weights that are multiplied by the group
penalty to account for different group sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnX</code></td>
<td>
<p>A Boolean value that specifies whether standardized design matrix should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters of underlying basic functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two options are available for choosing a penalty. With the argument <code>penalty</code>,
the methods Sparse Group LASSO, Sparse Group SCAD, Sparse Group MCP and Sparse Group EP
can be selected with the abbreviations <code>sgl</code>, <code>sgs</code>, <code>sgm</code> and <code>sge</code>.
Alternatively, penalties can be combined additively with the arguments <code>pvar</code>
and <code>pgr</code>, where <code>pvar</code> is the penalty applied at the variable level and
<code>pgr</code> is the penalty applied at the group level. The options are <code>lasso</code>,
<code>scad</code>, <code>mcp</code> and <code>exp</code> for Least Absolute Shrinkage and Selection Operator,
Smoothly Clipped Absolute Deviation, Minimax Concave Penalty and Exponential Penalty.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>beta</dt>
<dd>
<p>A vector with estimated coefficients.</p>
</dd>
<dt>type</dt>
<dd>
<p>A string indicating the type of regression model (linear or binomial).</p>
</dd>
<dt>group</dt>
<dd>
<p>A vector indicating the group membership of the individual variables in X.</p>
</dd>
<dt>lambdas</dt>
<dd>
<p>The sequence of lambda values.</p>
</dd>
<dt>alpha</dt>
<dd>
<p>Tuning parameter for the mixture of penalties at group and variable level.</p>
</dd>
<dt>loss</dt>
<dd>
<p>A vector containing either the residual sum of squares (linear) or the negative log-likelihood (binomial).</p>
</dd>
<dt>prec</dt>
<dd>
<p>The convergence threshold used for each lambda.</p>
</dd>
<dt>n</dt>
<dd>
<p>Number of observations.</p>
</dd>
<dt>penalty</dt>
<dd>
<p>A string indicating the sparse group penalty used.</p>
</dd>
<dt>df</dt>
<dd>
<p>A vector of pseudo degrees of freedom for each lambda.</p>
</dd>
<dt>iter</dt>
<dd>
<p>A vector of the number of iterations for each lambda.</p>
</dd>
<dt>group.weight</dt>
<dd>
<p>A vector of weights multiplied by the group penalty.</p>
</dd>
<dt>y</dt>
<dd>
<p>The response vector.</p>
</dd>
<dt>X</dt>
<dd>
<p>The design matrix without intercept.</p>
</dd>
</dl>
<h3>References</h3>


<ul>
<li>
<p> Buch, G., Schulz, A., Schmidtmann, I., Strauch, K., and Wild, P. S. (2024)
Sparse Group Penalties for bi-level variable selection. Biometrical Journal, 66, 2200334.
<a href="https://doi.org/10.1002/bimj.202200334">doi:10.1002/bimj.202200334</a>
</p>
</li>
<li>
<p> Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2011)
A Sparse-Group Lasso. Journal of computational and graphical statistics, 22(2), 231-245.
<a href="https://doi.org/10.1080/10618600.2012.681250">doi:10.1080/10618600.2012.681250</a>
</p>
</li>
<li>
<p>  Breheny, P., and Huang J. (2009)
Penalized methods for bi-level variable selection. Statistics and its interface, 2: 369-380.
<a href="https://doi.org/10.4310/sii.2009.v2.n3.a10">doi:10.4310/sii.2009.v2.n3.a10</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Generate data
 n &lt;- 100
 p &lt;- 200
 nr &lt;- 10
 g &lt;- ceiling(1:p / nr)
 X &lt;- matrix(rnorm(n * p), n, p)
 b &lt;- c(-3:3)
 y_lin &lt;- X[, 1:length(b)] %*% b + 5 * rnorm(n)
 y_log &lt;- rbinom(n, 1, exp(y_lin) / (1 + exp(y_lin)))

# Linear regression
 lin_fit &lt;- sgp(X, y_lin, g, type = "linear", penalty = "sgl")
 plot(lin_fit)
 lin_fit &lt;- sgp(X, y_lin, g, type = "linear", penalty = "sgs")
 plot(lin_fit)
 lin_fit &lt;- sgp(X, y_lin, g, type = "linear", penalty = "sgm")
 plot(lin_fit)
 lin_fit &lt;- sgp(X, y_lin, g, type = "linear", penalty = "sge")
 plot(lin_fit)

# Logistic regression
 log_fit &lt;- sgp(X, y_log, g, type = "logit", penalty = "sgl")
 plot(log_fit)
 log_fit &lt;- sgp(X, y_log, g, type = "logit", penalty = "sgs")
 plot(log_fit)
 log_fit &lt;- sgp(X, y_log, g, type = "logit", penalty = "sgm")
 plot(log_fit)
 log_fit &lt;- sgp(X, y_log, g, type = "logit", penalty = "sge")
 plot(log_fit)

</code></pre>


</div>