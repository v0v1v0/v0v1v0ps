<div class="container">

<table style="width: 100%;"><tr>
<td>fss2dfun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Various Verification Statistics on Possibly Neighborhood-Smoothed Fields.</h2>

<h3>Description</h3>

<p>Functions to calculate various verification statistics on possibly neighborhood smoothed fields.  Used by hoods2d, but can be called on their own.</p>


<h3>Usage</h3>

<pre><code class="language-R">fss2dfun(sPy, sPx, subset = NULL, verbose = FALSE)

fuzzyjoint2dfun(sPy, sPx, subset = NULL)

MinCvg2dfun(sIy, sIx, subset = NULL)

multicon2dfun(sIy, Ix, subset = NULL)

pragmatic2dfun(sPy, Ix, mIx = NULL, subset = NULL)

upscale2dfun(sYy, sYx, threshold = NULL, which.stats = c("rmse",
                 "bias", "ts", "ets"), rule = "&gt;=", subset = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sPy</code></td>
<td>
<p>n by m matrix giving a smoothed binary forecast field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sPx</code></td>
<td>
<p>n by m matrix giving a smoothed binary observed field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sIy</code></td>
<td>
<p>n by m matrix giving a binary forecast field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sIx</code></td>
<td>
<p>n by m matrix giving a binary observed field (the s indicates that the binary field is obtained from a smoothed field).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ix</code></td>
<td>
<p>n by m matrix giving a binary observed field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mIx</code></td>
<td>
<p>(optional) single numeric giving the base rate.  If NULL, this will be calculated by the function.  Simply a computation saving step if this has already been calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sYy</code></td>
<td>
<p>n by m matrix giving a smoothed forecast field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sYx</code></td>
<td>
<p>n by m matrix giving a smoothed observed field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>(optional) numeric vector of length 2 giving the threshold over which to calculate the verification statistics: bias, ts and ets.  If NULL, only the rmse will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.stats</code></td>
<td>
<p>character vector naming which statistic(s) should be caluclated for <code>upscale2dfun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>(optional) numeric indicating over which points the summary scores should be calculated.  If NULL, all of the points are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>character string giving the sort of thresholding process desired.  See the help file for <code>thresholder</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, should progress information be printed to the screen?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These are modular functions that calculate the neighborhood smoothing method statistics in spatial forecast verification (see, e.g., Ebert, 2008, 2009; Gilleland et al., 2009, 2010; Roberts and Lean,2008).  These functions take fields that have already had the neighborhood smoothing applied (e.g., using <code>kernele2d</code>) when appropriate.  They are called by <code>hoods2d</code>, so need not be called by the user, but they can be.
</p>


<h3>Value</h3>

<p>In the case of <code>fss2dfun</code>, a single numeric giving the FSS value is returned.  In the other cases, list objects are returned with one or more of the following components, depending on the particular function.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fuzzy</code></td>
<td>
<p><code>fuzzyjoint2dfun</code> returns a list with this list as one component.  The list component fuzzy has the components: pod, far and ets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p><code>fuzzyjoint2dfun</code> returns a list with this list as one component.  The list component joint has the components: pod, far and ets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pod</code></td>
<td>
<p>numeric giving the probability of detection, or hit rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>far</code></td>
<td>
<p>numeric giving the false alarm ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ets</code></td>
<td>
<p>numeric giving the equitable threat score, or Gilbert Skill Score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>numeric giving the false alarm rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hk</code></td>
<td>
<p>numeric giving the Hanssen-Kuipers statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs</code></td>
<td>
<p>Brier Score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bss</code></td>
<td>
<p>Brier Skill Score.  The <code>pragmatic2dfun</code> returns the bs and bss values.  The Brier Skill Score here uses the mean square error between the base rate and the Ix field as the reference forecast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ts</code></td>
<td>
<p>numeric giving the threat score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>numeric giving the frequency bias.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Eric Gilleland</p>


<h3>References</h3>

<p>Ebert, E. E. (2008) Fuzzy verification of high resolution gridded forecasts: A review and proposed framework.  <em>Meteorol. Appl.</em>, <b>15</b>, 51–64. doi:10.1002/met.25 
</p>
<p>Ebert, E. E. (2009) Neighborhood verification: A strategy for rewarding close forecasts.  <em>Wea. Forecasting</em>, <b>24</b>, 1498–1510, doi:10.1175/2009WAF2222251.1.
</p>
<p>Gilleland, E., Ahijevych, D., Brown, B. G., Casati, B. and Ebert, E. E. (2009) Intercomparison of Spatial Forecast Verification Methods. <em>Wea. Forecasting</em>, <b>24</b>, 1416–1430, doi:10.1175/2009WAF2222269.1.
</p>
<p>Gilleland, E., Ahijevych, D. A., Brown, B. G. and Ebert, E. E. (2010) Verifying Forecasts Spatially. <em>Bull. Amer. Meteor. Soc.</em>, October, 1365–1373.
</p>
<p>Roberts, N. M. and Lean, H. W. (2008) Scale-selective verification of rainfall accumulations from high-resolution forecasts of convective events.  <em>Mon. Wea. Rev.</em>, <b>136</b>, 78–97. doi:10.1175/2007MWR2123.1.</p>


<h3>See Also</h3>

<p><code>hoods2d</code>,<code>kernel2dsmooth</code>,<code>vxstats</code>, <code>thresholder</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- y &lt;- matrix( 0, 100, 100)
x[ sample(1:100, 10), sample(1:100, 10)] &lt;- 1
y[ sample(1:100, 20), sample(1:100, 20)] &lt;- 1
Px &lt;- kernel2dsmooth( x, kernel.type="boxcar", n=9, xdim=c(100, 100))
Py &lt;- kernel2dsmooth( y, kernel.type="boxcar", n=9, xdim=c(100, 100))
par( mfrow=c(2,2))
image( x, col=c("grey", "darkblue"), main="Simulated Observed Events")
image( y, col=c("grey", "darkblue"), main="Simulated Forecast Events")
image( Px, col=c("grey", tim.colors(256)), main="Forecast Event Frequencies (9 nearest neighbors)")
image( Py, col=c("grey", tim.colors(256)), main="Smoothed Observed Events (9 nearest neighbors)")
fss2dfun( Py, Px)

</code></pre>


</div>