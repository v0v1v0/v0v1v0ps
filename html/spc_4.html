<div class="container">

<table style="width: 100%;"><tr>
<td>imr.arl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute ARLs and control limit factors for I-MR combos in case of normal data</h2>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given mean <code>mu</code> and <code>sigma</code> etc.</p>


<h3>Usage</h3>

<pre><code class="language-R">imr.arl(M, Ru, mu, sigma, vsided="upper", Rl=0, cmode="coll", N=30, qm=30)

imr.Ru_Mgiven(M, L0, N=30, qm=30)

imr.Rl_Mgiven(M, L0, N=30, qm=30)

imr.MandRu(L0, N=30, qm=30)

imr.MandRuRl(L0, N=30, qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>control limit multiple for mean chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ru</code></td>
<td>
<p>upper control limit multiple for moving range chart.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>actual mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>actual standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vsided</code></td>
<td>
<p>switches between the more common "upper" and the less popular "two"(-sided) case of the MR chart.
Setting <code>vsided</code> to "two" and <code>Ru</code> sufficiently large (at least <code>2*M</code>), creates an I-MR chart
with a lower limit only for the MR part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rl</code></td>
<td>
<p>lower control limit multiple for moving range chart (not needed in the upper case, i.e. if <code>vsided</code>="upper").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmode</code></td>
<td>
<p>selects the numerical algorithm. The default <code>"coll"</code> picks the piecewise collocation, which is
the most accurate method. Selecting <code>"Crowder"</code>, the algorithm from Crowder (1987b) is chosen (re-implemented in R).
Taking a label from <code>"gl"</code>, <code>"rectangular"</code>, <code>"trapezoid"</code>, <code>"simpson"</code> or <code>"simpson3_8"</code>,
one decides for the quite common Nystroem procedure to numerically solve the considered integral equation.
It is astonishing that Crowder's modified Nystroem design with the trapezoidal quadrature works so well.
However, it is clearly dominated by the piecewise collocation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Controls the dimension of the linear equation system and consequently the accuracy of the result. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qm</code></td>
<td>
<p>Number of quadrature nodes (and weights) to determine the collocation definite integrals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>pre-defined in-control ARL, that is, determine <code>Ru</code>, <code>Rl</code>, or <code>M</code> and <code>Ru</code> or
all of them (essentially ending in a lower limit MR chart) so that the mean
number of observations until a false alarm is <code>L0</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Crowder (1987a) provided some math to determine the ARL of the so-called individual moving range (IMR) chart.
The given integral equation was approximated by a linear equation system applying trapezoidal quadratures.
Interestingly, Crowder did not recognize the specific behavior of the solution for <code>Ru</code> &gt;= <code>M</code> (which is
the more common case), where the resulting function L() is constant in the central part of the
considered domain. In addition, by performing collocation on two (<code>Ru</code> &gt; <code>M</code>)
or three (<code>Ru</code> &lt; <code>M</code>) subintervals piecewise, one obtains highly accurate
ARL numbers. Note that <code>imr.MandRu</code> yields <code>M</code> and <code>Ru</code> for the upper MR trace, whereas
<code>imr.MandRuRl</code> provides in addition the lower factor <code>Rl</code> for IMR consisting of two two-sided control charts.
Note that the underlying ARL unbiased condition suppresses the upper limit <code>Ru</code> in all considered cases so far.
This is not completely surprising, because the mean chart is already quite sensitive for increases in the variance.
The two functions <code>imr.Ru_Mgiven</code> and <code>imr.Rl_Mgiven</code> deliver the single upper and lower limit,
respectively, if a one-sided MR design is utilized and the control lmit factor <code>M</code> of
the mean chart is set already. Note that for <code>Ru</code> &gt; <code>2*M</code>, the upper MR limit is
not operative anymore. If it was initially an upper MR chart, then it reduces to a single mean chart.
If it was originally a two-sided MR design, then it becomes a two-sided mean/lower variance chart combo.
Within the latter scheme, the mean chart signals variance increases (a well-known pattern), whereas
the MR subchart delivers only decreasing variance signals. However, these simple Shewhart charts
exhibit in all configurations week variance decreases detection behavior.
Eventually, we should note that the scientific control chart community mainly recommends to
ignore MR charts, see, for example, Vardeman and Jobe (2016), whereas standards (such as ISO), commercial
SPC software and many training manuals provide the IMR scheme with completely wrong upper limits for the MR chart.</p>


<h3>Value</h3>

<p>Returns either the ARL or control limit factors (alias multiples).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1987a)
Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 98-102.
</p>
<p>S. V. Crowder (1987b)
A Program for the Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 103-106.
</p>
<p>K. C. B. Roes, R. J. M. M. Does, Y. Schurink,
Shewhart-Type Control Charts for Individual Observations,
<em>Journal of Quality Technology</em> 25(3), 188-198.
</p>
<p>S. E. Rigdon, E. N. Cruthis, C. W. Champ (1994)
Design Strategies for Individuals and Moving Range Control Charts,
<em>Journal of Quality Technology</em> 26(4), 274-287.
</p>
<p>D. Radson, L. C. Alwan (1995)
Detecting Variance Reductions Using the Moving Range,
<em>Quality Engineering</em> 8(1), 165-178.
</p>
<p>S. R. Adke, X. Hong (1997)
A Supplementary Test Based on the Control Chart for Individuals,
<em>Journal of Quality Technology</em> 29(1), 16-20.
</p>
<p>R. W. Amin, R. A. Ethridge (1998)
A Note on Individual and Moving Range Control Charts,
<em>Journal of Quality Technology</em> 30(1), 70-74.
</p>
<p>C. A. Acosta-Mejia, J. J. Pignatiello (2000)
Monitoring process dispersion without subgrouping,
<em>Journal of Quality Technology</em> 32(2), 89-102.
</p>
<p>N. B. Marks, T. C. Krehbiel (2011)
Design And Application Of Individuals And Moving Range Control Charts,
<em>Journal of Applied Business Research (JABR)</em> 25(5), 31-40.
</p>
<p>D. Rahardja (2014)
Comparison of Individual and Moving Range Chart Combinations to Individual
Charts in Terms of ARL after Designing for a Common “All OK” ARL,
<em>Journal of Modern Applied Statistical Methods</em> 13(2), 364-378.
</p>
<p>S. B. Vardeman, J. M. Jobe (2016)
<em>Statistical Methods for Quality Assurance</em>,
Springer, 2nd edition.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Crowder (1987b), Output Listing 1, trapezoidal quadrature (less accurate)

M &lt;- 2
Ru &lt;- 3
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- LL2 &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) {
  LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=4)
  LL2[i] &lt;- round( imr.arl(M, Ru, mu[i], 1, cmode="Crowder", N=80), digits=4)
}
LL1987b &lt;- c(18.2164, 16.3541, 12.4282, 8.7559, 6.1071, 4.3582, 3.2260, 2.4878, 1.9989)
print( data.frame(mu, LL2, LL1987b, LL) )

## Crowder (1987a), Table 1, trapezoidal quadrature (less accurate)

M &lt;- 4
Ru &lt;- 3
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=4)
LL1987a &lt;- c(34.44, 34.28, 34.07, 33.81, 33.45, 32.82, 31.50, 28.85, 24.49)
print( data.frame(mu, LL1987a, LL) )

## Rigdon, Cruthis, Champ (1994), Table 1, Monte Carlo based

M &lt;- 2.992
Ru &lt;- 4.139
icARL &lt;- imr.arl(M, Ru, 0, 1)
icARL1994 &lt;- 200
print( data.frame(icARL1994, icARL) )

M &lt;- 3.268
Ru &lt;- 4.556
icARL &lt;- imr.arl(M, Ru, 0, 1)
icARL1994 &lt;- 500
print( data.frame(icARL1994, icARL) )

## ..., Table 2, Monte Carlo based

M &lt;- 2.992
Ru &lt;- 4.139
tau &lt;- c(seq(1, 1.3, by=0.05), seq(1.4, 2, by=0.1))
LL &lt;- rep(NA, length(tau))
for ( i in 1:length(tau) ) LL[i] &lt;- round( imr.arl(M, Ru, 0, tau[i]), digits=2)
LL1994 &lt;- c(200.54, 132.25, 90.84, 65.66, 49.35, 38.92, 31.11, 21.35, 15.47,
12.04, 9.81, 8.21, 7.03, 6.14)
print( data.frame(tau, LL1994, LL) )

## Radson, Alwan (1995), Table 2 (Monte Carlo based), half-normal, known parameter case
## two-sided (!) MR-alone (!) chart, hence the ARL results has to be decreased by 1
## Here: a large M (=12) is deployed to mimic Inf
alpha &lt;- 0.00915
Ru &lt;- sqrt(2) * qnorm(1-alpha/4)
Rl &lt;- sqrt(2) * qnorm(0.5+alpha/4)
k &lt;- 1.5 - (0:7)/10
LL &lt;- rep(NA, length(k))
for ( i in 1:length(k) )
  LL[i] &lt;- round( imr.arl(12, Ru, 0, k[i], vsided="two", Rl=Rl), digits=2) - 1
RA1995 &lt;- c(18.61, 24.51, 34.21, 49.74, 75.08, 113.14, 150.15, 164.54)
print( data.frame(k, RA1995, LL) )

## Amin, Ethridge (1998), Table 2, column sigma/sigma_0 = 1.00

M &lt;- 3.27
Ru &lt;- 4.56
#M &lt;- 3.268
#Ru &lt;- 4.556
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=1)
LL1998 &lt;- c(505.3, 427.6, 276.7, 156.2, 85.0, 46.9, 26.9, 16.1, 10.1)
print( data.frame(mu, LL1998, LL) )

## ..., column sigma/sigma_0 = 1.05

for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1.05), digits=1)
LL1998 &lt;- c(296.8, 251.6, 169.6, 101.6, 58.9, 34.5, 20.9, 13.2, 8.7)
print( data.frame(mu, LL1998, LL) )

## Acosta-Mejia, Pignatiello (2000), Table 2
## AMP utilized Markov chain approximation
## However, the MR series is not Markovian!
## MR-alone (!) chart, hence the ARL results has to be decreased by 1
## Here: a large M (=8) is deployed to mimic Inf
Ru &lt;- 3.93
sigma &lt;- c(1, 1.05, 1.1, 1.15, 1.2, 1.3, 1.4, 1.5, 1.75)
LL &lt;- rep(NA, length(sigma))
for ( i in 1:length(sigma) ) LL[i] &lt;- round( imr.arl(8, Ru, 0, sigma[i], N=30), digits=1) - 1
AMP2000 &lt;- c(201.0, 136.8, 97.9, 73.0, 56.3, 36.4, 25.6, 19.1, 11.0)
print( data.frame(sigma, AMP2000, LL) )

## Mark, Krehbiel (2011), Table 2, deployment of Crowder (1987b), nominal ic ARL 500

M &lt;- c(3.09, 3.20, 3.30, 3.50, 4.00)
Ru &lt;- c(6.00, 4.67, 4.53, 4.42, 4.36)
LL0 &lt;- rep(NA, length(M))
for ( i in 1:length(M) ) LL0[i] &lt;- round( imr.arl(M[i], Ru[i], 0, 1), digits=1)
print( data.frame(M, Ru, LL0) )
</code></pre>


</div>