<div class="container">

<table style="width: 100%;"><tr>
<td>addLoggingWrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Return a function which internally stores x or y values.</h2>

<h3>Description</h3>

<p>Often it is desired and useful to store the optimization path, i.e., the evaluated
function values and/or the parameters. Not all optimization algorithms offer
such a trace. This wrapper makes a smoof function handle x/y-values itself.
</p>


<h3>Usage</h3>

<pre><code class="language-R">addLoggingWrapper(fn, logg.x = FALSE, logg.y = TRUE, size = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br>
Smoof function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logg.x</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Should x-values be logged?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logg.y</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Should objective values be logged?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Initial size of the internal data structures used for logging.
Default is 100. I.e., there is space reserved for 100 function evaluations.
In case of an overflow (i.e., more function evaluations than space reserved)
the data structures are re-initialized by adding space for another <code>size</code> evaluations.
This comes handy if you know the number of function evaluations (or at least
an upper bound thereof) a-priori and may serve to reduce the time complextity
of logging values.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>smoof_logging_function</code>]
</p>


<h3>Note</h3>

<p>Logging values, in particular logging x-values, will substantially slow
down the evaluation of the function.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We first build the smoof function and apply the logging wrapper to it
fn = makeSphereFunction(dimensions = 2L)
fn = addLoggingWrapper(fn, logg.x = TRUE)

# We now apply an optimization algorithm to it and the logging wrapper keeps
# track of the evaluated points.
res = optim(fn, par = c(1, 1), method = "Nelder-Mead")

# Extract the logged values
log.res = getLoggedValues(fn)
print(log.res$pars)
print(log.res$obj.vals)
log.res = getLoggedValues(fn, compact = TRUE)
print(log.res)

</code></pre>


</div>