<div class="container">

<table style="width: 100%;"><tr>
<td>decimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Decimate or downsample a signal </h2>

<h3>Description</h3>

<p>Downsample a signal by a factor, using an FIR or IIR filter.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">decimate(x, q, n = if (ftype == "iir") 8 else 30, ftype = "iir")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> signal to be decimated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p> integer factor to downsample by. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> filter order used in the downsampling. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ftype</code></td>
<td>
<p> filter type, <code>"iir"</code> or <code>"fir"</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, an order 8 Chebyshev type I
filter is used or a 30-point FIR filter if <code>ftype</code> is <code>'fir'</code>.  Note
that <code>q</code> must be an integer for this rate change method.
</p>
<p>Makes use of the <code>filtfilt</code> function with all its limitations.
</p>


<h3>Value</h3>

<p>The decimated signal, an array of length <code>ceiling(length(x) / q)</code>.
</p>


<h3>Author(s)</h3>

<p> Original Octave version by Paul Kienzle
<a href="mailto:pkienzle@user.sf.net">pkienzle@user.sf.net</a>. Conversion to R by Tom Short. </p>


<h3>References</h3>

 
<p>Octave Forge <a href="https://octave.sourceforge.io/">https://octave.sourceforge.io/</a>
</p>


<h3>See Also</h3>

 <p><code>filter</code>, <code>resample</code>, <code>interp</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"># The signal to decimate starts away from zero, is slowly varying
# at the start and quickly varying at the end, decimate and plot.
# Since it starts away from zero, you will see the boundary
# effects of the antialiasing filter clearly.  You will also see
# how it follows the curve nicely in the slowly varying early
# part of the signal, but averages the curve in the quickly
# varying late part of the signal.
t &lt;- seq(0, 2, by = 0.01)
x &lt;- chirp(t, 2, 0.5, 10, 'quadratic') + sin(2*pi*t*0.4)
y &lt;- decimate(x, 4)   # factor of 4 decimation
plot(t, x, type = "l")
lines(t[seq(1,length(t), by = 4)], y, col = "blue")
</code></pre>


</div>