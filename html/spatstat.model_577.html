<div class="container">

<table style="width: 100%;"><tr>
<td>residuals.ppm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Residuals for Fitted Point Process Model
</h2>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
compute residuals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'ppm'
residuals(object, type="raw", ...,
                check=TRUE, drop=FALSE,
                fittedvalues=NULL, 
                new.coef=NULL, dropcoef=FALSE,
                quad=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which residuals should be calculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>String indicating the type of residuals to be calculated.
Current options are
<code>"raw"</code>, <code>"inverse"</code>, <code>"pearson"</code> and <code>"score"</code>.
A partial match is adequate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>object</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>Logical value determining whether to delete quadrature points
that were not used to fit the model. See <code>quad.ppm</code> for
explanation. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fittedvalues</code></td>
<td>

<p>Vector of fitted values for the conditional intensity at 
the quadrature points,
from which the residuals will be computed. 
For expert use only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.coef</code></td>
<td>

<p>Optional. Numeric vector of coefficients for the model,
replacing <code>coef(object)</code>.
See the section on Modified Residuals below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropcoef</code></td>
<td>

<p>Internal use only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad</code></td>
<td>

<p>Optional. Data specifying how to re-fit the model.
A list of arguments passed to <code>quadscheme</code>.
See the section on Modified Residuals below.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes several kinds of residuals for the fit of
a point process model to a spatial point pattern dataset
(Baddeley et al, 2005).
Use <code>plot.msr</code> to plot the residuals directly,
or <code>diagnose.ppm</code>
to produce diagnostic plots based on these residuals.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code>). Such objects are produced by the maximum
pseudolikelihood fitting algorithm <code>ppm</code>.
This fitted model object contains complete
information about the original data pattern. 
</p>
<p>Residuals are attached both to the data points and to some
other points in the window of observation (namely, to the dummy
points of the quadrature scheme used to fit the model).
If the fitted model is correct, then the sum of the 
residuals over all (data and dummy) points in a spatial region <code class="reqn">B</code>
has mean zero. For further explanation, see Baddeley et al (2005).
</p>
<p>The type of residual
is chosen by the argument <code>type</code>. Current options are
</p>

<dl>
<dt>
<code>"raw"</code>:</dt>
<dd>
<p>the raw residuals
</p>
<p style="text-align: center;"><code class="reqn">
	r_j = z_j - w_j \lambda_j
      </code>
</p>

<p>at the quadrature points <code class="reqn">u_j</code>,
where <code class="reqn">z_j</code> is the indicator equal to 1 if <code class="reqn">u_j</code>
is a data point and 0 if <code class="reqn">u_j</code> is a dummy point;
<code class="reqn">w_j</code> is the quadrature weight attached to
<code class="reqn">u_j</code>; and
</p>
<p style="text-align: center;"><code class="reqn">\lambda_j = \hat\lambda(u_j,x)</code>
</p>

<p>is the conditional intensity of the fitted model at <code class="reqn">u_j</code>.
These are the spatial analogue of the martingale residuals
of a one-dimensional counting process.
</p>
</dd>
<dt>
<code>"inverse"</code>:</dt>
<dd>
<p>the ‘inverse-lambda’ residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r^{(I)}_j = \frac{r_j}{\lambda_j}
        = \frac{z_j}{\lambda_j} - w_j
      </code>
</p>

<p>obtained by dividing the raw residuals by 
the fitted conditional intensity. These are 
a counterpart of the exponential energy marks (see <code>eem</code>).
</p>
</dd>
<dt>
<code>"pearson"</code>:</dt>
<dd>
<p>the Pearson residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r^{(P)}_j = \frac{r_j}{\sqrt{\lambda_j}}
        = \frac{z_j}{\sqrt{\lambda_j}}
        - w_j \sqrt{\lambda_j}
      </code>
</p>

<p>obtained by dividing the raw residuals by the
square root of the fitted conditional intensity.
The Pearson residuals are standardised, in the sense
that if the model (true and fitted) is Poisson,
then the sum of the Pearson residuals in a spatial region <code class="reqn">B</code>
has variance equal to the area of <code class="reqn">B</code>.
</p>
</dd>
<dt>
<code>"score"</code>:</dt>
<dd>
<p>the score residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r_j = (z_j - w_j \lambda_j) x_j
      </code>
</p>

<p>obtained by multiplying the raw residuals <code class="reqn">r_j</code>
by the covariates <code class="reqn">x_j</code> for quadrature point <code class="reqn">j</code>.
The score residuals always sum to zero.
</p>
</dd>
</dl>
<p>The result of <code>residuals.ppm</code> is a measure
(object of class <code>"msr"</code>).
Use <code>plot.msr</code> to plot the residuals directly,
or <code>diagnose.ppm</code> to produce diagnostic plots
based on these residuals.
Use <code>integral.msr</code> to compute the total residual.
</p>
<p>By default, 
the window of the measure is the same as the original window
of the data. If <code>drop=TRUE</code> then the window is the
domain of integration of the pseudolikelihood or composite likelihood.
This only matters when the model <code>object</code> was fitted using
the border correction: in that case, if <code>drop=TRUE</code> the
window of the residuals is the erosion of the original data window
by the border correction distance <code>rbord</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code> 
representing a signed measure or vector-valued measure
(see <code>msr</code>). This object can be plotted.
</p>


<h3>Modified Residuals</h3>

<p>Sometimes we want to modify the calculation of residuals by using
different values for the model parameters. This capability is
provided by the arguments <code>new.coef</code> and <code>quad</code>.
</p>
<p>If <code>new.coef</code> is given, then the residuals will be computed
by taking the model parameters to be <code>new.coef</code>.
This should be a numeric vector
of the same length as the vector of fitted model parameters
<code>coef(object)</code>. 
</p>
<p>If <code>new.coef</code> is missing and <code>quad</code> is given,
then the model parameters will
be determined by re-fitting the model using a new
quadrature scheme specified by <code>quad</code>. 
Residuals will be computed for the
original model <code>object</code> using these new parameter values.
</p>
<p>The argument <code>quad</code> should normally be
a list of arguments in <code>name=value</code> format that will be
passed to <code>quadscheme</code> (together with
the original data points) to determine the new quadrature scheme.
It may also be a quadrature scheme (object of class
<code>"quad"</code>) to which the model should be fitted, or a
point pattern (object of class <code>"ppp"</code>) specifying the
<em>dummy points</em> in a new quadrature scheme.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617–666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627–649.
</p>


<h3>See Also</h3>

<p><code>msr</code>,
<code>diagnose.ppm</code>,
<code>ppm.object</code>,
<code>ppm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   fit &lt;- ppm(cells, ~x, Strauss(r=0.15))

   # Pearson residuals
   rp &lt;- residuals(fit, type="pe")
   rp

   # simulated data
   X &lt;- rStrauss(100,0.7,0.05)
   # fit Strauss model 
   fit &lt;- ppm(X, ~1, Strauss(0.05))
   res.fit &lt;- residuals(fit)

   # check that total residual is 0 
   integral.msr(residuals(fit, drop=TRUE))

   # true model parameters
   truecoef &lt;- c(log(100), log(0.7))
   res.true &lt;- residuals(fit, new.coef=truecoef)  
</code></pre>


</div>