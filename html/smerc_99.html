<div class="container">

<table style="width: 100%;"><tr>
<td>csg2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct connected subgraphs</h2>

<h3>Description</h3>

<p><code>csg2</code>, <code>lcsg2</code>, and <code>scsg2</code> construct
connected subgraphs. These functions are not intended
for users.
<code>nn</code> contains a list of nearest
neighbors for each region. <code>idx</code> is a
vector of possible vertices being considered as a
subgraph. <code>w</code> is a connectivity matrix relating the
N vertices. <code>w[i,j] = 1</code> if vertices i and j are
connected, i.e., if they share an edge. The dimensions of
<code>w</code> are <code class="reqn">N times k</code>, where <code>k =
length(idx)</code>. While the rows of <code>w</code> contain
adjacency information for all N vertices, only the
<code>idx</code> columns of the complete adjacency matrix are
used in <code>w</code>.  See Details for discussion of
<code>scsg</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">csg2(cz, cnn, cw)

lcsg2(lcz, cnn, cw)

scsg2(
  nn,
  w,
  idx = seq_along(nn),
  nlevel = NULL,
  verbose = FALSE,
  logical = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cz</code></td>
<td>
<p>A logical vector representing the current subgraph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cnn</code></td>
<td>
<p>The indices of the neighbors of the current vertex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cw</code></td>
<td>
<p>A binary adjacency matrix for the neighbors of the current vertex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcz</code></td>
<td>
<p>A list of current zones (in the form of logical vectors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>A list of the nearest neighbors for each vertex (region).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A binary adjacency matrix indicating connected neighbors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>A vector of vertices for which to construct the set of connected subgraphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevel</code></td>
<td>
<p>The maximum size of each subgraph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value indicating whether descriptive messages should be provided.  Default is
<code>FALSE</code>.  If <code>TRUE</code>, this can be useful for
diagnosing where the sequences of connected subgraphs
is slowing down/having problems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logical</code></td>
<td>
<p>A logical value indicating whether a list of logical vectors should be returned. The default is <code>FALSE</code>,
indicating that the <code>scsg</code> function should return a list of vectors with
each vector containing the vertex indices included in each subgraph.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>scsg2</code> performs a sequence of <code>lcsg2</code> calls.
Starting with <code>lcz == list(idx[1])</code>, <code>scsg</code>
keeps iteratively building more connected subsgraphs by
perfoming something like:  lcz1 = list(idx[1]).  lcz2 =
lcsg2(lcz1, ...). lcz3 = lcsg2(lcz2, ...).  This is
done until there are no more connected subgraphs among
the elements of <code>idx</code>.
</p>


<h3>Value</h3>

<p>A list with all possible connected subgraphs based on the
user-provided parameters.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nydf)
data(nyw)
# determine 50 nn of region 1 for NY data
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
nn3 &lt;- knn(coords, longlat = TRUE, k = 3)
z1 &lt;- scsg2(nn3, nyw)
z2 &lt;- flex.zones(coords, nyw, k = 3, longlat = TRUE)
all.equal(z1, z2)
</code></pre>


</div>