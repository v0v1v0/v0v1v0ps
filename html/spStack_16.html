<div class="container">

<table style="width: 100%;"><tr>
<td>spLMstack</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian spatial linear model using predictive stacking</h2>

<h3>Description</h3>

<p>Fits Bayesian spatial linear model on a collection of candidate
models constructed based on some candidate values of some model parameters
specified by the user and subsequently combines inference by stacking
predictive densities. See Zhang, Tang and Banerjee (2024) for more details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spLMstack(
  formula,
  data = parent.frame(),
  coords,
  cor.fn,
  priors,
  params.list,
  n.samples,
  loopd.method,
  parallel = FALSE,
  solver = "ECOS",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the regression model to be fit.
See example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spLMstack</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">\mathbb{R}^2</code> (e.g., easting and northing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.
See below for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name and
containing prior details. If not supplied, uses defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params.list</code></td>
<td>
<p>a list containing candidate values of spatial process
parameters for the <code>cor.fn</code> used, and, noise-to-spatial variance ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>number of posterior samples to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loopd.method</code></td>
<td>
<p>character. Valid inputs are <code>'exact'</code> and <code>'PSIS'</code>. The
option <code>'exact'</code> corresponds to exact leave-one-out predictive densities.
The option <code>'PSIS'</code> is faster, as it finds approximate leave-one-out
predictive densities using Pareto-smoothed importance sampling
(Gelman <em>et al.</em> 2024).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. If <code>parallel=FALSE</code>, the parallelization plan,
if set up by the user, is ignored. If <code>parallel=TRUE</code>, the function
inherits the parallelization plan that is set by the user via the function
<code>future::plan()</code> only. Depending on the parallel backend available, users
may choose their own plan. More details are available at
<a href="https://cran.R-project.org/package=future">https://cran.R-project.org/package=future</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>(optional) Specifies the name of the solver that will be used
to obtain optimal stacking weights for each candidate model. Default is
<code>"ECOS"</code>. Users can use other solvers supported by the
CVXR-package package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints model-specific optimal
stacking weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional argument.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Instead of assigning a prior on the process parameters <code class="reqn">\phi</code>
and <code class="reqn">\nu</code>, noise-to-spatial variance ratio <code class="reqn">\delta^2</code>, we consider
a set of candidate models based on some candidate values of these parameters
supplied by the user. Suppose the set of candidate models is
<code class="reqn">\mathcal{M} = \{M_1, \ldots, M_G\}</code>. Then for each
<code class="reqn">g = 1, \ldots, G</code>, we sample from the posterior distribution
<code class="reqn">p(\sigma^2, \beta, z \mid y, M_g)</code> under the model <code class="reqn">M_g</code> and find
leave-one-out predictive densities <code class="reqn">p(y_i \mid y_{-i}, M_g)</code>. Then we
solve the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">
 \begin{aligned}
 \max_{w_1, \ldots, w_G}&amp; \, \frac{1}{n} \sum_{i = 1}^n \log \sum_{g = 1}^G
 w_g p(y_i \mid y_{-i}, M_g) \\
 \text{subject to} &amp; \quad w_g \geq 0, \sum_{g = 1}^G w_g = 1
 \end{aligned}
 </code>
</p>

<p>to find the optimal stacking weights <code class="reqn">\hat{w}_1, \ldots, \hat{w}_G</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>spLMstack</code>, which is a list including the
following tags -
</p>

<dl>
<dt><code>samples</code></dt>
<dd>
<p>a list of length equal to total number of candidate models
with each entry corresponding to a list of length 3, containing posterior
samples of fixed effects (<code>beta</code>), variance parameter
(<code>sigmaSq</code>), spatial effects (<code>z</code>) for that model.</p>
</dd>
<dt><code>loopd</code></dt>
<dd>
<p>a list of length equal to total number of candidate models with
each entry containing leave-one-out predictive densities under that
particular model.</p>
</dd>
<dt><code>n.models</code></dt>
<dd>
<p>number of candidate models that are fit.</p>
</dd>
<dt><code>candidate.models</code></dt>
<dd>
<p>a matrix with <code>n_model</code> rows with each row
containing details of the model parameters and its optimal weight.</p>
</dd>
<dt><code>stacking.weights</code></dt>
<dd>
<p>a numeric vector of length equal to the number of
candidate models storing the optimal stacking weights.</p>
</dd>
<dt><code>run.time</code></dt>
<dd>
<p>a <code>proc_time</code> object with runtime details.</p>
</dd>
<dt><code>solver.status</code></dt>
<dd>
<p>solver status as returned by the optimization
routine.</p>
</dd>
</dl>
<p>The return object might include additional data that is useful for subsequent
prediction, model fit evaluation and other utilities.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br>
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Vehtari A, Simpson D, Gelman A, Yao Y, Gabry J (2024). "Pareto
Smoothed Importance Sampling." <em>Journal of Machine Learning Research</em>,
<strong>25</strong>(72), 1-58. URL <a href="https://jmlr.org/papers/v25/19-556.html">https://jmlr.org/papers/v25/19-556.html</a>.
</p>
<p>Zhang L, Tang W, Banerjee S (2024). "Bayesian Geostatistics Using
Predictive Stacking." <br><a href="https://doi.org/10.48550/arXiv.2304.12414">doi:10.48550/arXiv.2304.12414</a>.
</p>


<h3>See Also</h3>

<p><code>spLMexact()</code>, <code>spGLMstack()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load data and work with first 100 rows
data(simGaussian)
dat &lt;- simGaussian[1:100, ]

# setup prior list
muBeta &lt;- c(0, 0)
VBeta &lt;- cbind(c(1.0, 0.0), c(0.0, 1.0))
sigmaSqIGa &lt;- 2
sigmaSqIGb &lt;- 2
prior_list &lt;- list(beta.norm = list(muBeta, VBeta),
                   sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))

mod1 &lt;- spLMstack(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  priors = prior_list,
                  params.list = list(phi = c(1.5, 3),
                                     nu = c(0.5, 1),
                                     noise_sp_ratio = c(1)),
                  n.samples = 1000, loopd.method = "exact",
                  parallel = FALSE, solver = "ECOS", verbose = TRUE)

post_samps &lt;- stackedSampler(mod1)
post_beta &lt;- post_samps$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))

post_z &lt;- post_samps$z
post_z_summ &lt;- t(apply(post_z, 1,
                       function(x) quantile(x, c(0.025, 0.5, 0.975))))

z_combn &lt;- data.frame(z = dat$z_true,
                      zL = post_z_summ[, 1],
                      zM = post_z_summ[, 2],
                      zU = post_z_summ[, 3])

library(ggplot2)
plot1 &lt;- ggplot(data = z_combn, aes(x = z)) +
  geom_point(aes(y = zM), size = 0.25,
             color = "darkblue", alpha = 0.5) +
  geom_errorbar(aes(ymin = zL, ymax = zU),
                width = 0.05, alpha = 0.15) +
  geom_abline(slope = 1, intercept = 0,
              color = "red", linetype = "solid") +
  xlab("True z") + ylab("Stacked posterior of z") +
  theme_bw() +
  theme(panel.background = element_blank(),
        aspect.ratio = 1)
</code></pre>


</div>