<div class="container">

<table style="width: 100%;"><tr>
<td>protect_quadtree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Protect a raster with  a quadtree method.</h2>

<h3>Description</h3>

<p><code>protect_quadtree</code> reduces sensitivy by aggregating sensisitve cells with its
three neighbors, and does this recursively until no sensitive cells are
left or when the maximum zoom levels has been reached.
</p>


<h3>Usage</h3>

<pre><code class="language-R">protect_quadtree(x, max_zoom = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>sdc_raster</code> object to be protected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_zoom</code></td>
<td>
<p><code>numeric</code>, restricts the number of zoom steps and thereby the max resolution for the
blocks. Each step will zoom with a factor of 2 in x and y so the max resolution = resolution * 2^max_zoom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>is_sensitive</code>
</p>

<dl>
<dt><code>max_risk</code></dt>
<dd>
<p>a risk value higher than <code>max_risk</code> will be sensitive.</p>
</dd>
<dt><code>min_count</code></dt>
<dd>
<p>a count lower than <code>min_count</code> will be sensitive.</p>
</dd>
<dt><code>risk_type</code></dt>
<dd>
<p>what kind of measure should be used (see details).</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This implementation generalizes the method as described by Suñé et al., in
which there is no
risk function, and only a  <code>min_count</code> to determine sensitivity.
Furthermore the method the article
only handles count data (<code>x$value$count</code>), not mean or summed values.
Currently the translation feature of the article is not (yet) implemented,
for the original method does not take the <code>disclosure_risk</code> into account.
</p>


<h3>Value</h3>

<p>a <code>sdc_raster</code> object, in which sensitive cells have been recursively aggregated until not sensitive or
when max_zoom has been reached.
</p>


<h3>References</h3>

<p>Suñé, E., Rovira, C., Ibáñez, D., Farré, M. (2017).
Statistical disclosure control on visualising geocoded population data using
a structure in quadtrees, NTTS 2017
</p>


<h3>See Also</h3>

<p>Other protection methods: 
<code>protect_smooth()</code>,
<code>remove_sensitive()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># library(raster)
#
# fined &lt;- sdc_raster(enterprises, enterprises$fined)
# plot(fined)
# fined_qt &lt;- protect_quadtree(fined)
# plot(fined_qt)
#
# fined &lt;- sdc_raster(enterprises, enterprises$fined, r=50)
# plot(fined)
# fined_qt &lt;- protect_quadtree(fined)
# plot(fined_qt)
#
#
#
# library(sf)
# gemeente_2019 &lt;- st_read("https://cartomap.github.io/nl/rd/gemeente_2019.geojson")
# st_crs(gemeente_2019) &lt;- 28992
# nbl &lt;- st_touches(gemeente_2019)
#
# coords &lt;- st_coordinates(st_centroid(gemeente_2019))
# l &lt;- lapply(seq_along(nbl), function(i){
#   nb &lt;- nbl[[i]]
#   st_sfc(lapply(nb, function(j){
#     st_linestring(coords[c(i,j),])})
#   )
# })
# l2 &lt;- do.call(c, l)
#
# edge_list &lt;- as.data.frame(nbl)
# library(data.table)
# el &lt;- as.data.table(edge_list)
# names(el) &lt;- c("from", "to")
#
# edge_list$from &lt;- gemeente_2019$id[edge_list$row.id]
# edge_list$to &lt;- gemeente_2019$id[edge_list$col.id]
# edge_list &lt;- subset(edge_list, row.id &lt; col.id)
# edge_list &lt;- edge_list[,c("from", "to")]
#
# g &lt;- igraph::graph_from_data_frame(edge_list, directed = FALSE)
# plot(g)
# library(igraph)
# i &lt;- match(names(V(g)), gemeente_2019$id)
#
# c2 &lt;- igraph::layout_with_fr(g, coords[i,])
# plot(g, layout = c2)
#
# buurt_2019 &lt;- st_read("https://cartomap.github.io/nl/rd/buurt_2019.geojson")
# st_crs(buurt_2019) &lt;- 28992
# system.time({
#   nbl &lt;- st_touches(buurt_2019)
# })
#
# coords &lt;- st_coordinates(st_centroid(buurt_2019))
# l &lt;- lapply(seq_along(nbl), function(i){
#   nb &lt;- nbl[[i]]
#   st_sfc(lapply(nb, function(j){
#     st_linestring(coords[c(i,j),])})
#   )
# })
# l2 &lt;- do.call(c, l)
#
# plot(l2)
</code></pre>


</div>