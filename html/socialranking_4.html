<div class="container">

<table style="width: 100%;"><tr>
<td>testRelation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test relation between two elements</h2>

<h3>Description</h3>

<p>On a given <code>PowerRelation</code> object <code>pr</code>, check if <code>e1</code> relates to <code>e2</code> based on the given social ranking solution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">testRelation(powerRelation, e1)

powerRelation %:% e1

pr_e1 %&gt;=dom% e2

pr_e1 %&gt;dom% e2

pr_e1 %&gt;=cumuldom% e2

pr_e1 %&gt;cumuldom% e2

pr_e1 %&gt;=cp% e2

pr_e1 %&gt;cp% e2

pr_e1 %&gt;=banz% e2

pr_e1 %&gt;banz% e2

pr_e1 %&gt;=cop% e2

pr_e1 %&gt;cop% e2

pr_e1 %&gt;=ks% e2

pr_e1 %&gt;ks% e2

pr_e1 %&gt;=lex% e2

pr_e1 %&gt;lex% e2

pr_e1 %&gt;=duallex% e2

pr_e1 %&gt;duallex% e2

pr_e1 %&gt;=L1% e2

pr_e1 %&gt;L1% e2

pr_e1 %&gt;=L2% e2

pr_e1 %&gt;L2% e2

pr_e1 %&gt;=LP% e2

pr_e1 %&gt;LP% e2

pr_e1 %&gt;=LPS% e2

pr_e1 %&gt;LPS% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr_e1</code></td>
<td>
<p><code>PowerRelation</code> and <code>e1</code> element, packed into a list using <code>pr %:% e1</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>testRelation</code> is somewhat only used to make the offered comparison operators in the package better discoverable.
</p>
<p><code>testRelation(pr, e1)</code> is equivalent to <code>pr %:% e1</code> and <code>list(pr, e1)</code>. It should be used together with one of the
comparison operators listed in the usage section.
</p>


<h3>Value</h3>

<p><code>testRelation()</code> and <code style="white-space: pre;">⁠%:%⁠</code> returns <code>list(powerRelation, e1)</code>.
</p>
<p>Followed by a <code style="white-space: pre;">⁠%&gt;=comparison%⁠</code> or <code style="white-space: pre;">⁠%&gt;comparison%⁠</code> it returns <code>TRUE</code> or <code>FALSE</code>, depending on the relation between
<code>e1</code> and <code>e2</code>.
</p>


<h3>See Also</h3>

<p>Comparison function: <code>dominates()</code>, <code>cumulativelyDominates()</code>, <code>cpMajorityComparison()</code>.
</p>
<p>Score Functions: <code>ordinalBanzhafScores()</code>, <code>copelandScores()</code>, <code>kramerSimpsonScores()</code>, <code>lexcelScores()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("123 &gt; 12 ~ 13 ~ 23 &gt; 3 &gt; 1 ~ 2 &gt; {}")

# Dominance
stopifnot(pr %:% 1 %&gt;=dom% 2)

# Strict dominance
stopifnot((pr %:% 1 %&gt;dom% 2) == FALSE)

# Cumulative dominance
stopifnot(pr %:% 1 %&gt;=cumuldom% 2)

# Strict cumulative dominance
stopifnot((pr %:% 1 %&gt;cumuldom% 2) == FALSE)

# CP-Majority relation
stopifnot(pr %:% 1 %&gt;=cp% 2)

# Strict CP-Majority relation
stopifnot((pr %:% 1 %&gt;cp% 2) == FALSE)

# Ordinal banzhaf relation
stopifnot(pr %:% 1 %&gt;=banz% 2)

# Strict ordinal banzhaf relation
# (meaning 1 had a strictly higher positive contribution than 2)
stopifnot((pr %:% 1 %&gt;banz% 2) == FALSE)

# Copeland-like method
stopifnot(pr %:% 1 %&gt;=cop% 2)
stopifnot(pr %:% 2 %&gt;=cop% 1)

# Strict Copeland-like method
# (meaning pairwise winning minus pairwise losing comparison of
# 1 is strictly higher than of 2)
stopifnot((pr %:% 1 %&gt;cop% 2) == FALSE)
stopifnot((pr %:% 2 %&gt;cop% 1) == FALSE)
stopifnot(pr %:% 3 %&gt;cop% 1)

# Kramer-Simpson-like method
stopifnot(pr %:% 1 %&gt;=ks% 2)
stopifnot(pr %:% 2 %&gt;=ks% 1)

# Strict Kramer-Simpson-like method
# (meaning ks-score of 1 is actually higher than 2)
stopifnot((pr %:% 2 %&gt;ks% 1) == FALSE)
stopifnot((pr %:% 1 %&gt;ks% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;ks% 1)

# Lexicographical and dual lexicographical excellence
stopifnot(pr %:% 3 %&gt;=lex% 1)
stopifnot(pr %:% 3 %&gt;=duallex% 1)

# Strict lexicographical and dual lexicographical excellence
# (meaning their lexicographical scores don't match)
stopifnot(pr %:% 3 %&gt;lex% 1)
stopifnot(pr %:% 3 %&gt;duallex% 1)

# L^(1) and L^(2)
stopifnot(pr %:% 1 %&gt;=L1% 2)
stopifnot(pr %:% 1 %&gt;=L2% 2)

# Strict L^(1) and L^(2)
stopifnot((pr %:% 1 %&gt;L1% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;L1% 1)

stopifnot((pr %:% 1 %&gt;L2% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;L2% 1)

# L^p and L^p*
stopifnot(pr %:% 1 %&gt;=LP% 2)
stopifnot(pr %:% 1 %&gt;=LPS% 2)

# Strict L^(1) and L^(2)
stopifnot((pr %:% 1 %&gt;LP% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;LP% 1)

stopifnot((pr %:% 1 %&gt;LPS% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;LPS% 1)

</code></pre>


</div>