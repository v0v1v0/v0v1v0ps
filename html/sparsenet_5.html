<div class="container">

<table style="width: 100%;"><tr>
<td>cv.sparsenet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for sparsenet</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for sparsenet, produces a plot,
and returns values for <code>gamma, lambda</code></p>


<h3>Usage</h3>

<pre><code class="language-R">cv.sparsenet(x, y, weights, type.measure = c("mse", "mae"), ...,nfolds = 10,
       foldid, keep=FALSE, trace.it=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>x</code> matrix as in <code>sparsenet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response <code>y</code> as in <code>sparsenet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently two
options:
squared-error (<code>type.measure="mse"</code>) or
mean-absolute error ( <code>type.measure="mae"</code> )
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments that can be passed to <code>sparsenet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is <code>nfolds=3</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying whhat fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>If <code>TRUE</code>, we include the prevalidation array as
component <code>fit.preval</code> on the returned object. Default is
<code>keep = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>TRUE</code>, then we get a printout that shows the
progress</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function runs <code>sparsenet</code> <code>nfolds</code>+1 times; the
first to get the <code>lambda</code> sequence, and then the remainder to
compute the fit with each of the folds omitted. The error is
accumulated, and the average error and standard deviation over the
folds is computed. 
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.sparsenet"</code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits. This is an
<code>nlambda x ngamma</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a matrix shaped like lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda,
      gamma</code> pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting
purposes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparsenet.fit</code></td>
<td>
<p>a fitted sparsenet object for the full data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms.min</code></td>
<td>
<p>values of <code>gamma, lambda</code> that gives minimum
<code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.min</code></td>
<td>
<p>indices for the above</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p><code>gamma, lambda</code> of smallest model (df) such that error is
within 1 standard error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.1se</code></td>
<td>
<p>indices of the above</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Rahul Mazumder, Jerome Friedman and Trevor Hastie
</p>
<p>Maintainer: Trevor Hastie &lt;hastie@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Mazumder, Rahul, Friedman, Jerome and Hastie, Trevor (2011)
<em>SparseNet: Coordinate Descent with Nonconvex Penalties. JASA, Vol 106(495), 1125-38</em>,
<a href="https://hastie.su.domains/public/Papers/Sparsenet/Mazumder-SparseNetCoordinateDescent-2011.pdf">https://hastie.su.domains/public/Papers/Sparsenet/Mazumder-SparseNetCoordinateDescent-2011.pdf</a>
</p>


<h3>See Also</h3>

<p><code>glmnet</code> package,  <code>predict</code>, <code>coef</code>, <code>print</code> and <code>plot</code> methods, and the <code>sparsenet</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">train.data=gendata(100,1000,nonzero=30,rho=0.3,snr=3)
fit=sparsenet(train.data$x,train.data$y)
par(mfrow=c(3,3))
plot(fit)
par(mfrow=c(1,1))
fitcv=cv.sparsenet(train.data$x,train.data$y,trace.it=TRUE)
plot(fitcv)
</code></pre>


</div>