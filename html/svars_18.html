<div class="container">

<table style="width: 100%;"><tr>
<td>mb.boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Moving block bootstrap for IRFs of identified SVARs</h2>

<h3>Description</h3>

<p>Calculating confidence bands for impulse response via moving block bootstrap
</p>


<h3>Usage</h3>

<pre><code class="language-R">mb.boot(
  x,
  design = "recursive",
  b.length = 15,
  n.ahead = 20,
  nboot = 500,
  nc = 1,
  dd = NULL,
  signrest = NULL,
  signcheck = TRUE,
  itermax = 300,
  steptol = 200,
  iter2 = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SVAR object of class "svars"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>character. If design="fixed", a fixed design bootstrap is performed. If design="recursive", a recursive design bootstrap is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.length</code></td>
<td>
<p>Integer. Length of each block</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ahead</code></td>
<td>
<p>Integer specifying the steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>Integer. Number of bootstrap iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>Integer. Number of processor cores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dd</code></td>
<td>
<p>Object of class 'indepTestDist'. A simulated independent sample of the same size as the data.
If not supplied, it will be calculated by the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signrest</code></td>
<td>
<p>A list with vectors containing 1 and -1, e.g. c(1,-1,1), indicating a sign pattern of specific shocks to be tested
with the help of the bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signcheck</code></td>
<td>
<p>Boolean. Whether the sign pattern should be checked for each bootstrap iteration.
Note that this procedure is computationally extremely demanding for high dimensional VARs, since the number of possible permutations of B is K!,
where K is the number of variables in the VAR.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>Integer. Maximum number of iterations for DEoptim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steptol</code></td>
<td>
<p>Numeric. Tolerance for steps without improvement for DEoptim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter2</code></td>
<td>
<p>Integer. Number of iterations for the second optimization</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class "sboot" with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>true</code></td>
<td>
<p>Point estimate of impulse response functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap</code></td>
<td>
<p>List of length "nboot" holding bootstrap impulse response functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE</code></td>
<td>
<p>Bootstrapped standard errors of estimated covariance decomposition
(only if "x" has method "Cramer von-Mises", or "Distance covariances")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>character. Whether a fixed design or recursive design bootstrap is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b_length</code></td>
<td>
<p>Length of each block</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point_estimate</code></td>
<td>
<p>Point estimate of covariance decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_mean</code></td>
<td>
<p>Mean of bootstrapped covariance decompositions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signrest</code></td>
<td>
<p>Evaluated sign pattern</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_complete</code></td>
<td>
<p>Frequency of appearance of the complete sign pattern in all bootstrapped covariance decompositions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_part</code></td>
<td>
<p>Frequency of bootstrapped covariance decompositions which conform the complete predetermined sign pattern. If signrest=NULL,
the frequency of bootstrapped covariance decompositions that hold the same sign pattern as the point estimate is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_part</code></td>
<td>
<p>Frequency of single shocks in all bootstrapped covariance decompositions which accord to a specific predetermined sign pattern</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_bs</code></td>
<td>
<p>Covariance matrix of bootstrapped parameter in impact relations matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Used bootstrap method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Brueggemann, R., Jentsch, C., and Trenkler, C., 2016. Inference in VARs with conditional heteroskedasticity of unknown form. Journal of Econometrics 191, 69-85.<br>
Herwartz, H., 2017. Hodges Lehmann detection of structural shocks -
An analysis of macroeconomic dynamics in the Euro Area, Oxford Bulletin of Economics and Statistics.
</p>


<h3>See Also</h3>

<p><code>id.cvm</code>, <code>id.dc</code>, <code>id.ngml</code>, <code>id.garch</code>, <code>id.cv</code> or <code>id.st</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
summary(x1)

# impulse response analysis with confidence bands
# Checking how often theory based impact relations appear
signrest &lt;- list(demand = c(1,1,1), supply = c(-1,1,1), money = c(-1,-1,1))
bb &lt;- mb.boot(x1, b.length = 15, nboot = 500, n.ahead = 30, nc = 1, signrest = signrest)
summary(bb)

# Plotting IRFs with confidance bands
plot(bb, lowerq = 0.16, upperq = 0.84)

# With different confidence levels
plot(bb, lowerq = c(0.05, 0.1, 0.16), upperq = c(0.95, 0.9, 0.84))

# Halls percentile
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'hall')

# Bonferroni bands
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'bonferroni')


</code></pre>


</div>