<div class="container">

<table style="width: 100%;"><tr>
<td>bootCast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Forecasting Function for ARMA Models via Bootstrap</h2>

<h3>Description</h3>

<p>Point forecasts and the respective forecasting intervals for
autoregressive-moving-average (ARMA) models can be calculated, the latter
via bootstrap, by means of this function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootCast(
  X,
  p = NULL,
  q = NULL,
  include.mean = FALSE,
  n.start = 1000,
  h = 1,
  it = 10000,
  pb = TRUE,
  cores = future::availableCores(),
  alpha = 0.95,
  export.error = FALSE,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a numeric vector that contains the time series that is assumed to
follow an ARMA model ordered from past to present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer value <code class="reqn">\geq 0</code> that defines the AR order
<code class="reqn">p</code> of the underlying ARMA(<code class="reqn">p,q</code>) model within <code>X</code>; is set to
<code>NULL</code> by default; if no value is passed to <code>p</code> but one is passed
to <code>q</code>, <code>p</code> is set to <code>0</code>; if both <code>p</code> and <code>q</code> are
<code>NULL</code>, optimal orders following the BIC for
<code class="reqn">0 \leq p,q \leq 5</code> are chosen; is set to <code>NULL</code> by
default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>an integer value <code class="reqn">\geq 0</code> that defines the MA order
<code class="reqn">q</code> of the underlying ARMA(<code class="reqn">p,q</code>) model within <code>X</code>; is set to
<code>NULL</code> by default; if no value is passed to <code>q</code> but one is passed
to <code>p</code>, <code>q</code> is set to <code>0</code>; if both <code>p</code> and <code>q</code> are
<code>NULL</code>, optimal orders following the BIC for
<code class="reqn">0 \leq p,q \leq 5</code> are chosen; is set to <code>NULL</code> by
default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.mean</code></td>
<td>
<p>a logical value; if set to <code>TRUE</code>, the mean of the
series is also also estimated; if set to <code>FALSE</code>, <code class="reqn">E(X_t) = 0</code> is
assumed; is set to <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.start</code></td>
<td>
<p>an integer that defines the 'burn-in' number
of observations for the simulated ARMA series via bootstrap; is set to
<code>1000</code> by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>an integer that represents the forecasting horizon; if <code class="reqn">n</code> is
the number of observations, point forecasts and forecasting intervals will be
obtained for the time points <code class="reqn">n + 1</code> to <code class="reqn">n + h</code>; is set to
<code>h = 1</code> by default; decimal numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it</code></td>
<td>
<p>an integer that represents the total number of iterations, i.e.,
the number of simulated series; is set to <code>10000</code> by default; decimal
numbers will be rounded off to integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pb</code></td>
<td>
<p>a logical value; for <code>pb = TRUE</code>, a progress bar will be shown
in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>an integer value &gt;0 that states the number of (logical) cores to
use in the bootstrap (or <code>NULL</code>); the default is the maximum number of
available cores
(via <code>future::availableCores</code>); for
<code>cores = NULL</code>, parallel computation is disabled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a numeric vector of length 1 with <code class="reqn">0 &lt; </code> <code>alpha</code>
<code class="reqn"> &lt; 1</code>; the forecasting intervals will be obtained based on the
confidence level (<code class="reqn">100</code><code>alpha</code>)-percent; is set to
<code>alpha = 0.95</code> by default, i.e., a <code class="reqn">95</code>-percent confidence level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export.error</code></td>
<td>
<p>a single logical value; if the argument is set to
<code>TRUE</code>, a list is returned instead of a matrix (<code>FALSE</code>); the
first element of the list is the usual forecasting matrix, whereas the second
element is a matrix with <code>h</code> columns, where each column represents
the calculated forecasting errors for the respective future time point
<code class="reqn">n + 1, n + 2, ..., n + h</code>; is set to <code>FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>a logical value that controls the graphical output; for
<code>plot = TRUE</code>, the original series with the obtained point forecasts
as well as the forecasting intervals will be plotted; for the default
<code>plot = FALSE</code>, no plot will be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for the standard plot function, e.g.,
<code>xlim</code>, <code>type</code>, ... ; arguments with respect to plotted graphs,
e.g., the argument <code>col</code>, only affect the original series <code>X</code>;
please note that in accordance with the argument <code>x</code> (lower case) of the
standard plot function, an additional numeric vector with time points can be
implemented via the argument <code>x</code> (lower case). <code>x</code> should be
valid for the sample observations only, i.e.
<code>length(x) == length(X)</code> should be <code>TRUE</code>, as future time
points will be calculated automatically.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is part of the <code>smoots</code> package and was implemented under
version 1.1.0. For a given time series <code class="reqn">X_t</code>, <code class="reqn">t = 1, 2, ..., n</code>,
the point forecasts and the respective forecasting intervals will be
calculated. It is assumed that the series follows an ARMA(<code class="reqn">p,q</code>) model
</p>
<p style="text-align: center;"><code class="reqn">X_t - \mu = \epsilon_t + \beta_1 (X_{t-1} - \mu) + ... + \beta_p
(X_{t-p} - \mu) + \alpha_1 \epsilon_{t-1} + ... + \alpha_{q}
\epsilon_{t-q},</code>
</p>

<p>where <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_i</code> are real
numbers (for <code class="reqn">i = 1, 2, .., p</code> and <code class="reqn">j = 1, 2, ..., q</code>) and
<code class="reqn">\epsilon_t</code> are i.i.d. (identically and independently
distributed) random variables with zero mean and constant variance.
<code class="reqn">\mu</code> is equal to <code class="reqn">E(X_t)</code>.
</p>
<p>The point forecasts and forecasting intervals for the future periods
<code class="reqn">n + 1, n + 2, ..., n + h</code> will be obtained. With respect to the point
forecasts <code class="reqn">\hat{X}_{n + k}</code>, where <code class="reqn">k = 1, 2, ..., h</code>,
</p>
<p style="text-align: center;"><code class="reqn">\hat{X}_{n + k} = \hat{\mu} + \sum_{i = 1}^{p} \hat{\beta}_{i}
(X_{n + k - i} - \hat{\mu}) + \sum_{j = 1}^{q} \hat{\alpha}_{j}
\hat{\epsilon}_{n + k - j}</code>
</p>

<p>with <code class="reqn">X_{n+k-i} = \hat{X}_{n+k-i}</code> for
<code class="reqn">n+k-i &gt; n</code> and
<code class="reqn">\hat{\epsilon}_{n+k-j} = E(\epsilon_t) = 0</code> for <code class="reqn">n+k-j &gt; n</code> will be applied.
</p>
<p>The forecasting intervals on the other hand are obtained by a forward
bootstrap method that was introduced by Pan and Politis (2016) for
autoregressive models and extended by Lu and Wang (2020) for applications to
autoregressive-moving-average models.
For this purpose, let <code class="reqn">l</code> be the number of the current bootstrap
iteration. Based on the demeaned residuals of the initial ARMA estimation,
different innovation series <code class="reqn">\epsilon_{l,t}^{s}</code> will
be sampled.  The initial coefficient estimates and the sampled innovation
series are then used to simulate a variety of series
<code class="reqn">X_{l,t}^{s}</code>, from which again coefficient estimates will
be obtained. With these newly obtained estimates, proxy residual series
<code class="reqn">\hat{\epsilon}_{l,t}^{s}</code> are calculated for
the original series <code class="reqn">X_t</code>. Subsequently, point forecasts for the
time points <code class="reqn">n + 1</code> to <code class="reqn">n + h</code> are obtained for each iteration
<code class="reqn">l</code> based on the original series <code class="reqn">X_t</code>, the newly obtained
coefficient forecasts and the proxy residual series
<code class="reqn">\epsilon_{l,t}^{s}</code>.
Simultaneously, "true" forecasts, i.e., true future observations, are
simulated. Within each iteration, the difference between the simulated true
forecast and the bootstrapped point forecast is calculated and saved for each
future time point <code class="reqn">n + 1</code> to <code class="reqn">n + h</code>. The result for these time
points are simulated empirical values of the forecasting error. Denote by
<code class="reqn">q_k(.)</code> the quantile of the empirical distribution for the
future time point <code class="reqn">n + k</code>. Given a predefined confidence level
<code>alpha</code>, define <code class="reqn">\alpha_s = (1 -</code> <code>alpha</code><code class="reqn">)/2</code>. The
bootstrapped forecasting interval is then
</p>
<p style="text-align: center;"><code class="reqn">[\hat{X}_{n + k} + q_k(\alpha_s), \hat{X}_{n + k} + q_k(1 -
\alpha_s)],</code>
</p>

<p>i.e., the forecasting intervals are given by the sum of the respective point
forecasts and quantiles of the respective bootstrapped forecasting error
distributions.
</p>
<p>The function <code>bootCast</code> allows for different adjustments to
the forecasting progress. At first, a vector with the values of the observed
time series ordered from past to present has to be passed to the argument
<code>X</code>. Orders <code class="reqn">p</code> and <code class="reqn">q</code> of the underlying ARMA process can be
defined via the arguments <code>p</code> and <code>q</code>. If only one of these orders
is inserted by the user, the other order is automatically set to <code>0</code>. If
none of these arguments are defined, the function will choose orders based on
the Bayesian Information Criterion (BIC) for
<code class="reqn">0 \leq p,q \leq 5</code>. Via the logical argument
<code>include.mean</code> the user can decide, whether to consider the mean of the
series within the estimation process. By means of <code>n.start</code>, the number
of "burn-in" observations for the simulated ARMA processes can be regulated.
These observations are usually used for the processes to build up and then
omitted. Furthermore, the argument <code>h</code> allows for the definition of the
maximum future time point <code class="reqn">n + h</code>. Point forecasts and forecasting
intervals will be returned for the time points <code class="reqn">n + 1</code> to <code class="reqn">n + h</code>.
<code>it</code> corresponds to the number of bootstrap iterations. We recommend a
sufficiently high number of repetitions for maximum accuracy of the results.
Another argument is <code>alpha</code>, which is the equivalent of the confidence
level considered within the calculation of the forecasting intervals, i.e.,
the quantiles <code class="reqn">(1 - </code> <code>alpha</code><code class="reqn">)/2</code> and <code class="reqn">1 - (1 - </code>
<code>alpha</code><code class="reqn">)/2</code> of the bootstrapped forecasting error distribution
will be obtained.
</p>
<p>Since this bootstrap approach needs a lot of computation time, especially for
series with high numbers of observations and when fitting models with many
parameters, parallel computation of the bootstrap iterations is enabled.
With <code>cores</code>, the number of cores can be defined with an integer.
Nonetheless, for <code>cores = NULL</code>, no cluster is created and therefore
the parallel computation is disabled. Note that the bootstrapped results are
fully reproducible for all cluster sizes. The progress of the bootstrap can
be observed in the R console, where a progress bar and the estimated
remaining time are displayed for <code>pb = TRUE</code>.
</p>
<p>If the argument <code>export.error</code> is set to <code>TRUE</code>, the output of
the function is a list instead of a matrix with additional information on
the simulated forecasting errors. For more information see the section
<em>Value</em>.
</p>
<p>For simplicity, the function also incorporates the possibility to directly
create a plot of the output, if the argument <code>plot</code> is set to
<code>TRUE</code>. By the additional and optional arguments <code>...</code>, further
arguments of the standard plot function can be implemented to shape the
returned plot.
</p>
<p>NOTE:
</p>
<p>Within this function, the <code>arima</code> function of the
<code>stats</code> package with its method <code>"CSS-ML"</code> is used throughout
for the estimation of ARMA models. Furthermore, to increase the performance,
C++ code via the <code>Rcpp</code> and
<code>RcppArmadillo</code> packages was
implemented. Also, the <code>future</code> and
<code>future.apply</code> packages are
considered for parallel computation of bootstrap iterations. The progress
of the bootstrap is shown via the
<code>progressr</code> package.
</p>


<h3>Value</h3>

<p>The function returns a <code class="reqn">3</code> by <code class="reqn">h</code> matrix with its columns
representing the future time points and the point forecasts, the lower
bounds of the forecasting intervals and the upper bounds of the
forecasting intervals as the rows. If the argument <code>plot</code> is set to
<code>TRUE</code>, a plot of the forecasting results is created.
</p>
<p>If <code>export.error = TRUE</code> is selected, a list with the following
elements is returned instead.
</p>

<dl>
<dt>fcast</dt>
<dd>
<p>the <code class="reqn">3</code> by <code class="reqn">h</code> matrix forecasting matrix with point
forecasts and bounds of the forecasting intervals.</p>
</dd>
<dt>error</dt>
<dd>
<p>a <code>it</code> by <code class="reqn">h</code> matrix, where each column represents a
future time point <code class="reqn">n + 1, n + 2, ..., n + h</code>; in each column the
respective <code>it</code> simulated forecasting errors are saved.</p>
</dd>
</dl>
<h3>Author(s)</h3>


<ul><li>
<p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br>
Package Creator and Maintainer
</p>
</li></ul>
<h3>References</h3>

<p>Feng, Y., Gries, T. and Fritz, M. (2020). Data-driven
local polynomial for the trend and its derivatives in economic time
series. Journal of Nonparametric Statistics, 32:2, 510-533.
</p>
<p>Feng, Y., Gries, T., Letmathe, S. and Schulz, D. (2019). The smoots package
in R for semiparametric modeling of trend stationary time series. Discussion
Paper. Paderborn University. Unpublished.
</p>
<p>Feng, Y., Gries, T., Fritz, M., Letmathe, S. and Schulz, D. (2020).
Diagnosing the trend and bootstrapping the forecasting intervals using a
semiparametric ARMA. Discussion Paper. Paderborn University. Unpublished.
</p>
<p>Lu, X., and Wang, L. (2020). Bootstrap prediction interval for ARMA models
with unknown orders. REVSTAT–Statistical Journal, 18:3, 375-396.
</p>
<p>Pan, L. and Politis, D. N. (2016). Bootstrap prediction intervals for linear,
nonlinear and nonparametric autoregressions. In: Journal of Statistical
Planning and Inference 177, pp. 1-27.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example 1: Simulated ARMA process ###

# Function for drawing from a demeaned chi-squared distribution
rchisq0 &lt;- function(n, df, npc = 0) {
 rchisq(n, df, npc) - df
}

# Simulation of the underlying process
n &lt;- 2000
n.start = 1000
set.seed(23)
X &lt;- arima.sim(model = list(ar = c(1.2, -0.7), ma = 0.63), n = n,
 rand.gen = rchisq0, n.start = n.start, df = 3) + 13.1

# Quick application with low number of iterations
# (not recommended in practice)
result &lt;- bootCast(X = X, p = 2, q = 1, include.mean = TRUE,
 n.start = n.start, h = 5, it = 10, cores = 2, plot = TRUE,
 lty = 3, col = "forestgreen", xlim = c(1950, 2005), type = "b",
 main = "Exemplary title", pch = "*")
result

### Example 2: Application with more iterations ###
## Not run: 
result2 &lt;- bootCast(X = X, p = 2, q = 1, include.mean = TRUE,
 n.start = n.start, h = 5, it = 10000, cores = 2, plot = TRUE,
 lty = 3, col = "forestgreen", xlim = c(1950, 2005),
 main = "Exemplary title")
result2


## End(Not run)
</code></pre>


</div>