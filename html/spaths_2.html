<div class="container">

<table style="width: 100%;"><tr>
<td>shortest_paths</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shortest Paths and/ or Distances between Locations</h2>

<h3>Description</h3>

<p>The shortest paths and/ or distance between locations in a grid according to Dijkstra's (1959) algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">shortest_paths(
  rst,
  origins,
  destinations = NULL,
  output = c("distances", "lines", "both"),
  output_class = NULL,
  origin_names = NULL,
  destination_names = NULL,
  pairwise = FALSE,
  contiguity = c("queen", "rook"),
  spherical = TRUE,
  radius = 6371010,
  extent = NULL,
  dist_comp = c("spaths", "terra"),
  tr_fun = NULL,
  v_matrix = FALSE,
  tr_directed = TRUE,
  pre = TRUE,
  early_stopping = TRUE,
  bidirectional = FALSE,
  update_rst = NULL,
  touches = TRUE,
  ncores = NULL,
  par_lvl = c("update_rst", "points"),
  show_progress = FALSE,
  bar_limit = 150L,
  path_type = c("int", "unsigned short int"),
  distance_type = c("double", "float", "int", "unsigned short int")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rst</code></td>
<td>
<p>SpatRaster (terra), RasterLayer (raster), matrix, or list of matrices object. RasterLayers are converted to SpatRasters. Pixels with non-NA 
values in all layers mark the cells through which the algorithm may pass. The values of <code>rst</code> can be accessed in <code>tr_fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origins</code></td>
<td>
<p>Origin points at which the shortest paths start. If <code>rst</code> is a SpatRaster or RasterLayer object, these points can be passed as a 
single SpatVector (terra), sf (sf), or Spatial* (sp) object. sf and sp objects are converted to SpatVectors. Polygons and lines are converted to points 
using their centroid. If <code>rst</code> is a matrix or list of matrices, <code>origins</code> must be a single matrix, data.frame, or data.table of coordinates 
with columns named <code>"x"</code> and <code>"y"</code>. The coordinates must refer to points in the reference system that <code>rst</code> utilizes. Lines and 
polygons are thus not accepted in this case. Details on which points the function connects are outlined below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>destinations</code></td>
<td>
<p>Destination points to which the shortest paths are derived. It defaults to <code>NULL</code>, resulting in the function to compute 
shortest paths between the <code>origins</code> points. Otherwise, the same input rules as for <code>origins</code> apply. Details on which points the function 
connects are outlined below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p><code>"distances"</code> (default), <code>"lines"</code>, or <code>"both"</code>. <code>"distances"</code> lists the total transition costs along the shortest 
paths. By default, it is the distance between origin and destination in meters, if <code>rst</code> is an unprojected SpatRaster or RasterLayer or if 
<code>dist_comp = "terra"</code>. Otherwise, it is denoted in the projection's units. If you pass another function to <code>tr_fun</code>, the total transition cost 
is measured in the units of <code>tr_fun</code>'s results. <code>"lines"</code> returns the shortest paths as spatial lines. <code>"both"</code> returns both distances 
and lines. <code>"distances"</code> is faster and requires less RAM than <code>"lines"</code> or <code>"both"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_class</code></td>
<td>
<p>Class of the returned object. With <code>output = "distances"</code>, the options are <code>"data.table"</code> (default) and 
<code>"data.frame"</code>. With <code>output = "lines"</code> or <code>output = "both"</code>, the options are <code>"SpatVector"</code> (default when <code>rst</code> is a 
SpatRaster or RasterLayer) and <code>"list"</code> (default when <code>rst</code> is a matrix or a list of matrices). In the case of <code>"list"</code>, the attributes, 
the line coordinates, and the CRS are returned as individual list elements. The first element in the list of line coordinates refers to the first row in 
the attributes table etc. <code>"SpatVector"</code> is only available with a SpatRaster or RasterLayer <code>rst</code>. <code>output_class</code> changes the format of 
the returned object, not the information it contains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin_names</code></td>
<td>
<p>Character specifying the name of the column in the <code>origins</code> object used to label the origins in the output object. It 
defaults to row numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>destination_names</code></td>
<td>
<p>Character specifying the name of the column in the <code>destinations</code> object used to label the destinations in the output 
object. It defaults to row numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairwise</code></td>
<td>
<p>Logical specifying whether to compute pairwise paths, if <code>origins</code> and <code>destinations</code> have equally many rows. If <code>TRUE</code>, 
the function computes the shortest path between the first origin and the first destination, the second origin and the second destination, etc. 
Otherwise, it derives the shortest paths from all origins to all destinations. <code>pairwise = TRUE</code> can alter the order in which results are returned. 
Check the output's origins and destinations columns for the respective order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contiguity</code></td>
<td>
<p><code>"queen"</code> (default) for queen's case contiguity or <code>"rook"</code> for rook's case contiguity. In the latter case, the algorithm 
only moves between horizontally or vertically adjacent cells. In the former case, it is also travels between diagonally adjacent cells. <code>"rook"</code> is 
more efficient than <code>"queen"</code> as it implies fewer edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spherical</code></td>
<td>
<p>Logical specifying whether coordinates are unprojected, i.e. lonlat, and refer to a sphere, e.g. a planet, if <code>rst</code> is a matrix or 
a list of matrices. It defaults to <code>TRUE</code>. If <code>FALSE</code>, the function assumes the coordinates to originate from a planar projection. This 
argument has no effect when <code>rst</code> is a SpatRaster or RasterLayer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Radius of the object, e.g. planet, if <code>spherical = TRUE</code>. This argument has no effect when <code>rst</code> is a SpatRaster or RasterLayer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extent</code></td>
<td>
<p>Vector of length 4, specifying the extent of <code>rst</code>, if <code>rst</code> is a matrix or a list of matrices. It must contain xmin, xmax, 
ymin, and ymax, in that order. The argument has no effect when <code>rst</code> is a SpatRaster or RasterLayer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_comp</code></td>
<td>
<p>Method to compute distances between adjacent cells. <code>"spaths"</code> (default) or <code>"terra"</code>. The default <code>"spaths"</code> uses 
spherical (Haversine) distances in case of lonlat data and planar (Euclidean) distances in case of projected (non-lonlat) data. The functions are 
optimized based on the fact that many inter-pixel distances are identical. Modelling the planet as a perfect sphere is in line with e.g. the s2 package, 
but is of course an oversimplification. With <code>"terra"</code>, the function derives distances via <code>terra::distance</code>. Because this computes all 
inter-pixel distances separately, it is slower than the <code>"spaths"</code> approach. It does take the non-spherical nature of the planet into account 
though. With <code>tr_fun</code>, you can specify a custom distance function that uses neither <code>"spaths"</code> nor <code>"terra"</code> distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr_fun</code></td>
<td>
<p>The transition function based on which to compute edge weights, i.e. the travel cost between adjacent grid cells. Defaults to the 
geographic distance between pixel centroids. Permitted function parameter names are <code>d</code> (distance between the pixel centroids), <code>x1</code> (x 
coordinate or longitude of the first cell), <code>x2</code> (x coordinate or longitude of the second cell), <code>y1</code> (y coordinate or latitude of the first cell), 
<code>y2</code> (y coordinate or latitude of the second cell), <code>v1</code> (<code>rst</code> layers' values from the first cell), <code>v2</code> (<code>rst</code> layers' 
values from the second cell), and <code>nc</code> (number of CPU cores according to the <code>ncores</code> argument). If the data is unprojected, i.e. lonlat, or 
if <code>dist_comp = "terra"</code>, <code>d</code> is measured in meters. Otherwise, it uses the units of the CRS. If <code>rst</code> has one layer, the values are 
passed to <code>v1</code> and <code>v2</code> as vectors, otherwise they are passed as a data table where the first column refers to the first layer, the second 
column to the second layer etc. Note that data tables are data frames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v_matrix</code></td>
<td>
<p>Logical specifying whether to pass values to <code>v1</code> and <code>v2</code> in <code>tr_fun</code> as matrices (<code>TRUE</code>) instead of data tables 
in the multi-layer case and vectors in the single-layer case (<code>FALSE</code>). It defaults to <code>FALSE</code>. Setting it to <code>TRUE</code> might e.g. be 
useful when defining <code>tr_fun</code> as a C++ Armadillo function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr_directed</code></td>
<td>
<p>Logical specifying whether <code>tr_fun</code> creates a directed graph. In a directed graph, transition costs can be asymmetric. 
Traveling from cells A to B may imply a different cost than traveling from B to A. It defaults to <code>TRUE</code> and only has an effect when 
<code>tr_fun</code> is not <code>NULL</code>. The default without <code>tr_fun</code> constructs an undirected graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>
<p>Logical specifying whether to compute the distances between neighboring cells before executing the shortest paths algorithm in C++. 
<code>pre</code> only has an effect, when no <code>tr_fun</code> is specified and <code>dist_comp = "spaths"</code>, as the distances are otherwise imported from R. 
<code>TRUE</code> (default) is in the vast majority of cases faster than <code>FALSE</code>. <code>FALSE</code> computes distances between neighboring cells while the 
shortest paths algorithm traverses the graph. This requires less RAM, but is slower than <code>TRUE</code>, unless <code>early_stopping = TRUE</code> and all points 
are close to each other. <code>TRUE</code>'s speed advantage is even larger, when <code>update_rst</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping</code></td>
<td>
<p>Logical specifying whether to stop the shortest path algorithm once the target cells are reached. It defaults to <code>TRUE</code>, 
which can be faster than <code>FALSE</code>, if the points are close to each other compared to the full set of <code>rst</code> cells. If at least one points 
pair is far from each other, <code>FALSE</code> is the faster setting. <code>FALSE</code> computes the distance to all cells and then extracts the distance to the 
target cells. It, therefore, does not check for each visited cell, whether it is in the set of targets. <code>TRUE</code> and <code>FALSE</code> produce the same 
result and only differ in terms of computational performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bidirectional</code></td>
<td>
<p>Logical specifying whether to produce paths or distances in both directions, if destinations are not specified and no directed 
transition function is given. In that case, the distance and the path from point A to point B is the same as the distance and path from point B to point 
A. <code>FALSE</code> (default) only returns distances or paths in one direction. Declaring <code>TRUE</code> returns distances or paths in both directions. This 
parameter's objective is to control the return object's RAM requirement. It only has an effect, if destinations are not specified and no directed 
transition function is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_rst</code></td>
<td>
<p>Object updating <code>rst</code> with moving barriers. It defaults to <code>NULL</code>, corresponding to <code>rst</code> not being updated. If 
<code>rst</code> is a SpatRaster or RasterLayer, <code>update_rst</code> can be a SpatVector (terra), sf (sf), or Spatial* (sp) object, or a list of them. sf and sp 
objects are converted to SpatVectors. The function updates <code>rst</code> by setting any cell intersecting with <code>update_rst</code> to NA, thereby not 
allowing the shortest paths algorithm to pass through that cell. <code>update_rst</code> only sets non-NA cells to NA, not vice versa. The elements of 
<code>update_rst</code> always update the unmodified <code>rst</code>. I.e. if <code>update_rst</code> is a list of two polygons, the shortest paths are derived three 
times: once based on the not updated <code>rst</code>, denoted layer 0 in the output, once based on <code>rst</code> updated with the first polygon, referred to as 
layer 1, and once based on <code>rst</code> updated with the second polygon, termed layer 2. The second polygon updates the unmodified <code>rst</code>, not the 
<code>rst</code> updated by the first polygon. If <code>rst</code> is a matrix or a list of matrices, <code>update_rst</code> can be a vector of cell numbers, a matrix, 
or a list of either. Analogously to the SpatRaster case, these objects mark which cells to set to NA. As in terra, cell numbers start with 1 in the top 
left corner and then increase first from left to right and then from top to bottom. The cell numbers in the vector and the NA cells in the matrix 
identify the pixels to set to NA. Accordingly, the matrix is of equal dimensions as <code>rst</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>touches</code></td>
<td>
<p>Logical specifying the <code>touches</code> argument of <code>terra::extract</code> used when <code>update_rst</code> is a SpatVector, sf, or Spatial* 
object. It defaults to <code>TRUE</code>. If <code>FALSE</code>, the function only removes cells on the line render path or with the center point inside a polygon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>An integer specifying the number of CPU cores to use. It defaults to the number of cores installed on the machine. A value of 1 induces a 
single-threaded process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_lvl</code></td>
<td>
<p><code>"points"</code> or <code>"update_rst"</code>, indicating the level at which to parallelize when using multiple cores and <code>update_rst</code> is a 
list. <code>"points"</code> parallelizes over the origin (and destination) point combinations in both the base grid not updated by <code>update_rst</code> and the 
grids updated with <code>update_rst</code>. The default <code>"update_rst"</code> is equivalent to <code>"points"</code> in the base grid, but parallelizes at the 
<code>update_rst</code> list level in the updated grid stage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_progress</code></td>
<td>
<p>Logical specifying whether the function prints messages on progress. It defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bar_limit</code></td>
<td>
<p>Integer specifying until up to how many paths or list elements of <code>update_rst</code> to display a progress bar, if 
<code>show_progress = TRUE</code>. It defaults to 150, in which case the function prints one <code>=</code> per computed path, if there are no more than 150 paths 
requested. In the grids updated with <code>update_rst</code>, the function displays one <code>=</code> per processed <code>update_rst</code> list element, not per path. 
In parallel applications, the progress bar can notably slow the execution as the functions only permit one thread to write to output at a time. Do not 
set the argument too high to avoid R crashes from text buffer overflows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_type</code></td>
<td>
<p>Data type with which C++ stores cell numbers. <code>"int"</code> (default) is the 4 byte signed integers that R also uses and is the fastest 
option. <code>"unsigned short int"</code> is a 2 byte unsigned integer which requires less RAM than <code>"int"</code>, but only works if there are less than 65,535 
non-NA cells and is comparatively slower because it requires type conversions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance_type</code></td>
<td>
<p>Data type with which C++ stores distances. <code>"double"</code> (default) is a double precision 8 byte floating point number. It is the 
fastest and most precise option and also used by R as its <code>numeric</code> data type. <code>"float"</code> is a single precision 4 byte floating point number, 
which stores decimal values less precisely than <code>"double"</code> does and is comparatively slower because it requires type conversions. <code>"int"</code> and 
<code>"unsigned short int"</code> are the integer types described in the <code>path_type</code> documentation above. With <code>"int"</code> and 
<code>"unsigned short int"</code>, distances are rounded to integers. When employing these integers types, the distance between any cells in <code>rst</code>, not 
just the cells of interest, must not exceed 2,147,483,647 and 65,535 respectively. The distance difference caused by rounding double values to another 
type can accumulate along the shortest paths and can result in notable distance deviation in the output. The recommendations is to stick with the 
default <code>"double"</code> unless the machine does not have enough RAM to run the function otherwise.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes shortest paths and/ or distance between locations in a grid using Dijkstra's algorithm. Examples are a ship navigating 
around land masses or a hiker traversing mountains.
</p>
<p>Let us explore the ship example to illustrate how <code>shortest_paths</code> works. To compute shortest paths between ports around the world, you start with 
a global SpatRaster, in which all land pixels are set to NA and all ocean pixels are set a non-NA value, e.g. 1. A SpatVector marks port locations as 
points on water pixels. Passing these two objects to the parameters <code>rst</code> and <code>origins</code> respectively derives the shortest paths from each port 
to all other ports conditional on ships solely traversing water pixels and returns the distances, i.e. lengths of these paths. If you are not interested 
in the distances, but in the spatial lines themselves, set <code>output</code> to <code>"lines"</code>. If you want to obtain both, set it to <code>"both"</code>.
</p>
<p>In a different application, you do not want to compute the paths between all ports, but only the paths between the ports on the northern hemisphere and 
the ports on the southern hemisphere, but not the paths between ports within the same hemisphere. To assess this, you split the ports into two 
SpatVectors and pass them to <code>origins</code> and <code>destinations</code> respectively. What if you do not want to connect all orgins to all destinations? Set 
<code>pairwise</code> to <code>TRUE</code> to connect the first origin just to the first destination, the second origin to the second destination, etc.
</p>
<p>By default, the distance or transition cost between adjacent cells of the input grid is the geographic distance between the cells' centroids. What if 
the boat is a sailing vessel that minimizes travel time conditional on wind speed, wind direction, and ocean currents? Construct a SpatRaster with 
three layers containing information on the three variables respectively. Define a transition function that combines the three layers into a travel time 
measure and pass the SpatRaster to <code>rst</code> and this function to <code>tr_fun</code>. <code>tr_fun</code> makes this package very versatile. With custom 
transition functions, you can take this software out of the geo-spatial context and e.g. apply it to biomedical research.
</p>
<p>Going back to the ship routing example, consider that there are hurricanes in the Caribbean. Ships traveling from India to Australia do not care, but 
ships traveling from Mexico to the Netherlands have to go around the storm and must not take the shortest path through the hurricane. You have ten 
SpatVector polygons delineating the extent of the hurricane on ten different days. You want to know what the shortest paths are given that ships must go 
around the polygon on that day. Calling <code>shortest_paths</code> ten times with ten different SpatRasters would be very inefficient. This would assemble 
the graph ten times and recompute also paths unaffected by the hurricanes, such as the path between India and Australia, in each iteration. Instead, 
pass the SpatVector polygons to <code>update_rst</code>. <code>shortest_paths</code> then produces the shortest paths for a hurricane-free route and all ten 
hurricane days, only reestimating the paths that are affected by the hurricane polygon on a specific day.
</p>
<p>Applications to Earth should always pass a SpatRaster or RasterLayer to <code>rst</code>. The option to use a matrix or a list of matrices is meant for 
applications to other planets, non-geo-spatial settings, and users who cannot install the terra package on their system.
</p>
<p>The largest source of runtime inefficiency is the quantity of non-NA pixels in the <code>rst</code> grid. Limit the <code>rst</code> argument to the relevant area. 
E.g. crop the grid to the North Atlantic when computing shipping routes between Canada and France. And set regions through which the shortest path does 
certainly not pass to NA.
</p>
<p><code>shortest_paths</code> is optimized for computational performance. Most of its functions are written in C++ and it does not use a general purpose graph 
library, but comes with its custom graph-theoritical implementation tailored to gridded inputs.
</p>
<p>The <a href="../doc/spaths_introduction.html">vignette</a> provides further details on the package.
</p>


<h3>Value</h3>

<p>If 'output = "distances"', the output is by default returned as a data table. If you want the result to be a data frame only, not a data table, 
set 'output_class' to '"data.frame"'. If 'output' is '"lines"' or '"both"', the the function returns a SpatVector, if 'rst' is a SpatRaster or a 
RasterLayer, and a list, if 'rst' is a matrix or a list of matrices. Explicitly setting 'output_class' to '"list"' returns a list in any case. 
'output_class = "SpatVector"', however, returns a SpatVector only if 'rst' is a SpatRaster or a RasterLayer.
</p>
<p>If <code>output = "distances"</code> or <code>output = "both"</code>, the <code>distances</code> variable marks which points are connected. Unconnected point pairs have 
an <code>Inf</code> distance, if <code>distance_type = "double"</code> or <code>distance_type = "float"</code>, and an NA distance, if <code>distance_type = "int"</code> or 
<code>distance_type = "unsigned short int"</code>. If <code>output = "lines"</code>, the <code>connected</code> variable marks which points are connected. Points are 
connected, when it is possible to travel between them via non-NA cells in <code>rst</code>.
</p>


<h3>References</h3>

<p>Dijkstra, E. W. 1959. "A note on two problems in connexion with graphs." <em>Numerische Mathematik</em> 1 (1): 269–71.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Generate example data
set.seed(2L)
input_grid &lt;- terra::rast(crs = "epsg:4326", resolution = 2, vals = sample(c(1L, NA_integer_),
  16200L, TRUE, c(0.8, 0.2)))
origin_pts &lt;- rnd_locations(5L, output_type = "SpatVector")
origin_pts$name &lt;- sample(letters, 5)
destination_pts &lt;- rnd_locations(5L, output_type = "SpatVector")

# Compute distances
shortest_paths(input_grid, origin_pts)
shortest_paths(input_grid, origin_pts, bidirectional = TRUE)
shortest_paths(input_grid, origin_pts, destination_pts)
shortest_paths(input_grid, origin_pts, origin_names = "name")
shortest_paths(input_grid, origin_pts, destination_pts, pairwise = TRUE)

# Compute lines
shortest_paths(input_grid, origin_pts, output = "lines")

# Compute distances and lines
shortest_paths(input_grid, origin_pts, output = "both")

# Use custom transition function
input_grid[input_grid == 1L] &lt;- stats::runif(terra::freq(input_grid, value = 1L)$count,
  max = 1000)
shortest_paths(input_grid, origin_pts, tr_fun = function(d, v1, v2) sqrt(d^2 + abs(v2 - v1)^2),
  tr_directed = FALSE)

# Compute distances with grid updating
barrier &lt;- terra::vect("POLYGON ((-179 1, 30 1, 30 0, -179 0, -179 1))", crs = "epsg:4326")
shortest_paths(input_grid, origin_pts, update_rst = barrier)
barriers &lt;- list(barrier, terra::vect("POLYGON ((0 0, 0 89, 1 89, 1 0, 0 0))",
  crs = "epsg:4326"))
shortest_paths(input_grid, origin_pts, update_rst = barriers)


</code></pre>


</div>