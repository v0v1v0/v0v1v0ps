<div class="container">

<table style="width: 100%;"><tr>
<td>rec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Recode variables</h2>

<h3>Description</h3>

<p><code>rec()</code> recodes values of variables, where variable
selection is based on variable names or column position, or on
select helpers (see documentation on <code>...</code>). <code>rec_if()</code> is a
scoped variant of <code>rec()</code>, where recoding will be applied only
to those variables that match the logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rec(
  x,
  ...,
  rec,
  as.num = TRUE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_r",
  to.factor = !as.num
)

rec_if(
  x,
  predicate,
  rec,
  as.num = TRUE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_r",
  to.factor = !as.num
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rec</code></td>
<td>
<p>String with recode pairs of old and new values. See 'Details'
for examples. <code>rec_pattern</code> is a convenient function to
create recode strings for grouping variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.label</code></td>
<td>
<p>Optional string, to set variable label attribute for the
returned variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), variable label attribute of <code>x</code> will
be used (if present). If empty, variable label attributes will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>val.labels</code></td>
<td>
<p>Optional character vector, to set value label attributes
of recoded variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), no value labels will be set. Value labels
can also be directly defined in the <code>rec</code>-syntax, see
'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>String value, will be appended to variable (column) names of
<code>x</code>, if <code>x</code> is a data frame. If <code>x</code> is not a data
frame, this argument will be ignored. The default value to suffix
column names in a data frame depends on the function call:
</p>

<ul>
<li>
<p> recoded variables (<code>rec()</code>) will be suffixed with <code>"_r"</code>
</p>
</li>
<li>
<p> recoded variables (<code>recode_to()</code>) will be suffixed with <code>"_r0"</code>
</p>
</li>
<li>
<p> dichotomized variables (<code>dicho()</code>) will be suffixed with <code>"_d"</code>
</p>
</li>
<li>
<p> grouped variables (<code>split_var()</code>) will be suffixed with <code>"_g"</code>
</p>
</li>
<li>
<p> grouped variables (<code>group_var()</code>) will be suffixed with <code>"_gr"</code>
</p>
</li>
<li>
<p> standardized variables (<code>std()</code>) will be suffixed with <code>"_z"</code>
</p>
</li>
<li>
<p> centered variables (<code>center()</code>) will be suffixed with <code>"_c"</code>
</p>
</li>
</ul>
<p>If <code>suffix = ""</code> and <code>append = TRUE</code>, existing variables that
have been recoded/transformed will be overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to.factor</code></td>
<td>
<p>Logical, alias for <code>as.num</code>. If <code>TRUE</code>, return value
will be a factor, not numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>rec</code> string has following syntax:
</p>

<dl>
<dt>recode pairs</dt>
<dd>
<p>each recode pair has to be separated by a <code>;</code>, e.g. <code>rec = "1=1; 2=4; 3=2; 4=3"</code></p>
</dd>
<dt>multiple values</dt>
<dd>
<p>multiple old values that should be recoded into a new single value may be separated with comma, e.g. <code>"1,2=1; 3,4=2"</code></p>
</dd>
<dt>value range</dt>
<dd>
<p>a value range is indicated by a colon, e.g. <code>"1:4=1; 5:8=2"</code> (recodes all values from 1 to 4 into 1, and from 5 to 8 into 2)</p>
</dd>
<dt>value range for doubles</dt>
<dd>
<p>for double vectors (with fractional part), all values within the specified range are recoded; e.g. <code>1:2.5=1;2.6:3=2</code> recodes 1 to 2.5 into 1 and 2.6 to 3 into 2, but 2.55 would not be recoded (since it's not included in any of the specified ranges)</p>
</dd>
<dt>
<code>"min"</code> and <code>"max"</code>
</dt>
<dd>
<p>minimum and maximum values are indicates by <em>min</em> (or <em>lo</em>) and <em>max</em> (or <em>hi</em>), e.g. <code>"min:4=1; 5:max=2"</code> (recodes all values from minimum values of <code>x</code> to 4 into 1, and from 5 to maximum values of <code>x</code> into 2)</p>
</dd>
<dt><code>"else"</code></dt>
<dd>
<p>all other values, which have not been specified yet, are indicated by <em>else</em>, e.g. <code>"3=1; 1=2; else=3"</code> (recodes 3 into 1, 1 into 2 and all other values into 3)</p>
</dd>
<dt><code>"copy"</code></dt>
<dd>
<p>the <code>"else"</code>-token can be combined with <em>copy</em>, indicating that all remaining, not yet recoded values should stay the same (are copied from the original value), e.g. <code>"3=1; 1=2; else=copy"</code> (recodes 3 into 1, 1 into 2 and all other values like 2, 4 or 5 etc. will not be recoded, but copied, see 'Examples')</p>
</dd>
<dt>
<code>NA</code>'s</dt>
<dd>
<p><code>NA</code> values are allowed both as old and new value, e.g. <code>"NA=1; 3:5=NA"</code> (recodes all NA into 1, and all values from 3 to 5 into NA in the new variable)</p>
</dd>
<dt><code>"rev"</code></dt>
<dd>
<p><code>"rev"</code> is a special token that reverses the value order (see 'Examples')</p>
</dd>
<dt>direct value labelling</dt>
<dd>
<p>value labels for new values can be assigned inside the recode pattern by writing the value label in square brackets after defining the new value in a recode pair, e.g. <code>"15:30=1 [young aged]; 31:55=2 [middle aged]; 56:max=3 [old aged]"</code>. See 'Examples'.</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>x</code> with recoded categories. If <code>x</code> is a data frame,
for <code>append = TRUE</code>, <code>x</code> including the recoded variables
as new columns is returned; if <code>append = FALSE</code>, only
the recoded variables will be returned. If <code>append = TRUE</code> and
<code>suffix = ""</code>, recoded variables will replace (overwrite) existing
variables.
</p>


<h3>Note</h3>

<p>Please note following behaviours of the function:
</p>

<ul>
<li>
<p> the <code>"else"</code>-token should always be the last argument in the <code>rec</code>-string.
</p>
</li>
<li>
<p> Non-matching values will be set to <code>NA</code>, unless captured by the <code>"else"</code>-token.
</p>
</li>
<li>
<p> Tagged NA values (see <code>tagged_na</code>) and their value labels will be preserved when copying NA values to the recoded vector with <code>"else=copy"</code>.
</p>
</li>
<li>
<p> Variable label attributes (see, for instance, <code>get_label</code>) are preserved (unless changed via <code>var.label</code>-argument), however, value label attributes are removed (except for <code>"rev"</code>, where present value labels will be automatically reversed as well). Use <code>val.labels</code>-argument to add labels for recoded values.
</p>
</li>
<li>
<p> If <code>x</code> is a data frame, all variables should have the same categories resp. value range (else, see second bullet, <code>NA</code>s are produced).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>set_na</code> for setting <code>NA</code> values, <code>replace_na</code>
to replace <code>NA</code>'s with specific value, <code>recode_to</code>
for re-shifting value ranges and <code>ref_lvl</code> to change the
reference level of (numeric) factors.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(efc)
table(efc$e42dep, useNA = "always")

# replace NA with 5
table(rec(efc$e42dep, rec = "1=1;2=2;3=3;4=4;NA=5"), useNA = "always")

# recode 1 to 2 into 1 and 3 to 4 into 2
table(rec(efc$e42dep, rec = "1,2=1; 3,4=2"), useNA = "always")

# keep value labels. variable label is automatically preserved
library(dplyr)
efc %&gt;%
  select(e42dep) %&gt;%
  rec(rec = "1,2=1; 3,4=2",
      val.labels = c("low dependency", "high dependency")) %&gt;%
  frq()

# works with mutate
efc %&gt;%
  select(e42dep, e17age) %&gt;%
  mutate(dependency_rev = rec(e42dep, rec = "rev")) %&gt;%
  head()

# recode 1 to 3 into 1 and 4 into 2
table(rec(efc$e42dep, rec = "min:3=1; 4=2"), useNA = "always")

# recode 2 to 1 and all others into 2
table(rec(efc$e42dep, rec = "2=1; else=2"), useNA = "always")

# reverse value order
table(rec(efc$e42dep, rec = "rev"), useNA = "always")

# recode only selected values, copy remaining
table(efc$e15relat)
table(rec(efc$e15relat, rec = "1,2,4=1; else=copy"))

# recode variables with same category in a data frame
head(efc[, 6:9])
head(rec(efc[, 6:9], rec = "1=10;2=20;3=30;4=40"))

# recode multiple variables and set value labels via recode-syntax
dummy &lt;- rec(
  efc, c160age, e17age,
  rec = "15:30=1 [young]; 31:55=2 [middle]; 56:max=3 [old]",
  append = FALSE
)
frq(dummy)

# recode variables with same value-range
lapply(
  rec(
    efc, c82cop1, c83cop2, c84cop3,
    rec = "1,2=1; NA=9; else=copy",
    append = FALSE
  ),
  table,
  useNA = "always"
)

# recode character vector
dummy &lt;- c("M", "F", "F", "X")
rec(dummy, rec = "M=Male; F=Female; X=Refused")

# recode numeric to character
rec(efc$e42dep, rec = "1=first;2=2nd;3=third;else=hi") %&gt;% head()

# recode non-numeric factors
data(iris)
table(rec(iris, Species, rec = "setosa=huhu; else=copy", append = FALSE))

# recode floating points
table(rec(
  iris, Sepal.Length, rec = "lo:5=1;5.01:6.5=2;6.501:max=3", append = FALSE
))

# preserve tagged NAs
if (require("haven")) {
  x &lt;- labelled(c(1:3, tagged_na("a", "c", "z"), 4:1),
                c("Agreement" = 1, "Disagreement" = 4, "First" = tagged_na("c"),
                  "Refused" = tagged_na("a"), "Not home" = tagged_na("z")))
  # get current value labels
  x
  # recode 2 into 5; Values of tagged NAs are preserved
  rec(x, rec = "2=5;else=copy")
}

# use select-helpers from dplyr-package
out &lt;- rec(
  efc, contains("cop"), c161sex:c175empl,
  rec = "0,1=0; else=1",
  append = FALSE
)
head(out)

# recode only variables that have a value range from 1-4
p &lt;- function(x) min(x, na.rm = TRUE) &gt; 0 &amp;&amp; max(x, na.rm = TRUE) &lt; 5
out &lt;- rec_if(efc, predicate = p, rec = "1:3=1;4=2;else=copy")
head(out)
</code></pre>


</div>