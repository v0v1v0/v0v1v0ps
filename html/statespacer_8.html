<div class="container">

<table style="width: 100%;"><tr>
<td>statespacer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>State Space Model Fitting</h2>

<h3>Description</h3>

<p>Fits a State Space model as specified by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">statespacer(
  y,
  H_format = NULL,
  local_level_ind = FALSE,
  slope_ind = FALSE,
  BSM_vec = NULL,
  cycle_ind = FALSE,
  addvar_list = NULL,
  level_addvar_list = NULL,
  arima_list = NULL,
  sarima_list = NULL,
  self_spec_list = NULL,
  exclude_level = NULL,
  exclude_slope = NULL,
  exclude_BSM_list = lapply(BSM_vec, function(x) 0),
  exclude_cycle_list = list(0),
  exclude_arima_list = lapply(arima_list, function(x) 0),
  exclude_sarima_list = lapply(sarima_list, function(x) 0),
  damping_factor_ind = rep(TRUE, length(exclude_cycle_list)),
  format_level = NULL,
  format_slope = NULL,
  format_BSM_list = lapply(BSM_vec, function(x) NULL),
  format_cycle_list = lapply(exclude_cycle_list, function(x) NULL),
  format_addvar = NULL,
  format_level_addvar = NULL,
  fit = TRUE,
  initial = 0,
  method = "BFGS",
  control = list(),
  collapse = FALSE,
  diagnostics = TRUE,
  standard_errors = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>N x p matrix containing the N observations of the p
dependent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H_format</code></td>
<td>
<p>Format of the H system matrix,
the variance - covariance matrix of the observation equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local_level_ind</code></td>
<td>
<p>Boolean indicating whether a local level should
be added to the state space model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope_ind</code></td>
<td>
<p>Boolean indicating whether a local level + slope should
be added to the state space model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BSM_vec</code></td>
<td>
<p>Vector containing the BSM seasonalities that have to be added
to the state space model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle_ind</code></td>
<td>
<p>Boolean indicating whether a cycle has to be added
to the state space model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addvar_list</code></td>
<td>
<p>A list containing the explanatory variables for each of
the dependent variables. The list should contain p (number of dependent
variables) elements. Each element of the list should be a N x k_p matrix,
with k_p being the number of explanatory variables for the pth
dependent variable. If no explanatory variables should be added for one
of the dependent variables, then set the corresponding element to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level_addvar_list</code></td>
<td>
<p>A list containing the explanatory variables for
each of the dependent variables. The list should contain p (number of
dependent variables) elements. Each element of the list should be a
N x k_p matrix, with k_p being the number of explanatory variables
for the pth dependent variable. If no explanatory variables should be
added for one of the dependent variables, then set the corresponding
element to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arima_list</code></td>
<td>
<p>Specifications of the ARIMA components, should be a list
containing vectors of length 3 with the following format: <code>c(AR, I, MA)</code>.
Should be a list to allow different ARIMA models for different sets of
dependent variables. Note: The AR and MA coefficients are
constrained such that the AR component is stationary, and the MA
component is invertible.
See Ansley and Kohn (1986) for details about
the transformation used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sarima_list</code></td>
<td>
<p>Specifications of the SARIMA components, should be a list
containing lists that contain 4 named vectors. Vectors should be named:
"s", "ar", "i", "ma". Should be a list of lists to allow different SARIMA
models for different sets of dependent variables. Note: The AR and MA
coefficients are constrained such that the AR components are stationary,
and the MA components are invertible.
See Ansley and Kohn (1986) for details about
the transformation used. Note: For multivariate models, the order of "s"
matters, as matrix multiplication is not commutative!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self_spec_list</code></td>
<td>
<p>A list containing the specification of the self
specified component. See the Details section for extensive details about
the format that must be followed for this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_level</code></td>
<td>
<p>Vector containing the dependent variables that should
not get a local level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_slope</code></td>
<td>
<p>Vector containing the dependent variables that should
not get a slope.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_BSM_list</code></td>
<td>
<p>List of vectors, each vector containing the
dependent variables that should not get the corresponding BSM component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_cycle_list</code></td>
<td>
<p>The dependent variables that should not get the
corresponding cycle component. Should be a list of vectors to allow
different dependent variables to be excluded for different cycles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_arima_list</code></td>
<td>
<p>The dependent variables that should not be
involved in the corresponding ARIMA component. Should be a list of
vectors to allow different dependent variables to be excluded for
different ARIMA components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_sarima_list</code></td>
<td>
<p>The dependent variables that should not be
involved in the corresponding SARIMA component. Should be a list of
vectors to allow different dependent variables to be excluded for
different SARIMA components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>damping_factor_ind</code></td>
<td>
<p>Boolean indicating whether a damping factor should
be included. Must be a vector if multiple cycles are included,
to indicate which cycles should include a damping factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_level</code></td>
<td>
<p>Format of the Q_level system matrix
the variance - covariance matrix of the level state equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_slope</code></td>
<td>
<p>Format of the Q_slope system matrix,
the variance - covariance matrix of the slope state equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_BSM_list</code></td>
<td>
<p>Format of the Q_BSM system matrix,
the variance - covariance matrix of the BSM state equation. Should be a
list to allow different formats for different seasonality periods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_cycle_list</code></td>
<td>
<p>Format of the Q_cycle system matrix,
the variance - covariance matrix of the cycle state equation. Should be a
list to allow different formats for different cycles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_addvar</code></td>
<td>
<p>Format of the Q_addvar system matrix, the
variance - covariance matrix of the explanatory variables state equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_level_addvar</code></td>
<td>
<p>Format of the Q_level_addvar system matrix, the
variance - covariance matrix of the explanatory variables of the level
state equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Boolean indicating whether the model should be fit by an
iterative optimisation procedure. If <code>FALSE</code>, the model is only evaluated
at the initial values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>Vector of initial values for the parameter search.
The initial values are recycled or truncated if too few or too many values
have been specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method that should be used by the <code>optim</code>
or <code>optimr</code> function to estimate the parameters. Only
used if <code>fit = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters for the
<code>optim</code> or <code>optimr</code> function. Only
used if <code>fit = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>Boolean indicating whether the observation vector should be
collapsed. Should only be set to <code>TRUE</code> if the dimensionality of the
observation vector exceeds the dimensionality of the state vector.
If this is the case, computational gains can be achieved by collapsing
the observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostics</code></td>
<td>
<p>Boolean indicating whether diagnostical tests should be
computed. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard_errors</code></td>
<td>
<p>Boolean indicating whether standard errors should be
computed. <span class="pkg">numDeriv</span> must be installed in order to compute the
standard errors! Defaults to <code>TRUE</code> if <span class="pkg">numDeriv</span> is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean indicating whether the progress of the optimisation
procedure should be printed. Only used if <code>fit = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To fit the specified State Space model, one occasionally has to pay careful
attention to the initial values supplied. See
<code>vignette("dictionary", "statespacer")</code> for details.
Initial values should not be too large, as some parameters use the
transformation exp(2x) to ensure non-negative values, they should also not
be too small as some variances might become relatively too close to 0,
relative to the magnitude of y.
</p>
<p>If a component is specified without a <code>format</code>, then the format defaults to a
diagonal <code>format</code>.
</p>
<p><code>self_spec_list</code> provides a means to incorporate a self-specified component
into the State Space model. This argument can only contain any of the
following items, of which some are mandatory:
</p>

<ul>
<li> <p><code>H_spec</code>: Boolean indicating whether the H matrix is self-specified.
Should be <code>TRUE</code>, if you want to specify the H matrix yourself.
</p>
</li>
<li> <p><code>state_num</code> (mandatory): The number of state parameters introduced by the
self-specified component. Must be 0 if only <code>H</code> is self-specified.
</p>
</li>
<li> <p><code>param_num</code>: The number of parameters needed by the self-specified
component. Must be specified and greater than 0 if parameters are needed.
</p>
</li>
<li> <p><code>sys_mat_fun</code>: A function returning a list of system matrices that are
constructed using the parameters. Must have <code>param</code> as an argument. The
items in the list returned should have any of the following names: Z,
Tmat, R, Q, a1, P_star, H. Note: Only the system matrices that depend on
the parameters should be returned by the function!
</p>
</li>
<li> <p><code>sys_mat_input</code>: A list containing additional arguments to <code>sys_mat_fun</code>.
</p>
</li>
<li> <p><code>Z</code>: The Z system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>Tmat</code>: The T system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>R</code>: The R system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>Q</code>: The Q system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>a1</code>: The initial guess of the state vector. Must be a matrix
with one column.
</p>
</li>
<li> <p><code>P_inf</code>: The initial diffuse part of the variance - covariance
matrix of the initial state vector. Must be a matrix.
</p>
</li>
<li> <p><code>P_star</code>: The initial non-diffuse part of the variance - covariance
matrix of the initial state vector if it does not depend on the
parameters. Must be a matrix.
</p>
</li>
<li> <p><code>H</code>: The H system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>transform_fun</code>: Function that returns transformed parameters for which
standard errors have to be computed. Must have <code>param</code> as an argument.
</p>
</li>
<li> <p><code>transform_input</code>: A list containing additional arguments to
<code>transform_fun.</code>
</p>
</li>
<li> <p><code>state_only</code>: The indices of the self specified state that do not play a
role in the observation equations, but only in the state equations. Should
only be used if you want to use <code>collapse = TRUE</code> and have some state
parameters that do not play a role in the observation equations. Does not
have to be specified for <code>collapse = FALSE</code>.
</p>
</li>
</ul>
<p>Note: System matrices should only be specified once and need to be
specified once! That is, system matrices that are returned by <code>sys_mat_fun</code>
should not be specified directly, and vice versa. So, system matrices need
to be either specified directly, or be returned by <code>sys_mat_fun</code>. An
exception holds for the case where you <strong>only</strong> want to specify <code>H</code>
yourself. This will not be checked, so be aware of erroneous output if you
do not follow the guidelines of specifying <code>self_spec_list</code>. If time-varying
system matrices are required, return an array for the time-varying system
matrix instead of a matrix.
</p>


<h3>Value</h3>

<p>A statespacer object containing:
</p>

<ul>
<li> <p><code>function_call</code>: A list containing the input to the function.
</p>
</li>
<li> <p><code>system_matrices</code>: A list containing the system matrices of
the State Space model.
</p>
</li>
<li> <p><code>predicted</code>: A list containing the predicted components of
the State Space model.
</p>
</li>
<li> <p><code>filtered</code>: A list containing the filtered components of
the State Space model.
</p>
</li>
<li> <p><code>smoothed</code>: A list containing the smoothed components of
the State Space model.
</p>
</li>
<li> <p><code>diagnostics</code>: A list containing items useful for diagnostical tests.
</p>
</li>
<li> <p><code>optim</code> (if <code>fit = TRUE</code>): A list containing the variables that are returned
by the <code>optim</code> or <code>optimr</code> function.
</p>
</li>
<li> <p><code>loglik_fun</code>: Function that returns the loglikelihood of the
specified State Space model, as a function of its parameters.
</p>
</li>
<li> <p><code>standard_errors</code> (if <code>standard_errors = TRUE</code>): A list containing the
standard errors of the parameters of the State Space model.
</p>
</li>
</ul>
<p>For extensive details about the object returned,
see <code>vignette("dictionary", "statespacer")</code>.
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>References</h3>

<p>Durbin J, Koopman SJ (2012).
<em>Time series analysis by state space methods</em>.
Oxford university press.
</p>
<p>Ansley CF, Kohn R (1986).
“A note on reparameterizing a vector autoregressive moving average model to enforce stationarity.”
<em>Journal of Statistical Computation and Simulation</em>, <b>24</b>(2), 99–106.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Fits a local level model for the Nile data
library(datasets)
y &lt;- matrix(Nile)
fit &lt;- statespacer(initial = 10, y = y, local_level_ind = TRUE)

# Plots the filtered estimates
plot(
  1871:1970, fit$function_call$y,
  type = "p", ylim = c(500, 1400),
  xlab = NA, ylab = NA
)
lines(1871:1970, fit$filtered$level, type = "l")
lines(
  1871:1970, fit$filtered$level +
    1.644854 * sqrt(fit$filtered$P[1, 1, ]),
  type = "l", col = "gray"
)
lines(
  1871:1970, fit$filtered$level -
    1.644854 * sqrt(fit$filtered$P[1, 1, ]),
  type = "l", col = "gray"
)

# Plots the smoothed estimates
plot(
  1871:1970, fit$function_call$y,
  type = "p", ylim = c(500, 1400),
  xlab = NA, ylab = NA
)
lines(1871:1970, fit$smoothed$level, type = "l")
lines(
  1871:1970, fit$smoothed$level +
    1.644854 * sqrt(fit$smoothed$V[1, 1, ]),
  type = "l", col = "gray"
)
lines(
  1871:1970, fit$smoothed$level -
    1.644854 * sqrt(fit$smoothed$V[1, 1, ]),
  type = "l", col = "gray"
)
</code></pre>


</div>