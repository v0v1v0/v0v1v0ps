<div class="container">

<table style="width: 100%;"><tr>
<td>L1Scores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>L1 Ranking</h2>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{(1)}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">L1Scores(powerRelation, elements = powerRelation$elements)

L1Ranking(powerRelation)

lexcel1Scores(powerRelation, elements = powerRelation$elements)

lexcel1Ranking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>powerRelation</code></td>
<td>
<p>A <code>PowerRelation</code> object created by <code>PowerRelation()</code> or <code>as.PowerRelation()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Similar to <code>lexcelRanking()</code>, the number of times an element appears in each equivalence class is counted.
In addition, we now also consider the size of the coalitions.
</p>
<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>The <code class="reqn">L^{(1)}</code> rewards elements that appear in higher ranking coalitions as well as in smaller coalitions.
When comparing two matrices for a power relation, if <code class="reqn">M^\succsim_i &gt;_{L^{(1)}} M^\succsim_j</code>,
this suggests that there exists a <code class="reqn">p^0 \in \{1, \dots, |N|\}</code> and <code class="reqn">q^0 \in \{1, \dots, m\}</code> such that the following holds:
</p>

<ol>
<li> <p><code class="reqn">(M^\succsim_i)_{p^0,q^0} &gt; (M^\succsim_j)_{p^0,q^0}</code>
</p>
</li>
<li> <p><code class="reqn">(M^\succsim_i)_{p,q^0} = (M^\succsim_j)_{p,q^0}</code> for all <code class="reqn">p &lt; p^0</code>
</p>
</li>
<li> <p><code class="reqn">(M^\succsim_i)_{p,q} = (M^\succsim_j)_{p,q}</code> for all <code class="reqn">q &lt; q^0</code> and <code class="reqn">p \in \{1, \dots, |N|\}</code>
</p>
</li>
</ol>
<h3>Value</h3>

<p>Score function returns a list of type <code>L1Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>powerRelation$eqs</code>, the number of
times the given element appears in each equivalence class.
</p>
<p>Ranking function returns corresponding <code>SocialRanking</code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 13 \sim 2) \succ (12 \sim 1 \sim 3) \succ (23 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 1 &amp; 0\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p>From <code class="reqn">(M^\succsim_2)_{1,1} &gt; (M^\succsim_1)_{1,1}</code> and <code class="reqn">(M^\succsim_2)_{1,1} &gt; (M^\succsim_3)_{1,1}</code> it
immediately follows that <code class="reqn">2</code> is ranked above <code class="reqn">1</code> and <code class="reqn">3</code> according to <code class="reqn">L^{(1)}</code>.
</p>
<p>Comparing <code class="reqn">1</code> against <code class="reqn">3</code> we can set <code class="reqn">p^0 = 2</code> and <code class="reqn">q^0 = 2</code>.
Following the constraints from the definition above, we can verify that the entire column 1 is identical.
In column 2, we determine that <code class="reqn">(M^\succsim_1)_{1,q^0} = (M^\succsim_3)_{1,q^0}</code>, whereas
<code class="reqn">(M^\succsim_1)_{p^0,q^0} &gt; (M^\succsim_3)_{p^0,q^0}</code>, indicating that <code class="reqn">1</code>
is ranked higher than <code class="reqn">3</code>, hence <code class="reqn">2 \succ 1 \succ 3</code> according to <code class="reqn">L^{(1)}</code>.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcel1Scores()</code> and <code>lexcel1Ranking()</code> serve as aliases for <code>L1Scores()</code> and <code>L1Ranking()</code>, respectively.
</p>


<h3>References</h3>

<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
“Lexicographic solutions for coalitional rankings.”
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1–33.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code>L2Scores()</code>,
<code>LPSScores()</code>,
<code>LPScores()</code>,
<code>copelandScores()</code>,
<code>cumulativeScores()</code>,
<code>kramerSimpsonScores()</code>,
<code>lexcelScores()</code>,
<code>ordinalBanzhafScores()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pr &lt;- as.PowerRelation("(123 ~ 13 ~ 2) &gt; (12 ~ 1 ~ 3) &gt; (23 ~ {})")
scores &lt;- L1Scores(pr)
scores$`1`
#      [,1] [,2] [,3]
# [1,]    0    1    0
# [2,]    1    1    0
# [3,]    1    0    0

L1Ranking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>


</div>