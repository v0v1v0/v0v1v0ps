<div class="container">

<table style="width: 100%;"><tr>
<td>optimalSpacing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal Detector Spacing</h2>

<h3>Description</h3>

<p>Estimate the detector spacing that yields the greatest precision (lowest RSE D-hat) for a given detector geometry, number of sampling occasions, density and detection parameters. By default this uses only the approximate RSE of Efford and Boulanger (2019), but simulations may also be performed and the optimum found later with <code>minsimRSE</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
optimalSpacing (D, traps, detectpar, noccasions, nrepeats = 1, 
    detectfn = c('HHN', 'HHR', 'HEX','HAN','HCG', 'HN', 'HR', 'EX'),
    fittedmodel = NULL, xsigma = 4, R = seq(0.2, 4, 0.2), CF = 1.0,
    distribution = c("poisson", "binomial"),
    fit.function = c("none", "secr.fit"), 
    simulationR = seq(0.4, 4, 0.4), nrepl = 10, 
    plt = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>population density animals / hectare (constant)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traps</code></td>
<td>
 <p><code>traps</code> object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectpar</code></td>
<td>
<p>named list giving a value for each parameter of detection function (sigma not needed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrepeats</code></td>
<td>
<p>integer number of replicate arrays (not yet used)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function – see detectfn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fittedmodel</code></td>
<td>
<p>secr fitted model (instead of preceding arguments)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xsigma</code></td>
<td>
<p>numeric buffer width as multiple of sigma</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>numeric vector of relative spacings at which to plot rule-of-thumb RSE(D-hat)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CF</code></td>
<td>
<p>numeric correction factor for rule-of-thumb RSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>character distribution of number of individuals detected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.function</code></td>
<td>
<p>character function to use for model fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simulationR</code></td>
<td>
<p>numeric vector of relative spacings at which to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrepl</code></td>
<td>
<p>integer number of replicate simulations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plt</code></td>
<td>
<p>logical; if TRUE then results are plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to various functions (see Details)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A numerical search over possible spacings uses the rule-of-thumb RSE(D-hat) given by <code>minnrRSE</code> as the objective function. 
</p>
<p><code>traps</code> provides the geometry of the detector layout and the initial spacing <code class="reqn">s</code>. Function <code>optimize</code> is used to search for a solution (minimum RSE) in the range of <code>R</code> x <code class="reqn">s</code>.
</p>
<p>The computation emulates variation in detector spacing by inverse variation in sigma (sigma' = sigma / R) with compensating variation in density. Mask buffer width and spacing are also scaled by R.
</p>
<p>If <code>fit.function</code> is "secr.fit" then simulations are also performed for the relative spacings in <code>simulationR</code>. Density, sigma and mask attributes are scaled as for the rule-of-thumb calculations. Using 'method = "none"' gives fast prediction of RSE (from the Hessian evaluated at the known parameter values), but does not estimate bias.
</p>
<p>Simulation results are not summarised as a unique ‘optimal’ spacing. For this apply the method <code>minsimRSE</code> to the resulting object.
</p>
<p>The ... argument may be used to set the values of these arguments:
</p>

<table>
<tr>
<td style="text-align: left;">
Function </td>
<td style="text-align: left;"> Arguments </td>
</tr>
<tr>
<td style="text-align: left;">
make.mask </td>
<td style="text-align: left;"> `nx', `type', `poly',`poly.habitat' </td>
</tr>
<tr>
<td style="text-align: left;">
run.scenarios </td>
<td style="text-align: left;"> `seed', `ncores', `method' </td>
</tr>
<tr>
<td style="text-align: left;">
plot.optimalSpacing </td>
<td style="text-align: left;"> `add', ... </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The argument <code>CF</code> may be set to NA to suppress rule-of-thumb RSE, including optimisation. <code>range(R)</code> specifies the search interval for optimisation.
</p>
<p>A <code>plot</code> method is provided, with options for plotting different components.
</p>


<h3>Value</h3>

<p>List of two components, one for the rule-of-thumb optimisation (rotRSE) and the other for simulation results, if requested (simRSE).
</p>
<p>The optimisation results are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>dataframe with E(n), E(r) and the rule-of-thumb RSE for each requested R</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimum.spacing</code></td>
<td>
<p>the absolute spacing that yields maximum precision (minimum rule-of-thumb RSE(D-hat))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimum.R</code></td>
<td>
<p>spacing relative to sigma</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimum.RSE</code></td>
<td>
<p>final value of the objective function (minimum rule-of-thumb RSE(D-hat))</p>
</td>
</tr>
</table>
<p>The simulation results in the dataframe simRSE are the mean and SE of the simulated RSE(D-hat) for each level of <code>simulationR</code>, with added columns for the relative bias (RB) and relative root-mean-square-error (rRMSE) of D-hat.
</p>
<p>Results are returned invisibly if <code>plt = TRUE</code>.
</p>


<h3>Warnings</h3>

<p>For single-catch traps, use of a maximum likelihood estimate of lambda0 from a fitted multi-catch model results in negative bias.
</p>
<p>Only hazard-based detection functions are supported. The meaning of the ‘sigma’ parameter depends on the function, and so will the optimal spacing in sigma units.
</p>


<h3>Note</h3>

<p>fit.function = 'openCR.fit' was deprecated from 2.5.8 and has been removed as an option</p>


<h3>References</h3>

<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture–recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529–1535. DOI: 10.1111/2041-210X.13239
</p>


<h3>See Also</h3>

<p><code>minnrRSE</code>,
<code>minsimRSE</code>
<code>plot.optimalSpacing</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">
grid &lt;- make.grid(7, 7)  # default multi-catch detector
optimalSpacing(D = 5, traps = grid, detectpar = list(lambda0 = 0.2, sigma = 20), 
   noccasions = 5, plt = TRUE)

## Not run: 

optimalSpacing(D = 5, traps = grid, detectpar = list(lambda0 = 0.4, sigma = 20), 
    detectfn = 'HEX', R = seq(1,6,0.4), noccasions = 10, plt = TRUE, col = "blue")

## with simulations
grid &lt;- make.grid(8, 8, spacing = 20, detector = 'proximity')
optimalSpacing(D = 5, traps = grid, detectfn = "HHN", detectpar = 
    list(lambda0 = 0.2, sigma = 20), noccasions = 5, nrepl = 20, nx = 32, 
    fit.function = "secr.fit", ncores = 4, plt = TRUE, col = "blue")

## manual check
grid &lt;- make.grid(8, 8, spacing = 60, detector = 'proximity')
scen &lt;- make.scenarios(D = 5, detectfn = 14, lambda0 = 0.2, sigma = 20,
    noccasions = 5)
sim1 &lt;- run.scenarios(nrepl = 20, scen, trapset = list(grid), fit = TRUE, 
    fit.args = list(detectfn = 14), ncores = 4, byscenario = FALSE)
summary(sim1)


## End(Not run)

</code></pre>


</div>