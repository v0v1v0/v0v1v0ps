<div class="container">

<table style="width: 100%;"><tr>
<td>estSigmaI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate Abundance Index Sigma</h2>

<h3>Description</h3>

<p>Estimate the effective sigma (magnitude of observation noise) for a
survey or commercial abundance index, based on the empirical standard
deviation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estSigmaI(model, what="s", series=NULL, init=NULL, FUN=mean, p=1,
          digits=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>fitted <code>scape</code> model containing element <code>CPUE</code>
and/or <code>Survey</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>which effective sigma to estimate: <code>"c"</code>[ommercial]
or <code>"s"</code>[urvey] abundance index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>series</code></td>
<td>
<p>vector of strings indicating which gears or surveys to
analyze (all by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>initial sigma, determining the relative pattern of the
effective sigmas between years.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>function to use when scaling a vector of sigmas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>effective number of parameters estimated in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of decimal places to use when rounding, or
<code>NULL</code> to suppress rounding.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>init</code> sigmas set a fixed pattern for the relative sigmas
between years. For example, if there are two years of abundance index
data and the initial sigmas are 0.1 in year 1 and 0.2 in year 2, the
effective sigma will be two times greater in year 2 than in year 1,
although both will be scaled up or down depending on how closely the
model fits the abundance index. The value of <code>init</code> can be one of
the following:
</p>

<dl>
<dt><code>NULL</code></dt>
<dd>
<p>means read the initial sigmas from the existing
<code>CV</code> column (default).</p>
</dd>
<dt>model</dt>
<dd>
<p>means read the initial sigmas from the <code>CV</code> column
in that model (object of class <code>scape</code>).</p>
</dd>
<dt>numeric vector</dt>
<dd>
<p>means those are the initial sigmas (same
length as the number of years).</p>
</dd>
<dt>
<code>FALSE</code> or <code>1</code>
</dt>
<dd>
<p>means use one effective sigma
(<code class="reqn">\hat sigma</code>) across all years.</p>
</dd>
</dl>
<p>The idea behind <code>FUN=mean</code> is to guarantee that regardless of the
value of <code>init</code>, the mean effective sigma will always be the
same. Other functions can be used to a similar effect, such as
<code>FUN=median</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of effective sigmas (one value if <code>init=1</code>), or a
list of such vectors when analyzing multiple series.
</p>


<h3>Note</h3>

<p>This function uses the empirical standard deviation to estimate an
effective sigma, which may be appropriate as likelihood weights for
abundance index data. The better the model fits the data, the smaller
the effective sigma.
</p>
<p><code>estSigmaI</code> can be used iteratively, along with
<code>estN</code> and <code>estSigmaR</code> to assign likelihood
weights that are indicated by the model fit to the data. Sigmas and
sample sizes are then adjusted between model runs, until they
converge. The <code>iterate</code> function facilitates this procedure.
</p>
<p>If <code class="reqn">rss</code> is the residual sum of squares in log space, <code class="reqn">n</code> is
the number of abundance index data points, and <code class="reqn">p</code> is the
effective number of parameters estimated in the model, then the
estimated effective sigma is:
</p>
<p style="text-align: center;"><code class="reqn">\hat\sigma=\sqrt{\frac{rss}{n-p}}</code>
</p>

<p>There is no simple way to calculate <code class="reqn">p</code> for statistical
catch-at-age models. The default value of 1 is likely to underestimate
the true magnitude of observation noise.
</p>


<h3>See Also</h3>

<p><code>getN</code>, <code>getSigmaI</code>, <code>getSigmaR</code>,
<code>estN</code>, <code>estSigmaI</code>, and <code>estSigmaR</code>
extract and estimate sample sizes and sigmas.
</p>
<p><code>iterate</code> combines all the <code>get*</code> and <code>est*</code>
functions in one call.
</p>
<p><code>plotIndex</code> shows what is behind the sigma estimation.
</p>
<p><code>scape-package</code> gives an overview of the package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Exploring candidate sigmas:

getSigmaI(x.cod)       # sigma used in assessment 0.20
estSigmaI(x.cod)       # model fit implies 0.17
plotIndex(x.cod)       # model fit
estSigmaI(x.cod, p=8)  # eight estimated parameters implies 0.22

getSigmaI(x.sbw)          # sigma used in assessment
estSigmaI(x.sbw)          # model fit implies smaller sigma
estSigmaI(x.sbw, init=1)  # could use 0.17 in all years

## Same mean, regardless of init:

mean(estSigmaI(x.sbw, digits=NULL))
mean(estSigmaI(x.sbw, digits=NULL, init=1))

## Same median, regardless of init:

median(estSigmaI(x.sbw, FUN=median, digits=NULL))
median(estSigmaI(x.sbw, FUN=median, digits=NULL, init=1))

## Multiple series:

getSigmaI(x.oreo, "c")                 # sigma used in assessment
getSigmaI(x.oreo, "c", digits=2)       # rounded
estSigmaI(x.oreo, "c")                 # model fit implies smaller sigma
estSigmaI(x.oreo, "c", init=1)         # could use 0.19 in all years
estSigmaI(x.oreo, "c", init=1, digits=3)  # series 2 slightly worse fit
# estSigmaI(x.oreo, "c", init=1, p=11) # more parameters than datapoints

getSigmaI(x.oreo, "c", series="Series 2-1")  # get one series
estSigmaI(x.oreo, "c", series="Series 2-1")  # estimate one series
</code></pre>


</div>