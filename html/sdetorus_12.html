<div class="container">

<table style="width: 100%;"><tr>
<td>crankNicolson1D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crank–Nicolson finite difference scheme for the 1D Fokker–Planck equation with periodic boundaries</h2>

<h3>Description</h3>

<p>Implementation of the Crank–Nicolson scheme for solving the Fokker–Planck equation
</p>
<p style="text-align: center;"><code class="reqn">p(x, t)_t = -(p(x, t) b(x))_x + \frac{1}{2}(\sigma^2(x) p(x, t))_{xx},</code>
</p>

<p>where <code class="reqn">p(x, t)</code> is the transition probability density of the circular diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=b(X_t)dt+\sigma(X_t)dW_t</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">crankNicolson1D(u0, b, sigma2, N, deltat, Mx, deltax, imposePositive = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u0</code></td>
<td>
<p>matrix of size <code>c(Mx, 1)</code> giving the initial condition. Typically, the evaluation of a density highly concentrated at a given point. If <code>nt == 1</code>, then <code>u0</code> can be a matrix <code>c(Mx, nu0)</code> containing different starting values in the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>vector of length <code>Mx</code> containing the evaluation of the drift.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>vector of length <code>Mx</code> containing the evaluation of the squared diffusion coefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>increasing integer vector of length <code>nt</code> giving the indexes of the times at which the solution is desired. The times of the solution are <code>delta * c(0:max(N))[N + 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltat</code></td>
<td>
<p>time step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mx</code></td>
<td>
<p>size of the equispaced spatial grid in <code class="reqn">[-\pi,\pi)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltax</code></td>
<td>
<p>space grid discretization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imposePositive</code></td>
<td>
<p>flag to indicate whether the solution should be transformed in order to be always larger than a given tolerance. This prevents spurious negative values. The tolerance will be taken as <code>imposePositiveTol</code> if this is different from <code>FALSE</code> or <code>0</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function makes use of <code>solvePeriodicTridiag</code> for obtaining implicitly the next step in time of the solution.
</p>
<p>If <code>imposePositive = TRUE</code>, the code implicitly assumes that the solution integrates to one at any step. This might b unrealistic if the initial condition is not properly represented in the grid (for example, highly concentrated density in a sparse grid).
</p>


<h3>Value</h3>


<ul>
<li>
<p> If <code>nt &gt; 1</code>, a matrix of size <code>c(Mx, nt)</code> containing the discretized solution at the required times.
</p>
</li>
<li>
<p> If <code>nt == 1</code>, a matrix of size <code>c(Mx, nu0)</code> containing the discretized solution at a fixed time for different starting values.
</p>
</li>
</ul>
<h3>References</h3>

<p>Thomas, J. W. (1995). <em>Numerical Partial Differential Equations: Finite Difference Methods</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4899-7278-1">doi:10.1007/978-1-4899-7278-1</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Parameters
Mx &lt;- 200
N &lt;- 200
x &lt;- seq(-pi, pi, l = Mx + 1)[-c(Mx + 1)]
times &lt;- seq(0, 1, l = N + 1)
u0 &lt;- dWn1D(x, pi/2, 0.05)
b &lt;- driftWn1D(x, alpha = 1, mu = pi, sigma = 1)
sigma2 &lt;- rep(1, Mx)

# Full trajectory of the solution (including initial condition)
u &lt;- crankNicolson1D(u0 = cbind(u0), b = b, sigma2 = sigma2, N = 0:N,
                     deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx)

# Mass conservation
colMeans(u) * 2 * pi

# Visualization of tpd
plotSurface2D(times, x, z = t(u), levels = seq(0, 3, l = 50))

# Only final time
v &lt;- crankNicolson1D(u0 = cbind(u0), b = b, sigma2 = sigma2, N = N,
                     deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx)
sum(abs(u[, N + 1] - v))
</code></pre>


</div>