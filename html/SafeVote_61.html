<div class="container">

<table style="width: 100%;"><tr>
<td>stv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Count preferential ballots using an STV method</h2>

<h3>Description</h3>

<p>The 'votes' parameter is as described in <code>condorcet()</code> with the following
additional semantics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stv(
  votes,
  nseats = NULL,
  eps = 0.001,
  equal.ranking = FALSE,
  fsep = "\t",
  ties = c("f", "b"),
  quota.hare = FALSE,
  constant.quota = FALSE,
  win.by.elim = TRUE,
  group.nseats = NULL,
  group.members = NULL,
  complete.ranking = FALSE,
  invalid.partial = FALSE,
  verbose = FALSE,
  seed = NULL,
  quiet = FALSE,
  digits = 3,
  backwards.compatible = FALSE,
  safety = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>votes</code></td>
<td>
<p>an array with one column per candidate and one row per ballot,
as described in <code>condorcet()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nseats</code></td>
<td>
<p>the number of seats to be filled in this election</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>fuzz-factor when comparing fractional votes.  The default of 0.001
is preserved from the legacy code, injecting substantial validity hazards
into the codebase.  We have not attempted to mitigate any of these hazards
in 'SafeVote v1.0.0'.  We prefer instead to retain backwards-compatibility
with the legacy code in 'vote_2.3-2' in the knowledge that, even if these
hazards were adequately addressed, the resulting code is unlikely to be
reliable at replicating the results of any other implementation of any of
the many variants of "STV" counting methods.  Please see the description of
the 'a53_hil' dataset in this package for some preliminary findings on the
magnitude of the vote-count-variances which may be injected by differing
implementations of broadly-similar "STV" counting methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal.ranking</code></td>
<td>
<p>if 'TRUE', equal preferences are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsep</code></td>
<td>
<p>column-separator for output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties</code></td>
<td>
<p>vector of tie-breaking methods: ”f” for forward, ”b” for
backward</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quota.hare</code></td>
<td>
<p>'TRUE' if Hare quota, 'FALSE' if Droop quota (default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant.quota</code></td>
<td>
<p>'TRUE' if quota is held constant.  Over-rides
'quota.hare'. Default is 'FALSE'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>win.by.elim</code></td>
<td>
<p>'TRUE' (default) if the quota is waived when there are no
more candidates than vacant seats.  Note: there is no lower limit when the
quota is waived, so a candidate may be elected on zero votes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.nseats</code></td>
<td>
<p>number of seats reserved to members of a group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.members</code></td>
<td>
<p>vector of members of the group with reserved seats</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete.ranking</code></td>
<td>
<p>is 'TRUE' by default.  This parameter is retained
solely for backwards compatibility with <code>vote::stv()</code>. It has no effect on
elections in which 'nseats' is explicitly specified in the call to
<code>stv()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invalid.partial</code></td>
<td>
<p>'TRUE' if ballots which do not specify a complete
ranking of candidates are informal (aka "invalid") <em>i.e.</em> ignored
(with a warning).  Default is 'FALSE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>'TRUE' for diagnostic output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer seed for tie-breaking.  Warning: if non-'NULL', the PRNG
for R is reseeded prior to <em>every</em> random tie-break among the
possibly-elected candidates.  We have preserved this functionality in this
branch to allow regression against the legacy codebase of <code>vote::stv()</code>. In
<code>stv()</code> the default value for seed is 'NULL' rather than the
legacy value of 1234, to mitigate the validity hazard of PRNG reseedings
during a stochastic experiment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>'TRUE' to suppress console output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of significant digits in the output table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backwards.compatible</code></td>
<td>
<p>'TRUE' to regress against vote2_3.2 by
disabling $margins, $fuzz, $rankingTable, $safeRank</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>safety</code></td>
<td>
<p>number of standard deviations on vote-counts, when producing a
safeRank by clustering near-ties in a complete ranking</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>undocumented intent (preserved from legacy code)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default the preferences are not allowed to contain duplicates per ballot.
However, if the argument 'equal.ranking' is set to 'TRUE', ballots are allowed
to have the same ranking for multiple candidates. The desired format is such
that for each preference $i$ that does not have any duplicate, there must be
exactly $i – 1$ preferences $j$ with $0 &lt; j &lt; i$. For example, valid ordered
preferences are '1; 1; 3; 4; …', or '1; 2; 3; 3; 3; 6; …', but NOT '1; 1; 2;
3; …', or NOT '1; 2; 3; 3; 3; 5; 6; …'. If the data contain such invalid
votes, they are automatically corrected and a warning is issued by calling
the 'correct.ranking' function.
</p>
<p>If equal ranking is not allowed ('equal.ranking = FALSE'), the argument
'invalid.partial' can be used to make ballots containing duplicates or gaps
partially valid. If it is 'TRUE', a ballot is considered valid up to a
preference that is in normal case not allowed. For example, ballots '1; 2; 3;
4; 4; 6' or '1; 2; 3; 5; 6; 7' would be both converted into '1; 2; 3; 0; 0;
0', because the ballots contain valid ranking only up to the third
preference.
</p>
<p>By default, ties in the STV algorithm are resolved using the forwards
tie-breaking method, see Newland and Briton (Section 5.2.5). Argument 'ties'
can be set to ”b” in order to use the backwards tie-breaking method, see
O’Neill (2004). In addition, both methods are complemented by the following
“ordered” method: Prior to the STV election candidates are ordered by the
number of first preferences. Equal ranks are resolved by moving to the number
of second preferences, then third and so on. Remaining ties are broken by
random draws. Such complete ordering is used to break any tie that cannot be
resolved by the forwards or backwards method. If there is at least one tie
during the processing, the output contains a row indicating in which count a
tie-break happened (see the 'ties' element in the Value section for an
explanation of the symbols).
</p>
<p>The ordered tiebreaking described above can be analysed from outside of the
'stv' function by using the 'ordered.tiebreak' function for viewing the
a-priori ordering (the highest number is the best and lowest is the worst).
Such ranking is produced by comparing candidates along the columns of the
matrix returned by 'ordered.preferences'.
</p>


<h3>Value</h3>

<p>object of class 'vote.stv'.  Note: the winning margins in this object
are valid for the elected candidates and their (total) ranking, but must be
adjusted within tiegroups to be valid for the candidates' (possibly
partial) safeRank.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(food_election)
stv(food_election, safety = 0.0)
stv(food_election, nseats = 2)

</code></pre>


</div>