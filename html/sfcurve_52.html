<div class="container">

<table style="width: 100%;"><tr>
<td>sfc_2x2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create space-filling curves</h2>

<h3>Description</h3>

<p>Create space-filling curves
</p>


<h3>Usage</h3>

<pre><code class="language-R">sfc_2x2(seed, code = integer(0), rot = 0L)

sfc_3x3_peano(seed, code = integer(0), rot = 0L, level = NULL, flip = FALSE)

sfc_3x3_meander(seed, code = integer(0), rot = 0L, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed sequence. In most cases, the seed sequence is a single base pattern, which can be specified as a single letter, then <code>rot</code> controls
the initial rotation of the base pattern. It also supports a sequence with more than one base patterns as the seed sequence. In this case,
it can be specified as a string of more than one base letters, then <code>rot</code> can be set to a single rotation scalar which controls the rotation of the
first letter, or a vector with the same length as the number of base letters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>A vector of the expansion code. The left side corresponds to the top levels of the curve and the right side corresponds to the bottom level of the curve.
The value can be set as a vector e.g. <code>c(1, 2, 1)</code>, or as a string e.g. <code>"121"</code>, or as a number e.g. <code>121</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rot</code></td>
<td>
<p>Rotation of the seed sequence, measured in the polar coordinate system, in degrees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Specifically for <code>sfc_3x3_peano()</code>, since there is only one expansion code 1, it can also be generated by <code>rep(1, level)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>Whether to use the "flipped" rules? For the Peano curve and the Meander curve, there is also a "fliiped" version
of curve expansion rules. On each level expansion in the Peano curve and the Meander curve, a point expands to nine points in
3x3 grids. Thus the value of <code>flip</code> can be set as a logical vector of length of nine that controls whether to use the flipped expansion
for the corresponding unit. Besides such "1-to-9" mode, <code>flip</code> can also be set as a function which acccepts the number of current points in the curve and return
a logical vector with the same length, i.e. the "all-to-all*9" mode.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li> <p><code>sfc_2x2()</code> generates the Hilbert curve from the seed sequence.
</p>
</li>
<li> <p><code>sfc_3x3_peano()</code> generates the Peano curve from the seed sequence.
</p>
</li>
<li> <p><code>sfc_3x3_meander()</code> generates the Meander curve from the seed sequence.
</p>
</li>
</ul>
<h3>Value</h3>


<ul>
<li> <p><code>sfc_hilbert()</code> returns an <code>sfc_2x2</code> object.
</p>
</li>
<li> <p><code>sfc_peano()</code> returns an <code>sfc_3x3_peano</code> object.
</p>
</li>
<li> <p><code>sfc_meander()</code> returns an <code>sfc_3x3_meander</code> object.
</p>
</li>
</ul>
<p>These three classes are child classes of <code>sfc_nxn</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">sfc_2x2("I", "111") |&gt; plot()
sfc_2x2("I", "111", rot = 90) |&gt; plot()
sfc_2x2("IR", "111", rot = 90) |&gt; plot()
sfc_3x3_peano("I", "111") |&gt; plot()
sfc_3x3_peano("I", "111", 
    flip = c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)) |&gt; plot()
sfc_3x3_peano("IJ", "111") |&gt; plot()

sfc_3x3_peano("I", level = 4, flip = function(p) {
    p@rot %in% c(90, 270)
}) |&gt; plot(lwd = 1)

level = 4
sfc_3x3_peano("I", level = level, flip = function(p) {
     if(length(p) == 9^(level-1)) {
         l = rep(FALSE, length(p))
         ind = 1:9^2 + 9^2*rep(c(0, 2, 4, 6, 8), each = 9^2)
         l[ind] = p@rot[ind] %in% c(90, 270)

         ind = 1:9^2 + 9^2*rep(c(1, 3, 5, 7), each = 9^2)
         l[ind] = p@rot[ind] %in% c(0, 180)

         l
    } else {
         rep(FALSE, length(p))
    }
}) |&gt; plot(lwd = 1)

sfc_3x3_meander("I", "111") |&gt; plot()
sfc_3x3_meander("I", "111", 
    flip = c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)) |&gt; plot()
sfc_3x3_meander("IR", "111") |&gt; plot()
</code></pre>


</div>