<div class="container">

<table style="width: 100%;"><tr>
<td>estimate.bounds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Bounds on Response Time Cumulative Distribution Functions for Parallel Processing Models
</h2>

<h3>Description</h3>

<p>Calculates the bounds on the range of cumulative distribution functions for response time data for parallel processing models under specified stopping rules (OR, AND, or Single-Target Self-Terminating).
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate.bounds(RT, CR = NULL, stopping.rule = c("OR","AND","STST"), 
  assume.ID=FALSE, numchannels=NULL, unified.space=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>RT</code></td>
<td>
<p>A list of numeric response time arrays for the individual processing channels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopping.rule</code></td>
<td>
<p>A character string specifying the stopping rule for the parallel processing model; must be one of "OR", "AND", "STST". If NULL, then "OR" is the default model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assume.ID</code></td>
<td>
<p>A logical indicating whether the individual channel distributions are assumed to be Identically Distributed (ID). If FALSE, non-ID distributions are estimated from the RT data. If TRUE, only the first array in RT is used, together with numchannels, to estimate the distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numchannels</code></td>
<td>
<p>Number of channels in the parallel processing model when all channels are active. If NULL,number channels will be estimated equal to length of RT.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unified.space</code></td>
<td>
<p>A logical indicating whether the unified capacity space version of the bounds should be estimated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <em>estimate.bounds</em> function uses the response times from individual channels processing in isolation to estimae the response time distributions for an <code class="reqn">n</code>-channel parallel model. The input argument RT must be a list of numeric arrays, containing either one array for each of the <code class="reqn">n</code> channels to be estimated (so length(RT)=n), or it can have length(RT)=1 and the bounds can be found under an assumption that the <code class="reqn">n</code> channels are identically distributed to the data in RT. For this latter case, assume.ID=TRUE and numchannels=n (where <code class="reqn">n \ge 2</code>) must be specified.
</p>
<p>Standard unlimited capacity parallel processing models for <code class="reqn">n</code> simultaneously operating channels can produce a range of behavior, which is bounded by various functions derived from the probability distributions on each of the <code class="reqn">i</code>, for <code class="reqn">i=1,\ldots,n</code>, channels operating in isolation. These bounds depend on the stopping rule under which is the parallel model is assumed to be operating (OR, AND, or STST).
</p>
<p><em>stopping.rule="OR"</em>
</p>
<p>Let <code class="reqn">F_{n}(t)=P[RT \le t]=P[min(T_{i}) \le t]</code> for <code class="reqn">i=1,...,n</code>, denote the cumulative distribution of response times under a minimum time (logical OR) stopping rule.
The general bounds for n-channel parallel processing under an OR stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">max_{i}F^{i}_{n-1}(t) \le F_{n}(t) \le min_{i,j}[F^{i}_{n-1}(t) + F^{j}_{n-1}(t) - F^{ij}_{n-2}(t)]</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">F_{n-1}(t) \le F_{n}(t) \le [2*F_{n-1}(t) - F_{n-2}(t)]</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">F^{i}_{1}(t) \le F_{2}(t) \le [F^{i}_{1}(t) + F^{j}_{1}(t)]</code>
</p>

<p><em>stopping.rule="AND"</em>
</p>
<p>Let <code class="reqn">G_{n}(t)=P[RT \le t]=P[max(T_i) \le t]</code>, for <code class="reqn">i=1,...,n</code>, denote the cumulative distribution of repsonse times under a maximum time (logical AND, ehxaustive) stopping rule.
The general bounds for n-channel parallel processing under an AND stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">max_{i,j}[G^{i}_{n-1}(t) + G^{j}_{n-1}(t) - G^{ij}_{n-2}(t)] \le G_{n}(t) \le min_{i}G^{i}_{n-1}(t)</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">[2*G_{n-1}(t) - G_{n-2}(t)] \le G_{n}(t) \le G_{n-1}(t)</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">[G^{i}_{1}(t) + G^{j}_{1}(t) - 1] \le G_{2}(t) \le G^{i}_{1}(t)</code>
</p>

<p><em>stopping.rule="STST"</em>
</p>
<p>Let <code class="reqn">F_{k}(t)=P[RT \le t]</code> denote the cumulative distribution of repsonse times under a single-target self-terminating (STST) stopping rule, where the target of interest is on processing channel <code class="reqn">k</code> among <code class="reqn">n</code> active channels.
The general bounds for n-channel parallel processing under an STST stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">\prod_{i=1}^{n} F_{1}(t) \le F_{k}(t) \le \sum_{i=1}^{n} F_{1}(t)</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">[F_{1}(t)]^{n} \le F_{k}(t) \le n*F_{1}(t)</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">[F^{i}_{1}(t) * F^{j}_{1}(t)] \le F_{k}(t) \le [F^{i}_{1}(t) + F^{j}_{1}(t)]</code>
</p>

<p>Note that in this case, <code class="reqn">k=i</code> or <code class="reqn">k=j</code>, but this may not be specifiable <em>a priori</em> depending on experimental design.
</p>
<p>Across all stopping rule conditions, violation of the upper bound indicates performance that is faster than can be predicted by an unlimited capacity parallel model. This may arise from positive (facilitatory) crosstalk between parallel channels, super capacity parallel processing, or some form of co-active architecture in the measured human response time data.
</p>
<p>Violation of the lower bound indicates performance that is slower than predictd by an unlimited capacity parallel model. This may arise from negative (inhibitory) crosstalk between parallel channels, fixed capacity or limited capacity processing, or some form of serial architecture in the measured human response time data.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Upper.Bound</code></td>
<td>
<p>An object of class "approxfun"" representing the estimated upper bound on the cumulative distribution function for an unlimited capacity parallel model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower.Bound</code></td>
<td>
<p>A object of class "approxfun" representing the estimated lower bound on the cumulative distribution function for an unlimited capacity parallel model.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Leslie Blaha &lt;leslie.blaha@us.af.mil&gt;
</p>
<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Blaha, L.M. &amp; Townsend, J.T. (under review). On the capacity of single-target self-terminating processes.
</p>
<p>Colonius, H. &amp; Vorberg, D. (1994). Distribution inequalities for parallel models with unlimited capacity. <em>Journal of Mathematical Psychology, 38</em>, 35-58. 
</p>
<p>Grice, G.R., Canham, L., &amp; Gwynne, J.W. (1984). Absense of a redundant-signals effect in a raction time task with divided attention. <em>Perception &amp; Psychophysics, 36</em>, 565-570.
</p>
<p>Miller, J. (1982). Divided attention: Evidence for coactivation with redundant signals. <em>Cognitive Psychology, 14</em>, 247-279.
</p>
<p>Townsend, J.T. &amp; Eidels, A. (2011). Workload capacity spaces: a unified methodology for response time measures of efficiency as workload is varied. <em>Psychonomic Bulletin &amp; Review, 18</em>, 659-681.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003â€“1035.
</p>


<h3>See Also</h3>

<p><code>ucip.test</code>
<code>capacity.or</code>
<code>capacity.and</code>
<code>capacity.stst</code>
<code>approxfun</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#randomly generated data
rate1 &lt;- .35
rate2 &lt;- .3
rate3 &lt;- .4
RT.paa &lt;- rexp(100, rate1)
RT.apa &lt;- rexp(100, rate2)
RT.aap &lt;- rexp(100, rate3)
RT.or &lt;- pmin(rexp(100, rate1), rexp(100, rate2), rexp(100, rate3))
RT.and &lt;- pmax(rexp(100, rate1), rexp(100, rate2), rexp(100, rate3))
tvec &lt;- sort(unique(c(RT.paa, RT.apa, RT.aap, RT.or, RT.and)))

or.bounds &lt;- estimate.bounds(RT=list(RT.paa, RT.apa, RT.aap), CR=NULL, assume.ID=FALSE, 
  unified.space=FALSE)
and.bounds &lt;- estimate.bounds(RT=list(RT.paa, RT.apa, RT.aap))

## Not run: 
#plot the or bounds together with a parallel OR model
matplot(tvec, 
  cbind(or.bounds$Upper.Bound(tvec), or.bounds$Lower.Bound(tvec), ecdf(RT.or)(tvec)),
  type='l', lty=1, ylim=c(0,1), col=2:4, main="Example OR Bounds", xlab="Time", 
  ylab="P(T&lt;t)")
abline(1,0)
legend('topright', c("Upper Bound", "Lower Bound", "Parallel OR Model"), 
  lty=1, col=2:4, bty="n")

#using the dots data set in sft package
data(dots)
attach(dots)
RT.A &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==0, 'RT']
RT.B &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==0 &amp; Channel2==2, 'RT']
RT.AB &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==2, 'RT']
tvec &lt;- sort(unique(c(RT.A, RT.B, RT.AB)))
Cor.A &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==0, 'Correct']
Cor.B &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==0 &amp; Channel2==2, 'Correct']
Cor.AB &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==2, 'Correct']
capacity &lt;- capacity.or(list(RT.AB,RT.A,RT.B), list(Cor.AB,Cor.A,Cor.B), ratio=TRUE)
bounds &lt;- estimate.bounds(list(RT.A,RT.B), list(Cor.A,Cor.B), unified.space=TRUE)

#plot unified capacity coefficient space
plot(tvec, capacity$Ct(tvec), type="l", lty=1, col="red", lwd=2)
lines(tvec, bounds$Upper.Bound(tvec), lty=2, col="blue", lwd=2)
lines(tvec, bounds$Lower.Bound(tvec), lty=4, col="blue", lwd=2)
abline(h=1, col="black", lty=1)

## End(Not run)
</code></pre>


</div>