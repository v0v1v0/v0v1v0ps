<div class="container">

<table style="width: 100%;"><tr>
<td>formula.utilities</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions for Querying, Validating and Extracting from Formulas</h2>

<h3>Description</h3>

<p>A suite of utilities for handling model formulas of the style used in Statnet packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">append_rhs.formula(
  object = NULL,
  newterms,
  keep.onesided = FALSE,
  env = if (is.null(object)) NULL else environment(object)
)

append.rhs.formula(object, newterms, keep.onesided = FALSE)

filter_rhs.formula(object, f, ...)

nonsimp_update.formula(object, new, ..., from.new = FALSE)

nonsimp.update.formula(object, new, ..., from.new = FALSE)

term.list.formula(rhs, sign = +1)

list_summands.call(object)

list_rhs.formula(object)

eval_lhs.formula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>formula object to be updated or evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newterms</code></td>
<td>
<p>a <code>term_list</code> object, or any list of terms (names
or calls) to append to the formula, or a formula whose RHS terms
will be used; its <code>"sign"</code> attribute vector can give the sign of
each term (<code>+1</code> or <code>-1</code>), and its <code>"env"</code> attribute
vector will be used to set its environment, with the first
available being used and subsequent ones producing a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.onesided</code></td>
<td>
<p>if the initial formula is one-sided, keep it
whether to keep it one-sided or whether to make the initial
formula the new LHS</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>an environment for the new formula, if <code>object</code> is
<code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a function whose first argument is the term and whose
additional arguments are forwarded from <code>...</code> that returns either
<code>TRUE</code> or <code>FALSE</code>, for whether that term should be kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments. Currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new</code></td>
<td>
<p>new formula to be used in updating</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from.new</code></td>
<td>
<p>logical or character vector of variable names. controls how
environment of formula gets updated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs, sign</code></td>
<td>
<p>Arguments to the deprecated <code>term.list.formula</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>append_rhs.formula</code> each return an updated formula
object; if <code>object</code> is <code>NULL</code> (the default), a one-sided formula
containing only the terms in <code>newterms</code> will be returned.
</p>
<p><code>nonsimp_update.formula</code> each return an
updated formula object
</p>
<p><code>list_summands.call</code> returns an object of type
<code>term_list</code>; its <code>"env"</code> attribute is set to a list of
<code>NULL</code>s, however.
</p>
<p><code>list_rhs.formula</code> returns an object of type <code>term_list</code>.
</p>
<p><code>eval_lhs.formula</code> an object of whatever type the LHS evaluates to.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>append_rhs.formula()</code>: <code>append_rhs.formula</code> appends a list of terms to the RHS of a
formula. If the formula is one-sided, the RHS becomes the LHS, if
<code>keep.onesided==FALSE</code> (the default).
</p>
</li>
<li> <p><code>append.rhs.formula()</code>: <code>append.rhs.formula</code> has been renamed to <code>append_rhs.formula</code>.
</p>
</li>
<li> <p><code>filter_rhs.formula()</code>: <code>filter_rhs.formula</code> filters through the terms in the RHS of a
formula, returning a formula without the terms for which function
<code>f(term, ...)</code> is <code>FALSE</code>. Terms inside another term (e.g.,
parentheses or an operator other than + or -) will be unaffected.
</p>
</li>
<li> <p><code>nonsimp_update.formula()</code>: <code>nonsimp_update.formula</code> is a reimplementation of
<code>update.formula</code> that does not simplify.  Note that the
resulting formula's environment is set as follows. If
<code>from.new==FALSE</code>, it is set to that of object. Otherwise, a new
sub-environment of object, containing, in addition, variables in new listed
in from.new (if a character vector) or all of new (if TRUE).
</p>
</li>
<li> <p><code>nonsimp.update.formula()</code>: <code>nonsimp.update.formula</code> has been renamed to <code>nonsimp_update.formula</code>.
</p>
</li>
<li> <p><code>term.list.formula()</code>: <code>term.list.formula</code> is an older version of <code>list_rhs.formula</code> that required the RHS call, rather than the formula itself.
</p>
</li>
<li> <p><code>list_summands.call()</code>: <code>list_summands.call</code>, given an unevaluated call or expression
containing the sum of one or more terms, returns an object of class <code>term_list</code> with the
terms being summed, handling <code>+</code> and <code>-</code> operators and
parentheses, and keeping track of whether a term has a plus or a
minus sign.
</p>
</li>
<li> <p><code>list_rhs.formula()</code>: <code>list_rhs.formula</code> returns an object of type <code>term_list</code>,
containing terms in a given formula, handling <code>+</code> and <code>-</code>
operators and parentheses, and keeping track of whether a term has
a plus or a minus sign.
</p>
</li>
<li> <p><code>eval_lhs.formula()</code>: <code>eval_lhs.formula</code> extracts the LHS of a formula, evaluates it in the formula's environment, and returns the result.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
## append_rhs.formula

(f1 &lt;- append_rhs.formula(y~x,list(as.name("z1"),as.name("z2"))))
(f2 &lt;- append_rhs.formula(~y,list(as.name("z"))))
(f3 &lt;- append_rhs.formula(~y+x,structure(list(as.name("z")),sign=-1)))
(f4 &lt;- append_rhs.formula(~y,list(as.name("z")),TRUE))
(f5 &lt;- append_rhs.formula(y~x,~z1-z2))
(f6 &lt;- append_rhs.formula(NULL,list(as.name("z"))))
(f7 &lt;- append_rhs.formula(NULL,structure(list(as.name("z")),sign=-1)))

fe &lt;- ~z2+z3
environment(fe) &lt;- new.env()
(f8 &lt;- append_rhs.formula(NULL, fe)) # OK
(f9 &lt;- append_rhs.formula(y~x, fe)) # Warning
(f10 &lt;- append_rhs.formula(y~x, fe, env=NULL)) # No warning, environment from fe.
(f11 &lt;- append_rhs.formula(fe, ~z1)) # Warning, environment from fe



## filter_rhs.formula
(f1 &lt;- filter_rhs.formula(~a-b+c, `!=`, "a"))
(f2 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "a"))
(f3 &lt;- filter_rhs.formula(~a-b+c, `!=`, "b"))
(f4 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "b"))
(f5 &lt;- filter_rhs.formula(~a-b+c, `!=`, "c"))
(f6 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "c"))
(f7 &lt;- filter_rhs.formula(~c-a+b-c(a),
                          function(x) (if(is.call(x)) x[[1]] else x)!="c"))




stopifnot(identical(list_rhs.formula(a~b),
          structure(alist(b), sign=1, env=list(globalenv()), class="term_list")))
stopifnot(identical(list_rhs.formula(~b),
          structure(alist(b), sign=1, env=list(globalenv()), class="term_list")))
stopifnot(identical(list_rhs.formula(~b+NULL),
          structure(alist(b, NULL),
                    sign=c(1,1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~-b+NULL),
          structure(alist(b, NULL),
                    sign=c(-1,1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~+b-NULL),
          structure(alist(b, NULL),
                    sign=c(1,-1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~+b-(NULL+c)),
          structure(alist(b, NULL, c),
                    sign=c(1,-1,-1), env=rep(list(globalenv()), 3), class="term_list")))

## eval_lhs.formula

(result &lt;- eval_lhs.formula((2+2)~1))

stopifnot(identical(result,4))
</code></pre>


</div>