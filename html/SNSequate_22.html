<div class="container">

<table style="width: 100%;"><tr>
<td>ker.eq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Kernel method of test equating</h2>

<h3>Description</h3>

<p>This function implements the kernel method of test equating  as described in Holland and Thayer (1989), 
and Von Davier et al. (2004). Nonstandard kernels others than the gaussian are available. Associated standard error 
of equating are also provided. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ker.eq(scores, kert, hx = NULL, hy = NULL, degree, design, Kp = 1, scores2, 
degreeXA, degreeYA, J, K, L, wx, wy, w, gapsX, gapsY, gapsA, lumpX, lumpY, 
lumpA, alpha, h.adap,r=NULL,s=NULL)
</code></pre>


<h3>Arguments</h3>

  
<p>		Note that depending on the specified equating design, not all arguments are necessary 
as detailed below. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>	If the "EG" design is specified, a two column matrix containing the raw sample frequencies 
coming from the two groups of scores to be equated. It is assumed that the data in the first 
and second columns come from tests <code class="reqn">X</code> and <code class="reqn">Y</code>, respectively.
</p>
<p>If the "SG" design is specified, a matrix containing the (joint) bivariate sample 
frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> (columns).
</p>
<p>If the "CB" design is specified, a two column matrix containing the observed scores 
of the sample taking test <code class="reqn">X</code> first, followed by test <code class="reqn">Y</code>. The <code>scores2</code> 
argument is then used for the scores of the sample taking test Y first followed by test 
<code class="reqn">X</code>.
</p>
<p>If either the "NEAT_CB" or "NEAT_PSE" design is selected, a two column matrix containing 
the observed scores on	test <code class="reqn">X</code> (first column) and the observed scores on the anchor 
test <code class="reqn">A</code> (second column). The <code>scores2</code> argument is then used for the observed 
scores on test <code class="reqn">Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kert</code></td>
<td>
<p>		A character string giving the type of kernel to be used for continuization. 
Current options include "<code>gauss</code>", "<code>logis</code>", "<code>uniform</code>", "<code>epan</code>" and "<code>adap</code>" 
for the gaussian, logistic, uniform, Epanechnikov and Adaptative kernels, respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hx</code></td>
<td>
<p>		An integer indicating the value of the bandwidth parameter to be used for kernel continuization 
of <code class="reqn">F(x)</code>. If not provided (Default), this value is automatically calculated (see 
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hy</code></td>
<td>
<p>		An integer indicating the value of the bandwidth parameter to be used for kernel continuization 
of <code class="reqn">G(y)</code>. If not provided (Default), this value is automatically calculated (see 
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>	A vector indicating the number of power moments to be fitted to the marginal distributions 
("EG" design), and/or the number or cross moments to be fitted to the joint distributions 
(see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>	A character string indicating the equating design (one of "EG", "SG", "CB", "NEAT_CE", 
"NEAT_PSE")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kp</code></td>
<td>
<p>		A number which acts as a weight for the second term in the combined penalization function used 
to obtain <code>h</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores2</code></td>
<td>
<p>	Only used for the "CB", "NEAT_CE" and "NEAT_PSE" designs. See the description of
<code>scores</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degreeXA</code></td>
<td>
<p>	A vector indicating the	number of power moments to be fitted to the marginal distributions 
<code class="reqn">X</code> and <code class="reqn">A</code>, and the number or cross moments to be fitted to the joint 
distribution <code class="reqn">(X,A)</code>	(see details). Only used for the "NEAT_CE" and "NEAT_PSE" designs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degreeYA</code></td>
<td>
<p>	Only used for the "NEAT_CE" and "NEAT_PSE" designs (see the description for
<code>degreeXA</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>		The number of possible <code class="reqn">X</code> scores. Only needed for "CB", "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>		The number of possible <code class="reqn">Y</code> scores. Only needed for "CB", "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>		The number of possible <code class="reqn">A</code> scores. Needed for "NEAT_CB" and "NEAT_PSE" designs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wx</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_X\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the "CB" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_Y\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the "CB" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w\leq 1</code> indicating the weight given to 
population <code class="reqn">P</code>. Only used for the "NEAT" design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsX</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">J</code> to smooth "gaps", usually ocurring at regular intervals due to scores rounded to integer values and other methodological factors. </p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted by the log-linear model.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsY</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">K</code>.</p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gapsA</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt>
<dd>
<p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">L</code>. </p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>
<p>Only used for the "NEAT" design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpX</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">X</code> due to recording of negative rounded formulas or any other methodological artifact.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpY</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lumpA</code></td>
<td>
<p>An integer to represent the index where an artificial "lump" is created in the marginal distribution of frecuencies for <code class="reqn">A</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Only for Adaptative Kernel. Sensitivity parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.adap</code></td>
<td>
<p>Only for Adaptative Kernel. A list(hx, hy) containing bandwidths for Adaptative kernel for each Form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Score probabilities for <code class="reqn">X</code> scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Score probabilities for <code class="reqn">Y</code> scores.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a generic function that implements the kernel method of test equating as described in Von Davier et al.
(2004). Given test scores <code class="reqn">X</code> and <code class="reqn">Y</code>, the functions calculates 
</p>
<p style="text-align: center;"><code class="reqn">\hat{e}_Y(x)=G_{h_{Y}}^{-1}(F_{h_{X}}(x;\hat{r}),\hat{s})</code>
</p>

<p>where <code class="reqn">\hat{r}</code> and <code class="reqn">\hat{s}</code> are estimated score probabilities obtained via loglinear
smoothing (see <code>loglin.smooth</code>). The value of <code class="reqn">h_X</code> and <code class="reqn">h_Y</code> can either be specified 
by the user or left unspecified (default) in which case they are automatically calculated. For instance, one can
specifies large values of <code class="reqn">h_X</code> and <code class="reqn">h_Y</code>, so that the <code class="reqn">\hat{e}_Y(x)</code> tends to the 
linear equating function (see Theorem 4.5 in Von Davier et al, 2004 for more details). 
</p>


<h3>Value</h3>

<p>	An object of class <code>ker.eq</code> representing the kernel equating process. Generic functions such as 
<code>print</code>, and <code>summary</code> have methods to show the results of the equating. The results include 
summary statistics, equated values, standard errors of equating, and others.  
</p>
<p>The function <code>SEED</code> can be used to obtain standard error of equating differences (SEED) of two 
objects of class <code>ker.eq</code>. The function <code>PREp</code> can be used on a <code>ker.eq</code> object to 
obtain the percentage relative error measure (see Von Davier et al, 2004). 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Scores</code></td>
<td>
<p>The possible values of <code class="reqn">x_j</code> and <code class="reqn">y_k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eqYx </code></td>
<td>
<p>The equated values of test <code class="reqn">X</code> in test <code class="reqn">Y</code> scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eqXy </code></td>
<td>
<p>The equated values of test <code class="reqn">Y</code> in test <code class="reqn">X</code> scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SEEYx</code></td>
<td>
<p>The standard error of equating for equating <code class="reqn">X</code> to <code class="reqn">Y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SEEXy</code></td>
<td>
<p>The standard error of equating for equating <code class="reqn">Y</code> to <code class="reqn">X</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1989). The kernel method of equating score distributions. 
(Technical Report No 89-84). Princeton, NJ: Educational Testing Service.
</p>
<p>Holland, P., King, B. and Thayer, D. (1989). The standard error of equating for the kernel method 
of equating score distributions (Tech. Rep. No. 89-83). Princeton, NJ: Educational Testing Service. 
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code>loglin.smooth</code>, <code>SEED</code>, <code>PREp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Kernel equating under the "EG" design
data(Math20EG)
mod&lt;-ker.eq(scores=Math20EG,kert="gauss",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 

summary(mod)

#Reproducing Table 7.6 in Von Davier et al, (2004)

scores&lt;-0:20
SEEXy&lt;-mod$SEEXy
SEEYx&lt;-mod$SEEYx

Table7.6&lt;-cbind(scores,SEEXy,SEEYx)
Table7.6

#Other nonstandard kernels. Table 10.3 in Von Davier (2011).

mod.logis&lt;-ker.eq(scores=Math20EG,kert="logis",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 
mod.unif&lt;-ker.eq(scores=Math20EG,kert="unif",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 
mod.gauss&lt;-ker.eq(scores=Math20EG,kert="gauss",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 

XtoY&lt;-cbind(mod.logis$eqYx,mod.unif$eqYx,mod.gauss$eqYx)
YtoX&lt;-cbind(mod.logis$eqXy,mod.unif$eqXy,mod.gauss$eqXy)

Table10.3&lt;-cbind(XtoY,YtoX)
Table10.3

## Examples using Adaptive and Epanechnikov kernels
x_sim = c(1,2,3,4,5,6,7,8,9,10,11,10,9,8,7,6,5,4,3,2,1)
prob_sim = x_sim/sum(x_sim)
set.seed(1)
sim = rmultinom(1, p = prob_sim, size = 1000)

x_asimD = c(1,7,13,18,22,24,25,24,20,18,16,15,13,9,5,3,2.5,1.5,1.5,1,1)
probas_asimD = x_asimD/sum(x_asimD)
set.seed(1)
asim = rmultinom(1, p = probas_asimD, size = 1000)

scores = cbind(asim,sim)

mod.adap  = ker.eq(scores,degree=c(2,2),design="EG",kert="adap")
mod.epan  = ker.eq(scores,degree=c(2,2),design="EG",kert="epan")
</code></pre>


</div>