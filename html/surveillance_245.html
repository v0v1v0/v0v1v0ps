<div class="container">

<table style="width: 100%;"><tr>
<td>plapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Verbose and Parallel <code>lapply</code>
</h2>

<h3>Description</h3>

<p>Verbose and parallelized version of <code>lapply</code> wrapping around
<code>mclapply</code> and <code>parLapply</code>
in the base package <span class="pkg">parallel</span>.
This wrapper can take care of the <code>.Random.seed</code> and
print progress information (not for cluster-based parallelization).
With the default arguments it equals <code>lapply</code>
enriched by a progress bar.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plapply(X, FUN, ...,
        .parallel = 1, .seed = NULL, .verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X,FUN,...</code></td>
<td>
<p>see <code>lapply</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>

<p>the number of processes to use in parallel operation, or a
<code>"cluster"</code> object (see <code>makeCluster</code>).
If a number, <code>mclapply</code> (forking) is used on
Unix-alikes, whereas on Windows <code>parLapply</code> is
used on a newly created cluster of the specified size, which is
stopped when exiting the function.
By default (<code>.parallel = 1</code>), the basic <code>lapply</code> is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.seed</code></td>
<td>

<p>If set (non-<code>NULL</code>), results involving random number generation
become reproducible. If using a cluster (see the <code>.parallel</code>
argument), <code>clusterSetRNGStream</code> is called
with the specified <code>.seed</code> before running <code>parLapply</code>.
Otherwise, <code>set.seed(.seed)</code> is called and the
<code>RNGkind</code> is changed to <code>"L'Ecuyer-CMRG"</code> if
<code>.parallel &gt; 1</code> (see the section on random numbers in the
documentation of <code>mcparallel</code> in package <span class="pkg">parallel</span>).

If <code>.seed</code> is non-<code>NULL</code>,
the original <code>.Random.seed</code> will be restored
<code>on.exit</code> of the function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.verbose</code></td>
<td>

<p>if and how progress information should be displayed, i.e., what to
do on each exit of <code>FUN</code>. This is unsupported and ignored for
cluster-based parallelization and primitive <code>FUN</code>ctions.
The default (<code>TRUE</code>) will show a <code>txtProgressBar</code>
(if <code>.parallel = 1</code> in an <code>interactive</code> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> session)
or <code>cat(".")</code> (otherwise). Other choices for the dot are possible
by specifying the desired symbol directly as the <code>.verbose</code>
argument. Alternatively, <code>.verbose</code> may be any custom call or
expression to be executed <code>on.exit</code> of <code>FUN</code> and
may thus involve any objects from the local evaluation environment.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of the results of calling <code>FUN</code> on each value of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code>mclapply</code> and <code>parLapply</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## example inspired by help("lapply")
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))

## if neither parallel nor verbose then this simply equals lapply()
plapply(x, quantile, probs = 1:3/4, .verbose = FALSE)

## verbose lapply() -- not really useful for such fast computations
res &lt;- plapply(x, quantile, probs = 1:3/4, .verbose = TRUE)
res &lt;- plapply(x, quantile, probs = 1:3/4, .verbose = "|")
res &lt;- plapply(x, quantile, probs = 1:3/4,
               .verbose = quote(cat("length(x) =", length(x), "\n")))

## setting the seed for reproducibility of results involving the RNG
samp &lt;- plapply(as.list(1:3), runif, .seed = 1)

## parallel lapply()
res &lt;- plapply(x, quantile, probs = 1:3/4, .parallel = 2, .verbose = FALSE)

## using a predefined cluster
library("parallel")
cl &lt;- makeCluster(getOption("cl.cores", 2))
res &lt;- plapply(x, quantile, probs = 1:3/4, .parallel = cl)
stopCluster(cl)
</code></pre>


</div>