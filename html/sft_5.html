<div class="container">

<table style="width: 100%;"><tr>
<td>capacity.stst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Capacity Coefficient for Single-Target Self-Terminating (STST) Processing
</h2>

<h3>Description</h3>

<p>Calculates the Capacity Coefficient for Single-Target Self-Terminating (STST) Processing
</p>


<h3>Usage</h3>

<pre><code class="language-R">capacity.stst(RT, CR=NULL, ratio=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the single-target among N distractors condition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>Indicates whether to return the standard ratio capacity coefficient or, if FALSE, the difference form.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The STST capacity coefficient compares performance on task to an unlimited-capacity, independent, parallel (UCIP) model using cumulative reverse hazard functions.  Suppose <code class="reqn">K_{i,1}(t)</code> is the cumulative reverse hazard function for response times when single-target process <code class="reqn">i</code> is completed in isolation and <code class="reqn">K_{i,n}(t)</code> is the cumulative reverse hazard function for response times when the single-target <code class="reqn">i</code> is processed among <code class="reqn">n</code> other processes, all completed together.  Then the STST capacity coefficient is given by, 
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm STST}(t)=\frac{K_{i,1}(t)}{K_{i,n}(t)}.</code>
</p>

<p>The numerator is the estimated cumulative reverse hazard function for the UCIP model, based on the response times for the <code class="reqn">i</code> process in isolation and the denominator is the actual performance on the <code class="reqn">i</code> process among <code class="reqn">n</code> distractors or other active channels. 
</p>
<p><code class="reqn">C_{\rm STST}(t) &lt;1</code> implies worse performance than the UCIP model.  This indicates that either there are limited processing resources, there is inhibition among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed serially).
</p>
<p><code class="reqn">C_{\rm STST}(t) &gt;1</code> implies better performance than the UCIP model.  This indicates that either there are more processing resources available per process when there are more processes, that there is facilitation among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed coactively).
</p>
<p>The difference form of the capacity coefficient (returned if ratio=FALSE) is given by,
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm STST}(t)=K_{i,n}(t) - K_{i,1}(t).</code>
</p>
<p>  Negative values indicate worse than UCIP performance and positive values indicate better than UCIP performance.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Ct</code></td>
<td>
<p>An object of class approxfun representing the estimated STST capacity coefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Var</code></td>
<td>
<p>An object of class approxfun representing the variance of the estimated STST capacity coefficient.  Only returned if ratio=FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ctest</code></td>
<td>
<p>A list with class "htest" that is returned from <code>ucip.test</code> and contains the statistic and p-value.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Leslie Blaha &lt;leslie.blaha@us.af.mil&gt;
</p>
<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Blaha, L.M. &amp; Townsend, J.T. (under review). On the capacity of single-target self-terminating processes.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical measures for workload capacity analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003â€“1035.
</p>


<h3>See Also</h3>

<p><code>ucip.test</code>
<code>capacityGroup</code>
<code>capacity.or</code>
<code>capacity.and</code>
<code>estimateNAK</code>
<code>approxfun</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">rate1 &lt;- .35
RT.pa &lt;- rexp(100, rate1)
RT.pp.limited &lt;- rexp(100, .5*rate1)
RT.pp.unlimited &lt;- rexp(100, rate1)
RT.pp.super &lt;- rexp(100, 2*rate1)
tvec &lt;- sort(unique(c(RT.pa, RT.pp.limited, RT.pp.unlimited, RT.pp.super)))

cap.limited &lt;- capacity.stst(RT=list(RT.pp.limited, RT.pa))
print(cap.limited$Ctest)
cap.unlimited &lt;- capacity.stst(RT=list(RT.pp.unlimited, RT.pa))
cap.super &lt;- capacity.stst(RT=list(RT.pp.super, RT.pa))

matplot(tvec, cbind(cap.limited$Ct(tvec), cap.unlimited$Ct(tvec), cap.super$Ct(tvec)),
  type='l', lty=1, ylim=c(0,5), col=2:4, main="Example Capacity Functions", xlab="Time", 
  ylab="C(t)")
abline(1,0)
legend('topright', c("Limited", "Unlimited", "Super"), lty=1, col=2:4, bty="n")

</code></pre>


</div>