<div class="container">

<table style="width: 100%;"><tr>
<td>heuristics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generating heuristics for the use in STUART subtest construction</h2>

<h3>Description</h3>

<p>Creates uninformative heuristic matrices for the use in <code>mmas</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">heuristics(
  data,
  factor.structure,
  capacity = NULL,
  repeated.measures = NULL,
  mtmm = NULL,
  grouping = NULL,
  localization = "nodes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localization</code></td>
<td>
<p>Which parameterization to use when depositing pheromones. Can be either 'nodes' (the default) for depositing pheromones on selected nodes or 'arcs' for depositing on selection arcs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments normally provided to <code>mmas</code>, which will be ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates a list of matrices which can be used as heuristics for all STUART constructions. This is mainly intended to write the structure of the heuristic matrices to an object, change components in line with theoretically derived heuristics and feed them back into <code>mmas</code> via the <code>heuristics</code> argument. The generated heuristics will contain only 1s and 0s, making it no heuristic information. Selection probabilities can be altered by manipulating the contents of the object created by <code>heuristics</code>. Setting a value to 0 will result in prohibiting a certain choice to be made. Please note, that it will lead to unpredictable behavior if the diagonal elements of the matrices produced in the arcs parameterization are set to values other than 0.
</p>


<h3>Value</h3>

<p>Returns a list of the same length as the <code>factor.structure</code> argument provided.
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code>mmas</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# heuristics for node localization
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

(heu &lt;- heuristics(fairplayer, fs, 4))

# Define anchor-item
heu$si[1] &lt;- 10000
heu

# heuristics for arc localization
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

(heu &lt;- heuristics(fairplayer, fs, 4, localization = 'arcs'))

# Define equal selection of odd and even items
heu$si[1:10,] &lt;- c(rep(c(0, 1), 5), rep(c(1, 0), 5))
heu

</code></pre>


</div>