<div class="container">

<table style="width: 100%;"><tr>
<td>make.capthist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Construct capthist Object </h2>

<h3>Description</h3>

<p>Form a <code>capthist</code> object from a data frame of capture records and a <code>traps</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make.capthist(captures, traps, fmt = c("trapID", "XY"), noccasions = NULL,
    covnames = NULL, bysession = TRUE, sortrows = TRUE,
    cutval = NULL, tol = 0.01, snapXY = FALSE, noncapt = "NONE", signalcovariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>captures</code></td>
<td>
<p> dataframe of capture records in one of two possible formats (see Details) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traps</code></td>
<td>
<p> object of class <code>traps</code> describing an array of passive detectors </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fmt</code></td>
<td>
<p> character string for capture format. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p> number of occasions on which detectors were operated </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covnames</code></td>
<td>
<p> character vector of names for individual covariate fields </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bysession</code></td>
<td>
<p> logical, if true then ID are made unique by session </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortrows</code></td>
<td>
<p> logical, if true then rows are sorted in ascending order of animalID </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutval</code></td>
<td>
<p> numeric, threshold of signal strength for ‘signal’ detector type </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> numeric, snap tolerance in metres</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snapXY</code></td>
<td>
<p> logical; if TRUE then fmt = 'XY' uses nearest trap
within tol for non-polygon detectors </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noncapt</code></td>
<td>
<p> character value; animal ID used for ‘no captures’ </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signalcovariates</code></td>
<td>
<p>character vector of field names from
‘captures’</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>make.capthist</code> is the most flexible way to prepare data for
<code>secr.fit</code>. See <code>read.capthist</code> for a more streamlined
way to read data from text files for common detector types. Each row of
the input data frame <code>captures</code> represents a detection on one
occasion. The capture data frame may be formed from a text file with
<code>read.table</code>.
</p>
<p>Input formats are based on the Density software (Efford 2012; see also
<a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a>). If <code>fmt =
"XY"</code> the required fields are (session, ID, occasion, x, y) in that
order. If <code>fmt = "trapID"</code> the required fields are (session, ID,
occasion, trap), where <code>trap</code> is the numeric index of the relevant
detector in <code>traps</code>. <code>session</code> and <code>ID</code> may be
character-, vector- or factor-valued; other required fields are
numeric. Fields are matched by position (column number), <em>not</em> by
name. Columns after the required fields are interpreted as individual
covariates that may be continuous (e.g., size) or categorical (e.g.,
age, sex).
</p>
<p>If <code>captures</code> has data from multiple sessions then <code>traps</code> may
be either a list of <code>traps</code> objects, one per session, or a single
<code>traps</code> object that is assumed to apply throughout. Similarly,
<code>noccasions</code> may be a vector specifying the number of occasions in
each session.
</p>
<p>Covariates are assumed constant for each individual; the first
non-missing value is used. The length of <code>covnames</code> should equal the
number of covariate fields in <code>captures</code>.
</p>
<p><code>bysession</code> takes effect when the same individual is detected in
two or more sessions: TRUE results in one capture history per session,
FALSE has the effect of generating a single capture history (this is not
appropriate for the models currently provided in <span class="pkg">secr</span>).
</p>
<p>Deaths are coded as negative values in the occasion field of
<code>captures</code>. Occasions should be numbered 1, 2, ..., noccasions. By
default, the number of occasions is the maximum value of ‘occasion’ in
<code>captures</code>.
</p>
<p>Signal strengths may be provided in the fifth (fmt = trapID) or sixth
(fmt = XY) columns. Detections with signal strength missing (NA) or
below ‘cutval’ are discarded.
</p>
<p>A session may result in no detections. In this case a null line is
included in <code>captures</code> using the animal ID field given by
<code>noncapt</code>, the maximum occasion number, and any trapID (e.g. "sess1
NONE 5 1" for a 5-occasion session) (or equivalently "sess1 NONE 5 10
10" for fmt = XY).
</p>
<p>Nonspatial data (Session, AnimalID, Occasion and possibly individual 
covariates) may be entered by omitting the ‘traps’ argument or setting 
it to NULL.
</p>


<h3>Value</h3>

<p>An object of class <code>capthist</code> (a matrix or array of
detection data with attributes for detector positions etc.). For
‘single’ and ‘multi’ detectors this is a matrix with one row per animal
and one column per occasion (dim(capthist)=c(nc,noccasions)); each
element is either zero (no detection) or a detector number (the row
number in <code>traps</code> <em>not</em> the row name). For ‘proximity’
detectors <code>capthist</code> is an array of values {-1, 0, 1} and
dim(capthist)=c(nc,noccasions,ntraps). The number of animals <code>nc</code>
is determined from the input, as is <code>noccasions</code> if it is not specified.
<code>traps</code>, <code>covariates</code> and other data are retained as
attributes of <code>capthist</code>.
</p>
<p>Deaths during the experiment are represented as negative values in <code>capthist</code>.
</p>
<p>For ‘signal’ and ‘signalnoise’ detectors, the columns of <code>captures</code>
identified in <code>signalcovariates</code> are saved along with signal
strength measurements in the attribute ‘signalframe’.
</p>
<p>If the input has data from multiple sessions then the output is an
object of class c("capthist", "list") comprising a list of single-session
<code>capthist</code> objects.
</p>


<h3>Note</h3>

<p><code>make.capthist</code> requires that the data for <code>captures</code> and
<code>traps</code> already exist as <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects. To read data from external
(text) files, first use <code>read.table</code> and <code>read.traps</code>, or try
<code>read.capthist</code> for a one-step solution.
</p>
<p>Prior to <span class="pkg">secr</span> 4.4.0, occasional valid records for "multi" and "single" detectors 
were rejected as duplicates.
</p>
<p>From <span class="pkg">secr</span> 4.5.0, ‘snapXY’ works for transects as well as point detectors.
</p>


<h3>References</h3>

<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture–recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

 <p><code>capthist</code>, <code>traps</code>,
<code>read.capthist</code>, <code>secr.fit</code>,
<code>sim.capthist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
## peek at demonstration data
head(captXY)
head(trapXY)

demotraps &lt;- read.traps(data = trapXY)
demoCHxy  &lt;- make.capthist (captXY, demotraps, fmt = "XY")

demoCHxy            ## print method for capthist
plot(demoCHxy)      ## plot method for capthist
summary(demoCHxy)   ## summary method for capthist


## To enter `count' data without manually repeating rows
## need a frequency vector f, length(f) == nrow(captXY)
n &lt;- nrow(captXY)
f &lt;- sample (1:5, size = n, prob = rep(0.2,5), replace = TRUE)
## repeat rows as required...
captXY &lt;- captXY[rep(1:n, f),]
counttraps &lt;- read.traps(data = trapXY, detector = "count")
countCH  &lt;- make.capthist (captXY, counttraps, fmt = "XY")

</code></pre>


</div>