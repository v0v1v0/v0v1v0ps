<div class="container">

<table style="width: 100%;"><tr>
<td>local_covariance_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computation of Local Covariance Matrices
</h2>

<h3>Description</h3>

<p><code>local_covariance_matrix</code> computes local covariance matrices for a random field based on a given set of spatial kernel matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">local_covariance_matrix(x, kernel_list, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
                        center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list with spatial kernel matrices of dimension <code>c(n, n)</code>. This list is usually computed with the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default) or <code>'ldiff'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is centered prior computing the local covariance matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two versions of local covariance matrices are implemented, the argument <code>lcov</code> determines which version is used:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li>
</ul>
<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code>sbss_asymp</code> and <code>sbss_boot</code>. The function <code>local_covariance_matrix</code> computes local covariance matrices for a given random field and given spatial kernel matrices, the type of computed local covariance matrices is determined by the argument <code>'lcov'</code>. If the argument <code>center</code> equals <code>FALSE</code> then the centering in the above formula for <code class="reqn">LCov(f)</code> is not carried out. See also <code>spatial_kernel_matrix</code> for details. 
</p>


<h3>Value</h3>

<p><code>local_covariance_matrix</code> returns a list of equal length as the argument <code>kernel_list</code>. Each list entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a local covariance matrix. The list has the attribute <code>'lcov'</code> which equals the function argument <code>lcov</code>.
</p>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>


<h3>See Also</h3>

<p><code>spatial_kernel_matrix</code>, <code>sbss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # computing two ring kernel matrices and corresponding local covariance matrices
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_covariance_matrix(x = field, kernel_list = ring_kernel_list)
    
  # computing two ring kernel matrices and corresponding local difference matrices
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_covariance_matrix(x = field, kernel_list = ring_kernel_list, lcov = 'ldiff')
  
  # computing three ball kernel matrices and corresponding local covariance matrices
  kernel_params_ball &lt;- c(0.5, 1, 2)
  ball_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ball', kernel_params_ball)
  loc_cov_ball &lt;- 
    local_covariance_matrix(x = field, kernel_list = ball_kernel_list)
  
  # computing three gauss kernel matrices and corresponding local covariance matrices
  kernel_params_gauss &lt;- c(0.5, 1, 2)
  gauss_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)
  loc_cov_gauss &lt;- 
    local_covariance_matrix(x = field, kernel_list = gauss_kernel_list)
}
</code></pre>


</div>