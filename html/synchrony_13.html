<div class="container">

<table style="width: 100%;"><tr>
<td>phase.sync</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Phase synchrony of quasi-periodic time series
</h2>

<h3>Description</h3>

<p>Compute the phase synchrony between two quasi-periodic time series by quantifying
their phase difference at each time step
</p>


<h3>Usage</h3>

<pre><code class="language-R">phase.sync (t1, t2,  nrands = 0, mod = 1, method = c("markov", "fft"), 
            nbreaks = 10, mins = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>t1</code></td>
<td>

<p>time series 1 in matrix format (<code>n</code> rows x 2 columns). 
The first column should contain the time 
steps and the second column should contain the values. If <code>t1</code> is a column
vector instead of a matrix, then it will be automatically converted to a 
matrix with column 1 corresponding to a time index ranging from 1 to the length of <code>t1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t2</code></td>
<td>

<p>time series 2 in matrix format (<code>n</code> rows x 2 columns). 
The first column should contain the time 
steps and the second column should contain the values. If <code>t2</code> is a column
vector instead of a matrix, then it will be automatically converted to
matrix with column 1 corresponding to a time index ranging from 1 to the length of <code>t2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrands</code></td>
<td>

<p>number of randomizations to perform (default is 0)  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>flag to indicate whether to compute phase difference modulus <code class="reqn">2\pi</code> 
between 0 and <code class="reqn">2\pi</code> (<code>mod=1</code>) or phase difference modulus 
<code class="reqn">2\pi</code> between <code class="reqn">-\pi</code> and <code class="reqn">\pi</code> (<code>mod=2</code>). Default is <code>mod=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to generate surrogate time series for Monte Carlo simulations.
This can be set to <code>markov</code> to use the Markov process described in 
Cazelles and Stone (2004) or <code>fft</code> to use the FFT approach described in
Theiler et al. (1992). Default is <code>method=markov</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbreaks</code></td>
<td>
<p>number of bins to use to group the values in the time series.
Default is <code>10</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mins</code></td>
<td>

<p>use local minima instead of local maxima to compute and the interpolate the phase. Default is
<code>FALSE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two time series are phase-locked if the relationship between their phases
remains constant over time. This function computes the phase of successive local maxima
or minima for each time series and then uses linear interpolation to find the phase at
time steps that fall between local maxima/minima. A histogram can be used to determine if the
distribution of the phase difference at each time step is uniform (indicating no phase locking) 
or has a clear peak (indicating phase locking).
</p>


<h3>Value</h3>

<p>Returns a list containing <code>Q.obs</code>, <code>pval</code>, <code>rands</code>,
<code>phases1</code>, <code>phases2</code>, <code>deltaphase</code>, and <code>icdf</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Q.obs </code></td>
<td>
<p> Phase synchrony ranging from 0 (no phase synchrony) to 1 (full phase synchrony)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval </code></td>
<td>
<p>p-value of observed phase synchrony based on randomization test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rands </code></td>
<td>
<p>Monte Carlo randomizations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phases1 </code></td>
<td>
<p><code>n</code> x 3 matrix containing the timestep, value, and phase of the 
first time series </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phases2 </code></td>
<td>
<p><code>n</code> x 3 matrix containing the timestep, value, and phase of the 
second time series </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltaphase </code></td>
<td>
<p><code>n</code> x 4 matrix containing the timestep, raw phase difference, 
phase difference modulus <code class="reqn">2\pi</code> between 0 and <code class="reqn">2\pi</code>, phase difference 
modulus <code class="reqn">2\pi</code> between <code class="reqn">-\pi</code> and <code class="reqn">\pi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icdf </code></td>
<td>
<p>Inverse cumulative distribution of Q values obtained from Monte Carlo randomizatons</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Cazelles, B., and L. Stone. 2003. Detection of imperfect population synchrony 
in an uncertain world. <em>Journal of Animal Ecology</em> 72:953–968.
</p>
<p>Theiler, J., S. Eubank, A. Longtin, B. Galdrikian, and J. Doyne Farmer. 1992. 
Testing for nonlinearity in time series: the method of surrogate data. 
Physica D: Nonlinear Phenomena 58:77–94.
</p>


<h3>Examples</h3>

<pre><code class="language-R">t1=runif(100)
t2=runif(100)
# Compute and interpolate phases using successive local minima
sync.mins=phase.sync(t1, t2, mins=TRUE)
# Compute and interpolate phases using successive local maxima
sync.maxs=phase.sync(t1, t2)
# Plot distribution of phase difference
hist(sync.mins$deltaphase$mod_phase_diff_2pi)
</code></pre>


</div>