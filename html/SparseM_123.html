<div class="container">

<table style="width: 100%;"><tr>
<td>matrix.csr.chol-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "matrix.csr.chol" (Block Sparse Cholesky Decomposition)</h2>

<h3>Description</h3>

<p>A class of objects returned from Ng and Peyton's (1993) block
sparse Cholesky algorithm.
</p>


<h3>Details</h3>

<p>Note that the <code>perm</code> and notably <code>invp</code> maybe important to back
permute rows and columns of the decompositions, see the Examples, and our
<code>chol</code> help page.
</p>


<h3>Objects from the Class</h3>

<p>Objects may be created by calls of the form <code>new("matrix.csr.chol",
    ...)</code>, but typically result from
<code>chol(&lt;matrix.csr&gt;)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>nrow</code>:</dt>
<dd>
<p>an <code>integer</code>, the number of rows of the
original matrix, or in the linear system of equations.</p>
</dd>
<dt>
<code>nnzlindx</code>:</dt>
<dd>
<p>Object of class <code>numeric</code>, number of non-zero elements in <code>lindx</code></p>
</dd>
<dt>
<code>nsuper</code>:</dt>
<dd>
<p>an <code>integer</code>, the number of supernodes of the decomposition</p>
</dd>
<dt>
<code>lindx</code>:</dt>
<dd>
<p>Object of class <code>integer</code>, vector of integer
containing, in column major order, the row subscripts of the non-zero entries
in the Cholesky factor in a compressed storage format</p>
</dd>
<dt>
<code>xlindx</code>:</dt>
<dd>
<p>Object of class <code>integer</code>, vector of integer of pointers for <code>lindx</code></p>
</dd>
<dt>
<code>nnzl</code>:</dt>
<dd>
<p>of class <code>"numeric"</code>, an integer, the number of non-zero
entries, including the diagonal entries, of the Cholesky factor stored in <code>lnz</code></p>
</dd>
<dt>
<code>lnz</code>:</dt>
<dd>
<p>a <code>numeric</code> vector of the entries of the Cholesky factor</p>
</dd>
<dt>
<code>xlnz</code>:</dt>
<dd>
<p>an <code>integer</code> vector, the column pointers for the Cholesky factor stored in <code>lnz</code></p>
</dd>
<dt>
<code>invp</code>:</dt>
<dd>
<p>inverse permutation vector, <code>integer</code></p>
</dd>
<dt>
<code>perm</code>:</dt>
<dd>
<p>permutation vector, <code>integer</code></p>
</dd>
<dt>
<code>xsuper</code>:</dt>
<dd>
<p>Object of class <code>integer</code>, array containing the supernode partioning</p>
</dd>
<dt>
<code>det</code>:</dt>
<dd>
<p><code>numeric</code>, the determinant of the Cholesky factor</p>
</dd>
<dt>
<code>log.det</code>:</dt>
<dd>
<p><code>numeric</code>, the log determinant of the Cholesky factor</p>
</dd>
<dt>
<code>ierr</code>:</dt>
<dd>
<p>an <code>integer</code>, the error flag (from Fortran's ‘<span class="file">src/chol.f</span>’)</p>
</dd>
<dt>
<code>time</code>:</dt>
<dd>
<p><code>numeric</code>, unused (always <code>0.</code>) currently.</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>as.matrix.csr</dt>
<dd>
<p><code>signature(x = "matrix.csr.chol",
	upper.tri=TRUE)</code>: to get the sparse (<code>"matrix.csr"</code>) upper
triangular matrix corresponding to the Cholesky decomposition.</p>
</dd>
<dt>backsolve</dt>
<dd>
<p><code>signature(r = "matrix.csr.chol")</code>: for computing
<code class="reqn">R^{-1} b</code> when the Cholesky decomposition is <code class="reqn">A = R'R</code>.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>Base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s <code>chol</code> and <span class="pkg">SparseM</span>'s
<code>chol</code>, notably for examples;
<code>backsolve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x5g &lt;- new("matrix.csr",
          ra = c(300, 130, 5, 130, 330,
                 125, 10, 5, 125, 200, 70,
                 10, 70, 121.5, 1e30),
          ja = c(1:3, 1:4, 1:4, 2:5),
          ia = c(1L, 4L, 8L, 12L, 15L, 16L),
          dimension = c(5L, 5L))
(m5g &lt;- as.matrix(x5g)) # yes, is symmetric, and positive definite:
eigen(m5g, only.values=TRUE)$values  # all positive (but close to singular)
ch5g &lt;- chol(x5g)
str(ch5g) # --&gt; the slots of the "matrix.csr.chol" class
mch5g &lt;- as.matrix.csr(ch5g)
print.table(as.matrix(mch5g), zero.print=".") # indeed upper triagonal w/ positive diagonal

## x5 has even more extreme entry at [5,5]:
x5 &lt;- x5g; x5[5,5] &lt;- 2.9e32
m5 &lt;- as.matrix(x5)
(c5 &lt;- chol(m5))# still fine, w/ [5,5] entry = 1.7e16 and other diag.entries in (9.56, 17.32)
ch5 &lt;- chol(x5) # --&gt; warning  "Replaced 3 tiny diagonal entries by 'Large'"
                # gave error for a while
(mmc5 &lt;- as.matrix(as.matrix.csr(ch5)))
        # yes, these replacements were extreme, and the result is "strange'
## Solve the problem (here) specifying non-default  singularity-tuning par 'tiny':
ch5. &lt;- chol(x5, tiny = 1e-33)
(mmc5. &lt;- as.matrix(as.matrix.csr(ch5.))) # looks much better.
## Indeed: R'R  back-permuted *is* the original matrix x5, here m5:
(RtR &lt;- crossprod(mmc5.)[ch5.@invp, ch5.@invp])
          all.equal(m5, RtR, tolerance = 2^-52)
stopifnot(all.equal(m5, RtR, tolerance = 1e-14)) # on F38 Linux, only need tol = 1.25e-16
</code></pre>


</div>