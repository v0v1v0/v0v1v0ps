<div class="container">

<table style="width: 100%;"><tr>
<td>Ey.given.x</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
E-Step for Abundance Estimation
</h2>

<h3>Description</h3>

<p>Take the E-step of the EM algorithm for estimating the number of
sonicants in a sample
</p>


<h3>Usage</h3>

<pre><code class="language-R">Ey.given.x(x, theta, phi)
pr.y.given.x(x, theta, phi, kmax=20 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a zero-one indicator matrix whose rows correspond to unique lengths with rownames
indicating those lengths
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p> a vector of the abundance estimates. <code>length(theta)==ncol(x)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi </code></td>
<td>
<p> a vector of the probabilities of sonicant
lengths. <code>length(phi)==nrow(x)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmax</code></td>
<td>
<p> highest count to bother with (all higher values are
globbed together in the result) </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> Supposing Poisson sampling of sonicants,
<code>Ey.given.x(x,theta,phi)[i,j]</code> gives the expected value of the
number of sonicants given that <code>x[i,j]</code> distinct sonicant lengths
were observed. <code>pr.y.given.x(x,theta,phi.kmax)[k,j]</code> gives the
probability of <code>k</code> sonicants (censored at <code>kmax+1</code>) of
insertion site <code>j</code> </p>


<h3>Value</h3>

<p><code>Ey.given.x()</code> is a double matrix of the same dimension as
<code>x</code>. <code>pr.y.given.x(...,kmax)</code> is a double matrix of
dimension <code>c( kmax+1, ncol(x) )</code> 
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:ccberry@users.r-forge.r-project.org">ccberry@users.r-forge.r-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
mat &lt;- diag(10)
mat[ ,10 ] &lt;- 1.0
phi1 &lt;- prop.table( rep(1,10))
theta1 &lt;- 1:10
Ey.given.x( mat, theta1, phi1 )
pr.mat &lt;- pr.y.given.x( mat, theta1, phi1 )
## Estimate Seen plus Unseen sites
popsize.chao &lt;- function(tab) sum(tab)+tab[1]*(tab[1]-1)/(2*(tab[2]+1))
## evaluate at expected counts
popsize.chao( rowSums(pr.mat) ) 
## average randomly sampled counts
cnt.samp &lt;- function(x) sample( seq_along(x) , 1 ,pr=x )
mean(replicate(100,popsize.chao( table(apply(pr.mat,2, cnt.samp) ))))
</code></pre>


</div>