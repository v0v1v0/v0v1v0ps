<div class="container">

<table style="width: 100%;"><tr>
<td>sk_corr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stationary 1D correlation kernels</h2>

<h3>Description</h3>

<p>Computes stationary correlation function values for the n (non-negative) 1-dimensional
distances in <code>d</code>. Parameter list entry <code>pars$kp</code> supplies the kernel parameter(s).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_corr(pars, d = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>list with elements 'k', the kernel name, and 'kp' the parameter vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>numeric vector of length n, the distances to evaluate</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pars$k</code> must be one of the following kernel names:
</p>

<ul>
<li>
<p> 'exp': exponential (special case of 'gex' with shape p=1)
</p>
</li>
<li>
<p> 'gau': gaussian/stable (special case of 'gex' with shape p=2)
</p>
</li>
<li>
<p> 'sph': spherical (AKA stable/Gaussian for p=2)
</p>
</li>
<li>
<p> 'gex': gamma-exponential (with shape p)
</p>
</li>
<li>
<p> 'mat': Whittle-Matern (Handcock and Wallis parameterization, with shape kap)
</p>
</li>
</ul>
<p>where the first three kernels have only a range parameters, and the last two have both a
range and shape parameter.
</p>
<p>For the 1-parameter kernels, <code>pars$kp</code> is the range parameter value ('rho'); For the
2-parameter kernels, <code>pars$kp</code> is a vector whose first element is 'rho', and second
element is the shape parameter ('p' or 'kap'). The names in <code>pars$kp</code> are ignored and
only the order matters - the range parameter always comes first.
</p>
<p>Note that this function will not accept parameter lists <code>pars</code> of the form returned by
<code>sk_pars(...)</code> etc, as these include a pair of 1d kernels (however the sub-lists
<code>pars$y</code> and <code>pars$x</code> are accepted).
</p>


<h3>Value</h3>

<p>length-n vector or a list of parameters and bounds (see details)
</p>


<h3>See Also</h3>

<p>Other internal variance-related functions: 
<code>sk_corr_mat()</code>,
<code>sk_toep_mult()</code>,
<code>sk_var_mult()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# define test distances, grid, and example kernel
n_test = 100
d_test = seq(n_test)-1
g_example = sk(n_test)
pars = sk_pars(g_example, c('mat', 'gau'))
pars_x = pars[['x']]

# compute and plot the x component of the correlogram function
corr_x_example = sk_corr(pars_x, d=d_test)
plot(d_test, corr_x_example, pch=NA)
lines(d_test, corr_x_example)

## show how this function gets used to build more complicated objects

# get the other component correlation, take product
pars_y = pars[['y']]
corr_y_example = sk_corr(pars_y, d=d_test)
corr_example = corr_y_example * corr_x_example

# variogram
variogram_example = sk_vario_fun(pars, d=list(y=d_test, x=d_test))
variogram_compare = 2 * pars$eps + pars$psill * (1 - corr_example)
max(abs( variogram_example - variogram_compare ))

# Toeplitz component matrices built entirely from these correlation vectors
variance_matrix_example = sk_var(g_example, pars, sep=TRUE)
str(variance_matrix_example)
max(abs( variance_matrix_example[['y']][,1L] - corr_y_example ))
max(abs( variance_matrix_example[['x']][,1L] - corr_x_example ))

</code></pre>


</div>