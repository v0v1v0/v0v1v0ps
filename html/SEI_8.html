<div class="container">

<table style="width: 100%;"><tr>
<td>std_index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate standardised indices</h2>

<h3>Description</h3>

<p>Inputs a time series of a chosen variable (e.g. precipitation,
energy demand, residual load etc.) and returns a time series of standardised indices.
Indices can be calculated on any timescale.
</p>


<h3>Usage</h3>

<pre><code class="language-R">std_index(
  x_new,
  x_ref = x_new,
  dist = "empirical",
  preds_new = NULL,
  preds_ref = preds_new,
  method = "mle",
  return_fit = FALSE,
  index_type = "normal",
  gr_new = NULL,
  gr_ref = gr_new,
  timescale = NULL,
  moving_window = NULL,
  window_scale = NULL,
  agg_period = NULL,
  agg_scale = NULL,
  agg_fun = "sum",
  rescale = NULL,
  rescale_fun = "sum",
  ignore_na = FALSE,
  n_thres = 10,
  na_thres = 10,
  lower = -Inf,
  upper = Inf,
  cens = index_type,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_new</code></td>
<td>
<p>vector or time series to be converted to standardised indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_ref</code></td>
<td>
<p>vector or time series containing reference data to use when calculating the standardised indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>character string specifying the distribution to be fit to the data;
one of <code>'empirical'</code>, <code>'kde'</code>, <code>'norm'</code>, <code>'lnorm'</code>, <code>'logis'</code>, <code>'llogis'</code>,
<code>'exp'</code>, <code>'gamma'</code>, and <code>'weibull'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preds_new</code></td>
<td>
<p>data frame of predictor variables on which the estimated distribution
should depend, corresponding to the new observations <code>x_new</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preds_ref</code></td>
<td>
<p>data frame of predictor variables on which the estimated distribution
should depend, corresponding to the reference observations <code>x_ref</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A character string coding for the fitting method: 
<code>"mle"</code> for 'maximum likelihood estimation', <code>"mme"</code> for 'moment matching estimation', 
<code>"qme"</code> for 'quantile matching estimation', <code>"mge"</code> for 'maximum goodness-of-fit estimation'
and <code>"mse"</code> for 'maximum spacing estimation'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_fit</code></td>
<td>
<p>logical specifying whether to return parameters and goodness-of-fit
statistics for the distribution fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_type</code></td>
<td>
<p>the type of standardised index: <code>"normal"</code> (default), <code>"prob01"</code>,
or <code>"prob11"</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr_new</code></td>
<td>
<p>vector of factors for which separate distributions should be applied to <code>x_new</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr_ref</code></td>
<td>
<p>vector of factors for which separate distributions should be fit to <code>x_ref</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timescale</code></td>
<td>
<p>timescale of the data; one of <code>'mins'</code>, <code>'hours'</code>, <code>'days'</code>, <code>'weeks'</code>, <code>'months'</code>, <code>'years'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moving_window</code></td>
<td>
<p>length of moving window on which to calculate the indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window_scale</code></td>
<td>
<p>timescale of <code>moving_window</code>; default is the timescale of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agg_period</code></td>
<td>
<p>length of the aggregation period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agg_scale</code></td>
<td>
<p>timescale of <code>agg_period</code>;
one of <code>'mins'</code>, <code>'hours'</code>, <code>'days'</code>, <code>'weeks'</code>, <code>'months'</code>, <code>'years'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agg_fun</code></td>
<td>
<p>string specifying the function used to aggregate the data over the
aggregation period, default is <code>'sum'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>the timescale that the time series should be rescaled to;
one of <code>"days"</code>, <code>"weeks"</code>, <code>"months"</code>, <code>"quarters"</code>, and <code>"years"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_fun</code></td>
<td>
<p>string specifying the function used to rescale the data; default is <code>"sum"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_na</code></td>
<td>
<p>logical specifying whether to ignore NAs when rescaling the time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_thres</code></td>
<td>
<p>minimum number of data points required to estimate the distribution;
default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_thres</code></td>
<td>
<p>threshold for the percentage of NA values allowed in the
aggregation period; default is 10%.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>numeric values specifying the lower and upper bounds at which the
values in <code>x_ref</code> and <code>x_new</code> are censored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens</code></td>
<td>
<p>method used to deal with censoring of the PIT values; either a string
(<code>'none'</code>, <code>'normal'</code> or <code>'prob'</code>), corresponding to common choices, or a custom numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to <code>fitdist</code> or
<code>gamlss</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Standardised indices</strong>
</p>
<p>Standardised indices are calculated by estimating the cumulative distribution function (CDF)
of the variable of interest, and using this to transform the measurements to
a standardised scale. <code>std_index</code> is a wrapper for <code>get_pit</code> and
<code>fit_dist</code> that additionally allows for aggregation, rescaling, and grouping
of the time series. Further details can be found in the help pages of <code>get_pit</code>
and <code>fit_dist</code>.
</p>
<p><code>std_index</code> estimates the CDF using a time series of reference data <code>x_ref</code>,
and applies the resulting transformation to the time series <code>x_new</code>. The result is
a time series of standardised <code>x_new</code> values. These standardised indices quantify
how extreme the <code>x_new</code> values are in reference to <code>x_ref</code>.
<code>x_new</code> and <code>x_ref</code> should therefore contain values of the same variable.
If <code>x_ref</code> is not specified, then it is set equal to <code>x_new</code>, so that the
standardised indices are calculated in-sample.
</p>
<p>The function returns a vector or time series (depending on the format of <code>x_new</code>)
containing the standardised indices corresponding to <code>x_new</code>. Three different
types of indices are available, which are explained in detail in the vignette.
The index type can be chosen using <code>index_type</code>, which must be one of
<code>"normal"</code> (default), <code>"prob01"</code>, and <code>"prob11"</code>.
</p>
<p><strong>Time series manipulations</strong>
</p>
<p><code>x_new</code> and <code>x_ref</code> can either be provided as vectors or <code>xts</code> time series.
In the latter case, the time series can be aggregated across timescales or rescaled.
This is useful, for example, if <code>x_new</code> contains hourly data, but interest is
on daily accumulations or averages of the hourly data.
</p>
<p>The argument <code>rescale</code> converts the data to a different timescale. The original
timescale of the data can be manually specified using the argument <code>timescale</code>.
<code>timescale</code> is required if the time series is to be aggregated or rescaled.
Otherwise, <code>std_index</code> will try to automatically determine the timescale of the data.
Manually specifying the timescale of the data is generally more robust. The rescaling
is performed using the function <code>rescale_fun</code>. By default,
<code>rescale_fun = "sum"</code>, so that values are added across the timescale of interest.
This can be changed to any user-specified function.
</p>
<p>The argument <code>agg_period</code> aggregates the data across the timescale of interest.
The aggregation is performed using <code>aggregate_xts</code>.
This differs from <code>rescale</code> in that the resolution of the data remains the same.
<code>agg_period</code> is a number specifying how long the data should be aggregated across.
By default, it is assumed that <code>agg_period</code> is on the same timescale as <code>x_new</code>
and <code>x_ref</code>. For example, if the data is hourly and <code>agg_period = 24</code>, then
this assumes the data is to be aggregated over the past 24 hours. The scale of the
aggregation period can also be specified manually using <code>agg_scale</code>. For example,
specifying <code>agg_period = 1</code> and <code>agg_scale = "days"</code>
would also aggregate the data over the past day. <code>agg_fun</code> specifies how the
data is to be aggregated, the default is <code>agg_fun = "sum"</code>.
</p>
<p><strong>Distribution estimation</strong>
</p>
<p><code>dist</code> is the distribution used to estimate the CDF from <code>x_ref</code>.
Currently, functionality is available to fit one of the following distributions to the data:
Normal (<code>"norm"</code>), Log-normal (<code>"lnorm"</code>), Logistic (<code>"logis"</code>),
Log-logistic (<code>"llogis"</code>), Exponential (<code>"exp"</code>), Gamma (<code>"gamma"</code>),
and Weibull (<code>"weibull"</code>).
Alternatively, the CDF can be estimated empirically (<code>dist = "empirical"</code>)
based on the values in <code>x_ref</code>, or using kernel density estimation (<code>dist = "kde"</code>).
</p>
<p>If <code>dist</code> is a parametric family of distributions, then parameters of the
distribution are estimated from <code>x_ref</code>. <code>method</code> specifies how the parameters
are estimated; see <code>fit_dist</code> for details.
The resulting parameters and corresponding goodness-of-fit statistics can be
returned by specifying <code>return_fit = TRUE</code>.
</p>
<p>By default, the distribution is estimated over all values in <code>x_ref</code>. Alternatively,
if <code>x_new</code> is an <code>xts</code> object, parameters can be estimated sequentially using a
moving window of values. <code>moving_window</code> determines the length of the moving window.
This is a single value, assumed to be on the same timescale as <code>x_new</code>.
The timsscale of the moving window can also be specified manually using <code>window_scale</code>.
<code>window_scale</code> must also be one of <code>"days"</code>, <code>"weeks"</code>, <code>"months"</code>,
<code>"quarters"</code>, and <code>"years"</code>.
</p>
<p>The estimated distribution can also be non-stationary, by depending on some predictors
or covariates. These predictors can be stored in data frames and input to <code>std_index</code>
via the arguments <code>preds_new</code> and <code>preds_ref</code>; see <code>fit_dist</code> for
details. Predictors cannot be used if the data is to be rescaled, since this would also
require rescaling the predictors; in this case, an error is returned.
</p>
<p><strong>Grouping</strong>
</p>
<p>By default, one distribution is fit to all values in <code>x_ref</code>. Separate distributions
can be fit to different subsets of the data by specifying <code>gr_ref</code> and <code>gr_new</code>.
These should be factor vectors, where each factor corresponds to a different grouping or
subset of the data.
No factor should appear in <code>gr_new</code> that does not appear in <code>gr_ref</code>, since
there would be no data from which to estimate the distribution for this group. An error
is returned in this case.
Since the distribution of the values in <code>x_ref</code> could change for different groupings,
the argument <code>dist</code> can be a vector of strings of the same length as the number of
factor levels in <code>gr_new</code>. In this case, the first element of <code>dist</code>
should correspond to the first element of <code>levels(gr_new)</code> and so on.
If <code>dist</code> is a single string, then the same distribution is used for each grouping.
</p>


<h3>Value</h3>

<p>Time series of standardised indices. If <code>return_fit = TRUE</code>, then a list is returned
that contains the time series of standardised indices, as well as information about the
fit of the distribution to the data. If <code>gr_new</code> is specified, then <code>std_index</code>
returns a list of time series of standardised indices, with an element corresponding to
each factor in <code>gr_new</code>.
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>References</h3>

<p>McKee, T. B., Doesken, N. J., &amp; Kleist, J. (1993):
‘The relationship of drought frequency and duration to time scales’,
<em>In Proceedings of the 8th Conference on Applied Climatology</em> 17, 179-183.
</p>
<p>Vicente-Serrano, S. M., Beguería, S., &amp; López-Moreno, J. I. (2010):
‘A multiscalar drought index sensitive to global warming: the standardized precipitation evapotranspiration index’,
<em>Journal of Climate</em> 23, 1696-1718.
<a href="https://doi.org/10.1175/2009JCLI2909.1">doi:10.1175/2009JCLI2909.1</a>
</p>
<p>Allen, S. &amp; N. Otero (2023):
‘Standardised indices to monitor energy droughts’,
<em>Renewable Energy</em> 217, 119206.
<a href="https://doi.org/10.1016/j.renene.2023.119206">doi:10.1016/j.renene.2023.119206</a>
</p>


<h3>See Also</h3>

<p><code>xts</code> <code>aggregate_xts</code> <code>get_pit</code> <code>fit_dist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(data_supply)
# consider hourly German energy supply data in 2019
supply_de &lt;- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de &lt;- xts::xts(supply_de$PWS, order.by = supply_de$date)
#options(xts_check_TZ = FALSE)

# convert to hourly standardised indices
supply_de_std &lt;- std_index(supply_de, timescale = "hours")
hist(supply_de, main = "Raw values")
hist(supply_de_std, main = "Standardised values")

# convert to daily or weekly standardised indices
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days")

# convert to weekly standardised indices calculated on each day
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           agg_period = 1, agg_scale = "weeks")

# calculate standardised indices corresponding to December, based on the previous year
dec &lt;- zoo::index(supply_de) &gt; "2019-12-01 UTC"
supply_de_std_dec &lt;- std_index(x_new = supply_de[dec], x_ref = supply_de[!dec],
                               timescale = "hours")

# calculate standardised indices using a 100 day moving window
supply_de_std_dec &lt;- std_index(supply_de[dec], supply_de, timescale = "hours",
                               rescale = "days", moving_window = 100)

# suppose we are interested in the daily maximum rather than the daily total
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           rescale_fun = "max")
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           rescale_fun = "mean") # or average

# the default uses the empirical distribution, but this requires more data than
# parametric distributions, meaning it is not ideal when data is short, e.g. in weekly case
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks") # warning
# instead, we can use a parametric distribution, e.g. a gamma distribution
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "gamma")
# we can check the fit by checking whether the indices resemble a standard normal distribution
hist(supply_de)
hist(supply_de_std)
# we can also look at the properties of the fit
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks",
                           dist = "gamma", return_fit = TRUE)

# we could also use kernel density estimation, which is a flexible compromise between the two
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "kde")


# calculate separate indices for each quarter of 2019
season &lt;- ceiling(lubridate::month(zoo::index(supply_de)) / 3)
season &lt;- factor(c("Q1", "Q2", "Q3", "Q4")[season])
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           gr_new = season, dist = "kde", return_fit = TRUE)


# non-stationary distribution estimation using gamlss

N &lt;- 1000
x &lt;- seq(-10, 20, length.out = N)
data &lt;- rnorm(N, x, exp(x/10)) # non-stationary mean and standard deviation
plot.ts(data)
preds &lt;- data.frame(t = x)

# standardised indices without trend
si_st &lt;- std_index(data, dist = "norm")
plot_sei(si_st)
# standardised indices with trend in mean
si_nst &lt;- std_index(data, dist = "norm", preds_new = preds)
plot_sei(si_nst)
# standardised indices with trend in mean and sd
si_nst2 &lt;- std_index(data, dist = "norm", preds_new = preds, sigma.formula = ~ .)
plot_sei(si_nst2)


</code></pre>


</div>