<div class="container">

<table style="width: 100%;"><tr>
<td>doApply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions for Iterating Over All Subjobs</h2>

<h3>Description</h3>

<p><code>doLapply()</code> iterates over all subjobs (using the non-parallel
<code>lapply()</code>). Similarly, but in parallel, for
<code>doForeach</code> (based on CRAN package <a href="https://CRAN.R-project.org/package=foreach"><span class="pkg">foreach</span></a>'s <code>foreach()</code>),
<code>doRmpi</code> (based on <a href="https://CRAN.R-project.org/package=Rmpi"><span class="pkg">Rmpi</span></a>'s <code>mpi.apply()</code>),
<code>doMclapply</code> (based on <span class="pkg">parallel</span>'s <code>mclapply()</code>), and
<code>doClusterApply</code> (based on <span class="pkg">parallel</span>'s <code>clusterApply()</code>).
</p>
<p><code>doRes.equal()</code> is simple convenience wrapper for
<code>all.equal()</code>, for comparing two results (from the same
<code>varlist</code> and <code>doOne</code> arguments) of the <code>do*</code>
lapply-like functions above.
</p>


<h3>Usage</h3>

<pre><code class="language-R">doLapply(vList, seed="seq", repFirst=TRUE,
       sfile=NULL, check=TRUE, doAL=TRUE, subjob.=subjob, monitor=FALSE,
       doOne, ...)
doForeach(vList, cluster=makeCluster(detectCores(), type="PSOCK"),
       cores=NULL, block.size = 1, seed="seq", repFirst=TRUE,
       sfile=NULL, check=TRUE, doAL=TRUE, subjob.=subjob, monitor=FALSE,
       doOne, extraPkgs=character(), exports=character(), ...)
doRmpi(vList,
       nslaves = if((sz &lt;- Rmpi::mpi.universe.size()) &lt;= 1) detectCores() else sz,
       load.balancing=TRUE, block.size = 1, seed="seq", repFirst=TRUE,
       sfile=NULL, check=TRUE, doAL=TRUE, subjob.=subjob, monitor=FALSE,
       doOne, exports=character(), ...)
doMclapply(vList, cores = if(.Platform$OS.type == "windows") 1 else detectCores(),
       load.balancing=TRUE, block.size = 1, seed="seq", repFirst=TRUE,
       sfile=NULL, check=TRUE, doAL=TRUE, subjob.=subjob, monitor=FALSE,
       doOne, ...)
doClusterApply(vList, cluster=makeCluster(detectCores(), type="PSOCK"),
       load.balancing=TRUE, block.size = 1, seed="seq", repFirst=TRUE,
       sfile=NULL, check=TRUE, doAL=TRUE, subjob.=subjob, monitor=FALSE,
       doOne, initExpr, exports=character(), ...)

doRes.equal(x, y, tol = 1e-15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vList</code></td>
<td>
<p>a <code>list</code> of variable specifications. Each
variable spec is itself a named list which must contain a
<code>"value"</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>cluster object, typically generated by
<code>makeCluster()</code>. For <code>doForeach()</code>, this can
be <code>NULL</code> as well, see Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>the number of cores. For <code>doForeach()</code>, this can
be <code>NULL</code> as well, see Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nslaves</code></td>
<td>
<p>the number of workers for <code>doRmpi</code>, passed
to package <a href="https://CRAN.R-project.org/package=Rmpi"><span class="pkg">Rmpi</span></a>'s <code>mpi.spawn.Rslaves</code> when no
running workers are found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>load.balancing</code></td>
<td>
<p><code>logical</code> indicating whether
load balancing is used:
</p>

<dl>
<dt>doRmpi()</dt>
<dd>
<p><code>mpi.applyLB()</code> is used instead of
<code>mpi.apply()</code>.</p>
</dd>
<dt>doMclapply()</dt>
<dd>
<p>here, <code>mc.preschedule=!load.balancing</code>
determines load balancing.</p>
</dd>
<dt>doClusterApply()</dt>
<dd>
<p><code>clusterApplyLB()</code> instead of
<code>clusterApply()</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block.size</code></td>
<td>
<p>size of blocks of rows in the virtual grid which are
computed simultaneously (load-balancing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed, repFirst</code></td>
<td>
<p>see <code>subjob()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfile, check, doAL</code></td>
<td>
<p>see <code>saveSim()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subjob.</code></td>
<td>
<p>a <code>function</code> for computing a subjob (one
row of the virtual grid). Typically <code>subjob()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doOne</code></td>
<td>
<p>a user-supplied <code>function</code> for computing one
row of the (physical) grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitor</code></td>
<td>
<p>a logical or a <code>function</code> for producing
“monitoring” output; the function argument list must contain
the one of <code>printInfo[["default"]]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extraPkgs</code></td>
<td>
<p><code>character</code> vector of packages to be made
available on the nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exports</code></td>
<td>
<p><code>character</code> vector of functions (for
<code>doForeach()</code> and <code>doClusterApply()</code>) or
objects (for <code>doRmpi()</code>) to export.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initExpr</code></td>
<td>
<p>expression initially evaluated on the cluster
(can be missing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>subjob()</code> (typically
further passed on to <code>doOne()</code>), or, for <code>doRes.equal()</code>, to
<code>all.equal(*)</code>.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>each a result of, say <code>doLapply()</code> which should be
compared where sensible, i.e., the first three components
<code>"value"</code>,<code>"error"</code>,<code>"warning"</code>, using
<code>all.equal</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>passed to <code>all.equal(*)</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the vignette or references in <code>simsalapar-package</code> for
how to use these functions.
</p>
<p>For reasons to choose <code>"MPI"</code> as cluster type (if not on Windows),
see the discussion starting at
<a href="https://stat.ethz.ch/pipermail/r-sig-hpc/2013-April/001647.html">https://stat.ethz.ch/pipermail/r-sig-hpc/2013-April/001647.html</a>.
</p>
<p>For <code>doForeach()</code>, precisely one of <code>cluster</code> or
<code>cores</code> has to be not <code>NULL</code>. This will determine whether
the parallel computations are carried out on a cluster with multiple
nodes or on a multi-core processor.
</p>


<h3>Value</h3>

<p>The result of applying <code>subjob()</code> to all subjobs, converted with
<code>saveSim()</code>.
</p>


<h3>Author(s)</h3>

<p>Marius Hofert and Martin Maechler.</p>


<h3>See Also</h3>

<p><code>subjob()</code> for computing a subjob.  <code>doCallWE()</code>
for the return value of <code>doOne()</code>.  <code>.Random.seed</code> for
information about random number generators and seeds.
</p>


<h3>Examples</h3>

<pre><code class="language-R"> if(simsalapar:::doExtras()) { ## needs some CPU
   demo(robust.mean) # 512 simulations, differing block sizes, ...
 }
</code></pre>


</div>