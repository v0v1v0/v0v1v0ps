<div class="container">

<table style="width: 100%;"><tr>
<td>latent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Bayesian hierarchical models for spatial extremes
</h2>

<h3>Description</h3>

<p>This function generates a Markov chain from a Bayesian hierarchical
model for block maxima assuming conditional independence.
</p>


<h3>Usage</h3>

<pre><code class="language-R">latent(data, coord, cov.mod = "powexp", loc.form, scale.form,
shape.form, marg.cov = NULL, hyper, prop, start, n = 5000, thin = 1,
burn.in = 0, use.log.link = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.mod</code></td>
<td>
<p>A character string corresponding to the covariance
model for the Gaussian latent processes. Must be one of "gauss" for
the Smith's model; "whitmat", "cauchy", "powexp" or "bessel" or
for the Whittle-Matern, the Cauchy, the Powered Exponential and the
Bessel correlation families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc.form, scale.form, shape.form</code></td>
<td>
<p>R formulas defining the
spatial linear model for the mean of the latent processes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marg.cov</code></td>
<td>
<p>Matrix with named columns giving additional covariates
for the latent processes means. If <code>NULL</code>, no extra covariates are
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyper</code></td>
<td>
<p>A named list specifying the hyper-parameters — see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>A named list specifying the jump sizes when a
Metropolis–Hastings move is needed — see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A named list specifying the starting values — see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The effective length of the simulated Markov chain i.e., once
the burnin period has been discarded and after thinning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>An integer specifying the thinning length. The default is
1, i.e., no thinning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn.in</code></td>
<td>
<p>An integer specifying the burnin period. The default is
0, i.e., no burnin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.log.link</code></td>
<td>
<p>An integer. Should a log-link function should be
use for the GEV scale parameters, i.e., assuming that the GEV scale
parameters a drawn from a log-normal process rather than a gaussian
process.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates a Markov chain from the following model. For
each <code class="reqn">x \in R^d</code>, suppose that
<code class="reqn">Y(x)</code> is GEV distributed whose parameters <code class="reqn">\{\mu(x),
    \sigma(x), \xi(x)\}</code> vary smoothly for
<code class="reqn">x \in R^d</code> according to a stochastic process
<code class="reqn">S(x)</code>. We assume that the processes for each GEV
parameters are mutually independent Gaussian processes. For instance,
we take for the location parameter <code class="reqn">\mu(x)</code>
</p>
<p style="text-align: center;"><code class="reqn">\mu(x) = f_{\mu(x)}(x;\beta_\mu) + S_\mu(x;\alpha_{\mu},
    \lambda_\mu, \kappa_\mu)</code>
</p>

<p>where <code class="reqn">f_\mu</code> is a deterministic function depending on
regression parameters <code class="reqn">\beta_\mu</code>, and
<code class="reqn">S_\mu</code> is a zero mean, stationary Gaussian process with a
prescribed covariance function with sill <code class="reqn">\alpha_\mu</code>,
range <code class="reqn">\lambda_\mu</code> and shape parameters
<code class="reqn">\kappa_\mu</code>. Similar formulations for the scale
<code class="reqn">\sigma(x)</code> and the shape <code class="reqn">\xi(x)</code> parameters
are used. Then conditional on the values of the three Gaussian
processes at the sites <code class="reqn">(x_1, \ldots, x_K)</code>,
the maxima are assumed to follow GEV distributions
</p>
<p style="text-align: center;"><code class="reqn">Y_i(x_j) \mid \{\mu(x_j), \sigma(x_j), \xi(x_j)\} \sim
    \mbox{GEV}\{\mu(x_j), \sigma(x_j), \xi(x_j)\},</code>
</p>

<p>independently for each location <code class="reqn">(x_1, \ldots, x_K)</code>.
</p>
<p>A joint prior density must be defined for the sills, ranges, shapes
parameters of the covariance functions as well as for the regression
parameters <code class="reqn">\beta_\mu</code>,<code class="reqn">\beta_\sigma</code>
and <code class="reqn">\beta_\xi</code>. Conjugate priors are used whenever
possible, taking independent inverse Gamma and multivariate normal
distributions for the sills and the regression parameters. No
conjugate prior exist for <code class="reqn">\lambda</code> and
<code class="reqn">\kappa</code>, for wich a Gamma distribution is assumed.
</p>
<p>Consequently <code>hyper</code> is a named list with named components
</p>

<dl>
<dt>sills</dt>
<dd>
<p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a 2-length vector specifying the shape
and the scale of the inverse Gamma prior distribution for the sill
parameter of the covariance functions;</p>
</dd>
<dt>ranges</dt>
<dd>
<p>A list with three components named 'loc', 'scale' and
'shape' each of these is a 2-length vector specifying the shape and
the scale of the Gamma prior distribution for the range parameter of
the covariance functions.</p>
</dd>
<dt>smooths</dt>
<dd>
<p>A list with three components named 'loc', 'scale' and
'shape' each of these is a 2-length vector specifying the shape and
the scale of the Gamma prior distribution for the shape parameter of
the covariance functions;</p>
</dd>
<dt>betaMean</dt>
<dd>
<p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a vector specifying the mean vector of
the multivariate normal prior distribution for the regression
parameters;</p>
</dd>
<dt>betaIcov</dt>
<dd>
<p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a matrix specifying the inverse of
the covariance matrix of the multivariate normal prior distribution
for the regression parameters.</p>
</dd>
</dl>
<p>As no conjugate prior exists for the GEV parameters and the range and
shape parameters of the covariance functions, Metropolis–Hastings
steps are needed. The proposals <code class="reqn">\theta_{prop}</code> are
drawn from a proposal density <code class="reqn">q(\cdot \mid \theta_{cur},
    s)</code> where <code class="reqn">\theta_{cur}</code> is
the current state of the parameter and <code class="reqn">s</code> is a parameter of
the proposal density to be defined. These proposals are driven by
<code>prop</code> which is a list with three named components 
</p>

<dl>
<dt>gev</dt>
<dd>
<p>A vector of length 3 specifying the standard deviations
of the proposal distributions. These are taken to be normal
distribution for the location and shape GEV parameters and a
log-normal distribution for the scale GEV parameters;</p>
</dd>
<dt>ranges</dt>
<dd>
<p>A vector of length 3 specifying the jump sizes for the
range parameters of the covariance functions — <code class="reqn">q(\cdot |
	\theta_{cur}, s)</code> is the log-normal density
with mean <code class="reqn">\theta_{cur}</code> and standard deviation
<code class="reqn">s</code> both on the log-scale;</p>
</dd>
<dt>smooths</dt>
<dd>
<p>A vector of length 3 specifying the jump sizes for
the shape parameters of the covariance functions — <code class="reqn">q(\cdot |
	\theta_{cur}, s)</code> is the log-normal density
with mean <code class="reqn">\theta_{cur}</code> and standard deviation
<code class="reqn">s</code> both on the log-scale.</p>
</dd>
</dl>
<p>If one want to held fixed a parameter this can be done by setting a null
jump size then the parameter will be held fixed to its starting value.
</p>
<p>Finally <code>start</code> must be a named list with 4 named components
</p>

<dl>
<dt>sills</dt>
<dd>
<p>A vector of length 3 specifying the starting values for
the sill of the covariance functions;</p>
</dd>
<dt>ranges</dt>
<dd>
<p>A vector of length 3 specifying the starting values
for the range of the covariance functions;</p>
</dd>
<dt>smooths</dt>
<dd>
<p>A vector of length 3 specifying the starting values
for the shape of the covariance functions;</p>
</dd>
<dt>beta</dt>
<dd>
<p>A named list with 3 components 'loc', 'scale' and
'shape' each of these is a numeric vector specifying the starting
values for the regression coefficients.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list</p>


<h3>Warning</h3>

<p>This function can be time consuming and makes an intensive use of BLAS
routines so it is (much!) faster if you have an optimized BLAS.
</p>
<p>The starting values will never be stored in the generated Markov chain
even when <code>burn.in=0</code>.
</p>


<h3>Note</h3>

<p>If you want to analyze the convergence ans mixing properties of the
Markov chain, it is recommended to use the library <span class="pkg">coda</span>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B. P., and Gelfand, A. E. (2004). Hierarchical
Modeling and Analysis for Spatial Data. Chapman &amp; Hall/CRC, New
York.
</p>
<p>Casson, E. and Coles, S. (1999) Spatial regression models for
extremes. <em>Extremes</em> <b>1</b>,449–468.
</p>
<p>Cooley, D., Nychka, D. and Naveau, P. (2007) Bayesian spatial
modelling of extreme precipitation return levels <em>Journal of the
American Statistical Association</em> <b>102</b>:479, 824–840.
</p>
<p>Davison, A.C., Padoan, S.A. and Ribatet, M. Statistical Modelling of
Spatial Extremes. Submitted.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Generate realizations from the model
n.site &lt;- 30
n.obs &lt;- 50
coord &lt;- cbind(lon = runif(n.site, -10, 10), lat = runif(n.site, -10 , 10))

gp.loc &lt;- rgp(1, coord, "powexp", sill = 4, range = 20, smooth = 1)
gp.scale &lt;- rgp(1, coord, "powexp", sill = 0.4, range = 5, smooth = 1)
gp.shape &lt;- rgp(1, coord, "powexp", sill = 0.01, range = 10, smooth = 1)

locs &lt;- 26 + 0.5 * coord[,"lon"] + gp.loc
scales &lt;- 10 + 0.2 * coord[,"lat"] + gp.scale
shapes &lt;- 0.15 + gp.shape

data &lt;- matrix(NA, n.obs, n.site)
for (i in 1:n.site)
  data[,i] &lt;- rgev(n.obs, locs[i], scales[i], shapes[i])

loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

hyper &lt;- list()
hyper$sills &lt;- list(loc = c(1,8), scale = c(1,1), shape = c(1,0.02))
hyper$ranges &lt;- list(loc = c(2,20), scale = c(1,5), shape = c(1, 10))
hyper$smooths &lt;- list(loc = c(1,1/3), scale = c(1,1/3), shape = c(1, 1/3))
hyper$betaMeans &lt;- list(loc = rep(0, 2), scale = c(9, 0), shape = 0)
hyper$betaIcov &lt;- list(loc = solve(diag(c(400, 100))),
                       scale = solve(diag(c(400, 100))),
                       shape = solve(diag(c(10), 1, 1)))

## We will use an exponential covariance function so the jump sizes for
## the shape parameter of the covariance function are null.
prop &lt;- list(gev = c(1.2, 0.08, 0.08), ranges = c(0.7, 0.8, 0.7), smooths = c(0,0,0))
start &lt;- list(sills = c(4, .36, 0.009), ranges = c(24, 17, 16), smooths
              = c(1, 1, 1),  beta = list(loc = c(26, 0.5), scale = c(10, 0.2),
                               shape = c(0.15)))

mc &lt;- latent(data, coord, loc.form = loc.form, scale.form = scale.form,
             shape.form = shape.form, hyper = hyper, prop = prop, start = start,
             n = 10000, burn.in = 5000, thin = 15)
mc

## End(Not run)
</code></pre>


</div>