<div class="container">

<table style="width: 100%;"><tr>
<td>str_match_arg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Argument Matching.</h2>

<h3>Description</h3>

<p>Match <code>arg</code> against a series of candidate <code>choices</code>. <code>arg</code> <em>matches</em> an
element of <code>choices</code> if <code>arg</code> is a prefix of that element.
</p>


<h3>Usage</h3>

<pre><code class="language-R">str_match_arg(
  arg,
  choices = NULL,
  index = FALSE,
  several_ok = FALSE,
  ignore_case = FALSE
)

match_arg(
  arg,
  choices = NULL,
  index = FALSE,
  several_ok = FALSE,
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>arg</code></td>
<td>
<p>A character vector (of length one unless <code>several_ok = TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choices</code></td>
<td>
<p>A character vector of candidate values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>Return the index of the match rather than the match itself?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>several_ok</code></td>
<td>
<p>Allow <code>arg</code> to have length greater than one to match
several arguments at once?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_case</code></td>
<td>
<p>Ignore case while matching. If this is <code>TRUE</code>, the
returned value is the matched element of <code>choices</code> (with its original
casing).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ERROR</code>s are thrown when a match is not made and where the match is
ambiguous. However, sometimes ambiguities are inevitable. Consider the case
where <code>choices = c("ab", "abc")</code>, then there's no way to choose <code>"ab"</code>
because <code>"ab"</code> is a prefix for <code>"ab"</code> and <code>"abc"</code>. If this is the case, you
need to provide a full match, i.e. using <code>arg = "ab"</code> will get you <code>"ab"</code>
without an error, however <code>arg = "a"</code> will throw an ambiguity error.
</p>
<p>When <code>choices</code> is <code>NULL</code>, the <code>choices</code> are obtained from a default setting
for the formal argument <code>arg</code> of the function from which <code>str_match_arg</code> was
called. This is consistent with <code>base::match.arg()</code>. See the examples for
details.
</p>
<p>When <code>arg</code> and <code>choices</code> are identical and <code>several_ok = FALSE</code>, the first
element of <code>choices</code> is returned. This is consistent with
<code>base::match.arg()</code>.
</p>
<p>This function inspired by <code>RSAGA::match.arg.ext()</code>. Its behaviour is almost
identical (the difference is that <code>RSAGA::match.arg.ext(..., ignore.case = TRUE)</code> always returns in all lower case; <code>strex::match_arg(..., ignore_case = TRUE)</code> ignores case while matching but returns the element of <code>choices</code> in
its original case). <code>RSAGA</code> is a heavy package to depend upon so
<code>strex::match_arg()</code> is handy for package developers.
</p>
<p>This function is designed to be used inside of other functions. It's fine to
use it for other purposes, but the error messages might be a bit weird.
</p>


<h3>Examples</h3>

<pre><code class="language-R">choices &lt;- c("Apples", "Pears", "Bananas", "Oranges")
match_arg("A", choices)
match_arg("B", choices, index = TRUE)
match_arg(c("a", "b"), choices, several_ok = TRUE, ignore_case = TRUE)
match_arg(c("b", "a"), choices,
  ignore_case = TRUE, index = TRUE,
  several_ok = TRUE
)
myword &lt;- function(w = c("abacus", "baseball", "candy")) {
  w &lt;- match_arg(w)
  w
}
myword("b")
myword()
myword &lt;- function(w = c("abacus", "baseball", "candy")) {
  w &lt;- match_arg(w, several_ok = TRUE)
  w
}
myword("c")
myword()
</code></pre>


</div>