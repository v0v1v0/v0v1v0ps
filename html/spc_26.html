<div class="container">

<table style="width: 100%;"><tr>
<td>pois.cusum.crit.L0L1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control ARL L1, Poisson case</h2>

<h3>Description</h3>

<p>Computation of the reference value k and the alarm threshold h
for one-sided CUSUM control charts monitoring Poisson data, if the in-control ARL L0 and the out-of-control ARL L1 are given.</p>


<h3>Usage</h3>

<pre><code class="language-R">pois.cusum.crit.L0L1(mu0, L0, L1, sided="upper", OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mu0</code></td>
<td>
<p>in-control Poisson mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>in-control ARL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L1</code></td>
<td>
<p>out-of-control ARL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p>distinguishes between <code>"upper"</code> and <code>"lower"</code> CUSUM designs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OUTPUT</code></td>
<td>
<p>controls whether iteration details are printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pois.cusum.crit.L0L1</code> determines the reference value k and the alarm threshold h
for given in-control ARL <code>L0</code> and out-of-control ARL <code>L1</code>
by applying grid search and using <code>pois.cusum.arl()</code> and <code>pois.cusum.crit()</code>.
These CUSUM design rules were firstly (and quite rarely afterwards) used by Ewan and Kemp.
In the Poisson case, Rossi et al. applied them while analyzing three different normal
approximations of the Poisson distribution. See the example which illustrates
the validity of all these approaches.
</p>


<h3>Value</h3>

<p>Returns a data frame with results for the denominator <code>m</code> of the rational approximation,
<code>km</code> as (integer) enumerator of the reference value (approximation), the corresponding
out-of-control mean <code>mu1</code>, the final approximation <code>k</code> of the reference value,
the threshold values <code>hm</code> (integer) and <code>h</code> (<code>=hm/m</code>), and the randomization constant
<code>gamma</code> (the target in-control ARL is exactly matched).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>W. D. Ewan and K. W. Kemp (1960),
Sampling inspection of continuous processes with no autocorrelation between successive results,
<em>Biometrika</em> 47 (3/4), 363-380.
</p>
<p>K. W. Kemp (1962),
The Use of Cumulative Sums for Sampling Inspection Schemes,
<em>Journal of the Royal Statistical Sociecty C, Applied Statistics</em> 11(1), 16-31.
</p>
<p>G. Rossi, L. Lampugnani and M. Marchi (1999),
An approximate CUSUM procedure for surveillance of health events,
<em>Statistics in Medicine</em> 18(16), 2111-2122.
</p>


<h3>See Also</h3>

<p><code>pois.cusum.arl</code> for zero-state ARL and <code>pois.cusum.crit</code> for threshold h computation.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Table 1 from Rossi et al. (1999) -- one-sided CUSUM
La &lt;- 500 # in-control ARL
Lr &lt;- 7 # out-of-control ARL
m_a &lt;- 0.52 # in-control mean of the Poisson variate
## Not run: kh &lt;- xcusum.crit.L0L1(La, Lr, sided="one")
# kh &lt;- ...: instead of deploying EK1960, one could use more accurate numbers
EK_k &lt;- 0.60 # EK1960 results in
EK_h &lt;- 3.80 # Table 2 on p. 372
eZR &lt;- 2*EK_h # reproduce normal ooc mean from reference value k
m_r &lt;- 1.58 # EK1960 Table 3 on p. 377 for m_a = 0.52
R1 &lt;- round( eZR/sqrt(m_a) + 1, digits=2)
R2 &lt;- round( ( eZR/2/sqrt(m_a) + 1 )^2, digits=2)
R3 &lt;- round(( sqrt(4 + 2*eZR/sqrt(m_a)) - 1 )^2, digits=2)
RS &lt;- round( m_r / m_a, digits=2 )
## Not run: K_hk &lt;- pois.cusum.crit.L0L1(m_a, La, Lr) # 'our' 'exact' approach
K_hk &lt;- data.frame(m=1000, km=948, mu1=1.563777, k=0.948, hm=3832, h=3.832, gamma=0.1201901)
# get k for competing means mu0 (m_a) and mu1 (m_r)
k_m01 &lt;- function(mu0, mu1) (mu1 - mu0) / (log(mu1) - log(mu0))
# get ooc mean mu1 (m_r) for given mu0 (m_a) and reference value k
m1_km0 &lt;- function(mu0, k) {
  zero &lt;- function(x) k - k_m01(mu0,x)
  upper &lt;- mu0 + .5
  while ( zero(upper) &gt; 0 ) upper &lt;- upper + 0.5
  mu1 &lt;- uniroot(zero, c(mu0*1.00000001, upper), tol=1e-9)$root
  mu1
}
K_m_r &lt;- m1_km0(m_a, K_hk$k)
RK &lt;- round( K_m_r / m_a, digits=2 )
cat(paste(m_a, R1, R2, R3, RS, RK, "\n", sep="\t"))
</code></pre>


</div>