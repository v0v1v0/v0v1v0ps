<div class="container">

<table style="width: 100%;"><tr>
<td>SJspearman</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulate joint given marginals and Spearman correlations.
</h2>

<h3>Description</h3>

<p>Reorder elements in each column of a matrix such that the column-wise Spearman correlations approximate a given correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SJspearman(
  X,
  cor,
  stochasticStepDomain = as.numeric(c(0, 1)),
  errorType = "meanSquare",
  seed = 123L,
  maxCore = 7L,
  convergenceTail = 8L,
  iterLimit = 100000L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>An <code>N x K</code> numeric matrix of <code>K</code> marginal distributions (samples). Columns are sorted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>

<p>A <code>K x K</code> correlation matrix. The matrix should be positive semi-definite.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stochasticStepDomain</code></td>
<td>

<p>A numeric vector of size 2. Range of the stochastic step ratio for correcting the correlation matrix in each iteration. Default [0, 1]. See the package vignette for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorType</code></td>
<td>

<p>Cost function for convergence test.
</p>
<p><code>"meanRela"</code>: average absolute relative error between elements of the target correlation matrix and the correlation matrix approximated in each iteration.
</p>
<p><code>"maxRela"</code>: maximal absolute relative error.
</p>
<p><code>"meanSquare"</code>: mean squared error. Default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>An integer or an integer vector of size 4. A single integer seeds a <code>pcg64</code> generator the usual way. An integer vector of size 4 supplies all the bits for a <code>pcg64</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCore</code></td>
<td>

<p>An integer. Maximal threads to invoke. Default 7. Better be no greater than the total number of virtual cores on machine.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergenceTail</code></td>
<td>

<p>An integer. If the last <code>convergenceTail</code> iterations resulted in equal cost function values, return. Default 8.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterLimit</code></td>
<td>

<p>An integer. The maximal number of iterations. Default 100000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A boolean value. <code>TRUE</code> prints progress.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithms are detailed in the package vignette.
</p>


<h3>Value</h3>

<p>A list of size 2.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p>A numeric matrix of size <code>N x K</code>, the simulated joint distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor </code></td>
<td>
<p>Spearman correlation matrix of <code>X</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># =============================================================================
# Use the same example from &lt;https://cran.r-project.org/web/packages/
#                            SimMultiCorrData/vignettes/workflow.html&gt;.
# =============================================================================
set.seed(123)
N = 10000L # Sample size.
K = 10L # 10 marginals.
# Sample from 3 PDFs, 2 nonparametric PMFs, 5 parametric PMFs:
marginals = cbind(
  rnorm(N), rchisq(N, 4), rbeta(N, 4, 2),
  LHSpmf(data.frame(val = 1:3, P = c(0.3, 0.45, 0.25)), N,
         seed = sample(1e6L, 1)),
  LHSpmf(data.frame(val = 1:4, P = c(0.2, 0.3, 0.4, 0.1)), N,
         seed = sample(1e6L, 1)),
  rpois(N, 1), rpois(N, 5), rpois(N, 10),
  rnbinom(N, 3, 0.2), rnbinom(N, 6, 0.8))
# The seeding for `LHSpmf()` is unhealthy, but OK for small examples.


marginals = apply(marginals, 2, function(x) sort(x))


# Create the target correlation matrix `Rey` treated as Spearman
# correlations.
set.seed(11)
Rey &lt;- diag(1, nrow = 10)
for (i in 1:nrow(Rey)) {
  for (j in 1:ncol(Rey)) {
    if (i &gt; j) Rey[i, j] &lt;- runif(1, 0.2, 0.7)
    Rey[j, i] &lt;- Rey[i, j]
  }
}


result = SimJoint::SJspearman(
  X = marginals, cor = Rey, errorType = "meanSquare", seed = 456,
  maxCore = 1, convergenceTail = 8, verbose = TRUE)


# Check relative errors.
summary(as.numeric(abs(cor(result$X, method = "spearman") / Rey - 1)))




# Another way to impose rank correlation is to supply rank matrix
# to SJpearson():
system.time({reorderedRanks = SimJoint::SJpearson(
  X = apply(marginals, 2, function(x) rank(x)), cor = Rey,
  errorType = "meanSquare", seed = 456, maxCore = 1,
  convergenceTail = 8, verbose = TRUE)})


# Reordering according to ranks:
result = apply(rbind(reorderedRanks$X, marginals), 2, function(x)
{
  x[(N + 1L) : (2L * N)][as.integer(x[1L : N])]
})


# Check the relative errors.
summary(as.numeric(abs(cor(result, method = "spearman") / Rey - 1)))
</code></pre>


</div>