<div class="container">

<table style="width: 100%;"><tr>
<td>SFS_sfs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Similarity-First Search multisweep algorithm</h2>

<h3>Description</h3>

<p>Return a ranking of the objects such that similar objects are ordered close to each other. If the matrix is <em>Robinsonian</em>, then the ranking returned is a <em>Robinson ordering</em>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">sfs(matrix, sfs_epsilon = 0, dissimilarity = FALSE, Robinsonian = FALSE, num_sweeps = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>a 3-columns <code>data frame</code> with no repeated symmetric entries, representing the list of all similarities (or dissimilarities) <code class="reqn">(i, j, A_{ij})</code> between the pairs of objects to reorder.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfs_epsilon</code></td>
<td>
<p>a numerical value which determines that two entries whose difference is below this threshold are considered to be equal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dissimilarity</code></td>
<td>
<p>a boolean value equal to <code>TRUE</code> if the input data is a dissimilarity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Robinsonian</code></td>
<td>
<p>a boolean value equal to <code>TRUE</code> if one wants to recognize a Robinsonian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_sweeps</code></td>
<td>
<p>an integer value that determines how many iterations of SFS shall be performed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a a 3-columns <code>data frame</code> <code class="reqn">(i, j, A_{ij})</code> listing all the similarities (or dissimilarities) among the objects, this function builds a <code>spMat</code> object in <em>Armadillo</em> and computes a finite number of repeated SFS iterations (each called a <em>sweep</em>). The user may decide the threshold for which two entries are considered equal, meaning that if <code class="reqn">|A_{ij} - A_{ik}| \leq</code> <code>sfs_epsilon</code>, then objects <code class="reqn">j</code> and <code class="reqn">k</code> have the same similarity (or dissimilarity) with respect to object <code class="reqn">i</code>. By default, this threshold is set to <code class="reqn">0</code>. <br> If not specified, the <code>matrix</code> represents the similarity information between objects. If <code>dissimilarity = TRUE</code>, then the <code>matrix</code> represents the dissimilarity information and the SFS algorithm is modified by sorting the neighborhood of a visited vertex for increasing values (instead of for decreasing values). <br>	 The parameter <code class="reqn">k=</code><code>num_sweeps</code> sets the number of sweeps performed by <code>SFS()</code>. This number directly affects the complexity of the function since, as each sweep runs in <code class="reqn">(k(n+m\log n))</code> time, <code>SFS()</code> runs in <code class="reqn">(k(n+m \log n))</code> time. By default, <code>num_sweeps=4</code>, as it is known that three sweeps suffice for recognizing Robinonian binary matrices and for general matrices experiments show that four sweeps are enough for finding a good ranking for most data. If <code>Robinsonian = TRUE</code>, then the number of sweeps is automatically set to the number of objects <code class="reqn">n</code> to rank minus one. In this case, <code>sfs()</code> also checks if the returned permutation is a Robinson ordering (since it is known that if the order returned after <code class="reqn">n-1</code> sweeps is not a Robinson ordering then the data is not Robinsonian). Efficient measures are implemented in order to avoid unnecessary time consuming loops between consecutive SFS iterations. Note that checking if a given permutation is a Robinson ordering is implemented at the moment only when dealing with similarities among the objects. <br> Finally, the object returned by <code>SFS()</code> is a vector of integers, where the entry at position <code class="reqn">i</code> represents the <code class="reqn">i</code>-th object in the ranking. If the <code>matrix</code> is 0-based, then the returned vector is 0-based. If <code>matrix</code> is 1-based, then the returned vector is 1-based.</p>


<h3>Value</h3>

<p>Return a (row) vector of integers representing the ranking of the objects, which is  0-based or 1-based accordingly with the input <code>matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Matteo Seminaroti (SFS) and Utz-Uwe Haus (R wrapping)</p>


<h3>References</h3>

 
<p>M. Laurent and M. Seminaroti. Similarity-First Search: a new algorithm with application to Robinsonian matrix recognition. SIAM Journal on Discrete Mathematics (to appear). <em>arXiv:1601.03521</em>. 2016.
</p>
<p>M. Seminaroti. Combinatorial Algorithms for the Seriation Problem. <em>PhD thesis</em>. School of Economics and Management, Tilburg University, pages 1â€“209. 2016.
</p>


<h3>Examples</h3>

<pre><code class="language-R">	## install package in R
 	#install.packages("SFS_0.1.tar.gz")
	#install.packages("seriation")
 	
 	## load package in R
 	library(SFS)
 
 	## invoke SFS on a R Matrix
 	mtxt &lt;- c("11 2 9 0 5 0 5 5 2 0 5 0 5 6 0 0 2 0 5",
         "2 11 2 0 9 0 8 5 10 0 5 0 5 2 0 0 10 0 8",
         "9 2 11 0 5 0 5 5 2 0 5 0 5 10 0 0 2 0 5",
         "0 0 0 11 0 3 0 0 0 3 0 3 0 0 10 3 0 9 0",
         "5 9 5 0 11 0 8 7 9 0 7 0 7 5 0 0 9 0 10",
         "0 0 0 3 0 11 0 0 0 10 0 6 0 0 5 8 0 5 0",
         "5 8 5 0 8 0 11 7 8 0 7 0 7 5 0 0 8 0 9",
         "5 5 5 0 7 0 7 11 6 0 10 0 8 7 0 0 6 0 7",
         "2 10 2 0 9 0 8 6 11 0 6 0 5 2 0 0 10 0 8",
         "0 0 0 3 0 10 0 0 0 11 0 6 0 0 4 9 0 5 0",
         "5 5 5 0 7 0 7 10 6 0 11 0 9 7 0 0 6 0 7",
         "0 0 0 3 0 6 0 0 0 6 0 11 0 0 9 6 0 10 0",
         "5 5 5 0 7 0 7 8 5 0 9 0 11 7 0 0 5 0 7",
         "6 2 10 0 5 0 5 7 2 0 7 0 7 11 0 0 2 0 5",
         "0 0 0 10 0 5 0 0 0 4 0 9 0 0 11 4 0 10 0",
         "0 0 0 3 0 8 0 0 0 9 0 6 0 0 4 11 0 4 0",
         "2 10 2 0 9 0 8 6 10 0 6 0 5 2 0 0 11 0 8",
         "0 0 0 9 0 5 0 0 0 5 0 10 0 0 10 4 0 11 0",
         "5 8 5 0 10 0 9 7 8 0 7 0 7 5 0 0 8 0 11")
  	M &lt;- as.matrix(read.table(textConnection(mtxt)))
  	A &lt;- SFS::read(M)
  	SFS::sfs(A, Robinsonian = TRUE)
  	
  	## invoke SFS on a data-frame with 3-column data-frames with 0-based vertices, with 
  	## (row, col, value) triples containing symmetric values
  	data &lt;- c("0 0 1.0",
            "1 0 1.5",
            "2 0 1.9",
            "0 1 2.0",
            "1 1 2.5",
            "2 1 2.9",
            "0 2 3.0",
            "1 2 3.5",
            "2 2 3.9")
  	M &lt;- read.table(textConnection(data))
  	A &lt;- SFS::read(M, identical_val = TRUE)
  	SFS::sfs(A)

  	## invoke SFS on a \code{dist} from seriation package:
    library(seriation)
    data("iris");
    x &lt;- as.matrix(iris[-5]);
    x &lt;- x[sample(1:nrow(x)),];
    M &lt;- dist(x)
    D &lt;- SFS::read(M)
    SFS::sfs(D, sfs_epsilon = 0.01, dissimilarity = TRUE)

	## invoke SFS reading from file a Robinsonian matrix
	M &lt;- read.table(system.file("extdata", "list_130.txt", package = "SFS"))
	A &lt;- SFS::read(M, identical_val = TRUE)
	SFS::sfs(A, Robinsonian = TRUE)
	
	## invoke SFS reading from file containing 3-columns (row, col, value) entries
        ## of an asymmetric non-Robinsonian similarity matrix with 1-based vertices
	M &lt;- read.table(system.file("extdata", "list_130.txt", package = "SFS"))
	A &lt;- SFS::read(M, identical_val = TRUE, symmetric = FALSE)
	SFS::sfs(A, num_sweeps = 7)
  
</code></pre>


</div>