<div class="container">

<table style="width: 100%;"><tr>
<td>line_segment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Divide an sf object with LINESTRING geometry into regular segments</h2>

<h3>Description</h3>

<p>This function keeps the attributes.
Note: results differ when <code>use_rsgeo</code> is <code>TRUE</code>:
the <code>{rsgeo}</code> implementation will be faster.
Results may not always keep returned linestrings below
the <code>segment_length</code> value.
The <code>{rsgeo}</code> implementation does not always
return the number of segments requested due to an upstream issue in the
<code>geo</code> Rust crate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">line_segment(
  l,
  segment_length = NA,
  n_segments = NA,
  use_rsgeo = NULL,
  debug_mode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>A spatial lines object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment_length</code></td>
<td>
<p>The approximate length of segments in the output (overrides n_segments if set)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_segments</code></td>
<td>
<p>The number of segments to divide the line into.
If there are multiple lines, this should be a vector of the same length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_rsgeo</code></td>
<td>
<p>Should the <code>rsgeo</code> package be used?
If <code>rsgeo</code> is available, this faster implementation is used by default.
If <code>rsgeo</code> is not available, the <code>lwgeom</code> package is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug_mode</code></td>
<td>
<p>Should debug messages be printed? Default is FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note: we recommend running these functions on projected data.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code>angle_diff()</code>,
<code>geo_toptail()</code>,
<code>is_linepoint()</code>,
<code>line2df()</code>,
<code>line2points()</code>,
<code>line_bearing()</code>,
<code>line_breakup()</code>,
<code>line_midpoint()</code>,
<code>line_segment1()</code>,
<code>line_via()</code>,
<code>mats2line()</code>,
<code>n_segments()</code>,
<code>n_vertices()</code>,
<code>onewaygeo()</code>,
<code>points2line()</code>,
<code>toptail_buff()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf)
l &lt;- routes_fast_sf[2:4, "ID"]
l_seg_multi &lt;- line_segment(l, segment_length = 1000, use_rsgeo = FALSE)
l_seg_n &lt;- line_segment(l, n_segments = 2)
l_seg_n &lt;- line_segment(l, n_segments = c(1:3))
# Number of subsegments
table(l_seg_multi$ID)
plot(l_seg_multi["ID"])
plot(l_seg_multi$geometry, col = seq_along(l_seg_multi), lwd = 5)
round(st_length(l_seg_multi))
# rsgeo implementation (default if available):
if (rlang::is_installed("rsgeo")) {
  rsmulti = line_segment(l, segment_length = 1000, use_rsgeo = TRUE)
  plot(rsmulti["ID"])
}
# Check they have the same total length, to nearest mm:
# round(sum(st_length(l_seg_multi)), 3) == round(sum(st_length(rsmulti)), 3)
# With n_segments for 1 line (set use_rsgeo to TRUE to use rsgeo):
l_seg_multi_n &lt;- line_segment(l[1, ], n_segments = 3, use_rsgeo = FALSE)
l_seg_multi_n &lt;- line_segment(l$geometry[1], n_segments = 3, use_rsgeo = FALSE)
# With n_segments for all 3 lines:
l_seg_multi_n &lt;- line_segment(l, n_segments = 2)
nrow(l_seg_multi_n) == nrow(l) * 2
</code></pre>


</div>