<div class="container">

<table style="width: 100%;"><tr>
<td>string_split2df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Splits a character vector into a data frame</h2>

<h3>Description</h3>

<p>Splits a character vector and formats the resulting substrings into a data.frame
</p>


<h3>Usage</h3>

<pre><code class="language-R">string_split2df(
  x,
  data = NULL,
  split = NULL,
  id = NULL,
  add.pos = FALSE,
  id_unik = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame(),
  dt = FALSE,
  ...
)

string_split2dt(
  x,
  data = NULL,
  split = NULL,
  id = NULL,
  add.pos = FALSE,
  id_unik = TRUE,
  fixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector or a two-sided formula. If a two-sided formula, then the
argument <code>data</code> must be provided since the variables will be fetched in there.
A formula is of the form <code>char_var ~ id1 + id2</code> where <code>char_var</code> on the left is a
character variable and on the right <code>id1</code> and <code>id2</code> are identifiers which will be
included in the resulting table. Alternatively, you can provide identifiers via
the argument <code>id</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional, only used if the argument <code>x</code> is a formula. It should
contain the variables of the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>A character scalar. Used to split the character vectors. By default
this is a regular expression. You can use flags in the pattern in the form <code style="white-space: pre;">⁠flag1, flag2/pattern⁠</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
magic (add interpolation with <code>"{}"</code>). Example:
if "ignore/hello" and the text contains "Hello", it will be split at "Hello".
Shortcut: use the first letters of the flags. Ex: "iw/one" will split at the word
"one" (flags 'ignore' + 'word').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Optional. A character vector or a list of vectors. If provided, the
values of <code>id</code> are considered as identifiers that will be included in the resulting table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.pos</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to include the position of each split element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_unik</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. In the case identifiers are provided,
whether to trigger a message if the identifiers are not unique. Indeed, if
the identifiers are not unique, it is not possible to reconstruct the original texts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to consider the argument <code>split</code>
as fixed (and not as a regular expression).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = "The, mountain" will select strings containing either the word
'The' or the word 'mountain'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to return a <code>data.table</code>. See also the function <code>string_split2dt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a <code>data.frame</code> or a <code>data.table</code> which will contain: i) <code>obs</code>: the observation index,
ii) <code>pos</code>: the position of the text element in the initial string (optional, via add.pos),
iii) the text element, iv) the identifier(s) (optional, only if <code>id</code> was provided).
</p>


<h3>Functions</h3>


<ul><li> <p><code>string_split2dt()</code>: Splits a string vector and returns a <code>data.table</code>
</p>
</li></ul>
<h3>See Also</h3>

<p>String operations: <code>string_is()</code>, <code>string_get()</code>, <code>string_clean()</code>, <code>string_split2df()</code>.
Chain basic operations with <code>string_ops()</code>. Clean character vectors efficiently
with <code>string_clean()</code>.
</p>
<p>Use <code>string_vec()</code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code>string_magic()</code>. You can change <code>string_magic</code>
default values with <code>string_magic_alias()</code> and add custom operations with <code>string_magic_register_fun()</code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code>cat_magic()</code> and <code>message_magic()</code>.
</p>
<p>Other tools with aliases: 
<code>cat_magic_alias()</code>,
<code>string_magic()</code>,
<code>string_magic_alias()</code>,
<code>string_ops_alias()</code>,
<code>string_vec_alias()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = c("Nor rain, wind, thunder, fire are my daughters.",
      "When my information changes, I alter my conclusions.")

id = c("ws", "jmk")

# we split at each word
string_split2df(x, "[[:punct:] ]+")

# we add the 'id'
string_split2df(x, "[[:punct:] ]+", id = id)

# TO NOTE:
# - the second argument is `data`
# - when it is missing, the argument `split` becomes implicitly the second
# - ex: above we did not use `split = "[[:punct:] ]+"`

#
# using the formula

base = data.frame(text = x, my_id = id)
string_split2df(text ~ my_id, base, "[[:punct:] ]+")

#
# with 2+ identifiers

base = within(mtcars, carname &lt;- rownames(mtcars))

# we have a message because the identifiers are not unique
string_split2df(carname ~ am + gear + carb, base, " +")

# adding the position of the words &amp; removing the message
string_split2df(carname ~ am + gear + carb, base, " +", id_unik = FALSE, add.pos = TRUE)


</code></pre>


</div>