<div class="container">

<table style="width: 100%;"><tr>
<td>do_ldet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial regression model Jacobian computations</h2>

<h3>Description</h3>

<p>These functions are made available in the package namespace for other developers, and are not intended for users. They provide a shared infrastructure for setting up data for Jacobian computation, and then for caclulating the Jacobian, either exactly or approximately, in maximum likelihood fitting of spatial regression models. The techniques used are the exact eigenvalue, Cholesky decompositions (Matrix, spam), and LU ones, with Chebyshev and Monte Carlo approximations; moments use the methods due to Martin and Smirnov/Anselin.</p>


<h3>Usage</h3>

<pre><code class="language-R">do_ldet(coef, env, which=1)
jacobianSetup(method, env, con, pre_eig=NULL, trs=NULL, interval=NULL, which=1)
cheb_setup(env, q=5, which=1)
mcdet_setup(env, p=16, m=30, which=1)
eigen_setup(env, which=1)
eigen_pre_setup(env, pre_eig, which=1)
spam_setup(env, pivot="MMD", which=1)
spam_update_setup(env, in_coef=0.1, pivot="MMD", which=1)
Matrix_setup(env, Imult, super=as.logical(NA), which=1)
Matrix_J_setup(env, super=FALSE, which=1)
LU_setup(env, which=1)
LU_prepermutate_setup(env, coef=0.1, order=FALSE, which=1)
moments_setup(env, trs=NULL, m, p, type="MC", correct=TRUE, trunc=TRUE, eq7=TRUE, which=1)
SE_classic_setup(env, SE_method="LU", p=16, m=30, nrho=200, interpn=2000,
 interval=c(-1,0.999), SElndet=NULL, which=1)
SE_whichMin_setup(env, SE_method="LU", p=16, m=30, nrho=200, interpn=2000,
 interval=c(-1,0.999), SElndet=NULL, which=1)
SE_interp_setup(env, SE_method="LU", p=16, m=30, nrho=200,
 interval=c(-1,0.999), which=1)
can.be.simmed(listw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>spatial coefficient value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>environment containing pre-computed objects, fixed after assignment in setup functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>default 1; if 2, use second listw object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string value, used by <code>jacobianSetup</code> to choose method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con</code></td>
<td>
<p>control list passed from model fitting function and parsed in <code>jacobianSetup</code> to set environment variables for method-specific setup</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre_eig</code></td>
<td>
<p>pre-computed eigenvalues of length n</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Chebyshev approximation order; default in calling spdep functions is 5, here it cannot be missing and does not have a default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Monte Carlo approximation number of random normal variables; default calling spdep functions is 16, here it cannot be missing and does not have a default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Monte Carlo approximation number of series terms; default in calling spdep functions is 30, here it cannot be missing and does not have a default; <code>m</code> serves the same purpose in the moments method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pivot</code></td>
<td>
<p>default “MMD”, may also be “RCM” for Cholesky decompisition using spam</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_coef</code></td>
<td>
<p>fill-in initiation coefficient value, default 0.1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Imult</code></td>
<td>
<p>see <code>Cholesky</code>; numeric scalar which defaults to zero. The matrix that is decomposed is A+m*I where m is the value of Imult and I is the identity matrix of order ncol(A). Default in calling spdep functions is 2, here it cannot be missing and does not have a default, but is rescaled for binary weights matrices in proportion to the maximim row sum in those calling functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>super</code></td>
<td>
<p>see <code>Cholesky</code>; logical scalar indicating is a supernodal decomposition should be created.  The alternative is a simplicial decomposition. Default in calling spdep functions is FALSE for “Matrix_J” and <code>as.logical(NA)</code> for “Matrix”.  Setting it to NA leaves the choice to a CHOLMOD-internal heuristic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>default FALSE; used in LU_prepermutate, note warnings given for <code>lu</code> method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trs</code></td>
<td>
<p>A numeric vector of <code>m</code> traces, as from <code>trW</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>moments trace type, see <code>trW</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct</code></td>
<td>
<p>default TRUE: use Smirnov correction term, see <code>trW</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trunc</code></td>
<td>
<p>default TRUE: truncate Smirnov correction term, see <code>trW</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq7</code></td>
<td>
<p>default TRUE; use equation 7 in Smirnov and Anselin (2009), if FALSE no unit root correction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE_method</code></td>
<td>
<p>default “LU”, alternatively “MC”; underlying lndet method to use for generating SE toolbox emulation grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrho</code></td>
<td>
<p>default 200, number of lndet values in first stage SE toolbox emulation grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>default c(-1,0.999) if interval argument NULL, bounds for SE toolbox emulation grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpn</code></td>
<td>
<p>default 2000, number of lndet values to interpolate in second stage SE toolbox emulation grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SElndet</code></td>
<td>
<p>default NULL, used to pass a pre-computed two-column matrix of coefficient values and corresponding interpolated lndet values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a spatial weights object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Since environments are containers in the R workspace passed by reference rather than by value, they are useful for passing objects to functions called in numerical optimisation, here for the maximum likelihood estimation of spatial regression models. This technique can save a little time on each function call, balanced against the need to access the objects in the environment inside the function. The environment should contain a <code>family</code> string object either “SAR”, “CAR” or “SMA” (used in <code>do_ldet</code> to choose spatial moving average in <code>spautolm</code>, and these specific objects before calling the set-up functions:
</p>

<dl>
<dt>eigen</dt>
<dd>
<p>Classical Ord eigenvalue computations - either:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
<dt>verbose</dt>
<dd>
<p>logical scalar: legacy report print control, for historical reasons only</p>
</dd>
</dl>
<p> or:
</p>

<dl>
<dt>pre_eig</dt>
<dd>
<p>pre-computed eigenvalues</p>
</dd>
</dl>
<p>and assigns to the environment:
</p>

<dl>
<dt>eig</dt>
<dd>
<p>a vector of eigenvalues</p>
</dd>
<dt>eig.range</dt>
<dd>
<p>the search interval for the spatial coefficient</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “eigen”</p>
</dd>
</dl>
</dd>
<dt>Matrix</dt>
<dd>
<p>Sparse matrix pre-computed Cholesky decomposition with fast updating:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>csrw</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>nW</dt>
<dd>
<p>negative sparse spatial weights matrix</p>
</dd>
<dt>pChol</dt>
<dd>
<p>a “CHMfactor” from factorising <code>csrw</code> with <code>Cholesky</code></p>
</dd>
<dt>nChol</dt>
<dd>
<p>a “CHMfactor” from factorising <code>nW</code> with <code>Cholesky</code></p>
</dd>
<dt>method</dt>
<dd>
<p>string: “Matrix”</p>
</dd>
</dl>
</dd>
<dt>Matrix_J</dt>
<dd>
<p>Standard Cholesky decomposition without updating:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>csrw</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>I</dt>
<dd>
<p>sparse identity matrix</p>
</dd>
<dt>super</dt>
<dd>
<p>the value of the <code>super</code> argument</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “Matrix_J”</p>
</dd>
</dl>
</dd>
<dt>spam</dt>
<dd>
<p>Standard Cholesky decomposition without updating:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>csrw</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>I</dt>
<dd>
<p>sparse identity matrix</p>
</dd>
<dt>pivot</dt>
<dd>
<p>string — pivot method</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “spam”</p>
</dd>
</dl>
</dd>
<dt>spam_update</dt>
<dd>
<p>Pre-computed Cholesky decomposition with updating:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>csrw</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>I</dt>
<dd>
<p>sparse identity matrix</p>
</dd>
<dt>csrwchol</dt>
<dd>
<p>A Cholesky decomposition for updating</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “spam”</p>
</dd>
</dl>
</dd>
<dt>LU</dt>
<dd>
<p>Standard LU decomposition without updating:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>W</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>I</dt>
<dd>
<p>sparse identity matrix</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “LU”</p>
</dd>
</dl>
</dd>
<dt>LU_prepermutate</dt>
<dd>
<p>Standard LU decomposition with updating (pre-computed fill-reducing permutation):
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>W</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>lu_order</dt>
<dd>
<p>order argument to lu</p>
</dd>
<dt>pq</dt>
<dd>
<p>2-column matrix for row and column permutation for fill-reduction</p>
</dd>
<dt>I</dt>
<dd>
<p>sparse identity matrix</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “LU”</p>
</dd>
</dl>
</dd>
<dt>MC</dt>
<dd>
<p>Monte Carlo approximation:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>clx</dt>
<dd>
<p>list of Monte Carlo approximation terms  (the first two simulated traces are replaced by their analytical equivalents)</p>
</dd>
<dt>W</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “MC”</p>
</dd>
</dl>
</dd>
<dt>cheb</dt>
<dd>
<p>Chebyshev approximation:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>trT</dt>
<dd>
<p>vector of Chebyshev approximation terms</p>
</dd>
<dt>W</dt>
<dd>
<p>sparse spatial weights matrix</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “Chebyshev”</p>
</dd>
</dl>
</dd>
<dt>moments</dt>
<dd>
<p>moments approximation:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>can.sim</dt>
<dd>
<p>logical scalar: can the spatial weights be made symmetric by similarity</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>trs</dt>
<dd>
<p>vector of traces, possibly approximated</p>
</dd>
<dt>q12</dt>
<dd>
<p>integer vector of length 2, unit roots terms, ignored until 0.5-52</p>
</dd>
<dt>eq7</dt>
<dd>
<p>logical scalar: use equation 7</p>
</dd>
<dt>correct</dt>
<dd>
<p>logical scalar: use Smirnov correction term</p>
</dd>
<dt>trunc</dt>
<dd>
<p>logical scalar: truncate Smirnov correction term</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “moments”</p>
</dd>
</dl>
</dd>
<dt>SE_classic</dt>
<dd>
<p>:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>detval</dt>
<dd>
<p>two column matrix of lndet grid values</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “SE_classic”</p>
</dd>
<dt>SE_method</dt>
<dd>
<p>string: “LU” or “MC”</p>
</dd>
</dl>
</dd>
<dt>SE_whichMin</dt>
<dd>
<p>:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>detval</dt>
<dd>
<p>two column matrix of lndet grid values</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “SE_whichMin”</p>
</dd>
<dt>SE_method</dt>
<dd>
<p>string: “LU” or “MC”</p>
</dd>
</dl>
</dd>
<dt>SE_interp</dt>
<dd>
<p>:
</p>

<dl>
<dt>listw</dt>
<dd>
<p>A listw spatial weights object</p>
</dd>
<dt>n</dt>
<dd>
<p>number of spatial objects</p>
</dd>
</dl>
<p> and assigns to the environment:
</p>

<dl>
<dt>fit</dt>
<dd>
<p>fitted spline object from which to predict lndet values</p>
</dd>
<dt>method</dt>
<dd>
<p>string: “SE_interp”</p>
</dd>
<dt>SE_method</dt>
<dd>
<p>string: “LU” or “MC”</p>
</dd>
</dl>
</dd>
</dl>
<p>Some set-up functions may also assign <code>similar</code> to the environment if the weights were made symmetric by similarity.
</p>
<p>Three set-up functions emulate the behaviour of the Spatial Econometrics toolbox (March 2010) maximum likelihood lndet grid performance. The toolbox lndet functions compute a smaller number of lndet values for a grid of coefficient values (spacing 0.01), and then interpolate to a finer grid of values (spacing 0.001). “SE_classic”, which is an implementation of the SE toolbox code, for example in f_sar.m, appears to have selected a row in the grid matrix one below the correct row when the candidate coefficient value was between 0.005 and 0.01-fuzz, always rounding the row index down. A possible alternative is to choose the index that is closest to the candidate coefficient value (“SE_whichMin”). Another alternative is to fit a spline model to the first stage coarser grid, and pass this fitted model to the log likelihood function to make a point prediction using the candidate coefficient value, rather than finding the grid index (“SE_interp”).
</p>


<h3>Value</h3>

<p><code>do_ldet</code> returns the value of the Jacobian for the calculation method recorded in the environment argument, and for the Monte Carlo approximation, returns a measure of the spread of the approximation as an “sd” attribute; the remaining functions modify the environment in place as a side effect and return nothing.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>LeSage J and RK Pace (2009) Introduction to Spatial Econometrics. CRC Press, Boca Raton, pp. 77–110.
</p>
<p>Bivand, R. S., Hauke, J., and Kossowski, T. (2013). Computing the Jacobian in Gaussian spatial autoregressive models: An illustrated comparison of available methods. <em>Geographical Analysis</em>, 45(2), 150-179.
</p>


<h3>See Also</h3>

<p><code>spautolm</code>, <code>lagsarlm</code>, <code>errorsarlm</code>, <code>Cholesky</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(boston, package="spData")
#require("spdep", quietly=TRUE)
lw &lt;- spdep::nb2listw(boston.soi)
can.sim &lt;- can.be.simmed(lw)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("can.sim", can.sim, envir=env)
assign("similar", FALSE, envir=env)
assign("verbose", FALSE, envir=env)
assign("family", "SAR", envir=env)
eigen_setup(env)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("can.sim", can.sim, envir=env)
assign("similar", FALSE, envir=env)
assign("verbose", FALSE, envir=env)
assign("family", "SAR", envir=env)
assign("n", length(boston.soi), envir=env)
eigen_pre_setup(env, pre_eig=eigenw(similar.listw(lw)))
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("can.sim", can.sim, envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
assign("n", length(boston.soi), envir=env)
Matrix_setup(env, Imult=2, super=FALSE)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("n", length(boston.soi), envir=env)
assign("can.sim", can.sim, envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
spam_setup(env)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("n", length(boston.soi), envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
LU_setup(env)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("n", length(boston.soi), envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
LU_prepermutate_setup(env)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
cheb_setup(env, q=5)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
env &lt;- new.env(parent=globalenv())
assign("listw", lw, envir=env)
assign("n", length(boston.soi), envir=env)
assign("similar", FALSE, envir=env)
assign("family", "SAR", envir=env)
set.seed(12345)
mcdet_setup(env, p=16, m=30)
get("similar", envir=env)
do_ldet(0.5, env)
rm(env)
</code></pre>


</div>