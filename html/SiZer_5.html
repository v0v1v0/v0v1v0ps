<div class="container">

<table style="width: 100%;"><tr>
<td>locally.weighted.polynomial</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Smoothes the given bivariate data using kernel regression.</h2>

<h3>Description</h3>

<p>Smoothes the given bivariate data using kernel regression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">locally.weighted.polynomial(
  x,
  y,
  h = NA,
  x.grid = NA,
  degree = 1,
  kernel.type = "Normal"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector of data for the independent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of data for the dependent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>The bandwidth for the kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.grid</code></td>
<td>
<p>What x-values should the value of the smoother be calculated at.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>The degree of the polynomial to be fit at each x-value. The default 
is to fit a linear regression, ie degree=1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.type</code></td>
<td>
<p>What kernel to use.  Valid choices are 'Normal',
'Epanechnikov', 'biweight', and 'triweight'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The confidence intervals are created using the row-wise method of 
Hannig and Marron (2006).
</p>
<p>Notice that the derivative to be estimated must be less than or equal to 
the degree of the polynomial initially fit to the data.
</p>
<p>If the bandwidth is not given, the Sheather-Jones bandwidth selection method is used.
</p>


<h3>Value</h3>

<p>Returns a <code>LocallyWeightedPolynomial</code> object that has the following elements:
</p>

<dl>
<dt>data</dt>
<dd>
<p>A structure of the data used to generate the smoothing curve</p>
</dd>
<dt>h</dt>
<dd>
<p>The bandwidth used to generate the smoothing curve.</p>
</dd>
<dt>x.grid</dt>
<dd>
<p>The grid of x-values that we have estimated function value 
and derivative(s) for.</p>
</dd>
<dt>degrees.freedom</dt>
<dd>
<p>The effective sample size at each grid point</p>
</dd>
<dt>Beta</dt>
<dd>
<p>A matrix of estimated beta values.  The number of rows is
degrees+1, while the number of columns is the same as the length
of x.grid. Notice that 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{f}(x_i)   = \beta[1,i] </code>
</p>

<p style="text-align: center;"><code class="reqn"> \hat{f'}(x_i)  = \beta[2,i]*1! </code>
</p>

<p style="text-align: center;"><code class="reqn"> \hat{f''}(x_i) = \beta[3,i]*2! </code>
</p>
  
<p>and so on...</p>
</dd>
<dt>Beta.var</dt>
<dd>
<p>Matrix of estimated variances for <code>Beta</code>.  Same structure as <code>Beta</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chaudhuri, P., and J. S. Marron. 1999. SiZer for exploration of structures in curves. 
Journal of the American Statistical Association 94 807-823. 
</p>
<p>Hannig, J., and J. S. Marron. 2006. Advanced distribution theory for SiZer. 
Journal of the American Statistical Association 101 484-499.
</p>
<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. Using SiZer to detect
thresholds in ecological data. Frontiers in Ecology and the Environment 7:190-195
</p>


<h3>See Also</h3>

<p><code>SiZer</code>, <code>plot.LocallyWeightedPolynomial</code>,  
<code>spm</code> in package 'SemiPar', <code>loess</code>, <code>smooth.spline</code>, 
<code>interpSpline</code> in the <code>splines</code> package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Arkansas)
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies
layout(cbind(1,2,3))
model &lt;- locally.weighted.polynomial(x,y)
plot(model, main='Smoothed Function', xlab='Year', ylab='Sqrt.Mayflies')

model2 &lt;- locally.weighted.polynomial(x,y,h=.5)
plot(model2, main='Smoothed Function', xlab='Year', ylab='Sqrt.Mayflies')

model3 &lt;- locally.weighted.polynomial(x,y, degree=1)
plot(model3, derv=1, main='First Derivative', xlab='Year', ylab='1st Derivative')

</code></pre>


</div>