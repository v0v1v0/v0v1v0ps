<div class="container">

<table style="width: 100%;"><tr>
<td>syrup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Memory and CPU Usage Information for Parallel R Code</h2>

<h3>Description</h3>

<p>This function is a wrapper around the system command <code>ps</code> that can
be used to benchmark (peak) memory and CPU usage of parallel R code.
By taking snapshots the memory usage of R processes at a regular <code>interval</code>,
the function dynamically builds up a profile of their usage of system
resources.
</p>


<h3>Usage</h3>

<pre><code class="language-R">syrup(expr, interval = 0.5, peak = FALSE, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>The interval at which to take snapshots of respirce usage.
In practice, there's an overhead on top of each of these intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>peak</code></td>
<td>
<p>Whether to return rows for only the "peak" memory usage.
Interpreted as the <code>id</code> with the maximum <code>rss</code> sum. Defaults to <code>FALSE</code>,
but may be helpful to set <code>peak = TRUE</code> for potentially very long-running
processes so that the tibble doesn't grow too large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>The environment to evaluate <code>expr</code> in.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>While much of the verbiage in the package assumes that the supplied
expression will be distributed across CPU cores, there's nothing specific
about this package that necessitates the expression provided to <code>syrup()</code> is
run in parallel. Said another way, <code>syrup()</code> will work just fine
with "normal," sequentially-run R code (as in the examples). That said,
there are many better, more fine-grained tools for the job in the case of
sequential R code, such as <code>Rprofmem()</code>, the
<a href="https://CRAN.R-project.org/package=profmem">profmem</a>
package, the bench package, and packages in
the <a href="https://github.com/r-prof">R-prof</a> GitHub organization.
</p>
<p>Loosely, the function works by:
</p>

<ul>
<li>
<p> Setting up another R process (call it <code>sesh</code>) that queries system
information using <code>ps::ps()</code> at a regular interval,
</p>
</li>
<li>
<p> Evaluating the supplied expression,
</p>
</li>
<li>
<p> Reading the queried system information back into the main process from <code>sesh</code>,
</p>
</li>
<li>
<p> Closing <code>sesh</code>, and then
</p>
</li>
<li>
<p> Returning the queried system information.
</p>
</li>
</ul>
<p>Note that information on the R process <code>sesh</code> is filtered out from the results
automatically.
</p>


<h3>Value</h3>

<p>A tibble with columns <code>id</code> and <code>time</code> and a number of columns from
<code>ps::ps()</code> output describing memory and CPU usage. Notably, the process ID
<code>pid</code>, parent process ID <code>ppid</code>, percent CPU usage, and resident set size
<code>rss</code> (a measure of memory usage).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# pass any expression to syrup. first, sequentially:
res_syrup &lt;- syrup({res_output &lt;- Sys.sleep(1)})

res_syrup

# to snapshot memory and CPU information more (or less) often, set `interval`
syrup(Sys.sleep(1), interval = .01)

# use `peak = TRUE` to return only the snapshot with
# the highest memory usage (as `sum(rss)`)
syrup(Sys.sleep(1), interval = .01, peak = TRUE)

# results from syrup are more---or maybe only---useful when
# computations are evaluated in parallel. see package README
# for an example.

</code></pre>


</div>