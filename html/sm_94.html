<div class="container">

<table style="width: 100%;"><tr>
<td>sm.surface3d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Adding a regression surface to an rgl plot.
</h2>

<h3>Description</h3>

<p>This function adds a regression surface, defined by a matrix of heights
at a regular grid of values of two covariates, to an <code>rgl</code> plot.
Missing values can be accommodated.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> sm.surface3d(eval.points, surf, scaling, 
                    col = "green", col.mesh = "black", 
                    alpha = 0.7, alpha.mesh = 1, lit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eval.points</code></td>
<td>

<p>if this is a two-column matrix then each column defines the marginal grids of covariate values.  Alternatively, a list with two components can also be used to handle cases where the grids are of different size.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surf</code></td>
<td>

<p>a matrix of heights corresponding to the grid of covariate values.
NAs are allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>

<p>a function to define the scaling for the <code>rgl</code> plot.  This
function is returned by an initial call to <code>rp.plot3d</code> in the
<code>rpanel</code> package.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>

<p>the colour of the surface.  If <code>col</code> is set to a single value, this
is replicated across the two components.  However, a matrix of values
corresponding to the entries of <code>surf</code> can also be supplied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.mesh</code></td>
<td>

<p>the colour of the surface mesh.  If <code>col.mesh</code> is set to a single value, this
is replicated across the two components.  However, a matrix of values
corresponding to the entries of <code>surf</code> can also be supplied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>the transparency of the filled triangles defining the surface.  Setting 
this to <code>0</code> will remove the filled triangles from the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.mesh</code></td>
<td>

<p>the transparency of the lines drawn across the regular grid of covariate 
values.  Setting this to <code>0</code> will remove the lines from the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lit</code></td>
<td>

<p>a logical variable which controls whether the <code>rgl</code> plot is lit or not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other optional parameters which are passed to <code>material3d</code> in the 
<code>rgl</code> package.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>the principal motivation for this function is that is can handle missing
data in regression surfaces.  In particular, it can be used to plot the
results of applying <code>sm.regression</code>.  In addition, the function can 
be used to build up more complex plots by adding successive surfaces.
</p>


<h3>Value</h3>

<p>a vector of length 2 containing the ids of the filled surface and lines
added to the <code>rgl</code> plot.
</p>


<h3>Side Effects</h3>

<p>a surface is added to the <code>rgl</code> plot.  
</p>


<h3>See Also</h3>

<p><code>sm.regression</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">with(trawl, {
   Zone93    &lt;- (Year == 1 &amp; Zone == 1)
   Position  &lt;- cbind(Longitude - 143, Latitude)
   model1 &lt;- sm.regression(Position[Zone93,], Score1[Zone93],
        h= c(0.1, 0.1), display = "rgl", xlab="Longitude - 143")
   model2 &lt;- sm.regression(Position[Zone93,], Score1[Zone93],
        h= c(0.2, 0.2), display = "none")
   sm.surface3d(model2$eval.points, model2$est, model1$scaling, col = "red")
})
</code></pre>


</div>