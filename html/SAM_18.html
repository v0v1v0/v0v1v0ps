<div class="container">

<table style="width: 100%;"><tr>
<td>samQL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Training function of Sparse Additive Models</h2>

<h3>Description</h3>

<p>The regression model is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">samQL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.005,
  thol = 1e-05,
  max.ite = 1e+05,
  regfunc = "L1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The <code>n</code>-dimensional response vector of the training set, where <code>n</code> is sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samQL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 30.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 5e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regfunc</code></td>
<td>
<p>A string indicating the regularizer. The default value is "L1". You can also assign "MCP" or "SCAD" to it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by "warm-start" and "active-set" tricks.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion, the length of each column is <code>d*p+1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>The solution path of the intercept.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sse</code></td>
<td>

<p>Sums of square errors of the solution path.
</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>SAM</code>,<code>plot.samQL,print.samQL,predict.samQL</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## generating training data
n = 100
d = 500
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)

## generating response
y = -2*sin(X[,1]) + X[,2]^2-1/3 + X[,3]-1/2 + exp(-X[,4])+exp(-1)-1

## Training
out.trn = samQL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)

yt = -2*sin(Xt[,1]) + Xt[,2]^2-1/3 + Xt[,3]-1/2 + exp(-Xt[,4])+exp(-1)-1

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>


</div>