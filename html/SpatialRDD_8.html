<div class="container">

<table style="width: 100%;"><tr>
<td>plotspatialrd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot SpatialRD output</h2>

<h3>Description</h3>

<p>Produces plot of GRDDseries and optionally of a map that visualises every point estimate in space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotspatialrd(SpatialRDoutput, map = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SpatialRDoutput</code></td>
<td>
<p>spatial object that is produced by an estimation with <code>spatialrd</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>TRUE/FALSE depending on whether mapplot is desired (make sure to set <code>spatial.objcet = TRUE</code> in the <code>spatialrd</code> function)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>plots produced with ggplot2
</p>


<h3>Examples</h3>

<pre><code class="language-R">
points_samp.sf &lt;- sf::st_sample(polygon_full, 1000) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
# assign treatment:
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
# first we define a variable for the number of "treated" and control
NTr &lt;- length(points_samp.sf$id[points_samp.sf$treated == 1])
NCo &lt;- length(points_samp.sf$id[points_samp.sf$treated == 0])
# the treated areas get a 10 percentage point higher literacy rate
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- 0.7
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- 0.6
# and we add some noise, otherwise we would obtain regression coeffictions with no standard errors
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- rnorm(NTr, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 1]
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- rnorm(NCo, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 0]

# create distance to cutoff
points_samp.sf$dist2cutoff &lt;- as.numeric(sf::st_distance(points_samp.sf, cut_off))

points_samp.sf$distrunning &lt;- points_samp.sf$dist2cutoff
# give the non-treated one's a negative score
points_samp.sf$distrunning[points_samp.sf$treated == 0] &lt;- -1 *
 points_samp.sf$distrunning[points_samp.sf$treated == 0]

# create borderpoints
borderpoints.sf &lt;- discretise_border(cutoff = cut_off, n = 10)
borderpoints.sf$id &lt;- 1:nrow(borderpoints.sf)

# finally, carry out estimation alongside the boundary:
results &lt;- spatialrd(y = "education", data = points_samp.sf, cutoff.points = borderpoints.sf,
treated = "treated", minobs = 20, spatial.object = FALSE)


plotspatialrd(results)
</code></pre>


</div>