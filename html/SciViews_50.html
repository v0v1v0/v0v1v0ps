<div class="container">

<table style="width: 100%;"><tr>
<td>pcomp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Principal Components Analysis.</h2>

<h3>Description</h3>

<p>Perform a principal components analysis on a matrix or data frame and return
a <code>pcomp</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcomp(x, ...)

## S3 method for class 'formula'
pcomp(formula, data = NULL, subset, na.action,
  method = c("svd", "eigen"), ...)

## Default S3 method:
pcomp(x, method = c("svd", "eigen"), scores = TRUE,
  center = TRUE, scale = TRUE, tol = NULL, covmat = NULL,
  subset = rep(TRUE, nrow(as.matrix(x))), ...)

## S3 method for class 'pcomp'
print(x, ...)

## S3 method for class 'pcomp'
summary(object, loadings = TRUE, cutoff = 0.1, ...)

## S3 method for class 'summary.pcomp'
print(x, digits = 3, loadings = x$print.loadings,
  cutoff = x$cutoff, ...)

## S3 method for class 'pcomp'
plot(x, which = c("screeplot", "loadings", "correlations",
  "scores"), choices = 1L:2L, col = par("col"), bar.col = "gray",
  circle.col = "gray", ar.length = 0.1, pos = NULL, labels = NULL,
  cex = par("cex"), main = paste(deparse(substitute(x)), which, sep =
  " - "), xlab, ylab, ...)

## S3 method for class 'pcomp'
screeplot(x, npcs = min(10, length(x$sdev)),
  type = c("barplot", "lines"), col = "cornsilk",
  main = deparse(substitute(x)), ...)

## S3 method for class 'pcomp'
points(x, choices = 1L:2L, type = "p", pch = par("pch"),
  col = par("col"), bg = par("bg"), cex = par("cex"), ...)

## S3 method for class 'pcomp'
lines(x, choices = 1L:2L, groups, type = c("p", "e"),
  col = par("col"), border = par("fg"), level = 0.9, ...)

## S3 method for class 'pcomp'
text(x, choices = 1L:2L, labels = NULL, col = par("col"),
  cex = par("cex"), pos = NULL, ...)

## S3 method for class 'pcomp'
biplot(x, choices = 1L:2L, scale = 1, pc.biplot = FALSE,
  ...)

## S3 method for class 'pcomp'
pairs(x, choices = 1L:3L, type = c("loadings",
  "correlations"), col = par("col"), circle.col = "gray",
  ar.col = par("col"), ar.length = 0.05, pos = NULL,
  ar.cex = par("cex"), cex = par("cex"), ...)

## S3 method for class 'pcomp'
predict(object, newdata, dim = length(object$sdev), ...)

## S3 method for class 'pcomp'
correlation(x, newvars, dim = length(x$sdev), ...)

scores(x, ...)

## S3 method for class 'pcomp'
scores(x, labels = NULL, dim = length(x$sdev), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix or data frame with numeric data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to or from other methods. If 'x<code>is a formula one might specify</code>scale =<code>,</code>tol =<code>or</code>covmat ='.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula with no response variable, referring only to numeric
variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional data frame (or similar: see <code>model.frame()</code>)
containing the variables in the formula <code>formula =</code>. By default the variables
are taken from <code>environment(formula)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action =</code> setting of
<code>options()</code>, and is <code>na.fail()</code> if that is  not set. The 'factory-fresh'
default is <code>na.omit()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Either <code>"svd"</code> (using <code>prcomp()</code>), <code>"eigen"</code> (using
<code>princomp()</code>), or an abbreviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>A logical value indicating whether the score on each principal
component should be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>A logical value indicating whether the variables should be
shifted to be zero centered. Alternately, a vector of length equal the
number of columns of <code>x</code> can be supplied. The value is passed to <code>scale =</code>.
Note that this argument is ignored for <code>method = "eigen"</code> and the dataset is
always centered in this case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A logical value indicating whether the variables should be
scaled to have unit variance before the analysis takes place. The default is
<code>TRUE</code>, which in general, is advisable. Alternatively, a vector of length
equal the number of columns of <code>x</code> can be supplied. The value is passed to
<code>scale()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Only when <code>method = "svd"</code>. A value indicating the magnitude
below which components should be omitted. (Components are omitted if their
standard deviations are less than or equal to <code>tol</code> times the standard
deviation of the first component.) With the default null setting, no
components are omitted. Other settings for <code>tol =</code> could be <code>tol = 0</code> or
<code>tol = sqrt(.Machine$double.eps)</code>, which would omit essentially constant
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covmat</code></td>
<td>
<p>A covariance matrix, or a covariance list as returned by
<code>cov.wt()</code> (and <code>cov.mve()</code> or <code>cov.mcd()</code> from package <strong>MASS</strong>). If
supplied, this is used rather than the covariance matrix of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A 'pcomp' object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>Do we also summarize the loadings?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>The cutoff value below which loadings are replaced by white
spaces in the table. That way, larger values are easier to spot and to read
in large tables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>The number of digits to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>The graph to plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choices</code></td>
<td>
<p>Which principal axes to plot. For 2D graphs, specify two
integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>The color to use in graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bar.col</code></td>
<td>
<p>The color of bars in the screeplot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circle.col</code></td>
<td>
<p>The color for the circle in the loadings or correlations
plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.length</code></td>
<td>
<p>The length of the arrows in the loadings and correlations
plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>The position of text relative to arrows in loadings and
correlation plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>The labels to write. If <code>NULL</code> default values are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>The factor of expansion for text (labels) in the graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>The title of the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>The label of the x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>The label of the y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npcs</code></td>
<td>
<p>The number of principal components to represent in the screeplot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of screeplot (<code>"barplot"</code> or <code>"lines"</code>) or pairs plot
(<code>"loadings"</code> or <code>"correlations"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>The type of symbol to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg</code></td>
<td>
<p>The background color for symbols.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>A grouping factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border</code></td>
<td>
<p>The color of the border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The probability level to use to draw the ellipse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc.biplot</code></td>
<td>
<p>Do we create a Gabriel's biplot (see <code>biplot()</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.col</code></td>
<td>
<p>Color of arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.cex</code></td>
<td>
<p>Expansion factor for terxt on arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>New individuals with observations for the same variables as
those used for calculating the PCA. You can then plot these additional
individuals in the scores plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>The number of principal components to keep.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newvars</code></td>
<td>
<p>New variables with observations for same individuals as those
used for mcalculating the PCA. Correlation with PCs is calculated. You can
then plot these additional variables in the correlation plot.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pcomp()</code> is a generic function with <code>"formula"</code> and <code>"default"</code>
methods. It is essentially a wrapper around <code>prcomp()</code> and <code>princomp()</code> to
provide a coherent interface and object for both methods.
</p>
<p>A 'pcomp' object is created. It inherits from 'pca' (as in <strong>labdsv</strong>
package, but not compatible with the 'pca' object of package <strong>ade4</strong>) and of
'princomp'.
</p>
<p>For more information on calculation done, refer to <code>prcomp()</code> for
<code>method = "svd"</code> or <code>princomp()</code> for <code>method = "eigen"</code>.
</p>


<h3>Value</h3>

<p>A <code>c("pcomp", "pca", "princomp")</code> object.
</p>


<h3>Note</h3>

<p>The signs of the columns of the loadings and scores are arbitrary, and
so may differ between functions for PCA, and even between different builds of
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
</p>


<h3>Author(s)</h3>

<p>Philippe Grosjean <a href="mailto:phgrosjean@sciviews.org">phgrosjean@sciviews.org</a>, but the core code is
indeed in package <strong>stats</strong>.
</p>


<h3>See Also</h3>

<p><code>vectorplot()</code>, <code>prcomp()</code>, <code>princomp()</code>, <code>loadings()</code>,
<code>Correlation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We will analyze mtcars without the Mercedes data (rows 8:14)
data(mtcars)
cars.pca &lt;- pcomp(~ mpg + cyl + disp + hp + drat + wt + qsec, data = mtcars,
  subset = -(8:14))
cars.pca
summary(cars.pca)
screeplot(cars.pca)

# Loadings are extracted and plotted like this
(cars.ldg &lt;- loadings(cars.pca))
plot(cars.pca, which = "loadings") # Equivalent to vectorplot(cars.ldg)

# Similarly, correlations of variables with PCs are extracted and plotted
(cars.cor &lt;- Correlation(cars.pca))
plot(cars.pca, which = "correlations") # Equivalent to vectorplot(cars.cor)
# One can add supplementary variables on this graph
lines(Correlation(cars.pca,
  newvars = mtcars[-(8:14), c("vs", "am", "gear", "carb")]))

# Plot the scores
plot(cars.pca, which = "scores", cex = 0.8) # Similar to plot(scores(x)[, 1:2])
# Add supplementary individuals to this plot (labels), also points() or lines()
text(predict(cars.pca, newdata = mtcars[8:14, ]), col = "gray", cex = 0.8)

# Pairs plot for 3 PCs
iris.pca &lt;- pcomp(iris[, -5])
pairs(iris.pca, col = (2:4)[iris$Species])
</code></pre>


</div>