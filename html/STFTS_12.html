<div class="container">

<table style="width: 100%;"><tr>
<td>furt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Unit Root Test</h2>

<h3>Description</h3>

<p>Unit root test for functional time series with different methods on determining the critical values of the test statistic. The Monte Carlo method was constructed in Chen and Pun (2021), while the bootstrap-based methods have not been validated in the literature (although such an option is provided, please use them at your own risk).
</p>


<h3>Usage</h3>

<pre><code class="language-R">furt(
  X,
  ALPHA = 0.05,
  TYPE = "R",
  METHOD = "MC",
  K = default_kernel,
  h_power = 2/5,
  est_ev = nrow(X) - 1,
  MCNsim = 10000,
  bm_set = NULL,
  M = 1000,
  b = ceiling((2 * (nrow(X) - 1))^(1/3))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The functional time series being tested, inputted in a matrix form with each row representing each observation of the functional data values on equidistant points of any prespecified interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ALPHA</code></td>
<td>
<p>Significance level of the test. The default value is 5%.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TYPE</code></td>
<td>
<p>Type of hypothesis test. The default value 'TYPE="R"' represents the right-tailed test, which is used when the alternative hypothesis is trend stationarity model. 'TYPE="L"' represents the left-tailed test, which is used when the alternative hypothesis is simple stationarity model or AR(1) model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>METHOD</code></td>
<td>
<p>Method to determine the critical value of the test statistic. The default value 'METHOD="MC"' represents the Monte Carlo method. 'METHOD="SB"' represents the simple bootstrap method and 'METHOD="MBB"' represents the moving block bootstrap method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Kernel function in the estimation of the long-run covariance function, which is only effective in the Monte Carlo method. The default function is 'default_kernel' function in this package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_power</code></td>
<td>
<p>Power of sample size 'N' (valued in (0,1)) for the smoothing bandwidth, which is only effective in the Monte Carlo method. The default value is 2/5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_ev</code></td>
<td>
<p>Number of the largest eigenvalues chosen to estimate the limiting distribution, which is only effective in the Monte Carlo method. The default value is the sample size 'N'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCNsim</code></td>
<td>
<p>Number of Monte Carlo datasets generated in the Monte Carlo method, which is only effective in Monte Carlo method. The default value is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bm_set</code></td>
<td>
<p>A vector of independent simulated data generated from the function 'dataset_bm', which is only effective and essential in Monte Carlo method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Number of bootstrap datasets generated in the bootstrap method, which is only effective in bootstrap methods. The default value is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Block length used in the moving block bootstrap method, which is only effective in the moving block bootstrap method. The default value is ceiling((2N)^(1/3)), where 'N' is the sample size.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The result of the test is presented with the value of test statistic and its p-value under the null hypothesis of functional random walk.
</p>


<h3>References</h3>

<p>Chen, Y., &amp; Pun, C. S. (2021). Functional Unit Root Test. Available at SSRN.
</p>


<h3>Examples</h3>

<pre><code class="language-R">N&lt;-100
EE&lt;-matrix(rep(0,N*100),ncol=100)
EX&lt;-matrix(rep(0,N*100),ncol=100)
set.seed(1)
for (i in 1:N) {
temp&lt;-rnorm(100,0,1)
EE[i,1]&lt;-temp[1]
for (j in 2:100) {
EE[i,j]&lt;-EE[i,j-1]+temp[j]
}
}
EX[1,]&lt;-EE[1,]
for (i in 2:N) {EX[i,]&lt;-EX[i-1]+EE[i,]}
furt(X=EX,METHOD="SB")
</code></pre>


</div>