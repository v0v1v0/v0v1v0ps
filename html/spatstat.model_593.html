<div class="container">

<table style="width: 100%;"><tr>
<td>rmh.ppm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate from a Fitted Point Process Model</h2>

<h3>Description</h3>

<p>Given a point process model fitted to data, 
generate a random simulation of the model, 
using the Metropolis-Hastings algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'ppm'
rmh(model, start=NULL,
                    control=default.rmhcontrol(model, w=w),
                    ...,
                    w = NULL, 
                    project=TRUE,
                    nsim=1, drop=TRUE, saveinfo=TRUE,
                    verbose=TRUE, new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A fitted point process model (object of class
<code>"ppm"</code>, see <code>ppm.object</code>) which it is desired
to simulate.  This fitted model is usually the result of a call
to <code>ppm</code>.  See <b>Details</b> below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Data determining the initial state
of the Metropolis-Hastings algorithm.  See
<code>rmhstart</code> for description of these arguments.
Defaults to <code>list(x.start=data.ppm(model))</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Data controlling the iterative behaviour of
the Metropolis-Hastings algorithm.  See <code>rmhcontrol</code>
for description of these arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to <code>rmhcontrol</code>,
or to <code>rmh.default</code>, or to covariate functions in the model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>Optional. Window in which the simulations should be generated.
Default is the window of the original data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>project</code></td>
<td>

<p>Logical flag indicating what to do if the fitted model is
invalid (in the sense that the values of the fitted coefficients do not
specify a valid point process).
If <code>project=TRUE</code> the closest valid model will be simulated;
if <code>project=FALSE</code> an error will occur.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>Number of simulated point patterns that should be generated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a single point pattern.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveinfo</code></td>
<td>

<p>Logical value indicating whether to save auxiliary information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(model)</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates simulated realisations from a point
process model that has been fitted to point pattern data.  It is
a method for the generic function <code>rmh</code> for the
class <code>"ppm"</code> of fitted point process models.  To simulate
other kinds of point process models, see <code>rmh</code>
or <code>rmh.default</code>.
</p>
<p>The argument <code>model</code> describes the fitted model.  It must be
an object of class <code>"ppm"</code> (see <code>ppm.object</code>),
and will typically be the result of a call to the point process
model fitting function <code>ppm</code>.
</p>
<p>The current implementation enables simulation from any fitted model
involving the interactions
<code>AreaInter</code>,
<code>DiggleGratton</code>,
<code>DiggleGatesStibbard</code>,
<code>Geyer</code>,
<code>Hardcore</code>,
<code>MultiStrauss</code>,
<code>MultiStraussHard</code>,
<code>PairPiece</code>,
<code>Poisson</code>,
<code>Strauss</code>,
<code>StraussHard</code>
and <code>Softcore</code>,
including nonstationary models. See the examples.
</p>
<p>It is also possible to simulate <em>hybrids</em> of several such models.
See <code>Hybrid</code> and the examples.
</p>
<p>It is possible that the fitted coefficients of a point process model
may be “illegal”, i.e. that there may not exist a
mathematically well-defined point process with the given parameter
values. For example, a Strauss process with interaction
parameter <code class="reqn">\gamma &gt; 1</code> does not exist,
but the model-fitting procedure used in <code>ppm</code> will sometimes
produce values of <code class="reqn">\gamma</code> greater than 1.
In such cases, if <code>project=FALSE</code> then an error will occur,
while if <code>project=TRUE</code> then <code>rmh.ppm</code> will find
the nearest legal model and simulate
this model instead. (The nearest legal model is obtained by
projecting the vector of coefficients onto the set of
valid coefficient vectors. The result is usually the Poisson process
with the same fitted intensity.)
</p>
<p>The arguments <code>start</code> and <code>control</code> are lists of
parameters determining the initial state and the iterative
behaviour, respectively, of the Metropolis-Hastings algorithm.
</p>
<p>The argument <code>start</code> is passed directly to <code>rmhstart</code>.
See <code>rmhstart</code> for details of the parameters of the
initial state, and their default values.
</p>
<p>The argument <code>control</code> is first passed to
<code>rmhcontrol</code>. Then if any additional arguments <code>...</code>
are given, <code>update.rmhcontrol</code> is called to update the
parameter values. See <code>rmhcontrol</code> for details of
the iterative behaviour parameters, and <code>default.rmhcontrol</code>
for their default values.
</p>
<p>Note that if you specify expansion of the simulation window
using the parameter <code>expand</code> (so that the
model will be simulated on a window larger than the original data
window) then the model must be capable of extrapolation to this
larger window. This is usually not possible for models which
depend on external covariates, because the domain of a covariate image
is usually the same as the domain of the fitted model.
</p>
<p>After extracting the relevant information from the fitted model
object <code>model</code>, <code>rmh.ppm</code> invokes the default
<code>rmh</code> algorithm <code>rmh.default</code>, unless the model
is Poisson. If the model is Poisson then the Metropolis-Hastings
algorithm is not needed, and the model is simulated directly, using
one of <code>rpoispp</code>, <code>rmpoispp</code>,
<code>rpoint</code> or <code>rmpoint</code>.
</p>
<p>See <code>rmh.default</code> for further information about the
implementation, or about the Metropolis-Hastings algorithm.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>; see
<code>ppp.object</code>) or a list of point patterns.
</p>


<h3>Warnings</h3>

<p>See Warnings in <code>rmh.default</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>simulate.ppm</code>,
<code>rmh</code>,
<code>rmhmodel</code>,
<code>rmhcontrol</code>,
<code>default.rmhcontrol</code>,
<code>update.rmhcontrol</code>,
<code>rmhstart</code>,
<code>rmh.default</code>,
<code>ppp.object</code>,
<code>ppm</code>,
</p>
<p>Interactions:
<code>AreaInter</code>,
<code>DiggleGratton</code>,
<code>DiggleGatesStibbard</code>,
<code>Geyer</code>,
<code>Hardcore</code>,
<code>Hybrid</code>,
<code>MultiStrauss</code>,
<code>MultiStraussHard</code>,
<code>PairPiece</code>,
<code>Poisson</code>,
<code>Strauss</code>,
<code>StraussHard</code>,
<code>Softcore</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   live &lt;- interactive()
   op &lt;- spatstat.options()
   spatstat.options(rmh.nrep=1e5)
   Nrep &lt;- 1e5

   X &lt;- swedishpines
   if(live) plot(X, main="Swedish Pines data")

   # Poisson process
   fit &lt;- ppm(X, ~1, Poisson())
   Xsim &lt;- rmh(fit)
   if(live) plot(Xsim, main="simulation from fitted Poisson model")

   # Strauss process   
   fit &lt;- ppm(X, ~1, Strauss(r=7))
   Xsim &lt;- rmh(fit)
   if(live) plot(Xsim, main="simulation from fitted Strauss model")

   if(live) {
     # Strauss process simulated on a larger window
     # then clipped to original window
     Xsim &lt;- rmh(fit, control=list(nrep=Nrep, expand=1.1, periodic=TRUE))
     Xsim &lt;- rmh(fit, nrep=Nrep, expand=2, periodic=TRUE)
   }

   if(live) {
     X &lt;- rSSI(0.05, 100)
     # piecewise-constant pairwise interaction function
     fit &lt;- ppm(X, ~1, PairPiece(seq(0.02, 0.1, by=0.01)))
     Xsim &lt;- rmh(fit)
   }

    # marked point pattern
    Y &lt;- amacrine

   if(live) {
     # marked Poisson models
     fit &lt;- ppm(Y)
     fit &lt;- ppm(Y,~marks)
     fit &lt;- ppm(Y,~polynom(x,2))
     fit &lt;- ppm(Y,~marks+polynom(x,2))
     fit &lt;- ppm(Y,~marks*polynom(x,y,2))
     Ysim &lt;- rmh(fit)
   }

   # multitype Strauss models
   MS &lt;- MultiStrauss(radii=matrix(0.07, ncol=2, nrow=2),
                      types = levels(Y$marks))
   if(live) {
    fit &lt;- ppm(Y ~marks, MS)
    Ysim &lt;- rmh(fit)
   }

   fit &lt;- ppm(Y ~ marks*polynom(x,y,2), MS)
   Ysim &lt;- rmh(fit)
   if(live) plot(Ysim, main="simulation from fitted inhomogeneous Multitype Strauss")

   spatstat.options(op)

  if(live) {
    # Hybrid model
    fit &lt;- ppm(redwood, ~1, Hybrid(A=Strauss(0.02), B=Geyer(0.1, 2)))
    Y &lt;- rmh(fit)
  }
</code></pre>


</div>