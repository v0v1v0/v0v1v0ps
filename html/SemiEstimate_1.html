<div class="container">

<table style="width: 100%;"><tr>
<td>semislv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve Semi-parametric estimation by implicit profiling</h2>

<h3>Description</h3>

<p>Solve Semi-parametric estimation by implicit profiling
</p>


<h3>Usage</h3>

<pre><code class="language-R">semislv(
  theta,
  lambda,
  Phi_fn,
  Psi_fn,
  jac = list(),
  intermediates = list(),
  method = "implicit",
  diy = FALSE,
  control = list(max_iter = 100, tol = 0.001),
  save = list(time = TRUE, path = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the initial value of parametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the initial value of non-parametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi_fn</code></td>
<td>
<p>the equation function highly relevant to the parametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Psi_fn</code></td>
<td>
<p>the equation function highly relevant to the non-parametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jac</code></td>
<td>
<p>a list containing some of deterivate info of Phi_der_theta_fn, Psi_der_theta_fn, Phi_der_lambda_fn, Psi_der_lambda_fn,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intermediates</code></td>
<td>
<p>a list containing the important variables for diy mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>"implicit" or "iterative"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diy</code></td>
<td>
<p>a bool value to decide to parse user designed function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list like list(max_iter = 100, tol = 1e-3) to control the early stop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save</code></td>
<td>
<p>a list like list(time = FALSE, path = FALSE) to control saving setting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>static parameter for Phi_fn, Psi_fn. Diy execution function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A save space containing final iteration result and iteration path
</p>


<h3>Examples</h3>

<pre><code class="language-R">Phi_fn &lt;- function(theta, lambda, alpha) 2 * theta + alpha * lambda
Psi_fn &lt;- function(theta, lambda, alpha) 2 * lambda + alpha * theta
# build quasi jacobiean by package NumDeriv
res &lt;- semislv(1, 1, Phi_fn, Psi_fn, alpha = 1)
res &lt;- semislv(1, 1, Phi_fn, Psi_fn, method = "iterative", alpha = 1)
# parsing all mathematical Jacobian function by user
res &lt;- semislv(1, 1, Phi_fn, Psi_fn, jac = list(
        Phi_der_theta_fn = function(theta, lambda, alpha) 2,
        Phi_der_lambda_fn = function(theta, lambda, alpha) alpha,
        Psi_der_theta_fn = function(theta, lambda, alpha) alpha,
        Psi_der_lambda_fn = function(theta, lambda, alpha) 2
), method = "implicit", alpha = 1)
res &lt;- semislv(1, 1, Phi_fn, Psi_fn, jac = list(
        Phi_der_theta_fn = function(theta, lambda, alpha) 2,
        Psi_der_lambda_fn = function(theta, lambda, alpha) 2
), method = "iterative", alpha = 1)
# parsing partial mathemetical user-provided Jacobian, the rest will be generated by the NumDeriv
res &lt;- semislv(1, 1, Phi_fn, Psi_fn,
        jac = list(Phi_der_theta_fn = function(theta, lambda, alpha) 2),
        method = "implicit", alpha = 1
)
res &lt;- semislv(1, 1, Phi_fn, Psi_fn,
        jac = list(Phi_der_theta_fn = function(theta, lambda, alpha) 2),
        method = "iterative", alpha = 1
)
# use some package or solve the updating totally by the user
# Cases: (1) use thirty party package (2) save the intermediates
# use diy = True, then the package will be just a wrapper for your personalise code
# diy is an advanced mode for researchers, see more examples in our vigettee documents
</code></pre>


</div>