<div class="container">

<table style="width: 100%;"><tr>
<td>print.q.svmmaj</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SVM-Maj Algorithm</h2>

<h3>Description</h3>

<p>SVM-Maj is an algorithm to compute a support vector machine (SVM) solution.
In its most simple form, it aims at finding hyperplane that optimally
separates two given classes.  This objective is equivalent to finding a
linear combination of <code>k</code> predictor variables to predict the two
classes for <code>n</code> observations.  SVM-Maj minimizes the standard support
vector machine (SVM) loss function.  The algorithm uses three efficient
updates for three different situations: primal method which is efficient in
the case of <code>n &gt; k</code>, the decomposition method, used when the matrix of
predictor variables is not of full rank, and a dual method, that is
efficient when <code>n &lt; k</code>.  Apart from the standard absolute hinge error,
SVM-Maj can also handle the quadratic and the Huber hinge.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'q.svmmaj'
print(x, ...)

svmmaj(
  X,
  y,
  lambda = 1,
  weights.obs = 1,
  weights.var = 1,
  scale = c("interval", "zscore", "none"),
  spline.knots = 0,
  spline.degree = 1L,
  kernel = vanilladot,
  kernel.sigma = 1,
  kernel.scale = 1,
  kernel.degree = 1,
  kernel.offset = 1,
  hinge = c("absolute", "quadratic", "huber", "logitistic"),
  hinge.delta = 1e-08,
  options = setSVMoptions(),
  initial.point = NULL,
  verbose = FALSE,
  na.action = na.omit,
  ...
)

## Default S3 method:
svmmaj(
  X,
  y,
  lambda = 1,
  weights.obs = 1,
  weights.var = 1,
  scale = c("interval", "zscore", "none"),
  spline.knots = 0,
  spline.degree = 1L,
  kernel = vanilladot,
  kernel.sigma = 1,
  kernel.scale = 1,
  kernel.degree = 1,
  kernel.offset = 1,
  hinge = c("absolute", "quadratic", "huber", "logitistic"),
  hinge.delta = 1e-08,
  options = setSVMoptions(),
  initial.point = NULL,
  verbose = FALSE,
  na.action = na.omit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the <code>svmmaj</code> object as result of <code>svmmaj</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A data frame (or object coercible by
<code>as.data.frame</code> to a data frame) consisting the attributes,
the class of each attribute can be either <code>numeric</code>, <code>logical</code> or
<code>factor</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A factor (or object coercible by <code>factor</code> to a
factor) consisting the class labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Regularization parameter of the penalty term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.obs</code></td>
<td>
<p>a vector of length <code>n</code> with the nonnegative weight 
for the residual of each object (with length <code>n</code>).  If the length is
<code>2</code>, then it specifies the weight per class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.var</code></td>
<td>
<p>a vector of length <code>k</code> with weights for each
attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Specifies whether the columns of attribute matrix <code>X</code>
needs to be standardized into zscores or to the interval <code>[0 1]</code>.
Possible values are: <code>none</code>, <code>zscore</code> and <code>interval</code>.
Moreover, the standardization parameters can be given instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.knots</code></td>
<td>
<p>equals the number of internal knots of the spline basis. 
When the number of knots exceeds the number of (categorical) values of 
an explanatory variable, the duplicate knots will be removed using 
<code>unique</code>. For no splines, use <code>spline.knots = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.degree</code></td>
<td>
<p>equals the polynomial degree of the splines, 
for no splines:<code>spline.degree = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>Specifies which kernel function to be used (see
<code>dots</code> of package <span class="pkg">kernlab</span>). 
Default kernel is the linear kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.sigma</code></td>
<td>
<p>additional parameters used for the kernel function
(see <code>dots</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.scale</code></td>
<td>
<p>additional parameters used for the kernel function
(see <code>dots</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.degree</code></td>
<td>
<p>additional parameters used for the kernel function
(see <code>dots</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.offset</code></td>
<td>
<p>additional parameters used for the kernel function
(see <code>dots</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hinge</code></td>
<td>
<p>Specifies with hinge function from 
<code>getHinge</code> should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hinge.delta</code></td>
<td>
<p>The parameter of the huber hinge 
(only if <code>hinge = 'huber'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>additional settings used in the <code>svmmaj</code> algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.point</code></td>
<td>
<p>Initial solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> shows the progress of the
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Generic function for handling NA values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following settings can be added as element in the <code>options</code> 
parameter:
<code>decomposition</code> Specifies whether the QR decomposition should be used
for efficient updates. Possible values are <code>'svd'</code> for Singular value 
decomposition (Eigenvalue decomposition for non-linear kernel) or 
<code>'chol'</code> for Cholesky (or QR decomposition in case of linear kernel)
</p>
<p><code>convergence</code> Specifies the convergence criterion of the algorithm.
Default is <code>1e-08</code>.
<code>increase.step</code> The iteration number from which relaxed update will be
used.
<code>eps</code> The relaxation of the majorization function for absolute hinge:
<code>.25 * eps^-1</code> is the maximum steepness of the majorization function.
</p>
<p><code>check.positive</code> Specifies whether a check has to be made for positive
input values.
<code>max.iter</code> maximum number of iterations to use
</p>


<h3>Value</h3>

<p>Returns a svmmaj-class object, 
of which the methods <code>plot</code>,
<code>plotWeights</code>, <code>summary</code> and <code>predict</code> can be applied.  
(see also <code>predict.svmmaj</code> and 
<code>print.svmmaj</code>)
</p>


<h3>Author(s)</h3>

<p>Hok San Yip, Patrick J.F. Groenen, Georgi Nalbantov
</p>


<h3>References</h3>

<p>P.J.F. Groenen, G. Nalbantov and J.C. Bioch (2008)
<em>SVM-Maj: a majorization approach to linear support vector machines 
with different hinge errors.</em>
</p>


<h3>See Also</h3>

<p><code>dots</code> for the computations of the kernels.
<code>predict.svmmaj</code> 
<code>normalize</code>
<code>isb</code> 
<code>getHinge</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## using default settings
model1 &lt;- svmmaj(
 diabetes$X, diabetes$y, hinge = 'quadratic', lambda = 1)
summary(model1)

weights.obs = list(positive = 2, negative = 1)
## using radial basis kernel
library(kernlab)
model2 &lt;- svmmaj(
  diabetes$X, diabetes$y, hinge = 'quadratic', lambda = 1, 
  weights.obs = weights.obs, scale = 'interval',
  kernel = rbfdot,
  kernel.sigma = 1
)
summary(model2)
## I-spline basis
library(ggplot2)
model3 &lt;- svmmaj(
  diabetes$X, diabetes$y, weight.obs = weight.obs,
  spline.knots = 3, spline.degree = 2
)
plotWeights(model3, plotdim = c(2, 4))
</code></pre>


</div>