<div class="container">

<table style="width: 100%;"><tr>
<td>sep.cov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Construct time and parameter covariance matrices
</h2>

<h3>Description</h3>

<p>Construct time and parameter covariance matrices. The time matrix
follows standard AR(1) covariance. The parameter covariance is squared
exponential, separable between the parameters, with an extra nugget term. While
not directly related to other functions in this
package, this function can be re-used if someone wants to build a
new/different Gaussian Process emulator code.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sep.cov(Theta.mat, t.vec, rho, kappa, phi.vec, zeta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Theta.mat</code></td>
<td>

<p>Parameter matrix of the ensemble. [row, col] = [run number, parameter
number]. See References for more information on this and other arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.vec</code></td>
<td>

<p>Evenly spaced vector of times for model output (can also be a coordinate
vector for a regularly spaced spatial transect)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>

<p>Lag-1 time autocorrelation parameter <code class="reqn">\rho</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>

<p>Parameter covariance scaling factor <code class="reqn">\kappa</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.vec</code></td>
<td>

<p>Vector of range parameters. Must have the same length as
number of columns in <code>Theta.mat</code>. All elements should be positive.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>

<p>Nugget <code class="reqn">\zeta</code>. Should be positive.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The time covariance is an n*n matrix (where n is the length of time
dimension). Its (j,k) element is specified by <code class="reqn">\varsigma_{t,jk} =
  \frac{\rho^{|t_j-t_k|}}{1-\rho^2}</code>. The parameter covariance is a p*p matrix (where p
is the number of runs in the model ensemble). Specifically,
<code class="reqn">\Sigma_{\theta,ij} = \kappa*exp(-A) + \zeta*1(i=j)</code> where
<code class="reqn">A=\sum\limits_{k=1}^{m}{\frac{(\theta_{k,i} -
      \theta_{k,j})^2}{\phi_k^2}}</code>. Here <code class="reqn">k</code> refers to parameter index.
For more details on the time and parameter covariance matrices produced by
this function, see References.
</p>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$Sigma.t.mat</code></td>
<td>
<p> Time covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Sigma.theta.mat</code></td>
<td>
<p>Parameter covariance matrix</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>R. Olson and W. Chang (2013): Mathematical framework for a separable
Gaussian Process Emulator. Tech. Rep., available from <br><a href="http://www.scrimhub.org/resources/stilt/Olson_and_Chang_2013_Stilt_Emulator_Technical_Report.pdf">www.scrimhub.org/resources/stilt/Olson_and_Chang_2013_Stilt_Emulator_Technical_Report.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>predict.emul</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Construct time AR(1) and square exponential separable parameter
# covariance matrix for a simple 1D parameter ensemble output example
data(Data.1D.par)
data(Data.1D.model)

Theta.mat.1D &lt;- t(Data.1D.par$par)
t.vec.1D     &lt;- Data.1D.model$t

# Use lag-1 time autocorrelation of 0.9, nugget and parameter covariance
# scaling factor of 100, and range of 3.
cov &lt;- sep.cov(Theta.mat.1D, t.vec.1D, 0.9, 100, 3, 100)

# Find the covariance between second parameter setting (Theta=1) and
# ninth parameter setting (Theta=8)
cov.2.9 &lt;- cov$Sigma.theta.mat[2,9]
cat("Covariance between Theta=1 and Theta=8 is:", cov.2.9, "\n")

# Plot the time covariance matrix [for fun]
# Note how covariance is high between similar years, but is low for markedly
# different years. Produces a pretty plot.
filled.contour(t.vec.1D, t.vec.1D, cov$Sigma.t.mat, xlab="Year", ylab="Year")
</code></pre>


</div>