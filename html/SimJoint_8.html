<div class="container">

<table style="width: 100%;"><tr>
<td>SJspearmanPMF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulate joint with marginal PMFs and Spearman correlations.
</h2>

<h3>Description</h3>

<p>Sample from marginal probability mass functions via Latin hypercube sampling and then simulate the joint distribution with Spearman correlations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SJspearmanPMF(
  PMFs,
  sampleSize,
  cor,
  stochasticStepDomain = as.numeric(c(0, 1)),
  errorType = "meanSquare",
  seed = 123L,
  maxCore = 7L,
  convergenceTail = 8L,
  iterLimit = 100000L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>PMFs</code></td>
<td>

<p>A list of data frames. Each data frame has 2 columns, a value vector and a probability vector. Probabilities should sum up to 1. Let the size of <code>PMFs</code> be <code>K</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleSize</code></td>
<td>

<p>An integer. The sample size <code>N</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>

<p>A <code>K x K</code> correlation matrix. The matrix should be positive semi-definite.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stochasticStepDomain</code></td>
<td>

<p>A numeric vector of size 2. Range of the stochastic step ratio for correcting the correlation matrix in each iteration. Default [0, 1]. See the package vignette for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorType</code></td>
<td>

<p>Cost function for convergence test.
</p>
<p><code>"meanRela"</code>: average absolute relative error between elements of the target correlation matrix and the correlation matrix approximated in each iteration.
</p>
<p><code>"maxRela"</code>: maximal absolute relative error.
</p>
<p><code>"meanSquare"</code>: mean squared error. Default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>An integer or an integer vector of size 4. A single integer seeds a <code>pcg64</code> generator the usual way. An integer vector of size 4 supplies all the bits for a <code>pcg64</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCore</code></td>
<td>

<p>An integer. Maximal threads to invoke. Default 7. Better be no greater than the total number of virtual cores on machine.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergenceTail</code></td>
<td>

<p>An integer. If the last <code>convergenceTail</code> iterations resulted in equal cost function values, return. Default 8.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterLimit</code></td>
<td>

<p>An integer. The maximal number of iterations. Default 100000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A boolean value. <code>TRUE</code> prints progress.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithms are detailed in the package vignette.
</p>


<h3>Value</h3>

<p>A list of size 2.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p>A numeric matrix of size <code>N x K</code>, the simulated joint distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor </code></td>
<td>
<p>Spearman correlation matrix of <code>X</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># =============================================================================
# Play with completely random nonparametric PMFs.
# =============================================================================
set.seed(123)
N = 2000L
K = 20L


# Create totally random nonparametric PMFs:
PMFs = lapply(1L : K, function(x)
{
  p = runif(2, 1, 10)
  result = data.frame(
    val = sort(rnorm(200)), P = runif(200))
  result$P = result$P / sum(result$P)
  result
})


# Create a valid correlation matrix upper-bounded by `frechetUpperCor`.
while(TRUE)
{
  targetCor = matrix(runif(K * K, -0.1, 0.3), ncol = K)
  targetCor[lower.tri(targetCor)] = t(targetCor)[lower.tri(t(targetCor))]
  diag(targetCor) = 1
  if(min(eigen(targetCor)$values) &gt;= 0) break # Break once the correlation
  # matrix is semi-positive definite. This loop could be running for quite
  # a long time if we do not bound `runif()`.
}


result = SimJoint::SJspearmanPMF(
  PMFs = PMFs, sampleSize = N, cor = targetCor, stochasticStepDomain = c(0, 1),
  errorType = "meanSquare", seed = 456, maxCore = 1, convergenceTail = 8)


# Visualize errors and correlation matrices.
par(mfrow = c(2, 2))
hist(result$cor - targetCor, breaks = K * K, main = NULL,
     xlab = "Error", cex.lab = 1.5, cex.axis = 1.25)
hist(result$cor / targetCor - 1, breaks = K * K, main = NULL,
     xlab = "Relative error", ylab = "", cex.lab = 1.5, cex.axis = 1.25)
zlim = range(range(targetCor[targetCor &lt; 1]), range(result$cor[result$cor &lt; 1]))
col = colorRampPalette(c("blue", "red", "yellow"))(K * K)
tmp = targetCor[, K : 1L]
image(tmp, xaxt = "n", yaxt = "n", zlim = zlim, bty = "n",
      main = "Target cor", col = col)
tmp = result$cor[, K : 1L]
image(tmp, xaxt = "n", yaxt = "n", zlim = zlim, bty = "n",
      main = "Cor reached", col = col)
par(mfrow = c(1, 1))
</code></pre>


</div>