<div class="container">

<table style="width: 100%;"><tr>
<td>uniroot.integer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the root of a function to the nearest integer</h2>

<h3>Description</h3>

<p>Let f be a monotonic function that changes sign within the interval specified. If f(i)=0 for some i within the interval specified (including the ends of the interval), then the root is i. Otherwise  if <code>pos.side</code>=TRUE (or FALSE) then <code>uniroot.integer</code> finds the integer i such that 
f(i) is closest to the sign change and is positive (or negative). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">uniroot.integer(f, interval, lower = min(interval), upper = max(interval), 
    step.power = 6, step.up = TRUE, pos.side = FALSE, print.steps = FALSE, 
    maxiter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p> function for which a root is needed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>an interval giving minimum and maximum allowable values for root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>minimum allowable root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>maximum allowable root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.power</code></td>
<td>
<p>initial step size is <code class="reqn">2^{step.power}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.up</code></td>
<td>
<p>if TRUE steps up from 'lower', if FALSE steps down from 'upper'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.side</code></td>
<td>
<p>if TRUE finds integer, i, closest to the root such that f(i) <code class="reqn">&gt;</code> zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.steps</code></td>
<td>
<p>if TRUE, prints iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> maximum number of iterations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to 'f'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm evaluates f(i) iteratively, increasing (or decreasing if step.up=FALSE) 
i by <code class="reqn">2^{step.power}</code> until either f(i)=0 or f(i) switches sign.
If f(i)=0, then stop. If f(i) switches sign, then the change in  'i' is halved each iteration until convergence. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code> root</code></td>
<td>
<p>the integer on the correct side of the root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.root</code></td>
<td>
<p>value of f at root</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of times f was evaluated</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Unlike <code>uniroot</code>, the function is not automatically evaluated at both extremes. This makes 
<code>uniroot.integer</code> an efficient method to use when the calculation time of f(i) 
increases with the value of 'i'. For an example of the importance of this see 
<code>ss.fromdata.pois</code>. </p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>See Also</h3>

<p><code>uniroot</code>, used by <code>ss.fromdata.neff</code>, <code>ss.fromdata.pois</code>,
<code>ss.nonadh</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">root.func&lt;-function(i) i - 500.1 
## initial step sizes = 2^2 =4
uniroot.integer(root.func,c(0,Inf),step.power=2)
## more efficient to use bigger initial step sizes = 2^10 =1024
uniroot.integer(root.func,c(0,Inf),step.power=10,print.steps=TRUE)
</code></pre>


</div>