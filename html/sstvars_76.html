<div class="container">

<table style="width: 100%;"><tr>
<td>linear_IRF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate linear impulse response function based on a single regime of a structural STVAR model.</h2>

<h3>Description</h3>

<p><code>linear_IRF</code> estimates linear impulse response function based on a single regime
of a structural STVAR model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">linear_IRF(
  stvar,
  N = 30,
  regime = 1,
  which_cumulative = numeric(0),
  scale = NULL,
  ci = NULL,
  bootstrap_reps = 100,
  ncores = 2,
  robust_method = c("Nelder-Mead", "SANN", "none"),
  maxit_robust = 1000,
  seed = NULL,
  ...
)

## S3 method for class 'irf'
plot(x, shocks_to_plot, ...)

## S3 method for class 'irf'
print(x, ..., digits = 2, N_to_print, shocks_to_print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code> defining a structural or reduced form
STVAR model. For a reduced form model, the shocks are automatically identified by
the lower triangular Cholesky decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
linear impulse responses be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regime</code></td>
<td>
<p>Based on which regime the linear IRF should be calculated?
An integer in <code class="reqn">1,...,M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the linear impulse
responses should be cumulative. Default is none.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>should the linear IRFs to some of the shocks be scaled so that they
correspond to a specific instantaneous response of some specific
variable? Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
its instantaneous response in the third element (a non-zero real number).
If the linear IRFs of multiple shocks should be scaled, provide a matrix which has one
column for each of the shocks with the columns being the length three vectors described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>a real number in <code class="reqn">(0, 1)</code> specifying the confidence level of the
confidence intervals calculated via a fixed-design wild residual bootstrap method.
Available only for models that impose linear autoregressive dynamics
(excluding changes in the volatility regime).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap_reps</code></td>
<td>
<p>the number of bootstrap repetitions for estimating confidence bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number of CPU cores to be used in parallel computing when bootstrapping confidence bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust_method</code></td>
<td>
<p>Should some robust estimation method be used in the estimation before switching
to the gradient based variable metric algorithm? See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit_robust</code></td>
<td>
<p>the maximum number of iterations on the first phase robust estimation, if employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a real number initializing the seed for the random generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>'irf'</code> generated by the function <code>linear_IRF</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shocks_to_plot</code></td>
<td>
<p>IRFs of which shocks should be plotted? A numeric vector
with elements in <code>1,...,d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of decimals to print</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shocks_to_print</code></td>
<td>
<p>the responses to which should should be printed?
A numeric vector with elements in <code>1,...,d</code>. The default is that responses to
all the shocks are printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the autoregressive dynamics of the model are linear (i.e., either M == 1 or mean and AR parameters
are constrained identical across the regimes), confidence bounds can be calculated based on a fixed-design
wild residual bootstrap method. We employ the method described in Herwartz and L端tkepohl (2014); see also
the relevant chapters in Kilian and L端tkepohl (2017).
</p>
<p>Employs the estimation function <code>optim</code> from the package <code>stats</code> that implements the optimization
algorithms. The robust optimization method Nelder-Mead is much faster than SANN but can get stuck at a local
solution. See <code>?optim</code> and the references therein for further details.
</p>
<p>For model identified by non-Gaussianity, the signs and ordering of the shocks are normalized by assuming
that the first non-zero element of each column of the impact matrix of Regime 1 is strictly positive and they are
in a decreasing order. Use the argument <code>scale</code> to obtain IRFs scaled for specific impact responses.
</p>


<h3>Value</h3>

<p>Returns a class <code>'irf'</code> list with  with the following elements:
</p>

<dl>
<dt>
<code>$point_est</code>:</dt>
<dd>
<p>a 3D array <code>[variables, shock, horizon]</code> containing the point estimates of the IRFs.
Note that the first slice is for the impact responses and the slice i+1 for the period i. The response of the
variable 'i1' to the shock 'i2' is subsetted as <code>$point_est[i1, i2, ]</code>.</p>
</dd>
<dt>
<code>$conf_ints</code>:</dt>
<dd>
<p>bootstrapped confidence intervals for the IRFs in a <code>[variables, shock, horizon, bound]</code>
4D array. The lower bound is obtained as <code>$conf_ints[, , , 1]</code>, and similarly the upper bound as
<code>$conf_ints[, , , 2]</code>. The subsetted 3D array is then the bound in a form similar to <code>$point_est</code>.</p>
</dd>
<dt>
<code>$all_bootstrap_reps</code>:</dt>
<dd>
<p>IRFs from all of the bootstrap replications in a <code>[variables, shock, horizon, rep]</code>.
4D array. The IRF from replication i1 is obtained as <code>$all_bootstrap_reps[, , , i1]</code>, and the subsetted 3D array
is then the in a form similar to <code>$point_est</code>.</p>
</dd>
<dt>Other elements:</dt>
<dd>
<p>contains some of the arguments the <code>linear_IRF</code> was called with.</p>
</dd>
</dl>
<h3>Functions</h3>


<ul>
<li> <p><code>plot(irf)</code>: plot method
</p>
</li>
<li> <p><code>print(irf)</code>: print method
</p>
</li>
</ul>
<h3>References</h3>


<ul>
<li>
<p> Herwartz H. and L端tkepohl H. 2014. Structural vector autoregressions with Markov switching:
Combining conventional with statistical identification of shocks. <em>Journal of Econometrics</em>,
183, pp. 104-116.
</p>
</li>
<li>
<p> Kilian L. and L端tkepohl H. 2017. Structural Vectors Autoregressive Analysis.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>GIRF</code>, <code>GFEVD</code>, <code>fitSTVAR</code>, <code>STVAR</code>,
<code>reorder_B_columns</code>, <code>swap_B_signs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## These are long running examples that take approximately 10 seconds to run.
## A small number of bootstrap replications is used below to shorten the
## running time (in practice, a larger number of replications should be used).

# p=1, M=1, d=2, linear VAR model with independent Student's t shocks identified
# by non-Gaussianity (arbitrary weight function applied here):
theta_112it &lt;- c(0.644, 0.065, 0.291, 0.021, -0.124, 0.884, 0.717, 0.105, 0.322,
  -0.25, 4.413, 3.912)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112it, cond_dist="ind_Student",
 identification="non-Gaussianity", weight_function="threshold", weightfun_pars=c(1, 1))
mod112 &lt;- swap_B_signs(mod112, which_to_swap=1:2)

# Estimate IRFs 20 periods ahead, bootstrapped 90% confidence bounds based on
# 10 bootstrap replications. Linear model so robust estimation methods are
# not required.
irf1 &lt;- linear_IRF(stvar=mod112, N=20, regime=1, ci=0.90, bootstrap_reps=1,
 robust_method="none", seed=1, ncores=1)
plot(irf1)
print(irf1, digits=3)

# p=1, M=2, d=2, Gaussian STVAR with relative dens weight function,
# shocks identified recursively.
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg, identification="recursive")

# Estimate IRF based on the first regime 30 period ahead. Scale IRFs so that
# the instantaneous response of the first variable to the first shock is 0.3,
# and the response of the second variable to the second shock is 0.5.
# response of the Confidence bounds
# are not available since the autoregressive dynamics are nonlinear.
irf2 &lt;- linear_IRF(stvar=mod122, N=30, regime=1, scale=cbind(c(1, 1, 0.3), c(2, 2, 0.5)))
plot(irf2)

 # Estimate IRF based on the second regime without scaling the IRFs:
irf3 &lt;- linear_IRF(stvar=mod122, N=30, regime=2)
plot(irf3)

# p=3, M=2, d=3, Students't logistic STVAR model with the first lag of the second
# variable as the switching variable. Autoregressive dynamics restricted linear,
# but the volatility regime varies in time, allowing the shocks to be identified
# by conditional heteroskedasticity.
theta_322 &lt;- c(0.7575, 0.6675, 0.2634, 0.031, -0.007, 0.5468, 0.2508, 0.0217, -0.0356,
 0.171, -0.083, 0.0111, -0.1089, 0.1987, 0.2181, -0.1685, 0.5486, 0.0774, 5.9398, 3.6945,
 1.2216, 8.0716, 8.9718)
mod322 &lt;- STVAR(data=gdpdef, p=3, M=2, params=theta_322, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", mean_constraints=list(1:2),
  AR_constraints=rbind(diag(3*2^2), diag(3*2^2)), identification="heteroskedasticity",
  parametrization="mean")

## Estimate IRFs 30 periods ahead, bootstrapped 90% confidence bounds based on
# 10 bootstrap replications. Responses of the second variable are accumulated.
irf4 &lt;- linear_IRF(stvar=mod322, N=30, regime=1, ci=0.90, bootstrap_reps=10,
 which_cumulative=2, seed=1)
plot(irf4)

</code></pre>


</div>