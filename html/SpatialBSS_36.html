<div class="container">

<table style="width: 100%;"><tr>
<td>snss_sjd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spatial Non-Stationary Source Separation Spatial Joint Diagonalization
</h2>

<h3>Description</h3>

<p><code>snss_sjd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant (spatial) covariance by jointly diagonalizing several covariance and/or spatial covariance matrices computed for a subdivision of the spatial domain into at least two sub-domains.
</p>


<h3>Usage</h3>

<pre><code class="language-R">snss_sjd(x, ...)

## Default S3 method:
snss_sjd(x, coords, n_block, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, with_cov = TRUE, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
     ordered = TRUE, ...)
## S3 method for class 'list'
snss_sjd(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, with_cov = TRUE, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
     ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_sjd(x, ...)
## S3 method for class 'sf'
snss_sjd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length <code>K</code> defining the subdivision of the domain, an object of class <code>sf</code> or an object of class <code>SpatialPointsDataFrame</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length <code>K</code> if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_block</code></td>
<td>

<p>either be an integer defining the subdivision of the domain, <code>'x'</code> or <code>'y'</code>. See details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_cov</code></td>
<td>

<p>logical. If <code>TRUE</code> not only spatial covariance matrices but also the sample covariances matrices for each sub-domain are considered in the joint diagonalization procedure. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default), <code>'ldiff'</code> or <code>'lcov_norm'</code>. See <code>sbss_asymp</code> for details on the latter option.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared pseudo-eigenvalues of the diagonalized sub-domain (local) covariance matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the sub-domain covariance matrices. See details and <code>frjd</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant (spatial) second order dependence. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain into <code>n_block^2</code> equally sized rectangular sub-domains and jointly diagonalizing the corresponding spatial covariance matrices for all sub-domains. If the argument <code>with_cov</code> equals <code>TRUE</code> (default) then additionally also the sample covariance matrices for each sub-domain are included in the joint diagonalization procedure.
</p>
<p>The arguments <code>kernel_type</code>, <code>kernel_parameters</code> and <code>lcov</code> determine which spatial kernel functions and which type of local covariance matrices are used for each sub-domain. The usage is equal to the function <code>sbss</code>.
</p>
<p>Alternatively the domain subdivision can be defined by providing lists of length <code>K</code> for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain, etc.. The argument <code>n_block</code> might be <code>'x'</code> or <code>'y'</code> indicating a split across the x or y coordinates similar as done by the function <code>snss_sd</code>.
</p>
<p><code>snss_sjd</code> jointly diagonalizes the covariance matrices for each sub-domain with the function <code>frjd</code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Similarly as <code>sbss</code> the function <code>snss_jd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized sub-domain covariance and/or local covariance matrices.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code>sbss</code>, <code>sp</code>, <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                                data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_sjd with 4 sub-domains
# one ring kernel per sub-domain
# without covariances
res_4_ball &lt;- snss_sjd(observed_field, coords, n_block = 2,
                  kernel_type = 'ball', kernel_parameters = c(0, 2), 
                  with_cov = TRUE)
JADE::MD(W.hat = coef(res_4_ball), A = mixing_matrix)

# apply snss_sjd with split across y
# one ring kernel per sub-domain
# without covariances
# should not work as field does not show spatial dependence
res_4_ring &lt;- snss_sjd(observed_field, coords, n_block = 'y',
                       kernel_type = 'ring', kernel_parameters = c(0, 2), 
                       with_cov = FALSE)
JADE::MD(W.hat = coef(res_4_ring), A = mixing_matrix)

# print object
print(res_4_ball)

# plot latent field
plot(res_4_ball, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_4_ball, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_4_ball)

# apply snss_jd with SpatialPointsDataFrame object 
res_4_ball_sp &lt;- snss_sjd(observed_field_sp, n_block = 2,
                          kernel_type = 'ball', kernel_parameters = c(0, 2), 
                          with_cov = TRUE)

# apply with list arguments
# first axis split by 5
# second axis split by 10
# results in 4 sub-domains
flag_x &lt;- coords[, 1] &lt; 5
flag_y &lt;- coords[, 2] &lt; 10
coords_list &lt;- list(coords[flag_x &amp; flag_y, ],
                    coords[!flag_x &amp; flag_y, ],
                    coords[flag_x &amp; !flag_y, ],
                    coords[!flag_x &amp; !flag_y, ])
field_list &lt;- list(observed_field[flag_x &amp; flag_y, ],
                   observed_field[!flag_x &amp; flag_y, ],
                   observed_field[flag_x &amp; !flag_y, ],
                   observed_field[!flag_x &amp; !flag_y, ])
plot(coords, col = 1)
points(coords_list[[2]], col = 2)
points(coords_list[[3]], col = 3)
points(coords_list[[4]], col = 4)

res_list &lt;- snss_sjd(x = field_list,
                    coords = coords_list,
                    kernel_type = 'ring', kernel_parameters = c(0, 2))
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>


</div>