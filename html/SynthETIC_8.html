<div class="container">

<table style="width: 100%;"><tr>
<td>claim_output</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Loss Reserving Output</h2>

<h3>Description</h3>

<p>Outputs the full (or past) square of claim payments by occurrence period and
development period. The upper left triangle represents the past, and the
lower right triangle the unseen future. <br><br>
Users can modify the aggregate level by providing an <code>aggregate_level</code>
argument to the function. For example, setting <code>aggregate_level = 4</code> when
working with calendar <em>quarters</em> produces a payment square by occurrence and
development <em>year</em>. <br><br>
Users will also have the option to decide whether to include the out-of-bound
transactions to the maximum DQ, or to leave them in a separate "tail" cell,
see Details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">claim_output(
  frequency_vector,
  payment_time_list,
  payment_size_list,
  aggregate_level = 1,
  incremental = TRUE,
  future = TRUE,
  adjust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>payment_time_list</code></td>
<td>
<p>(compound) list of payment times (both the continous
time scale and the discrete period versions work).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>payment_size_list</code></td>
<td>
<p>(compound) list of payment size pattern (can be
either with or without inflation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate_level</code></td>
<td>
<p>number of periods to be aggregated together; must be
a divisor of the total number of periods under consideration (default 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incremental</code></td>
<td>
<p>logical; if true returns the incremental payment square,
else returns the cumulative payment square.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future</code></td>
<td>
<p>logical; if true shows the full claim triangle (i.e. including
claim payments in future periods), else shows only the past triangle (default
TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>logical; if true accumulates all payments beyond the max
development period to the last development period, else shows a separate
"tail" column for all the out-of-bound transactions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Remark on out-of-bound payment times</strong>: This function allows adjustment
for out-of-bound transaction dates, by forcing payments that were projected
to fall out of the maximum development period to be paid at the exact end of
the maximum development period allowed (when we set <code>adjust = TRUE</code>, which is
the default behaviour). For example, if we consider 40 periods of development
and a claim incurred in the interval (20, 21] was projected to have a payment
at time 62.498210, then for the purpose of tabulation, we can
</p>

<ul>
<li>
<p> treat such a payment as if it occurred at time 60 (<code>adjust = TRUE</code>);
</p>
</li>
<li>
<p> leave the payment in the "tail" cell, so the user can see the proportion of
payments beyond the maximum development period (<code>adjust = FALSE</code>).
</p>
</li>
</ul>
<h3>Value</h3>

<p>An array of claims payments.
</p>


<h3>Examples</h3>

<pre><code class="language-R">attach(test_claims_object)
# a square of cumulative claims payments by accident and development quarters
CL &lt;- claim_output(frequency_vector, payment_time_list, payment_size_list,
                   aggregate_level = 1, incremental = FALSE)
detach(test_claims_object)
</code></pre>


</div>