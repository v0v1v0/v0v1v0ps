<div class="container">

<table style="width: 100%;"><tr>
<td>emulator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to fit an emulator to ensemble model output
</h2>

<h3>Description</h3>

<p>Fits a Gaussian Process emulator to regularly spaced time-series (or 1D spatial)
model output. This emulator can later be used to interpolate the model
output across model parameter settings. The emulator is fit by
maximizing the emulator likelihood using a PORT local optimization
routine. The emulator has a flexible structure which can be chosen by
the user (see Details). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">emulator(mpars, moutput, par.reg, time.reg, kappa0, zeta0, myrel.tol =
NULL, twice = FALSE, fix.betas = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mpars</code></td>
<td>

<p>Model ensemble parameter settings. A list with components:
</p>

<dl>
<dt>$par</dt>
<dd>
<p>Matrix of ensemble parameter settings. [row, column] =
[parameter index, run index]. Columns should correspond to
columns of the model output matrix <code>moutput$out</code>.</p>
</dd>
<dt>$parnames</dt>
<dd>
<p>Parameter names for rows of $par (character vector)</p>
</dd>
<dt>$parunits</dt>
<dd>
<p>Units for parameters in rows of $par (character vector)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moutput</code></td>
<td>

<p>Model output. A list with components:
</p>

<dl>
<dt>$t</dt>
<dd>
<p> Time vector for rows of $out (vector)</p>
</dd>
<dt>$tunits</dt>
<dd>
<p>Time units (character)</p>
</dd>
<dt>$out</dt>
<dd>
<p> Model output matrix [row, col] = [time, run
index]. The run indices should match with the <code>mpars$par</code> argument.</p>
</dd> 
<dt>$outname</dt>
<dd>
<p> name (character)</p>
</dd>
<dt>$outunits</dt>
<dd>
<p> units (character</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.reg</code></td>
<td>
<p> Logical vector specifying which parameters to include into the
regression matrix. Elements refer to rows of <code>mpars$par</code>.
Note that if nothing is included into the regression matrix, the mean is
still optimized.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.reg</code></td>
<td>
<p>Logical specifying whether to include time into the
regression matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa0</code></td>
<td>
<p> Initial guess for the parameter covariance scaling factor. Larger values
lead to higher parameter covariance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta0</code></td>
<td>
<p>Initial guess for the nugget.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>myrel.tol</code></td>
<td>
<p>Relative tolerance for optimization. If you want to
use the defaults, assign it to NULL. The optimization stops if it thinks the true likelihood is
within this fraction of current likelihood. The higher the
number the sooner the optimization stops, but the emulator
is 'worse'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twice</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the optimization is done twice with different
initial parameter values, and then the best of the two is chosen as
final emulator. Default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix.betas</code></td>
<td>

<p>Logical. If <code>TRUE</code>, beta regression coefficients are fixed, and if <code>FALSE</code>,
they are estimated. Default is <code>TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The emulator parameters are optimized using a local optimization
method, to within the specified relative tolerance. The optimization maximizes
emulator likelihood. Optionally, if <code>twice=TRUE</code>, the optimization is done twice with
different initial parameter settings, and the emulator with the highest
likelihood is selected. Depending on the value of <code>fix.betas</code>, the regression
beta parameters can either be fixed at their multiple linear regression
estimates, or estimated together with other
emulator parameters. Mean structure is flexible, and user can choose which
parameter and time dimensions to use as regressors via the
<code>time.reg</code> and <code>par.reg</code> parameters
</p>


<h3>Value</h3>

<p>Emulator returns an object of <code>class</code> "emul" and is a list with components 
(see also Reference in the References Section).
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$Theta.mat</code></td>
<td>
<p>Theta matrix. [row, col] = [run number, parameter
number]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$t.vec</code></td>
<td>
<p>Time vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Y.mat</code></td>
<td>
<p>Data matrix Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$X.mat</code></td>
<td>
<p>Regression matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$beta.vec</code></td>
<td>
<p>A vector of regression parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$kappa</code></td>
<td>
<p> Parameter covariance scaling factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$phi.vec</code></td>
<td>
<p>A vector of range parameters phi</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$zeta</code></td>
<td>
<p>Nugget</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$n</code></td>
<td>
<p>Length of time dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$rho</code></td>
<td>
<p>Time AR(1) parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$p</code></td>
<td>
<p>Number of model runs in the ensemble</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$vecC</code></td>
<td>
<p>Data matrix Y minus the mean vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$par.reg</code></td>
<td>
<p> Logical vector specifying which parameters to include
in the regression matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$time.reg</code></td>
<td>
<p>Logical, specifies whether to include time into the
regression matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Sigma.mats</code></td>
<td>
<p>List of two precomputed matrices that may be useful:
<code>$Sigma.t.mat</code> and <code>$Sigma.theta.mat</code> (see References)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Sigma.theta.inv.mat</code></td>
<td>
<p>Inverse of <code>$Sigma.mats$Sigma.theta.mat</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Evaluation of this function (especially for large datasets and many parameters) might take a long time.
</p>


<h3>Limitations and Caveats</h3>


<ol>
<li>
<p> The emulator will not work well for 'jagged' model response
surfaces (high nugget)
</p>
</li>
<li>
<p> The emulator is restricted to output at regular intervals in
time and space
</p>
</li>
<li>
<p> The code has not been tested under conditions of extreme high
/ extreme low input parameter range, output time(space) coordinates
range, and output range (an example would be model output ranging
from -1E20 to 1E20, etc.). In such cases it is recommended to
re-scale the time(space) coordinates vector, the input parameters,
and/or the model output.
</p>
</li>
<li>
<p> The emulator will not work on scalar model output â€“ it
requires multivariate data
</p>
</li>
<li>
<p> The emulator assumes a separable covariance function, and
stationarity of the covariance part of the Gaussian process.
</p>
</li>
<li>
<p> The optimization of the emulator parameters degrades
dramatically (and increases in time) as a function of number of
free parameters. Hence, the emulator might be of limited use for
large parameter ensembles
</p>
</li>
<li>
<p> The emulator authors are not responsible for any code errors
and/or bugs
</p>
</li>
</ol>
<h3>Note</h3>

<p>If the final emulator performs poorly, try adjusting the
settings, especially the initial <code>kappa0</code> and <code>zeta0</code> values.
</p>


<h3>References</h3>

<p>R. Olson and W. Chang (2013): Mathematical framework for a separable
Gaussian Process Emulator. Tech. Rep., available from <br><a href="http://www.scrimhub.org/resources/stilt/Olson_and_Chang_2013_Stilt_Emulator_Technical_Report.pdf">www.scrimhub.org/resources/stilt/Olson_and_Chang_2013_Stilt_Emulator_Technical_Report.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>emul.lik</code>, <code>optimize.emul</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Fit an emulator to the example 1D parameter ensemble data
# Do not use any covariates, use standard settings
data(Data.1D.model)
data(Data.1D.par)
emul.1D &lt;- emulator(Data.1D.par, Data.1D.model, FALSE, FALSE, 1, 1)

# Take a look at the range and regression parameters
cat("Range parameters are:", emul.1D$phi.vec, "\n")
cat("Regression parameters are:", emul.1D$beta.vec, "\n")

# Predict using the emulator at Theta*=3
pred.1D &lt;- predict(emul.1D, 3)

# Plot the prediction
plot(emul.1D$t.vec, pred.1D$mean, xlab="Year", ylab="Sample Output")


## Not run: 
    # Fit an emulator to the UVic ESCM 3-parameter ensemble temperature
    # output Use time and aerosol scaling covariates (parameter 3), run
    # the optimization twice with relative tolerance of 0.1, keep
    # regression parameters at their multiple linear regression
    # estimates data(Data.UVic.model) data(Data.UVic.par) UVic.emul &lt;-
    # emulator(mpars=Data.UVic.par, moutput=Data.UVic.model,
    # par.reg=c(FALSE, FALSE, TRUE), time.reg=TRUE, kappa0=1, zeta0=1,
    # myrel.tol=0.1, twice=TRUE, fix.betas=TRUE)
   
## End(Not run)
</code></pre>


</div>