<div class="container">

<table style="width: 100%;"><tr>
<td>paste</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Concatenate Strings</h2>

<h3>Description</h3>

<p>Concatenate (join) the corresponding and/or consecutive elements of
given vectors, after converting them to strings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">paste(..., sep = " ", collapse = NULL, recycle0 = FALSE)

paste0(..., sep = "", collapse = NULL, recycle0 = FALSE)

e1 %x+% e2

strcat(x, collapse = "", na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>character vectors (or objects coercible to)
whose corresponding/consecutive elements are to be concatenated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>single string; separates terms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>single string or <code>NULL</code>; an optional
separator if tokens are to be merged into a single string</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recycle0</code></td>
<td>
<p>single logical value; if <code>FALSE</code>, then empty
vectors provided via <code>...</code> are silently ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>character vectors (or objects coercible to)
whose corresponding elements are to be concatenated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>character vector (or an object coercible to)
whose consecutive elements are to be concatenated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>single logical value; if <code>TRUE</code>, missing values
are silently ignored</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>`%x+%`</code> is an operator that concatenates corresponding
strings from two character vectors (and which behaves just like
the arithmetic <code>`+`</code> operator).
</p>
<p><code>strcat</code> joins (aggregates based on string concatenation)
consecutive strings in a character vector, possibly with
a specified separator in place, into a single string.
</p>
<p><code>paste</code> and <code>paste0</code>, concatenate a number
of vectors using the same separator and then possibly join them into
a single string. We recommend using
<code>`%x+%`</code>, <code>sprintf</code>, and <code>strcat</code> instead
(see below for discussion).
</p>


<h3>Value</h3>

<p>A character vector (in UTF-8).
</p>
<p><code>`%x+%`</code> preserves object attributes in a similar way as
other Arithmetic operators (however, they may be lost
during <code>as.character(...)</code> conversion, which is an S3 generic).
</p>
<p><code>strcat</code> is an aggregation function, therefore it
preserves no attributes whatsoever.
</p>
<p>Currently, <code>paste</code> and <code>paste0</code> preserve no attributes too.
</p>


<h3>Differences from Base R</h3>

<p>Replacement for base <code>paste</code>
implemented with <code>stri_join</code>.
</p>
<p>Note that <code>paste</code> can be thought of as a string counterpart
of both the <code>`+`</code> operator (actually, some languages do have a binary
operator for string concatenation, e.g., <code>`.`</code> in Perl and PHP,
<code>`+`</code> (<code>str.__add__</code>) in Python; R should have it too,
but does not) which is additionally vectorised ('Map') and the
<code>sum</code> function ('Reduce').
Therefore, we would expect it to behave similarly with regards
to the propagation of missing values and the preservation of object
attributes, but it does not.
</p>

<ul>
<li>
<p> missing values treated as <code>"NA"</code> strings (it is a well-documented
feature though) <b>[fixed here]</b>
</p>
</li>
<li>
<p> partial recycling with no warning "longer object length is not
a multiple of shorter object length" <b>[fixed here]</b>
</p>
</li>
<li>
<p> empty vectors are treated as vectors of empty strings
<b>[fixed here]</b>
</p>
</li>
<li>
<p> input objects' attributes are not preserved
<b>[fixed only in <code>`%x+%`</code> operator]</b>
</p>
</li>
<li> <p><code>paste0</code> multiplies entities without necessity;
<code>sep=""</code> should be the default in <code>paste</code> <b>[not fixed]</b>
</p>
</li>
<li> <p><code>paste0</code> treats the named argument <code>sep="..."</code> as one
more vector to concatenate
<b>[fixed by introducing <code>sep</code> argument]</b>
</p>
</li>
<li>
<p> overloading <code>`+.character`</code> has no effect in R, because S3
method dispatch is done internally with hard-coded support for
character arguments. We could have replaced the generic <code>`+`</code>
with the one that calls <code>UseMethod</code>, but the
dispatch would be done on the type of the first argument anyway
(not to mention it feels like a too intrusive solution).
Actually having a separate operator for concatenation (similar to
PHP's or Perl's <code>`.`</code>) which always coerces to character
frees the user from manual coercion (is it such a burden on the other
hand?)
<b>[fixed by introducing <code>`%x+%`</code> operator]</b>
</p>
</li>
</ul>
<p>It should also be noted that <code>paste</code> with <code>collapse=NULL</code> is a
special case of <code>sprintf</code> (which is featured in many programming
languages; R's version is of course vectorised).
For instance, <code>paste(x, y, sep=",")</code>
is equivalent to <code>sprintf("%s,%s", x, y)</code>.
</p>
<p>Taking into account the above, <code>paste</code> and <code>paste0</code> seem
redundant and hence we mark them as [DEPRECATED].
Here are our recommendations:
</p>

<ul>
<li>
<p> the most frequent use case - concatenating corresponding
strings from two character vectors with no separator - is covered
by a new operator <code>`%x+%`</code> which propagates NAs correctly
and handles object attributes the same way as the built-in arithmetic
operators;
</p>
</li>
<li>
<p> for fancy elementwise (like 'Map') concatenation,
use our version of <code>sprintf</code>;
</p>
</li>
<li>
<p> for the 'flattening' of consecutive strings in a character vector
(like 'Reduce'), use the new function <code>strcat</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringx</span> at <a href="https://stringx.gagolewski.com/">https://stringx.gagolewski.com/</a>
</p>
<p>Related function(s): <code>strrep</code>, <code>sprintf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># behaviour of `+` vs. base::paste vs. stringx::paste
x &lt;- structure(c(x=1, y=NA, z=100, w=1000), F="*")
y1 &lt;- structure(c(a=1, b=2, c=3), G="#", F="@")
y2 &lt;- structure(c(a=1, b=2, c=3, d=4), G="#", F="@")
y3 &lt;- structure(1:4, G="#", F="@", dim=c(2, 2), dimnames=list(NULL, c("a", "b")))
x + y1
x + y2
x + y3
y2 + x
base::paste(x, y1)
base::paste(x, y2)
base::paste(x, y3)
stringx::paste(x, y1)
stringx::paste(x, y2)
stringx::paste(x, y3)
base::paste(x, character(0), y2, sep=",")
stringx::paste(x, character(0), y2, sep=",")
x %x+% y1
x %x+% y2
x %x+% y3
y2 %x+% x
x %x+% character(0)
strcat(x, collapse=",")
strcat(x, collapse=",", na.rm=TRUE)


</code></pre>


</div>