<div class="container">

<table style="width: 100%;"><tr>
<td>syn.ipf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Synthesis of a group of categorical variables by iterative 
proportional fitting</h2>

<h3>Description</h3>

<p>A fit to the table is obtained from the log-linear fit that matches the 
numbers in the margins specified by the margin parameters.</p>


<h3>Usage</h3>

<pre><code class="language-R">syn.ipf(x, k, proper = FALSE, priorn = 1, structzero = NULL, 
        gmargins = "twoway", othmargins = NULL, tol = 1e-3,
        max.its = 5000, maxtable = 1e8, print.its = FALSE,
        epsilon = 0, rand = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data frame of the set of original data to be synthesised.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>a number of rows in each synthetic data set - defaults to <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proper</code></td>
<td>
<p>if <code>proper = TRUE</code> <code>x</code> is replaced with a bootstrap 
sample before synthesis, thus effectively sampling from the posterior 
distribution of the model, given the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorn</code></td>
<td>
<p>the sum of the parameters of the Dirichlet prior which can be 
thought of as a pseudo-count giving the number of observations that inform 
prior knowledge about the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structzero</code></td>
<td>
<p>a named list of lists that defines which cells in the table 
are structural zeros and will remain as zeros in the synthetic data, by 
leaving their prior as zeros. Each element of the <code>structzero</code> list is 
a list that describes a set of cells in the table defined by a combination 
of two or more variables and a name of each such element must consist of 
those variable names seperated by an underscore, e.g. <code>sex_edu</code>. 
The length of each such element is determined by the number of variables and 
each component gives the variable levels (numeric or labels) that define the 
structural zero cells (see an example below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmargins</code></td>
<td>
<p>a single character to define a group of margins. At present 
there is "oneway" and "twoway" option that creates, respectively, all 1-way 
and 2-way margins from the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>othmargins</code></td>
<td>
<p>a list of margins that will be fitted. If <code>gmargins</code> is
not <code>NULL</code> <code>othmargins</code> will be added to them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>stopping criterion for <code>Ipfp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.its</code></td>
<td>
<p>maximum umber of iterations allowed for <code>Ipfp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxtable</code></td>
<td>
<p>the number of cells in the cross-tabulation of all the 
variables that will trigger a severe warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.its</code></td>
<td>
<p>if true the iterations from <code>Ipfp</code> will be 
printed on the console. Otherwise only a message as to whether the 
iterations have converged will be given at the end of the fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>epsilon value for overall differential privacy (DP) parameter.
This is implemented by dividing the privacy budget equally over all the 
margins used to fit the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>when epsilon is &gt; 0 and DP synthetic data are created this 
determines whether the data are created by Poisson counts from the expected 
fitted counts in the cells of the DP adjusted data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When used in <code>syn</code> function the group of variables with 
<code>method = "ipf"</code> must all be together at the start of the visit sequence. 
This function is designed for categorical variables, but it can also be used for 
numerical variables if they are categorised by specifying them in the 
<code>numtocat</code> parameter of the main function <code>syn</code>. Subsequent variables 
in <code>visit.sequence</code> are then synthesised conditional on the synthesised 
values of the grouped variables. A fit to the table is obtained from the 
log-linear fit that matches the numbers in the margins specified by the margin 
parameters. Prior probabilities for the proportions in each cell of the table 
are given by a Dirichlet distribution with the same parameter for every cell 
in the table that is not a structural zero. The sum of these parameters is 
<code>priorn</code>. The default <code>priorn = 1</code> can be thought of as equivalent 
to the knowledge that <code>1</code> observation would be equally likely to
fall in any cell of the table. The synthetic data are generated from a multinomial
distribution with parameters given by the expected posterior probabilities for 
each cell of the table. If the maximum likelihood estimate from the log-linear 
fit to cell <code class="reqn">c_i</code> is <code class="reqn">p_i</code> and the table has <code class="reqn">N</code> cells that are not
structural zeros then the expectation of the posterior probability
for this cell is <code class="reqn">(p_i + priorn/N^2) / (1 + priorn / N^2)</code> or
equivalently <code class="reqn">(N * p_i + priorn/N) / (N + priorn / N)</code>.
</p>
<p>Unlike <code>syn.satcat</code>, which fits saturated models from their conditional 
distrinutions, <code>x</code> can include any combination of variables, including 
those not present in the original data, except those defined by <code>structzero</code>.
</p>
<p>NOTE that when the function is called by setting elements of
method in <code>syn</code> to <code>"ipf"</code>, the parameters <code>priorn</code>,
<code>structzero</code>, <code>gmargins</code>, <code>othmargins</code>, <code>tol</code>, 
<code>max.its</code>, <code>maxtable</code>, <code>print.its</code>, <code>epsilon</code>, 
and <code>rand</code> must be supplied to <code>syn</code> as e.g. <code>ipf.priorn</code>.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>a data frame with <code>k</code> rows containing the synthesised data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a list made up of two lists: the margins fitted and the original 
data for each margin.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">ods &lt;- SD2011[, c(1, 4, 5, 6, 2, 10, 11)]
table(ods[, c("placesize", "region")])

# Each `placesize_region` sublist: 
# for each relevant level of `placesize` defined in the first element, 
# the second element defines regions (variable `region`) that do not 
# have places of that size.

struct.zero &lt;- list(
  placesize_region = list(placesize = "URBAN 500,000 AND OVER", 
                          region = c(2, 4, 5, 8:13, 16)),
  placesize_region = list(placesize = "URBAN 200,000-500,000", 
                          region = c(3, 4, 10:11, 13)),
  placesize_region = list(placesize = "URBAN 20,000-100,000", 
                          region = c(1, 3, 5, 6, 8, 9, 14:15)))

synipf &lt;- syn(ods, method = c(rep("ipf", 4), "ctree", "normrank", "ctree"), 
              ipf.gmargins = "twoway", ipf.othmargins = list(c(1, 2, 3)),
              ipf.priorn = 2, ipf.structzero = struct.zero)
</code></pre>


</div>