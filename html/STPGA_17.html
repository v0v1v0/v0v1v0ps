<div class="container">

<table style="width: 100%;"><tr>
<td>GenAlgForSubsetSelection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Genetic algorithm for subset selection</h2>

<h3>Description</h3>

<p>It uses a genetic algorithm to select <code class="reqn">n_{Train}</code> individuals so that optimality criterion is minimum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GenAlgForSubsetSelection(P, Candidates, Test, ntoselect, npop = 100, nelite =
                 5, keepbest = TRUE, tabu = TRUE, tabumemsize = 1, mutprob
                 = 0.8, mutintensity = 1, niterations = 500,
                 minitbefstop = 200, niterreg = 5, lambda = 1e-06,
                 plotiters = FALSE, plottype=1,errorstat = "PEVMEAN2", C = NULL,
                 mc.cores = 1, InitPop = NULL, tolconv = 1e-07, Vg =
                 NULL, Ve = NULL, Fedorov=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>

<p>depending on the criterion this is either a numeric data matrix or a symmetric similarity matrix. When it is a data matrix, the union of the identifiers of the candidate (and test) individuals should be put as rownames (and column names in case of a similarity matrix). For methods using the relationships, this is the inverse of the relationship matrix with row and column names as the the identifiers of the candidate (and test) individuals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Candidates</code></td>
<td>
 
<p>vector of identifiers for the individuals in the candidate set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Test</code></td>
<td>

<p>vector of identifiers for the individuals in the test set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntoselect</code></td>
<td>

<p><code class="reqn">n_{Train}:</code> number of individuals to select in the training set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npop</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nelite</code></td>
<td>

<p>genetic algorithm parameter, number of solutions selected as elite parents which will  generate the next set of solutions. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepbest</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the best solution is always kept in the next generation of solutions (elitism). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tabu</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the solutions that are saved in tabu memory will not be retried.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tabumemsize</code></td>
<td>

<p>genetic algorithm parameter, integer&gt;0. Number of generations to hold in tabu memory. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterations</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minitbefstop</code></td>
<td>

<p>genetic algorithm parameter, number of iterations before stopping if no change is observed in criterion value.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niterreg</code></td>
<td>

<p>genetic algorithm parameter, number of iterations to use regressions, an integer with minimum value of 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>scalar shrinkage parameter  (<code class="reqn">\lambda&gt;0</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plottype</code></td>
<td>

<p>type of plot, default is 1. possible values 1,2,3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorstat</code></td>
<td>

<p>optimality criterion: One of the optimality criterion. Default is "PEVMEAN". It is possible to use user defined functions as shown in the examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolconv</code></td>
<td>

<p>if the algorithm cannot improve the errorstat more than tolconv for the last minitbefstop iterations it will stop.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vg</code></td>
<td>

<p>covariance matrix between traits generated by the relationship K (only for multi-trait version of PEVMEANMM).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ve</code></td>
<td>

<p>residual covariance matrix for the traits (only for multi-trait version of PEVMEANMM). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fedorov</code></td>
<td>

<p>Whether the Fedorovs exchange algorithm from <code>AlgDesign</code> Package should be used for initial solutions. 
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of length nelite+1. The first nelite elements of the list are optimized training samples of size <code class="reqn">n_{train}</code> and they are listed in increasing order of the optimization criterion. The last item on the list is a vector that stores the minimum values of the objective function at each iteration. 
</p>


<h3>Note</h3>

<p>The GA does not guarantee convergence to globally optimal solutions and it is highly recommended that the algorithm is replicated to obtain ”good” training samples. 
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class="language-R">	## Not run: 
####################################
library(EMMREML)
library(STPGA)
data(WheatData)

svdWheat&lt;-svd(Wheat.K, nu=5, nv=5)
PC50WHeat&lt;-Wheat.K%*%svdWheat$v
plot(PC50WHeat[,1],PC50WHeat[,2])
rownames(PC50WHeat)&lt;-rownames(Wheat.K)
DistWheat&lt;-dist(PC50WHeat)
TreeWheat&lt;-hclust(DistWheat)
TreeWheat&lt;-cutree(TreeWheat, k=4)

Test&lt;-rownames(PC50WHeat)[TreeWheat==4]
length(Test)
Candidates&lt;-setdiff(rownames(PC50WHeat), Test)


###instead of using the algorithm directly using a wrapper to 
###implement an for multiple starting points for genetic algorithm.
repeatgenalg&lt;-function(numrepsouter,numrepsinner){
  StartingPopulation2=NULL 
  for (i in 1:numrepsouter){
    print("Rep:")
    print(i)
    StartingPopulation&lt;-lapply(1:numrepsinner, function(x){
    	GenAlgForSubsetSelection(P=PC50WHeat,Candidates=Candidates, 
    	Test=Test, ntoselect=50, InitPop=StartingPopulation2,
 npop=50, nelite=5, mutprob=.5, mutintensity = rpois(1,4),
 niterations=10,minitbefstop=5, tabumemsize = 2,plotiters=TRUE, 
 lambda=1e-9,errorstat="CDMEAN", mc.cores=1)})
    StartingPopulation2&lt;-vector(mode="list", length = numrepsouter*1)
    ij=1
    for (i in 1:numrepsinner){
      for (j in 1:1){
        StartingPopulation2[[ij]]&lt;-StartingPopulation[[i]][[j]]
        ij=ij+1
      }
    }
  }
  ListTrain&lt;-GenAlgForSubsetSelection(P=PC50WHeat,Candidates=Candidates, 
    	Test=Test,ntoselect=50, InitPop=StartingPopulation2,npop=100, 
    	nelite=10, mutprob=.5, mutintensity = 1,niterations=300,
    	minitbefstop=100, tabumemsize = 1,plotiters=T,
    	lambda=1e-9,errorstat="CDMEAN", mc.cores=1)
  return(ListTrain)
}


ListTrain&lt;-repeatgenalg(20, 3)

###test sample
deptestopt&lt;-Wheat.Y[Wheat.Y$id%in%Test,]

##predictions by optimized sample
deptrainopt&lt;-Wheat.Y[(Wheat.Y$id%in%ListTrain[[1]]),]

Ztrain&lt;-model.matrix(~-1+deptrainopt$id)
Ztest&lt;-model.matrix(~-1+deptestopt$id)

modelopt&lt;-emmreml(y=deptrainopt$plant.height,X=matrix(1, nrow=nrow(deptrainopt), ncol=1), 
Z=Ztrain, K=Wheat.K)
predictopt&lt;-Ztest%*%modelopt$uhat

corvecrs&lt;-c()
for (rep in 1:300){
###predictions by a random sample of the same size
  rs&lt;-sample(Candidates, 50)
  
  deptestrs&lt;-Wheat.Y[Wheat.Y$id%in%Test,]
  
  deptrainrs&lt;-Wheat.Y[(Wheat.Y$id%in%rs),]
  
  Ztrain&lt;-model.matrix(~-1+deptrainrs$id)
  Ztest&lt;-model.matrix(~-1+deptestrs$id)
  
  library(EMMREML)
  modelrs&lt;-emmreml(y=deptrainrs$plant.height,X=matrix(1, nrow=nrow(deptrainrs), ncol=1), 
  Z=Ztrain, K=Wheat.K)
  predictrs&lt;-Ztest%*%modelrs$uhat
corvecrs&lt;-c(corvecrs,cor(predictrs, deptestrs$plant.height))

}
mean(corvecrs)
cor(predictopt, deptestopt$plant.height)


plot(PC50WHeat[,1],PC50WHeat[,2], col=rownames(PC50WHeat)%in%ListTrain[[1]]+1,
pch=2*rownames(PC50WHeat)%in%Test+1, xlab="pc1", ylab="pc2")

## End(Not run)


</code></pre>


</div>