<div class="container">

<table style="width: 100%;"><tr>
<td>powerRelationGenerator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate power relations</h2>

<h3>Description</h3>

<p>Based on a list of coalitions, create a generator function that returns a new <code>PowerRelation</code> object with every call.
<code>NULL</code> is returned once every possible power relation has been generated.
</p>
<p>Alternatively, use <code>generateRandomPowerRelation()</code> to create random power relations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">powerRelationGenerator(coalitions, startWithLinearOrder = FALSE)

generateNextPartition(gen)

generateRandomPowerRelation(coalitions, linearOrder = FALSE, monotonic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coalitions</code></td>
<td>
<p>List of coalition vectors. An empty coalition can be set with <code>c()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startWithLinearOrder</code></td>
<td>
<p>If set to <code>TRUE</code>, the first <code>PowerRelation</code> object generated will be a linear order in the order of the list of <code>coalitions</code> they are given.
If set to <code>FALSE</code>, the first <code>PowerRelation</code> object generated will have a single equivalence class containing all coalitions, as in, every coalition is equally powerful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gen</code></td>
<td>
<p>A generator object returned by <code>powerRelationGenerator()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linearOrder</code></td>
<td>
<p>logical, if TRUE, only linear orders are generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monotonic</code></td>
<td>
<p>logical, if TRUE, only monotonic power relations are created (see <code>makePowerRelationMonotonic()</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Using the <code>partitions</code> library, <code>partitions::compositions()</code> is used to create all possible partitions over the set of coalitions.
For every partition, <code>partitions::multinomial()</code> is used to create all permutations over the order of the coalitions.
</p>
<p>Note that the number of power relations (or total preorders) grows incredibly fast.
</p>
<p>The Stirling number of second kind <code class="reqn">S(n,k)</code> gives us the number of <code class="reqn">k</code> partitions over <code class="reqn">n</code> elements.
</p>
<p style="text-align: center;"><code class="reqn">S(n,k) = \frac{1}{k!}\sum_{j=0}^{k} (-1)^j \binom{k}{j}(k-j)^n</code>
</p>

<p>For example, with 4 coalitions (n = 4) there are 6 ways to split it into k = 3 partitions.
The sum of all partitions of any size is also known as the Bell number (<code class="reqn">B_n = \sum_{k=0}^n S(n,k)</code>, see also <code>numbers::bell()</code>).
</p>
<p>Regarding total preorders <code class="reqn">\mathcal{T}(X)</code> over a set <code class="reqn">X</code>, the Stirling number of second kind can be used to determine the number of all possible total preorders <code class="reqn">|\mathcal{T}(X)|</code>.
</p>
<p style="text-align: center;"><code class="reqn">|\mathcal{T}(X)| = \sum_{k=0}^{|X|} k! * S(|X|, k)</code>
</p>

<p>In literature, it is referred to as the ordered Bell number or Fubini number.
</p>
<p>In the context of social rankings we may consider total preorders over the set of coalitions <code class="reqn">2^N</code> for a given set of elements or players <code class="reqn">N</code>.
Here, the number of coalitions doubles with every new element.
The number of preorders then are:</p>

<table>
<tr>
<td style="text-align: left;">
   # of elements </td>
<td style="text-align: left;"> # of coalitions </td>
<td style="text-align: left;"> # of total preorders </td>
<td style="text-align: left;"> 1ms / computation </td>
</tr>
<tr>
<td style="text-align: left;">
   0 </td>
<td style="text-align: left;"> 1 </td>
<td style="text-align: left;"> 1 </td>
<td style="text-align: left;"> 1ms </td>
</tr>
<tr>
<td style="text-align: left;">
   1 </td>
<td style="text-align: left;"> 2 </td>
<td style="text-align: left;"> 3 </td>
<td style="text-align: left;"> 3ms </td>
</tr>
<tr>
<td style="text-align: left;">
   2 </td>
<td style="text-align: left;"> 4 </td>
<td style="text-align: left;"> 75 </td>
<td style="text-align: left;"> 75ms </td>
</tr>
<tr>
<td style="text-align: left;">
   3 </td>
<td style="text-align: left;"> 7 (w/o empty set) </td>
<td style="text-align: left;"> 47,293 </td>
<td style="text-align: left;"> 47 seconds </td>
</tr>
<tr>
<td style="text-align: left;">
   3 </td>
<td style="text-align: left;"> 8 </td>
<td style="text-align: left;"> 545,835 </td>
<td style="text-align: left;"> 9 minutes </td>
</tr>
<tr>
<td style="text-align: left;">
   4 </td>
<td style="text-align: left;"> 15 (w/o empty set) </td>
<td style="text-align: left;"> 230,283,190,977,853 </td>
<td style="text-align: left;"> 7,302 years </td>
</tr>
<tr>
<td style="text-align: left;">
   4 </td>
<td style="text-align: left;"> 16 </td>
<td style="text-align: left;"> 5,315,654,681,981,355 </td>
<td style="text-align: left;"> 168,558 years </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Value</h3>

<p>A generator function.
Every time this generator function is called, a different <code>PowerRelation</code> object is returned.
Once all possible power relations have been generated, the generator function returns <code>NULL</code>.
</p>
<p>A generator function.
If the generator is already down to its last partition, it will throw an error.
</p>
<p>Use <code>generateNextPartition(gen)</code> to skip to the next partition of the generator.
</p>


<h3>Note</h3>

<p>Due to its implementation, <code>randomPowerRelation()</code> does not create weak orders uniformly.
I.e., it is much less likely to generate linear orders even though they have the proportionally highest representation
in the set of all weak orders.
</p>


<h3>Examples</h3>

<pre><code class="language-R">coalitions &lt;- createPowerset(c('a','b'), includeEmptySet = FALSE)
# list(c('a','b'), 'a', 'b')

gen &lt;- powerRelationGenerator(coalitions)

while(!is.null(pr &lt;- gen())) {
  print(pr)
}
# (ab ~ a ~ b)
# (ab ~ a) &gt; b
# (ab ~ b) &gt; a
# (a ~ b) &gt; ab
# ab &gt; (a ~ b)
# a &gt; (ab ~ b)
# b &gt; (ab ~ a)
# ab &gt; a &gt; b
# ab &gt; b &gt; a
# a &gt; ab &gt; b
# b &gt; ab &gt; a
# a &gt; b &gt; ab
# b &gt; a &gt; ab

# from now on, gen() always returns NULL
gen()
# NULL

# Use generateNextPartition() to skip certain partitions
gen &lt;- powerRelationGenerator(coalitions)

gen &lt;- generateNextPartition(gen)
gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; (a ~ b)

gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; a &gt; b

coalitions &lt;- createPowerset(c('a','b'), includeEmptySet = FALSE)
# list(c('a','b'), 'a', 'b')

gen &lt;- powerRelationGenerator(coalitions)
gen()
# (ab ~ a ~ b)

gen()
# (ab ~ b) &gt; a

# skipping partition of size two, where the first partition has
# 2 coalitions and the second partition has 1 coalition
gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; (a ~ b)

# only remaining partition is one of size 3, wherein each
# equivalence class is of size 1
gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; a &gt; b

# went through all partitions, it will only generate NULL now
gen &lt;- generateNextPartition(gen)
stopifnot(is.null(gen()))


# create random power relation
generateRandomPowerRelation(coalitions)

# make sure it's monotonic, i.e., {1} &gt; {1,2} cannot exist
# because {1} is a subset of {1,2}
generateRandomPowerRelation(coalitions, monotonic = TRUE)

</code></pre>


</div>