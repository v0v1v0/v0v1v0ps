<div class="container">

<table style="width: 100%;"><tr>
<td>SEL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Semiparametric Elicitation of a bounded parameter </h2>

<h3>Description</h3>

<p>Fits a distribution to quantiles (stated for example by an expert)
using B-splines with a Brier entropy penalty.
</p>
<p>There exists a <code>print</code> and a <code>summary</code> method to display
details of the fitted SEL object. The fitted density (or cdf) can be
displayed with the <code>plot</code> method.  Different
SEL objects can be displayed in one plot with the
<code>comparePlot</code> function. The fitted density (or cdf) can be
evaluated with the <code>predict</code> method. The
<code>coef</code> method extracts the coefficients of the fitted B-spline
basis. The <code>quantSEL</code> function calculates quantiles of the
fitted distribution and the <code>rvSEL</code> function generates
random variables from a fitted SEL object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  SEL(x, alpha, bounds = c(0, 1), d = 4, inknts = x, N, gamma, Delta,
      fitbnds = c(1e-8, 10)*diff(bounds), pistar = NULL,
      constr = c("none", "unimodal", "decreasing", "increasing"),
      mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> Numeric vector of quantiles. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> Numeric vector determining the levels of the quantiles
specified in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p> Vector containing the bounds for the expert's density. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p> Number of equally spaced inner knots (ignored if
<code>inknts</code> is specified). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p> Degree of the spline (the order of the spline is d+1),
values larger than 20 are to be avoided; they can
lead to numerical instabilities. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inknts</code></td>
<td>
<p> Vector specifying the inner knots. If equal to
<code>NULL</code>, the B-spline basis reduces to the Bernstein polynomial
basis. Per default the inner knots are located on the values
specified via <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p> Parameter controlling the weight of the negative
entropy in the objective function to be optimized (see Bornkamp and
Ickstadt (2009)). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Delta</code></td>
<td>
<p> The code calculates the <code>gamma</code> parameter achieving a
certain overall L2 distance between the specified quantiles and the fitted
distribution function (only if <code>gamma</code> is not specified). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitbnds</code></td>
<td>
<p> Numeric of length 2 for the bisection search algorithm
searching for gamma giving the error Delta (only relevant if gamma is
missing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pistar</code></td>
<td>
<p> Prior density function used in Brier
divergence (see Bornkamp and
Ickstadt (2009). If <code>NULL</code> Brier entropy is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p> Character vector specifying, which shape constraint should
be used, should be one of "none", "unimodal", "decreasing",
"increasing".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p> Numerical value needed when <code>constraint =
       "unimodal"</code>. The code selects the knot average closest
to <code>mode</code> as the location of the mode for the finite
dimensional constraints on the coefficients of the B-spline
in the optimization (note that the final
density will only have a mode close to the value specified via <code>mode</code>). </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An SEL object containing the following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p>Character determining the shape constraint used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inknts </code></td>
<td>
<p>Inner knots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nord</code></td>
<td>
<p>Order of the spline.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Bounds for the elicited quantity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xalpha</code></td>
<td>
<p>List containing the specified quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>Penalty matrix used for calculating Brier entropy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>Fitted coefficients of the B-spline basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pistar</code></td>
<td>
<p>Function handed over to <code>SEL</code> via the
<code>pistar</code> argument (if any).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dplus</code></td>
<td>
<p>The d vector, only necessary when pistar is specified
(see Bornkamp and Ickstadt (2009).)
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Bjoern Bornkamp </p>


<h3>References</h3>

 
<p>Bornkamp, B. and Ickstadt, K. (2009). A Note on B-Splines for
Semiparametric Elicitation. <em>The American Statistician</em>,
<b>63</b>, 373â€“377
</p>
<p>O'Hagan A., Buck C. E., Daneshkhah, A., Eiser, R., Garthwaite,
P., Jenkinson, D., Oakley, J. and Rakow, T. (2006), <em>Uncertain
Judgements: Eliciting Expert Probabilities</em>, John Wiley and Sons Inc.
</p>
<p>Dierckx, P. (1993), <em>Curve and Surface
Fitting with Splines</em>, Clarendon Press
</p>


<h3>See Also</h3>

 <p><code>plot.SEL</code>, <code>comparePlot</code>, <code>quantSEL</code>, <code>rvSEL</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">### example from O'Hagan et al. (2006)
### 1st example in Bornkamp and Ickstadt (2009)
x &lt;- c(177.5, 183.75, 190, 205, 220)
y &lt;- c(0.175, 0.33, 0.5, 0.75, 0.95)
I &lt;- SEL(x, y, d = 1, Delta = 0.015, bounds = c(165, 250), inknts = x)
II &lt;- SEL(x, y, d = 14, N = 0, Delta = 0.015, bounds = c(165, 250))
III &lt;- SEL(x, y, d = 4, Delta = 0.015, bounds = c(165, 250), inknts = x)
IV &lt;- SEL(x, y, d = 4, Delta = 0.015, bounds = c(165, 250), inknts = x,
      constr = "u", mode = 185)
comparePlot(I, II, III, IV, type = "cdf")
comparePlot(I, II, III, IV, type = "density")



### bimodal example 
x2 &lt;- c(0.1, 0.2, 0.5, 0.8, 0.9)
y2 &lt;- c(0.2, 0.4, 0.45, 0.85, 0.99)
fit1 &lt;- SEL(x2, y2, Delta=0.05, d = 4, inknts = x2)
fit2 &lt;- SEL(x2, y2, Delta=0.05, d = 15, N = 0)
comparePlot(fit1, fit2, superpose = TRUE)



### sample from SEL object and evaluate density
xxx &lt;- rvSEL(50000, fit1)
hist(xxx, breaks=100, freq=FALSE)
curve(predict(fit1, newdata=x), add=TRUE)



### illustrate shrinkage against uniform dist.
gma01 &lt;- SEL(x2, y2, gamma = 0.1)
gma02 &lt;- SEL(x2, y2, gamma = 0.2)
gma04 &lt;- SEL(x2, y2, gamma = 0.4)
gma10 &lt;- SEL(x2, y2, gamma = 1.0)
comparePlot(gma01, gma02, gma04, gma10, superpose = TRUE)



### including shape constraints
x &lt;- c(177.5, 183.75, 190, 205, 220)
y &lt;- c(0.175, 0.33, 0.5, 0.75, 0.95)
unconstr1 &lt;- SEL(x, y, Delta = 0.05, bounds = c(165, 250))
unconstr2 &lt;- SEL(x, y, d = 10, N = 0, Delta = 0.05, bounds = c(165,250))
unimod1 &lt;- SEL(x, y, Delta = 0.05, bounds = c(165, 250),
            constr = "unimodal", mode = 185)
unimod2 &lt;- SEL(x, y, d = 10, N = 0, Delta = 0.05, bounds = c(165, 250),
           constr =  "unimodal", mode = 185)
comparePlot(unconstr1, unconstr2, unimod1, unimod2)



### shrinkage against another distribution
pr &lt;- function(x) dbeta(x, 2, 2)
pr01  &lt;- SEL(x2, y2, gamma = 0.1, d = 3, pistar = pr)
pr03  &lt;- SEL(x2, y2, gamma = 0.3, d = 3, pistar = pr)
pr12 &lt;- SEL(x2, y2, gamma = 1.2, pistar = pr)
comparePlot(pr01, pr03, pr12, superpose = TRUE)



### 2nd example from Bornkamp and Ickstadt (2009)
# theta
# "true" density
pmixbeta &lt;- function(x, a1, b1, a2, b2){
  0.3*pbeta(x/20,a1,b1)+0.7*pbeta(x/20,a2,b2)
}
dmixbeta &lt;- function(x, a1, b1, a2, b2){
  out &lt;- 0.3*dbeta(x/20,a1,b1)+0.7*dbeta(x/20,a2,b2)
  out/20
}
x &lt;- c(2,10,15)
a1 &lt;- 1;a2 &lt;- 10;b1 &lt;- 15;b2 &lt;- 5
mu &lt;- pmixbeta(x, a1, b1, a2, b2)
set.seed(1) # simulate experts statements
y &lt;- rnorm(length(mu), mu, sqrt(mu*(1-mu)*0.05^2))
thet &lt;- SEL(x, y, d = 4, Delta = 0.03, bounds = c(0, 20), inknts = x)
plot(thet, ylim = c(0,0.25))
curve(dmixbeta(x, a1, b1, a2, b2), add=TRUE, col="red")
abline(h=0.05, lty = 2)
legend("topright", c("true density", "elicited density", "uniform density"), 
       col=c(2,1,1), lty=c(1,1,2))

# sigma
# "true" density
dtriang &lt;- function(x,m,a,b){
  inds &lt;- x &lt; m;res &lt;- numeric(length(x))
  res[inds] &lt;- 2*(x[inds]-a)/((b-a)*(m-a))
  res[!inds] &lt;- 2*(b-x[!inds])/((b-a)*(b-m))
  res
}
ptriang &lt;- function(x,m,a,b){
  inds &lt;- x &lt; m;res &lt;- numeric(length(x))
  res[inds] &lt;- (x[inds]-a)^2/((b-a)*(m-a))
  res[!inds] &lt;- 1-(b-x[!inds])^2/((b-a)*(b-m))
  res
}
x &lt;- c(1,2,4)
mu &lt;- ptriang(x, 1, 0, 5)
set.seed(1) # simulate experts statements
y &lt;- rnorm(length(mu), mu, sqrt(mu*(1-mu)*0.05^2))
sig &lt;- SEL(x, y, d = 4, Delta = 0.03, bounds = c(0, 5),
       inknts = x, mode = 1, constr="unimodal")
plot(sig, ylim=c(0,0.4))
curve(dtriang(x, 1, 0, 5), add=TRUE, col="red")
abline(h=0.2, lty = 2)
legend("topright", c("true density", "elicited density", "uniform density"), 
       col=c(2,1,1), lty=c(1,1,2))


## Not run: 
### generate some random elicitations
numb &lt;- max(rnbinom(1, mu = 4, size = 1), 1)
x0 &lt;- runif(1, -1000, 1000)
x1 &lt;- x0+runif(1, 0, 1000)
xs &lt;- sort(runif(numb, x0, x1))
y &lt;- runif(numb+1)
ys &lt;- (cumsum(y)/sum(y))[1:numb]
fit1 &lt;- SEL(xs, ys, bounds = c(x0, x1))
fit2 &lt;- SEL(xs, ys, d = 1, inknts = xs, bounds = c(x0, x1))
fit3 &lt;- SEL(xs, ys, d = 15, N = 0, bounds = c(x0, x1))
comparePlot(fit1, fit2, fit3, type="cdf")

## End(Not run)
</code></pre>


</div>