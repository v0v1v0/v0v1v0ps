<div class="container">

<table style="width: 100%;"><tr>
<td>sbss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spatial Blind Source Separation
</h2>

<h3>Description</h3>

<p><code>sbss</code> estimates the unmixing matrix assuming a spatial blind source separation model by simultaneous/jointly diagonalizing the covariance matrix and one/many local covariance matrices. These local covariance matrices are determined by spatial kernel functions. Three types of such kernel functions are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sbss(x, ...)

## Default S3 method:
sbss(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, lcov = c('lcov', 'ldiff', 'lcov_norm'), ordered = TRUE, 
     kernel_list = NULL, rob_whitening = FALSE, ...)
## S3 method for class 'SpatialPointsDataFrame'
sbss(x, ...)
## S3 method for class 'sf'
sbss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code>SpatialPointsDataFrame</code> or an object of class <code>sf</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default), <code>'ldiff'</code> or <code>'lcov_norm'</code>. See <code>sbss_asymp</code> for details on the latter option.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared (pseudo-)eigenvalues of the diagonalized local covariance matrix/matrices. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rob_whitening</code></td>
<td>

<p>logical. If <code>TRUE</code> whitening is carried out with respect to the first spatial scatter matrix and not the sample covariance matrix, see details. Default is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code>frjd</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Three versions of local covariance matrices are implemented, the argument <code>lcov</code> determines which version is used:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li>
</ul>
<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code>sbss_asymp</code> and <code>sbss_boot</code>. LDiff matrices are supposed to be more robust when the random field shows a smooth trend. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_{in}</code> and outer radius <code class="reqn">r_{out}</code>, with <code class="reqn">r_{in} &lt; r_{out}</code>, and <code class="reqn">r_{in}, r_{out} \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_{in}, r_{out}) = I(r_{in} &lt; d \le r_{out})</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2)</code>
</p>

</li>
</ul>
<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> local covariance matrices are used. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_in1, r_out1, r_in2, r_out2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> local covariance matrices are used.
</p>
<p>Internally, <code>sbss</code> calls <code>spatial_kernel_matrix</code> to compute a list of <code>c(n,n)</code> kernel matrices based on the parameters given, where each entry of those matrices corresponds to <code class="reqn">f(d_{i,j})</code>. Alternatively, such a list of kernel matrices can be given directly to the function <code>sbss</code> via the <code>kernel_list</code> argument. This is useful when <code>sbss</code> is called numerous times with the same coordinates/kernel functions as the computation of the kernel matrices is then done only once prior the actual <code>sbss</code> calls. For details see also <code>spatial_kernel_matrix</code>.
</p>
<p><code>rob_whitening</code> determines which scatter is used for the whitening step. If <code>TRUE</code>, whitening is carried out with respect to the scatter matrix defined by the <code>lcov</code> argument, where the kernel function is given by the argument <code>kernel_type</code> and the parameters correspond to the first occuring in the argument <code>kernel_parameters</code>. Therefore, at least two different kernel parameters need to be given. Note that only <code class="reqn">LDiff(f)</code> matrices are positive definite, hence whitening with <code>'lcov'</code> is likely to produce an error. If the argument is <code>FALSE</code>, whitening is carried out with respect to the usual sample covariance matrix. <code>sbss</code> internally calls <code>white_data</code>.
</p>
<p>If more than one local covariance matrix is used <code>sbss</code> jointly diagonalizes these matrices with the function <code>frjd</code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>sbss</code> returns a list of class <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>sbss</code> call.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pevals</code></td>
<td>

<p>(pseudo-)eigenvalues for each latent field entry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c(length(kernel_parameters)*p,p)</code> for <code>'ball'</code> and <code>'gauss'</code> kernel or <code>c(</code>
<code>(length(kernel_parameters) / 2)*p,p)</code> for <code>'ring'</code> kernel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diags</code></td>
<td>

<p>matrix of dimension <code>c(length(kernel_parameters),p)</code> where the rows contain the diagonal of the diagonalized local autocovariance matrices.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>
<p>Nordhausen, K., Oja, H., Filzmoser, P., Reimann, C. (2015), <em>Blind Source Separation for Spatial Compositional Data</em>, Mathematical Geosciences 47, 753-770, <a href="https://doi.org/10.1007/s11004-014-9559-5">doi:10.1007/s11004-014-9559-5</a>.
</p>
<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.v
</p>


<h3>See Also</h3>

<p><code>spatial_kernel_matrix</code>, <code>local_covariance_matrix</code>, <code>sp</code>, <code>sf</code>, <code>frjd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")

# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # apply sbss with three ring kernels
  kernel_parameters &lt;- c(0, 1, 1, 2, 2, 3)
  sbss_result &lt;- 
    sbss(field, coords, kernel_type = 'ring', kernel_parameters = kernel_parameters)
  
  # print object
  print(sbss_result)
  
  # plot latent field
  plot(sbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid
  predict(sbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix
  w_unmix &lt;- coef(sbss_result)
  
  # apply the same sbss with a kernel list
  kernel_list &lt;- spatial_kernel_matrix(coords, kernel_type = 'ring', kernel_parameters)
  sbss_result_k &lt;- sbss(field, kernel_list = kernel_list)
  
  # apply sbss with three ring kernels and local difference matrices
  sbss_result_ldiff &lt;- 
    sbss(field, coords, kernel_type = 'ring', 
         kernel_parameters = kernel_parameters, lcov = 'ldiff')
}

</code></pre>


</div>