<div class="container">

<table style="width: 100%;"><tr>
<td>adaptMetropGibbs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive Metropolis within Gibbs algorithm</h2>

<h3>Description</h3>

<p>Markov chain Monte Carlo for continuous random vector using an
adaptive Metropolis within Gibbs algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">adaptMetropGibbs(ltd, starting, tuning=1, accept.rate=0.44,
                 batch = 1, batch.length=25, report=100,
                 verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ltd</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function that evaluates the log target density of the
desired equilibrium distribution of the Markov chain. First argument is the
starting value vector of the Markov chain. Pass variables used in
the <code>ltd</code> via the ... argument of <code>aMetropGibbs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a real vector of parameter starting values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p> a scalar or vector of initial Metropolis tuning values. The vector must be of <code>length(starting)</code>. If a scalar is passed then it is expanded to <code>length(starting)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept.rate</code></td>
<td>
<p> a scalar or vector of target Metropolis acceptance
rates. The vector must be of <code>length(starting)</code>. If a scalar is passed then it is expanded to <code>length(starting)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p>the number of batches. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch.length</code></td>
<td>
<p>the number of sampler iterations in each batch. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>report</code></td>
<td>
<p>the number of batches between acceptance rate reports. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis acceptance rate at the end of each
batch. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ltd</code></td>
<td>
<p><code>ltd</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept.rate</code></td>
<td>
<p><code>accept.rate</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p><code>batch</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch.length</code></td>
<td>
<p><code>batch.length</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proc.time</code></td>
<td>
<p>the elapsed CPU and wall time (in seconds). </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function is a rework of Rosenthal (2007) with some added
niceties. </p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>
</p>


<h3>References</h3>

<p>Roberts G.O. and Rosenthal J.S. (2006). Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint.
</p>
<p>Rosenthal J.S. (2007). AMCMC: An R interface for adaptive MCMC. <em>Computational
Statistics and Data Analysis</em>. 51:5467-5470.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

###########################
##Fit a spatial regression
###########################
set.seed(1)
n &lt;- 50
x &lt;- runif(n, 0, 100)
y &lt;- runif(n, 0, 100)

D &lt;- as.matrix(dist(cbind(x, y)))

phi &lt;- 3/50
sigmasq &lt;- 50
tausq &lt;- 20
mu &lt;- 150

s &lt;- (sigmasq*exp(-phi*D))
w &lt;-  rmvn(1, rep(0, n), s)
Y &lt;- rmvn(1, rep(mu, n) + w, tausq*diag(n))
X &lt;- as.matrix(rep(1, length(Y)))

##Priors
##IG sigma^2 and tau^2
a.sig &lt;- 2 
b.sig &lt;- 100
a.tau &lt;- 2
b.tau &lt;- 100

##Unif phi
a.phi &lt;- 3/100
b.phi &lt;- 3/1

##Functions used to transform phi to continuous support.
logit &lt;- function(theta, a, b){log((theta-a)/(b-theta))}
logit.inv &lt;- function(z, a, b){b-(b-a)/(1+exp(z))}

##Metrop. target
target &lt;- function(theta){
  
  mu.cand &lt;- theta[1]
  sigmasq.cand &lt;- exp(theta[2])
  tausq.cand &lt;- exp(theta[3])
  phi.cand &lt;- logit.inv(theta[4], a.phi, b.phi)

  Sigma &lt;- sigmasq.cand*exp(-phi.cand*D)+tausq.cand*diag(n)
  SigmaInv &lt;- chol2inv(chol(Sigma))
  logDetSigma &lt;- determinant(Sigma, log=TRUE)$modulus[1]
  
  out &lt;- (
          ##Priors
          -(a.sig+1)*log(sigmasq.cand) - b.sig/sigmasq.cand
          -(a.tau+1)*log(tausq.cand) - b.tau/tausq.cand
          ##Jacobians
          +log(sigmasq.cand) + log(tausq.cand) 
          +log(phi.cand - a.phi) + log(b.phi -phi.cand) 
          ##Likelihood
          -0.5*logDetSigma-0.5*(t(Y-X%*%mu.cand)%*%SigmaInv%*%(Y-X%*%mu.cand))
          )
  
  return(out)
}


##Run a couple chains
n.batch &lt;- 500
batch.length &lt;- 25

inits &lt;- c(0, log(1), log(1), logit(3/10, a.phi, b.phi))
chain.1 &lt;- adaptMetropGibbs(ltd=target, starting=inits,
                            batch=n.batch, batch.length=batch.length, report=100)

inits &lt;- c(500, log(100), log(100), logit(3/90, a.phi, b.phi))
chain.2 &lt;- adaptMetropGibbs(ltd=target, starting=inits,
                            batch=n.batch, batch.length=batch.length, report=100)

##Check out acceptance rate just for fun
plot(mcmc.list(mcmc(chain.1$acceptance), mcmc(chain.2$acceptance)))

##Back transform
chain.1$p.theta.samples[,2] &lt;- exp(chain.1$p.theta.samples[,2])
chain.1$p.theta.samples[,3] &lt;- exp(chain.1$p.theta.samples[,3])
chain.1$p.theta.samples[,4] &lt;- 3/logit.inv(chain.1$p.theta.samples[,4], a.phi, b.phi)

chain.2$p.theta.samples[,2] &lt;- exp(chain.2$p.theta.samples[,2])
chain.2$p.theta.samples[,3] &lt;- exp(chain.2$p.theta.samples[,3])
chain.2$p.theta.samples[,4] &lt;- 3/logit.inv(chain.2$p.theta.samples[,4], a.phi, b.phi)

par.names &lt;- c("mu", "sigma.sq", "tau.sq", "effective range (-log(0.05)/phi)")
colnames(chain.1$p.theta.samples) &lt;- par.names
colnames(chain.2$p.theta.samples) &lt;- par.names

##Discard burn.in and plot and do some convergence diagnostics
chains &lt;- mcmc.list(mcmc(chain.1$p.theta.samples), mcmc(chain.2$p.theta.samples))
plot(window(chains, start=as.integer(0.5*n.batch*batch.length)))

gelman.diag(chains)

##########################
##Example of fitting a
##a non-linear model
##########################
##Example of fitting a non-linear model
set.seed(1)

########################################################
##Simulate some data.
########################################################
a &lt;- 0.1 #-Inf &lt; a &lt; Inf
b &lt;- 0.1 #b &gt; 0
c &lt;- 0.2 #c &gt; 0
tau.sq &lt;- 0.1 #tau.sq &gt; 0

fn &lt;- function(a,b,c,x){
  a+b*exp(x/c)
}

n &lt;- 200
x &lt;- seq(0,1,0.01)
y &lt;- rnorm(length(x), fn(a,b,c,x), sqrt(tau.sq))

##check out your data
plot(x, y)

########################################################
##The log target density
########################################################
##Define the log target density used in the Metrop.
ltd &lt;- function(theta){

  ##extract and transform as needed
  a &lt;- theta[1]
  b &lt;- exp(theta[2])
  c &lt;- exp(theta[3])
  tau.sq &lt;- exp(theta[4])

  y.hat &lt;- fn(a, b, c, x)

  ##likelihood
  logl &lt;- sum(dnorm(y, y.hat, sqrt(tau.sq), log=TRUE))

  ##priors IG on tau.sq and normal on a and transformed b, c, d
  logl &lt;- (logl
           -(IG.a+1)*log(tau.sq)-IG.b/tau.sq
           +sum(dnorm(theta[1:3], N.mu, N.v, log=TRUE))
           )
  
  ##Jacobian adjustment for tau.sq
  logl &lt;- logl+log(tau.sq)
  
  return(logl)  
}

########################################################
##The rest
########################################################

##Priors
IG.a &lt;- 2
IG.b &lt;- 0.01

N.mu &lt;- 0
N.v &lt;- 10

theta.tuning &lt;- c(0.01, 0.01, 0.005, 0.01)

##Run three chains with different starting values
n.batch &lt;- 1000
batch.length &lt;- 25

theta.starting &lt;- c(0, log(0.01), log(0.6), log(0.01))
run.1 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

theta.starting &lt;- c(1.5, log(0.05), log(0.5), log(0.05))
run.2 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

theta.starting &lt;- c(-1.5, log(0.1), log(0.4), log(0.1))
run.3 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

##Back transform
samples.1 &lt;- cbind(run.1$p.theta.samples[,1], exp(run.1$p.theta.samples[,2:4]))
samples.2 &lt;- cbind(run.2$p.theta.samples[,1], exp(run.2$p.theta.samples[,2:4]))
samples.3 &lt;- cbind(run.3$p.theta.samples[,1], exp(run.3$p.theta.samples[,2:4]))

samples &lt;- mcmc.list(mcmc(samples.1), mcmc(samples.2), mcmc(samples.3))

##Summary 
plot(samples, density=FALSE)
gelman.plot(samples)

burn.in &lt;- 5000

fn.pred &lt;- function(theta,x){
  a &lt;- theta[1]
  b &lt;- theta[2]
  c &lt;- theta[3]
  tau.sq &lt;- theta[4]
  
  rnorm(length(x), fn(a,b,c,x), sqrt(tau.sq))
}

post.curves &lt;- t(apply(samples.1[burn.in:nrow(samples.1),], 1, fn.pred, x))

post.curves.quants &lt;- summary(mcmc(post.curves))$quantiles

plot(x, y, pch=19, xlab="x", ylab="f(x)")
lines(x, post.curves.quants[,1], lty="dashed", col="blue")
lines(x, post.curves.quants[,3])
lines(x, post.curves.quants[,5], lty="dashed", col="blue")



## End(Not run)
</code></pre>


</div>