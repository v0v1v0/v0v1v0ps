<div class="container">

<table style="width: 100%;"><tr>
<td>eigen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Eigenvalues for Sparse Matrices</h2>

<h3>Description</h3>

<p>Functions to calculate eigenvalues and eigenvectors of <code>sparse</code> matrices.
It uses the value of <code>spam.options("inefficiencywarning")</code> to dispatch between <code>base::eigen()</code> or the Implicitly Restarted Arnoldi Process, using 'ARPACK'.
</p>
<p><code>eigen.spam</code> is a wrapper function of <code>eigen_approx</code> and transforms its output to <code>base::eigen</code> like.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eigen.spam(x, nev = 10, symmetric, only.values = FALSE, control = list())
eigen_approx(x, nev, ncv, nitr, mode, only.values = FALSE, verbose = FALSE, f_routine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of class <code>spam</code> whose <code>nev</code> eigenvalues and eigenvectors are to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nev</code></td>
<td>
<p>number of eigenvalues to calculate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>if TRUE, the matrix is assumed to be symmetric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.values</code></td>
<td>
<p>if TRUE, only <code>nev</code> eigenvalues are computed and returned, otherwise <code>nev</code> eigenvalues and eigenvectors are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>additional options, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncv</code></td>
<td>
<p>see ‘Details’, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nitr</code></td>
<td>
<p>see ‘Details’, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>see ‘Details’, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>see ‘Details’, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_routine</code></td>
<td>
<p>only for <code>eigen_approx</code>, to call the Fortran routine for symmetric matrices set this option to "ds_eigen_f" and for non symmetric to "dn_eigen_f".</p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt>
<code>mode = "  "</code>:</dt>
<dd>
<p>there are different modes available for this function, each mode returns a different range of eigenvalues.
Also the available modes are dependent, whether the input matrix is symmetric or not:
</p>

<dl>
<dt>
<code>"LM"</code>:</dt>
<dd>
<p>Eigenvalues with largest magnitude (sym, non sym), that is, largest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt>
<code>"SM"</code>:</dt>
<dd>
<p>Eigenvalues with smallest magnitude (sym, non sym), that is, smallest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt>
<code>"LR"</code>:</dt>
<dd>
<p>Eigenvalues with largest real part (non sym).</p>
</dd>
<dt>
<code>"SR"</code>:</dt>
<dd>
<p>Eigenvalues with smallest real part (non sym).</p>
</dd>
<dt>
<code>"LI"</code>:</dt>
<dd>
<p>Eigenvalues with largest imaginary part (non sym).</p>
</dd>
<dt>
<code>"SI"</code>:</dt>
<dd>
<p>Eigenvalues with smallest imaginary part (non sym).</p>
</dd>
<dt>
<code>"LA"</code>:</dt>
<dd>
<p>Eigenvalues with largest algebraic value (sym), that is, largest eigenvalues inclusive of any negative sign.</p>
</dd>
<dt>
<code>"SA"</code>:</dt>
<dd>
<p>Eigenvalues with smallest algebraic value (syn), that is, smallest eigenvalues inclusive of any negative sign.</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dt>
<code>ncv</code>:</dt>
<dd>
<p>the largest number of basis vectors that will be used in the Implicitly Restarted Arnoldi Process.
Work per major iteration is proportional to x@dimension[1]*ncv*ncv.
The default is set if <code>symmetric</code> to min(x@dimension[1] + 1, max(2 * nev + 1, 200)) or else to min(x@dimension[1] - 1, max(2 * nev + 1, 100)).
Note, this value should not be chosen arbitrary large, but slightly larger than <code>nev</code>.
Otherwise it could lead to memory allocation problems.</p>
</dd>
<dt>
<code>nitr</code>:</dt>
<dd>
<p>the maximum number of iterations.
The default is set to <code>ncv + 1000</code></p>
</dd>
<dt>
<code>spamflag = FALSE</code>:</dt>
<dd>
<p>if TRUE, the Implicitly Restarted Arnoldi Process is used,
independent of the dimension of the respective matrix (provided matrix
is larger than 10x10).</p>
</dd>
<dt>
<code>verbose = FALSE</code>:</dt>
<dd>
<p>print additional information.</p>
</dd>
<dt>
<code>cmplxeps</code>:</dt>
<dd>
<p>threshold to determine whether a double value is zero, while transforming the ARPACK output to R class complex.
The default is set to <code>.Machine$double.eps</code>.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A vector of the length corresponding to the dimension of the input matrix.
Containing the required <code>nev</code> eigenvalues.
If requested also the corresponding eigenvectors.
In the non symmetric case, the eigenvalues are returned in a matrix with a column containing the real parts and a column containing the imaginary parts of the eigenvalues.
The eigenvectors are then returned in two matrices.</p>


<h3>Note</h3>

<p>The user is advised to choose the <code>control</code> options carefully, see ‘Details’ for more information.
</p>


<h3>Author(s)</h3>

<p>Roman Flury, Reinhard Furrer</p>


<h3>References</h3>

<p>Lehoucq, R. B. and Sorensen, D. C. and Yang, C. (1997) <em>ARPACK Users Guide: Solution of Large Scale Eigenvalue Problems by Implicitly Restarted Arnoldi Methods</em>.</p>


<h3>See Also</h3>

<p>Option <code>"inefficiencywarning"</code> in <code>spam.options</code> and <code>spam_random</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(81)
rspam &lt;- spam_random(42^2, density = .0001, spd = TRUE)
SPD &lt;- eigen.spam(rspam, nev = 18, control = list(mode = "SM"),
                  only.values = TRUE)

any(SPD$values &lt;= 0, na.rm = TRUE)
isSymmetric(rspam)
# hence the matrix is symmetric positiv definit

rspam2 &lt;- spam_random(50^2, density = .0001, spd = FALSE, sym = TRUE,
                      distribution = rpois, lambda = 2)
SNPD &lt;- eigen.spam(rspam2, nev = 18, control = list(mode = "SM"),
                    only.values = TRUE)

any(SNPD$values &lt;= 0, na.rm = TRUE)
isSymmetric(rspam2)
# hence the matrix is symmetric but not positiv definit
</code></pre>


</div>