<div class="container">

<table style="width: 100%;"><tr>
<td>smooth.construct.cv.smooth.spec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor for concave P-splines in SCAMs
</h2>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to concavity constraint which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using concave P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="cv",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>cvBy.smooth.spec</code> works similar to <code>cv.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>cvBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="cvBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="cv")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cv.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'cvBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"cv.smooth"</code>, <code>"cvBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code>smooth.construct.cx.smooth.spec</code>, 
<code>smooth.construct.mpi.smooth.spec</code>, 
</p>
<p><code>smooth.construct.mdcv.smooth.spec</code>, 
<code>smooth.construct.mdcx.smooth.spec</code>, 
</p>
<p><code>smooth.construct.micx.smooth.spec</code>, 
<code>smooth.construct.mpd.smooth.spec</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> ## Not run: 
## Concave P-splines example 
  ## simulating data...
   require(scam)
   set.seed(1)
   n &lt;- 100
   x &lt;- sort(2*runif(n)-1)
   f &lt;- -4*x^2
   y &lt;- f + rnorm(n)*0.45
   dat &lt;- data.frame(x=x,y=y)
   b &lt;- scam(y~s(x,k=15,bs="cv"),family=gaussian,data=dat,not.exp=FALSE)
   ## fit unconstrained model...
   b1 &lt;- scam(y~s(x,k=15,bs="cr"),family=gaussian, data=dat,not.exp=FALSE)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,f)      ## the true function
   lines(x,b$fitted,col=2)  ## constrained fit 
   lines(x,b1$fitted,col=3) ## unconstrained fit 

## Poisson version...
   y &lt;- rpois(n,15*exp(f))
   dat &lt;- data.frame(x=x,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="cv"),family=poisson(link="log"),data=dat,not.exp=FALSE)

   ## fit unconstrained model...
   b1&lt;-scam(y~s(x,k=15,bs="cr"),family=poisson(link="log"), data=dat,not.exp=FALSE)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,15*exp(f))      ## the true function
   lines(x,b$fitted,col=2)  ## constrained fit 
   lines(x,b1$fitted,col=3) ## unconstrained fit 

## plotting on log scale...
   plot(x,log(15*exp(f)),type="l",cex=.5)      ## the true function
   lines(x,log(b$fitted),col=2)  ## constrained fit 
   lines(x,log(b1$fitted),col=3) ## unconstrained fit 

## 'by' factor example... 
  set.seed(9)
  n &lt;- 400
  x &lt;- sort(runif(n,-.5,.5))
  f1 &lt;- -.7*x+cos(x)-3
  f2 &lt;- -20*x^2 
  par(mfrow=c(1,2))
  plot(x,f1,type="l");plot(x,f2,type="l")
  e &lt;- rnorm(n, 0, 1.5)
  fac &lt;- as.factor(sample(1:2,n,replace=TRUE))
  fac.1 &lt;- as.numeric(fac==1)
  fac.2 &lt;- as.numeric(fac==2)
  y &lt;- f1*fac.1 + f2*fac.2 + e 
  dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2)
  b2 &lt;- scam(y ~ fac+s(x,by=fac,bs="cv"),data=dat,optimizer="efs")  
  plot(b2,pages=1,scale=0,shade=TRUE)
  summary(b2)
  x11()
  vis.scam(b2,theta=50,color="terrain")

 ## numeric 'by' variable example... 
 set.seed(6)
 n &lt;- 100
 x &lt;- sort(2*runif(n)-1)
 z &lt;- runif(n,-2,3)
 f &lt;- -4*x^2
 y &lt;- f*z + rnorm(n)*0.6
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="cvBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
  
## End(Not run)
</code></pre>


</div>