<div class="container">

<table style="width: 100%;"><tr>
<td>selm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting linear models with skew-elliptical error term</h2>

<h3>Description</h3>

<p>Function <code>selm</code> fits a <code>l</code>inear <code>m</code>odel
with <code>s</code>kew-<code>e</code>lliptical error term. 
The term ‘skew-elliptical distribution’ is an abbreviated equivalent 
of skew-elliptically contoured (<abbr><span class="acronym">SEC</span></abbr>) distribution.
The function works for univariate and multivariate response variables.</p>


<h3>Usage</h3>

<pre><code class="language-R">selm(formula, family = "SN", data, weights, subset, na.action, 
  start = NULL, fixed.param = list(), method = "MLE",  penalty=NULL, 
  model = TRUE, x = FALSE, y = FALSE, contrasts = NULL, offset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>"formula"</code> 
(or one that can be coerced to that class): a symbolic description of the
model to be fitted, using the same syntax used for the similar parameter of
e.g. <code>"lm"</code>, with the restriction that the constant
term must not be removed from the linear predictor. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a character string which selects the parametric family
of <abbr><span class="acronym">SEC</span></abbr> type  assumed for the error term. It must be one of
<code>"SN"</code> (default), <code>"ST"</code> or <code>"SC"</code>, which correspond to the
skew-normal, the skew-<em>t</em> and the skew-Cauchy family, respectively.
See <code>makeSECdistr</code> for more information on these families and
the set of <abbr><span class="acronym">SEC</span></abbr> distributions; notice that the family <code>"ESN"</code> 
listed there is not allowed here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame  containing the variables in
the model.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>selm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numeric vector of weights associated to  individual
observations. Weights are supposed to represent frequencies, hence must be
non-negative integers (not all 0) and <code>length(weights)</code> must equal the
number of observations. If not assigned, a vector of all 1's is generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process. It works like the same parameter
in <code>lm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by the
<code>na.action</code> setting of <code>options</code>.  
The ‘factory-fresh’ default is <code>na.omit</code>.  
Another possible value is <code>NULL</code>, no action.  

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a vector (in the univariate case) or a list (in the  
multivariate case) of initial <abbr><span class="acronym">DP</span></abbr> values for searching the 
parameter estimates. See ‘Details’ about a choice of
<kbd>start</kbd> to be avoided.  If <code>start=NULL</code> (default), 
initial values are  selected by the procedure.
If <code>family="ST"</code>, an additional option exists; see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.param</code></td>
<td>
<p>a list of assignments of parameter values which must
be kept fixed in the estimation process. 
Currently, there only two types of admissible constraint: one is to
set <code>alpha=0</code> to impose a symmetry condition of the distribution; 
the other is to set <code>nu=&lt;value&gt;</code>, to fix the degrees of freedom  
at the named <code>&lt;value&gt;</code> when <code>family="ST"</code>, for instance
<code>list(nu=3)</code>.  See ‘Details’ for additional information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string which selects the estimation method to be
used for fitting. Currently, two options exist: <code>"MLE"</code> (default) and
<code>"MPLE"</code>, corresponding to standard maximum likelihood and maximum
penalized likelihood estimation, respectively. See ‘Details’ for
additional information.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>a character string which denotes the penalty function to be
subtracted to the log-likelihood function, when <code>method="MPLE"</code>; if
<code>penalty=NULL</code> (default), a pre-defined function is adopted. See
‘Details’ for a description of the default penalty function and for
the expected format of alternative specifications.  When
<code>method="MLE"</code>, no penalization is applied and this argument has no
effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, x, y</code></td>
<td>
<p>logicals.  If <code>TRUE</code>, the corresponding components
of the fit are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the number of
cases.  One or more <code>offset</code> terms can be included in the
formula instead or as well, and if more than one are specified their sum 
is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional control parameters, as follows.
</p>

<ul>
<li> <p><code>trace</code>: a logical value which indicates whether intermediate
evaluations of the optimization process are printed (default:
<code>FALSE</code>).
</p>
</li>
<li> <p><code>info.type</code>: a character string which indicates the type of
Fisher information matrix; possible values are <code>"observed"</code>
(default) and <code>"expected"</code>. Currently, <code>"expected"</code> is
implemented only for the <abbr><span class="acronym">SN</span></abbr> family.
</p>
</li>
<li> <p><code>opt.method</code>: a character string which selects the numerical
optimization method, among the possible values 
<code>"nlminb", "Nelder-Mead", "BFGS", "CG", "SANN"</code>. 
If <code>opt.method="nlminb"</code> (default),
function <code>nlminb</code> is called, 
otherwise function <code>optim</code> is called with 
<code>method</code> equal to <code>opt.method</code>.
</p>
</li>
<li> <p><code>opt.control</code>: a list of control parameters which is passed on
either to <code>nlminb</code> or to <code>optim</code>, depending on the chosen
<code>opt.method</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, <code>selm</code> fits the selected model by maximum
likelihood estimation (<abbr><span class="acronym">MLE</span></abbr>), making use of some numerical
optimization method.  Maximization is performed in one
parameterization, usually <abbr><span class="acronym">DP</span></abbr>, and then the estimates are mapped to
other parameter sets, <abbr><span class="acronym">CP</span></abbr> and pseudo-<abbr><span class="acronym">CP</span></abbr>; 
see <code>dp2cp</code> for more information on parameterizations. 
These parameter transformations are carried out trasparently to the user. 
The observed information matrix is used to obtain the estimated variance 
matrix of the <abbr><span class="acronym">MLE</span></abbr>'s and from this the standard errors.  
Background information on <abbr><span class="acronym">MLE</span></abbr> in the context of <abbr><span class="acronym">SEC</span></abbr> 
distributions is provided by Azzalini and Capitanio (2014); 
see specifically Chapter 3, Sections 4.3, 5.2,  6.2.5–6. For additional
information, see the original research work referenced therein as well as
the sources quoted below.
</p>
<p>Although the density functionof SEC distributions are expressed using
<abbr><span class="acronym">DP</span></abbr> parameter sets, the methods associated to the objects created
by this function communicate, by default, their outcomes in the <abbr><span class="acronym">CP</span></abbr>
parameter set, or its variant form pseudo-<abbr><span class="acronym">CP</span></abbr> when <abbr><span class="acronym">CP</span></abbr>
does not exist; the ‘Note’ at <code>summary.selm</code> explains why. 
A more detailed discussion  is provided by Azzalini and Capitanio 
(1999,  Section 5.2) and Arellano-Valle and  Azzalini (2008, Section 4), 
for the univariate and the multivariate SN case, respectively; 
an abriged account is available in Sections 3.1.4–6 and 5.2.3 of 
Azzalini and Capitanio (2014). For the ST case, see Arellano-Valle 
and  Azzalini (2013).
</p>
<p>There is a known open issue which affects computation of the information
matrix of the multivariate skew-normal distribution when the slant
parameter <code class="reqn">\alpha</code> approaches the null vector; see p.149 of
Azzalini and Capitanio (2014). Consequently, if a model with
multivariate response is fitted with <code>family="SN"</code> and the estimate
<code>alpha</code> of <code class="reqn">\alpha</code> is at the origin or neary so, the
information matrix and the standard errors are not computed and a
warning message is issued. In this unusual circumstance, a simple
work-around is to re-fit the model with <code>family="ST"</code>, which will
work except in remote cases when (i) the estimated degrees of freedom
<code>nu</code> diverge and (ii) still <code>alpha</code> remains at the origin.
</p>
<p>The optional argument <code>fixed.param=list(alpha=0)</code> imposes the
constraint <code class="reqn">\alpha=0</code> in the estimation process; in the multivariate 
case, the expression is interpreted in the sense that all the components  
of vector <code class="reqn">\alpha</code> are zero, which implies symmetry of the
error distribution, irrespectively of the parameterization 
subsequently adopted for summaries and diagnostics.
When this restriction is selected, the estimation method cannot be
set to <code>"MPLE"</code>. Under the constraint <code class="reqn">\alpha=0</code>,
if <code>family="SN"</code>, the model is  fitted similarly to <code>lm</code>, except
that here <abbr><span class="acronym">MLE</span></abbr> is used for estimation of the covariance matrix. 
If <code>family="ST"</code> or <code>family="SC"</code>, a symmetric Student's <code class="reqn">t</code> 
or Cauchy distribution is adopted. 
</p>
<p>Under the constraint <code class="reqn">\alpha=0</code>, the location parameter <code class="reqn">\xi</code>
coincides with the mode and the mean of the distribution, when the latter
exists. In addition, when the covariance matrix of a <abbr><span class="acronym">ST</span></abbr>
distribution exists, it differs from <code class="reqn">\Omega</code> only by a multiplicative
factor. Consequently, the summaries of a model of this sort automatically
adopt the <abbr><span class="acronym">DP</span></abbr> parametrization.
</p>
<p>The other possible form of constraint allows to fix the degrees of
freedom when <code>family="ST"</code>. The two constraints can be combined 
writing, for instance,  <code>fixed.param=list(alpha=0, nu=6)</code>.
The constraint <code>nu=1</code> is equivalent to select <code>family="SC"</code>.
In practice, an expression of type <code>fixed.param=list(..)</code> can be
abbreviated to <code>fixed=list(..)</code>.
</p>
<p>Argument <kbd>start</kbd> allows to set the initial values, with respect to the
<abbr><span class="acronym">DP</span></abbr> parameterization, of the numerical optimization. 
However, there is a specific choice of start to be avoided.
When <kbd>family="SN"</kbd>, do not set the shape parameter <kbd>alpha</kbd> 
exactly at 0, as this would blow-up computation of the log-likelihood 
gradient and the Hessian matrix. This is not due to a software bug, 
but to a known peculiar behaviour of the log-likelihood  function at 
that specific point. Therefore, in the univariate case for instance, 
do not set e.g. <kbd>start=c(12, 21, 0)</kbd>, but set instead something
like <kbd>start=c(12, 21, 0.01)</kbd>. 




Recall that, if one needs to fit a model forcing 0 asymmetry, typically to
compare two log-likelihood functions with/without asymmetry, then the option
to use is <kbd>fixed.param=list(alpha=0)</kbd>.
</p>
<p>Since version 1.6.0, a new initialization procedure has been introduced
for the case <kbd>family="ST"</kbd>, which adopts the method proposed by 
Azzalini &amp; Salehi (2020), implemented in functions <kbd>st.prelimFit</kbd> 
and <kbd>mst.prelimFit</kbd>.
Correspondingly, the <kbd>start</kbd> argument can now be of different type,
namely a character with possible values <kbd>"M0"</kbd>, <kbd>"M2"</kbd> (detault in 
the univariate case) and <kbd>"M3"</kbd> (detault in the multivariate case).
The choice <kbd>"M0"</kbd> selects the older method, in use prior to version
1.6.0. For more information, see Azzalini &amp;  Salehi (2020).
</p>
<p>In some cases, especially for small sample size, the <abbr><span class="acronym">MLE</span></abbr> occurs on
the frontier of the parameter space, leading to <abbr><span class="acronym">DP</span></abbr> estimates with
<code>abs(alpha)=Inf</code> or to a similar situation in the multivariate case 
or in an alternative parameterization. Such outcome is regared by many as
unsatisfactory; surely it prevents using the observed information matrix to
compute standard errors. This problem motivates the use of maximum penalized
likelihood estimation (<abbr><span class="acronym">MPLE</span></abbr>), where the regular log-likelihood
function <code class="reqn">\log~L</code> is penalized by subtracting an amount
<code class="reqn">Q</code>, say, increasingly large as <code class="reqn">|\alpha|</code> increases. 
Hence the function which is maximized at the optimization stage is now
<code class="reqn">\log\,L~-~Q</code>.  If <code>method="MPLE"</code> and
<code>penalty=NULL</code>, the default function <code>Qpenalty</code> is used,
which implements the penalization:
</p>
<p style="text-align: center;"><code class="reqn">Q(\alpha) = c_1 \log(1 + c_2 \alpha_*^2)</code>
</p>

<p>where <code class="reqn">c_1</code> and <code class="reqn">c_2</code> are positive constants, which
depend on the degrees of freedom <code>nu</code> in the <code>ST</code> case,
</p>
<p style="text-align: center;"><code class="reqn">\alpha_*^2 = \alpha^\top \bar\Omega \alpha</code>
</p>

<p>and <code class="reqn">\bar\Omega</code> denotes the correlation matrix 
associated to the scale matrix <code>Omega</code> described in connection with
<code>makeSECdistr</code>. In the univariate case 
<code class="reqn">\bar\Omega=1</code>,
so that <code class="reqn">\alpha_*^2=\alpha^2</code>. Further information 
on <abbr><span class="acronym">MPLE</span></abbr> and this choice of the penalty function is given in 
Section 3.1.8 and p.111 of Azzalini and Capitanio (2014); for a more 
detailed account, see Azzalini and Arellano-Valle (2013) and references  
therein.
</p>
<p>It is possible to change the penalty function, to be declared via the 
argument <code>penalty</code>. For instance, if the calling statement includes 
<code>penalty="anotherQ"</code>, the user must have defined  
</p>
<p><code style="white-space: pre;">⁠    ⁠</code><code>anotherQ &lt;- function(alpha_etc, nu = NULL, der = 0)</code>
</p>
<p>with the following arguments.
</p>

<ul>
<li> <p><code>alpha_etc</code>: in the univariate case, a single value <code>alpha</code>;
in the multivariate case, a two-component list whose first component is
the vector <code>alpha</code>, the second one is matrix equal to
<code>cov2cor(Omega)</code>.

</p>
</li>
<li> <p><code>nu</code>: degrees of freedom, only relevant if <code>family="ST"</code>.
</p>
</li>
<li> <p><code>der</code>: a numeric value which indicates the required order of
derivation; if <code>der=0</code> (default value), only the penalty <code>Q</code>
needs to be retuned by the function; 
if <code>der=1</code>, <code>attr(Q, "der1")</code> must represent the
first order derivative of <code>Q</code> with respect to <code>alpha</code>; if
<code>der=2</code>, also <code>attr(Q, "der2")</code> must be assigned, containing
the second derivative (only required in the univariate case).
</p>
</li>
</ul>
<p>This function must return a single numeric value, possibly with required
attributes when is called with <code>der&gt;1</code>.
Since <span class="pkg">sn</span> imports functions <code>grad</code> and 
<code>hessian</code> from package <span class="pkg">numDeriv</span>, one can rely 
on them for numerical evaluation of the derivatives, if they are not 
available in an explicit form.
</p>
<p>This penalization scheme allows to introduce a prior distribution 
<code class="reqn">\pi</code> for <code class="reqn">\alpha</code> by setting <code class="reqn">Q=-\log\pi</code>, 
leading to a maximum <em>a posteriori</em> estimate in the stated sense. 
See <code>Qpenalty</code> for more information and an illustration.
</p>
<p>The actual computations are not performed within <code>selm</code> which only 
sets-up ingredients for work of <code>selm.fit</code> and other functions
further below this one.  See <code>selm.fit</code> for more information.
</p>


<h3>Value</h3>

<p>an S4 object of class <code>selm</code> or <code>mselm</code>, depending on whether
the response variable of the fitted model is univariate or multivariate;
these objects are described in the <code>selm class</code>.
</p>


<h3>Cautionary notes</h3>

<p>The first of these notes applies to the stage <em>preceding</em> the
use of <kbd>selm</kbd> and related fitting procedures. Before fitting a model of
this sort, consider whether you have enough data for this task. 
In this respect, the passage below taken from p.63 of Azzalini 
and Capitanio (2014) is relevant.
</p>
<p>“Before entering technical aspects, it is advisable to underline 
a qualitative effect of working with a parametric family which effectively 
is regulated by moments up to the third order. 
The implication is that the traditional rule of thumb by which a sample 
size is small up to ‘about <code class="reqn">n = 30</code>’, and then starts to become ‘large’,
while sensible for a normal population or other two-parameter distribution, 
is not really appropriate here. 
To give an indication of a new threshold is especially difficult, 
because the value of  <code class="reqn">\alpha</code> also has a role here. 
Under this <em>caveat</em>, numerical experience suggests that ‘about 
<code class="reqn">n = 50</code>’ may be a more appropriate guideline in this context.”
</p>
<p>The above passage referred to the univariate SN context. 
In the multivariate case, increase the sample size appropriately, 
especially so with the <abbr><span class="acronym">ST</span></abbr> family.
This is not to say that one cannot attempt fitting these models 
with small or moderate sample size. However, one must be aware of the 
implications and not be surprised if problems appear.
</p>
<p>The second cautionary note refers instead to the outcome of a call to 
<kbd>selm</kbd> and related function, or the lack of it.
The estimates are obtained by numerical optimization methods and, as
usual in similar cases, there is no guarantee that the maximum of the
objective function is achieved. Consideration of model simplicity
and of numerical experience indicate that models with <abbr><span class="acronym">SN</span></abbr> error
terms generally produce more reliable results compared to those with 
the <abbr><span class="acronym">ST</span></abbr> family. Take into account that models involving a 
traditional Student's <code class="reqn">t</code> distribution with unknown degrees of freedom 
can already be problematic; the presence of the (multivariate) slant parameter
<code class="reqn">\alpha</code> in the <abbr><span class="acronym">ST</span></abbr> family cannot make things any simpler. 
Consequently, care must be exercised, especially so if one works with 
the (multivariate) <abbr><span class="acronym">ST</span></abbr> family. 
Consider re-fitting a model with different starting values and, 
in the <abbr><span class="acronym">ST</span></abbr> case, building the profile log-likelihood for a range 
of <code class="reqn">\nu</code> values; function <code>profile.selm</code> can be useful here.
</p>
<p>Details on the numerical optimization which has produced object <code>obj</code> 
can be extracted with <code>slot(obj, "opt.method")</code>; inspection of this
component can be useful in problematic cases.
# Be aware that  occasionally <code>optim</code> and <code>nlminb</code> declare successful
# completion of a regular minimization problem at a point where the Hessian 
# matrix is not positive-definite. 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B., and Azzalini, A. (2008).
The centred parametrization for the multivariate skew-normal distribution.
<em>J. Multiv. Anal.</em> <b>99</b>, 1362–1382.
Corrigendum: <b>100</b> (2009), 816.
</p>
<p>Arellano-Valle, R. B., and Azzalini, A. (2013, available online 12 June 2011).
The centred parametrization and related quantities for the  skew-<em>t</em> 
distribution.
<em>J. Multiv. Anal.</em> <b>113</b>, 73–90. 
</p>
<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579–602. 
Full-length version available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. and Arellano-Valle, R. B. (2013, available online 30 June 2012). 
Maximum penalized likelihood estimation for skew-normal and skew-<em>t</em> 
distributions. <em>J. Stat. Planning &amp; Inference</em> <b>143</b>, 419–433. 
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Azzalini, A. and Salehi, M. (2020).
Some computational aspects of maximum likelihood estimation 
of the skew-<em>t</em> distribution. In <em>Computational and Methodological 
Statistics and Biostatistics</em>, edited by A. Bekker, Ding-Geng Chen and 
Johannes T. Ferreira, pp.3-28.  Springer Nature Switzerland.
</p>



<h3>See Also</h3>


<ul>
<li>
<p><code>selm-class</code> for classes <code>"selm"</code> and <code>"mselm"</code>,
<code>summary.selm</code> for summaries, <code>plot.selm</code> for plots,
<code>residuals.selm</code> for residuals and fitted values
</p>
</li>
<li>
<p>the generic functions <code>coef</code>, <code>logLik</code>, 
<code>vcov</code>, <code>profile</code>, <code>confint</code>, 
<code>predict</code>
</p>
</li>
<li>
<p>the underlying function <code>selm.fit</code> and those further down
</p>
</li>
<li>
<p>the selection of a penalty function of the log-likelihood, 
such as <code>Qpenalty</code>
</p>
</li>
<li>
<p>the function <code>extractSECdistr</code> to extract the <abbr><span class="acronym">SEC</span></abbr>
error distribution from an object returned by <code>selm</code> 
</p>
</li>
<li>
<p> the broad underlying logic and a number of ingredients are like in 
function <code>lm</code>  
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">data(ais)
m1 &lt;- selm(log(Fe) ~ BMI + LBM, family="SN", data=ais)
print(m1)
summary(m1)
s &lt;- summary(m1, "DP", cov=TRUE, cor=TRUE)
plot(m1)
plot(m1, param.type="DP")
logLik(m1)
coef(m1)
coef(m1, "DP")
var &lt;- vcov(m1)
#
m1a &lt;- selm(log(Fe) ~ BMI + LBM, family="SN", method="MPLE", data=ais)
m1b &lt;- selm(log(Fe) ~ BMI + LBM, family="ST", fixed.param=list(nu=8), data=ais)
#
data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75],10) 
m &lt;- selm(logPrice ~ 1, family="ST", opt.method="Nelder-Mead")
summary(m)
summary(m, "DP")
plot(m, which=2, col=4, main="Barolo log10(price)")
# cfr Figure 4.7 of Azzalini &amp; Capitanio (2014), p.107
detach(barolo)
#-----
# examples with multivariate response
#
m3 &lt;- selm(cbind(BMI, LBM) ~ WCC + RCC, family="SN", data=ais)
plot(m3, col=2, which=2)
summary(m3, "dp")
coef(m3)
coef(m3, vector=FALSE)
#
data(wines)
m28 &lt;- selm(cbind(chloride, glycerol, magnesium) ~ 1, family="ST", data=wines)
dp28 &lt;- coef(m28, "DP", vector=FALSE) 
pcp28 &lt;- coef(m28, "pseudo-CP", vector=FALSE) 
# the next statement takes a little more time than others
plot(m28)

#
m4 &lt;- selm(cbind(alcohol,sugar)~1, family="ST", data=wines)
m5 &lt;- selm(cbind(alcohol,sugar)~1, family="ST", data=wines, fixed=list(alpha=0))
print(1 - pchisq(2*as.numeric(logLik(m4)-logLik(m5)), 2)) # test for symmetry
</code></pre>


</div>