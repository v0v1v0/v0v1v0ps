<div class="container">

<table style="width: 100%;"><tr>
<td>dcovICA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
ICA via distance covariance for 2 components</h2>

<h3>Description</h3>

<p>This algorithm finds the rotation which minimizes the distance covariance between two orthogonal components via the angular parameterization of a 2x2 orthogonal matrix with the function stats::optimize. The results will be (approximately)
equivalent to steadyICA but this function is much faster (but does not extend to higher dimensions).</p>


<h3>Usage</h3>

<pre><code class="language-R">dcovICA(Z, theta.0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The whitened n x d data matrix, where n is the number of observations and d the number of components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.0</code></td>
<td>
<p>Determines the interval to be searched by the optimizer: lower bound = theta.0, upper
bound = pi/2. Changing theta.0 affects the initial value,
where the initial value = theta.0+(1/2+sqrt(5)/2)*pi/2, see optimize.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta.hat</code></td>
<td>
<p>Estimated minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>W = t(theta2W(theta.hat))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Estimated independent components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>The distance covariance of S.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>David Matteson and Benjamin Risk
</p>


<h3>References</h3>

<p>Matteson, D. S. &amp; Tsay, R. Independent component analysis via U-Statistics. 
&lt;http://www.stat.cornell.edu/~matteson/#ICA&gt;
</p>


<h3>See Also</h3>

<p><code>steadyICA</code>,
<code>optimize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(JADE)
library(ProDenICA)
set.seed(123)
simS = cbind(rjordan(letter='j',n=1024),rjordan(letter='m',n=1024))
simM = mixmat(p=2)
xData = simS%*%simM
xWhitened = whitener(xData)

#Define true unmixing matrix as true M multiplied by the estimated whitener:
#Call this the target matrix:
W.true &lt;- solve(simM%*%xWhitened$whitener) 


a=Sys.time()
est.dCovICA = dcovICA(Z = xWhitened$Z,theta.0=0)
Sys.time()-a

#See the example with steadyICA for an explanation
#of the parameterization used in amari.error:
amari.error(t(est.dCovICA$W),W.true)

##NOTE: also try theta.0 = pi/4 since there may be local minima
  ## Not run: est.dcovICA = dcovICA(Z = xWhitened$Z,theta.0=pi/4)
  amari.error(t(est.dcovICA$W),W.true)
## End(Not run)

a=Sys.time()
est.steadyICA = steadyICA(X=xWhitened$Z,verbose=TRUE)
Sys.time()-a
amari.error(t(est.steadyICA$W),W.true)
##theta parameterization with optimize is much faster
</code></pre>


</div>