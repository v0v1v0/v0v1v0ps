<div class="container">

<table style="width: 100%;"><tr>
<td>lagmess</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix exponential spatial lag model</h2>

<h3>Description</h3>

<p>The function fits a matrix exponential spatial lag model, using <code>optim</code> to find the value of <code>alpha</code>, the spatial coefficient.</p>


<h3>Usage</h3>

<pre><code class="language-R">lagmess(formula, data = list(), listw, zero.policy = NULL, na.action = na.fail,
 q = 10, start = -2.5, control=list(), method="BFGS", verbose=NULL,
 use_expm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit. The details 
of model specification are given for <code>lm()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment which the function 
is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>spdep::nb2listw()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE assign NA - causing <code>lagmess()</code> to terminate with an error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function (default <code>options("na.action")</code>), can also be <code>na.omit</code> or <code>na.exclude</code> with consequences for residuals and fitted values - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>default 10; number of powers of the spatial weights to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting value for numerical optimization, should be a small negative number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control parameters passed to <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>default <code>BFGS</code>, method passed to <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>default NULL, use global option value; if TRUE report function values during optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_expm</code></td>
<td>
<p>default FALSE; if TRUE use <code>expm::expAtv</code> instead of a truncated power series of W</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The underlying spatial lag model:
</p>
<p style="text-align: center;"><code class="reqn">y = \rho W y + X \beta + \varepsilon</code>
</p>

<p>where <code class="reqn">\rho</code> is the spatial parameter may be fitted by maximum likelihood. In that case, the log likelihood function includes the logarithm of cumbersome Jacobian term <code class="reqn">|I - \rho W|</code>. If we rewrite the model as:
</p>
<p style="text-align: center;"><code class="reqn">S y = X \beta + \varepsilon</code>
</p>

<p>we see that in the ML case <code class="reqn">S y = (I - \rho W) y</code>. If W is row-stochastic, S may be expressed as a linear combination of row-stochastic matrices. By pre-computing the matrix <code class="reqn">[y, Wy, W^2y, ..., W^{q-1}y]</code>, the term <code class="reqn">S y (\alpha)</code> can readily be found by numerical optimization using the matrix exponential approach. <code class="reqn">\alpha</code> and <code class="reqn">\rho</code> are related as <code class="reqn">\rho = 1 - \exp{\alpha}</code>, conditional on the number of matrix power terms taken <code>q</code>.</p>


<h3>Value</h3>

<p>The function returns an object of class <code>Lagmess</code> with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lmobj</code></td>
<td>
<p>the <code>lm</code> object returned after fitting <code>alpha</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the spatial coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphase</code></td>
<td>
<p>the standard error of the spatial coefficient using the numerical Hessian</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the value of <code>rho</code> implied by <code>alpha</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestmess</code></td>
<td>
<p>the object returned by <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>the number of powers of the spatial weights used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>the starting value for numerical optimization used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>(possibly) named vector of excluded or omitted observations if non-default na.action argument used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullLL</code></td>
<td>
<p>the log likelihood of the aspatial model for the same data</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Eric Blankmeyer</p>


<h3>References</h3>

<p>J. P. LeSage and R. K. Pace (2007) A matrix exponential specification. Journal of Econometrics, 140, 190-214; J. P. LeSage and R. K. Pace (2009) Introduction to Spatial Econometrics. CRC Press, Chapter 9.</p>


<h3>See Also</h3>

<p><code>lagsarlm</code>, <code>optim</code></p>


<h3>Examples</h3>

<pre><code class="language-R">#require(spdep, quietly=TRUE)
data(baltimore, package="spData")
baltimore$AGE &lt;- ifelse(baltimore$AGE &lt; 1, 1, baltimore$AGE)
lw &lt;- spdep::nb2listw(spdep::knn2nb(spdep::knearneigh(cbind(baltimore$X, baltimore$Y), k=7)))
obj1 &lt;- lm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT),
 data=baltimore)
spdep::lm.morantest(obj1, lw)
spdep::lm.LMtests(obj1, lw, test="all")
system.time(obj2 &lt;- lagmess(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw))
(x &lt;- summary(obj2))
coef(x)
has_expm &lt;- require("expm", quietly=TRUE)
if (has_expm) {
system.time(
obj2a &lt;- lagmess(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw, use_expm=TRUE)
)
summary(obj2a)
}
obj3 &lt;- lagsarlm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw)
summary(obj3)

data(boston, package="spData")
lw &lt;- spdep::nb2listw(boston.soi)
gp2 &lt;- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)
 +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
 data=boston.c, lw, method="Matrix")
summary(gp2)
gp2a &lt;- lagmess(CMEDV ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)
 +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),
 data=boston.c, lw)
summary(gp2a)

</code></pre>


</div>