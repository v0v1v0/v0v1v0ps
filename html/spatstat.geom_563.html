<div class="container">

<table style="width: 100%;"><tr>
<td>matchingdist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance for a Point Pattern Matching</h2>

<h3>Description</h3>

<p>Computes the distance associated with a matching between two point patterns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  matchingdist(matching, type = NULL, cutoff = NULL, q = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>matching</code></td>
<td>
<p>A point pattern matching (an object of class <code>"pppmatching"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>A character string giving the type of distance to be computed.
One of <code>"spa"</code>, <code>"ace"</code> or <code>"mat"</code>. See details below. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>

<p>The value <code class="reqn">&gt; 0</code> at which interpoint distances are cut off.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>

<p>The order of the average that is applied to the interpoint distances.
May be <code>Inf</code>, in which case the maximum of the interpoint distances is taken.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the distance specified by <code>type</code>, <code>cutoff</code>, and <code>order</code>
for a point matching. If any of these arguments are not provided, the function
uses the corresponding elements of <code>matching</code> (if available).
</p>
<p>For the type <code>"spa"</code> (subpattern assignment) it is assumed that the points
of the point pattern with the smaller cardinality <code class="reqn">m</code> are matched to a
<code class="reqn">m</code>-point subpattern of the point pattern with the larger
cardinality <code class="reqn">n</code> in a 1-1 way. The distance
is then given as the <code>q</code>-th order average of the <code class="reqn">m</code> distances between
matched points (minimum of Euclidean distance and <code>cutoff</code>)
and <code class="reqn">n-m</code> "penalty distances" of value <code>cutoff</code>.
</p>
<p>For the type <code>"ace"</code> (assignment only if cardinalities equal) the matching
is assumed to be 1-1 if the cardinalities of the point patterns are
the same, in which case the <code>q</code>-th order average of the matching distances
(minimum of Euclidean distance and <code>cutoff</code>) is taken. If the cardinalities
are different, the matching may be arbitrary and the distance returned is always
equal to <code>cutoff</code>.
</p>
<p>For the type <code>mat</code> (mass transfer) it is assumed that each point of
the point pattern with the smaller cardinality <code class="reqn">m</code> has mass <code class="reqn">1</code>,
each point of the point pattern with the larger cardinality <code class="reqn">n</code>
has mass <code class="reqn">m/n</code>,
and fractions of these masses are matched in such a way that each point
contributes exactly its mass. The distance is then given as the <code>q</code>-th
order weighted average of all distances (minimum of Euclidean distance
and <code>cutoff</code>) of (partially) matched points with weights equal to the
fractional masses divided by <code class="reqn">m</code>.
</p>
<p>If the cardinalities of the two point patterns are equal,
<code>matchingdist(m, type, cutoff, q)</code> yields the same result
no matter if <code>type</code> is <code>"spa"</code>, <code>"ace"</code> or
<code>"mat"</code>.
</p>


<h3>Value</h3>

<p>Numeric value of the distance associated with the matching.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>, URL <code>http://dominic.schuhmacher.name/</code>.
</p>


<h3>See Also</h3>

<p><code>pppdist</code>
<code>pppmatching.object</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # an optimal matching
  X &lt;- runifrect(20)
  Y &lt;- runifrect(20)
  m.opt &lt;- pppdist(X, Y)
  summary(m.opt)
  matchingdist(m.opt)
       # is the same as the distance given by summary(m.opt)
  
  # sequential nearest neighbour matching
  # (go through all points of point pattern X in sequence
  # and match each point with the closest point of Y that is
  # still unmatched)
  am &lt;- matrix(0, 20, 20)
  h &lt;- matrix(c(1:20, rep(0,20)), 20, 2)
  h[1,2] = nncross(X[1],Y)[1,2]
  for (i in 2:20) {
    nn &lt;- nncross(X[i],Y[-h[1:(i-1),2]])[1,2]
    h[i,2] &lt;- ((1:20)[-h[1:(i-1),2]])[nn]
  }
  am[h] &lt;- 1
  m.nn &lt;- pppmatching(X, Y, am)
  matchingdist(m.nn, type="spa", cutoff=1, q=1)
       # is &gt;= the distance obtained for m.opt
       # in most cases strictly &gt;

  opa &lt;- par(mfrow=c(1,2))
  plot(m.opt, main="optimal")
  plot(m.nn,  main="nearest neighbour")
  text(X, 1:20, pos=1, offset=0.3, cex=0.8)
  par(opa)
</code></pre>


</div>