<div class="container">

<table style="width: 100%;"><tr>
<td>iterateHydOrder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iteratively Attempt Hydrologic Ordering of Geomorphic Proportion Matrix</h2>

<h3>Description</h3>

<p>Iteratively Attempt Hydrologic Ordering of Geomorphic Proportion Matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">iterateHydOrder(
  x,
  g,
  target = 0.9,
  maxIter = 20,
  j.amount = 0.05,
  verbose = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>data.frame</code> geomorphic proportion matrix, as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>name of geomorphic summary table, one of: <code>c('geomcomp', 'hillpos', 'flats', 'terrace', 'mtnpos', 'shape')</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>numeric, target match rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>integer, maximum number of perturbations of geomorphic probability matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j.amount</code></td>
<td>
<p>numeric, amount of noise applied to rows with too few unique values, passed to <code>jitter()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, additional output printed via message</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical, additional list of results for each iteration</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is used by the suite of geomorphic proportion visualization functions (<code style="white-space: pre;">⁠viz*⁠</code>) to attempt rotation of a dendrogram according to "hydrologic ordering" rules. A perfect rotation is not always possible, and reported as a match rate in the returned <code>score</code> value
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>clust</code>: rotated <code>hclust</code> object
</p>
</li>
<li> <p><code>hyd.order</code>: vector of series names, in hydrologic ordering
</p>
</li>
<li> <p><code>clust.hyd.order</code>: vector of series names, after clustering + rotation, approximate hydrologic ordering
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li>
<li> <p><code>obj</code>: objective function value (sum of squared rank differences), used by <code>iterateHydOrder()</code>
</p>
</li>
<li> <p><code>niter</code>: number of iterations
</p>
</li>
<li> <p><code>trace</code>: list of results by iteration, only when <code>trace = TRUE</code>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example data, similar to results from soilDB::fetchOSD(..., extended = TRUE)
data("OSDexamples")

# single iteration of hydrologic ordering
h1 &lt;- hydOrder(OSDexamples$hillpos, g = 'hillpos', clust = TRUE)

# perform several iterations, keep the best one
h2 &lt;- iterateHydOrder(OSDexamples$hillpos, 'hillpos', verbose = TRUE)

# compare: only slightly better match rate achieved
h1$match.rate
h2$match.rate

# return trace log for eval of objective function
# increase max iterations
h2 &lt;- iterateHydOrder(OSDexamples$hillpos, 'hillpos', maxIter = 100, verbose = TRUE, trace = TRUE)

# inspect objective function evolution
tr &lt;- h2$trace
obj &lt;- sapply(tr, '[[', 'obj')

plot(obj, type = 'b')
hist(obj)

# in this case the clustering of hillpos proportions has only two possible configurations

</code></pre>


</div>