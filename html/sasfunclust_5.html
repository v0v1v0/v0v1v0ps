<div class="container">

<table style="width: 100%;"><tr>
<td>sasfclust_cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for sasfclust</h2>

<h3>Description</h3>

<p>K-fold cross-validation procedure to choose the number of clusters and the tuning parameters for the sparse and smooth functional clustering (SaS-Funclust) method (Centofanti et al., 2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sasfclust_cv(
  X = NULL,
  timeindex = NULL,
  curve = NULL,
  grid = NULL,
  q = 30,
  lambda_l_seq = 10^seq(-1, 2),
  lambda_s_seq = 10^seq(-5, -3),
  G_seq = 2,
  tol = 10^-7,
  maxit = 50,
  par_LQA = list(eps_diff = 1e-06, MAX_iter_LQA = 200, eps_LQA = 1e-05),
  plot = FALSE,
  trace = FALSE,
  init = "kmeans",
  varcon = "diagonal",
  lambda_s_ini = NULL,
  K_fold = 5,
  X_test = NULL,
  grid_test = NULL,
  m1 = 1,
  m2 = 0,
  m3 = 1,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For functional data observed over a regular grid: a matrix of where  the rows must correspond to argument values and columns to replications.
For functional data observed over an irregular grid:  a vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>, with <code class="reqn">N</code>  the number of curves,
where the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are elements representing the observations for curve <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeindex</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> provide the locations on <code>grid</code> of curve  <code class="reqn">k</code>.
So for example, if the <code class="reqn">k</code>th curve is observed at time points <code class="reqn">t_l,t_m</code> of the <code>grid</code> then the the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> would be <code class="reqn">l,m</code>, being <code class="reqn">n_k=2</code>.
If X is a matrix, timeindex is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>curve</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are equal to  <code class="reqn">k</code>.
If X is a matrix, curve is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>The vector of time points where the curves are sampled.
For Functional data observed over an irregular grid, <code>timeindex</code> and <code>grid</code> provide the time points for each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The dimension of the set of B-spline functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_l_seq</code></td>
<td>
<p>Sequence of tuning parameter of the functional adaptive pairwise fusion penalty (FAPFP).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_s_seq</code></td>
<td>
<p>Sequence of tuning parameter of the smoothness penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G_seq</code></td>
<td>
<p>Sequence of number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance for the stopping condition of the expectation conditional maximization (ECM) algorithms.
The algorithm stops when the log-likelihood difference between two consecutive iterations is less or equal than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the ECM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_LQA</code></td>
<td>
<p>A list of parameters for the local quadratic approximation (LQA) in the ECM algorithm.
<code>eps_diff</code> is the lower bound for the coefficient mean differences, values below <code>eps_diff</code> are set to zero.
<code>MAX_iter_LQA</code> is the maximum number of iterations allowed in the LQA.
<code>eps_LQA</code> is the tolerance for the stopping condition of LQA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>If TRUE, the estimated cluster means are plotted at each iteration of the ECM algorithm. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If TRUE, information are shown at each iteration of the ECM algorithm. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>It is the way to initialize the ECM algorithm. There are three ways of initialization: "kmeans", "model-based", and "hierarchical", that
provide initialization through the k-means algorithm,  model-based clustering based on parameterized finite Gaussian mixture model, and  hierarchical clustering, respectively.
Default is "kmeans".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcon</code></td>
<td>
<p>A vector of character strings indicating the type of coefficient covariance matrix. Three values are allowed: "full", "diagonal", and "equal".
"full" means unrestricted cluster coefficient covariance matrices allowed to be different among clusters.
"diagonal" means diagonal cluster coefficient covariance matrices that are equal among clusters.
"equal" means diagonal cluster coefficient covariance matrices, with equal diagonal entries, that are equal among clusters.
Default is "diagonal".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_s_ini</code></td>
<td>
<p>The tuning parameter used to obtain the functional data through smoothing B-splines before applying the initialization algorithm.
If NULL a Generalized cross validation procedure is used as described in Ramsay (2005). Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_fold</code></td>
<td>
<p>Number of folds. Default is 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_test</code></td>
<td>
<p>Only for functional data observed over a regular grid, a matrix  where  the rows must correspond to argument values and columns to replications of the test set. Default in NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_test</code></td>
<td>
<p>The vector of time points where the test set curves are sampled. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m1</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>G</code> for each <code>lambda_s</code> and <code>lambda_l</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>lambda_s</code> fixed <code>G</code> for each <code>lambda_l</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m3</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>lambda_l</code> fixed <code>G</code> and <code>lambda_s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>If <code>ncores</code>&gt;1, then parallel computing is used, with <code>ncores</code> cores. Default is 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following arguments:
</p>
<p><code>G_opt</code>: The optimal  number of clusters.
</p>
<p><code>lambda_l_opt</code>: The optimal tuning parameter of the FAPFP.
</p>
<p><code>lambda_s_opt</code>: The optimal tuning parameter of the smoothness penalty.
</p>
<p><code>comb_list</code>: The combinations of <code>G</code>,<code>lambda_s</code> and <code>lambda_l</code> explored.
</p>
<p><code>CV</code>: The cross-validation values obtained for each combination of <code>G</code>,<code>lambda_s</code> and <code>lambda_l</code>.
</p>
<p><code>CV_sd</code>: The standard deviations of the cross-validation values.
</p>
<p><code>zeros</code>: Fraction of domain over which the estimated cluster means are fused.
</p>
<p><code>ms</code>: The m-standard deviation rule parameters.
</p>
<p><code>class</code>: A label for the output type.
</p>


<h3>References</h3>

<p>Centofanti, F., Lepore, A., &amp; Palumbo, B. (2021).
Sparse and Smooth Functional Data Clustering.
<em>arXiv preprint arXiv:2103.15224</em>.
</p>
<p>Ramsay, J., Ramsay, J., &amp; Silverman, B. W. (2005). Functional Data Analysis. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

<p><code>sasfclust</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
lambda_s_seq=10^seq(-4,-3)
lambda_l_seq=10^seq(-1,0)
G_seq=2
mod_cv&lt;-sasfclust_cv(X=train$X,grid=train$grid,G_seq=G_seq,
lambda_l_seq = lambda_l_seq,lambda_s_seq =lambda_s_seq,maxit = 20,K_fold = 2,q=10)
plot(mod_cv)

</code></pre>


</div>