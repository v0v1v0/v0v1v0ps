<div class="container">

<table style="width: 100%;"><tr>
<td>nCsdAlleles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Report the number of distinct csd alleles</h2>

<h3>Description</h3>

<p>Level 0 function that returns the number of distinct csd alleles
in input. See <code>SimParamBee</code> for more information about the csd
locus.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nCsdAlleles(x, collapse = FALSE, simParamBee = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>Pop-class</code>, <code>Colony-class</code>, or
<code>MultiColony-class</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the function will return the number
of distinct csd alleles in either the entire population, colony, or
multicolony. Note this has nothing to do with the colony collapse. It's
like <code>paste(..., collapse = TRUE)</code>. Default is <code>FALSE</code>. See
examples about this behaviour.Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simParamBee</code></td>
<td>
<p><code>SimParamBee</code>, global simulation parameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Queen has 2 distinct csd alleles, since she has to be heterozygous
to be viable. The same holds for individual virgin queens and workers, but
note that looking at csd genotypes of virgin queens or workers we are
looking at a sample of 1 csd allele from the queen and 1 csd allele from
their fathers, noting that homozygous genotypes are excluded. Therefore,
<code>nCsdAlleles()</code> from virgin queens and workers is a noisy realisation
of <code>nCsdAlleles()</code> from queens and fathers. For this reason, we also
report <code>nCsdAlleles()</code> from queens and fathers combined (see the
<code>queenAndFathers</code> list node) when <code>x</code> is
<code>Colony-class</code>. This last measure is then the expected number
of csd alleles in a colony as opposed to realised number of csd alleles in
a sample of virgin queens and workers. Similarly as for virgin queens and
workers, <code>nCsdAlleles()</code> from drones gives a noisy realisation of
<code>nCsdAlleles()</code> from queens. The amount of noise will depend on the
number of individuals, so in most cases with reasonable number of
individuals there should be minimal amount of noise.
</p>


<h3>Value</h3>

<p>integer representing the number of distinct csd alleles when <code>x</code>
is <code>Pop-class</code> (or ), list of integer
when <code>x</code> is <code>Colony-class</code> (list nodes named by caste) and
list of a list of integer when <code>x</code> is <code>MultiColony-class</code>,
outer list is named by colony id when <code>x</code> is
<code>MultiColony-class</code>; the integer rep
</p>


<h3>Examples</h3>

<pre><code class="language-R">founderGenomes &lt;- quickHaplo(nInd = 8, nChr = 1, segSites = 100)
SP &lt;- SimParamBee$new(founderGenomes)

basePop &lt;- createVirginQueens(founderGenomes)

drones &lt;- createDrones(x = basePop[1], nInd = 1000)
droneGroups &lt;- pullDroneGroupsFromDCA(drones, n = 10, nDrones = nFathersPoisson)

# Create a Colony and a MultiColony class
colony &lt;- createColony(x = basePop[2])
colony &lt;- cross(colony, drones = droneGroups[[1]])
colony &lt;- buildUp(x = colony, nWorkers = 6, nDrones = 3)
colony &lt;- addVirginQueens(x = colony, nInd = 4)

apiary &lt;- createMultiColony(basePop[3:4], n = 2)
apiary &lt;- cross(apiary, drones = droneGroups[c(2, 3)])
apiary &lt;- buildUp(x = apiary, nWorkers = 6, nDrones = 3)
apiary &lt;- addVirginQueens(x = apiary, nInd = 5)

nCsdAlleles(getQueen(colony))
nCsdAlleles(getWorkers(colony))

nCsdAlleles(colony)
nCsdAlleles(colony, collapse = TRUE)

nCsdAlleles(apiary)
nCsdAlleles(apiary, collapse = TRUE)
</code></pre>


</div>