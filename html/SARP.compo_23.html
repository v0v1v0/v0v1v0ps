<div class="container">

<table style="width: 100%;"><tr>
<td>creer_matrice</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create p-values matrix from pairwise tests of all possible
ratios of a compositional vector
</h2>

<h3>Description</h3>

<p>This function performs hypothesis testing on all possible pairwise
ratios or differences of a set of variables in a given data frame, and
store their results in a (symmetric) matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">creer.Mp( d, noms, f.p, log = FALSE, en.log = !log,
          nom.var = 'R', n.coeurs = 1, controles = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The data frame that contains the compositional variables. Other
objects will be coerced as data frames using
<code>as.data.frame</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.p</code></td>
<td>

<p>An R function that will perform the hypothesis test on a single
ratio (or log ratio, depending on <code>log</code> and <code>en.log</code>
values).
</p>
<p>This function should return a single numerical value, typically the
p-value from the test.
</p>
<p>This function must accept at least two named arguments: <code>d</code>
that will contain the data frame containing all required variables
and <code>variable</code> that will contain the name of the column that
contains the (log) ratio in this data frame. All other needed
arguments can be passed through <code>...</code>.
</p>
<p>Such functions are provided for several common situations, see
references at the end of this manual page.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>en.log</code></td>
<td>
<p> If <code>TRUE</code>, the ratio will be log-transformed
before applying the hypothesis test computed by <code>f.p</code>. Don't
change the default unless you really know what you are doing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nom.var</code></td>
<td>
<p> A length-one character vector giving the name of the
variable containing a single ratio (or log-ratio). No sanity check
is performed on it: if you experience strange behaviour, check you
gave a valid column name, for instance using
<code>make.names</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the
help of the parallel package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controles</code></td>
<td>
<p>If TRUE, sanity checks are done on the obtained
matrix. Columns and Rows containing only non-finite values are
removed, with warnings; corresponding component names are stored as
attribute <code>omis</code> in the final result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to <code>f.p</code>, passed unchanged to
it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function constructs a <code class="reqn">n\times n</code> matrix, where <code>n =
  length( noms )</code> (after eventually removing names in <code>noms</code> that
do not correspond to numeric variables). Term <code class="reqn">(i,j)</code> in this
matrix is the result of the <code>f.p</code> function when applied on the
ratio of variables <code>noms[ i ]</code> and <code>noms[ j ]</code> (or on its
log, if either <code>(log == TRUE) &amp;&amp; (en.log == FALSE)</code> or <code>(log
  == FALSE) &amp;&amp; (en.log == TRUE)</code>).
</p>
<p>The <code>f.p</code> function is always called only once, for <code class="reqn">i &lt; j</code>,
and the other term is obtained by symmetry.
</p>
<p>The diagonal of the matrix is filled with 1 without calling <code>f.p</code>,
since corresponding ratios are always identically equal to 1 so
nothing useful can be tested on.
</p>


<h3>Value</h3>

<p> These function returns the matrix obtained as described above,
with row an column names set to the names in <code>noms</code> (after
conversion into column names and removing all non-numeric variables).
</p>


<h3>Note</h3>

<p>Since the whole matrix is stored and since it is a dense
matrix, memory consumption (and computation time) increases as
<code class="reqn">n^2</code>. For compositional data with  a large number of components,
like in RNA-Seq data, consider instead creating a file.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p>Predefined <code>f.p</code> functions: <code>anva1.fpc</code> for one-way
analysis of variance; <code>kw.fpc</code> for the non-parametric
equivalent (Kruskal-Wallis test).
</p>
<p><code>grf.Mp to create a graphe from the obtained matrix.</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site' )
   Mp

   # Make a graphe from it and plot it
   plot( grf.Mp( Mp ) )
</code></pre>


</div>