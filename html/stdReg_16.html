<div class="container">

<table style="width: 100%;"><tr>
<td>stdGee</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regression standardization in conditional generalized estimating equations
</h2>

<h3>Description</h3>

<p><code>stdGee</code> performs regression standardization in linear and log-linear 
fixed effects models, at specified values of the exposure, over the sample 
covariate distribution. Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, 
the exposure, and a vector of covariates, respectively. It is assumed that data
are clustered with a cluster indicator <code class="reqn">i</code>. <code>stdGee</code> uses 
fitted fixed effects model, with cluster-specific intercept <code class="reqn">a_i</code> 
(see <code>details</code>), to estimate the standardized mean 
<code class="reqn">\theta(x)=E\{E(Y|i,X=x,Z)\}</code>, where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, 
and the outer expectation is over the marginal distribution of <code class="reqn">(a_i,Z)</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">stdGee(fit, data, X, x, clusterid, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>an object of class <code>"gee"</code>, with argument <code>cond = TRUE</code>, as returned 
by the <code>gee</code> function in the <span class="pkg">drgee</span> package. If arguments 
<code>weights</code> and/or <code>subset</code> are used when fitting the model, then the 
same weights and subset are used in <code>stdGee</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized mean. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal mean
<code class="reqn">E(Y)=E\{E(Y|X,Z)\}</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterid</code></td>
<td>

<p>an mandatory string containing the name of a cluster identification variable.
Must be identical to the clusterid variable used in the gee call. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stdGee</code> assumes that a fixed effects model 
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|i,X,Z)\}=a_i+h(X,Z;\beta)</code>
</p>
 
<p>has been fitted. The link function <code class="reqn">\eta</code> is assumed to be the identity link
or the log link. The conditional generalized estimating equation (CGGE)
estimate of <code class="reqn">\beta</code> is used to obtain estimates of the cluster-specific 
means:
</p>
<p style="text-align: center;"><code class="reqn">\hat{a}_i=\sum_{j=1}^{n_i}r_{ij}/n_i,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}-h(X_{ij},Z_{ij};\hat{\beta})</code>
</p>

<p>if <code class="reqn">\eta</code> is the identity link, and
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}exp\{-h(X_{ij},Z_{ij};\hat{\beta})\}</code>
</p>

<p>if <code class="reqn">\eta</code> is the log link, and <code class="reqn">(X_{ij},Z_{ij})</code> is the value of 
<code class="reqn">(X,Z)</code> for subject <code class="reqn">j</code> in cluster <code class="reqn">i</code>, <code class="reqn">j=1,...,n_i</code>, 
<code class="reqn">i=1,...,n</code>. The CGEE estimate of <code class="reqn">\beta</code> and the estimate of 
<code class="reqn">a_i</code> are used to estimate the mean <code class="reqn">E(Y|i,X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{E}(Y|i,X=x,Z)=\eta^{-1}\{\hat{a}_i+h(X=x,Z;\hat{\beta})\}.</code>
</p>
 
<p>For each <code class="reqn">x</code> in the <code>x</code> argument, these estimates are averaged across 
all subjects (i.e. all observed values of <code class="reqn">Z</code> and all estimated values of 
<code class="reqn">a_i</code>) to produce estimates  
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(x)=\sum_{i=1}^n \sum_{j=1}^{n_i} \hat{E}(Y|i,X=x,Z_i)/N,</code>
</p>

<p>where <code class="reqn">N=\sum_{i=1}^n n_i</code>. The variance for <code class="reqn">\hat{\theta}(x)</code> is 
obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdGee"</code> is a list containing 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>

<p>a vector with length equal to <code>length(x)</code>, where element <code>j</code> is equal to 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>

<p>a square matrix with <code>length(x)</code> rows, where the element 
on row <code>i</code> and column <code>j</code> is the (estimated) covariance of 
<code class="reqn">\hat{\theta}</code>(<code>x[i]</code>) and 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The variance calculation performed by <code>stdGee</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_{11},...,Z_{nn_i})</code>. To see how this 
matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(x)\}=E[var\{\hat{\theta}(x)|\bar{Z}\}]+var[E\{\hat{\theta}(x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a generalized linear model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), 
so that the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding 
variance decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, 
<code class="reqn">\theta(x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the sample 
distribution for <code class="reqn">Z</code>, and thus the term <code class="reqn">var[E\{\hat{\theta}(x)|\bar{Z}\}]</code> 
is not 0, unless one conditions on <code class="reqn">\bar{Z}</code>. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Goetgeluk S. and Vansteelandt S. (2008). Conditional generalized estimating 
equations for the analysis of clustered and longitudinal data. 
<em>Biometrics</em> <b>64</b>(3), 772-780.
</p>
<p>Martin R.S. (2017). Estimation of average marginal effects in multiplicative 
unobserved effects panel models. <em>Economics Letters</em> <b>160</b>, 16-19.
</p>
<p>Sjolander A. (2019). Estimation of marginal causal effects in the presence of 
confounding by cluster. <em>Biostatistics</em> doi: 10.1093/biostatistics/kxz054
</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(drgee)

n &lt;- 1000
ni &lt;- 2
id &lt;- rep(1:n, each=ni)
ai &lt;- rep(rnorm(n), each=ni)
Z &lt;- rnorm(n*ni)
X &lt;- rnorm(n*ni, mean=ai+Z)
Y &lt;- rnorm(n*ni, mean=ai+X+Z+0.1*X^2)
dd &lt;- data.frame(id, Z, X, Y)
fit &lt;- gee(formula=Y~X+Z+I(X^2), data=dd, clusterid="id", link="identity",
  cond=TRUE)
fit.std &lt;- stdGee(fit=fit, data=dd, X="X", x=seq(-3,3,0.5), clusterid="id")
print(summary(fit.std, contrast="difference", reference=2))
plot(fit.std)

</code></pre>


</div>