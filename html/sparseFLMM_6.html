<div class="container">

<table style="width: 100%;"><tr>
<td>sparseFLMM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Linear Mixed Models for Irregularly or Sparsely Sampled Data</h2>

<h3>Description</h3>

<p>Estimation of functional linear mixed models (FLMMs) for irregularly or sparsely
sampled data based on functional principal component analysis (FPCA).
The implemented models are special cases of the general FLMM
</p>
<p style="text-align: center;"><code class="reqn">Y_i(t_{ij}) = \mu(t_{ij},x_i) + z_i^T U(t_{ij}) + \epsilon_i(t_{ij}), i = 1,...,n, j = 1,...,D_i,</code>
</p>

<p>with <code class="reqn">Y_i(t_{ij})</code> the value of the response of curve <code class="reqn">i</code> at observation point
<code class="reqn">t_{ij}</code>, <code class="reqn">\mu(t_{ij},x_i)</code> is a mean function, which may depend on covariates
<code class="reqn">x_i = (x_{i1},\ldots,x_{ip})^T</code>. <code class="reqn">z_i</code> is a covariate vector,
which is multiplied with the vector of functional random effects <code class="reqn">U(t_{ij})</code>.
<code class="reqn">\epsilon_i(t_{ij})</code> is independent and identically distributed white noise
measurement error with homoscedastic, constant variance. For more details, see references below.<br><br>
The current implementation can be used to fit four special cases
of the above general FLMM:
</p>

<ul>
<li>
<p> a model for independent functional data (e.g. longitudinal data),
for which <code class="reqn">z_i^T U(t_{ij})</code> only consists of
a smooth curve-specific deviation (smooth error curve)
</p>
</li>
<li>
<p> a model for correlated functional data with one
functional random intercept (fRI) for one grouping variable in addition
to a smooth curve-specific error
</p>
</li>
<li>
<p> a model for correlated functional data with two crossed
fRIs for two grouping variables in addition to a smooth curve-specific error
</p>
</li>
<li>
<p> a model for correlated functional data with two nested fRIs for
two grouping variables in addition to a smooth curve-specific error.</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">sparseFLMM(
  curve_info,
  use_RI = FALSE,
  use_simple = FALSE,
  method = "fREML",
  use_bam = TRUE,
  bs = "ps",
  d_grid = 100,
  min_grid = 0,
  max_grid = 1,
  my_grid = NULL,
  bf_mean = 8,
  bf_covariates = 8,
  m_mean = c(2, 3),
  covariate = FALSE,
  num_covariates,
  covariate_form,
  interaction,
  which_interaction = matrix(NA),
  save_model_mean = FALSE,
  para_estim_mean = FALSE,
  para_estim_mean_nc = 0,
  bf_covs,
  m_covs,
  use_whole = FALSE,
  use_tri = FALSE,
  use_tri_constr = TRUE,
  use_tri_constr_weights = FALSE,
  np = TRUE,
  mp = TRUE,
  use_discrete_cov = FALSE,
  para_estim_cov = FALSE,
  para_estim_cov_nc = 0,
  var_level = 0.95,
  N_B = NA,
  N_C = NA,
  N_E = NA,
  use_famm = FALSE,
  use_bam_famm = TRUE,
  bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
  bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
  save_model_famm = FALSE,
  use_discrete_famm = FALSE,
  para_estim_famm = FALSE,
  para_estim_famm_nc = 0,
  nested = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>curve_info</code></td>
<td>
<p>data table in which each row represents a single observation
point. <code>curve_info</code> needs to contain the following columns:
</p>

<ul>
<li> <p><code>y_vec</code> (numeric): the response values for each observation point
</p>
</li>
<li> <p><code>t</code>  (numeric): the observations point locations, i.e. <code class="reqn">t_{ij}</code>
</p>
</li>
<li> <p><code>n_long</code> (integer): unique identification number for each curve
</p>
</li>
<li> <p><code>subject_long</code> (integer): unique identification number for each
level of the first grouping variable
(e.g. speakers for the phonetics data in the example below).
In the case of independent functions, <code>subject_long</code> should be set equal to <code>n_long</code>.
</p>
</li>
</ul>
<p>For models with two crossed functional random intercepts, the data table additionally needs to have columns:
</p>

<ul>
<li> <p><code>word_long</code> (integer): unique identification number for each level of
the second grouping variable (e.g. words for the phonetics data in the example below)
</p>
</li>
<li> <p><code>combi_long</code> (integer): number of the repetition of the combination of the
corresponding level of the first and of the second grouping variable.
</p>
</li>
</ul>
<p>For models with two nested functional random intercepts, the data table
additionally needs to have columns:
#' </p>

<ul>
<li> <p><code>word_long</code> (integer): unique identification number for each level
of the second grouping variable (e.g. phases of a randomized controled
trial). Note that the nested model is only implemented for two levels in the
second grouping variable.
</p>
</li>
<li> <p><code>combi_long</code> (integer): number of the repetition of the combination of the
corresponding level of the first and of the second grouping variable.
</p>
</li>
</ul>
<p>For models with covariates as part of the mean function <code class="reqn">\mu(t_{ij},x_i)</code>,
the covariate values (numeric) need to be in
separate columns with names: <code>covariate.1</code>, <code>covariate.2</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_RI</code></td>
<td>
<p>TRUE to specify a model with one functional random intercept
for the first grouping variable (<code>subject_long</code>) and a smooth random error curve.
Defaults to <code>FALSE</code>, which specifies a model with crossed functional random
intercepts for the
first and second grouping variable and a smooth error curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_simple</code></td>
<td>
<p><code>TRUE</code> to specify a model with only a smooth random error function,
<code>use_RI</code> should then also be set to <code>TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>estimation method for <code>gam</code> or <code>bam</code>, see <code>mgcv</code> for more details.
Defaults to <code>"fREML"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_bam</code></td>
<td>
<p><code>TRUE</code> to use function bam instead of function <code>gam</code> (syntax is the same, bam is faster for large data sets).
<code>bam</code> is recommended and set as default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs</code></td>
<td>
<p>spline basis function type for the estimation of the mean function and
the auto-covariance, see <code>s</code> and <code>te</code> for more details.
Defaults to penalized B-splines, i.e. <code>bs = "ps"</code>. This choice is recommended as others have not been
tested yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_grid</code></td>
<td>
<p>pre-specified grid length for equidistant grid on which the mean, the auto-covariance surfaces, the eigenfunctions
and the functional random effects are evaluated. NOTE: the length of the grid can be important for computation time (approx. quadratic influence).
Defaults to <code>d_grid = 100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_grid</code></td>
<td>
<p>minimum value of equidistant grid (should approx. correspond to minimum value of time interval). Defaults to <code>min_grid = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_grid</code></td>
<td>
<p>maximum value of equidistant grid (should approx. correspond to maximum value of time interval). Defaults to <code>max_grid = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my_grid</code></td>
<td>
<p>optional evaluation grid, which can be specified and used instead of <code>d_grid</code>, <code>min_grid</code>, <code>max_grid</code>.
NOTE: the grid should be equidistant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf_mean</code></td>
<td>
<p>basis dimension (number of basis functions) used for the functional intercept
<code class="reqn">f_0(t_{ij})</code> in the mean estimation via <code>bam/gam</code>. Defaults to <code>bf_mean = 8</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf_covariates</code></td>
<td>
<p>basis dimension (number of basis functions) used for the functional effects
of covariates in the mean estimation via <code>bam/gam</code>. Defaults to <code>bf_covariates = 8</code>.
NOTE: in the current implementation, the same basis dimension for all covariates is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m_mean</code></td>
<td>
<p>order of the penalty for this term in <code>bam/gam</code> of mean estimation, for <code>bs = "ps"</code> spline and penalty order,
defaults to <code>m_mean = c(2, 3)</code>, i.e., cubic B-splines with third order difference penalty, see <code>s</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p><code>TRUE</code> to estimate covariate effects (as part of the mean function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_covariates</code></td>
<td>
<p>number of covariates that are included in the model.
NOTE: not number of effects in case interactions of covariates are specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate_form</code></td>
<td>
<p>vector with entries for each covariate that specify the form in which the
respective covariate enters the mean function. Possible forms are <code>"by"</code> for varying-coefficient <code class="reqn">(f(t_{ij})*covariate)</code>, which is
possible for dummy coded covariates and metric covariates and
<code>"smooth"</code> for smooth effect in t and in covariate <code class="reqn">(f(t_{ij}, covariate))</code>, which is only
possible for metric covariates! NOTE: metric covariates should be centered such that the global functional intercept <code class="reqn">f_0(t_{ij})</code> can be interpreted as
global mean function and the effect can be interpreted as difference from the global mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction</code></td>
<td>
<p><code>TRUE</code> to estimate interaction effects of covariates, which interactions, see <code>which_interaction</code> (below).
Interactions are possible for dummy-coded covariates that act as varying coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_interaction</code></td>
<td>
<p>symmetric matrix that specifies which interactions should be considered in case <code>covariate = TRUE</code> and <code>interaction = TRUE</code>.
Entry <code>which_interaction</code>[k, l] specifies that the interaction between <code>covariate.k</code> and <code>covariate.l</code> is modeled (example below).
NOTE: entries are redundant, <code>which_interaction</code>[l, k] should be set to the
same as <code>which_interaction</code>[k, l] (symmetric). Defaults to <code>which_interaction = matrix(NA)</code> which should be specified when <code>interaction = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_model_mean</code></td>
<td>
<p><code>TRUE</code> to give out <code>gam/bam</code> object (attention: can be large!), defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_mean</code></td>
<td>
<p><code>TRUE</code> to parallelize mean estimation (only possible using <code>bam</code>), defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_mean_nc</code></td>
<td>
<p>number of cores for parallelization of mean estimation (only possible using <code>bam</code>,
only active if <code>para_estim_mean = TRUE</code>). Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf_covs</code></td>
<td>
<p>vector of marginal basis dimensions (number of basis functions) used for covariance estimation via <code>bam/gam</code>
for each functional random effect (including the smooth error curve).
In the case of multiple grouping variables, the first entry corresponds to the first grouping variable,
the second vector entry corresponds to the second grouping variable, and the third to the smooth error curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m_covs</code></td>
<td>
<p>list of marginal orders of the penalty for <code>bam/gam</code> for covariance estimation, for <code>bs = "ps"</code> marginal spline and
penalty order. As only symmetric surfaces are considered: same for both directions. <br>
For crossed fRIs: list of three vectors, e.g. <code>m_covs = list(c(2, 3), c(2, 3), c(2, 3))</code>, where first and second entry correspond to first
and second grouping variable, respectively and third entry corresponds to smooth error.
For one fRI: list of two vectors, e.g. <code>m_covs = list(c(2, 3), c(2, 3))</code>, where first entry corresponds to (first) grouping variable
and second entry corresponds to smooth error.
For independent curves: list of one vector, e.g. <code>m_covs = list(c(2,3))</code> corresponding to smooth error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_whole</code></td>
<td>
<p><code>TRUE</code> to estimate the whole auto-covariance surfaces without symmetry constraint.
Defaults to <code>FALSE</code> as is much slower than <code>use_tri_constr</code> and <code>use_tri_constr_weights</code>. For more details, see references below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_tri</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariance surfaces without
symmetry constraint. Defaults to <code>FALSE</code> and not recommended. For more details, see references below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_tri_constr</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariance surfaces with symmetry constraint using the
smooth class <code>'symm'</code>. Defaults to <code>TRUE</code>. For more details, see references below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_tri_constr_weights</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariances with symmetry constraint, using the
smooth class <code>'symm'</code> and weights of 0.5 on the diagonal to use the same weights as for estimating the whole auto-covariance surfaces.
Defaults to <code>FALSE</code>. For more details, see references below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>np</code></td>
<td>
<p><code>TRUE</code> to use 'normal parameterization' for a tensor product smooth, see <code>te</code> for more details.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mp</code></td>
<td>
<p><code>FALSE</code> to use Kronecker product penalty instead of Kronecker sum penalty
with only one smoothing parameter (<code>use_whole = TRUE</code> and <code>use_tri = TRUE</code>), for details see <code>te</code>.
For <code>use_tri_constr = TRUE</code> and <code>use_tri_constr_weights = TRUE</code>, only one smoothing parameter is estimated anyway.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_discrete_cov</code></td>
<td>
<p><code>TRUE</code> to further speed up the auto-covariance computation by discretization of
covariates for storage and efficiency reasons, includes parallelization controlled by <code>para_estim_cov_nc</code> (below),
see <code>bam</code> for more details. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_cov</code></td>
<td>
<p><code>TRUE</code> to parallelize auto-covariance estimation (only possible using <code>bam</code>), defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_cov_nc</code></td>
<td>
<p>number of cores (if <code>use_discrete_cov = FALSE</code>) or number of threads (if <code>use_discrete_cov = TRUE</code>)
for parallelization of auto-covariance estimation (only possible using <code>bam</code>, only active if <code>para_estim_cov = TRUE</code>).
Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_level</code></td>
<td>
<p>pre-specified level of explained variance used for the choice of the number of the functional principal
components (FPCs). Alternatively, a specific number of FPCs can be specified (see below). Defaults to <code>var_level = 0.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_B</code></td>
<td>
<p>number of components for B (fRI for first grouping variable) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_C</code></td>
<td>
<p>number of components for C (fRI for second grouping variable) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_E</code></td>
<td>
<p>number of components for E (smooth error) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_famm</code></td>
<td>
<p><code>TRUE</code> to embed the model into the framework of functional additive mixed
models (FAMMs) using re-estimation of the mean function together with the prediction of the FPC weights (scores).
This allows for point-wise confidence bands for the covariate effects. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_bam_famm</code></td>
<td>
<p><code>TRUE</code> to use function <code>bam</code> instead of function <code>gam</code> in FAMM estimation
(reduces computation time for large data sets),
highly recommended. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs_int_famm</code></td>
<td>
<p>specification of the estimation of the functional intercept <code class="reqn">f_0(t_{ij})</code>
(as part of the mean function), see <code>pffr</code> for details.
Defaults to <code>bs_int = list(bs = "ps", k = 8, m = c(2, 3))</code>, where
<code>bs</code>: type of basis functions, <code>k</code>: number of basis functions, <code>m</code>: order of the spline and order of the penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs_y_famm</code></td>
<td>
<p>specification of the estimation of the covariates effects (as part of the mean function), see <code>pffr</code> for details.
Defaults to <code>bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3))</code>, where
<code>bs</code>: type of basis functions, <code>k</code>: number of basis functions, <code>m</code>: order of the spline and order of the penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_model_famm</code></td>
<td>
<p><code>TRUE</code> to give out the FAMM model object (attention: can be very large!).
Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_discrete_famm</code></td>
<td>
<p><code>TRUE</code> to further speed up the fpc-famm computation by discretization of
# covariates for storage and efficiency reasons, includes parallelization controlled by <code>para_estim_famm_nc</code> (below),
see <code>bam</code> for more details. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_famm</code></td>
<td>
<p><code>TRUE</code> to parallelize FAMM estimation. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para_estim_famm_nc</code></td>
<td>
<p>number of cores (if <code>use_discrete_famm = FALSE</code>) or number of
threads (if <code>use_discrete_famm = TRUE</code>)
for parallelization of FAMM estimation (only possible using <code>bam</code>, only active if <code>para_estim_famm = TRUE</code>).
Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested</code></td>
<td>
<p><code>TRUE</code> to specify a model with nested functional random
intercepts for the first and second grouping variable and a smooth error
curve. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The code can handle irregularly and possibly sparsely sampled
data. Of course, it can also be used to analyze regular grid data,
but as it is especially designed for the irregular case and there may
be a more efficient way to analyze regular grid data. <br><br>
The mean function is of the form </p>
<p style="text-align: center;"><code class="reqn">\mu(t_{ij},x_i) = f_0(t_{ij}) +
\sum_{k=1}^r f_k(t_{ij},x_{ik}),</code>
</p>
<p> where <code class="reqn">f_0(t_{ij})</code> is a functional
intercept.
Currently implemented are effects of dummy-coded and metric covariates which act as
varying-coefficients of the
form <code class="reqn">f_k(t_{ij})*x_{ik}</code> and smooth effects of metric covariates (smooth in t and in the covariate)
of the form <code class="reqn">f(t_{ij}, x_{ik})</code>. NOTE: metric covariates should be centered such that the global functional intercept can be interpreted as global mean function and
the effect can be interpreted as difference from the global mean. Interaction effects of dummy-coded
covariates acting as varying coefficients are possible.
<br><br>
The estimation consists of four main steps:
</p>

<ol>
<li>
<p> estimation of the smooth mean function (including covariate effects)
under independence assumption using splines.
</p>
</li>
<li>
<p> estimation of the smooth auto-covariances of the functional random effects.
A fast bivariate symmetric smoother implemented in the smooth class 'symm' can be used to speed up estimation (see below).
</p>
</li>
<li>
<p> eigen decomposition of the estimated auto-covariances, which are evaluated on a
pre-specified equidistant grid. This yields estimated eigenvalues and eigenfunctions, which are
rescaled to ensure orthonormality with respect to the L2-scalar product.
</p>
</li>
<li>
<p> prediction of the functional principal component weights (scores) yielding predictions for
the functional random effects.
</p>
</li>
</ol>
<p>The estimation of the mean function and auto-covariance functions is based on package <span class="pkg">mgcv</span>.
<br>
The functional principal component weights (scores) are predicted as best (linear)
unbiased predictors. In addition, this implementation allows to embed the model
in the general framework of functional additive mixed models (FAMM) based on package <span class="pkg">refund</span>, which allows for the construction of
point-wise confidence bands for covariate effects (in the mean function) conditional on the FPCA.
Note that the estimation as FAMM may be computationally expensive as the model
is re-estimated in a mixed model framework.
</p>
<p>The four special cases of the general FLMM (two nested fRIs, two
crossed fRIs, one fRI, independent curves) are implemented as follows:
</p>

<ul>
<li>
<p> In the special case with two nested fRIs, three random processes B, C,
and E are considered, where B is the fRI for the first grouping variable (e.
g. patient in a random controlled trial), C denotes the fRI for the second
grouping variable (e.g. individual specific effect in the follow-up) and E
denotes the smooth error. For this special
case, arguments <code>use_RI</code> and <code>use_simple</code> are both set to
<code>FALSE</code> and argument <code>nested</code> is set to <code>TRUE</code>. Note that
this implementation only allows for a simple before/after study design.
</p>
</li>
<li>
<p> In the special case with two crossed fRIs,  three
random processes B, C, and E are considered, where B is the
fRI for the first grouping variable (e.g. speakers in the phonetics example below),
C denotes the fRI for the second grouping variable
(e.g. target words in the phonetics example below) and
E denotes the smooth error. For this special case, arguments
<code>use_RI</code> and <code>use_simple</code> are both set to <code>FALSE</code>.
</p>
</li>
<li>
<p> In the special case with only one fRI, only B and E are considered
and the number of levels for the second grouping variable is to zero.
For this special case, argument <code>use_RI</code> is set to <code>TRUE</code> and argument
<code>use_simple</code> is set to <code>FALSE</code>.
</p>
</li>
<li>
<p> The special case with independent curves is internally seen as a special case
of the model with one fRI for the first grouping variable, with the number of
levels for this grouping variable corresponding to the number of curves.
Thus, for each level of the first grouping variable there is one curve.
Therefore, for the special case of independent curves, the estimation returns an
estimate for the auto-covariance of B (instead of E) and all corresponding results are indicated with <code>'_B'</code>, although they
correspond to the smooth error. For this special case, arguments
<code>use_RI</code> and <code>use_simple</code> are both set to <code>TRUE</code>.</p>
</li>
</ul>
<h3>Value</h3>

<p>The function returns a list of two elements: <code>time_all</code> and <code>results</code>. <br><code>time_all</code> contains the total system.time() for calling function <code>sparseFLMM()</code>.<br><code>results</code> is a list of all estimates, including:
</p>

<ul><li> <p><code>mean_hat</code>: includes the components of the estimated mean function.
</p>

<ul>
<li> <p><code>mean_pred</code> contains effects of dummy covariates or metric covariates with a linear effect (varying coefficients).
</p>
</li>
<li> <p><code>mean_pred_smooth</code> contains effects of metric covariates with a smooth effect.
</p>
</li>
<li> <p><code>intercept</code> is the estimated intercept, which is part of <code class="reqn">f_0(t_{ij})</code>.
</p>
</li>
</ul>
</li></ul>
<p>For each auto-covariance smoothing alternative <code>X</code> (<code>use_whole</code>, <code>use_tri</code>,
<code>use_tri_constr</code>, <code>use_tri_constr_weights</code>):
</p>

<ul>
<li> <p><code>cov_hat_X</code>: includes
</p>

<ul>
<li> <p><code>sigmasq</code>: the estimated error variance
</p>
</li>
<li> <p><code>sigmasq_int</code>: the integral of the estimated error variance over the domain
</p>
</li>
<li> <p><code>grid_mat_B/C/E</code>: the estimated auto-covariance(s) evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>sp</code>: the smoothing parameter(s) for smoothing the auto-covariance(s)
</p>
</li>
<li> <p><code>time_cov_estim</code>: the time for the smoothing the auto-covariance(s) only
</p>
</li>
<li> <p><code>time_cov_pred_grid</code>: the time for evaluating the estimated auto-covariance(s) on the pre-specified grid.
</p>
</li>
</ul>
</li>
<li> <p><code>time_cov_X</code>: the total system.time() for the auto-covariance estimation
</p>
</li>
<li> <p><code>fpc_hat_X</code>: including
</p>

<ul>
<li> <p><code>phi_B/C/E_hat_grid</code>: the estimated rescaled eigenfunctions evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>nu_B/C/E_hat</code>: the estimated rescaled eigenvalues
</p>
</li>
<li> <p><code>N_B/C/E</code>: the estimated truncation numbers, i.e., number of FPCs which are chosen
</p>
</li>
<li> <p><code>total_var</code>: the estimated total variance
</p>
</li>
<li> <p><code>var_explained</code>: the estimated explained variance
</p>
</li>
<li> <p><code>xi_B/C/E_hat</code>: the predicted FPC weights (scores).
</p>
</li>
</ul>
</li>
<li> <p><code>time_fpc_X</code>: the total system.time() for the eigen decompositions
and prediction on the FPC weights (scores)
If <code>use_famm = TRUE</code>, the list <code>results</code> additionally contains:
</p>

<ul><li> <p><code>fpc_famm_hat_X</code>: including
</p>

<ul>
<li> <p><code>intercept</code>: the estimated intercept, which is part of <code class="reqn">f_0(t_{ij})</code>
</p>
</li>
<li> <p><code>residuals</code>: the residuals of the FAMM estimation
</p>
</li>
<li> <p><code>xi_B/C/E_hat_famm</code>: the predicted basis weights
</p>
</li>
<li> <p><code>famm_predict_B/C/E</code>: the predicted functional processes evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>famm_cb_mean</code>: the re-estimated functional intercept <code class="reqn">f_0(t_{ij})</code>
</p>
</li>
<li> <p><code>famm_cb_covariate.1</code>, <code>famm_cb_covariate.1</code>, etc: possible re-estimated covariate effects
</p>
</li>
<li> <p><code>famm_cb_inter_1_2</code>, <code>famm_cb_inter_1_3</code>, etc: possible interaction effects
</p>
</li>
<li> <p><code>time_fpc_famm_X</code>: the total system.time() for the FAMM estimation.
</p>
</li>
</ul>
</li></ul>
<p>The unique identification numbers for the levels of the grouping variables and curves are
renumbered for convenience during estimation from 1 in ascending order.
The original identification numbers are returned in the list <code>results</code>:
</p>

<ul>
<li> <p><code>n_orig</code>: curve levels as they entered the estimation
</p>
</li>
<li> <p><code>subject_orig</code>: levels of the first grouping variable as they entered the estimation
</p>
</li>
<li> <p><code>word_orig</code>: levels of the second grouping variable (if existent) as they entered the estimation
</p>
</li>
<li> <p><code>my_grid</code>: pre-specified grid.
</p>
</li>
</ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Jona Cederbaum
</p>


<h3>References</h3>

<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed Models
for Irregularly or Sparsely Sampled Data. Statistical Modelling, 16(1), 67-88.
</p>
<p>Cederbaum, Scheipl, Greven (2016): Fast symmetric additive covariance smoothing.
Submitted on arXiv.
</p>
<p>Scheipl, F., Staicu, A.-M. and Greven, S. (2015):
Functional Additive Mixed Models, Journal of Computational and Graphical Statistics, 24(2), 477-501.
</p>


<h3>See Also</h3>

<p>Note that <code>sparseFLMM</code> calls <code>bam</code> or <code>gam</code> directly.
</p>
<p>For functional linear mixed models with complex correlation structures
for data sampled on equal grids based on functional principal component analysis,
see function <code>denseFLMM</code> in package <code>denseFLMM</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# subset of acoustic data (very small subset, no meaningful results can be expected and
# FAMM estimation does not work for this subset example. For FAMM estimation, see below.)
data("acoustic_subset")

acoustic_results &lt;- sparseFLMM(curve_info = acoustic_subset, use_RI = FALSE, use_simple = FALSE,
              method = "fREML", use_bam = TRUE, bs = "ps", d_grid = 100, min_grid = 0,
              max_grid = 1, my_grid = NULL, bf_mean = 8, bf_covariates = 8, m_mean = c(2,3),
              covariate = TRUE, num_covariates = 4, covariate_form = rep("by", 4),
              interaction = TRUE,
              which_interaction = matrix(c(FALSE, TRUE, TRUE, TRUE, TRUE,
              FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE,
              FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
              byrow = TRUE, nrow = 4, ncol = 4),
              save_model_mean = FALSE, para_estim_mean = FALSE, para_estim_mean_nc = 0,
              bf_covs = c(5, 5, 5), m_covs = list(c(2, 3), c(2, 3), c(2, 3)),
              use_whole = FALSE, use_tri = FALSE, use_tri_constr = TRUE,
              use_tri_constr_weights = FALSE, np = TRUE, mp = TRUE,
              use_discrete_cov = FALSE,
              para_estim_cov = FALSE, para_estim_cov_nc = 5,
              var_level = 0.95, N_B = NA, N_C = NA, N_E = NA,
              use_famm = FALSE, use_bam_famm = TRUE,
              bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              save_model_famm = FALSE, use_discrete_famm = FALSE,
              para_estim_famm = FALSE, para_estim_famm_nc = 0)
## End(Not run)

## Not run: 
# whole data set with estimation in the FAMM framework

data("acoustic")
acoustic_results &lt;- sparseFLMM(curve_info = acoustic, use_RI = FALSE, use_simple = FALSE,
              method = "fREML", use_bam = TRUE, bs = "ps", d_grid = 100, min_grid = 0,
              max_grid = 1, my_grid = NULL, bf_mean = 8, bf_covariates = 8, m_mean = c(2,3),
              covariate = TRUE, num_covariates = 4, covariate_form = rep("by", 4),
              interaction = TRUE,
              which_interaction = matrix(c(FALSE, TRUE, TRUE, TRUE, TRUE,
              FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE,
              FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
              byrow = TRUE, nrow = 4, ncol = 4),
              save_model_mean = FALSE, para_estim_mean = FALSE, para_estim_mean_nc = 0,
              bf_covs = c(5, 5, 5), m_covs = list(c(2, 3), c(2, 3), c(2, 3)),
              use_whole = FALSE, use_tri = FALSE, use_tri_constr = TRUE,
              use_tri_constr_weights = FALSE, np = TRUE, mp = TRUE,
              use_discrete_cov = FALSE,
              para_estim_cov = TRUE, para_estim_cov_nc = 5,
              var_level = 0.95, N_B = NA, N_C = NA, N_E = NA,
              use_famm = TRUE, use_bam_famm = TRUE,
              bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              save_model_famm = FALSE, use_discrete_famm = FALSE,
              para_estim_famm = TRUE, para_estim_famm_nc = 5)
## End(Not run)

</code></pre>


</div>