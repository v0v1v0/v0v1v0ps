<div class="container">

<table style="width: 100%;"><tr>
<td>D2ss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numerical Derivatives of (x,y) Data  (via Smoothing Splines)</h2>

<h3>Description</h3>

<p>Compute the numerical first or 2nd derivatives of <code class="reqn">f()</code> given
observations <code>(x[i], y ~= f(x[i]))</code>.
</p>
<p><code>D1tr</code> is the <em><b>tr</b>ivial</em> discrete first derivative
using simple difference ratios, whereas <code>D1ss</code> and <code>D2ss</code>
use cubic smoothing splines (see <code>smooth.spline</code>)
to estimate first or second derivatives, respectively.
</p>
<p><code>D2ss</code> first uses <code>smooth.spline</code> for the first derivative
<code class="reqn">f'()</code> and then applies the same to the predicted values
<code class="reqn">\hat f'(t_i)</code> (where <code class="reqn">t_i</code> are the values of
<code>xout</code>) to find   <code class="reqn">\hat f''(t_i)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">D1tr(y, x = 1)

D1ss(x, y, xout = x, spar.offset = 0.1384, spl.spar=NULL)
D2ss(x, y, xout = x, spar.offset = 0.1384, spl.spar=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>numeric vectors of same length, supposedly from a model
<code>y ~ f(x)</code>.  For <code>D1tr()</code>, <code>x</code> can have length one
and then gets the meaning of <code class="reqn">h = \Delta x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xout</code></td>
<td>
<p>abscissa values at which to evaluate the derivatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar.offset</code></td>
<td>
<p>numeric fudge added to the smoothing parameter(s),
see <code>spl.par</code> below.  Note that the current default is there
for historical reasons only, and we often  would recommend to use
<code>spar.offset = 0</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spl.spar</code></td>
<td>
<p>direct smoothing parameter(s) for <code>smooth.spline</code>.
If it is <code>NULL</code> (as per default), the smoothing parameter used
will be <code>spar.offset + sp$spar</code>, where <code>sp$spar</code> is the GCV
estimated smoothing parameter for <em>both</em> smooths, see
<code>smooth.spline</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is well known that for derivative estimation, the optimal smoothing
parameter is larger (more smoothing needed) than for the function itself.
<code>spar.offset</code> is really just a <em>fudge</em> offset added to the
smoothing parameters. Note that in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s implementation of
<code>smooth.spline</code>, <code>spar</code> is really on the
<code class="reqn">\log\lambda</code> scale.






</p>


<h3>Value</h3>

<p><code>D1tr()</code> and <code>D1ss()</code> return a numeric vector of the length
of <code>y</code> or <code>xout</code>, respectively.
</p>
<p><code>D2ss()</code> returns a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the abscissae values (= <code>xout</code>) at which the
derivative(s) are evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>estimated values of <code class="reqn">f''(x_i)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spl.spar</code></td>
<td>
<p>numeric vector of length 2, contain the <code>spar</code>
arguments to the two <code>smooth.spline</code> calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar.offset</code></td>
<td>
<p>as specified on input (maybe rep()eated to length 2).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Martin Maechler, in 1992 (for S).</p>


<h3>See Also</h3>

<p><code>D1D2</code> which directly uses the 2nd derivative of
the smoothing spline;  <code>smooth.spline</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## First Derivative  --- spar.off = 0  ok "asymptotically" (?)
set.seed(330)
mult.fig(12)
for(i in 1:12) {
  x &lt;- runif(500, 0,10); y &lt;- sin(x) + rnorm(500)/4
  f1 &lt;- D1ss(x=x,y=y, spar.off=0.0)
  plot(x,f1, ylim = range(c(-1,1,f1)))
  curve(cos(x), col=3, add= TRUE)
}

 set.seed(8840)
 x &lt;- runif(100, 0,10)
 y &lt;- sin(x) + rnorm(100)/4

 op &lt;- par(mfrow = c(2,1))
 plot(x,y)
 lines(ss &lt;- smooth.spline(x,y), col = 4)
 str(ss[c("df", "spar")])
 xx &lt;- seq(0,10, len=201)
 plot(xx, -sin(xx), type = 'l', ylim = c(-1.5,1.5))
 title(expression("Estimating f''() :  " * frac(d^2,dx^2) * sin(x) == -sin(x)))
 offs &lt;- c(0.05, 0.1, 0.1348, 0.2)
 i &lt;- 1
 for(off in offs) {
   d12 &lt;- D2ss(x,y, spar.offset = off)
   lines(d12, col = i &lt;- i+1)
 }
 legend(2,1.6, c("true :  -sin(x)",paste("sp.off. = ", format(offs))), lwd=1,
        col = 1:(1+length(offs)), cex = 0.8, bg = NA)
 par(op)
</code></pre>


</div>