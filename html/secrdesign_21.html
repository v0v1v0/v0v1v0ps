<div class="container">

<table style="width: 100%;"><tr>
<td>GAoptim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
SECR detector placement by maximisation of a simple criterion
</h2>

<h3>Description</h3>

<p>Implements the approach of Durbach et al. (2021) for optimization of detector 
placement using a genetic algorithm to maximize the lesser 
of E(<code class="reqn">n</code>) and E(<code class="reqn">r</code>), where <code class="reqn">n</code> is the number of distinct individuals 
and <code class="reqn">r</code> is the total number of recaptures. This criterion predicts the 
relative standard error of the density estimate (Efford and Boulanger 2019).
</p>
<p>Users may choose the criterion to be maximised. The number of individuals 
detected at two or more detectors is an alternative of particular interest 
(Dupont et al. 2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">
GAoptim(mask, alltraps, ntraps, detectpar, noccasions, 
    detectfn = c("HHN", "HHR", "HEX", "HAN", "HCG"), D = NULL, 
    criterion = 4, penalty = NULL, seed = NULL, ...)
    
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p>mask object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alltraps</code></td>
<td>
<p>traps object with all possible trap locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntraps</code></td>
<td>
<p>number of required trap locations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectpar</code></td>
<td>
<p>list values of detection parameters lambd0, sigma etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function - see detectfn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>numeric density animals per hectare (0.01 km^2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>integer code for criterion to maximise, or function (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>list defining penalty for layout in relation to reference grid (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>set a random seed for reproducibility of GA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>kofnGA</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>detectpar</code> is a named list with values of the detection parameters for the chosen detectfn. Usually this will be just lambda0 (baseline hazard of detection) and sigma (spatial scale of detection).
</p>
<p>The genetic algorithm is provided by function <code>kofnGA</code> from package <span class="pkg">kofnGA</span> (Wolters 2015). The first three arguments of <code>kofnGA</code> (i.e., n, k, OF) are set by <code>GAoptim</code>. Others may be adjusted by the user via the ... argument. Specifically,
</p>

<table>
<tr>
<td style="text-align: left;">

Argument </td>
<td style="text-align: left;"> Default </td>
<td style="text-align: left;"> Description </td>
</tr>
<tr>
<td style="text-align: left;">
ngen </td>
<td style="text-align: left;"> 500 </td>
<td style="text-align: left;"> number of generations to run </td>
</tr>
<tr>
<td style="text-align: left;">

popsize </td>
<td style="text-align: left;"> 200 </td>
<td style="text-align: left;"> size of the population; equivalently, the number of offspring produced each generation </td>
</tr>
<tr>
<td style="text-align: left;">

mutprob </td>
<td style="text-align: left;"> 0.01 </td>
<td style="text-align: left;"> mutation rate </td>
</tr>
<tr>
<td style="text-align: left;">

verbose </td>
<td style="text-align: left;"> 0 </td>
<td style="text-align: left;"> integer controlling the display of progress during search. If a positive value, then the iteration number and best objective function value are displayed at the console every 'verbose' generations. Otherwise nothing is displayed. The default gives no display. </td>
</tr>
<tr>
<td style="text-align: left;">

cluster </td>
<td style="text-align: left;"> NULL </td>
<td style="text-align: left;"> number of parallel cores or a prebuilt parallel cluster </td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
</table>
<p>The default for ngen may (or may not) be larger than is needed for routine use. Durbach et al. (2021) used ngen = 50, popsize = 1000 and mutprob = 0.01. 
</p>
<p>Density D may be a scalar or a vector of length equal to the number of mask cells. No value need be specified if the sole aim is to optimize trap placement, but D is required for predictions of E(<code class="reqn">n</code>) and E(<code class="reqn">r</code>).
</p>
<p>Pathological detector layouts (sensu Efford and Boulanger 2019) may be avoided by adding a penalty to the objective.
No penalty is applied by default. To apply a penalty, <code>penalty</code> should be a list with named components pen_wt&gt;0 and pen_gridsigma). If a penalty is applied, the default compares the number of trap pairs with close spacing (2.5-3.5 sigma, 3.5-4.5 sigma) to the number in a compact sample from a regular grid with spacing sigma * pen_gridsigma (see internal functions <code>GApenfn</code> and <code>compactSample</code> and the vignette).  An alternative penalty function may be supplied as component ‘pen_fn’ of <code>penalty</code>.
</p>
<p>The default criterion is the minimum of E(n) and E(r) as used by Durbach et al. (2021).
The full list of builtin possibilities is:
</p>

<table>
<tr>
<td style="text-align: left;">

Code </td>
<td style="text-align: left;"> Description </td>
<td style="text-align: left;"> Note </td>
</tr>
<tr>
<td style="text-align: left;">
1 </td>
<td style="text-align: left;"> E(n) </td>
<td style="text-align: left;"> number of distinct individuals </td>
</tr>
<tr>
<td style="text-align: left;">
2 </td>
<td style="text-align: left;"> E(r) </td>
<td style="text-align: left;"> number of recaptures </td>
</tr>
<tr>
<td style="text-align: left;">
3 </td>
<td style="text-align: left;"> E(m) </td>
<td style="text-align: left;"> number of movement recaptures </td>
</tr>
<tr>
<td style="text-align: left;">
4 </td>
<td style="text-align: left;"> min(E(n), E(r)) </td>
<td style="text-align: left;"> minimum E(n), E(r) </td>
</tr>
<tr>
<td style="text-align: left;">
5 </td>
<td style="text-align: left;"> E(n2) </td>
<td style="text-align: left;"> expected number of animals detected at 2 or more sites (cf Qpm Dupont et al. 2021) </td>
</tr>
<tr>
<td style="text-align: left;">
6 </td>
<td style="text-align: left;"> E(n) + E(n2) </td>
<td style="text-align: left;"> (1) + (5) (cf Qpb Dupont et al. 2021)  </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Criteria 1–4 are computed with function <code>Enrm</code> (see also Efford and Boulanger 2019). Criteria 5–6 are computed with function <code>En2</code>. Any penalty is applied only when criterion = 4.
</p>
<p>The criterion may also be a function that returns a single numeric value to be maximised. Arguments of the function should match those of <code>En2</code>, although ... may suffice for some or all (see Examples).
</p>


<h3>Value</h3>

<p>An object of class "GAoptim" that is a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alltraps</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectpar</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noccasions</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detectfn</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>saved input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>des</code></td>
<td>
<p>kofnGA() output object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimaltraps</code></td>
<td>
<p>traps object with optimized layout</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimalenrms</code></td>
<td>
<p>E(n), E(r), E(m) evaluated with optimized layout</p>
</td>
</tr>
</table>
<h3>Warnings</h3>

<p>Spatial representativeness is not considered, so designs ‘optimised’ with <code>GAoptim</code> are not robust to unmodelled variation in density or detection parameters.
</p>


<h3>Author(s)</h3>

<p>Ian Durbach and Murray Efford.
</p>


<h3>References</h3>

<p>Dupont, G., Royle, J. A., Nawaz, M. A. and Sutherland, C. (2021) Optimal sampling
design for spatial capture–recapture. <em>Ecology</em> <b>102</b> e03262.
</p>
<p>Durbach, I., Borchers, D., Sutherland, C. and Sharma, K. (2021) Fast, flexible 
alternatives to regular grid designs for spatial capture–recapture. 
<em>Methods in Ecology and Evolution</em> <b>12</b>, 298–310. DOI 10.1111/2041-210X.13517
</p>
<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture–recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529–1535. DOI: 10.1111/2041-210X.13239
</p>
<p>Wolters, M. A. (2015) A genetic algorithm for selection of fixed-size
subsets with application to design problems. <em>Journal of Statistical
Software, Code Snippets</em>, <b>68</b>, 1–18. DOI 10.18637/jss.v068.c01
</p>


<h3>See Also</h3>

<p><code>Enrm</code>, 
<code>En2</code>, 
<code>minnrRSE</code>, 
<code>GApenfn</code>, 
<code>compactSample</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">


# an artificial example
msk &lt;- make.mask(type = 'rectangular', spacing = 10, nx = 30, ny = 20, buffer = 0)
alltrps &lt;- make.grid(nx = 29, ny = 19, origin = c(10,10), spacing = 10)
set.seed(123)

# 50 generations for demonstration, use more in practice
opt &lt;- GAoptim(msk, alltrps, ntraps = 20, detectpar = list(lambda0 = 0.5, sigma = 20), 
    detectfn = 'HHN', D = 10, noccasions = 5, ngen = 50, verbose = 1)

plot(msk)
plot(opt$optimaltraps, add = TRUE)
minnrRSE(opt, distribution = 'binomial')

# Using a criterion function
# En2 is unsuitable as a criterion function as it returns 2 values
# This function selects the second as the (unique) criterion
fn &lt;- function(...) En2(...)[2]
opt2 &lt;- GAoptim(msk, alltrps, ntraps = 20, detectpar = list(lambda0 = 0.5, sigma = 20), 
    detectfn = 'HHN', D = 10, noccasions = 5, ngen = 50, verbose = 1, criterion = fn)
    


</code></pre>


</div>