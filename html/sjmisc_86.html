<div class="container">

<table style="width: 100%;"><tr>
<td>split_var</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split numeric variables into smaller groups</h2>

<h3>Description</h3>

<p>Recode numeric variables into equal sized groups, i.e. a
variable is cut into a smaller number of groups at specific cut points.
<code>split_var_if()</code> is a scoped variant of <code>split_var()</code>, where
transformation will be applied only to those variables that match the
logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">split_var(
  x,
  ...,
  n,
  as.num = FALSE,
  val.labels = NULL,
  var.label = NULL,
  inclusive = FALSE,
  append = TRUE,
  suffix = "_g"
)

split_var_if(
  x,
  predicate,
  n,
  as.num = FALSE,
  val.labels = NULL,
  var.label = NULL,
  inclusive = FALSE,
  append = TRUE,
  suffix = "_g"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The new number of groups that <code>x</code> should be split into.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>val.labels</code></td>
<td>
<p>Optional character vector, to set value label attributes
of recoded variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), no value labels will be set. Value labels
can also be directly defined in the <code>rec</code>-syntax, see
'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.label</code></td>
<td>
<p>Optional string, to set variable label attribute for the
returned variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), variable label attribute of <code>x</code> will
be used (if present). If empty, variable label attributes will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inclusive</code></td>
<td>
<p>Logical; if <code>TRUE</code>, cut point value are included in
the preceding group. This may be necessary if cutting a vector into
groups does not define proper ("equal sized") group sizes.
See 'Note' and 'Examples'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>split_var()</code> splits a variable into equal sized groups, where
the amount of groups depends on the <code>n</code>-argument. Thus, this
functions <code>cuts</code> a variable into groups at the specified
<code>quantiles</code>.
<br><br>
By contrast, <code>group_var</code> recodes a variable into groups, where
groups have the same value range (e.g., from 1-5, 6-10, 11-15 etc.).
<br><br><code>split_var()</code> also works on grouped data frames
(see <code>group_by</code>). In this case, splitting is applied to
the subsets of variables in <code>x</code>. See 'Examples'.
</p>


<h3>Value</h3>

<p>A grouped variable with equal sized groups. If <code>x</code> is a data frame,
for <code>append = TRUE</code>, <code>x</code> including the grouped variables as new
columns is returned; if <code>append = FALSE</code>, only the grouped variables
will be returned. If <code>append = TRUE</code> and <code>suffix = ""</code>,
recoded variables will replace (overwrite) existing variables.
</p>


<h3>Note</h3>

<p>In case a vector has only few number of unique values, splitting into
equal sized groups may fail. In this case, use the <code>inclusive</code>-argument
to shift a value at the cut point into the lower, preceeding group to
get equal sized groups. See 'Examples'.
</p>


<h3>See Also</h3>

<p><code>group_var</code> to group variables into equal ranged groups,
or <code>rec</code> to recode variables.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(efc)
# non-grouped
table(efc$neg_c_7)

# split into 3 groups
table(split_var(efc$neg_c_7, n = 3))

# split multiple variables into 3 groups
split_var(efc, neg_c_7, pos_v_4, e17age, n = 3, append = FALSE)
frq(split_var(efc, neg_c_7, pos_v_4, e17age, n = 3, append = FALSE))

# original
table(efc$e42dep)

# two groups, non-inclusive cut-point
# vector split leads to unequal group sizes
table(split_var(efc$e42dep, n = 2))

# two groups, inclusive cut-point
# group sizes are equal
table(split_var(efc$e42dep, n = 2, inclusive = TRUE))

# Unlike dplyr's ntile(), split_var() never splits a value
# into two different categories, i.e. you always get a clean
# separation of original categories
library(dplyr)

x &lt;- dplyr::ntile(efc$neg_c_7, n = 3)
table(efc$neg_c_7, x)

x &lt;- split_var(efc$neg_c_7, n = 3)
table(efc$neg_c_7, x)

# works also with gouped data frames
mtcars %&gt;%
  split_var(disp, n = 3, append = FALSE) %&gt;%
  table()

mtcars %&gt;%
  group_by(cyl) %&gt;%
  split_var(disp, n = 3, append = FALSE) %&gt;%
  table()
</code></pre>


</div>