<div class="container">

<table style="width: 100%;"><tr>
<td>OF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optical Flow Verification
</h2>

<h3>Description</h3>

<p>Perform verification using optical flow as described in Marzban and Sandgathe (2010).
</p>


<h3>Usage</h3>

<pre><code class="language-R">OF(x, ...)

## Default S3 method:
OF(x, ..., xhat, W = 5, grads.diff = 1, center = TRUE, 
    cutoffpar = 4, verbose = FALSE)

## S3 method for class 'SpatialVx'
OF(x, ..., time.point = 1, obs = 1, model = 1, W = 5, grads.diff = 1,
    center = TRUE, cutoffpar = 4, verbose = FALSE)

## S3 method for class 'OF'
plot(x, ...)

## S3 method for class 'OF'
print(x, ...)

## S3 method for class 'OF'
hist(x, ...)

## S3 method for class 'OF'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, xhat</code></td>
<td>

<p>Default: m by n matrices describing the verification and forecast fields, resp.  The forecast field is considered the initial field that is morphed into the final (verification) field.
</p>
<p><code>OF.SpatialVx</code>: list object of class “SpatialVx”.
</p>
<p><code>plot</code>, <code>hist</code> and <code>print</code> methods: list object as returned by <code>OF</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>list object as returned by <code>OF</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>

<p>numeric/integer giving the window size (should be no smaller than 5).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grads.diff</code></td>
<td>

<p>1 or 2 describing whether to use first or second differences in finding the first derivative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>

<p>logical, should the fields be centered before performing the optical flow?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoffpar</code></td>
<td>

<p>numeric, set to NaN everything exceeding median +/- <code>cutoffpar</code>*sd.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical, should progress information be printed to the screen?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.point</code></td>
<td>
<p>numeric or character indicating which time point from the “SpatialVx” verification set to select for analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs, model</code></td>
<td>
<p>numeric indicating which observation/forecast model to select for the analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>For <code>OF</code>: optional arguments to the <code>optim</code> function (cannot be <code>par</code>, <code>fn</code>, <code>gr</code> or <code>method</code>).  See details section for <code>plot</code> and <code>hist</code> method functions.  Not used by the <code>summary</code> method function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the optical flow of the forecast field into the verification field.  Letting I_o(x,y) and I_f(x,y) represent the intensities of each field at coordinate (x,y), the collection of pairs (dx, dy) is the optical flow field, where:
</p>
<p>I_o(x,y) ~ I_f(x,y) + [partial(I_f) wrt x]*dx + [partial(I_f) wrt y]*dy.
</p>
<p>The procedure follows that proposed by Lucas and Kanade (1981) whereby for some window, W, it is assumed that all dx (dy) are assumed constant, and least squares estimation is used to estimate dx and dy (see Marzban and Sandgathe, 2010 for more on this implementation).  This function iteratively calls optflow for each window in the field.
</p>
<p>The above formulation is linear in the parameters.  Marzban and Sandgathe (2010) also introduce an additive error component, which leads to a nonlinear version of the above.  Namely,
</p>
<p>I_o(x,y) ~ I_f(x,y) + [partial(I_f) wrt x]*dx + [partial(I_f) wrt y]*dy + A(x,y).
</p>
<p>See Marzban and Sandgathe for more details.
</p>
<p>The plot method function can produce a figure like that of Fig. 1, 5, and 6 in Marzban and Sandgathe (2010) or with option <code>full=TRUE</code>, even more plots.  Optional arguments that may be passed in via the ellipses include: <code>full</code> (logical, produce a figure analogous to Fig. 1, 5 and 6 from Marzban and Sandgathe (2010) (FALSE/default) or make more plots (TRUE)), <code>scale</code> (default is 1 or no scaling, any numeric value by which the fields are divided/scaled before plotting), <code>of.scale</code> (default is 1, factor by which display vectors can be magnified), <code>of.step</code> (plot OF vectors every of.step, default is 4), <code>prop</code> (default is 2, value for <code>prop</code> argument in the call to <code>rose.diag</code> from package <span class="pkg">CircStats</span>), <code>nbins</code> (default is 40, number of bins to use in the call to <code>rose.diag</code>).
</p>
<p>The <code>hist</code> method function produces a two-dimensional histogram like that of Fig. 3 and 7 in Marzban and Sandgathe (2010).  It can also take various arguments passed via the ellipses.  They include: <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code> (lower and upper bounds for the histogram breaks in the x- (angle) and y- (magnitude/displacement error) directions, resp.  Defaults to (0,360) and (0,4)), nbreaks (default is 100, the number of breaks to use).
</p>
<p>The <code>summary</code> method mostly uses the <code>stats</code> function from package <span class="pkg">fields</span> to summarize results of the errors, but also uses <code>circ.summary</code> from package <span class="pkg">CircStats</span> for the angular errors.
</p>


<h3>Value</h3>

<p>OF returns a list object of class “OF” with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>list with components x and xhat containing the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>character vector giving the names of the verification and forecast fields.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>object of class “call” giving the original function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows,cols</code></td>
<td>
<p>numeric vector giving the rows and columns used for finding the centers of windows.  Needed by the plot and hist method functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.add.lin</code></td>
<td>
<p>m by n matrix giving the linear additive errors (intensities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.mag.lin</code></td>
<td>
<p>m by n matrix giving the linear magnitude (displacement) errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.ang.lin</code></td>
<td>
<p>m by n matrix giving the linear angular errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.add.nlin,err.mag.nlin,err.ang.nlin</code></td>
<td>
<p>same as above but for nonlinear errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.vc.lin,err.vr.lin,err.vc.nlin,err.vr.nlin</code></td>
<td>
<p>m by n matrices giving the x- and y- direction movements for the linear and nonlinear cases, resp.</p>
</td>
</tr>
</table>
<p>The hist method function invisibly returns a list object of class “OF” that contains the same object that was passed in along with new components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a list with components x and y giving the breaks in each direction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hist.vals</code></td>
<td>
<p>itself a list with components xb, yb (the number of breaks -1 used for each direction), and nb (the histogram values for each break)</p>
</td>
</tr>
</table>
<p>The plot and summary mehtod functions do not return anything.
</p>


<h3>Author(s)</h3>

<p>Caren Marzban, marzban “at” u.washington.edu, with modifications by Eric Gilleland
</p>


<h3>References</h3>

<p>Lucas, B D. and Kanade, T. (1981)  An iterative image registration technique with an application to stereo vision.  <em>Proc. Imaging Understanding Workshop</em>, DARPA, 121–130.
</p>
<p>Marzban, C. and Sandgathe, S. (2010)  Optical flow for verification.  <em>Wea. Forecasting</em>, <b>25</b>, 1479–1494, doi:10.1175/2010WAF2222351.1.
</p>


<h3>See Also</h3>

<p><code>optflow</code>, <code>optim</code>, <code>circ.summary</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data(hump)
initial &lt;- hump$initial
final &lt;- hump$final
look &lt;- OF(final, xhat=initial, W=9, verbose=TRUE)
plot(look) # Compare with Fig. 1 in Marzban and Sandgathe (2010).
par(mfrow=c(1,1))
hist(look) # 2-d histogram.
plot(look, full=TRUE) # More plots.
summary(look)

# Another way to skin the cat.
hold &lt;- make.SpatialVx( final, initial, field.type = "Bi-variate Gaussian",
    obs.name = "final", model.name = "initial" )

look2 &lt;- OF(hold, W=9, verbose=TRUE)
plot(look2)
par(mfrow=c(1,1))
hist(look2)
plot(look2, full=TRUE)
summary(look2)

## End(Not run)
</code></pre>


</div>