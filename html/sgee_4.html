<div class="container">

<table style="width: 100%;"><tr>
<td>bisee</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bi-Level Stagewise Estimating Equations Implementation</h2>

<h3>Description</h3>

<p>Function to perform BiSEE, a Bi-Level Boosting / Functional
Gradient Descent / Forward Stagewise regression in
the grouped covariates setting using
Generalized Estimating Equations
</p>


<h3>Usage</h3>

<pre><code class="language-R">bisee(y, ...)

## S3 method for class 'formula'
bisee(formula, data = list(), clusterID, waves = NULL,
  lambda1, lambda2 = 1 - lambda1, contrasts = NULL, subset, ...)

## Default S3 method:
bisee(y, x, waves = NULL, lambda1, lambda2 = 1 - lambda1,
  ...)

## S3 method for class 'fit'
bisee(y, x, family, clusterID, waves = NULL, groupID,
  corstr = "independence", alpha = NULL, lambda1 = 0.5, lambda2 = 1 -
  lambda1, intercept = TRUE, offset = 0, control = sgee.control(maxIt =
  200, epsilon = 0.05, stoppingThreshold = min(length(y), ncol(x)) - intercept,
  undoThreshold = 0.005), standardize = TRUE, verbose = FALSE, ...)

gsee(y, x, family, clusterID, waves = NULL, groupID = 1:ncol(x),
  corstr = "independence", alpha = NULL, offset = 0, intercept = TRUE,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(length(y), ncol(x)) - intercept, undoThreshold = 0.005),
  standardize = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of response measures that corresponds with modeling family
given in 'family' parameter. <code>y</code> is assumed to be the same length as
<code>clusterID</code> and is assumed to be organized into clusters as dictated by
<code>clusterID</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Object of class 'formula'; a symbolic description of
the model to be fitted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional data frame containing the variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterID</code></td>
<td>
<p>Vector of integers that identifies the clusters of response
measures in <code>y</code>. Data and <code>clusterID</code> are assumed to
1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that <code>clusterID</code> is a vector of consecutive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>waves</code></td>
<td>
<p>An integer vector which identifies components in clusters.
The length of <code>waves</code> should be the same as the number of
observations. <code>waves</code> is automatically generated if none is supplied,
but when using <code>subset</code> parameter, the <code>waves</code> parameter must be
provided by the user for proper calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>Mixing parameter used to indicate weight of $L_2$ Norm
(group selection). While not necessary, <code>lambda1</code> and
<code>lambda2</code> are
best set to sum to 1 as only the weights relative to each other matter.
Default value is set to .5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>Mixing parameter used to indicate weight of $L_1$ Norm
(individual selection). While not necessary, <code>lambda1</code> and
<code>lambda2</code> are best set to sum
to 1 as only the weights relative to each other matter.  Default value is
set to <code>1-lambda1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>An optional list provided when using a formula.
similar to <code>contrasts</code> from <code>glm</code>.
See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Design matrix of dimension <code>length(y)</code> x nvar,
the number of variables, where each row is
represents an observation of predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as <code>gaussian()</code> or
<code>poisson()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupID</code></td>
<td>
<p>Vector of integeres that identifies the groups of the
covariates/coefficients (i.e. the columns of <code>x</code>).  <code>x</code>
and <code>groupID</code> are
assumed 1) to be of corresponding dimension, (i.e.
<code>ncol(x) == length(groupID)</code>),
2) sorted so that groups of covariates are in contiguous
columns, and 3) organized so that <code>groupID</code> is a vector of consecutive
integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corstr</code></td>
<td>
<p>A character string indicating the desired working correlation
structure. The following are implemented : "independence" (default value),
"exchangeable", and "ar1".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>An initial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Vector of offset value(s) for the linear predictor.
<code>offset</code>
is assumed to be either of length one, or of the same length as <code>y</code>.
Default is to have no offset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of parameters used to contorl the path generation
process; see <code>sgee.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>A logical parameter that indicates whether or not
the covariates need to be standardized before fitting.
If standardized before fitting, the unstandardized
path is returned as the default, with a <code>standardizedPath</code> and
<code>standardizedX</code> included
separately. Default value is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical parameter indicating whether output should be produced
while bisee is running. Default value is FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function to implement BiSEE, a stagewise regression approach
that is designed to perform bi-level selection in the context of
Generalized Estimating Equations. Given a response <code>y</code> and
a design matrix <code>x</code>
(excluding intercept) BiSEE generates a path of stagewise regression
estimates for each covariate based on the provided step size epsilon,
and tuning parameters <code>lambda1</code> and <code>lambda2</code>. When
<code>lambda1 == 0</code> or <code>lambda2 == 0</code>, the simplified versions
of <code>bisee</code> called <code>see</code> and <code>gsee</code>, respectively,
will be called.
</p>
<p>The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
<code>summary.sgee</code> function provides such
functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the <code>plot.sgee</code> function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.
</p>
<p><code>bisee</code> makes use of the function uniroot in the stats package.
The <code>extendInt</code> parameter for <code>uniroot</code> is used, which may
cause issues for older versions of R.
</p>


<h3>Value</h3>

<p>Object of class <code>sgee</code> containing the path
of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, the iteration at which BiSEE terminated, and initial regression
values including <code>x</code>, <code>y</code>, codefamily, <code>clusterID</code>,
<code>groupID</code>, <code>offset</code>, <code>epsilon</code>, and <code>numIt</code>.
</p>


<h3>Note</h3>

<p>Function to execute BiSEE technique. Note that <code>lambda1</code>
and <code>lambda2</code> are tuning parameters. Though it is advised to
fix <code>lambda1 + lambda2 = 1</code>, this is not necessary. These parameters
can be tuned using various approaches including cross validation.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Stagewise
Generalized Estimating Equations with Grouped Variables. Biometrics 73,
1332-1342. URL: http://dx.doi.org/10.1111/biom.12669,
doi:10.1111/biom.12669.
</p>
<p>Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296–305.
</p>
<p>Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543–2588.
</p>
<p>Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2013). A
sparse-group lasso. Journal of Computational and Graphical
Statistics 22, 231–245.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)


## Perform Fitting by providing y and x values
coefMat1 &lt;- bisee(y = generatedData$y, x = generatedData$x,
                 family = gaussian(),
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable", 
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = .5,
                 lambda2 = .5,
                 verbose = TRUE)


## Perform Fitting by providing formula and data
genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat2 &lt;- bisee(formula(genDF), data = genDF,
                 family = gaussian(),
                 subset = Y &lt;1.5,
                 waves = rep(1:4, 50), 
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable",
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = 0.5,
                 lambda2 = 0.5,
                 verbose = TRUE)

par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

</code></pre>


</div>