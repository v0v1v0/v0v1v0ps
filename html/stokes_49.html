<div class="container">

<table style="width: 100%;"><tr>
<td>kform</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>k-forms</h2>

<h3>Description</h3>

<p>Functionality for dealing with <code class="reqn">k</code>-forms
</p>


<h3>Usage</h3>

<pre><code class="language-R">kform(S)
as.kform(M,coeffs,lose=TRUE)
kform_basis(n, k)
kform_general(W,k,coeffs,lose=TRUE)
is.kform(x)
d(i)
e(i,n)
## S3 method for class 'kform'
as.function(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Dimension of the vector space <code class="reqn">V=\mathbb{R}^n</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>Integer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>A <code class="reqn">k</code>-form maps <code class="reqn">V^k</code> to <code class="reqn">\mathbb{R}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Integer vector of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M,coeffs</code></td>
<td>
<p>Index matrix and coefficients for a <code class="reqn">k</code>-form</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lose</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce a
<code class="reqn">0</code>-form to a scalar and <code>FALSE</code> meaning to return the
formal <code class="reqn">0</code>-form</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>kform</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A <dfn><code class="reqn">k</code>-form</dfn> is an alternating <code class="reqn">k</code>-tensor.  In the
package, <code class="reqn">k</code>-forms are represented as sparse arrays
(<code>spray</code> objects), but with a class of <code>c("kform",
  "spray")</code>.  The constructor function <code>kform()</code> takes a
<code>spray</code> object and returns a <code>kform</code> object: it ensures that
rows of the index matrix are strictly nonnegative integers, have no
repeated entries, and are strictly increasing.  Function
<code>as.kform()</code> is more user-friendly.
</p>

<ul>
<li>
<p><code>kform()</code> is the constructor function.  It takes a
<code>spray</code> object and returns a <code>kform</code>.
</p>
</li>
<li>
<p><code>as.kform()</code> also returns a <code>kform</code> but is a bit more
user-friendly  than <code>kform()</code>.
</p>
</li>
<li>
<p><code>kform_basis()</code> is a low-level helper function that 
returns a matrix whose rows constitute a basis for the vector space
<code class="reqn">\Lambda^k(\mathbb{R}^n)</code> of <code class="reqn">k</code>-forms.
</p>
</li>
<li>
<p><code>kform_general()</code> returns a <code>kform</code> object with terms
that span the space of alternating tensors.
</p>
</li>
<li>
<p><code>is.kform()</code> returns <code>TRUE</code> if its argument is a
<code>kform</code> object.
</p>
</li>
<li>
<p><code>d()</code> is an easily-typed synonym for
<code>as.kform()</code>.  The idea is that <code>d(1) = dx</code>,
<code>d(2)=dy</code>, <code>d(5)=dx^5</code>, etc.  Also note that, for
example, <code>d(1:3)=dx^dy^dz</code>, the volume form.
</p>
</li>
</ul>
<p>Recall that a <code class="reqn">k</code>-tensor is a multilinear map from <code class="reqn">V^k</code>
to the reals, where <code class="reqn">V=\mathbb{R}^n</code> is a vector space.
A multilinear <code class="reqn">k</code>-tensor <code class="reqn">T</code> is <dfn>alternating</dfn> if it
satisfies
</p>
<p style="text-align: center;"><code class="reqn">T\left(v_1,\ldots,v_i,\ldots,v_j,\ldots,v_k\right)=
    -T\left(v_1,\ldots,v_j,\ldots,v_i,\ldots,v_k\right)
  </code>
</p>

<p>In the package, an object of class <code>kform</code> is an efficient
representation of an alternating tensor.
</p>
<p>Function <code>kform_basis()</code> is a low-level helper function that
returns a matrix whose rows constitute a basis for the vector space
<code class="reqn">\Lambda^k(\mathbb{R}^n)</code> of <code class="reqn">k</code>-forms:
</p>
<p style="text-align: center;"><code class="reqn">\phi=\sum_{1\leq i_1 &lt; \cdots &lt; i_k\leq n} a_{i_1\ldots
      i_k}\mathrm{d}x_{i_1}\wedge\cdots\wedge\mathrm{d}x_{i_k}</code>
</p>

<p>and indeed we have:
</p>
<p style="text-align: center;"><code class="reqn">a_{i_1\ldots i_k}=\phi\left(\mathbf{e}_{i_1},\ldots,\mathbf{e}_{i_k}\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{e}_j,1\leq j\leq k</code> is a basis for
<code class="reqn">V</code>.
</p>


<h3>Value</h3>

<p>All functions documented here return a <code>kform</code> object except
<code>as.function.kform()</code>, which returns a function, and
<code>is.kform()</code>, which returns a Boolean, and <code>e()</code>, which
returns a conjugate basis to that of <code>d()</code>.
</p>


<h3>Note</h3>

<p>Hubbard and Hubbard use the term “<code class="reqn">k</code>-form”, but Spivak
does not.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Hubbard and Hubbard; Spivak</p>


<h3>See Also</h3>

<p><code>ktensor</code>,<code>lose</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
as.kform(cbind(1:5,2:6),rnorm(5))
kform_general(1:4,2,coeffs=1:6)  # used in electromagnetism

K1 &lt;- as.kform(cbind(1:5,2:6),rnorm(5))
K2 &lt;- kform_general(5:8,2,1:6)
K1^K2  # or wedge(K1,K2)

d(1:3)
dx^dy^dz   # same thing

d(sample(9)) # coeff is +/-1 depending on even/odd permutation of 1:9

f &lt;- as.function(wedge(K1,K2))
E &lt;- matrix(rnorm(32),8,4)
f(E) + f(E[,c(1,3,2,4)])  # should be zero by alternating property

options(kform_symbolic_print = 'd')
(d(5)+d(7)) ^ (d(2)^d(5) + 6*d(4)^d(7))
options(kform_symbolic_print = NULL)  # revert to default

</code></pre>


</div>