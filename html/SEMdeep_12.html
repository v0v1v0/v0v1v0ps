<div class="container">

<table style="width: 100%;"><tr>
<td>SEMml</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nodewise-predictive SEM train using Machine Learning (ML)</h2>

<h3>Description</h3>

<p>The function converts a graph to a collection of 
nodewise-based models: each mediator or sink variable can be expressed as 
a function of its parents. Based on the assumed type of relationship, 
i.e. linear or non-linear, <code>SEMml()</code> fits a ML model to each
node (variable) with non-zero incoming connectivity. 
The model fitting is repeated equation-by equation (r=1,...,R) 
times, where R is the number of mediators and sink nodes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SEMml(
  graph,
  data,
  train = NULL,
  algo = "sem",
  vimp = FALSE,
  thr = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An igraph object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix with rows corresponding to subjects, and
columns to graph nodes (variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train</code></td>
<td>
<p>A numeric vector specifying the row indices corresponding to
the train dataset (default = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>ML method used for nodewise-network predictions.
Six algorithms can be specified:
</p>

<ul>
<li> <p><code>algo="sem"</code> (default) for a linear SEM, see <code>SEMrun</code>. 
</p>
</li>
<li> <p><code>algo="gam"</code> for a generalized additive model, see <code>gam</code>.
</p>
</li>
<li> <p><code>algo="rf"</code> for a random forest model, see <code>ranger</code>.
</p>
</li>
<li> <p><code>algo="xgb"</code> for a XGBoost model, see <code>xgboost</code>.
</p>
</li>
<li> <p><code>algo="nn"</code> for a small neural network model (1 hidden layer and 10 nodes), see <code>nnet</code>.
</p>
</li>
<li> <p><code>algo="dnn"</code> for a large neural network model (1 hidden layers and 1000 nodes), see <code>dnn</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vimp</code></td>
<td>
<p>A Logical value(default=FALSE). If TRUE compute the variable
importance, considering: (i) the squared value of the t-statistic or F-statistic
of the model parameters for "sem" or "gam"; (ii) the variable importance from
the <code>importance</code> or <code>xgb.importance</code>
functions for "rf" or "xgb"; (iii) the Olden's connection weights for "nn" or
"dnn".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr</code></td>
<td>
<p>A numerical value indicating the threshold to apply on the variable
importance to color the graph. If thr=NULL (default), the threshold is set to
thr = abs(mean(vimp)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the processed graph
will not be plotted to screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By mapping data onto the input graph, <code>SEMml()</code> creates
a set of nodewise-based models based on the directed links, i.e., 
a set of edges pointing in the same direction, between two nodes 
in the input graph that are causally relevant to each other. 
The mediator or sink variables can be characterized in detail as 
functions of their parents. An ML model (sem, gam, rf, xgb, nn, dnn) 
can then be fitted to each variable with non-zero inbound connectivity, 
taking into account the kind of relationship (linear or non-linear). 
With R representing the number of mediators and sink nodes in the 
network, the model fitting process is performed equation-by-equation 
(r=1,...,R) times.
</p>


<h3>Value</h3>

<p>An S3 object of class "ML" is returned. It is a list of 5 objects:
</p>

<ol>
<li>
<p> "fit", a list of ML model objects, including: the estimated covariance 
matrix (Sigma),  the estimated model errors (Psi), the fitting indices (fitIdx),
and the signed Shapley R2 values (parameterEstimates), if shap = TRUE,
</p>
</li>
<li>
<p> "Yhat", the matrix of continuous predicted values of graph nodes  
(excluding source nodes) based on training samples. 
</p>
</li>
<li>
<p> "model", a list of all the fitted nodewise-based models 
(sem, gam, rf, xgb or nn).
</p>
</li>
<li>
<p> "graph", the induced DAG of the input graph  mapped on data variables. 
If vimp = TRUE, the DAG is colored based on the variable importance measure,
i.e., if abs(vimp) &gt; thr will be highlighted in red (vimp &gt; 0) or blue
(vimp &lt; 0). 
</p>
</li>
<li>
<p> "data", istandardized training data subset mapping graph nodes. 
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal 
Network Analysis of High-Throughput Data with Structural Equation Models. 
Bioinformatics, 38 (20), 4829â€“4830 &lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>
<p>Hastie, T. and Tibshirani, R. (1990) Generalized Additive Models. London: 
Chapman and Hall.
</p>
<p>Breiman, L. (2001), Random Forests, Machine Learning 45(1), 5-32.
</p>
<p>Chen, T., &amp; Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. 
Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge 
Discovery and Data Mining.
</p>
<p>Ripley, B. D. (1996) Pattern Recognition and Neural Networks. Cambridge.
</p>
<p>Redell, N. (2019). Shapley Decomposition of R-Squared in Machine Learning 
Models. arXiv: Methodology.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# Load Amyotrophic Lateral Sclerosis (ALS)
data&lt;- alsData$exprs; dim(data)
data&lt;- transformData(data)$data
group&lt;- alsData$group; table (group)
ig&lt;- alsData$graph; gplot(ig)

#...with train-test (0.5-0.5) samples
set.seed(123)
train&lt;- sample(1:nrow(data), 0.5*nrow(data))

start&lt;- Sys.time()
# ... rf
res1&lt;- SEMml(ig, data, train, algo="rf", vimp=TRUE)

# ... xgb
res2&lt;- SEMml(ig, data, train, algo="xgb", vimp=TRUE)

# ... nn
res3&lt;- SEMml(ig, data, train, algo="nn", vimp=TRUE)

# ... gam
res4&lt;- SEMml(ig, data, train, algo="gam", vimp=TRUE)
end&lt;- Sys.time()
print(end-start)

# ... sem
res5&lt;- SEMml(ig, data, train, algo="sem", vimp=TRUE)

#str(res5, max.level=2)
res5$fit$fitIdx
res5$fit$parameterEstimates
gplot(res5$graph)

#Comparison of AMSE (in train data)
rf &lt;- res1$fit$fitIdx[2];rf
xgb&lt;- res2$fit$fitIdx[2];xgb
nn &lt;- res3$fit$fitIdx[2];nn
gam&lt;- res4$fit$fitIdx[2];gam
sem&lt;- res5$fit$fitIdx[2];sem

#Comparison of SRMR (in train data)
rf &lt;- res1$fit$fitIdx[4];rf
xgb&lt;- res2$fit$fitIdx[4];xgb
nn &lt;- res3$fit$fitIdx[4];nn
gam&lt;- res4$fit$fitIdx[4];gam
sem&lt;- res5$fit$fitIdx[4];sem

#Comparison of VIMP (in train data)
table(E(res1$graph)$color) #rf
table(E(res2$graph)$color) #xgb
table(E(res3$graph)$color) #nn
table(E(res4$graph)$color) #gam
table(E(res5$graph)$color) #sem

#Comparison of AMSE (in test data)
print(predict(res1, data[-train, ])$PE[1]) #rf
print(predict(res2, data[-train, ])$PE[1]) #xgb
print(predict(res3, data[-train, ])$PE[1]) #nn
print(predict(res4, data[-train, ])$PE[1]) #gam
print(predict(res5, data[-train, ])$PE[1]) #sem

#...with a binary outcome (1=case, 0=control)

ig1&lt;- mapGraph(ig, type="outcome"); gplot(ig1)
outcome&lt;- ifelse(group == 0, -1, 1); table(outcome)
data1&lt;- cbind(outcome, data); data1[1:5,1:5]

res6 &lt;- SEMml(ig1, data1, train, algo="nn", vimp=TRUE)
gplot(res6$graph)
table(E(res6$graph)$color)

mse6 &lt;- predict(res6, data1[-train, ])
yobs &lt;- group[-train]
yhat &lt;- mse6$Yhat[ ,"outcome"]
benchmark(yobs, yhat, thr=0, F1=TRUE)
benchmark(yobs, yhat, thr=0, F1=FALSE)


</code></pre>


</div>