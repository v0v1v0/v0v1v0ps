<div class="container">

<table style="width: 100%;"><tr>
<td>redist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Find a Matrix of Distances Between Positions Based on Regular Equivalence
</h2>

<h3>Description</h3>

<p><code>redist</code> uses the graphs indicated by <code>g</code> in <code>dat</code> to assess the extent to which each vertex is regularly equivalent; <code>method</code> determines the measure of approximate equivalence which is used (currently, only CATREGE).
</p>


<h3>Usage</h3>

<pre><code class="language-R">redist(dat, g = NULL, method = c("catrege"), mode = "digraph", 
    diag = FALSE, seed.partition = NULL, code.diss = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>a graph or set thereof.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>a vector indicating which elements of <code>dat</code> should be examined (by default, all are used).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>method to use when assessing regular equivalence (currently, only <code>"catrege"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>

<p><code>"digraph"</code> for directed data, otherwise <code>"graph"</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>

<p>logical; should diagonal entries (loops) should be treated as meaningful data?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.partition</code></td>
<td>

<p>optionally, an initial equivalence partition to “seed” the CATREGE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code.diss</code></td>
<td>

<p>logical; return as dissimilarities (rather than similarities)?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional parameters (currently ignored).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>redist</code> provides a basic tool for assessing the (approximate) regular equivalence of actors.  Two vertices <code class="reqn">i</code> and <code class="reqn">j</code> are said to be regularly equivalent with respect to role assignment <code>r</code> if <code class="reqn">\{r(u): u\in N^+(i)\}=\{r(u): u\in N^+(j)\}</code> and <code class="reqn">\{r(u): u\in N^-(i)\}=\{r(u): u\in N^-(j)\}</code>, where <code class="reqn">N^+</code> and <code class="reqn">N^-</code> denote out- and in-neighborhoods (respectively).  RE similarity/difference scores are computed by <code>method</code>, currently Borgatti and Everett's CATREGE algorithm (which is based on the multiplex maximal regular equivalence on <code class="reqn">G</code> and its transpose).  The “distance” between positions in this case is the inverse of the number of iterative refinements of the initial equivalence (i.e., role) structure required to allocate the positions to regularly equivalent roles (with 0 indicating positions which ultimately belong in the same role).  By default, the initial equivalence structure is one in which all vertices are treated as occupying the same role; the <code>seed.partition</code> option can be used to impose alternative constraints.  From this initial structure, vertices within the same role having non-identical mixes of neighbor types are re-allocated to different roles (where “neighbor type” is initially due to the pattern of (possibly valued) in- and out-ties, cross-classified by current alter type).  This procedure is then iterated until no further division of roles is necessary to satisfy the regularity condition.
</p>
<p>Once the similarities/differences are calculated, the results can be used with a clustering routine (such as <code>equiv.clust</code>) or an MDS (such as <code>cmdscale</code>) to identify the underlying role structure.
</p>


<h3>Value</h3>

<p>A matrix of similarity/difference scores.
</p>


<h3>Note</h3>

<p>The maximal regular equivalence is often very uninteresting (i.e., degenerate) for unvalued, undirected graphs.  An exogenous constraint (e.g., via the <code>seed.partition</code>) may be required to uncover a more useful refinement of the unconstrained maximal equivalence.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Borgatti, S.P. and Everett, M.G.  (1993).  “Two Algorithms for Computing Regular Equivalence.”  <em>Social Networks</em>, 15, 361-376.
</p>


<h3>See Also</h3>

<p><code>sedist</code>, <code>equiv.clust</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Create a random graph with _some_ edge structure
g.p&lt;-sapply(runif(20,0,1),rep,20)  #Create a matrix of edge 
                                   #probabilities
g&lt;-rgraph(20,tprob=g.p)            #Draw from a Bernoulli graph 
                                   #distribution

#Get RE distances
g.re&lt;-redist(g)

#Plot a metric MDS of vertex positions in two dimensions
plot(cmdscale(as.dist(g.re)))

#What if there were already something known to be different about
#the first five vertices?
sp&lt;-rep(1:2,times=c(5,15))            #Create "seed" partition
g.spre&lt;-redist(g,seed.partition=sp)   #Get new RE distances
g.spre
plot.sociomatrix(g.spre)              #Note the blocking! 
</code></pre>


</div>