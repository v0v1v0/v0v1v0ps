<div class="container">

<table style="width: 100%;"><tr>
<td>lq_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit of a <code class="reqn">L_q</code> Regression Model
</h2>

<h3>Description</h3>

<p>Fits a regression model in the <code class="reqn">L_q</code> norm (also labeled as the <code class="reqn">L_p</code> norm).
In more detail,
the optimization function <code class="reqn"> \sum_i | y_i - x_i \beta | ^p</code> is optimized.
The nondifferentiable function is approximated by a differentiable approximation,
i.e., we use <code class="reqn">|x| \approx \sqrt{x^2 + \varepsilon } </code>. The power <code class="reqn">p</code>
can also be estimated by using <code>est_pow=TRUE</code>, see
Giacalone, Panarello and Mattera (2018). The algorithm iterates between estimating
regression coefficients and the estimation of power values. The estimation of the
power based on a vector of residuals <code>e</code> can be conducted using the
function <code>lq_fit_estimate_power</code>.
</p>
<p>Using the <code class="reqn">L_q</code> norm in the regression is equivalent to assuming an expontial
power function for residuals (Giacalone et al., 2018). The density function and
a simulation function is provided by <code>dexppow</code> and <code>rexppow</code>, respectively.
See also the <span class="pkg">normalp</span> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lq_fit(y, X, w=NULL, pow=2, eps=0.001, beta_init=NULL, est_pow=FALSE, optimizer="optim",
    eps_vec=10^seq(0,-10, by=-.5), conv=1e-4, miter=20, lower_pow=.1, upper_pow=5)

lq_fit_estimate_power(e, pow_init=2, lower_pow=.1, upper_pow=10)

dexppow(x, mu=0, sigmap=1, pow=2, log=FALSE)

rexppow(n, mu=0, sigmap=1, pow=2, xbound=100, xdiff=.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Dependent variable
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Design matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>Optional vector of weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pow</code></td>
<td>

<p>Power <code class="reqn">p</code> in <code class="reqn">L_q</code> norm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_pow</code></td>
<td>

<p>Logical indicating whether power should be estimated
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>Parameter governing the differentiable approximation
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>Vector of resiuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pow_init</code></td>
<td>
<p>Initial value of power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_init</code></td>
<td>

<p>Initial vector
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>

<p>Can be <code>"optim"</code> or <code>"nlminb"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps_vec</code></td>
<td>
<p>Vector with decreasing <code class="reqn">\varepsilon</code> values used in
optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miter</code></td>
<td>
<p>Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower_pow</code></td>
<td>
<p>Lower bound for estimated power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_pow</code></td>
<td>
<p>Upper bound for estimated power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Location parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmap</code></td>
<td>
<p>Scale parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Logical indicating whether the logarithm should be provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbound</code></td>
<td>
<p>Lower and upper bound for density approximation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xdiff</code></td>
<td>
<p>Grid width for density approximation</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with following several entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>Vector of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res_optim</code></td>
<td>
<p>Results of optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>More values</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Giacalone, M., Panarello, D., &amp; Mattera, R. (2018).
Multicollinearity in regression: an efficiency comparison between $L_p$-norm and least
squares estimators. <em>Quality &amp; Quantity, 52</em>(4), 1831-1859.
<a href="https://doi.org/10.1007/s11135-017-0571-y">doi:10.1007/s11135-017-0571-y</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Small simulated example with fixed power
#############################################################################

set.seed(98)
N &lt;- 300
x1 &lt;- stats::rnorm(N)
x2 &lt;- stats::rnorm(N)
par1 &lt;- c(1,.5,-.7)
y &lt;- par1[1]+par1[2]*x1+par1[3]*x2 + stats::rnorm(N)
X &lt;- cbind(1,x1,x2)

#- lm function in stats
mod1 &lt;- stats::lm.fit(y=y, x=X)

#- use lq_fit function
mod2 &lt;- sirt::lq_fit( y=y, X=X, pow=2, eps=1e-4)
mod1$coefficients
mod2$coefficients

## Not run: 
#############################################################################
# EXAMPLE 2: Example with estimated power values
#############################################################################

#*** simulate regression model with residuals from the exponential power distribution
#*** using a power of .30
set.seed(918)
N &lt;- 2000
X &lt;- cbind( 1, c(rep(1,N), rep(0,N)) )
e &lt;- sirt::rexppow(n=2*N, pow=.3, xdiff=.01, xbound=200)
y &lt;- X %*% c(1,.5) + e

#*** estimate model
mod &lt;- sirt::lq_fit( y=y, X=X, est_pow=TRUE, lower_pow=.1)
mod1 &lt;- stats::lm( y ~ 0 + X )
mod$coefficients
mod$pow
mod1$coefficients

## End(Not run)
</code></pre>


</div>