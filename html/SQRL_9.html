<div class="container">

<table style="width: 100%;"><tr>
<td>sqrlScript</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Hybrid Script Syntax
</h2>

<h3>Description</h3>

<p>This material does not describe a function, but (instead) the <abbr><span class="acronym">SQRL</span></abbr>
scripting syntax for <abbr><span class="acronym">SQL</span></abbr> with embedded <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
</p>
<p>For instructions on how to submit (run) these scripts from file, refer to
<code>sqrlUsage</code>.
</p>


<h3>Script #01 (Pure SQL)</h3>

<pre>
use database;
select * from table;
</pre>


<h4>Commentary on Script #01</h4>

<p>Multi-statement <abbr><span class="acronym">SQL</span></abbr> scripts can be taken directly from
‘<span class="file">SQL Developer</span>’ (or similar application), and (usually) run without
modification.
The <span class="pkg">SQRL</span> parser identifies statement-terminating semicolons, and submits
each statement in turn, as those semicolons (or the end of the script) are
encountered.
</p>



<h3>Script #02 (SQL, with R in it)</h3>

<pre>
select isotope from periodic_table
where atomic_number = &lt;R&gt; Z &lt;/R&gt;
</pre>


<h4>Commentary on Script #02</h4>

<p>Scripts can be parameterised, via embedded <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
In <abbr><span class="acronym">SQRL</span></abbr>, <abbr><span class="acronym">XML</span></abbr>-style tags mark the beginning and end of an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
block.
As shown in <code>sqrlUsage</code>, values can either be passed explicitly, or
inherited from the calling environment.
Embedded <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is not restricted to the insertion of values for filtering, and can
be used to specify column names, clauses, or entire <abbr><span class="acronym">SQL</span></abbr> statements.
</p>
<p>Tags are not case sensitive.
</p>



<h3>Script #03 (Comments, and Arbitrary R)</h3>

<pre>
/* SQL-comment within SQL */
-- SQL-comment within SQL
select
  &lt;R&gt;
    /* SQL-comment within R */
    -- SQL-comment within R
    # R comment within R
    letter &lt;- sample(letters, 1)
    paste0("'", letter, "'")
  &lt;/R&gt;
</pre>


<h4>Commentary on Script #03</h4>

<p>The parser supports <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> comments, and two kinds of <abbr><span class="acronym">SQL</span></abbr> comments.
For syntax-highlighting purposes, <abbr><span class="acronym">SQL</span></abbr> comments may be used within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
sections (but <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> comments cannot be used within <abbr><span class="acronym">SQL</span></abbr>).
Since <code>a -- b</code> is legitimate <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, it would need to be rewritten with a space
between the minus signs, or as <code>a + b</code>, to avoid being interpreted as a
comment.


</p>
<p>Otherwise-arbitrary <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> script is allowed within (tag-delimited) <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
Evaluation of such <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> script takes place in a temporary child environment of the
calling environment.
The final result of that evaluation is then pasted into the surrounding
<abbr><span class="acronym">SQL</span></abbr>, before its submission.
This mechanism cannot be used to insert additional tags into the <abbr><span class="acronym">SQRL</span></abbr>
script.
</p>



<h3>Script #04 (R, out of SQL)</h3>

<pre>
&lt;R&gt;
  threshold &lt;- 9000
  sq &lt;- function(x) paste0("'", x, "'")
&lt;do&gt; -- This tag terminates the R section.

&lt;R&gt;
  if (!exists("date", inherits = FALSE))
    date &lt;- format(Sys.Date(), "%Y-%m-%d");
; -- This semicolon terminates the R section.

select * from database.table
where event_date = &lt;R&gt; sq(date) &lt;/R&gt;
and event_size &gt; &lt;R&gt; threshold &lt;/R&gt;
</pre>


<h4>Commentary on Script #04</h4>

<p>As in scripts #02 and #03, when an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section ends with <code>&lt;/R&gt;</code>, the result
of evaluating that section is pasted into the surrounding <abbr><span class="acronym">SQL</span></abbr> (or
implied <abbr><span class="acronym">SQL</span></abbr>, if those surroundings are blank).
However, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section can also be terminated by a <code>&lt;do&gt;</code> tag, or by a
non-syntactical semicolon (that being one with nothing but whitespace between it
and the previous semicolon, newline, or <code>&lt;R&gt;</code> tag).
Such sections are evaluated in the same way as those ending in <code>&lt;/R&gt;</code> tags,
but the results are not pasted into <abbr><span class="acronym">SQL</span></abbr>.
These sections can only appear between, not within, <abbr><span class="acronym">SQL</span></abbr> statements.
</p>
<p>In this script, the first out-of-<abbr><span class="acronym">SQL</span></abbr> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section defines a numerical
constant, and also a function for wrapping strings in single quotes.
The second out-of-<abbr><span class="acronym">SQL</span></abbr> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section supplies a default value for a
variable, <var>date</var>, if none was explicitly passed in (see
<code>sqrlUsage</code>).
These two <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections could be combined into one.
The function and values from these sections are applied in the subsequent
<abbr><span class="acronym">SQL</span></abbr>.
</p>



<h3>Script #05 (Temporary Parameter Settings)</h3>

<pre>
&lt;with&gt;
  na.strings = c('NA', "-")   -- comment
  x &lt;- 5; max = x + 1         /* comment */
  verbose = TRUE               # comment
  as.is = "configfile.txt"     # read from file
&lt;/with&gt;

-- Run this query with the above settings.
select * from database.table
</pre>


<h4>Commentary on Script #05</h4>

<p>Tags <code>&lt;with&gt;</code> and <code>&lt;/with&gt;</code> delimit special-purpose blocks of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
They are used to set temporary parameter values, which remain in effect only
for the duration of the script.
To be clear, temporary values survive beyond the <code>&lt;/with&gt;</code> tag, but not
beyond the end of the script.
The exception is that temporary values of <var>ping</var> are retained if and only if
the connection would otherwise be left open without a defined <var>ping</var>.
</p>
<p>This mechanism only works for a limited number of parameters:
<var>aCollapse</var>, <var>as.is</var>, <var>buffsize</var>, <var>dec</var>, <var>errors</var>,
<var>lCollapse</var>, <var>max</var>, <var>na.strings</var>, <var>nullstring</var>, <var>ping</var>,
<var>pwd</var>, <var>retry</var>, <var>scdo</var>, <var>stringsAsFactors</var>, and <var>verbose</var>.
</p>



<h3>Script #06 (Procedural Language Blocks)</h3>

<pre>
select 1 from dual; -- This semicolon terminates the statement.

declare
  x integer := 0;
begin
  for i in 1..10 loop
    x := x + 1;
    if x &gt; 7 then
      x := 0;
    else
      begin
        null;
      end;
    end if;
  end loop;
end; -- This semicolon terminates the block.

select 2 as N from dual
</pre>


<h4>Commentary on Script #06</h4>

<p>As with statement-terminating semicolons (refer to script #01), the <span class="pkg">SQRL</span>
parser attempts to identify procedural-language block-terminating semicolons,
and submits each such block as those semicolons are encountered.
The parser also submits (when necessary) upon reaching the end of the script.
Although trailing semicolons are not usually mandatory for <abbr><span class="acronym">SQL</span></abbr>
statements, they usually are mandatory at the end of a procedural block.
</p>
<p>If you have a script that came with forward-slashes, /, at the end
of procedural blocks, those slashes will normally need to be removed (as, say,
‘<span class="file">SQL Developer</span>’ would do for you).
</p>
<p>When a script contains multiple statements and/or blocks, only the final result
is returned.
In this case, that would be <code>data.frame(N = 2L)</code>.
</p>



<h3>Script #07 (Parser Control)</h3>

<pre>
-- Change parser to fallback mode.
&lt;with&gt;
  scdo = FALSE
&lt;/with&gt;

-- An outside-of-SQL R section.
&lt;R&gt;
  N &lt;- 2;
&lt;do&gt; -- This tag terminates the section.

-- The default (scdo = TRUE) SQRL parser would
-- not find the end of this procedural block.
begin
  null;
end /**/ ;
&lt;do&gt; -- This tag terminates the block.

select 1 from dual; -- Semicolon ignored.
&lt;do&gt; -- This tag terminates the statement.

select &lt;R&gt; N &lt;/R&gt; from dual
</pre>


<h4>Commentary on Script #07</h4>

<p>While the parser detects terminal semicolons at the ends of <abbr><span class="acronym">SQL</span></abbr>
statements and <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections, it remains unsophisticated, and ignorant of
<abbr><span class="acronym">DBMS</span></abbr>-specific procedural-language syntaxes.
That being the case, if you are working with procedural-language extensions to
<abbr><span class="acronym">SQL</span></abbr>, sooner or later the parser will fail to detect the end of a
block.
Presently, a simple thing that causes this is the presence of a comment between
an <code>end</code> and its semicolon (as appears, above).
</p>
<p>Setting the <var>scdo</var> parameter to FALSE causes the parser to ignore semicolons
and to conclude (out of <abbr><span class="acronym">SQL</span></abbr>) <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections, <abbr><span class="acronym">SQL</span></abbr> statements,
and procedural blocks only upon encountering a <code>&lt;do&gt;</code> tag.
This provides a robust multi-statement capability when need be, but will
require appropriate modification of any scripts originally developed for some
other application.
</p>
<p>Note that <code>&lt;do&gt;</code> tags function irrespective of the <var>scdo</var> setting.
That being the case, the use of these can be preferable to semicolons when
a <abbr><span class="acronym">SQRL</span></abbr> script is developed from scratch.
When <var>scdo</var> is <code>TRUE</code>, and a terminating semicolon is followed by a
<code>&lt;do&gt;</code> tag, with nothing but whitespace between them, they are treated as a
single <code>&lt;do&gt;</code> (only one submission is made).
An implied <code>do</code> tag exists at the end of every script.
</p>



<h3>Script #08 (Manipulation of Results)</h3>

<pre>
select
  calDate, Snowfall
from
  Weather.SparseDailySnowfall
where
  calYear = &lt;R&gt; year &lt;/R&gt;

-- Submit the above, assign the result to 'a',
-- and immediately begin an R section.
&lt;result -&gt; var&gt;

  names(var)[names(var) == "calDate"] &lt;- "Date"
  var$Snowfall &lt;- as.numeric(var$Snowfall)
  first &lt;- as.Date(paste(year, 1, 1, sep = "-"))
  last &lt;- as.Date(paste(year, 12, 31, sep = "-"))
  alldates &lt;- data.frame(Date = seq(first, last, 1))
  merge(alldates, var, all.x = TRUE)
</pre>


<h4>Commentary on Script #08</h4>

<p>A <code>&lt;result&gt;</code> tag acts as a combination of the <code>&lt;do&gt;</code> and <code>&lt;R&gt;</code>
tags, wherein the result of the query is assigned to an object within the
working (script evaluation) environment.
Any syntactically valid <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> variable name could be used in place of <var>var</var>.
Whilst the main tag is not case sensitive, the name of the variable is.
</p>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section begins immediately after the <code>&lt;result&gt;</code> tag.
This can be useful when preferred <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> column names are reserved <abbr><span class="acronym">SQL</span></abbr>
keywords (such as “date”), when dates come back in unconventional
formats (and need conversion), when strict type-conversion control is required
(typically in combination with <code>as.is = TRUE</code>), or when data is sparse
(zero-valued entries are not stored) and results need to be expanded to
explicitly include the implied zero-valued data.
The net effect is a single script, combining <abbr><span class="acronym">SQL</span></abbr> data extraction with
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> reformatting.
</p>
<p>Using “null” or “NULL” as the variable name stops assignment of
the query result (but the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section still begins).
</p>
<p>Only the final value of any <abbr><span class="acronym">SQRL</span></abbr> script is returned.
In this example, that value is the merged data frame.
</p>
<p>Note that <code>&lt;result&gt;</code> tags cannot be used to conclude <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
Also, <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections beginning with <code>&lt;result&gt;</code> tags cannot end in <code>&lt;/R&gt;</code>.
</p>
<p>When <var>scdo</var> is <code>TRUE</code>, and a terminating semicolon is followed by a
<code>&lt;result&gt;</code> tag, with nothing but whitespace between them, they are treated
as a single <code>&lt;result&gt;</code> tag (only one query submission is made).
However, when a <code>&lt;do&gt;</code> tag is followed by a <code>&lt;result&gt;</code> tag, two
submissions are made, irrespective of <var>scdo</var>.
First, the query before the <code>&lt;do&gt;</code> is submitted, and then the (blank) query
between the <code>&lt;do&gt;</code> and the <code>&lt;return&gt;</code>.
In <span class="pkg">SQRL</span>, blank queries (blank <abbr><span class="acronym">SQL</span></abbr> statements) are always
allowed, and return no value.
</p>



<h3>Script #09 (Feedback of Intermediate Results)</h3>

<pre>
select distinct customer_number from our.customers
where town in (&lt;R&gt; paste0("'", towns, "'") &lt;/R&gt;)

&lt;result -&gt; z&gt;; -- Same thing as &lt;result -&gt; z&gt;&lt;do&gt;

select sum(transactions) from online.orders
where customer_number in (&lt;R&gt; z$customer_number &lt;/R&gt;)
</pre>


<h4>Commentary on Script #09</h4>

<p>This script takes one parameter, <var>towns</var>, a character vector.
By default, atomic vectors are pasted into <abbr><span class="acronym">SQL</span></abbr> as comma-separated
values.
The first query returns a data frame, which we save, as <var>z</var>, but have no
need to manipulate.
Its (integer-valued) <var>customer_number</var> column is then applied to the second
query, once again as comma-separated values.
Only the final result (of the second query) is returned.
</p>
<p>Of course, this particular example could instead have been implemented with a
join, or temp table.
</p>
<p>The pasting behaviour of atomic objects is controlled by the <var>aCollapse</var>
parameter.
Similarly, the pasting behaviour of list-like objects is controlled by the
<var>lCollapse</var> parameter (which defaults to the empty string).
To restore <span class="pkg">SQRL</span>-0.6.3 pasting rules, insert
<code>&lt;with&gt; aCollapse = "\n"; lCollapse = ", " &lt;/with&gt;</code> at the top of a script.
See <code>sqrlUsage</code> and <code>sqrlParams</code> for further detail.
</p>



<h3>Script #10 (Combining Data Sources)</h3>

<pre>
&lt;R&gt;
  n &lt;- OtherSource("select distinct customer_number ",
                   "from our.customers where town in "
                   "(" paste0("'", towns, "'") ")")
&lt;do&gt;

select sum(transactions) from online.orders
where customer_number in (&lt;R&gt; n$customer_number &lt;/R&gt;)
</pre>


<h4>Commentary on Script #10</h4>

<p>This is a repeat of script #09, except now the tables of the first and second
queries are hosted on two entirely separate data sources.
The function <code>OtherSource</code> is the <span class="pkg">SQRL</span> interface to the data source
of the first query, while this script should be run from the interface to the
final source.
Again, there are other ways to do this, but the general idea is for the main <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
script (performing the modelling and analysis) to make a single call
“get me this data”, without clutter, or concern for the true horror of
where that data comes from.
</p>



<h3>Script #11 (The sqrl Function)</h3>

<pre>
&lt;R&gt;
  -- Check this is the intended source.
  stopifnot(sqrl("name") == "MySource")

  -- Remember initial parameter values.
  initials &lt;- sqrl("settings")

  -- Set some parameter values.
  sqrl(stringsAsFactors = FALSE,
       wintitle = "[MySource]",
       visible = TRUE)
;

-- Submit the query, record the result.
select * from database.table
&lt;result -&gt; out&gt;;

&lt;R&gt;
  -- Restore initial parameter values.
  sqrl(initials)

  -- Return the query result.
  out
</pre>


<h4>Commentary on Script #11</h4>

<p>The function <code>sqrl(...)</code> is a special interface that is automatically
defined into the temporary script-evaluation (working) environment.
It acts as a cut-down <code>sqrlAll</code>, relaying its
arguments only to whichever <span class="pkg">SQRL</span> data source is executing the script.
It works even when the name of the invoking interface function changes, or
when that interface function does not exist.
Consequently, <code>sqrl</code> should be adopted in preference to hard-coding
interface names into scripts.
</p>
<p>Here, the <code>sqrl</code> function is first used to provide an assert, which, in
this case, verifies the script is being run only on the intended data source.
A second call then takes a snapshot of the current <span class="pkg">RODBC</span>/<span class="pkg">SQRL</span>
parameter settings (the <code>settings</code> command is described in
<code>sqrlUsage</code>).
A third call then sets new values for three of those parameters, prior to
submission of the <abbr><span class="acronym">SQL</span></abbr> query.
</p>
<p>Due to <span class="pkg">SQRL</span>'s set-and-forget approach, these values are persistent, and
(unless they are changed again) will remain in effect after execution of the
script has completed.
That being the case, another call of <code>sqrl</code> is made after the query, in
order to restore the original parameter values.
</p>
<p>Note that (temporary) parameter values set via <code>&lt;with&gt; ... &lt;/with&gt;</code> take
precedence over (persistent) values set via <code>sqrl(...)</code>, irrespective of
the order in which those settings are made within the script.
Also, whilst (for example) <code>sqrl(max = 1)</code> sets the persistent value for
parameter <var>max</var>, <code>sqrl("max")</code> returns the value currently in effect
(which might be a temporary value).
Hence, for purposes of setting script-specific parameter values, using
<code>&lt;with&gt;</code> is, when possible, generally preferable to calling <code>sqrl</code>.
</p>
<p>As shown in script #17, the <code>sqrl</code> function can also be used to make nested
queries (its arguments could just as easily be another script).
</p>
<p>When a script is being run from some particular interface, explicit calls to
that same interface function (as opposed to <code>sqrl</code>) are normally blocked.
Calls to <code>sqrlAll</code>, <code>sqrlInterface</code>,
<code>sqrlOff</code>, <code>sqrlSource</code>, and <code>sqrlSources</code>
are also normally blocked.
If you really want a way around these blocks, calls can be made to
<code>SQRL::sqrlAll</code>, instead of just <code>sqrlAll</code>, and so on.
Alternatively, <code>&lt;R&gt; rm("sqrlAll") &lt;do&gt;</code> (et cetera) removes the block (this
also works for unblocking the interface function).
</p>



<h3>Script #12 (Closing Connections)</h3>

<pre>
-- Ensure readOnlyOptimise is TRUE.
&lt;R&gt;
  if (!sqrl("readOnlyOptimize"))
  {
    sqrl("close")
    sqrl(readOnlyOptimize = TRUE)
  }
&lt;do&gt;

-- Pull data (reopening is automatic).
select * from database.table;

-- Close the connection.
&lt;close&gt;
</pre>


<h4>Commentary on Script #12</h4>

<p>Many communications parameters are “locked while open”, and cannot be
changed while a connection (channel) exists to the source (see
<code>sqrlParams</code>).
In this example, we want a particular value for one such parameter, namely
<var>readOnlyOptimize</var>.
If its value needs changing, we must first ensure the channel is closed.
Within the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section, this is achieved with <code>sqrl("close")</code> (see
<code>sqrlUsage</code>).
</p>
<p>When the <abbr><span class="acronym">SQL</span></abbr> query is submitted, <span class="pkg">SQRL</span> will automatically open a
new connection, if need be.
</p>
<p>After the data is pulled, the <code>&lt;close&gt;</code> tag closes the channel (because, in
this example, we do not want to leave it open).
Unlike <code>&lt;R&gt;sqrl("close")&lt;do&gt;</code>, <code>&lt;close&gt;</code> tags return no value of their
own, which means the final value of this <abbr><span class="acronym">SQRL</span></abbr> script is still that of
the query (as we require).
</p>
<p>Be aware that <code>&lt;close&gt;</code> does not imply <code>&lt;do&gt;</code>, and it is an error to
use <code>&lt;close&gt;</code> in the presence of partially-formed, or unsubmitted,
<abbr><span class="acronym">SQL</span></abbr>.
Conversely, <code>&lt;R&gt;sqrl("close")&lt;/R&gt;</code> is allowed within <abbr><span class="acronym">SQL</span></abbr>.
</p>
<p>An alternative to putting <code>&lt;close&gt;</code> at the end of a script is to set the
<var>autoclose</var> parameter to <code>TRUE</code> (see <code>sqrlParams</code>).
Placing <code>&lt;close&gt;</code> at the beginning of a script can be used to ensure no
temporary tables are in existence (when no better mechanism is available).
</p>
<p>When user-input is required for authentication on the opening of a new channel,
connection closures should be kept to a bare minimum.
</p>



<h3>Script #13 (Returns)</h3>

<pre>
-- This selects 1 (the result of the embedded R expression).
select &lt;R&gt; return(1); 2 &lt;/R&gt;

-- This return doesn't exit the script either (only the R section).
&lt;R&gt;
  return(1)
  print("this won't be printed")
&lt;do&gt;

-- Pull from a temporary table, and save the result.
select some_columns from temp_table
&lt;result -&gt; a&gt;;

-- Drop the temp table (this returns a value).
drop temp_table;

-- Return the value of interest (exit the script).
&lt;return (a)&gt;

-- This is unreachable.
select 1
</pre>


<h4>Commentary on Script #13</h4>

<p>The difference between a <code>&lt;return (a)&gt;</code> and <code>&lt;R&gt;return(a)&lt;do&gt;</code>, is
that the former exits the <abbr><span class="acronym">SQRL</span></abbr> script, while the latter only exits
from the (embedded) <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section (back into <abbr><span class="acronym">SQL</span></abbr>), before continuing with
the script.
</p>
<p>Almost any valid <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expression is allowed between the (mandatory) parentheses of
a <code>&lt;return&gt;</code> tag (see script #03).
Note that <code>&lt;return&gt;</code> tags are not recognised within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
Also, <code>&lt;return&gt;</code> tags do not imply <code>&lt;do&gt;</code>, and it is an error to
attempt a <code>&lt;return&gt;</code> within partially-formed (unsubmitted) <abbr><span class="acronym">SQL</span></abbr>.
Because <code>x &lt;- y</code> returns invisibly, so too do <code>&lt;R&gt; x &lt;- y &lt;do&gt;</code> and
<code>&lt;return (x &lt;- y)&gt;</code> (see example script #16).
</p>
<p>The next example shows how <code>&lt;return&gt;</code> tags become much more useful when
combined with conditional expressions.
</p>



<h3>Script #14 (If, Else If, Else)</h3>

<pre>
-- Submit this when we have a 9-digit code.
&lt;if (nchar(code) == 9)&gt;
  select category from item_category
  where long_item_code = &lt;R&gt; code &lt;/R&gt;
  &lt;result -&gt; k&gt; k &lt;- as.integer(k) &lt;do&gt;

-- Submit this when we have a 6-digit code.
&lt;else if (nchar(code) == 6)&gt;
  select category from item_category
  where short_item_code = &lt;R&gt; code &lt;/R&gt;
  &lt;result -&gt; k&gt; k &lt;- as.integer(k) &lt;do&gt;

-- Exit here when we have neither
-- (because the next query would fail).
&lt;else&gt;
  &lt;return (NULL)&gt;
&lt;/if&gt;

-- Obtain all items in the same category,
-- in the original (long or short) format.
select
  category,
  &lt;if (nchar(code) == 9)&gt;
    long_item_code
  &lt;else&gt;
    short_item_code
  &lt;/if&gt;
from item_category
where category = &lt;R&gt; k &lt;/R&gt;
</pre>


<h4>Commentary on Script #14</h4>

<p>In this example, we have a table of (say) stock items, each of which has both a
long (9 digit) and short (6 digit) identity code, and is assigned to some kind
of category (with another integer identifier).
The script takes a single integer argument, <var>code</var>, which might be in either
the long or short format.
</p>
<p>The <code>&lt;if&gt;</code> and <code>&lt;else if&gt;</code> tags are used to submit an appropriate
query, according to the type of identity code supplied.
In the event that the code is of an unrecognised type, the <code>&lt;else&gt;</code> tag is
used, with <code>&lt;return&gt;</code>, to exit cleanly (without submitting any query).
Provided that the code is of a recognised type, a second query is submitted,
wherein <code>&lt;if&gt;</code> and <code>&lt;else&gt;</code> control which column is selected.
</p>
<p>In the final query, the appropriate column could instead have been named from
within <code>&lt;R&gt;</code> and <code>&lt;/R&gt;</code> tags, but the earlier conditional submission
and conditional return cannot easily be achieved in that way.
Essentially arbitrary <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is allowed between the (mandatory) parentheses of an
<code>&lt;if&gt;</code> or <code>&lt;else if&gt;</code> tag (see script #03), but the final result of
evaluating that <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> must be either <code>TRUE</code> or <code>FALSE</code>.
None of these tags are recognised within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
To enable their intra-statement application (as in the final query of the
example script), none of these tags imply <code>&lt;do&gt;</code>.
The space in <code>else if</code> is optional (i.e., <code>elseif</code> is equally valid).
</p>



<h3>Script #15 (Caching)</h3>

<pre>
-- If we already have a cached copy of the
-- data, return that.
&lt;if (exists(.cached, .GlobalEnv))&gt;
  &lt;return (get(.cached, .GlobalEnv))&gt;
&lt;/if&gt;

-- Otherwise, submit the query and cache the
-- result before returing it.
select * from table
&lt;result -&gt; x&gt;
  assign(.cached, x, .GlobalEnv)
  x
</pre>


<h4>Commentary on Script #15</h4>

<p>In this example, the result of a large query is cached locally, with <code>&lt;if&gt;</code>
and <code>&lt;return&gt;</code> logic being used to return that cached result should the
script be run again.
</p>
<p>This is most useful when the data changes infrequently, the query takes a long
time to run, and the script is stored as a procedure in the library (see script
#18).
</p>



<h3>Script #16 (While Loops)</h3>

<pre>
&lt;R&gt;
  batch &lt;- split(ID, ceiling(seq_along(ID) / 1000))
  x &lt;- NULL
  i &lt;- 1
&lt;do&gt;

-- Pull and accumulate results, a thousand at a time.
&lt;while (i &lt;= length(batch))&gt;
  select idnumber, name from identity_lookup
  where idnumber in (&lt;R&gt; batch[[i]] &lt;/R&gt;)
  &lt;result -&gt; y&gt;
    i &lt;- i + 1
    x &lt;- rbind(x, y)
  &lt;do&gt;
&lt;/while&gt;
</pre>


<h4>Commentary on Script #16</h4>

<p>In this example, we have a script with a single argument; <code>ID</code>, a vector of
integer codes.
Supposing that vector might be too long for the <abbr><span class="acronym">SQL</span></abbr> <code>in</code>
operator, a <code>&lt;while&gt;</code> loop is used to pull the results in batches.
</p>
<p>Essentially arbitrary <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is allowed between the (mandatory) parentheses of a
<code>&lt;while&gt;</code> tag (see script #03), but the final result of evaluating it must
be either <code>TRUE</code> or <code>FALSE</code>.
As with the <code>&lt;if&gt;</code> family, <code>&lt;while&gt;</code> and <code>&lt;/while&gt;</code> tags are not
recognised within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections, and do not imply <code>&lt;do&gt;</code>.
Ordinarily, loops over <abbr><span class="acronym">SQL</span></abbr> should be avoided, or used only as a last
resort, but there are use-cases (see script #18), including for the insertion of
rows.
</p>
<p>Referring back to script #13, the final result of script #16 (that of
<code>x &lt;- rbind(x, y)</code>) is invisible.
If visible output is required, <code>&lt;R&gt;x</code> or <code>&lt;return (x)&gt;</code> could be
appended to the script.
</p>
<p>The parser is simple, and does not verify or enforce correct nesting structure.
Unintuitive output may appear when nesting violations occur.
</p>



<h3>Script #17 (Procedures)</h3>

<pre>
&lt;proc "random patients"&gt;
  select patient_number
    from patient_details
    order by rand()
    limit &lt;R&gt; N &lt;/R&gt;
  &lt;result -&gt; a&gt;
    a[, 1L]
&lt;/proc&gt;

select days_in_hospital
from patient_history
where patient_number in
  (&lt;R&gt; sqrl("random patients", N = 200) &lt;/R&gt;)
</pre>


<h4>Commentary on Script #17</h4>

<p>It is possible to define reusable <abbr><span class="acronym">SQRL</span></abbr> procedures within (between)
<code>&lt;proc&gt;</code> and <code>&lt;/proc&gt;</code> tags.
Here, a (parameterised) procedure is employed as a nested-query alternative to
the sequential feedback mechanism of script #09.
</p>
<p>Each procedure must be named (in its <code>&lt;proc&gt;</code> tag), with quotes (either
single or double) being mandatory about that name.
The end of a procedure definition acts in the same way as the end of a script
(as an implied <code>&lt;do&gt;</code>).
Note that <code>&lt;/proc&gt;</code> tags are only recognised within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections, when (as
is the case in this example) the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section is within a procedure definition
(i.e., under a <code>&lt;proc&gt;</code> tag).
Opening <code>&lt;proc&gt;</code> tags are never recognised within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
</p>



<h3>Script #18 (Libraries)</h3>

<pre>
&lt;proc "add na.strings"&gt;
  -- Takes one argument, 'add' (a character vector),
  -- and adds its strings to the na.strings parameter.
  &lt;R&gt;
    sqrl(na.strings = unique(c(sqrl("na.strings"), add)))
  &lt;do&gt;
&lt;/proc&gt;

&lt;proc "drop if exists"&gt;
  /* Takes one argument, 'tables', being a
     character vector of tables to be dropped. */
  -- Force as.is to be TRUE (for the query).
  &lt;with&gt;
    as.is = TRUE
  &lt;/with&gt;
  -- Pull details of temporary tables.
  help volatile table
  &lt;result -&gt; v&gt;
  &lt;do&gt;
  -- Exit here when the above query did not return
  -- a data frame (when no volatile table exists).
  &lt;if (class(v) != class(data.frame()))&gt;
    &lt;return (invisible())&gt;
  &lt;/if&gt;
  -- Extract the names of all volatile tables
  -- in existence, retain only those (unique)
  -- tables to be dropped that actually exist,
  -- and initialise the iterator.
  &lt;R&gt;
    volatiles &lt;- as.character(v[, "Table SQL Name"])
    tables &lt;- unique(tables[tables %in% volatiles])
    i &lt;- 0L
  &lt;do&gt;
  -- Drop each requested table (that exists).
  &lt;while (i &lt;- i + 1L; i &lt;= length(tables))&gt;
    drop table &lt;R&gt; tables[i] &lt;/R&gt; &lt;do&gt;
  &lt;/while&gt;
  -- Return invisible NULL.
  &lt;return (invisible())&gt;
&lt;/proc&gt;
</pre>


<h4>Commentary on Script #18</h4>

<p>The previous example, script #17, exhibited a procedure defined as a utility
within a larger <abbr><span class="acronym">SQRL</span></abbr> script.
Such definitions are not persistent, with the procedures vanishing upon the
conclusion of their parent script.
</p>
<p>However, as shown in <code>sqrlUsage</code>, it is possible to construct a
persistent library of procedures.
As is the case above, <abbr><span class="acronym">SQRL</span></abbr> scripts intended for libraries must
consist only of procedure definitions; no other <abbr><span class="acronym">SQL</span></abbr> or <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is allowed.
This example script defines two procedures (both parameterised).
The first, “add na.strings”, adds strings to the existing
<var>na.strings</var> vector (refer to <code>sqrlParams</code>).
The second, “drop if exists”, implements that capability for Teradata
<abbr><span class="acronym">SQL</span></abbr> (which doesn't).
</p>
<p>Following <code>sqrlUsage</code>, let's say the above script is recorded in a
file ‘<span class="file">library.sqrl</span>’, and that we have a <span class="pkg">SQRL</span> interface function
called <code>owl</code>.
The library is then established with <code>owl(library = "library.sqrl")</code>, and
the procedures are called with (for instance)
<code>owl("add na.strings", add = c("N/A", "-"))</code>, and
<code>owl("drop if exists", tables = c("tableA", "tableB"))</code>.
</p>
<p>Ultimately, procedures do not confer any capability beyond that of
<abbr><span class="acronym">SQRL</span></abbr> files.
Procedure libraries merely allow the consolidation of multiple files into one.
They also offer another slight advantage in that when you change working
directory, they come along.
</p>



<h3>Script #19 (Stop)</h3>

<pre>
select 1

-- This ends the script.
&lt;stop&gt;

-- This is unreachable.
select 2
</pre>


<h4>Commentary on Script #19</h4>

<p>Lastly, <code>&lt;stop&gt;</code> tags act as an early end-of-script (with its implied
<code>&lt;do&gt;</code>).
They apply within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections, as well as <abbr><span class="acronym">SQL</span></abbr>, and even on the inside
of a <code>FALSE</code> conditional block (i.e., the <code>&lt;stop&gt;</code> still functions in
<code>&lt;if (FALSE)&gt;&lt;R&gt;&lt;stop&gt;</code>).
They are intended as a troubleshooting aid.
</p>



<h3>Summary of Tags</h3>


<dl>
<dt>
<code>&lt;R&gt;</code>:</dt>
<dd>
<p>Begins an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section (leaves <abbr><span class="acronym">SQL</span></abbr>).
Once begun, only <code>&lt;/R&gt;</code>, <code>&lt;do&gt;</code>, <code>;</code>, <code>&lt;stop&gt;</code>, <code>EOS</code>,
and <code>&lt;/proc&gt;</code> are recognised (and can end the section).
The <code>&lt;/proc&gt;</code> case is only recognised when the initiating <code>&lt;R&gt;</code> tag is
within a procedure definition (beneath a <code>&lt;proc&gt;</code> tag).
</p>
</dd>
<dt>
<code>&lt;/R&gt;</code>:</dt>
<dd>
<p>Ends an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section, causing that section to be evaluated.
The result of that evaluation is pasted back into the surrounding <abbr><span class="acronym">SQL</span></abbr>.
</p>
</dd>
<dt>
<code>&lt;do&gt;</code>:</dt>
<dd>
<p>If inside an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section, ends and evaluates that section (without pasting the
result back into <abbr><span class="acronym">SQL</span></abbr>).
If outside of an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section, causes the preceding <abbr><span class="acronym">SQL</span></abbr> (which may be
blank) to be submitted.
</p>
</dd>
<dt>
<code>&lt;result -&gt; name&gt;</code>:</dt>
<dd>
<p>Submits the preceding <abbr><span class="acronym">SQL</span></abbr>, and assigns the result of that submission
to the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> variable <code>name</code>.
Any syntactically valid <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> name, or “NULL”, is allowed (in place of
<code>name</code>).
An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section begins immediately after the tag.
That section concludes with any of the tags listed (above) for <code>&lt;R&gt;</code>,
besides <code>&lt;/R&gt;</code>.
</p>
</dd>
<dt>
<code>&lt;close&gt;</code>:</dt>
<dd>
<p>Closes the <abbr><span class="acronym">ODBC</span></abbr> channel (connection) to the data source.
</p>
</dd>
<dt>
<code>&lt;return (Rexp)&gt;</code>:</dt>
<dd>
<p>Evaluates <code>Rexp</code>, which can be any <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expression, and returns the resulting
value (exits the script).
The parentheses are mandatory.
</p>
</dd>
<dt>
<code>&lt;with&gt;</code>:</dt>
<dd>
<p>Begins a special <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section, for assigning temporary values to
<span class="pkg">RODBC</span>/<span class="pkg">SQRL</span> parameters.
Once begun, only <code>&lt;/with&gt;</code>, <code>&lt;stop&gt;</code>, <code>EOS</code>, and <code>&lt;/proc&gt;</code>
are recognised (and can end the section).
The <code>&lt;/proc&gt;</code> case is only recognised when the initiating <code>&lt;with&gt;</code> tag
lies within a procedure definition (beneath a <code>&lt;proc&gt;</code> tag).
Only the <var>aCollapse</var>, <var>as.is</var>, <var>buffsize</var>, <var>dec</var>, <var>errors</var>,
<var>lCollapse</var>, <var>max</var>, <var>na.strings</var>, <var>nullstring</var>, <var>ping</var>,
<var>pwd</var>, <var>retry</var>, <var>scdo</var>, <var>stringsAsFactors</var>, and <var>verbose</var>
parameters permit temporary value assignments.
</p>
</dd>
<dt>
<code>&lt;/with&gt;</code>:</dt>
<dd>
<p>Ends an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> section begun by <code>&lt;with&gt;</code>.
Causes the section to be evaluated, and assigns temporary parameter values
accordingly.
</p>
</dd>
<dt>
<code>&lt;if (Rexp)&gt;</code>:</dt>
<dd>
<p>Evaluates <code>Rexp</code>, which can be any <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expression.
If that expression evaluated to <code>TRUE</code>, the (arbitrary) script beneath the
tag is acted upon.
If that expression evaluated to <code>FALSE</code>, the (arbitrary) script beneath the
tag is ignored (except for any <code>&lt;stop&gt;</code> tags).
The parentheses are mandatory.
</p>
</dd>
<dt>
<code>&lt;else if (Rexp)&gt;</code>:</dt>
<dd>
<p>Acts as <code>&lt;if (Rexp)&gt;</code>, when the (mandatory) previous <code>&lt;if ((Rexp)&gt;</code>,
and all the (multiple, optional) previous <code>&lt;else if (Rexp)&gt;</code> tags,
evaluated to <code>FALSE</code>.
Otherwise (when any of those evaluated to <code>TRUE</code>), acts as
<code>&lt;if (FALSE)&gt;</code>.
The parentheses are mandatory.
</p>
</dd>
<dt>
<code>&lt;else&gt;</code>:</dt>
<dd>
<p>Acts as <code>&lt;else if (TRUE)&gt;</code>.
</p>
</dd>
<dt>
<code>&lt;/if&gt;</code>:</dt>
<dd>
<p>Marks the end of an <code>&lt;if (Rexp)&gt;</code> - <code>&lt;else if (Rexp)&gt;</code> - <code>&lt;else&gt;</code>
flow-control structure.
</p>
</dd>
<dt>
<code>&lt;while (Rexp)&gt;</code>:</dt>
<dd>
<p>Acts in the manner of <code>&lt;if (Rexp)&gt;</code>.
The parentheses are mandatory.
</p>
</dd>
<dt>
<code>&lt;/while&gt;</code>:</dt>
<dd>
<p>Marks the end of a <code>&lt;while (Rexp)&gt;</code> flow-control loop.
If the previous <code>&lt;while (Rexp)&gt;</code> evaluated to <code>TRUE</code>, the parser
returns to that <code>&lt;while (Rexp)&gt;</code> tag, and re-evaluates the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expression.
Otherwise (if the previous <code>&lt;while (Rexp)&gt;</code> evaluated to <code>FALSE</code>), no
action is performed (the parser continues from this point).
</p>
</dd>
<dt>
<code>&lt;proc "name"&gt;</code>:</dt>
<dd>
<p>Marks the beginning of the definition of a procedure called <var>name</var>.
Any character string can be used in place of <var>name</var>.
The quotation marks are mandatory (but can be singles or doubles).
</p>
</dd>
<dt>
<code>&lt;/proc&gt;</code>:</dt>
<dd>
<p>Marks the end of a procedure definition (acts as an <var>EOS</var> for that
procedure).
</p>
</dd>
<dt>
<code>&lt;stop&gt;</code>:</dt>
<dd>
<p>Acts as <var>EOS</var>.
Applies even from within a <code>FALSE</code> conditional block.
Intended for debugging, only.
</p>
</dd>
<dt>
<code>;</code>:</dt>
<dd>
<p>When the <var>scdo</var> parameter is at its default value of <code>TRUE</code> (see
<code>sqrlParams</code>), the <abbr><span class="acronym">SQRL</span></abbr> parser attempts to identify
<abbr><span class="acronym">SQL</span></abbr> statement terminating semicolons, procedural language block
terminating semicolons, and any extra semicolons within <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sections.
When detected, these all act as <code>&lt;do&gt;</code>.
</p>
</dd>
<dt>
<var>EOS</var>:</dt>
<dd>
<p>The end of the script (<var>EOS</var>), acts as <code>&lt;do&gt;</code>.
As necessary, it also acts as <code>&lt;/if&gt;</code> and <code>&lt;/proc&gt;</code> (it does not act
as <code>&lt;/while&gt;</code>).
</p>
</dd>
</dl>
<h3>Note</h3>

<p>The <var>verbose</var> parameter toggles extended output when running scripts (see
<code>sqrlParams</code>).
This includes the display of intermediate values.
</p>


<h3>See Also</h3>

<p><code>sqrlUsage</code>
</p>


</div>