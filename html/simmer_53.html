<div class="container">

<table style="width: 100%;"><tr>
<td>monitor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a Monitor</h2>

<h3>Description</h3>

<p>Methods for creating <code>monitor</code> objects for simulation environments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">monitor(name, xptr, get_arrivals, get_attributes, get_resources,
  handlers = NULL, finalizer = NULL)

monitor_mem()

monitor_delim(path = tempdir(), keep = FALSE, sep = " ", ext = ".txt",
  reader = read.delim, args = list(stringsAsFactors = FALSE))

monitor_csv(path = tempdir(), keep = FALSE, reader = read.csv,
  args = list(stringsAsFactors = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>an identifier to show when printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xptr</code></td>
<td>
<p>an external pointer pointing to a C++ object derived from the
abstract class simmer::Monitor. See C++ API for further details and, in
particular, the <code>simmer/monitor.h</code> header.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_arrivals</code></td>
<td>
<p>a function to retrieve the arrivals tables. It must accept
the <code>xptr</code> as a first argument, even if it is not needed, and a boolean
<code>per_resource</code> as a second argument (see <code>get_mon_arrivals</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_attributes</code></td>
<td>
<p>a function to retrieve the attributes table. It must accept
the <code>xptr</code> as a first argument, even if it is not needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_resources</code></td>
<td>
<p>a function to retrieve the resources table. It must accept
the <code>xptr</code> as a first argument, even if it is not needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handlers</code></td>
<td>
<p>an optional list of handlers that will be stored in a slot of
the same name. For example, <code>monitor_mem</code> does not use this slot, but
<code>monitor_delim</code> and <code>monitor_csv</code> store the path to the created files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finalizer</code></td>
<td>
<p>an optional one-argument function to be called when the
object is destroyed. For example, <code>monitor_mem</code> does not require any
finalizer, but <code>monitor_delim</code> and <code>monitor_csv</code> use this to remove
the created files when the monitor is destroyed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>directory where files will be created (must exist).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>whether to keep files on exit. By default, files are removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>separator character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ext</code></td>
<td>
<p>file extension to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reader</code></td>
<td>
<p>function that will be used to read the files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>a list of further arguments for <code>reader</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>monitor</code> method is a generic function to instantiate a
<code>monitor</code> object. It should not be used in general unless you want to
extend <code>simmer</code> with a custom monitor.
</p>
<p>The in-memory monitor is enabled by default (<code>memory_mem</code>),
and it should the fastest.
</p>
<p>For large simulations, or if the RAM footprint is an issue, you may
consider monitoring to disk. To that end, <code>monitor_delim</code> stores the values
in flat delimited files. The usual <code>get_mon_*</code> methods retrieve
data frames from such files using the <code>reader</code> provided. By default,
<code>read.delim</code> is used, but you may consider using faster
alternatives from other packages. It is also possible to <code>keep</code> the
files in a custom directory to read and post-process them in a separate
workflow.
</p>
<p><code>monitor_csv</code> is a special case of <code>monitor_delim</code> with
<code>sep=","</code> and <code>ext=".csv"</code>.
</p>


<h3>Value</h3>

<p>A <code>monitor</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">mon &lt;- monitor_csv()
mon

env &lt;- simmer(mon=mon) %&gt;%
  add_generator("dummy", trajectory() %&gt;% timeout(1), function() 1) %&gt;%
  run(10)
env

read.csv(mon$handlers$arrivals) # direct access
get_mon_arrivals(env)           # adds the "replication" column

</code></pre>


</div>