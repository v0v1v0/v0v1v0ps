<div class="container">

<table style="width: 100%;"><tr>
<td>spMisalignLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for fitting multivariate Bayesian spatial regression
models to misaligned data</h2>

<h3>Description</h3>

<p>The function <code>spMisalignLM</code> fits Gaussian multivariate Bayesian
spatial regression models to misaligned data. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">spMisalignLM(formula, data = parent.frame(), coords, 
      starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression models to be fit. See example below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>spMisalignLM</code> is called.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>a list of <code class="reqn">q</code> <code class="reqn">n_i \times 2</code>
matrices of the observation coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) where <code class="reqn">i=(1,2,\ldots,q)</code>. . </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>a list with tags corresponding to <code>A</code>,
<code>phi</code>, <code>nu</code>, and <code>Psi</code>. The value portion of each tag is a vector
that holds the parameter's starting values.
</p>
<p><code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and holds the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix.
</p>
<p><code>phi</code> and <code>nu</code> are
of length <code class="reqn">q</code>. The vector of residual variances <code>Psi</code> is also of length <code class="reqn">q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning</code></td>
<td>
<p>a list with tags <code>A</code>, <code>phi</code>, <code>nu</code>, and <code>Psi</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution.
<code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and <code>Psi</code>,
<code>phi</code>, and <code>nu</code> are of length <code class="reqn">q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>a list with tags <code>beta.flat</code>, <code>K.iw</code>, <code>Psi.ig</code>, <code>phi.unif</code>
and <code>nu.unif</code>. The hyperparameters of the inverse-Wishart for
the cross-covariance matrix <code class="reqn">K=AA'</code> are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively.  The inverse-Gamma hyperparameters for the non-spatial
residual variances are specified as a list <code>Psi.ig</code> of length two with the first and second list elements consisting of
vectors of the <code class="reqn">q</code> <em>shape</em> and <em>scale</em> hyperparameters,
respectively. The hyperparameters of the Uniform <code>phi.unif</code>,
and <code>nu.unif</code> are also passed as a list of vectors with the first
and second list elements corresponding to the lower and upper
support, respectively. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.report</code></td>
<td>
<p>the interval to report Metropolis acceptance and MCMC progress. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>


<h3>Value</h3>

<p>An object of class <code>spMisalignLM</code>, which is a list with the following
tags:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively</p>
</td>
</tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825–848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and B.D. Cook. (2014) Bayesian hierarchical models for spatially misaligned data. <em>Methods in Ecology and Evolution</em>, 5:514–523.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873–2884.
</p>
<p>Finley, A.O., S. Banerjee, A.R. Ek, and R.E. McRoberts. (2008) Bayesian multivariate process modeling for prediction of forest attributes. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 13:60–83.
</p>


<h3>See Also</h3>

<p><code>spMvLM</code><code>spMisalignGLM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##generate some data
n &lt;- 100 ##number of locations
q &lt;- 3 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##parameters for generating a multivariate spatial GP covariance matrix
theta &lt;- rep(3/0.5,q) ##spatial decay

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,1,-1,1,0.5,0.25)
K &lt;- A%*%t(A)
K ##spatial cross-covariance
cov2cor(K) ##spatial cross-correlation

C &lt;- mkSpCov(coords, K, diag(0,q), theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C) ##spatial random effects

w.a &lt;- w[seq(1,length(w),q)]
w.b &lt;- w[seq(2,length(w),q)]
w.c &lt;- w[seq(3,length(w),q)]

##covariate portion of the mean
x.a &lt;- cbind(1, rnorm(n))
x.b &lt;- cbind(1, rnorm(n))
x.c &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.a, x.b, x.c))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B.3 &lt;- c(-1,-1)
B &lt;- c(B.1, B.2, B.3)

Psi &lt;- c(0.1, 0.1, 0.1) ##non-spatial residual variance, i.e., nugget

y &lt;- rnorm(n*q, x%*%B+w, rep(sqrt(Psi),n))

y.a &lt;- y[seq(1,length(y),q)]
y.b &lt;- y[seq(2,length(y),q)]
y.c &lt;- y[seq(3,length(y),q)]

##subsample to make spatially misaligned data
sub.1 &lt;- 1:50
y.1 &lt;- y.a[sub.1]
w.1 &lt;- w.a[sub.1]
coords.1 &lt;- coords[sub.1,]
x.1 &lt;- x.a[sub.1,]

sub.2 &lt;- 25:75
y.2 &lt;- y.b[sub.2]
w.2 &lt;- w.b[sub.2]
coords.2 &lt;- coords[sub.2,]
x.2 &lt;- x.b[sub.2,]

sub.3 &lt;- 50:100
y.3 &lt;- y.c[sub.3]
w.3 &lt;- w.c[sub.3]
coords.3 &lt;- coords[sub.3,]
x.3 &lt;- x.c[sub.3,]

##call spMisalignLM
q &lt;- 3
A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]
n.samples &lt;- 5000

starting &lt;- list("phi"=rep(3/0.5,q), "A"=A.starting, "Psi"=rep(1,q))
tuning &lt;- list("phi"=rep(0.5,q), "A"=rep(0.01,length(A.starting)), "Psi"=rep(0.1,q))
priors &lt;- list("phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)), "Psi.ig"=list(rep(2,q), rep(0.1,q)))

m.1 &lt;- spMisalignLM(list(y.1~x.1-1, y.2~x.2-1, y.3~x.3-1), 
                    coords=list(coords.1, coords.2, coords.3),
                    starting=starting, tuning=tuning, priors=priors, 
                    n.samples=n.samples, cov.model="exponential", n.report=100)

burn.in &lt;- floor(0.75*n.samples)

plot(m.1$p.theta.samples, density=FALSE)

##recover regression coefficients and random effects
m.1 &lt;- spRecover(m.1, start=burn.in)

round(summary(m.1$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)
round(summary(m.1$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)

##predict for all locations, i.e., observed and not observed
out &lt;- spPredict(m.1, start=burn.in, thin=10, pred.covars=list(x.a, x.b,
x.c), 
                 pred.coords=list(coords, coords, coords))

##summary and check
quants &lt;- function(x){quantile(x, prob=c(0.5,0.025,0.975))}

y.hat &lt;- apply(out$p.y.predictive.samples, 1, quants)

##unstack and plot
y.a.hat &lt;- y.hat[,1:n]
y.b.hat &lt;- y.hat[,(n+1):(2*n)]
y.c.hat &lt;- y.hat[,(2*n+1):(3*n)]

par(mfrow=c(1,3))
plot(y.a, y.a.hat[1,], xlab="Observed y.a", ylab="Fitted &amp; predicted y.a",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.a[-sub.1], y.a.hat[1,-sub.1], y.a[-sub.1], y.a.hat[2,-sub.1], length=0.02, angle=90)
arrows(y.a[-sub.1], y.a.hat[1,-sub.1], y.a[-sub.1], y.a.hat[3,-sub.1], length=0.02, angle=90)
lines(range(y.a), range(y.a))

plot(y.b, y.b.hat[1,], xlab="Observed y.b", ylab="Fitted &amp; predicted y.b",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.b[-sub.2], y.b.hat[1,-sub.2], y.b[-sub.2], y.b.hat[2,-sub.2], length=0.02, angle=90)
arrows(y.b[-sub.2], y.b.hat[1,-sub.2], y.b[-sub.2], y.b.hat[3,-sub.2], length=0.02, angle=90)
lines(range(y.b), range(y.b))

plot(y.c, y.c.hat[1,], xlab="Observed y.c", ylab="Fitted &amp; predicted y.c",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.c[-sub.3], y.c.hat[1,-sub.3], y.c[-sub.3], y.c.hat[2,-sub.3], length=0.02, angle=90)
arrows(y.c[-sub.3], y.c.hat[1,-sub.3], y.c[-sub.3], y.c.hat[3,-sub.3], length=0.02, angle=90)
lines(range(y.c), range(y.c))

## End(Not run)
</code></pre>


</div>