<div class="container">

<table style="width: 100%;"><tr>
<td>set</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sets</h2>

<h3>Description</h3>

<p>Creation and manipulation of sets.</p>


<h3>Usage</h3>

<pre><code class="language-R">set(...)
as.set(x)
make_set_with_order(x)
is.set(x)

set_is_empty(x)
set_is_subset(x, y)
set_is_proper_subset(x, y)
set_is_equal(x, y)
set_contains_element(x, e)

set_union(...)
set_intersection(...)
set_symdiff(...)
set_complement(x, y)
set_cardinality(x)
## S3 method for class 'set'
length(x)
## S3 method for class 'set'
lengths(x, use.names = TRUE)
set_power(x)
set_cartesian(...)
set_combn(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For <code>as.set()</code> and <code>is.set()</code>:
an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object. A set object otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A set object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.names</code></td>
<td>
<p>logical; should the names of <code>x</code> be used in the result?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>set()</code>: <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects, and set objects otherwise.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions represent basic infrastructure for handling sets
of general (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) objects. The <code>set_is_<var>foo</var>()</code> predicates
are vectorized. In addition
to the methods defined, one can use the following operators:
<code>|</code> for the union,
<code>-</code> for the difference (or complement), <code>&amp;</code> for the
intersection, <code>%D%</code> for the symmetric difference,
<code>*</code> and <code>^<var>n</var></code> for the
(<code class="reqn">n</code>-fold) cartesian product, <code>2^</code> for the power set,
<code>%e%</code> for the element-of predicate,
<code>&lt;</code> and <code>&lt;=</code> for
the (proper) subset predicate, <code>&gt;</code> and <code>&gt;=</code> for
the (proper) superset predicate, and <code>==</code> and <code>!=</code> for
(in)equality. The <code>length</code> method for sets gives the
cardinality. The <code>lengths</code> method coerces the set to a list
before applying the <code>length</code> method on its elements.
<code>set_combn</code> returns the set of all
subsets of specified length. The <code>Summary</code> methods do also work if
defined for the set elements. The <code>mean</code> and
<code>median</code>
methods try to convert the object to a numeric vector before calling
the default methods.
</p>
<p>Because set elements are unordered, it is not allowed to use
<em>positional</em> indexing. However, it is possible to
do indexing using element labels or
simply the elements themselves (useful, e.g., for subassignment).
In addition, it is possible to iterate over
<em>all</em> elements using <code>for</code> and <code>lapply</code>/<code>sapply</code>.
</p>
<p>Note that converting objects to sets may change the internal order
of the elements, so that iterating over the original data
might give different results than iterating over the corresponding
set. The permutation can be obtained using the generic function
<code>make_set_with_order</code>, returning both the set and the ordering.
<code>as.set</code> simply calls
<code>make_set_with_order</code> internally and strips the order
information, so user-defined
methods for coercion have to be provided for the latter and not for
<code>as.set</code>.
</p>
<p>Note that <code>set_union</code>, <code>set_intersection</code>, and
<code>set_symdiff</code> accept any number of arguments. The <code class="reqn">n</code>-ary
symmetric difference of sets contains
just elements which are in an odd number of the sets.
</p>
<p><code>set_contains_element</code> is vectorized in <code>e</code>, that is, if <code>e</code>
is an atomic vector or list, the is-element operation is performed
element-wise, and a logical vector returned. Note that, however,
objects of class <code>tuple</code> are taken as atomic objects to
correctly handle sets of tuples.
</p>


<h3>Value</h3>

<p>For the predicate functions, a vector of logicals.
For <code>make_set_with_order</code>,
a list with two components <code>"set"</code> and <code>"order"</code>. For
<code>set_cardinality</code> and the length method, an integer value.
For the <code>lengths</code> method, an integer vector. For all
others, a set.
</p>


<h3>References</h3>

<p>D. Meyer and K. Hornik (2009),
Generalized and customizable sets in R,
<em>Journal of Statistical Software</em> <b>31</b>(2), 1–27.
<a href="https://doi.org/10.18637/jss.v031.i02">doi:10.18637/jss.v031.i02</a>.
</p>


<h3>See Also</h3>

<p><code>set_outer</code>,
<code>gset</code> for generalized sets,
and <code>tuple</code> for tuples (“vectors”).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## constructor
s &lt;- set(1L, 2L, 3L)
s

## named elements
snamed &lt;- set(one = 1, 2, three = 3)
snamed

## indexing by label
snamed[["one"]]

## subassignment
snamed[c(2,3)] &lt;- c("a","b")
snamed

## a more complex set
set(c, "test", list(1, 2, 3))

## converter
s2 &lt;- as.set(2:5)
s2

## converter with order
make_set_with_order(5:1)

## set of sets
set(set(), set(1))

## cartesian product
s * s2
s * s
s ^ 2 # same as above
s ^ 3

## power set
2 ^ s

## tuples
s3 &lt;- set(tuple(1,2,3), tuple(2,3,4))
s3

## Predicates:

## element
1:2 %e% s
tuple(1,2,3) %e% s3

## subset
s &lt;= s2
s2 &gt;= s # same

## proper subset
s &lt; s

## complement, union, intersection, symmetric difference:
s - set(1L)
s + set("a") # or use: s | set("a")
s &amp; s
s %D% s2
set(1,2,3) - set(1,2)
set_intersection(set(1,2,3), set(2,3,4), set(3,4,5))
set_union(set(1,2,3), set(2,3,4), set(3,4,5))
set_symdiff(set(1,2,3), set(2,3,4), set(3,4,5))

## subsets:
set_combn(as.set(1:3),2)

## iterators:
sapply(s, sqrt)
for (i in s) print(i)

## Summary methods
sum(s)
range(s)

## mean / median
mean(s)
median(s)

## cardinality
s &lt;- set(1, list(1, 2))
length(s)
lengths(s)

## vectorization
list(set(1), set(2), set()) == set(1)
</code></pre>


</div>