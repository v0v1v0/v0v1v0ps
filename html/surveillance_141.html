<div class="container">

<table style="width: 100%;"><tr>
<td>find.kh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine the k and h values in a standard normal setting</h2>

<h3>Description</h3>

<p>Given a specification of the average run length in the (a)cceptance
and (r)ejected setting determine the k and h values in a standard
normal setting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  find.kh(ARLa = 500, ARLr = 7, sided = "one", method = "BFGS", verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ARLa</code></td>
<td>
<p>average run length in acceptance setting, aka. in control state. Specifies the number of observations before false alarm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ARLr</code></td>
<td>
<p>average run length in rejection state, aka. out of control state. Specifies the number of observations before an increase is detected (i.e. detection delay)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p>one-sided cusum scheme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Which method to use in the function <code>optim</code>. Standard choice is BFGS, but in some situation Nelder-Mead can be advantageous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>gives extra information about the root finding process</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions from the <span class="pkg">spc</span> package are used in a simple univariate
root finding problem.
</p>


<h3>Value</h3>

<p>Returns a list with reference value k and decision interval h.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("spc")) {
    find.kh(ARLa=500,ARLr=7,sided="one")
    find.kh(ARLa=500,ARLr=3,sided="one")
}
</code></pre>


</div>