<div class="container">

<table style="width: 100%;"><tr>
<td>corassign</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group assignment that is correlated with latent factors.</h2>

<h3>Description</h3>

<p>We extract latent factors from the log of <code>mat</code> using an SVD, then
generate an underlying group-assignment variable from a conditional
normal distribution (conditional on the latent factors). This underlying
group-assignment variable is used to assign groups.
</p>


<h3>Usage</h3>

<pre><code class="language-R">corassign(mat, nfac = NULL, corvec = NULL, return = c("group", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A matrix of count data. The rows index the individuals and
the columns index the genes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfac</code></td>
<td>
<p>The number of latent factors. If <code>NULL</code>, then we will
use the method of Onatski (2010) to choose the number of latent factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corvec</code></td>
<td>
<p>The vector of correlations. <code>corvec[i]</code> is the correlation
between latent factor <code>i</code> and the underlying group-assignment variable.
You can think of the correlations in <code>corvec</code> as a kind of "tetrachoric
correlation." If <code>NULL</code>, then it assumes independence between
factors and group assignment. Note that the correlations of the
latent factors with the observed group-assignment vector (instead of the
latent group-assignment vector) will be <code>corvec * sqrt(2 / pi)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p>What should we return? Just the group assignment
(<code>"group"</code>) or a list of a bunch of things (<code>"full"</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>nfac</code> is provided, then <code>corvec</code> must be the same length as <code>nfac</code>.
If <code>nfac</code> is not provided, then it is assumed that the first <code>nfac</code>
elements of <code>corvec</code> are the underlying correlations, if <code>nfac</code> turns out to be
smaller than the length of <code>corvec</code>. If <code>nfac</code> turns
out to be larger than the length of <code>corvec</code>, then the factors without
defined correlations are assumed to have correlation 0.
</p>


<h3>Value</h3>

<p>A list with some or all of the following elements:
</p>

<dl>
<dt><code>x</code></dt>
<dd>
<p>The vector of group assignments. <code>0L</code> indicates
membership to one group and <code>1L</code> indicates membership to
the other group.</p>
</dd>
<dt><code>nfac</code></dt>
<dd>
<p>The number of assumed latent factors.</p>
</dd>
<dt><code>facmat</code></dt>
<dd>
<p>A matrix, whose columns contain the latent factors.</p>
</dd>
<dt><code>groupfac</code></dt>
<dd>
<p>The underlying group-assignment factor.</p>
</dd>
<dt><code>corvec</code></dt>
<dd>
<p>The correlation vector. Note that this is the
correlation between random variables observed in <code>groupfac</code>
and <code>facmat</code>, </p>
</dd>
</dl>
<p>If <code>return = "group"</code>, then the list only contains <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul><li> <p>A. Onatski (2010), Determining the number of factors from empirical distribution of eigenvalues. The Review of Economics and Statistics 92(4).
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 1000
ngene &lt;- 10
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 50), nrow = ngene)

## Set target correlation to be 0.9 and nfac to be 1
corvec &lt;- 0.9
nfac   &lt;- 1

## Group assignment
cout &lt;- corassign(mat    = t(Y),
                  nfac   = nfac,
                  corvec = corvec,
                  return = "full")

## Correlation between facmat and groupfac should be about 0.9
cor(cout$facmat, cout$groupfac)

## Correlation between facmat and x should be about 0.9 * sqrt(2 / pi)
cor(cout$facmat, cout$x)
corvec * sqrt(2 / pi)


</code></pre>


</div>