<div class="container">

<table style="width: 100%;"><tr>
<td>CgmmParametersEstim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate parameters of stable laws using a Cgmm method
</h2>

<h3>Description</h3>

<p>Estimate the four parameters of stable laws using generalised method
of moments based on a continuum of complex moment conditions (Cgmm)
due to Carrasco and Florens.  Those moments are computed by matching
the characteristic function with its sample counterpart. The resulting
(ill-posed) estimation problem is solved by a regularisation
technique.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CgmmParametersEstim(x, type = c("2S", "IT", "Cue"), alphaReg = 0.01,
                    subdivisions = 50,
                    IntegrationMethod = c("Uniform", "Simpson"),
                    randomIntegrationLaw = c("unif", "norm"),
                    s_min = 0, s_max = 1,
                    theta0 = NULL,
                    IterationControl = list(),
                    pm = 0, PrintTime = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Data used to perform the estimation: a vector of length n.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Cgmm algorithm: <code>"2S"</code> is the two steps GMM proposed by
Hansen(1982).  <code>"Cue"</code> and <code>"IT"</code> are respectively the
continuous updated and the iterative GMM proposed by Hansen, Eaton
et Yaron (1996) and adapted to the continuum case.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaReg</code></td>
<td>

<p>Value of the regularisation parameter; numeric, default = 0.01.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivisions</code></td>
<td>

<p>Number of subdivisions used to compute the different
integrals involved in the computation of the objective function (to
minimise); numeric.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IntegrationMethod</code></td>
<td>

<p>Numerical integration method to be used to approximate the
(vectorial) integrals. Users can choose between <code>"Uniform"</code>
discretization or the <code>"Simpson"</code>'s rule (the 3-point
Newton-Cotes quadrature rule).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomIntegrationLaw</code></td>
<td>

<p>Probability measure associated to the Hilbert space spanned by the
moment conditions. See Carrasco and Florens (2003) for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_min,s_max</code></td>
<td>

<p>Lower and Upper bounds of the interval where the
moment conditions are considered; numeric.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>

<p>Initial guess for the 4 parameters values: vector of length 4.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IterationControl</code></td>
<td>

<p>Only used with <code>type = "IT"</code> or <code>type = "Cue"</code> to control the
iterations, see Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pm</code></td>
<td>

<p>Parametrisation, an integer (0 or 1); default: <code>pm = 0</code> (Nolan's
‘S0’ parametrisation).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PrintTime</code></td>
<td>

<p>Logical flag; if set to TRUE, the estimation duration is printed out to
the screen in a readable format (h/min/sec).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments to be passed to the optimisation function and/or to
the integration function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>The moment conditions</b>

The moment conditions are given by:
</p>
<p style="text-align: center;"><code class="reqn">g_t(X,\theta)=g(t,X;\theta)= e^{itX} - \phi_{\theta}(t)</code>
</p>

<p>If one has a sample <code class="reqn">x_1,\dots,x_n</code> of i.i.d realisations of the
same random variable <code class="reqn">X</code>, then: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_n(t,\theta)  = \frac{1}{n}\sum_{i=1}^n g(t,x_i;\theta) =  \phi_n(t) -\phi_\theta(t),</code>
</p>

<p>where <code class="reqn">\phi_n(t)</code> is the eCF associated with the sample
<code class="reqn">x_1,\dots,x_n</code>, defined by <code class="reqn">\phi_n(t)= \frac{1}{n}
    \sum_{j=1}^n e^{itX_j}</code>.

<b>Objective function</b>

</p>
<p>Following Carrasco et al. (2007, Proposition 3.4),
the objective function to minimise is given by:
</p>
<p style="text-align: center;"><code class="reqn">obj(\theta)=\overline{\underline{v}^{\prime}}(\theta)[\alpha_{Reg} \mathcal{I}_n+C^2]^{-1}\underline{v}(\theta)</code>
</p>

<p>where:
</p>

<dl>
<dt>
<code class="reqn">\underline{v} = [v_1,\ldots,v_n]^{\prime}</code>;</dt>
<dd>
<p><code class="reqn">v_i(\theta)
	= \int_I \overline{g_i}(t;\hat{\theta}^1_n) \hat{g}(t;\theta) \pi(t) dt</code>.
</p>
</dd>
<dt><code class="reqn">I_n</code></dt>
<dd>
<p>is the identity matrix of size <code class="reqn">n</code>.</p>
</dd>
<dt><code class="reqn">C</code></dt>
<dd>
<p>is a <code class="reqn">n \times n</code> matrix with <code class="reqn">(i,j)</code>th
element given by
<code class="reqn">c_{ij} = \frac{1}{n-4}\int_I
	\overline{g_i}(t;\hat{\theta}^1_n) g_j(t;\hat{\theta}^1_n)
	\pi(t) dt</code>.
</p>
</dd>
</dl>
<p>To compute <code class="reqn">C</code> and <code class="reqn">v_i()</code> we will use the function
<code>IntegrateRandomVectorsProduct</code>.

<b>The IterationControl</b>

If <code>type = "IT"</code> or <code>type = "Cue"</code>, the user can control
each iteration using argument <code>IterationControl</code>, which should be
a <code>list</code> which contains the following elements:
</p>

<dl>
<dt>
<code>NbIter</code>:</dt>
<dd>
<p>maximum number of iterations.
The loop stops when <code>NBIter</code> is reached; default = 10.
</p>
</dd>
<dt>
<code>PrintIterlogical</code>:</dt>
<dd>
<p>if set to TRUE the values of the
current parameter estimates are printed to the screen at each
iteration; default = TRUE.
</p>
</dd>
<dt>
<code>RelativeErrMax</code>:</dt>
<dd>
<p>the loop stops if the relative error
between two consecutive estimation steps is smaller then
<code>RelativeErrMax</code>; default = 1e-3.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Estim</code></td>
<td>
<p>output of the optimisation function,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duration</code></td>
<td>
<p>estimation duration in numerical format,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>character</code> describing the method used.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><code>nlminb</code> as used to minimise the Cgmm objective function.
</p>


<h3>References</h3>

<p>Carrasco M, Florens J (2000).
“Generalization of GMM to a continuum of moment conditions.”
<em>Econometric Theory</em>, <b>16</b>(06), 797–834.
</p>
<p>Carrasco M, Florens J (2002).
“Efficient GMM estimation using the empirical characteristic function.”
<em>IDEI Working Paper</em>, <b>140</b>.
</p>
<p>Carrasco M, Florens J (2003).
“On the asymptotic efficiency of GMM.”
<em>IDEI Working Paper</em>, <b>173</b>.
</p>
<p>Carrasco M, Chernov M, Florens J, Ghysels E (2007).
“Efficient estimation of general dynamic models with a continuum of moment conditions.”
<em>Journal of Econometrics</em>, <b>140</b>(2), 529–573.
</p>
<p>Carrasco M, Kotchoni R (2010).
“Efficient estimation using the characteristic function.”
Mimeo. University of Montreal.
</p>


<h3>See Also</h3>

<p><code>Estim</code>,
<code>GMMParametersEstim</code>,
<code>IntegrateRandomVectorsProduct</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## general inputs
theta &lt;- c(1.45, 0.55, 1, 0)
pm &lt;- 0
set.seed(2345)
x &lt;- rstable(50, theta[1], theta[2], theta[3], theta[4], pm)

## GMM specific params
alphaReg &lt;- 0.01
subdivisions &lt;- 20
randomIntegrationLaw &lt;- "unif"
IntegrationMethod &lt;- "Uniform"

## Estimation
twoS &lt;- CgmmParametersEstim(x = x, type = "2S", alphaReg = alphaReg, 
                          subdivisions = subdivisions, 
                          IntegrationMethod = IntegrationMethod, 
                          randomIntegrationLaw = randomIntegrationLaw, 
                          s_min = 0, s_max = 1, theta0 = NULL, 
                          pm = pm, PrintTime = TRUE)
twoS
</code></pre>


</div>