<div class="container">

<table style="width: 100%;"><tr>
<td>snowfall-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Toplevel useability wrapper for snow to make parallel programming even
more easy and comfortable.
All functions are able to run without cluster in sequential mode.
Also snowfall works as connector to the cluster management
program sfCluster, but can also run without it.</h2>

<h3>Description</h3>

<p><span class="pkg">snowfall</span> is designed to make setup and usage of <span class="pkg">snow</span> more
easier. It also is made ready to work together with <code>sfCluster</code>,
a ressource management and runtime observation tool for
R-cluster usage.
</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> snowfall</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.61</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2008-11-01</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Initialisation</h3>

<p>Initalisation via <code>sfInit</code> must be called
before the usage
of any of the <span class="pkg">snowfall</span> internal functions. <code>sfStop</code> stopps
the current cluster. Some additional functions give access to build-in
functions (like <code>sfParallel</code>, <code>sfCpus</code> etc.).
</p>


<h3>Calculations</h3>

<p>The are plenty of function to execute parallel
calculations via <span class="pkg">snowfall</span>. Most of them are wrappers to the
according <span class="pkg">snow</span> functions, but there are additional functions as
well. Most likely the parallel versions of the R-buildin applies are
interesting: <code>sfLapply</code>, <code>sfSapply</code> and <code>sfApply</code>. For
better cluster take a look at the load balanced
<code>sfClusterApplyLB</code> and the function with restore possibilities:
<code>sfClusterApplySR</code>.
</p>


<h3>Tools</h3>

<p>Various tools allow an easier access to parallel
computing: <code>sfLibrary</code> and <code>sfSource</code> for loading code on
the cluster, <code>sfExport</code>, <code>sfExportAll</code>, <code>sfRemoveAll</code>
and <code>sfRemoveAll</code> for variable sperading on the cluster. And some
more.
</p>


<h3>sfCluster</h3>

<p><span class="pkg">snowfall</span> is also the R-connector to the
cluster management program <code>sfCluster</code>. Mostly all of the
communication to this tool is done implicit and directly affecting the
initialisation via <code>sfInit</code>. Using <code>sfCluster</code> makes the
parallel programming with <span class="pkg">snowfall</span> even more practicable in real
life environments.
</p>
<p>For futher informations about the usage of <code>sfCluster</code> look at
its documentation.
</p>


<h3>Author(s)</h3>

<p>Jochen Knaus
</p>
<p>Maintainer:
Jochen Knaus &lt;jo@imbi.uni-freiburg.de&gt;,
</p>


<h3>References</h3>

<p><span class="pkg">snow</span> (Simple Network of Workstations):<br>
http://cran.r-project.org/src/contrib/Descriptions/snow.html<br><br></p>
<p><code>sfCluster</code> (Unix management tool for <span class="pkg">snowfall</span> clusters):<br>
http://www.imbi.uni-freiburg.de/parallel<br></p>


<h3>See Also</h3>

<p>Snowfall Initialisation: <code>snowfall-init</code><br>
Snowfall Calculation: <code>snowfall-calculation</code><br>
Snowfall Tools: <code>snowfall-tools</code><br></p>
<p>Optional links to other man pages, e.g. <code>snow-cluster</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  # Init Snowfall with settings from sfCluster
  ##sfInit()

  # Init Snowfall with explicit settings.
  sfInit( parallel=TRUE, cpus=2 )

  if( sfParallel() )
    cat( "Running in parallel mode on", sfCpus(), "nodes.\n" )
  else
    cat( "Running in sequential mode.\n" )

  # Define some global objects.
  globalVar1 &lt;- c( "a", "b", "c" )
  globalVar2 &lt;- c( "d", "e" )
  globalVar3 &lt;- c( 1:10 )
  globalNoExport &lt;- "dummy"

  # Define stupid little function.
  calculate &lt;- function( x ) {
    cat( x )
    return( 2 ^ x )
  }

  # Export all global objects except globalNoExport
  # List of exported objects is listed.
  # Work both parallel and sequential.
  sfExportAll( except=c( "globalNoExport" ) )

  # List objects on each node.
  sfClusterEvalQ( ls() )

  # Calc something with parallel sfLappy
  cat( unlist( sfLapply( globalVar3, calculate ) ) )

  # Remove all variables from object.
  sfRemoveAll( except=c( "calculate" ) )

## End(Not run)
</code></pre>


</div>