<div class="container">

<table style="width: 100%;"><tr>
<td>spread3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An alternative spread function, conceived for insects</h2>

<h3>Description</h3>

<p>This is built with <code>spread2()</code> and is still experimental.
This one differs from other attempts in that it treats the advection and
dispersal as mathematical vectors that are added together.
They are "rounded" to pixel centres.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spread3(
  start,
  rasQuality,
  rasAbundance,
  advectionDir,
  advectionMag,
  meanDist,
  dispersalKernel = "exponential",
  sdDist = 1,
  plot.it = 2,
  minNumAgents = 50,
  verbose = getOption("LandR.verbose", 0),
  saveStack = NULL,
  skipChecks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Raster indices from which to initiate dispersal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rasQuality</code></td>
<td>
<p>A raster with habitat quality. Currently, must
be scaled from 0 to 1, i.e., a probability of "settling"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rasAbundance</code></td>
<td>
<p>A raster where each pixel represents the number
of "agents" or pseudo-agents contained. This number of agents, will
be spread horizontally, and distributed from each pixel
that contains a non-zero non NA value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>advectionDir</code></td>
<td>
<p>A single number or <code>RasterLayer</code> in degrees from North = 0
(though it will use radians if all values are <code style="white-space: pre;">⁠abs(advectionDir) &gt; 2 * pi)⁠</code>.
This indicates the direction of advective forcing (i.e., wind).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>advectionMag</code></td>
<td>
<p>A single number or <code>RasterLayer</code> in distance units of the
<code>rasQuality</code>, e.g., meters, indicating the relative forcing that will
occur. It is imposed on the total event, i.e., if the <code>meanDist</code> is
<code>10000</code>, and <code>advectionMag</code> is <code>5000</code>, then the expected
distance (i.e., <code style="white-space: pre;">⁠63%⁠</code> of agents) will have settled by <code>15000</code> map units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanDist</code></td>
<td>
<p>A single number indicating the mean distance parameter in map units
(not pixels), for a negative exponential distribution
dispersal kernel (e.g., <code>dexp</code>). This will mean that <code style="white-space: pre;">⁠63%⁠</code> of agents will have
settled at this <code>meanDist</code> (still experimental).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersalKernel</code></td>
<td>
<p>One of either <code>"exponential"</code> or <code>"weibull"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdDist</code></td>
<td>
<p>A single number indicating the <code>sd</code> parameter of a two-parameter
<code>dispersalKernel</code>.
Defaults to <code>1</code>, which is the same as the <code>exponential</code> distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>Numeric. With increasing numbers above 0, there will be plots
produced during iterations. Currently, only 0, 1, or 2+ are distinct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minNumAgents</code></td>
<td>
<p>Single numeric indicating the minimum number of agents
to consider all dispersing finished. Default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Numeric. With increasing numbers above 0, there will be more
messages produced. Currently, only 0, 1, or 2+ are distinct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveStack</code></td>
<td>
<p>If provided as a character string, it will save each iteration
as part of a <code>rasterStack</code> to disk upon exit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skipChecks</code></td>
<td>
<p>Logical. If <code>TRUE</code>, assertions will be skipped (faster, but could miss
problems)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.table</code> with all information used during the spreading
</p>


<h3>Examples</h3>

<pre><code class="language-R">## these tests are fairly heavy, so don't run during automated tests
#########################################################
# Simple case, no variation in rasQuality, numeric advectionDir and advectionMag
#########################################################

  library(terra)

  origDTThreads &lt;- data.table::setDTthreads(2L)
  origNcpus &lt;- options(Ncpus = 2L)

  maxDim &lt;- 10000
  ras &lt;- terra::rast(terra::ext(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
  rasQuality &lt;- terra::rast(ras)
  rasQuality[] &lt;- 1
  rasAbundance &lt;- terra::rast(rasQuality)
  rasAbundance[] &lt;- 0
  # startPixel &lt;- middlePixel(rasAbundance)
  startPixel &lt;- sample(seq(terra::ncell(rasAbundance)), 30)
  rasAbundance[startPixel] &lt;- 1000
  advectionDir &lt;- 70
  advectionMag &lt;- 4 * res(rasAbundance)[1]
  meanDist &lt;- 2600

  # Test the dispersal kernel -- create a function
  plotDispersalKernel &lt;- function(out, meanAdvectionMag) {
    out[, disGroup := round(distance / 100) * 100]
    freqs &lt;- out[, .N, by = "disGroup"]
    freqs[, `:=`(cumSum = cumsum(N), N = N)]
    plot(freqs$disGroup, freqs$cumSum, # addTo = "CumulativeNumberSettled",
         main = "Cumulative Number Settled") # can plot the distance X number
    abline(v = meanAdvectionMag + meanDist)
    newTitle &lt;- "Number Settled By Distance"
    plot(freqs$disGroup, freqs$N, # addTo = gsub(" ", "", newTitle),
         main = newTitle) # can plot the distance X number
    abline(v = meanAdvectionMag + meanDist)
    # should be 0.63:
    freqs[disGroup == meanAdvectionMag + meanDist, cumSum] / tail(freqs, 1)[, cumSum]
    mtext(side = 3, paste("Average habitat quality: ",
                          round(mean(rasQuality[], na.rm = TRUE), 2)),
          outer = TRUE, line = -2, cex = 2)
  }
  out &lt;- spread3(rasAbundance = rasAbundance,
                 rasQuality = rasQuality,
                 advectionDir = advectionDir,
                 advectionMag = advectionMag,
                 meanDist = meanDist, verbose = 2,
                 plot.it = interactive())

  plotDispersalKernel(out, advectionMag)

  # The next examples are potentially time consuming; avoid on automated testing
  if (interactive()) {
    #########################################################
    ### The case of variable quality raster
    #########################################################
    rasQuality &lt;- terra::rast(system.file("extdata", "rasQuality.tif",
                                          package = "SpaDES.tools"))
    terra::crs(rasQuality) &lt;- system.file("extdata", "targetCRS.rds", package = "SpaDES.tools") |&gt;
      readRDS() |&gt;
      slot("projargs")
    mask &lt;- rasQuality &lt; 5
    rasQuality[mask[] %in% TRUE] &lt;- 0
    # rescale so min is 0.75 and max is 1
    rasQuality[] &lt;- rasQuality[] / (reproducible::maxFn(rasQuality) * 4) + 1 / 4
    rasAbundance &lt;- terra::rast(rasQuality)
    rasAbundance[] &lt;- 0
    startPixel &lt;- sample(seq(ncell(rasAbundance)), 300)
    rasAbundance[startPixel] &lt;- 1000
    advectionDir &lt;- 75
    advectionMag &lt;- 4 * res(rasAbundance)[1]
    meanDist &lt;- 2600
    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = meanDist, verbose = 2,
                   plot.it = interactive())
    if (interactive()) {
      plotDispersalKernel(out, advectionMag)
    }

    ###############################################################################
    ### The case of variable quality raster, raster for advectionDir &amp; advectionMag
    ###############################################################################
    maxDim &lt;- 10000
    ras &lt;- terra::rast(terra::ext(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
    rasQuality &lt;- terra::rast(ras)
    rasQuality[] &lt;- 1
    rasAbundance &lt;- terra::rast(rasQuality)
    rasAbundance[] &lt;- NA
    # startPixel &lt;- middlePixel(rasAbundance)
    startPixel &lt;- sample(seq(ncell(rasAbundance)), 25)
    rasAbundance[startPixel] &lt;- 1000

    # raster for advectionDir
    advectionDir &lt;- terra::rast(system.file("extdata", "advectionDir.tif",
                                            package = "SpaDES.tools"))
    crs(advectionDir) &lt;- crs(rasQuality)
    # rescale so min is 0.75 and max is 1
    advectionDir[] &lt;- advectionDir[] / (reproducible::maxFn(advectionDir)) * 180

    # raster for advectionMag
    advectionMag &lt;- terra::rast(system.file("extdata", "advectionMag.tif",
                                            package = "SpaDES.tools"))
    crs(advectionMag) &lt;- crs(rasQuality)
    # rescale so min is 0.75 and max is 1
    advectionMag[] &lt;- advectionMag[] / (reproducible::maxFn(advectionMag)) * 600

    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = meanDist, verbose = 2,
                   plot.it = interactive())

    if (interactive()) {
      names(advectionDir) &lt;- "Wind direction"
      names(advectionMag) &lt;- "Wind speed"
      names(rasAbundance) &lt;- "Initial abundances"
      terra::plot(c(advectionDir, advectionMag, rasAbundance))

      plotDispersalKernel(out, mean(advectionMag[]))
    }

    #########################################
    # save iterations to a stack to make animated GIF
    ########################################
    tmpStack &lt;- tempfile(pattern = "stackToAnimate", fileext = ".tif")
    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = 2600, verbose = 2,
                   plot.it = interactive(), saveStack = tmpStack)

    ## This animates the series of images into an animated GIF
    if (require(animation, quietly = TRUE)) {
      out2 &lt;- terra::rast(tmpStack)
      gifName &lt;- file.path(tempdir(), "animation.gif")

      # Only works on some systems; may need to configure
      # Works on Windows without system adjustments
      if (identical(.Platform$OS.type, "windows"))
        saveGIF(interval = 0.1, movie.name = gifName, expr = {
          for (i in seq(length(names(out2)))) terra::plot(out2[[i]])
        })
    }
  }

  # clean up
  data.table::setDTthreads(origDTThreads)
  options(Ncpus = origNcpus)

</code></pre>


</div>