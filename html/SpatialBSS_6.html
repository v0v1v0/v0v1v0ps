<div class="container">

<table style="width: 100%;"><tr>
<td>local_gss_covariance_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computation of Robust Local Covariance Matrices
</h2>

<h3>Description</h3>

<p><code>local_gss_covariance_matrix</code> computes generalized local sign covariance matrices for a random field based on a given set of spatial kernel matrices. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">local_gss_covariance_matrix(x, kernel_list, lcov = c('norm', 'winsor', 'qwinsor'), 
                        center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_list</code></td>
<td>

<p>a list with spatial kernel matrices of dimension <code>c(n, n)</code>. This list is usually computed with the function <code>spatial_kernel_matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcov</code></td>
<td>

<p>a string indicating which type of robust local covariance matrix to use. Either <code>'norm'</code> (default), <code>'winsor'</code> or <code>'qwinsor'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is robustly centered prior computing the local covariance matrices. Default is <code>TRUE</code>. See also <code>white_data</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Generalized local sign matrices are determined by radial functions <code class="reqn">w(l_i)</code>, where <code class="reqn">l_i = ||x(s_i)-T(x)||</code> and <code class="reqn">T(x)</code> is Hettmansperger Randles location estimator (Hettmansperger &amp; Randles, 2002), and kernel functions <code class="reqn">f(d_{i,j})</code>, where <code class="reqn">d_{i,j}=||s_i - s_j||</code>. Generalized local sign covariance (gLSCM) matrix is then calculated as
</p>
<p style="text-align: center;"><code class="reqn">gLSCM(f,w) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j})  w(l_i)w(l_j)(x(s_i)-T(x)) (x(s_j)-T(x))'</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

<p>Three radial functions <code class="reqn">w(l_i)</code> (Raymaekers &amp; Rousseeuw, 2019) are implemented, the parameter <code>lcov</code> defines which is used:
</p>

<ul>
<li> <p><code>'norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = 1/l_i </code>
</p>

</li>
<li> <p><code>'winsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q/l_i </code>
</p>

</li>
<li> <p><code>'qwinsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q^2/l_i^2.</code>
</p>

</li>
</ul>
<p>The cutoff <code class="reqn">Q</code> is defined as <code class="reqn">Q = l_{(h)}</code>, where <code class="reqn">l_{(h)}</code> is <code class="reqn">h</code>th order statistic of <code class="reqn">\{l_1, ..., l_n\}</code> and <code class="reqn">h = (n + p + 1)/2</code>. If the argument <code>center</code> equals <code>FALSE</code> then the centering in the above formula for <code class="reqn">gLSCM(f,w)</code> is not carried out. See also <code>spatial_kernel_matrix</code> for details. 
</p>


<h3>Value</h3>

<p><code>local_gss_covariance_matrix</code> returns a list with two entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cov_sp_list</code></td>
<td>

<p>List of equal length as the argument <code>kernel_list</code>. Each list entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a robust local covariance matrix. The list has the attribute <code>'lcov'</code> which equals the function argument <code>lcov</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>numeric vector of <code>length(n)</code> giving the weights for each observation for the robust local covariance estimation.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>
<p>Raymaekers, J., &amp; Rousseeuw, P. (2019). <em>A generalized spatial sign covariance matrix. Journal of Multivariate Analysis</em>, 171 , 94-111. <a href="https://doi.org/10.1016/j.jmva.2018.11.010">doi:10.1016/j.jmva.2018.11.010</a>.
</p>
<p>Sipila, M., Muehlmann, C. Nordhausen, K. &amp; Taskinen, S. (2022). <em>Robust second order stationary spatial blind source separation using generalized sign matrices</em>. Manuscript.
</p>


<h3>See Also</h3>

<p><code>spatial_kernel_matrix</code>, <code>robsbss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  
  # computing two ring kernel matrices and corresponding 
  # robust local covariance matrices using 'norm' radial function:
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = ring_kernel_list, 
                               lcov = 'norm')
    
  # computing three ball kernel matrices and corresponding 
  # robust local covariance matrices using 'winsor' radial function:
  kernel_params_ball &lt;- c(0.5, 1, 2)
  ball_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ball', kernel_params_ball)
  loc_cov_ball &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = ball_kernel_list, 
                               lcov = 'winsor')
    
  # computing three gauss kernel matrices and corresponding 
  # robust local covariance matrices using 'qwinsor' radial function:
  kernel_params_gauss &lt;- c(0.5, 1, 2)
  gauss_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)
  loc_cov_gauss &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = gauss_kernel_list, 
                               lcov = 'qwinsor')
}
</code></pre>


</div>