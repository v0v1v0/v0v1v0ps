<div class="container">

<table style="width: 100%;"><tr>
<td>pointsInPoly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finds points in a polygon</h2>

<h3>Description</h3>

<p>Given a polygon and a set of points this function returns the subset
of points that are within the polygon.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> pointsInPoly(poly, points, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p>an <code class="reqn">n\times 2</code> matrix of polygon vertices. Matrix
columns correspond to vertices' x and y coordinates, respectively. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>an <code class="reqn">m\times 2</code> matrix of points. Matrix
columns correspond to points' x and y coordinates, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently no additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is assumed that the polygon is to be closed by joining the last vertex to the first vertex.
</p>


<h3>Value</h3>

<p>If points are found with the polygon, then a vector is returned with
elements corresponding to the row indices of <code>points</code>, otherwise
<code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br>
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br></p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
##Example 1
points &lt;- cbind(runif(1000, 0, 10),runif(1000, 0, 10))

poly &lt;- cbind(c(1:9,8:1), c(1,2*(5:3),2,-1,17,9,8,2:9))

point.indx &lt;- pointsInPoly(poly, points)

plot(points, pch=19, cex=0.5, xlab="x", ylab="y", col="red")
points(points[point.indx,], pch=19, cex=0.5, col="blue")
polygon(poly)

##Example 2
##a function to partition the domain
tiles &lt;- function(points, x.cnt, y.cnt, tol = 1.0e-10){

  x.min &lt;- min(points[,1])-tol
  x.max &lt;- max(points[,1])+tol
  y.min &lt;- min(points[,2])-tol
  y.max &lt;- max(points[,2])+tol
  
  x.cnt &lt;- x.cnt+1
  y.cnt &lt;- y.cnt+1
  
  x &lt;- seq(x.min, x.max, length.out=x.cnt)
  y &lt;- seq(y.min, y.max, length.out=y.cnt)

  tile.list &lt;- vector("list", (length(y)-1)*(length(x)-1))

  l &lt;- 1
  for(i in 1:(length(y)-1)){
    for(j in 1:(length(x)-1)){
      tile.list[[l]] &lt;- rbind(c(x[j], y[i]),
                              c(x[j+1], y[i]),
                              c(x[j+1], y[i+1]),
                              c(x[j], y[i+1]))
       l &lt;- l+1
    }

  }

  tile.list
}

n &lt;- 1000
points &lt;- cbind(runif(n, 0, 10), runif(n, 0, 10))

grd &lt;- tiles(points, x.cnt=10, y.cnt=10)

plot(points, pch=19, cex=0.5, xlab="x", ylab="y")

sum.points &lt;- 0
for(i in 1:length(grd)){
  polygon(grd[[i]], border="red")
  
  point.indx &lt;- pointsInPoly(grd[[i]], points)
  
  if(!is.na(point.indx[1])){
    sum.points &lt;- length(point.indx)+sum.points
    
    text(mean(grd[[i]][,1]), mean(grd[[i]][,2]), length(point.indx), col="red")
  }
}
sum.points


## End(Not run)

</code></pre>


</div>