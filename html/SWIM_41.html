<div class="container">

<table style="width: 100%;"><tr>
<td>SWIM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SWIM: A Package for Sensitivity Analysis</h2>

<h3>Description</h3>

<p>The <code>SWIM</code> package provides weights on simulated scenarios
from a stochastic model, such that a stressed model component
(random variable) fulfil given probabilistic constraints (e.g.
specified values for risk measures), under the new scenario weights.
Scenario weights are selected by constrained minimisation of the
relative entropy or Wasserstein distance to the baseline model.
</p>


<h3>Details</h3>

<p>The <code>SWIM</code> (Scenario Weights for Importance Measurement)
package provides weights on simulated scenarios from a stochastic
model, such that stressed random variables fulfil given
probabilistic constraints (e.g. specified values for risk
measures), under the new scenario weights. Scenario weights are
selected by constrained minimisation of the relative entropy or 
Wasserstein distance to the
baseline model.
</p>
<p>The <code>SWIM</code> package is based on the <em>reverse sensitivity
framework</em> developed by (Pesenti et al. 2019) and (Pesenti 2021).
</p>
<p>Consider the random vector <code>X = (X1,...,Xn)</code>. Let P
represent the probability measure under which all simulated
scenarios have the same probability. First, take the 
approach of minimizing the relative entropy. Then, for a random variable
<code>Xi</code>, the package solves:
</p>
<p style="text-align: center;"><code class="reqn">min D(P | Q)</code>
</p>

<p>subject to constraints on the distribution
of <code>Xi</code> under <code>Q</code>,
where <code>D(P | Q)</code> is the Kullback-Leibler divergence
(relative entropy) between <code>P</code> and <code>Q</code>.
</p>
<p>The approach of minimizing the Wasserstein distance of order 2 proceeds 
as follows: Let F be the distribution function of the random variable <code>Xi</code> 
under <code>P</code>, then the package solves
</p>
<p style="text-align: center;"><code class="reqn">argmin_{G} W_{2}(G, F)</code>
</p>

<p>subject to constraints on <code>G</code>, <code>W_{2}(G, F)</code> is the 2-Wasserstein distance 
between <code>G</code> and <code>F</code>. The solution to the above minimisation problem is the 
distribution of <code>Xi</code> under <code>Q</code>. The current implementation of the Wasserstein 
approach is based on Kernel density estimation with Gaussian kernels.
</p>
<p>For both approaches, the scenario weights are then formed via the Radon-Nikodym 
derivative <code>dQ / dP</code>. The weighting generates a model for which the joint distribution 
of <code>(X1,...,Xn)</code> is stressed.
</p>
<p>Different elements of <code>X</code> can be understood as
inputs or outputs of a model. For example, consider a model
<code>Y = g(Z)</code> with input vector <code>Z = (Z1,...,Z(n-1))</code>.
One can then identify <code>X1 = Y</code> and <code>X2 = Z1,...,Xn
    = Z(n-1)</code>. Subsequently, the user of the <code>SWIM</code> package can
stress the model output or any of the inputs, measuring the
resulting impact on the distributions of other variables.
</p>


<h3>Stresses for Relative Entropy Minimization</h3>

<p>Scenario weights for the following stresses are provided:
</p>

<table>
<tr>
<td style="text-align: left;">
       <code>stress</code>
</td>
<td style="text-align: left;"> calls one of the functions below by
    using <code>type</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_VaR</code> </td>
<td style="text-align: left;"> for stressing the VaR
    (<code>type = "VaR"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_VaR_ES</code> </td>
<td style="text-align: left;"> for stressing the VaR and
    ES jointly (<code>type = "VaR ES"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_mean</code>
</td>
<td style="text-align: left;"> for stressing means
    (<code>type = "mean"</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_mean_sd</code> </td>
<td style="text-align: left;"> for stressing means and
    standard deviations (<code>type = "mean std"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_moment</code> </td>
<td style="text-align: left;"> for stressing moments
    (<code>type = "moment"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_prob</code> </td>
<td style="text-align: left;"> for stressing the probabilities
      of intervals
    (<code>type = "prob"</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_user</code> </td>
<td style="text-align: left;"> for user defined scenario weights
    (<code>type = "user"</code>) </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
</table>
<h3>Stresses for Wasserstein Distance Minimization</h3>

<p>Scenario weights for the following stresses are provided:
</p>

<table>
<tr>
<td style="text-align: left;">
      <code>stress_wass</code>
</td>
<td style="text-align: left;"> calls one of the functions below by
    using <code>type</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_RM_w</code> </td>
<td style="text-align: left;"> for stressing the distortion risk measure (RM)
    (<code>type = "RM"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_mean_sd_w</code> </td>
<td style="text-align: left;"> for stressing mean and
    standard deviation (<code>type = "mean sd"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_RM_mean_sd_w</code> </td>
<td style="text-align: left;"> for stressing the RM, mean and 
      standard deviation (<code>type = "RM mean sd"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_HARA_RM_w</code> </td>
<td style="text-align: left;"> for stressing the HARA utility and RM
    (<code>type = "HARA RM"</code>)</td>
</tr>
<tr>
<td style="text-align: left;">
      <code>stress_mean_w</code> </td>
<td style="text-align: left;"> for stressing mean (<code>type = "mean"</code>)
    </td>
</tr>
</table>
<h3>A <code>SWIM</code> object</h3>

<p>A SWIM object is generated by applying a stress function subject to a relative entropy minimisation. 
An object of class <code>SWIM</code> contains a list of:
</p>

<ul>
<li> <p><code>x</code>, a data.frame containing realisations of a random
vector;
</p>
</li>
<li> <p><code>new_weights</code>, a list, each component corresponds to
a different stress and is either a vector of scenario weights or a
function, that applied to the <code>k</code>th column of <code>x</code>,
generates the vectors of scenario weights;
</p>
</li>
<li> <p><code>type</code>: a list, each component corresponds to a
different stress and specifies the type of the stress;
</p>
</li>
<li> <p><code>specs</code>, a list, each component corresponds to
a different stress and contains a list with the specifications
of what has been stressed.
Specifications depend on the <code>type</code> of stress:
</p>

<ul>
<li> <p><code>type = "VaR"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>alpha</code>, the level of
the stressed VaR; <code>q</code>, the stressed VaR at level
<code>alpha</code>.
</p>
</li>
<li> <p><code>type = "VaR ES"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>alpha</code>, the level of the
stressed VaR and ES; <code>q</code>, the stressed VaR at level
<code>alpha</code>.
</p>
</li>
<li> <p><code>type = "mean"</code>: <code>k</code>, the columns of <code>x</code>
on which the stress is applied to; <code>new_means</code>, the
stressed means.
</p>
</li>
<li> <p><code>type = "mean sd"</code>: <code>k</code>, the columns of <code>x</code>
on which the stress is applied to; <code>new_means</code>, the
stressed means; <code>new_sd</code>, the stressed standard deviations.
<code>s</code>, the stressed ES at level <code>alpha</code>.
</p>
</li>
<li> <p><code>type = "moment"</code>: <code>f</code>, the list of functions,
that, applied to <code>x</code>, constitute the moment constraints;
<code>k</code>, the columns of <code>x</code> on which each function in
<code>f</code> operates on; <code>m</code>, the stressed moments of
<code>f(x)</code>.
</p>
</li>
<li> <p><code>type = "prob"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>lower</code>, the left
endpoints of the intervals; <code>upper</code>, the right endpoints
of the intervals; <code>prob</code>, stressed probabilities
corresponding to the intervals defined through <code>lower</code>
and <code>upper</code>.
</p>
</li>
<li> <p><code>type = "user"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to.
</p>
</li>
</ul>
</li>
</ul>
<h3>A <code>SWIMw</code> object</h3>

<p>A SWIMw object is generated by applying a stress function 
subject to a Wasserstein minimisation. The Wasserstein 
minimisation approach assumes that all model components, 
(random variables) are continuously distributed. If only 
the stressed model component is continuously distributed, 
the SWIMw stress should be converted to a SWIM object, see 
<code>convert_SWIMw_to_SWIM</code>. 
An object of class <code>SWIMw</code> contains a list of:
</p>

<ul>
<li> <p><code>x</code>, a data.frame containing realisations of a random
vector;
</p>
</li>
<li> <p><code>new_weights</code>: a list, each component corresponds to
a different stress and is either a vector of scenario weights or a
function, that applied to the <code>k</code>th column of <code>x</code>,
generates the vectors of scenario weights;
</p>
</li>
<li> <p><code>type</code>: a list, each component corresponds to a
different stress and specifies the type of the stress;
</p>
</li>
<li> <p><code>h</code>: a list, each component corresponds to a different stress
and specifies the bandwidth;
</p>
</li>
<li> <p><code>u</code>: a list, each component corresponds to a different stress
and is a vector containing the gridspace on [0, 1];
</p>
</li>
<li> <p><code>lam</code>: a list, each component corresponds to a different stress
and is vector containing the lambda's of the optimized model;
</p>
</li>
<li> <p><code>str_fY</code>: a list, each component corresponds to a different 
stress and is a function defining the densities of the stressed component;
</p>
</li>
<li> <p><code>str_FY</code>: a list, each component corresponds to a different 
stress and is a function defining the distribution of the stressed component;
</p>
</li>
<li> <p><code>str_FY_inv</code>: a list, each component corresponds to a different 
stress and is a function defining the quantiles of the stressed component;
</p>
</li>
<li> <p><code>gamma</code>: a list, each component corresponds to a different 
stress and is a function defining the risk measure;
</p>
</li>
<li> <p><code>specs</code>: a list, each component corresponds to
a different stress and contains a list with the specifications
of what has been stressed.
Specifications depend on the <code>type</code> of stress:
</p>

<ul>
<li> <p><code>type = "RM"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>alpha</code>, the level of
the RM; <code>q</code>, the stressed RM at level
<code>alpha</code>.
</p>
</li>
<li> <p><code>type = "mean sd"</code>: <code>k</code>, the columns of <code>x</code>
on which the stress is applied to; <code>new_mean</code>, the
stressed mean; <code>new_sd</code>, the stressed standard deviation.
</p>
</li>
<li> <p><code>type = "RM mean sd"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>alpha</code>, the level of the
stressed RM; <code>q</code>, the stressed RM at level
<code>alpha</code>; <code>new_mean</code>, the
stressed mean; <code>new_sd</code>, the stressed standard deviation.
</p>
</li>
<li> <p><code>type = "HARA RM"</code>: <code>k</code>, the column of <code>x</code>
on which the stress is applied to; <code>alpha</code>, the level of
the stressed RM; <code>q</code>, the stressed RM at level
<code>alpha</code>; <code>a</code> a parameter of the HARA utility function;
<code>b</code>, a parameter of the HARA utility function;
<code>eta</code> a parameter of the HARA utility function;
<code>hu</code>, the stressed HARA utility with parameters 
<code>a</code>, <code>b</code>, and <code>eta</code>.
</p>
</li>
</ul>
</li>
</ul>
<h3>References</h3>

<p>Pesenti SM, Millossovich P, Tsanakas A (2019).
“Reverse sensitivity testing: What does it take to break the model?”
<em>European Journal of Operational Research</em>, <b>274</b>(2), 654–670.<br></p>
<p>Pesenti S BAMPTA (2020).
“Scenario Weights for Importance Measurement (SWIM) - An R package for sensitivity analysis.”
<em>Annals of Actuarial Science 15.2 (2021): 458-483. Available at SSRN: <a href="https://www.ssrn.com/abstract=3515274">https://www.ssrn.com/abstract=3515274</a></em>.<br></p>
<p>Csiszar I (1975).
“I-divergence geometry of probability distributions and minimization problems.”
<em>The Annals of Probability</em>, 146–158.
</p>


<h3>See Also</h3>

<p>See <code>get_data</code> for extracting the data,
<code>x</code>; <code>get_weights</code> for extracting the scenario
weights, <code>new_weights</code>; <code>get_weightsfun</code> for
extracting the functions generating the scenario weights; and
<code>get_specs</code> for extracting the specifications of
the stress on an object of class <code>SWIM</code>.
</p>


</div>