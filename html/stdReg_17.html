<div class="container">

<table style="width: 100%;"><tr>
<td>stdGlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regression standardization in generalized linear models
</h2>

<h3>Description</h3>

<p><code>stdGlm</code> performs regression standardization in generalized linear models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, the exposure, and a
vector of covariates, respectively. <code>stdGlm</code> uses a fitted generalized linear
model to estimate the standardized 
mean <code class="reqn">\theta(x)=E\{E(Y|X=x,Z)\}</code>, where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, 
and the outer expectation is over the marginal distribution of <code class="reqn">Z</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">stdGlm(fit, data, X, x, clusterid, case.control = FALSE, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. If arguments <code>weights</code> and/or <code>subset</code>
are used when fitting the model, then the same weights and subset are used 
in <code>stdGlm</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized mean. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal mean
<code class="reqn">E(Y)=E\{E(Y|X,Z)\}</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when data are clustered. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case.control</code></td>
<td>

<p>logical. Do data come from a case-control study? Defaults to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stdGlm</code> assumes that a generalized linear model 
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|X,Z)\}=h(X,Z;\beta)</code>
</p>

<p>has been fitted. The maximum likelihood estimate of <code class="reqn">\beta</code> is used to obtain 
estimates of the mean <code class="reqn">E(Y|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{E}(Y|X=x,Z)=\eta^{-1}\{h(X=x,Z;\hat{\beta})\}.</code>
</p>
 
<p>For each <code class="reqn">x</code> in the <code>x</code> argument, these estimates are averaged across 
all subjects (i.e. all observed values of <code class="reqn">Z</code>) to produce estimates  
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(x)=\sum_{i=1}^n \hat{E}(Y|X=x,Z_i)/n,</code>
</p>
 
<p>where <code class="reqn">Z_i</code> is the value of <code class="reqn">Z</code> for subject <code class="reqn">i</code>, <code class="reqn">i=1,...,n</code>.
The variance for <code class="reqn">\hat{\theta}(x)</code> is obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdGlm"</code> is a list containing 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>

<p>a vector with length equal to <code>length(x)</code>, where element <code>j</code> is equal to 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>

<p>a square matrix with <code>length(x)</code> rows, where the element 
on row <code>i</code> and column <code>j</code> is the (estimated) covariance of 
<code class="reqn">\hat{\theta}</code>(<code>x[i]</code>) and 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The variance calculation performed by <code>stdGlm</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(x)\}=E[var\{\hat{\theta}(x)|\bar{Z}\}]+var[E\{\hat{\theta}(x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a generalized linear model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that the 
term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance decomposition 
for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, <code class="reqn">\theta(x)</code> depends 
on <code class="reqn">\bar{Z}</code> through the average over the sample distribution for <code class="reqn">Z</code>, 
and thus the term <code class="reqn">var[E\{\hat{\theta}(x)|\bar{Z}\}]</code> is not 0, unless one 
conditions on <code class="reqn">\bar{Z}</code>. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Rothman K.J., Greenland S., Lash T.L. (2008). <em>Modern Epidemiology</em>, 3rd edition. 
Lippincott, Williams \&amp; Wilkins.
</p>
<p>Sjolander A. (2016). Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjolander A. (2016). Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##Example 1: continuous outcome
n &lt;- 1000
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean=Z)
Y &lt;- rnorm(n, mean=X+Z+0.1*X^2)
dd &lt;- data.frame(Z, X, Y)
fit &lt;- glm(formula=Y~X+Z+I(X^2), data=dd)
fit.std &lt;- stdGlm(fit=fit, data=dd, X="X", x=seq(-3,3,0.5))
print(summary(fit.std))
plot(fit.std)

##Example 2: binary outcome
n &lt;- 1000
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean=Z)
Y &lt;- rbinom(n, 1, prob=(1+exp(X+Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
fit &lt;- glm(formula=Y~X+Z+X*Z, family="binomial", data=dd)
fit.std &lt;- stdGlm(fit=fit, data=dd, X="X", x=seq(-3,3,0.5))
print(summary(fit.std))
plot(fit.std)
</code></pre>


</div>