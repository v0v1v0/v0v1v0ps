<div class="container">

<table style="width: 100%;"><tr>
<td>MRH</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix Representation of Hierarchical Clustering</h2>

<h3>Description</h3>

<p>Matrix Representation of Hierarchical clustering (MRH)</p>


<h3>Usage</h3>

<pre><code class="language-R">MRH(hcl, dim=NULL, method="groups")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>hcl</code></td>
<td>
<p>'hclust' object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Number of desired dimensions, if defaults are not suitable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Either "groups" (default), or "height", or "branches", or "cophenetic" (see below for explanations)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calls cutree(), or Hcl2mat(), or cmdscale(cophenetic()) in order to output the
Matrix Representation of Hierarchical clustering (MRH).
</p>
<p>If method="groups" then clustering tree is cut by all possible numbers of clusters 'k'
(excluding 'k=1' and 'k=n' which bring no information) so 'dim' is always 'n-2'.
</p>
<p>If method="height" then clustering tree is cut by equally spaced agglomeration heights
(excluding minimal and maximal heights which bring no information). Default 'dim' here is '2*n',
but higher values might work even better.
</p>
<p>If method="branches" then use Hcl2mat() to transform object into the binary matrix of memberships,
always with  'n-1' dimensions (so user-specified 'dim' is not taken into account).
Each column in this matrix represents the tree branch.
</p>
<p>If method="cophenetic" then multidimensional scaling scores with maximum dimensionality on cophenetic
distances are computed. Default 'dim' is 'n-1' but lesser numbers might work better.
</p>
<p>The main feature of the resulted matrices is that they provide the "bridge" of conversion between original data,
distance matrices and clustering (including phylogenetic trees) results. After conversion, many interesting applications
become possible. For example, if converted trees represent the _same_ objects,  it is possible to "hyper-bind",
or "average" (Ashkenazy et al., 2018) them.
</p>
<p>To work with 'phylo' objects, convert them first to 'hclust' with as.hclust(), and before that, possibly also apply
compute.brlen(), multi2di() and collapse.singles().
</p>


<h3>Value</h3>

<p>Matrix with default number of columns equal to number of objects (n) minus 1 (method="branches" or method="cophenetic")
or 'n-2' (method="groups"), or '2*n' (method="height").
</p>
<p>Rows are objects, values are either cluster numbers (method="groups" or method="height")
so matrix consist of whole positive numbers,  binary cluster memberships (method="branches")
or decimal MDS scores (method="cophenetic").
</p>


<h3>References</h3>

<p>Ashkenazy H., Sela I., Levy Karin E., Landan G., Pupko T. 2018. Multiple sequence alignment averaging
improves phylogeny reconstruction. Systematic Biology. 68: 117â€“130.
</p>


<h3>See Also</h3>

<p><code>cutree</code>, <code>link{cmdscale}</code>, <code>link{Hcl2mat}</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">aa.h &lt;- hclust(dist(t(atmospheres)))
plot(aa.h)

(aa.mrh1 &lt;- MRH(aa.h))
plot(hclust(dist(aa.mrh1)))

aa.mrh2 &lt;- MRH(aa.h, method="height", dim=100) # here 'dim' should better be large
str(aa.mrh2)
plot(hclust(dist(aa.mrh2)))

plot(hclust(dist(cbind(aa.mrh1, aa.mrh2)))) # hyper-bind

(aa.mrh3 &lt;- MRH(aa.h, method="branches"))
plot(hclust(dist(aa.mrh3)))

(aa.mrh4 &lt;- MRH(aa.h, method="cophenetic"))
plot(hclust(dist(aa.mrh4)))

library(ape)
tree &lt;- read.tree(text="((A:1,B:1):2,(C:3,D:4):2):3;")
(tree.mrh3 &lt;- MRH(as.hclust(compute.brlen(tree)), method="branches"))
</code></pre>


</div>