<div class="container">

<table style="width: 100%;"><tr>
<td>rarx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate parameters of ARX recursively</h2>

<h3>Description</h3>

<p>Estimates the parameters of a single-output ARX model of the 
specified order from data using the recursive weighted least-squares
algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rarx(x, order = c(1, 1, 1), lambda = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>idframe</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Specification of the orders: the three integer components 
(na,nb,nk) are the order of polynolnomial A, (order of polynomial B + 1) and 
the input-output delay</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Forgetting factor(Default=<code>0.95</code>)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following objects
</p>

<dl>
<dt>theta</dt>
<dd>
<p>Estimated parameters of the model. The <code class="reqn">k^{th}</code> 
row contains the parameters associated with the <code class="reqn">k^{th}</code> 
sample. Each row in <code>theta</code> has the following format: <br>
theta[i,:]=[a1,a2,...,ana,b1,...bnb]
</p>
</dd>
<dt>yhat</dt>
<dd>
<p>Predicted value of the output, according to the 
current model - parameters based on all past data</p>
</dd>
</dl>
<h3>References</h3>

<p>Arun K. Tangirala (2015), <em>Principles of System Identification: 
Theory and Practice</em>, CRC Press, Boca Raton. Section 25.1.3
</p>
<p>Lennart Ljung (1999), <em>System Identification: Theory for the User</em>, 
2nd Edition, Prentice Hall, New York. Section 11.2
</p>


<h3>Examples</h3>

<pre><code class="language-R">Gp1 &lt;- idpoly(c(1,-0.9,0.2),2,ioDelay=2,noiseVar = 0.1)
Gp2 &lt;- idpoly(c(1,-1.2,0.35),2.5,ioDelay=2,noiseVar = 0.1)
uk = idinput(2044,'prbs',c(0,1/4)); N = length(uk);
N1 = round(0.35*N); N2 = round(0.4*N); N3 = N-N1-N2;
yk1 &lt;- sim(Gp1,uk[1:N1],addNoise = TRUE)
yk2 &lt;- sim(Gp2,uk[N1+1:N2],addNoise = TRUE)
yk3 &lt;- sim(Gp1,uk[N1+N2+1:N3],addNoise = TRUE)
yk &lt;- c(yk1,yk2,yk3)
z &lt;- idframe(yk,uk,1)
g(theta,yhat) %=% rarx(z,c(2,1,2))

</code></pre>


</div>