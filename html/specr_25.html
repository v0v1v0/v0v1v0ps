<div class="container">

<table style="width: 100%;"><tr>
<td>specr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit models across all specifications</h2>

<h3>Description</h3>

<p>Runs the specification/multiverse analysis across specified models.
This is the central function of the package and represent the second step
in the analytic framework implemented in the package <code>specr</code>. It estimates
and returns respective parameters and estimates of models that were specified
via <code>setup()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">specr(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>specr.setup</code> object resulting from <code>setup</code> or a tibble that
contains the relevant specifications (e.g., a tibble resulting from
<code>as_tibble(setup(...))</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If x is not an object of "specr.setup" and simply a tibble, you
need to provide the data set that should be used. Defaults to NULL as it is
assumend that most users will create an object of class "specr.setup" that they'll
pass to <code>specr()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments that can be passed to <code>future_pmap</code>. This only becomes
important if parallelization is used. For example, if a custom model function is used
this involves passing <code>furrr_options</code> passing to the argument <code>.options</code>.
When a plan for parallelization is set, one can also set <code>.progress = TRUE</code>
to print a progress bar during the fitting process. See details for more information
on parallelization.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Empirical results are often contingent on analytical decisions that
are equally defensible, often arbitrary, and motivated by different reasons.
This decisions may introduce bias or at least variability. To this end,
specification curve analyses  (Simonsohn et al., 2020) or multiverse
analyses (Steegen et al., 2016) refer to identifying the set of
theoretically justified, statistically valid (and potentially also non-redundant
specifications, fitting the "multiverse" of models represented by these
specifications and extract relevant parameters often to display the results
graphically as a so-called specification curve. This allows readers to
identify consequential specifications decisions and how they affect the results
or parameter of interest.
</p>
<p><b>Use of this function</b>
</p>
<p>A general overview is provided in the vignettes <code>vignette("specr")</code>.
Generally, you create relevant specification using the function <code>setup()</code>.
You then pass the resulting object of a class <code>specr.setup</code> to the
present function <code>specr()</code> to run the specification curve analysis.
Further note that the resulting object of class <code>specr.object</code> allows
to use several generic function such as <code>summary()</code> or <code>plot()</code>.
Use <code>methods(class = "specr.object")</code> for an overview on available
methods and e.g., <code>?plot.specr.object</code> to view the dedicated help page.
</p>
<p><b>Parallelization</b>
</p>
<p>By default, the function fits models across all specifications sequentially
(one after the other). If the data set is large, the models complex (e.g.,
large structural equation models, negative binomial models, or Bayesian models),
and the number of specifications is large, it can make sense to parallelize
these operations. One simply has to load the package <code>furrr</code> (which
in turn, builds on <code>future</code>) up front. Then parallelizing the fitting process
works as specified in the package description of <code>furr</code>/<code>future</code> by setting a
"plan" before running <code>specr</code> such as:
</p>
<p><code>plan(multisession, workers = 4)</code>
</p>
<p>However, there are many more ways to specifically set up the plan, including
different strategy than <code>multisession</code>. For more information, see
<code>vignette("parallelization")</code> and the
<a href="https://future.futureverse.org/reference/plan.html">reference page</a>
for <code>plan()</code>.
</p>
<p><b>Disclaimer</b>
</p>
<p>We do see a lot of value in investigating how analytical choices
affect a statistical outcome of interest. However, we strongly caution
against using specr as a tool to somehow arrive at a better estimate
compared to a single model. Running a specification curve analysis
does not make your findings any more reliable, valid or generalizable
than a single analysis. The method is meant to inform about the effects
of analytical choices on results, and not a better way to estimate a
correlation or effect.
</p>


<h3>Value</h3>

<p>An object of class <code>specr.object</code>, which includes a data frame
with all specifications their respective results along with many other useful
information about the model. Parameters are extracted via the function passed
to <code>setup</code>. By default this is <code>broom::tidy()</code> and the function
<code>broom::glance()</code>).Several other aspects and information are included in
the resulting class (e.g., number of specifications, time elapsed, subsets
included in the analyses). Use <code>methods(class = "specr.object")</code> for
an overview on available methods.
</p>


<h3>References</h3>


<ul>
<li>
<p> Simonsohn, U., Simmons, J.P. &amp; Nelson, L.D. (2020). Specification curve analysis. <em>Nature Human Behaviour, 4</em>, 1208â€“1214. https://doi.org/10.1038/s41562-020-0912-z
</p>
</li>
<li>
<p> Steegen, S., Tuerlinckx, F., Gelman, A., &amp; Vanpaemel, W. (2016). Increasing Transparency Through a Multiverse Analysis. <em>Perspectives on Psychological Science, 11</em>(5), 702-712. https://doi.org/10.1177/1745691616658637
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>setup()</code> for the first step of setting up the specifications.
</p>
<p><code>summary.specr.object()</code> for how to summarize and inspect the results.
</p>
<p><code>plot.specr.object()</code> for plotting results.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1 ----
# Setup up typical specifications
specs &lt;- setup(data = example_data,
   y = c("y1", "y2"),
   x = c("x1", "x2"),
   model = "lm",
   controls = c("c1", "c2"),
   subsets = list(group1 = unique(example_data$group1)))

# Run analysis (not parallelized)
results &lt;- specr(specs)

# Summary of the results
summary(results)


# Example 2 ----
# Working without S3 classes
specs2 &lt;- setup(data = example_data,
    y = c("y1", "y2"),
    x = c("x1", "x2"),
    model = "lm",
    controls = "c1")

# Working with tibbles
specs_tibble &lt;- as_tibble(specs2)      # extract tibble from setup
results2 &lt;- specr(specs_tibble,
                  data = example_data) # need to provide data!

# Results (tibble instead of S3 class)
head(results2)
</code></pre>


</div>