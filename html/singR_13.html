<div class="container">

<table style="width: 100%;"><tr>
<td>lngca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Decompose the original data through LNGCA method.</h2>

<h3>Description</h3>

<p>Implements the methods of linear non-Gaussian component analysis (LNGCA) and likelihood component analysis (when using a density, e.g., tilted Gaussian) from the <a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2017.1407772">LNGCA paper</a>
</p>


<h3>Usage</h3>

<pre><code class="language-R">lngca(
  xData,
  n.comp = NULL,
  Ux.list = NULL,
  whiten = c("sqrtprec", "eigenvec", "none"),
  maxit = 1000,
  eps = 1e-06,
  verbose = FALSE,
  restarts.pbyd = 0,
  restarts.dbyd = 0,
  distribution = c("JB", "tiltedgaussian", "logistic"),
  density = FALSE,
  out.all = FALSE,
  orth.method = c("svd", "givens"),
  df = 0,
  stand = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xData</code></td>
<td>
<p>the original dataset for decomposition, matrix of n x px.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.comp</code></td>
<td>
<p>the number of components to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ux.list</code></td>
<td>
<p>list of user specified initial values for Ux. If null, will generate random orthogonal matrices. See restarts.pbyd and restarts.dbyd</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiten</code></td>
<td>
<p>whitening method. Defaults to "svd" which uses the n left eigenvectors divided by sqrt(px-1) by 'eigenvec'. Optionally uses the square root of the n x n "precision" matrix by 'sqrtprec'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>max iteration, defalut = 1000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>default = 1e-06</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>default = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restarts.pbyd</code></td>
<td>
<p>default = 0. Generates p x d random orthogonal matrices. Use a large number for large datasets. Note: it is recommended that you run lngca twice with different seeds and compare the results, which should be similar when a sufficient number of restarts is used. In practice, stability with large datasets and a large number of components can be challenging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restarts.dbyd</code></td>
<td>
<p>default = 0. These are d x d initial matrices padded with zeros, which results in initializations from the principal subspace. Can speed up convergence but may miss low variance non-Gaussian components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>distribution methods with default to tilted Gaussian. "logistic" is similar to infomax ICA, JB is capable of capture super and sub Gaussian distribution while being faster than tilted Gaussian. (tilted Gaussian tends to be most accurate, but computationally much slower.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>return the estimated tilted Gaussian density? default = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.all</code></td>
<td>
<p>default = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orth.method</code></td>
<td>
<p>default = 'svd'. Method to generate random initial matrices. See [gen.inits()]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>default = 0, df of the spline used in fitting the non-parametric density. use df=8 or so for tilted gaussian. set df=0 for JB and logistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>whether to standardize the data to have row and column means equal to 0 and the row standard deviation equal to 1 (i.e., all variables on same scale). Often used when combined with singR for data integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments to tiltedgaussian estimation</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Function outputs a list including the following:
</p>

<dl>
<dt><code>U</code></dt>
<dd>
<p>matrix rx x n, part of the expression that Ax = Ux x Lx and Ax x Xc = Sx, where Lx is the whitener matrix.</p>
</dd>
<dt><code>loglik</code></dt>
<dd>
<p>the value of log-likelihood in the lngca method.</p>
</dd>
<dt><code>S</code></dt>
<dd>
<p>the variable loading matrix r x px, each row is a component, which can be used to measure nongaussianity</p>
</dd>
<dt><code>df</code></dt>
<dd>
<p>egree of freedom.</p>
</dd>
<dt><code>distribution</code></dt>
<dd>
<p>the method used for data decomposition.</p>
</dd>
<dt><code>whitener</code></dt>
<dd>
<p>A symmetric whitening matrix n x n from dX, the same with  whitenerXA = est.sigmaXA %^% -0.5</p>
</dd>
<dt><code>M</code></dt>
<dd>
<p>Mx Mtrix with n x rx.</p>
</dd>
<dt><code>nongaussianity</code></dt>
<dd>
<p>the nongaussianity score for each component saved in S matrix.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">
#get simulation data
data(exampledata)
data=exampledata

# To get n.comp value, we can use NG_number function.

# use JB statistic as the measure of nongaussianity to run lngca with df=0
estX_JB = lngca(xData = data$dX, n.comp = 4,
 whiten = 'sqrtprec', restarts.pbyd = 20, distribution='JB',df=0)

# use the tiltedgaussian distribution to run lngca with df=8. This takes a long time:
estX_tilt = lngca(xData = data$dX, n.comp = 4,
 whiten = 'sqrtprec', restarts.pbyd = 20, distribution='tiltedgaussian',df=8)

# true non-gaussian component of Sx, include individual and joint components
trueSx = rbind(data$sjX,data$siX)

# use pmse to compare the difference of the two methods
pmse(S1 = t(trueSx),S2=t(estX_JB$S),standardize = TRUE)
pmse(S1 = t(trueSx),S2=t(estX_tilt$S),standardize = TRUE)

# the lngca using tiltedgaussian tends to be more accurate
# with smaller pmse value, but takes longer to run.


</code></pre>


</div>