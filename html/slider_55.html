<div class="container">

<table style="width: 100%;"><tr>
<td>slide</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Slide</h2>

<h3>Description</h3>

<p><code>slide()</code> iterates through <code>.x</code> using a sliding window, applying <code>.f</code> to each
sub-window of <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slide(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L, .complete = FALSE)

slide_vec(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .ptype = NULL
)

slide_dbl(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_int(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_lgl(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_chr(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_dfr(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_dfc(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector]⁠</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p><code style="white-space: pre;">⁠[function / formula]⁠</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.before, .after</code></td>
<td>
<p><code style="white-space: pre;">⁠[integer(1) / Inf]⁠</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to "look forward" from the current element if used as the
<code>.before</code> value, or "look backwards" if used as <code>.after</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.step</code></td>
<td>
<p><code style="white-space: pre;">⁠[positive integer(1)]⁠</code>
</p>
<p>The number of elements to shift the window forward between function calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.complete</code></td>
<td>
<p><code style="white-space: pre;">⁠[logical(1)]⁠</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ptype</code></td>
<td>
<p><code style="white-space: pre;">⁠[vector(0) / NULL]⁠</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li>
<p> By default, input names are zapped.
</p>
</li>
<li>
<p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li>
<p> If <code>NULL</code>, the input names are used as row names.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code>vec_as_names()</code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse recycling rules.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Unlike <code>lapply()</code> or <code>purrr::map()</code>, which construct calls like
</p>
<div class="sourceCode"><pre>.f(.x[[i]], ...)
</pre></div>
<p>the equivalent with <code>slide()</code> looks like
</p>
<div class="sourceCode"><pre>.f(vctrs::vec_slice(.x, i), ...)
</pre></div>
<p>which is approximately
</p>
<div class="sourceCode"><pre>.f(.x[i], ...)
</pre></div>
<p>except in the case of data frames or arrays, which are iterated
over row-wise.
</p>
<p>If <code>.x</code> has names, then the output will preserve those names.
</p>
<p>Using <code>vctrs::vec_cast()</code>, the output of <code>.f</code> will be automatically cast
to the type required by the variant of <code style="white-space: pre;">⁠slide_*()⁠</code> being used.
</p>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide()</code></h4>


<ul>
<li> <p><code>vec_size(slide(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide(.x)) == list()</code>
</p>
</li>
</ul>
<h4>
<code>slide_vec()</code> and <code style="white-space: pre;">⁠slide_*()⁠</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_vec(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_size(slide_vec(.x)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_vec(.x, .ptype = ptype)) == ptype</code>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>slide2()</code>, <code>slide_index()</code>, <code>hop()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The defaults work similarly to `map()`
slide(1:5, ~.x)

# Use `.before`, `.after`, and `.step` to control the window
slide(1:5, ~.x, .before = 1)

# This can be used for rolling means
slide_dbl(rnorm(5), mean, .before = 2)

# Or more flexible rolling operations
slide(rnorm(5), ~ .x - mean(.x), .before = 2)

# `.after` allows you to "align to the left" rather than the right
slide(1:5, ~.x, .after = 2)

# And a mixture of `.before` and `.after`
# allows you complete control over the exact alignment.
# Below, "center alignment" is used.
slide(1:5, ~.x, .before = 1, .after = 1)

# The `.step` controls how the window is shifted along `.x`,
# allowing you to "skip" iterations if you only need a less granular result
slide(1:10, ~.x, .before = 2, .step = 3)

# `.complete` controls whether or not partial results are computed.
# By default, they are, but setting `.complete = TRUE` restricts
# `slide()` to only evaluate the function where a complete window exists.
slide(1:5, ~.x, .before = 2, .after = 1)
slide(1:5, ~.x, .before = 2, .after = 1, .complete = TRUE)

# ---------------------------------------------------------------------------
# Data frames

# Data frames are iterated over rowwise
mtcars_rowwise &lt;- slide(mtcars, ~.x)
mtcars_rowwise[1:3]

# This means that any column name is easily accessible
slide_dbl(mtcars, ~.x$mpg + .x$cyl)

# More advanced rowwise iteration is available as well by using the
# other arguments
mtcars_rowwise_window &lt;- slide(mtcars, ~.x, .before = 1, .after = 1)
mtcars_rowwise_window[1:3]

# ---------------------------------------------------------------------------
# Cumulative sliding

# Using the special cased value, `Inf`, you can ask `slide()` to pin the
# start of the sliding window to the first element, effectively creating
# a cumulative window
slide(1:5, ~.x, .before = Inf)

# Same with `.after`, this creates a window where you start with all of the
# elements, but decrease the total number over each iteration
slide(1:5, ~.x, .after = Inf)

# ---------------------------------------------------------------------------
# Negative `.before` / `.after`

# `.before` is allowed to be negative, allowing you to "look forward" in
# your vector. Note that `abs(.before) &lt;= .after` must hold if `.before` is
# negative. In this example, we look forward to elements in locations 2 and 3
# but place the result in position 1 in the output.
slide(1:5, ~.x, .before = -1, .after = 2)

# `.after` can be negative as well to "look backwards"
slide(1:5, ~.x, .before = 2, .after = -1)

# ---------------------------------------------------------------------------
# Removing padding

# If you are looking for a way to remove the `NA` values from something like
# this, then it doesn't exist as a built in option.
x &lt;- rnorm(10)
slide_dbl(x, mean, .before = 3, .step = 2, .complete = TRUE)

# Adding an option to `slide_dbl()` to remove the `NA` values would destroy
# its size stability. Instead, you can use a combination of `slide_dfr()`
# to get the start/stop indices with `hop_index_vec()`.
i &lt;- seq_along(x)
idx &lt;- slide_dfr(
  i,
  ~data.frame(start = .x[1], stop = .x[length(.x)]),
  .before = 3,
  .step = 2,
  .complete = TRUE
)

idx

hop_index_vec(x, i, idx$start, idx$stop, mean, .ptype = double())

</code></pre>


</div>