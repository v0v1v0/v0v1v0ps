<div class="container">

<table style="width: 100%;"><tr>
<td>filter_keys</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filters .data according to all records in the filter</h2>

<h3>Description</h3>

<p>If <code>filters</code> is <code>NULL</code>, no filtering is done.
Otherwise, the <code>.data</code> object is filtered via an <code>inner_join()</code> using all columns of the filter:
<code>inner_join(.data, filter, by = colnames(filter))</code>
</p>
<p><code>by</code> and <code>na_by</code> can overwrite the <code>inner_join()</code> columns used in the filtering.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filter_keys(.data, filters, by = NULL, na_by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br>
Data object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filters</code></td>
<td>
<p>(<code>data.frame(1)</code>, <code>tibble(1)</code>, <code>data.table(1)</code>, or <code>tbl_dbi(1)</code>)<br>
A object subset data by.
If filters is <code>NULL</code>, no filtering occurs.
Otherwise, an <code>inner_join()</code> is performed using all columns of the filter object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>A join specification created with <code>join_by()</code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">⁠*_join()⁠</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code>join_by()</code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code>join_by()</code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code>join_by()</code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at ?join_by for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code>cross_join()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_by</code></td>
<td>
<p>(<code>character()</code>)<br>
Columns where NA should match with NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>dplyr::inner_join()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of same class as .data
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Filtering with null means no filtering is done
  filter &lt;- NULL
  identical(filter_keys(mtcars, filter), mtcars) # TRUE

  # Filtering by vs = 0
  filter &lt;- data.frame(vs = 0)
  identical(filter_keys(mtcars, filter), dplyr::filter(mtcars, vs == 0)) # TRUE

  # Filtering by the specific combinations of vs = 0 and am = 1
  filter &lt;- dplyr::distinct(mtcars, vs, am)
  filter_keys(mtcars, filter)

</code></pre>


</div>