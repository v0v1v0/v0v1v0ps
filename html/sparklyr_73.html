<div class="container">

<table style="width: 100%;"><tr>
<td>ft_one_hot_encoder_estimator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Feature Transformation â€“ OneHotEncoderEstimator (Estimator)</h2>

<h3>Description</h3>

<p>A one-hot encoder that maps a column of category indices
to a column of binary vectors, with at most a single one-value
per row that indicates the input category index. For example
with 5 categories, an input value of 2.0 would map to an output
vector of [0.0, 0.0, 1.0, 0.0]. The last category is not included
by default (configurable via dropLast), because it makes the
vector entries sum up to one, and hence linearly dependent. So
an input value of 4.0 maps to [0.0, 0.0, 0.0, 0.0].
</p>


<h3>Usage</h3>

<pre><code class="language-R">ft_one_hot_encoder_estimator(
  x,
  input_cols = NULL,
  output_cols = NULL,
  handle_invalid = "error",
  drop_last = TRUE,
  uid = random_string("one_hot_encoder_estimator_"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>spark_connection</code>, <code>ml_pipeline</code>, or a <code>tbl_spark</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input_cols</code></td>
<td>
<p>Names of input columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_cols</code></td>
<td>
<p>Names of output columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handle_invalid</code></td>
<td>
<p>(Spark 2.1.0+) Param for how to handle invalid entries. Options are
'skip' (filter out rows with invalid values), 'error' (throw an error), or
'keep' (keep invalid values in a special additional bucket). Default: "error"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_last</code></td>
<td>
<p>Whether to drop the last category. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uid</code></td>
<td>
<p>A character string used to uniquely identify the feature transformer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments; currently unused.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the case where <code>x</code> is a <code>tbl_spark</code>, the estimator
fits against <code>x</code> to obtain a transformer, returning a <code>tbl_spark</code>.
</p>


<h3>Value</h3>

<p>The object returned depends on the class of <code>x</code>. If it is a
<code>spark_connection</code>, the function returns a <code>ml_estimator</code> or a
<code>ml_estimator</code> object. If it is a <code>ml_pipeline</code>, it will return
a pipeline with the transformer or estimator appended to it. If a
<code>tbl_spark</code>, it will return a <code>tbl_spark</code> with the transformation
applied to it.
</p>


<h3>See Also</h3>

<p>Other feature transformers: 
<code>ft_binarizer()</code>,
<code>ft_bucketizer()</code>,
<code>ft_chisq_selector()</code>,
<code>ft_count_vectorizer()</code>,
<code>ft_dct()</code>,
<code>ft_elementwise_product()</code>,
<code>ft_feature_hasher()</code>,
<code>ft_hashing_tf()</code>,
<code>ft_idf()</code>,
<code>ft_imputer()</code>,
<code>ft_index_to_string()</code>,
<code>ft_interaction()</code>,
<code>ft_lsh</code>,
<code>ft_max_abs_scaler()</code>,
<code>ft_min_max_scaler()</code>,
<code>ft_ngram()</code>,
<code>ft_normalizer()</code>,
<code>ft_one_hot_encoder()</code>,
<code>ft_pca()</code>,
<code>ft_polynomial_expansion()</code>,
<code>ft_quantile_discretizer()</code>,
<code>ft_r_formula()</code>,
<code>ft_regex_tokenizer()</code>,
<code>ft_robust_scaler()</code>,
<code>ft_sql_transformer()</code>,
<code>ft_standard_scaler()</code>,
<code>ft_stop_words_remover()</code>,
<code>ft_string_indexer()</code>,
<code>ft_tokenizer()</code>,
<code>ft_vector_assembler()</code>,
<code>ft_vector_indexer()</code>,
<code>ft_vector_slicer()</code>,
<code>ft_word2vec()</code>
</p>


</div>