<div class="container">

<table style="width: 100%;"><tr>
<td>shape.constrained.smooth.terms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shape preserving smooth terms in SCAM</h2>

<h3>Description</h3>

<p>As in <code>mgcv(gam)</code>, shape preserving smooth terms are specified in a <code>scam</code> formula using <code>s</code> 
terms. All the shape constrained smooth terms (SCOP-splines) are constructed using the B-splines basis proposed by Eilers and Marx (1996) with a discrete penalty on the basis coefficients.
</p>
<p>The univariate single penalty built-in shape constrained smooth classes are summarized as follows.
</p>

<ul>
<li>
<p> Monotone increasing SCOP-splines: <code>bs="mpi"</code>. To achieve monotone increasing smooths this reparameterizes the coefficients so that they form an increasing sequence. 
</p>
<p>For details see <code>smooth.construct.mpi.smooth.spec</code>. 
</p>
</li>
<li>
<p> Monotone decreasing SCOP-splines: <code>bs="mpd"</code>. To achieve monotone decreasing smooths this reparameterizes the coefficients 
so that they form a decreasing sequence. A first order difference penalty applied to the basis coefficients starting with the 
second is used for the monotone increasing and decreasing cases.
</p>
</li>
<li>
<p> Convex SCOP-splines: <code>bs="cx"</code>. This reparameterizes the coefficients so that the second order differences of the basis coefficients are greater than zero. 
</p>
<p>For details see <code>smooth.construct.cx.smooth.spec</code>. 
</p>
</li>
<li>
<p> Concave SCOP-splines: <code>bs="cv"</code>. This reparameterizes the coefficients so that the second order differences of the basis coefficients are less than zero.
</p>
<p>For details see <code>smooth.construct.cv.smooth.spec</code>. 
</p>
</li>
<li>
<p> Increasing and convex SCOP-splines: <code>bs="micx"</code>. This reparameterizes the coefficients 
so that the first and the second order differences of the basis coefficients are greater than zero. 
For details see 
<code>smooth.construct.micx.smooth.spec</code>.
</p>
</li>
<li>
<p> Increasing and concave SCOP-splines: <code>bs="micv"</code>. This reparameterizes the coefficients 
so that the first order differences of the basis coefficients are greater than zero while the second order difference
are less than zero.
</p>
</li>
<li>
<p> Decreasing and convex SCOP-splines: <code>bs="mdcx"</code>. This reparameterizes the coefficients 
so that the first order differences of the basis coefficients are less than zero while the second order difference
are greater. 
For details see <code>smooth.construct.mdcx.smooth.spec</code>.
</p>
</li>
<li>
<p> Decreasing and concave SCOP-splines: <code>bs="mdcv"</code>. This reparameterizes the coefficients 
so that the first and the second order differences of the basis coefficients are less than zero.
</p>
</li>
<li>
<p> Increasing with an additional 'finish-at-zero' constraint SCOP-splines: <code>bs="mifo"</code>. This sets the last <code>(m+1)</code> spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>(k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1. 
</p>
<p>For details see <code>smooth.construct.mifo.smooth.spec</code>. 
</p>
</li>
<li>
<p> Increasing with an additional 'start-at-zero' constraint SCOP-spline: <code>bs="miso"</code>. This sets the first <code>(m+1)</code> spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>(k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1. 
</p>
<p>For details see <code>smooth.construct.miso.smooth.spec</code>. 
</p>
</li>
<li>
<p> SCOP-spline with positivity constraint: <code>bs="po"</code>. This reparameterizes the coefficients so that there are positive. For details see <code>smooth.construct.po.smooth.spec</code>. 
</p>
</li>
<li>
<p> Decreasing/increasing SCOP-splines used with numeric 'by' variable: <code>bs="mpdBy"</code>, <code>bs="mpiBy"</code>. These work similar to <code>mpd.smooth.spec</code>, <code>mpi.smooth.spec</code>,  but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
For details see <code>smooth.construct.mpd.smooth.spec</code>, <code>smooth.construct.mpi.smooth.spec</code>. 
</p>
</li>
<li>
<p> Convex/concave SCOP-splines used with numeric 'by' variable: <code>bs="cxdBy"</code>, <code>bs="cvBy"</code>. These work similar to <code>cx.smooth.spec</code>, <code>cv.smooth.spec</code>,  but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
</p>
<p>For details see <code>smooth.construct.cx.smooth.spec</code>, 
</p>
<p><code>smooth.construct.cv.smooth.spec</code>. 
</p>
</li>
<li>
<p> Decreasing/increasing and convex/concave SCOP-splines used with numeric 'by' variable: <code>bs="mdcxBy"</code>, <code>bs="mdcvBy"</code>, <code>bs="micxBy"</code>, <code>bs="micvBy"</code>. 
</p>
<p>These work similar to <code>mdcx.smooth.spec</code>, <code>mdcv.smooth.spec</code>, <code>micx.smooth.spec</code>, <br><code>micv.smooth.spec</code>, but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
For details see <code>smooth.construct.mdcx.smooth.spec</code>, 
</p>
<p><code>smooth.construct.mdcv.smooth.spec</code>,
</p>
<p><code>smooth.construct.micx.smooth.spec</code>, 
</p>
<p><code>smooth.construct.micv.smooth.spec</code>. 
</p>
</li>
<li>
<p> Locally shape-constrained P-splines (LSCOP-splines): <code>bs="lmpi"</code>. Locally increasing splines that are monotone increasing up to a specified change point and become unconstrained beyond that point. For details see <code>smooth.construct.lmpi.smooth.spec</code>. 
</p>
</li>
</ul>
<p>For all types of the mixed constrained smoothing a first order difference penalty applied to the basis coefficients starting with the third one is used. Centring ('sum-to-zero') constraint has been applied to univariate SCOP-splines subject to monotonicity (convexity) constraints after implementing the 'zero intercept' identifiability constraint. This is achieved by dropping the first (constant) column of the spline model matrix and subtracting the corresponding column means from the elements of the remaining columns afterwards. 'Sum-to-zero' constraint orthogonalized the smooth to the model intercept term, thus avoiding confounding with the intercept. The standard errors of the estimated intercept become lower with the centring constraint.
</p>
<p>Using the concept of the tensor product spline bases bivariate smooths under monotonicity constraint where monotonicity may be 
assumed on only one of the covariates (single monotonicity) or both of them (double monotonicity) are added as the smooth terms 
of the SCAM. Bivariate B-spline is constructed by expressing the coefficients of one of the marginal univariate 
B-spline bases as the B-spline of the other covariate. Double or single monotonicity is achieved by the corresponding 
re-parametrization of the bivariate basis coefficients to satisfy the sufficient conditions formulated in terms of the first 
order differences of the coefficients. The following explains the built in bivariate shape constrained smooth classes.
</p>

<ul>
<li>
<p> Double monotone increasing SCOP-splines: <code>bs="tedmi"</code>. 
</p>
<p>See <code>smooth.construct.tedmi.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Double monotone decreasing SCOP-splines: <code>bs="tedmd"</code>. 
</p>
</li>
<li>
<p> Single monotone increasing SCOP-splines along the first covariate direction: <code>bs="tesmi1"</code>. 
</p>
</li>
<li>
<p> Single monotone increasing SCOP-splines along the second covariate direction: <code>bs="tesmi2"</code>. 
</p>
</li>
<li>
<p> Single monotone decreasing SCOP-splines along the first covariate direction: <code>bs="tesmd1"</code>. 
</p>
</li>
<li>
<p> Single monotone decreasing SCOP-splines along the second covariate direction: <code>bs="tesmd2"</code>. 
</p>
</li>
<li>
<p> SCOP-splines with double concavity constraint: <code>bs="tecvcv"</code>.
</p>
<p>See <code>smooth.construct.tecvcv.smooth.spec</code> for details.
</p>
</li>
<li>
<p> SCOP-splines with double convexity constraint: <code>bs="tecxcx"</code>. 
</p>
<p>See <code>smooth.construct.tecxcx.smooth.spec</code> for details.
</p>
</li>
<li>
<p> SCOP-splines with convexity wrt the first covariate and
concavity wrt the second covariate: <code>bs="tecxcv"</code>. See <code>smooth.construct.tecxcv.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Decreasing along the first covariate and
concave along the second covariate SCOP-splines: <code>bs="tedecv"</code>. 
See <code>smooth.construct.tedecv.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Decreasing along the first covariate and convex along the second covariate SCOP-splines: <code>bs="tedecx"</code>. 
See <code>smooth.construct.tedecx.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Increasing along the first covariate and concave along the second covariate SCOP-splines: <code>bs="temicv"</code>. 
See <code>smooth.construct.temicv.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Increasing along the first covariate and convex along the second covariate SCOP-splines: <code>bs="temicx"</code>. 
See <code>smooth.construct.temicx.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Convex along the second covariate SCOP-splines: <code>bs="tescx"</code>. 
</p>
<p>See <code>smooth.construct.tescx.smooth.spec</code> for details.      
</p>
</li>
<li>
<p> Concave along the second covariate SCOP-splines: <code>bs="tescv"</code>. 
</p>
<p>See <code>smooth.construct.tescv.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Tensor product interaction with increasing constraint along the first
covariate and unconstrained along the second covariate: <code>bs="tismi"</code>. 
</p>
<p>See <code>smooth.construct.tismi.smooth.spec</code> for details.
</p>
</li>
<li>
<p> Tensor product interaction with decreasing constraint along the first
covariate and unconstrained along the second covariate: <code>bs="tismd"</code>. 
</p>
<p>See <code>smooth.construct.tismd.smooth.spec</code> for details.
</p>
</li>
</ul>
<p>Double penalties for the shape constrained tensor product smooths are obtained from the penalties of the marginal smooths. For the bivariate SCOP-splines with monotonicity (convexity) constraints along one covariate, the 'sum-to-zero' constraints are applied after dropping the first columns of the model matrix of the constrained marginal smooth. The basis for the unconstrained marginal must be non-negative over the region where the marginal monotonicity (convexity) is to hold. For the bivariate interaction smooths <code>"tismi"</code>  and <code>"tismd"</code> the following identifiability steps are implemented: i) dropped the first column of the <code>"mpi"</code> (<code>"mpd"</code>) marginals, ii) applied 'sum-to-zero' constraints to the marginals and to the unconstrained B-spline basis, iii) tensor product constructed. The 'sum-to-zero' constraint is applied to the final tensor product model matrix afters removing its first column when constructing bivariate SCOP-splines with double monotonicity (convexity). These result in faster convergence of the optimization routines and more stable intercept estimates.
</p>
<p>Also linear functionals of smooths with shape constraints (increasing/decreasing and convex/concave) are 
supported. See <code>linear.functional.terms</code>. 
</p>


<h3>Author(s)</h3>

<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a>
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. 
Statistical Science, 11(2):89-121
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press
</p>
<p>Wood, S.N. (2006) Low rank scale invariant tensor product smooths for
generalized additive mixed models. Biometrics 62(4):1025-1036
</p>


<h3>See Also</h3>

<p><code>s</code>, <code>smooth.construct.mpi.smooth.spec</code>, 
<code>smooth.construct.mpd.smooth.spec</code>,
</p>
<p><code>smooth.construct.cx.smooth.spec</code>, 
<code>smooth.construct.cv.smooth.spec</code>,
</p>
<p><code>smooth.construct.micx.smooth.spec</code>,
<code>smooth.construct.micv.smooth.spec</code>,
</p>
<p><code>smooth.construct.mdcx.smooth.spec</code>, 
<code>smooth.construct.mdcv.smooth.spec</code>, 
</p>
<p><code>smooth.construct.tedmi.smooth.spec</code>,
<code>smooth.construct.tedmd.smooth.spec</code>,
</p>
<p><code>smooth.construct.tesmi1.smooth.spec</code>, 
<code>smooth.construct.tesmi2.smooth.spec</code>, 
</p>
<p><code>smooth.construct.tesmd1.smooth.spec</code>, 
<code>smooth.construct.tesmd2.smooth.spec</code>,
</p>
<p><code>smooth.construct.tismi.smooth.spec</code>,
<code>smooth.construct.tismd.smooth.spec</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## see examples for scam 
</code></pre>


</div>