<div class="container">

<table style="width: 100%;"><tr>
<td>sk_sub</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Return a sub-grid of a sk grid object</h2>

<h3>Description</h3>

<p>Creates a "sk" object containing only the grid-lines specified in <code>idx_keep</code>. Alternatively,
grid lines to remove can be specified in <code>idx_rem</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sk_sub(g, ij_keep = NULL, ij_rem = NULL, idx = FALSE, mirror = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>sk grid or any grid-like object accepted by <code>sk</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ij_keep</code></td>
<td>
<p>list of grid line numbers ("i" and "j") forming regular sub-grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ij_rem</code></td>
<td>
<p>list of grid line numbers ("i" and "j") whose exclusion forms regular sub-grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>logical, if TRUE the function returns a list containing <code>ij_keep</code> and <code>ij_rem</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mirror</code></td>
<td>
<p>logical, whether to mirror the selection in <code>ij_rem</code> (see details)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One of <code>idx_keep</code> or <code>idx_rem</code> (but not both) can be specified, and the grid line numbers
(not intercepts) should be supplied in ascending order in list entries named "i" and "j".
</p>
<p>If <code>idx_rem</code> is specified, <code>mirror=TRUE</code> will cause the selection in <code>idx_rem</code> to be
reflected about the central grid line (useful for specifying outer grid lines). <code>mirror</code>
is ignored if <code>idx_keep</code> is specified instead.
</p>
<p>Default <code>idx=FALSE</code> causes the function to return the sub-grid as a sk grid object.
If <code>idx=TRUE</code>, the function instead returns a list containing <code>idx_keep</code> and <code>idx_rem</code> as
specified above.
</p>
<p>If neither <code>idx_keep</code> nor <code>idx_rem</code> is supplied, the function removes outer grid lines
iteratively (selecting the one with highest proportion of <code>NA</code>s), attempting to find a
complete sub-grid (having no <code>NA</code>s) somewhere in the interior. This heuristic is designed
for rasters with few <code>NA</code>s, all located around the perimeter.
</p>


<h3>Value</h3>

<p>an sk grid object, the requested sub-grid of <code>g</code>
</p>


<h3>See Also</h3>

<p>Other sk constructors: 
<code>sk_rescale()</code>,
<code>sk_snap()</code>,
<code>sk()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# make an example grid
g = sk(c(50, 100))
g[] = apply(expand.grid(g[['gyx']]), 1, \(z) cos( 2*sum(z^2) ) )
plot(g)

# subset by specifying grid lines to keep
ij_keep = list(i=seq(1, 50, by=2), j=seq(1, 50, by=2))
g_keep = sk_sub(g, ij_keep)
plot(g_keep)

# get the indices kept and removed
idx = sk_sub(g, ij_keep, idx=TRUE)

# equivalent call specifying grid lines to omit
g_rem = sk_sub(g, ij_rem=idx[['rem']])
identical(g_rem, g_keep)

# remove some data around the edges of the grid
idx = sk_sub(g, ij_rem=list(i=seq(10), j=seq(10)), mirror=TRUE, idx=TRUE)
idx_y_pts = sk_sub_idx(dim(g), idx[['rem']]['i'], idx=TRUE)
idx_x_pts = sk_sub_idx(dim(g), idx[['rem']]['j'], idx=TRUE)
idx_pts = c(idx_y_pts, idx_x_pts)
idx_na = sort(sample(idx_pts, 0.6*length(idx_pts)))
g[idx_na] = NA
plot(g)

# identify the interior sub-grid that is complete
g_sub = sk_sub(g)
print(g_sub)
plot(g_sub)

# verify it is as large as expected
( dim(g) - dim(g_sub) ) == sapply(idx[['rem']], length)

</code></pre>


</div>